; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Aircraft\Aircraft.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?acmiSwitch@@3UACMISwitchRecord@@A		; acmiSwitch
PUBLIC	?DOFRec@@3UACMIDOFRecord@@A			; DOFRec
PUBLIC	?gPlayerExitMenuShown@@3HA			; gPlayerExitMenuShown
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?OneSec@@3_NA					; OneSec
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?acmiSwitch@@3UACMISwitchRecord@@A DB 019H DUP (?)	; acmiSwitch
	ALIGN	4

?DOFRec@@3UACMIDOFRecord@@A DB 019H DUP (?)		; DOFRec
	ALIGN	4

?gPlayerExitMenuShown@@3HA DD 01H DUP (?)		; gPlayerExitMenuShown
?OneSec@@3_NA DB 01H DUP (?)				; OneSec
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
_DATA	SEGMENT
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	?IsCampBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsCampBase
PUBLIC	?GetRadarMode@FalconEntity@@UAEHXZ		; FalconEntity::GetRadarMode
PUBLIC	?SetRadarMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetRadarMode
PUBLIC	?ReturnToSearch@FalconEntity@@UAEXXZ		; FalconEntity::ReturnToSearch
PUBLIC	?SetSearchMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetSearchMode
PUBLIC	?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z	; FalconEntity::HasEntity
PUBLIC	?IsMissile@FalconEntity@@UAEHXZ			; FalconEntity::IsMissile
PUBLIC	?IsLauncher@FalconEntity@@UAEHXZ		; FalconEntity::IsLauncher
PUBLIC	?IsBomb@FalconEntity@@UAEHXZ			; FalconEntity::IsBomb
PUBLIC	?IsGun@FalconEntity@@UAEHXZ			; FalconEntity::IsGun
PUBLIC	?IsStatic@FalconEntity@@UAEHXZ			; FalconEntity::IsStatic
PUBLIC	?IsHelicopter@FalconEntity@@UAEHXZ		; FalconEntity::IsHelicopter
PUBLIC	?IsEject@FalconEntity@@UAEHXZ			; FalconEntity::IsEject
PUBLIC	?IsGroundVehicle@FalconEntity@@UAEHXZ		; FalconEntity::IsGroundVehicle
PUBLIC	?IsShip@FalconEntity@@UAEHXZ			; FalconEntity::IsShip
PUBLIC	?IsWeapon@FalconEntity@@UAEHXZ			; FalconEntity::IsWeapon
PUBLIC	?IsDead@FalconEntity@@UAEHXZ			; FalconEntity::IsDead
PUBLIC	?IsEmitting@FalconEntity@@UAEHXZ		; FalconEntity::IsEmitting
PUBLIC	?IsUnit@FalconEntity@@UAEHXZ			; FalconEntity::IsUnit
PUBLIC	?IsObjective@FalconEntity@@UAEHXZ		; FalconEntity::IsObjective
PUBLIC	?IsBattalion@FalconEntity@@UAEHXZ		; FalconEntity::IsBattalion
PUBLIC	?IsBrigade@FalconEntity@@UAEHXZ			; FalconEntity::IsBrigade
PUBLIC	?IsFlight@FalconEntity@@UBEHXZ			; FalconEntity::IsFlight
PUBLIC	?IsSquadron@FalconEntity@@UAEHXZ		; FalconEntity::IsSquadron
PUBLIC	?IsPackage@FalconEntity@@UAEHXZ			; FalconEntity::IsPackage
PUBLIC	?IsTeam@FalconEntity@@UAEHXZ			; FalconEntity::IsTeam
PUBLIC	?IsTaskForce@FalconEntity@@UAEHXZ		; FalconEntity::IsTaskForce
PUBLIC	?SetAQUIREtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetAQUIREtimer
PUBLIC	?SetSEARCHtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetSEARCHtimer
PUBLIC	?SetStepSearchMode@FalconEntity@@UAEXE@Z	; FalconEntity::SetStepSearchMode
PUBLIC	?GetAQUIREtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetAQUIREtimer
PUBLIC	?GetSEARCHtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetSEARCHtimer
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?IsSimBase@SimBaseClass@@UAE_NXZ		; SimBaseClass::IsSimBase
PUBLIC	?GetCountry@SimBaseClass@@UAEEXZ		; SimBaseClass::GetCountry
PUBLIC	?OnGround@SimBaseClass@@UAEHXZ			; SimBaseClass::OnGround
PUBLIC	?IsExploding@SimBaseClass@@UAEHXZ		; SimBaseClass::IsExploding
PUBLIC	?IsDead@SimBaseClass@@UBEHXZ			; SimBaseClass::IsDead
PUBLIC	?IsMover@SimMoverClass@@UAEHXZ			; SimMoverClass::IsMover
PUBLIC	??1InvalidBufferException@@UAE@XZ		; InvalidBufferException::~InvalidBufferException
PUBLIC	??0InvalidBufferException@@QAE@ABV0@@Z		; InvalidBufferException::InvalidBufferException
PUBLIC	??_GInvalidBufferException@@UAEPAXI@Z		; InvalidBufferException::`scalar deleting destructor'
PUBLIC	?memcpychk@@YAXPAXPAPAEIPAJ@Z			; memcpychk
PUBLIC	?IsVehicle@SimVehicleClass@@UAEHXZ		; SimVehicleClass::IsVehicle
PUBLIC	?WeaponKeepAlive@SimVehicleClass@@UAEXXZ	; SimVehicleClass::WeaponKeepAlive
PUBLIC	?MakeAircraftDirty@AircraftClass@@QAEXW4DirtyAircraft@1@W4Dirtyness@@@Z ; AircraftClass::MakeAircraftDirty
PUBLIC	?WriteDirty@AircraftClass@@QAEXPAPAE@Z		; AircraftClass::WriteDirty
PUBLIC	?ReadDirty@AircraftClass@@QAEXPAPAEPAJ@Z	; AircraftClass::ReadDirty
PUBLIC	?SetAcStatusBits@AircraftClass@@QAEXH@Z		; AircraftClass::SetAcStatusBits
PUBLIC	?ClearAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::ClearAcStatusBits
PUBLIC	?AddAVTRSeconds@AircraftClass@@QAEXXZ		; AircraftClass::AddAVTRSeconds
PUBLIC	?SetCockpitWingLight@AircraftClass@@QAEX_N@Z	; AircraftClass::SetCockpitWingLight
PUBLIC	?SetCockpitWingLightFlash@AircraftClass@@QAEX_N@Z ; AircraftClass::SetCockpitWingLightFlash
PUBLIC	?SetCockpitStrobeLight@AircraftClass@@QAEX_N@Z	; AircraftClass::SetCockpitStrobeLight
PUBLIC	?HotPitRefuel@AircraftClass@@QAEXXZ		; AircraftClass::HotPitRefuel
PUBLIC	?GetiffEnabled@AircraftClass@@UAEHXZ		; AircraftClass::GetiffEnabled
PUBLIC	??0AircraftClass@@QAE@HPAPAEPAJ@Z		; AircraftClass::AircraftClass
PUBLIC	??0AircraftClass@@QAE@HPAU_iobuf@@@Z		; AircraftClass::AircraftClass
PUBLIC	??0AircraftClass@@QAE@HH@Z			; AircraftClass::AircraftClass
PUBLIC	??1AircraftClass@@UAE@XZ			; AircraftClass::~AircraftClass
PUBLIC	?InitData@AircraftClass@@UAEXXZ			; AircraftClass::InitData
PUBLIC	?CleanupData@AircraftClass@@UAEXXZ		; AircraftClass::CleanupData
PUBLIC	?InitLocalData@AircraftClass@@AAEXH@Z		; AircraftClass::InitLocalData
PUBLIC	?CleanupLocalData@AircraftClass@@AAEXXZ		; AircraftClass::CleanupLocalData
PUBLIC	?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z ; AircraftClass::Init
PUBLIC	?Exec@AircraftClass@@UAEHXZ			; AircraftClass::Exec
PUBLIC	?CombatClass@AircraftClass@@UAEHXZ		; AircraftClass::CombatClass
PUBLIC	?HomeAirbase@AircraftClass@@QAE?AVVU_ID@@XZ	; AircraftClass::HomeAirbase
PUBLIC	?TakeoffAirbase@AircraftClass@@QAE?AVVU_ID@@XZ	; AircraftClass::TakeoffAirbase
PUBLIC	?LandingAirbase@AircraftClass@@QAE?AVVU_ID@@XZ	; AircraftClass::LandingAirbase
PUBLIC	?DivertAirbase@AircraftClass@@QAE?AVVU_ID@@XZ	; AircraftClass::DivertAirbase
PUBLIC	?SetPowerOutput@AircraftClass@@QAEXM@Z		; AircraftClass::SetPowerOutput
PUBLIC	?ReceiveOrders@AircraftClass@@UAEXPAVFalconEvent@@@Z ; AircraftClass::ReceiveOrders
PUBLIC	?GetFCC@AircraftClass@@UAEPAVFireControlComputer@@XZ ; AircraftClass::GetFCC
PUBLIC	?GetSMS@AircraftClass@@UAEPAVSMSBaseClass@@XZ	; AircraftClass::GetSMS
PUBLIC	?StepSeatArm@AircraftClass@@QAEXXZ		; AircraftClass::StepSeatArm
PUBLIC	?CleanupLitePool@AircraftClass@@QAEXXZ		; AircraftClass::CleanupLitePool
PUBLIC	?PreFlight@AircraftClass@@QAEXXZ		; AircraftClass::PreFlight
PUBLIC	?IncMainPower@AircraftClass@@QAEXXZ		; AircraftClass::IncMainPower
PUBLIC	?DecMainPower@AircraftClass@@QAEXXZ		; AircraftClass::DecMainPower
PUBLIC	?IncEWSPGM@AircraftClass@@QAEXXZ		; AircraftClass::IncEWSPGM
PUBLIC	?DecEWSPGM@AircraftClass@@QAEXXZ		; AircraftClass::DecEWSPGM
PUBLIC	?DecEWSProg@AircraftClass@@QAEXXZ		; AircraftClass::DecEWSProg
PUBLIC	?IncEWSProg@AircraftClass@@QAEXXZ		; AircraftClass::IncEWSProg
PUBLIC	?ToggleBetty@AircraftClass@@QAEXXZ		; AircraftClass::ToggleBetty
PUBLIC	?RunSensors@AircraftClass@@QAEXXZ		; AircraftClass::RunSensors
PUBLIC	?SetCursorCmdsByAnalog@AircraftClass@@QAEXXZ	; AircraftClass::SetCursorCmdsByAnalog
PUBLIC	?SetSpeedBrake@AircraftClass@@QAEXXZ		; AircraftClass::SetSpeedBrake
PUBLIC	?GetJDAMPBTarget@AircraftClass@@QAEHPAV1@@Z	; AircraftClass::GetJDAMPBTarget
PUBLIC	?IsAirplane@AircraftClass@@UAEHXZ		; AircraftClass::IsAirplane
PUBLIC	?Mass@AircraftClass@@UAEMXZ			; AircraftClass::Mass
PUBLIC	?RemovePilot@AircraftClass@@QAEXXZ		; AircraftClass::RemovePilot
PUBLIC	?Eject@AircraftClass@@QAEXXZ			; AircraftClass::Eject
PUBLIC	?HasPilot@AircraftClass@@UAEHXZ			; AircraftClass::HasPilot
PUBLIC	?GetA2GJDAMAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GJDAMAlt
PUBLIC	?GetA2GJSOWAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GJSOWAlt
PUBLIC	?GetA2GHarmAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GHarmAlt
PUBLIC	?GetA2GAGMAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GAGMAlt
PUBLIC	?GetA2GGBUAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GGBUAlt
PUBLIC	?GetA2GDumbHDAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GDumbHDAlt
PUBLIC	?GetA2GClusterAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GClusterAlt
PUBLIC	?GetA2GDumbLDAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GDumbLDAlt
PUBLIC	?GetA2GGenericBombAlt@AircraftClass@@QAEMXZ	; AircraftClass::GetA2GGenericBombAlt
PUBLIC	?GetA2GGunRocketAlt@AircraftClass@@QAEMXZ	; AircraftClass::GetA2GGunRocketAlt
PUBLIC	?GetA2GCameraAlt@AircraftClass@@QAEMXZ		; AircraftClass::GetA2GCameraAlt
PUBLIC	?GetA2GBombMissileAlt@AircraftClass@@QAEMXZ	; AircraftClass::GetA2GBombMissileAlt
PUBLIC	?FindBestSpawnPoint@AircraftClass@@AAEHPAVObjectiveClass@@PAVSimInitDataClass@@@Z ; AircraftClass::FindBestSpawnPoint
PUBLIC	?SetPulseTurbulence@AircraftClass@@QAEXMMMM@Z	; AircraftClass::SetPulseTurbulence
PUBLIC	?GetTurbulence@AircraftClass@@QAE?AUTpoint@@XZ	; AircraftClass::GetTurbulence
PUBLIC	??_GAircraftClass@@UAEPAXI@Z			; AircraftClass::`scalar deleting destructor'
PUBLIC	?RunningInstantAction@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningInstantAction
PUBLIC	?RunningDogfight@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningDogfight
PUBLIC	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_7InvalidBufferException@@6B@			; InvalidBufferException::`vftable'
PUBLIC	??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ ; `string'
PUBLIC	__TI4?AVInvalidBufferException@@
PUBLIC	__CTA4?AVInvalidBufferException@@
PUBLIC	??_R0?AVInvalidBufferException@@@8		; InvalidBufferException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7AircraftClass@@6B@				; AircraftClass::`vftable'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_04ODPAOBIJ@xxxx?$AA@			; `string'
PUBLIC	??_C@_05LOMFCAFC@?5?$DOAGG?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4AircraftClass@@6B@				; AircraftClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAircraftClass@@@8			; AircraftClass `RTTI Type Descriptor'
PUBLIC	??_R3AircraftClass@@8				; AircraftClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AircraftClass@@8				; AircraftClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AircraftClass@@8			; AircraftClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@SimVehicleClass@@8		; SimVehicleClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimVehicleClass@@@8			; SimVehicleClass `RTTI Type Descriptor'
PUBLIC	??_R3SimVehicleClass@@8				; SimVehicleClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimVehicleClass@@8				; SimVehicleClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimMoverClass@@8			; SimMoverClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimMoverClass@@@8			; SimMoverClass `RTTI Type Descriptor'
PUBLIC	??_R3SimMoverClass@@8				; SimMoverClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimMoverClass@@8				; SimMoverClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimBaseClass@@8			; SimBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimBaseClass@@@8			; SimBaseClass `RTTI Type Descriptor'
PUBLIC	??_R3SimBaseClass@@8				; SimBaseClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimBaseClass@@8				; SimBaseClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FalconEntity@@8			; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFalconEntity@@@8			; FalconEntity `RTTI Type Descriptor'
PUBLIC	??_R3FalconEntity@@8				; FalconEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FalconEntity@@8				; FalconEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuEntity@@8			; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuEntity@@@8				; VuEntity `RTTI Type Descriptor'
PUBLIC	??_R3VuEntity@@8				; VuEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuEntity@@8				; VuEntity::`RTTI Base Class Array'
PUBLIC	??_R4InvalidBufferException@@6B@		; InvalidBufferException::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidBufferException@@8			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidBufferException@@8			; InvalidBufferException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidBufferException@@8		; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3727c5ac
PUBLIC	__real@392c987a
PUBLIC	__real@3a83126f
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa34
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e6b851f
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f666666
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae147ae147b
PUBLIC	__real@3f933333
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40900000
PUBLIC	__real@40a00000
PUBLIC	__real@40b00000
PUBLIC	__real@40c00000
PUBLIC	__real@40e00000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41e00000
PUBLIC	__real@41f00000
PUBLIC	__real@4200b53f
PUBLIC	__real@420c0000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@43160000
PUBLIC	__real@43480000
PUBLIC	__real@437a0000
PUBLIC	__real@437f0000
PUBLIC	__real@43a28000
PUBLIC	__real@43bb8000
PUBLIC	__real@43c80000
PUBLIC	__real@43e10000
PUBLIC	__real@43f00000
PUBLIC	__real@43fa0000
PUBLIC	__real@44070000
PUBLIC	__real@447a0000
PUBLIC	__real@44898000
PUBLIC	__real@449c4000
PUBLIC	__real@44bb8000
PUBLIC	__real@45abe000
PUBLIC	__real@45bde1b0
PUBLIC	__real@461c4000
PUBLIC	__real@46fffe00
PUBLIC	__real@477fff00
PUBLIC	__real@4a396e66
PUBLIC	__real@8000000000000000
PUBLIC	__real@bd8f5c29
PUBLIC	__real@be99999a
PUBLIC	__real@becccccd
PUBLIC	__real@bf19999a
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c1200000
PUBLIC	__real@c1a00000
PUBLIC	__real@c1f00000
PUBLIC	__real@c2200000
PUBLIC	__real@c2480000
PUBLIC	__real@c2c80000
PUBLIC	__real@c3160000
PUBLIC	__real@c4fa0000
PUBLIC	__real@c61c4000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_sprintf:PROC
EXTRN	_atan:PROC
EXTRN	_fabs:PROC
EXTRN	_log:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetDelta@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetDelta
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z:PROC ; VuEntity::CustomCollisionCheck
EXTRN	?TerrainCollisionCheck@VuEntity@@UAEEXZ:PROC	; VuEntity::TerrainCollisionCheck
EXTRN	?IsTarget@VuEntity@@UAEEXZ:PROC			; VuEntity::IsTarget
EXTRN	?IsSession@VuEntity@@UAEEXZ:PROC		; VuEntity::IsSession
EXTRN	?IsGroup@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGroup
EXTRN	?IsGame@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGame
EXTRN	?IsCamera@VuEntity@@UBEEXZ:PROC			; VuEntity::IsCamera
EXTRN	?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuEvent@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuEntityCollisionEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuSessionEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Insert
EXTRN	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Remove
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?RemoveCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z:PROC ; VuSessionEntity::RemoveCamera
EXTRN	?GetDomain@FalconEntity@@UAEEXZ:PROC		; FalconEntity::GetDomain
EXTRN	?GetDamageModifiers@FalconEntity@@UAEPAEXZ:PROC	; FalconEntity::GetDamageModifiers
EXTRN	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z:PROC ; FalconEntity::MakeDirty
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z:PROC ; MatrixMult
EXTRN	?GetGroundType@TViewPoint@@QAEHMM@Z:PROC	; TViewPoint::GetGroundType
EXTRN	?UpdatePos@F4SoundPos@@QAEXPAVSimBaseClass@@@Z:PROC ; F4SoundPos::UpdatePos
EXTRN	?Sfx@F4SoundPos@@QAEXHHMM@Z:PROC		; F4SoundPos::Sfx
EXTRN	?SfxRel@F4SoundPos@@QAEXHHMMAAUTpoint@@@Z:PROC	; F4SoundPos::SfxRel
EXTRN	?IsPlaying@F4SoundPos@@QAE_NHH@Z:PROC		; F4SoundPos::IsPlaying
EXTRN	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z:PROC ; DrawableParticleSys::PS_AddParticleEx
EXTRN	?PS_KillTrail@DrawableParticleSys@@SAXK@Z:PROC	; DrawableParticleSys::PS_KillTrail
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?UpdateTargetList@@YAPAVSimObjectType@@PAV1@PAVSimMoverClass@@PAVFalconPrivateOrderedList@@@Z:PROC ; UpdateTargetList
EXTRN	??0PilotInputs@@QAE@XZ:PROC			; PilotInputs::PilotInputs
EXTRN	?SetEEGSData@HudClass@@QAEXMMMMMMMM@Z:PROC	; HudClass::SetEEGSData
EXTRN	?SetLightLevel@HudClass@@QAEXXZ:PROC		; HudClass::SetLightLevel
EXTRN	?SetLocation@WayPointClass@@QAEXMMM@Z:PROC	; WayPointClass::SetLocation
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	??0IrstClass@@QAE@HPAVSimMoverClass@@@Z:PROC	; IrstClass::IrstClass
EXTRN	??0BasicWeaponStation@@QAE@XZ:PROC		; BasicWeaponStation::BasicWeaponStation
EXTRN	??1BasicWeaponStation@@UAE@XZ:PROC		; BasicWeaponStation::~BasicWeaponStation
EXTRN	?CalcRelGeom@@YAXPAVSimBaseClass@@PAVSimObjectType@@QAY02MM@Z:PROC ; CalcRelGeom
EXTRN	?GetTeam@SimBaseClass@@UAEEXZ:PROC		; SimBaseClass::GetTeam
EXTRN	?GetCampID@SimBaseClass@@UAEFXZ:PROC		; SimBaseClass::GetCampID
EXTRN	?GetMovementType@SimBaseClass@@UAE?AW4MoveType@@XZ:PROC ; SimBaseClass::GetMovementType
EXTRN	?IsSPJamming@SimBaseClass@@UAEHXZ:PROC		; SimBaseClass::IsSPJamming
EXTRN	?IsAreaJamming@SimBaseClass@@UAEHXZ:PROC	; SimBaseClass::IsAreaJamming
EXTRN	?SetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::SetFlag
EXTRN	?UnSetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::UnSetFlag
EXTRN	?ApplyDeathMessage@SimBaseClass@@UAEXPAVFalconDeathMessage@@@Z:PROC ; SimBaseClass::ApplyDeathMessage
EXTRN	?GetPilotVoiceId@SimBaseClass@@QAEHXZ:PROC	; SimBaseClass::GetPilotVoiceId
EXTRN	?GetFocusPoint@SimBaseClass@@UAEXAAM00@Z:PROC	; SimBaseClass::GetFocusPoint
EXTRN	?MakeSimBaseDirty@SimBaseClass@@QAEXW4Dirty_Sim_Base@@W4Dirtyness@@@Z:PROC ; SimBaseClass::MakeSimBaseDirty
EXTRN	?MakeComplex@SimMoverClass@@IAEXXZ:PROC		; SimMoverClass::MakeComplex
EXTRN	?GetVt@SimMoverClass@@UBEMXZ:PROC		; SimMoverClass::GetVt
EXTRN	?GetKias@SimMoverClass@@UBEMXZ:PROC		; SimMoverClass::GetKias
EXTRN	?ChangeOwner@SimMoverClass@@UAEXVVU_ID@@@Z:PROC	; SimMoverClass::ChangeOwner
EXTRN	?FeatureCollision@SimMoverClass@@UAEPAVSimBaseClass@@M@Z:PROC ; SimMoverClass::FeatureCollision
EXTRN	?CheckLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z:PROC ; SimMoverClass::CheckLOS
EXTRN	?CheckCompositeLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z:PROC ; SimMoverClass::CheckCompositeLOS
EXTRN	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z:PROC ; SimMoverClass::SetTarget
EXTRN	?RemovalCallback@SimMoverClass@@UAEHXZ:PROC	; SimMoverClass::RemovalCallback
EXTRN	??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z:PROC ; FireControlComputer::FireControlComputer
EXTRN	?SetSms@FireControlComputer@@QAEXPAVSMSClass@@@Z:PROC ; FireControlComputer::SetSms
EXTRN	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z:PROC ; FireControlComputer::SetMasterMode
EXTRN	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z:PROC ; FireControlComputer::SetSubMode
EXTRN	?Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV2@0PAVPilotInputs@@@Z:PROC ; FireControlComputer::Exec
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	??_EInvalidBufferException@@UAEPAXI@Z:PROC	; InvalidBufferException::`vector deleting destructor'
EXTRN	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z:PROC ; ATCBrain::InList
EXTRN	??0DigitalBrain@@QAE@PAVAircraftClass@@PAVAirframeClass@@@Z:PROC ; DigitalBrain::DigitalBrain
EXTRN	?FindDesiredTaxiPoint@DigitalBrain@@QAEHKH@Z:PROC ; DigitalBrain::FindDesiredTaxiPoint
EXTRN	?FindJDAMGroundTarget@DigitalBrain@@QAEHPAVCampBaseClass@@HH@Z:PROC ; DigitalBrain::FindJDAMGroundTarget
EXTRN	??0FACBrain@@QAE@PAVAircraftClass@@PAVAirframeClass@@@Z:PROC ; FACBrain::FACBrain
EXTRN	??0TankerBrain@@QAE@PAVAircraftClass@@PAVAirframeClass@@@Z:PROC ; TankerBrain::TankerBrain
EXTRN	??0RadarDigiClass@@QAE@HPAVSimMoverClass@@@Z:PROC ; RadarDigiClass::RadarDigiClass
EXTRN	??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z:PROC ; RadarAGOnlyClass::RadarAGOnlyClass
EXTRN	??0EyeballClass@@QAE@HPAVSimMoverClass@@@Z:PROC	; EyeballClass::EyeballClass
EXTRN	??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z:PROC ; SMSClass::SMSClass
EXTRN	?EmergencyJettison@SMSClass@@QAEXXZ:PROC	; SMSClass::EmergencyJettison
EXTRN	?SetUnlimitedGuns@SMSClass@@QAEXH@Z:PROC	; SMSClass::SetUnlimitedGuns
EXTRN	?SetUnlimitedAmmo@SMSClass@@QAEXH@Z:PROC	; SMSClass::SetUnlimitedAmmo
EXTRN	?HasWeaponClass@SMSClass@@QAEHW4WeaponClass@@@Z:PROC ; SMSClass::HasWeaponClass
EXTRN	?Exec@SMSClass@@QAEXXZ:PROC			; SMSClass::Exec
EXTRN	?SetPosition@GunClass@@QAEXMMMMM@Z:PROC		; GunClass::SetPosition
EXTRN	?Lookup@LookupTable@@QAEMM@Z:PROC		; LookupTable::Lookup
EXTRN	?TEFTakeoff@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFTakeoff
EXTRN	?LEFTakeoff@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFTakeoff
EXTRN	?QuickEngineStart@AirframeClass@@QAEXXZ:PROC	; AirframeClass::QuickEngineStart
EXTRN	??0AirframeClass@@QAE@PAVAircraftClass@@@Z:PROC	; AirframeClass::AirframeClass
EXTRN	??1AirframeClass@@QAE@XZ:PROC			; AirframeClass::~AirframeClass
EXTRN	?Init@AirframeClass@@QAEXH@Z:PROC		; AirframeClass::Init
EXTRN	?InitData@AirframeClass@@QAEXH@Z:PROC		; AirframeClass::InitData
EXTRN	?Exec@AirframeClass@@QAEXXZ:PROC		; AirframeClass::Exec
EXTRN	?RemoteUpdate@AirframeClass@@QAEXXZ:PROC	; AirframeClass::RemoteUpdate
EXTRN	?AddFuel@AirframeClass@@QAEHM@Z:PROC		; AirframeClass::AddFuel
EXTRN	?SetSimpleMode@AirframeClass@@QAEXH@Z:PROC	; AirframeClass::SetSimpleMode
EXTRN	?GetParkType@AirframeClass@@QAEHXZ:PROC		; AirframeClass::GetParkType
EXTRN	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z:PROC ; SimVehicleClass::SOIManager
EXTRN	??0SimVehicleClass@@QAE@H@Z:PROC		; SimVehicleClass::SimVehicleClass
EXTRN	??0SimVehicleClass@@QAE@PAPAEPAJ@Z:PROC		; SimVehicleClass::SimVehicleClass
EXTRN	??0SimVehicleClass@@QAE@PAU_iobuf@@@Z:PROC	; SimVehicleClass::SimVehicleClass
EXTRN	??1SimVehicleClass@@UAE@XZ:PROC			; SimVehicleClass::~SimVehicleClass
EXTRN	?InitData@SimVehicleClass@@UAEXXZ:PROC		; SimVehicleClass::InitData
EXTRN	?CleanupData@SimVehicleClass@@UAEXXZ:PROC	; SimVehicleClass::CleanupData
EXTRN	?Init@SimVehicleClass@@UAEXPAVSimInitDataClass@@@Z:PROC ; SimVehicleClass::Init
EXTRN	?Exec@SimVehicleClass@@UAEHXZ:PROC		; SimVehicleClass::Exec
EXTRN	?SetDead@SimVehicleClass@@UAEXH@Z:PROC		; SimVehicleClass::SetDead
EXTRN	?GetRCSFactor@SimVehicleClass@@UAEMXZ:PROC	; SimVehicleClass::GetRCSFactor
EXTRN	?GetIRFactor@SimVehicleClass@@UAEMXZ:PROC	; SimVehicleClass::GetIRFactor
EXTRN	?GetRadarType@SimVehicleClass@@UAEHXZ:PROC	; SimVehicleClass::GetRadarType
EXTRN	?SaveSize@SimVehicleClass@@UAEHXZ:PROC		; SimVehicleClass::SaveSize
EXTRN	?Save@SimVehicleClass@@UAEHPAPAE@Z:PROC		; SimVehicleClass::Save
EXTRN	?Save@SimVehicleClass@@UAEHPAU_iobuf@@@Z:PROC	; SimVehicleClass::Save
EXTRN	?Handle@SimVehicleClass@@UAEHPAVVuFullUpdateEvent@@@Z:PROC ; SimVehicleClass::Handle
EXTRN	?Handle@SimVehicleClass@@UAEHPAVVuPositionUpdateEvent@@@Z:PROC ; SimVehicleClass::Handle
EXTRN	?Handle@SimVehicleClass@@UAEHPAVVuTransferEvent@@@Z:PROC ; SimVehicleClass::Handle
EXTRN	?InsertionCallback@SimVehicleClass@@UAEHXZ:PROC	; SimVehicleClass::InsertionCallback
EXTRN	?RunINS@AircraftClass@@QAEXXZ:PROC		; AircraftClass::RunINS
EXTRN	?Wake@AircraftClass@@UAEHXZ:PROC		; AircraftClass::Wake
EXTRN	?JoinFlight@AircraftClass@@UAEXXZ:PROC		; AircraftClass::JoinFlight
EXTRN	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z:PROC ; AircraftClass::SetAutopilot
EXTRN	?GetTotalFuel@AircraftClass@@UAEJXZ:PROC	; AircraftClass::GetTotalFuel
EXTRN	?GetTransform@AircraftClass@@UAEXQAY02M@Z:PROC	; AircraftClass::GetTransform
EXTRN	?ApplyDamage@AircraftClass@@UAEXPAVFalconDamageMessage@@@Z:PROC ; AircraftClass::ApplyDamage
EXTRN	?SetLead@AircraftClass@@UAEXH@Z:PROC		; AircraftClass::SetLead
EXTRN	?GetP@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetP
EXTRN	?GetQ@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetQ
EXTRN	?GetR@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetR
EXTRN	?GetAlpha@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetAlpha
EXTRN	?GetBeta@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetBeta
EXTRN	?GetNx@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetNx
EXTRN	?GetNy@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetNy
EXTRN	?GetNz@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetNz
EXTRN	?GetGamma@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetGamma
EXTRN	?GetSigma@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetSigma
EXTRN	?GetMu@AircraftClass@@UAEMXZ:PROC		; AircraftClass::GetMu
EXTRN	?MakePlayerVehicle@AircraftClass@@UAEXXZ:PROC	; AircraftClass::MakePlayerVehicle
EXTRN	?MakeNonPlayerVehicle@AircraftClass@@UAEXXZ:PROC ; AircraftClass::MakeNonPlayerVehicle
EXTRN	?MakeLocal@AircraftClass@@UAEXXZ:PROC		; AircraftClass::MakeLocal
EXTRN	?MakeRemote@AircraftClass@@UAEXXZ:PROC		; AircraftClass::MakeRemote
EXTRN	?ConfigurePlayerAvionics@AircraftClass@@UAEXXZ:PROC ; AircraftClass::ConfigurePlayerAvionics
EXTRN	?SetVuPosition@AircraftClass@@UAEXXZ:PROC	; AircraftClass::SetVuPosition
EXTRN	?Regenerate@AircraftClass@@UAEXMMMM@Z:PROC	; AircraftClass::Regenerate
EXTRN	?HasSPJamming@AircraftClass@@UAEHXZ:PROC	; AircraftClass::HasSPJamming
EXTRN	?HasAreaJamming@AircraftClass@@UAEHXZ:PROC	; AircraftClass::HasAreaJamming
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?DoElectrics@AircraftClass@@QAEXXZ:PROC		; AircraftClass::DoElectrics
EXTRN	?DoWeapons@AircraftClass@@QAEXXZ:PROC		; AircraftClass::DoWeapons
EXTRN	?GlocPrediction@AircraftClass@@QAEMXZ:PROC	; AircraftClass::GlocPrediction
EXTRN	?DoCountermeasures@AircraftClass@@QAEXXZ:PROC	; AircraftClass::DoCountermeasures
EXTRN	?GatherInputs@AircraftClass@@QAEXXZ:PROC	; AircraftClass::GatherInputs
EXTRN	?GroundFeatureCheck@AircraftClass@@QAEXM@Z:PROC	; AircraftClass::GroundFeatureCheck
EXTRN	?RunExplosion@AircraftClass@@QAEXXZ:PROC	; AircraftClass::RunExplosion
EXTRN	?ShowDamage@AircraftClass@@QAEXXZ:PROC		; AircraftClass::ShowDamage
EXTRN	?MoveSurfaces@AircraftClass@@QAEXXZ:PROC	; AircraftClass::MoveSurfaces
EXTRN	?OnGroundInit@AircraftClass@@QAEXPAVSimInitDataClass@@@Z:PROC ; AircraftClass::OnGroundInit
EXTRN	?CheckObjectCollision@AircraftClass@@QAEXXZ:PROC ; AircraftClass::CheckObjectCollision
EXTRN	?CautionCheck@AircraftClass@@QAEXXZ:PROC	; AircraftClass::CautionCheck
EXTRN	?Sleep@AircraftClass@@UAEHXZ:PROC		; AircraftClass::Sleep
EXTRN	??_EAircraftClass@@UAEPAXI@Z:PROC		; AircraftClass::`vector deleting destructor'
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z:PROC ; OTWDriverClass::InsertObject
EXTRN	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z:PROC ; OTWDriverClass::RemoveObject
EXTRN	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ:PROC ; OTWDriverClass::GetViewpoint
EXTRN	?EndFlight@OTWDriverClass@@QAEXXZ:PROC		; OTWDriverClass::EndFlight
EXTRN	?GetGroundType@OTWDriverClass@@QAEHMM@Z:PROC	; OTWDriverClass::GetGroundType
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?GetTeam@FalconSessionEntity@@QAEEXZ:PROC	; FalconSessionEntity::GetTeam
EXTRN	??0FalconDeathMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconDeathMessage::FalconDeathMessage
EXTRN	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z:PROC ; CampBaseClass::GetComponentIndex
EXTRN	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentEntity
EXTRN	?GetComponentLead@CampBaseClass@@QAEPAVSimBaseClass@@XZ:PROC ; CampBaseClass::GetComponentLead
EXTRN	?NumberOfComponents@CampBaseClass@@QAEHXZ:PROC	; CampBaseClass::NumberOfComponents
EXTRN	?GetFeatureStatus@ObjectiveClass@@QAEHH@Z:PROC	; ObjectiveClass::GetFeatureStatus
EXTRN	?GetFeatureID@ObjectiveClass@@QAEHH@Z:PROC	; ObjectiveClass::GetFeatureID
EXTRN	?GetFeatureOffset@ObjectiveClass@@QAEHHPAM00@Z:PROC ; ObjectiveClass::GetFeatureOffset
EXTRN	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ:PROC ; ObjectiveClass::GetObjectiveClassData
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?AddMflList@FaultClass@@QAEXKW4type_FSubSystem@1@H@Z:PROC ; FaultClass::AddMflList
EXTRN	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::SetFault
EXTRN	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z:PROC ; FackClass::ClearFault
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	??0FackClass@@QAE@XZ:PROC			; FackClass::FackClass
EXTRN	??1FackClass@@QAE@XZ:PROC			; FackClass::~FackClass
EXTRN	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z:PROC ; GetVehicleClassData
EXTRN	??0EjectedPilotClass@@QAE@PAVAircraftClass@@HH@Z:PROC ; EjectedPilotClass::EjectedPilotClass
EXTRN	??0FalconEjectMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconEjectMessage::FalconEjectMessage
EXTRN	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z:PROC		; ACMI_Hash::Add
EXTRN	?AircraftPositionRecord@ACMIRecorder@@QAEXPAUACMIAircraftPositionRecord@@@Z:PROC ; ACMIRecorder::AircraftPositionRecord
EXTRN	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z:PROC ; ACMIRecorder::SwitchRecord
EXTRN	?DeleteMissionTacans@NavigationSystem@@QAEXXZ:PROC ; NavigationSystem::DeleteMissionTacans
EXTRN	??0LaserPodClass@@QAE@HPAVSimMoverClass@@@Z:PROC ; LaserPodClass::LaserPodClass
EXTRN	??0FalconTankerMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconTankerMessage::FalconTankerMessage
EXTRN	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconRadioChatterMessage::FalconRadioChatterMessage
EXTRN	?CreateCallFromAwacs@@YAPAVFalconRadioChatterMessage@@PAVFlightClass@@FPAVVuTargetEntity@@@Z:PROC ; CreateCallFromAwacs
EXTRN	?GetFirstPt@@YAHH@Z:PROC			; GetFirstPt
EXTRN	?GetNextTaxiPt@@YAHH@Z:PROC			; GetNextTaxiPt
EXTRN	?GetPrevTaxiPt@@YAHH@Z:PROC			; GetPrevTaxiPt
EXTRN	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z:PROC ; TranslatePointData
EXTRN	?JoystickPlayEffect@@YAHHH@Z:PROC		; JoystickPlayEffect
EXTRN	??0EasyHarmTargetingPod@@QAE@HPAVSimMoverClass@@@Z:PROC ; EasyHarmTargetingPod::EasyHarmTargetingPod
EXTRN	??0VehRwrClass@@QAE@HPAVSimMoverClass@@@Z:PROC	; VehRwrClass::VehRwrClass
EXTRN	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z:PROC ; DrawableGroundVehicle::DrawableGroundVehicle
EXTRN	?Update@DrawableGroundVehicle@@QAEXPAUTpoint@@M@Z:PROC ; DrawableGroundVehicle::Update
EXTRN	?Exec@LantirnClass@@QAEXPAVAircraftClass@@@Z:PROC ; LantirnClass::Exec
EXTRN	?FindNearestFriendlyRunway@@YAPAVObjectiveClass@@EFF@Z:PROC ; FindNearestFriendlyRunway
EXTRN	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z:PROC	; ConvertSimToGrid
EXTRN	?Register3DAWACSabort@MissionEvaluationClass@@QAEXPAVFlightClass@@@Z:PROC ; MissionEvaluationClass::Register3DAWACSabort
EXTRN	?RecordPosition@AircraftTurbulence@@QAEXMMMM@Z:PROC ; AircraftTurbulence::RecordPosition
EXTRN	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z:PROC ; GetFeatureClassData
EXTRN	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z:PROC ; SIMLIB_IO_CLASS::GetAxisValue
EXTRN	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z:PROC ; FindLaserPod
EXTRN	?ACMIToggleRecording@@YAXKHPAX@Z:PROC		; ACMIToggleRecording
EXTRN	?ResetVoices@@YAXXZ:PROC			; ResetVoices
EXTRN	?RequestSARMission@@YAHPAVFlightClass@@@Z:PROC	; RequestSARMission
EXTRN	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z:PROC ; CalcTransformMatrix
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?SimLibFrameCount@@3IA:DWORD			; SimLibFrameCount
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?PitLightLevel@ColorBankClass@@2HA:DWORD	; ColorBankClass::PitLightLevel
EXTRN	?PtDataTable@@3PAUPtDataType@@A:DWORD		; PtDataTable
EXTRN	?SimACDefTable@@3PAUSimACDefType@@A:DWORD	; SimACDefTable
EXTRN	?DDP@@3PAUDirtyDataClassType@@A:DWORD		; DDP
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?RadarDataTable@@3PAURadarDataType@@A:DWORD	; RadarDataTable
EXTRN	?aeroDataset@@3PAVAeroDataSet@@A:DWORD		; aeroDataset
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?gSfxLOD@@3MA:DWORD				; gSfxLOD
EXTRN	?gACMIRec@@3VACMIRecorder@@A:BYTE		; gACMIRec
EXTRN	?ACMIIDTable@@3PAVACMI_Hash@@A:DWORD		; ACMIIDTable
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
EXTRN	?SimDogfight@@3VDogfightClass@@A:BYTE		; SimDogfight
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?TheTimeOfDay@@3VCTimeOfDay@@A:BYTE		; TheTimeOfDay
EXTRN	?theLantirn@@3PAVLantirnClass@@A:DWORD		; theLantirn
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?g_bDarkHudFix@@3_NA:BYTE			; g_bDarkHudFix
EXTRN	?g_nMPPowerXmitThreshold@@3HA:DWORD		; g_nMPPowerXmitThreshold
EXTRN	?g_bMultiEngineSound@@3_NA:BYTE			; g_bMultiEngineSound
EXTRN	?g_bAllHaveIFF@@3_NA:BYTE			; g_bAllHaveIFF
EXTRN	?g_bINS@@3_NA:BYTE				; g_bINS
EXTRN	?g_bNewEngineSounds@@3_NA:BYTE			; g_bNewEngineSounds
EXTRN	?NumACDefEntries@@3FA:WORD			; NumACDefEntries
EXTRN	?g_fCarrierStartTolerance@@3MA:DWORD		; g_fCarrierStartTolerance
EXTRN	?g_nShowDebugLabels@@3HA:DWORD			; g_nShowDebugLabels
EXTRN	?g_fAIRefuelSpeed@@3MA:DWORD			; g_fAIRefuelSpeed
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
;	COMDAT ?LastMach@?7??Exec@AircraftClass@@UAEHXZ@4MA
_BSS	SEGMENT
?LastMach@?7??Exec@AircraftClass@@UAEHXZ@4MA DD 01H DUP (?) ; `AircraftClass::Exec'::`8'::LastMach
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c61c4000
CONST	SEGMENT
__real@c61c4000 DD 0c61c4000r			; -10000
CONST	ENDS
;	COMDAT __real@c4fa0000
CONST	SEGMENT
__real@c4fa0000 DD 0c4fa0000r			; -2000
CONST	ENDS
;	COMDAT __real@c3160000
CONST	SEGMENT
__real@c3160000 DD 0c3160000r			; -150
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2480000
CONST	SEGMENT
__real@c2480000 DD 0c2480000r			; -50
CONST	ENDS
;	COMDAT __real@c2200000
CONST	SEGMENT
__real@c2200000 DD 0c2200000r			; -40
CONST	ENDS
;	COMDAT __real@c1f00000
CONST	SEGMENT
__real@c1f00000 DD 0c1f00000r			; -30
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf19999a
CONST	SEGMENT
__real@bf19999a DD 0bf19999ar			; -0.6
CONST	ENDS
;	COMDAT __real@becccccd
CONST	SEGMENT
__real@becccccd DD 0becccccdr			; -0.4
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@bd8f5c29
CONST	SEGMENT
__real@bd8f5c29 DD 0bd8f5c29r			; -0.07
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@4a396e66
CONST	SEGMENT
__real@4a396e66 DD 04a396e66r			; 3.03811e+006
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@45abe000
CONST	SEGMENT
__real@45abe000 DD 045abe000r			; 5500
CONST	ENDS
;	COMDAT __real@44bb8000
CONST	SEGMENT
__real@44bb8000 DD 044bb8000r			; 1500
CONST	ENDS
;	COMDAT __real@449c4000
CONST	SEGMENT
__real@449c4000 DD 0449c4000r			; 1250
CONST	ENDS
;	COMDAT __real@44898000
CONST	SEGMENT
__real@44898000 DD 044898000r			; 1100
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44070000
CONST	SEGMENT
__real@44070000 DD 044070000r			; 540
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43f00000
CONST	SEGMENT
__real@43f00000 DD 043f00000r			; 480
CONST	ENDS
;	COMDAT __real@43e10000
CONST	SEGMENT
__real@43e10000 DD 043e10000r			; 450
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43bb8000
CONST	SEGMENT
__real@43bb8000 DD 043bb8000r			; 375
CONST	ENDS
;	COMDAT __real@43a28000
CONST	SEGMENT
__real@43a28000 DD 043a28000r			; 325
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT __real@4200b53f
CONST	SEGMENT
__real@4200b53f DD 04200b53fr			; 32.177
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41e00000
CONST	SEGMENT
__real@41e00000 DD 041e00000r			; 28
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40b00000
CONST	SEGMENT
__real@40b00000 DD 040b00000r			; 5.5
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40900000
CONST	SEGMENT
__real@40900000 DD 040900000r			; 4.5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f933333
CONST	SEGMENT
__real@3f933333 DD 03f933333r			; 1.15
CONST	ENDS
;	COMDAT __real@3f847ae147ae147b
CONST	SEGMENT
__real@3f847ae147ae147b DQ 03f847ae147ae147br	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e6b851f
CONST	SEGMENT
__real@3e6b851f DD 03e6b851fr			; 0.23
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidBufferException@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidBufferException@@8 DD FLAT:??_R0?AVInvalidBufferException@@@8 ; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidBufferException@@8
rdata$r	SEGMENT
??_R2InvalidBufferException@@8 DD FLAT:??_R1A@?0A@EA@InvalidBufferException@@8 ; InvalidBufferException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@out_of_range@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidBufferException@@8
rdata$r	SEGMENT
??_R3InvalidBufferException@@8 DD 00H			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidBufferException@@6B@
rdata$r	SEGMENT
??_R4InvalidBufferException@@6B@ DD 00H			; InvalidBufferException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2VuEntity@@8
rdata$r	SEGMENT
??_R2VuEntity@@8 DD FLAT:??_R1A@?0A@EA@VuEntity@@8	; VuEntity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuEntity@@8
rdata$r	SEGMENT
??_R3VuEntity@@8 DD 00H					; VuEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuEntity@@@8
_DATA	SEGMENT
??_R0?AVVuEntity@@@8 DD FLAT:??_7type_info@@6B@		; VuEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuEntity@@8 DD FLAT:??_R0?AVVuEntity@@@8	; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FalconEntity@@8
rdata$r	SEGMENT
??_R2FalconEntity@@8 DD FLAT:??_R1A@?0A@EA@FalconEntity@@8 ; FalconEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3FalconEntity@@8
rdata$r	SEGMENT
??_R3FalconEntity@@8 DD 00H				; FalconEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFalconEntity@@@8
_DATA	SEGMENT
??_R0?AVFalconEntity@@@8 DD FLAT:??_7type_info@@6B@	; FalconEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFalconEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FalconEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FalconEntity@@8 DD FLAT:??_R0?AVFalconEntity@@@8 ; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2SimBaseClass@@8
rdata$r	SEGMENT
??_R2SimBaseClass@@8 DD FLAT:??_R1A@?0A@EA@SimBaseClass@@8 ; SimBaseClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3SimBaseClass@@8
rdata$r	SEGMENT
??_R3SimBaseClass@@8 DD 00H				; SimBaseClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SimBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimBaseClass@@@8
_DATA	SEGMENT
??_R0?AVSimBaseClass@@@8 DD FLAT:??_7type_info@@6B@	; SimBaseClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimBaseClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SimBaseClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimBaseClass@@8 DD FLAT:??_R0?AVSimBaseClass@@@8 ; SimBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SimMoverClass@@8
rdata$r	SEGMENT
??_R2SimMoverClass@@8 DD FLAT:??_R1A@?0A@EA@SimMoverClass@@8 ; SimMoverClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3SimMoverClass@@8
rdata$r	SEGMENT
??_R3SimMoverClass@@8 DD 00H				; SimMoverClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2SimMoverClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimMoverClass@@@8
_DATA	SEGMENT
??_R0?AVSimMoverClass@@@8 DD FLAT:??_7type_info@@6B@	; SimMoverClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimMoverClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SimMoverClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimMoverClass@@8 DD FLAT:??_R0?AVSimMoverClass@@@8 ; SimMoverClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimMoverClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SimVehicleClass@@8
rdata$r	SEGMENT
??_R2SimVehicleClass@@8 DD FLAT:??_R1A@?0A@EA@SimVehicleClass@@8 ; SimVehicleClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimMoverClass@@8
	DD	FLAT:??_R1A@?0A@EA@SimBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3SimVehicleClass@@8
rdata$r	SEGMENT
??_R3SimVehicleClass@@8 DD 00H				; SimVehicleClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2SimVehicleClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimVehicleClass@@@8
_DATA	SEGMENT
??_R0?AVSimVehicleClass@@@8 DD FLAT:??_7type_info@@6B@	; SimVehicleClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimVehicleClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SimVehicleClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimVehicleClass@@8 DD FLAT:??_R0?AVSimVehicleClass@@@8 ; SimVehicleClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimVehicleClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AircraftClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AircraftClass@@8 DD FLAT:??_R0?AVAircraftClass@@@8 ; AircraftClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AircraftClass@@8
rdata$r	ENDS
;	COMDAT ??_R2AircraftClass@@8
rdata$r	SEGMENT
??_R2AircraftClass@@8 DD FLAT:??_R1A@?0A@EA@AircraftClass@@8 ; AircraftClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimVehicleClass@@8
	DD	FLAT:??_R1A@?0A@EA@SimMoverClass@@8
	DD	FLAT:??_R1A@?0A@EA@SimBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3AircraftClass@@8
rdata$r	SEGMENT
??_R3AircraftClass@@8 DD 00H				; AircraftClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2AircraftClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAircraftClass@@@8
_DATA	SEGMENT
??_R0?AVAircraftClass@@@8 DD FLAT:??_7type_info@@6B@	; AircraftClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAircraftClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4AircraftClass@@6B@
rdata$r	SEGMENT
??_R4AircraftClass@@6B@ DD 00H				; AircraftClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAircraftClass@@@8
	DD	FLAT:??_R3AircraftClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOMFCAFC@?5?$DOAGG?$AA@
CONST	SEGMENT
??_C@_05LOMFCAFC@?5?$DOAGG?$AA@ DB ' >AGG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODPAOBIJ@xxxx?$AA@
CONST	SEGMENT
??_C@_04ODPAOBIJ@xxxx?$AA@ DB 'xxxx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7AircraftClass@@6B@
CONST	SEGMENT
??_7AircraftClass@@6B@ DD FLAT:??_R4AircraftClass@@6B@	; AircraftClass::`vftable'
	DD	FLAT:?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z
	DD	FLAT:?TerrainCollisionCheck@VuEntity@@UAEEXZ
	DD	FLAT:?IsTarget@VuEntity@@UAEEXZ
	DD	FLAT:?IsSession@VuEntity@@UAEEXZ
	DD	FLAT:?IsGroup@VuEntity@@UAEEXZ
	DD	FLAT:?IsGame@VuEntity@@UAEEXZ
	DD	FLAT:?IsCamera@VuEntity@@UBEEXZ
	DD	FLAT:?SaveSize@SimVehicleClass@@UAEHXZ
	DD	FLAT:?Save@SimVehicleClass@@UAEHPAU_iobuf@@@Z
	DD	FLAT:?Save@SimVehicleClass@@UAEHPAPAE@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuSessionEvent@@@Z
	DD	FLAT:?Handle@SimVehicleClass@@UAEHPAVVuTransferEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuEntityCollisionEvent@@@Z
	DD	FLAT:?Handle@SimVehicleClass@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@SimVehicleClass@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z
	DD	FLAT:??_EAircraftClass@@UAEPAXI@Z
	DD	FLAT:?InsertionCallback@SimVehicleClass@@UAEHXZ
	DD	FLAT:?RemovalCallback@SimMoverClass@@UAEHXZ
	DD	FLAT:?InitData@AircraftClass@@UAEXXZ
	DD	FLAT:?CleanupData@AircraftClass@@UAEXXZ
	DD	FLAT:?IsSimBase@SimBaseClass@@UAE_NXZ
	DD	FLAT:?IsCampBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?Wake@AircraftClass@@UAEHXZ
	DD	FLAT:?Sleep@AircraftClass@@UAEHXZ
	DD	FLAT:?GetCampID@SimBaseClass@@UAEFXZ
	DD	FLAT:?GetTeam@SimBaseClass@@UAEEXZ
	DD	FLAT:?GetCountry@SimBaseClass@@UAEEXZ
	DD	FLAT:?GetDomain@FalconEntity@@UAEEXZ
	DD	FLAT:?GetRadarMode@FalconEntity@@UAEHXZ
	DD	FLAT:?SetRadarMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?ReturnToSearch@FalconEntity@@UAEXXZ
	DD	FLAT:?SetSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?CombatClass@AircraftClass@@UAEHXZ
	DD	FLAT:?OnGround@SimBaseClass@@UAEHXZ
	DD	FLAT:?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z
	DD	FLAT:?IsMissile@FalconEntity@@UAEHXZ
	DD	FLAT:?IsLauncher@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBomb@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGun@FalconEntity@@UAEHXZ
	DD	FLAT:?IsMover@SimMoverClass@@UAEHXZ
	DD	FLAT:?IsVehicle@SimVehicleClass@@UAEHXZ
	DD	FLAT:?IsStatic@FalconEntity@@UAEHXZ
	DD	FLAT:?IsHelicopter@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEject@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAirplane@AircraftClass@@UAEHXZ
	DD	FLAT:?IsGroundVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsShip@FalconEntity@@UAEHXZ
	DD	FLAT:?IsWeapon@FalconEntity@@UAEHXZ
	DD	FLAT:?IsExploding@SimBaseClass@@UAEHXZ
	DD	FLAT:?IsDead@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEmitting@FalconEntity@@UAEHXZ
	DD	FLAT:?GetVt@SimMoverClass@@UBEMXZ
	DD	FLAT:?GetKias@SimMoverClass@@UBEMXZ
	DD	FLAT:?GetMovementType@SimBaseClass@@UAE?AW4MoveType@@XZ
	DD	FLAT:?IsUnit@FalconEntity@@UAEHXZ
	DD	FLAT:?IsObjective@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBattalion@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBrigade@FalconEntity@@UAEHXZ
	DD	FLAT:?IsFlight@FalconEntity@@UBEHXZ
	DD	FLAT:?IsSquadron@FalconEntity@@UAEHXZ
	DD	FLAT:?IsPackage@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTeam@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTaskForce@FalconEntity@@UAEHXZ
	DD	FLAT:?IsSPJamming@SimBaseClass@@UAEHXZ
	DD	FLAT:?IsAreaJamming@SimBaseClass@@UAEHXZ
	DD	FLAT:?HasSPJamming@AircraftClass@@UAEHXZ
	DD	FLAT:?HasAreaJamming@AircraftClass@@UAEHXZ
	DD	FLAT:?GetRCSFactor@SimVehicleClass@@UAEMXZ
	DD	FLAT:?GetIRFactor@SimVehicleClass@@UAEMXZ
	DD	FLAT:?GetRadarType@SimVehicleClass@@UAEHXZ
	DD	FLAT:?GetDamageModifiers@FalconEntity@@UAEPAEXZ
	DD	FLAT:?SetAQUIREtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetSEARCHtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetStepSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?GetAQUIREtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?GetSEARCHtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?WeaponKeepAlive@SimVehicleClass@@UAEXXZ
	DD	FLAT:?JoinFlight@AircraftClass@@UAEXXZ
	DD	FLAT:?ChangeOwner@SimMoverClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?MakeLocal@AircraftClass@@UAEXXZ
	DD	FLAT:?MakeRemote@AircraftClass@@UAEXXZ
	DD	FLAT:?IsDead@SimBaseClass@@UBEHXZ
	DD	FLAT:?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z
	DD	FLAT:?Exec@AircraftClass@@UAEHXZ
	DD	FLAT:?GetTransform@AircraftClass@@UAEXQAY02M@Z
	DD	FLAT:?ApplyDamage@AircraftClass@@UAEXPAVFalconDamageMessage@@@Z
	DD	FLAT:?ApplyDeathMessage@SimBaseClass@@UAEXPAVFalconDeathMessage@@@Z
	DD	FLAT:?SetDead@SimVehicleClass@@UAEXH@Z
	DD	FLAT:?MakePlayerVehicle@AircraftClass@@UAEXXZ
	DD	FLAT:?MakeNonPlayerVehicle@AircraftClass@@UAEXXZ
	DD	FLAT:?ConfigurePlayerAvionics@AircraftClass@@UAEXXZ
	DD	FLAT:?SetVuPosition@AircraftClass@@UAEXXZ
	DD	FLAT:?Regenerate@AircraftClass@@UAEXMMMM@Z
	DD	FLAT:?Mass@AircraftClass@@UAEMXZ
	DD	FLAT:?GetFocusPoint@SimBaseClass@@UAEXAAM00@Z
	DD	FLAT:?GetP@AircraftClass@@UAEMXZ
	DD	FLAT:?GetQ@AircraftClass@@UAEMXZ
	DD	FLAT:?GetR@AircraftClass@@UAEMXZ
	DD	FLAT:?GetAlpha@AircraftClass@@UAEMXZ
	DD	FLAT:?GetBeta@AircraftClass@@UAEMXZ
	DD	FLAT:?GetNx@AircraftClass@@UAEMXZ
	DD	FLAT:?GetNy@AircraftClass@@UAEMXZ
	DD	FLAT:?GetNz@AircraftClass@@UAEMXZ
	DD	FLAT:?GetGamma@AircraftClass@@UAEMXZ
	DD	FLAT:?GetSigma@AircraftClass@@UAEMXZ
	DD	FLAT:?GetMu@AircraftClass@@UAEMXZ
	DD	FLAT:?SetLead@AircraftClass@@UAEXH@Z
	DD	FLAT:?FeatureCollision@SimMoverClass@@UAEPAVSimBaseClass@@M@Z
	DD	FLAT:?CheckLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z
	DD	FLAT:?CheckCompositeLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z
	DD	FLAT:?ReceiveOrders@AircraftClass@@UAEXPAVFalconEvent@@@Z
	DD	FLAT:?GetFCC@AircraftClass@@UAEPAVFireControlComputer@@XZ
	DD	FLAT:?GetSMS@AircraftClass@@UAEPAVSMSBaseClass@@XZ
	DD	FLAT:?GetTotalFuel@AircraftClass@@UAEJXZ
	DD	FLAT:?HasPilot@AircraftClass@@UAEHXZ
	DD	FLAT:?GetiffEnabled@AircraftClass@@UAEHXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0InvalidBufferException@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVInvalidBufferException@@@8
_DATA	SEGMENT
??_R0?AVInvalidBufferException@@@8 DD FLAT:??_7type_info@@6B@ ; InvalidBufferException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidBufferException@@', 00H
_DATA	ENDS
;	COMDAT __CTA4?AVInvalidBufferException@@
xdata$x	SEGMENT
__CTA4?AVInvalidBufferException@@ DD 04H
	DD	FLAT:__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVInvalidBufferException@@
xdata$x	SEGMENT
__TI4?AVInvalidBufferException@@ DD 00H
	DD	FLAT:??1InvalidBufferException@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVInvalidBufferException@@
xdata$x	ENDS
;	COMDAT ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
CONST	SEGMENT
??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ DB 'Tryi'
	DB	'ng to write %lu bytes to %ld buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7InvalidBufferException@@6B@
CONST	SEGMENT
??_7InvalidBufferException@@6B@ DD FLAT:??_R4InvalidBufferException@@6B@ ; InvalidBufferException::`vftable'
	DD	FLAT:??_EInvalidBufferException@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??1AircraftClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AircraftClass@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1AircraftClass@@UAE@XZ$1
__unwindtable$??0AircraftClass@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AircraftClass@@QAE@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AircraftClass@@QAE@HH@Z$1
__unwindtable$??0AircraftClass@@QAE@HPAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AircraftClass@@QAE@HPAU_iobuf@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AircraftClass@@QAE@HPAU_iobuf@@@Z$1
__unwindtable$??0AircraftClass@@QAE@HPAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AircraftClass@@QAE@HPAPAEPAJ@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AircraftClass@@QAE@HPAPAEPAJ@Z$1
__unwindtable$?Exec@AircraftClass@@UAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Exec@AircraftClass@@UAEHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Exec@AircraftClass@@UAEHXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Exec@AircraftClass@@UAEHXZ$2
__ehfuncinfo$?Eject@AircraftClass@@QAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Eject@AircraftClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Exec@AircraftClass@@UAEHXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Exec@AircraftClass@@UAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1AircraftClass@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1AircraftClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0AircraftClass@@QAE@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0AircraftClass@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0AircraftClass@@QAE@HPAU_iobuf@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0AircraftClass@@QAE@HPAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0AircraftClass@@QAE@HPAPAEPAJ@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0AircraftClass@@QAE@HPAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Eject@AircraftClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$5
__unwindtable$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0
__ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$6
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale

; 74   : 			{	// construct with specified stamp value

	mov	DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, 0 ; std::numpunct<wchar_t>::id
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale

; 74   : 			{	// construct with specified stamp value

	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale

; 74   : 			{	// construct with specified stamp value

	mov	DWORD PTR ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale

; 74   : 			{	// construct with specified stamp value

	mov	DWORD PTR ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp

; 167  : 		{	// destroy the object

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 162  : 	error_category()

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_System_object

; 163  : 		{	// default constructor
; 164  : 		}
; 165  : 
; 166  : 	virtual ~error_category() _NOEXCEPT
; 167  : 		{	// destroy the object
; 168  : 		}
; 169  : 
; 170  : 	virtual const char *name() const _NOEXCEPT = 0;
; 171  : 
; 172  : 	virtual string message(int _Errval) const = 0;
; 173  : 
; 174  : 	virtual error_condition
; 175  : 		default_error_condition(int _Errval) const _NOEXCEPT;
; 176  : 
; 177  : 	virtual bool equivalent(int _Errval,
; 178  : 		const error_condition& _Cond) const _NOEXCEPT;
; 179  : 
; 180  : 	virtual bool equivalent(const error_code& _Code,
; 181  : 		int _Errval) const _NOEXCEPT;
; 182  : 
; 183  : 	bool operator==(const error_category& _Right) const _NOEXCEPT
; 184  : 		{	// compare categories for equality
; 185  : 		return (this == &_Right);
; 186  : 		}
; 187  : 
; 188  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 189  : 		{	// compare categories for inequality
; 190  : 		return (!(*this == _Right));
; 191  : 		}
; 192  : 
; 193  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 194  : 		{	// compare categories for order
; 195  : 		return (this < &_Right);
; 196  : 		}
; 197  : 
; 198  : private:
; 199  : 	error_category(const error_category&);	// not defined
; 200  : 
; 201  : 	error_category& operator=(const error_category&);	// not defined
; 202  : 	};
; 203  : 
; 204  : 		// CLASS error_code
; 205  : class error_code
; 206  : 	{	// store an implementation-specific error code and category
; 207  : public:
; 208  : 	typedef error_code _Myt;
; 209  : 
; 210  : 	error_code()
; 211  : 		: _Myval(0),
; 212  : 			_Mycat(&system_category())
; 213  : 		{	// construct non-error
; 214  : 		}
; 215  : 
; 216  : 	error_code(int _Val, const error_category& _Cat)
; 217  : 		: _Myval(_Val), _Mycat(&_Cat)
; 218  : 		{	// construct from error code and category
; 219  : 		}
; 220  : 
; 221  : 	template<class _Enum>
; 222  : 		error_code(_Enum _Errcode,
; 223  : 			typename enable_if<is_error_code_enum<_Enum>::value,
; 224  : 				void>::type ** = 0)
; 225  : 		: _Myval(0), _Mycat(0)
; 226  : 		{	// construct from enumerated error code
; 227  : 		*this = make_error_code(_Errcode);	// using ADL
; 228  : 		}
; 229  : 
; 230  : 	void assign(int _Val, const error_category& _Cat)
; 231  : 		{	// assign error code and category
; 232  : 		_Myval = _Val;
; 233  : 		_Mycat = &_Cat;
; 234  : 		}
; 235  : 
; 236  : 	template<class _Enum>
; 237  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 238  : 			error_code>::type& operator=(_Enum _Errcode)
; 239  : 		{	// assign enumerated error code
; 240  : 		*this = make_error_code(_Errcode);	// using ADL
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	void clear() _NOEXCEPT
; 245  : 		{	// assign non-error
; 246  : 		_Myval = 0;
; 247  : 		_Mycat = &system_category();
; 248  : 		}
; 249  : 
; 250  : 	int value() const
; 251  : 		{	// get error code
; 252  : 		return (_Myval);
; 253  : 		}
; 254  : 
; 255  : 	const error_category& category() const
; 256  : 		{	// get category
; 257  : 		return (*_Mycat);
; 258  : 		}
; 259  : 
; 260  : 	error_condition default_error_condition() const;
; 261  : 
; 262  : 	string message() const
; 263  : 		{	// get name of error code
; 264  : 		return (category().message(value()));
; 265  : 		}
; 266  : 
; 267  : 	_TYPEDEF_BOOL_TYPE;
; 268  : 
; 269  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 270  : 		{	// test for actual error
; 271  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 272  : 		}
; 273  : 
; 274  : 	bool operator!() const _NOEXCEPT
; 275  : 		{	// test for actual error
; 276  : 		return (value() == 0);
; 277  : 		}
; 278  : 
; 279  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 280  : 		{	// test if *this == _Right
; 281  : 		return (category() == _Right.category()
; 282  : 			&& value() == _Right.value());
; 283  : 		}
; 284  : 
; 285  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 286  : 		{	// test if *this != _Right
; 287  : 		return (!(*this == _Right));
; 288  : 		}
; 289  : 
; 290  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 291  : 		{	// test if *this == _Right
; 292  : 		return (category() < _Right.category()
; 293  : 			|| category() == _Right.category()
; 294  : 				&& value() < _Right.value());
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	int _Myval;	// the stored error number
; 299  : 	const error_category *_Mycat;	// pointer to error category
; 300  : 	};
; 301  : 
; 302  : 		// CLASS error_condition
; 303  : class error_condition
; 304  : 	{	// store an abstract error code and category
; 305  : public:
; 306  : 	typedef error_condition _Myt;
; 307  : 
; 308  : 	error_condition() _NOEXCEPT
; 309  : 		: _Myval(0),
; 310  : 			_Mycat(&generic_category())
; 311  : 		{	// construct non-error
; 312  : 		}
; 313  : 
; 314  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 315  : 		: _Myval(_Val), _Mycat(&_Cat)
; 316  : 		{	// construct from error code and category
; 317  : 		}
; 318  : 
; 319  : 	template<class _Enum>
; 320  : 		error_condition(_Enum _Errcode,
; 321  : 			typename enable_if<is_error_condition_enum<_Enum>::value,
; 322  : 				void>::type ** = 0) _NOEXCEPT
; 323  : 		: _Myval(0), _Mycat(0)
; 324  : 		{	// construct from enumerated error code
; 325  : 		*this = make_error_condition(_Errcode);	// using ADL
; 326  : 		}
; 327  : 
; 328  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 329  : 		{	// assign error code and category
; 330  : 		_Myval = _Val;
; 331  : 		_Mycat = &_Cat;
; 332  : 		}
; 333  : 
; 334  : 	template<class _Enum>
; 335  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 336  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 337  : 		{	// assign enumerated error code
; 338  : 		*this = make_error_condition(_Errcode);	// using ADL
; 339  : 		return (*this);
; 340  : 		}
; 341  : 
; 342  : 	void clear() _NOEXCEPT
; 343  : 		{	// assign non-error
; 344  : 		_Myval = 0;
; 345  : 		_Mycat = &generic_category();
; 346  : 		}
; 347  : 
; 348  : 	int value() const _NOEXCEPT
; 349  : 		{	// get error code
; 350  : 		return (_Myval);
; 351  : 		}
; 352  : 
; 353  : 	const error_category& category() const _NOEXCEPT
; 354  : 		{	// get category
; 355  : 		return (*_Mycat);
; 356  : 		}
; 357  : 
; 358  : 	string message() const
; 359  : 		{	// get name of error code
; 360  : 		return (category().message(value()));
; 361  : 		}
; 362  : 
; 363  : 	_TYPEDEF_BOOL_TYPE;
; 364  : 
; 365  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 366  : 		{	// test for actual error
; 367  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 368  : 		}
; 369  : 
; 370  : 	bool operator!() const _NOEXCEPT
; 371  : 		{	// test for actual error
; 372  : 		return (value() == 0);
; 373  : 		}
; 374  : 
; 375  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 376  : 		{	// test if *this == _Right
; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());
; 379  : 		}
; 380  : 
; 381  : 	bool operator!=(const error_condition& _Right) const _NOEXCEPT
; 382  : 		{	// test if *this != _Right
; 383  : 		return (!(*this == _Right));
; 384  : 		}
; 385  : 
; 386  : 	bool operator<(const error_condition& _Right) const _NOEXCEPT
; 387  : 		{	// test if *this == _Right
; 388  : 		return (category() < _Right.category()
; 389  : 			|| category() == _Right.category()
; 390  : 				&& value() < _Right.value());
; 391  : 		}
; 392  : 
; 393  : private:
; 394  : 	int _Myval;	// the stored error number
; 395  : 	const error_category *_Mycat;	// pointer to error category
; 396  : 	};
; 397  : 
; 398  : 		// VIRTUALS FOR error_category
; 399  : inline error_condition
; 400  : 	error_category::default_error_condition(int _Errval) const _NOEXCEPT
; 401  : 	{	// make error_condition for error code
; 402  : 	return (error_condition(_Errval, *this));
; 403  : 	}
; 404  : 
; 405  : inline bool
; 406  : 	error_category::equivalent(int _Errval,
; 407  : 		const error_condition& _Cond) const _NOEXCEPT
; 408  : 	{	// test if error code same condition
; 409  : 	return (default_error_condition(_Errval) == _Cond);
; 410  : 	}
; 411  : 
; 412  : inline bool
; 413  : 	error_category::equivalent(const error_code& _Code,
; 414  : 		int _Errval) const _NOEXCEPT
; 415  : 	{	// test if conditions same for this category
; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);
; 417  : 	}
; 418  : 
; 419  : 		// MEMBER FUNCTIONS for error_code
; 420  : inline error_condition error_code::default_error_condition() const
; 421  : 	{	// make error_condition for error code
; 422  : 	return (category().default_error_condition(value()));
; 423  : 	}
; 424  : 
; 425  : 		// OPERATOR== FOR error_code/error_condition
; 426  : inline bool operator==(
; 427  : 	const error_code& _Left,
; 428  : 	const error_condition& _Right) _NOEXCEPT
; 429  : 	{	// test errors for equality
; 430  : 	return (_Left.category().equivalent(_Left.value(), _Right)
; 431  : 		|| _Right.category().equivalent(_Left, _Right.value()));
; 432  : 	}
; 433  : 
; 434  : inline bool operator==(
; 435  : 	const error_condition& _Left,
; 436  : 	const error_code& _Right) _NOEXCEPT
; 437  : 	{	// test errors for equality
; 438  : 	return (_Right.category().equivalent(_Right.value(), _Left)
; 439  : 		|| _Left.category().equivalent(_Right, _Left.value()));
; 440  : 	}
; 441  : 
; 442  : 		// OPERATOR!= FOR error_code/error_condition
; 443  : inline bool operator!=(
; 444  : 	const error_code& _Left,
; 445  : 	const error_condition& _Right) _NOEXCEPT
; 446  : 	{	// test errors for inequality
; 447  : 	return (!(_Left == _Right));
; 448  : 	}
; 449  : 
; 450  : inline bool operator!=(
; 451  : 	const error_condition& _Left,
; 452  : 	const error_code& _Right) _NOEXCEPT
; 453  : 	{	// test errors for inequality
; 454  : 	return (!(_Left == _Right));
; 455  : 	}
; 456  : 
; 457  : 		// FUNCTION make_error_code
; 458  : inline error_code make_error_code(generic_errno _Errno) _NOEXCEPT
; 459  : 	{	// make an error_code
; 460  : 	return (error_code((int)_Errno, generic_category()));
; 461  : 	}
; 462  : 
; 463  : inline error_code make_error_code(_Io_errc _Errno) _NOEXCEPT
; 464  : 	{	// make an error_code
; 465  : 	return (error_code((int)_Errno, iostream_category()));
; 466  : 	}
; 467  : 
; 468  : 		// FUNCTION make_error_condition
; 469  : inline error_condition make_error_condition(generic_errno _Errno) _NOEXCEPT
; 470  : 	{	// make an error_condition
; 471  : 	return (error_condition((int)_Errno, generic_category()));
; 472  : 	}
; 473  : 
; 474  : inline error_condition make_error_condition(_Io_errc _Errno) _NOEXCEPT
; 475  : 	{	// make an error_condition
; 476  : 	return (error_condition((int)_Errno, iostream_category()));
; 477  : 	}
; 478  : 
; 479  : 		// TEMPLATE STRUCT SPECIALIZATION hash
; 480  : template<>
; 481  : 	struct hash<error_code>
; 482  : 		: public unary_function<error_code, size_t>
; 483  : 	{	// hash functor for error_code
; 484  : 	typedef error_code _Kty;
; 485  : 
; 486  : 	size_t operator()(const _Kty& _Keyval) const
; 487  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform
; 488  : 		return (hash<int>()(_Keyval.value()));
; 489  : 		}
; 490  : 	};
; 491  : 
; 492  : 		// CLASS system_error
; 493  : class system_error
; 494  : 	: public runtime_error
; 495  : 	{	// base of all system-error exceptions
; 496  : public:
; 497  : 	explicit system_error(error_code _Errcode)
; 498  : 		: runtime_error(_Errcode.message()),
; 499  : 			_Mycode(_Errcode)
; 500  : 		{	// construct from error code and message string
; 501  : 		_Makestr();
; 502  : 		}
; 503  : 
; 504  : 	system_error(error_code _Errcode,
; 505  : 		const string& _Message)
; 506  : 		: runtime_error(_Message), _Mycode(_Errcode)
; 507  : 		{	// construct from error code and message string
; 508  : 		_Makestr();
; 509  : 		}
; 510  : 
; 511  : 	system_error(int _Errval,
; 512  : 		const error_category& _Errcat)
; 513  : 		: runtime_error(error_code(_Errval, _Errcat).message()),
; 514  : 			_Mycode(_Errval, _Errcat)
; 515  : 		{	// construct from error code components and message string
; 516  : 		_Makestr();
; 517  : 		}
; 518  : 
; 519  : 	system_error(int _Errval,
; 520  : 		const error_category& _Errcat,
; 521  : 		const string& _Message)
; 522  : 		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
; 523  : 		{	// construct from error code components and message string
; 524  : 		_Makestr();
; 525  : 		}
; 526  : 
; 527  : 	system_error(int _Errval,
; 528  : 		const error_category& _Errcat,
; 529  : 		const char *_Message)
; 530  : 		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
; 531  : 		{	// construct from error code components and message string
; 532  : 		_Makestr();
; 533  : 		}
; 534  : 
; 535  : //	virtual ~system_error() _NOEXCEPT
; 536  : //		{	// destroy the object
; 537  : //		}
; 538  : 
; 539  : //	virtual const char *what() const _THROW0()
; 540  : //		{	// return pointer to message string
; 541  : //		return (_Mymes.c_str());
; 542  : //		}
; 543  : 
; 544  : 	const error_code& code() const _THROW0()
; 545  : 		{	// return stored error code
; 546  : 		return (_Mycode);
; 547  : 		}
; 548  : 
; 549  :  #if _HAS_EXCEPTIONS
; 550  : 
; 551  :  #else /* _HAS_EXCEPTIONS */
; 552  : protected:
; 553  : 	virtual void _Doraise() const
; 554  : 		{	// perform class-specific exception handling
; 555  : 		_RAISE(*this);
; 556  : 		}
; 557  :  #endif /* _HAS_EXCEPTIONS */
; 558  : 
; 559  : private:
; 560  : 	void _Makestr()
; 561  : 		{	// compose error message
; 562  : //		_Mymes = this->runtime_error::what();
; 563  : //		if (!_Mymes.empty())
; 564  : //			_Mymes.append(": ");
; 565  : //		_Mymes.append(_Mycode.message());
; 566  : 		}
; 567  : 
; 568  : 	error_code _Mycode;	// the stored error code
; 569  : //	string _Mymes;		// the stored error message
; 570  : 	};
; 571  : 
; 572  : _CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Syserror_map(int);
; 573  : _CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Winerror_map(int);
; 574  : 
; 575  : 		// CLASS _Generic_error_category
; 576  : class _Generic_error_category
; 577  : 	: public error_category
; 578  : 	{	// categorize a generic error
; 579  : public:
; 580  : 	_Generic_error_category()

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_System_object

; 581  : 		{	// default constructor
; 582  : 		}
; 583  : 
; 584  : 	virtual const char *name() const _NOEXCEPT
; 585  : 		{	// get name of category
; 586  : 		return ("generic");
; 587  : 		}
; 588  : 
; 589  : 	virtual string message(int _Errcode) const
; 590  : 		{	// convert to name of error
; 591  : 		const char *_Name = _Syserror_map(_Errcode);
; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));
; 593  : 		}
; 594  : 	};
; 595  : 
; 596  : 		// CLASS _Iostream_error_category
; 597  : class _Iostream_error_category
; 598  : 	: public _Generic_error_category
; 599  : 	{	// categorize a Posix error
; 600  : public:
; 601  : 	_Iostream_error_category()
; 602  : 		{	// default constructor
; 603  : 		}
; 604  : 
; 605  : 	virtual const char *name() const _NOEXCEPT
; 606  : 		{	// get name of category
; 607  : 		return ("iostream");
; 608  : 		}
; 609  : 
; 610  : 	virtual string message(int _Errcode) const
; 611  : 		{	// convert to name of error
; 612  : 		if (_Errcode == (int)io_errc::stream)
; 613  : 			return ("iostream stream error");
; 614  : 		else
; 615  : 			return (_Generic_error_category::message(_Errcode));
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : 		// CLASS _System_error_category
; 620  : class _System_error_category
; 621  : 	: public _Generic_error_category
; 622  : 	{	// categorize a generic error
; 623  : public:
; 624  : 	_System_error_category()

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7_System_error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 627  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp

; 167  : 		{	// destroy the object

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 162  : 	error_category()

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object

; 163  : 		{	// default constructor
; 164  : 		}
; 165  : 
; 166  : 	virtual ~error_category() _NOEXCEPT
; 167  : 		{	// destroy the object
; 168  : 		}
; 169  : 
; 170  : 	virtual const char *name() const _NOEXCEPT = 0;
; 171  : 
; 172  : 	virtual string message(int _Errval) const = 0;
; 173  : 
; 174  : 	virtual error_condition
; 175  : 		default_error_condition(int _Errval) const _NOEXCEPT;
; 176  : 
; 177  : 	virtual bool equivalent(int _Errval,
; 178  : 		const error_condition& _Cond) const _NOEXCEPT;
; 179  : 
; 180  : 	virtual bool equivalent(const error_code& _Code,
; 181  : 		int _Errval) const _NOEXCEPT;
; 182  : 
; 183  : 	bool operator==(const error_category& _Right) const _NOEXCEPT
; 184  : 		{	// compare categories for equality
; 185  : 		return (this == &_Right);
; 186  : 		}
; 187  : 
; 188  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 189  : 		{	// compare categories for inequality
; 190  : 		return (!(*this == _Right));
; 191  : 		}
; 192  : 
; 193  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 194  : 		{	// compare categories for order
; 195  : 		return (this < &_Right);
; 196  : 		}
; 197  : 
; 198  : private:
; 199  : 	error_category(const error_category&);	// not defined
; 200  : 
; 201  : 	error_category& operator=(const error_category&);	// not defined
; 202  : 	};
; 203  : 
; 204  : 		// CLASS error_code
; 205  : class error_code
; 206  : 	{	// store an implementation-specific error code and category
; 207  : public:
; 208  : 	typedef error_code _Myt;
; 209  : 
; 210  : 	error_code()
; 211  : 		: _Myval(0),
; 212  : 			_Mycat(&system_category())
; 213  : 		{	// construct non-error
; 214  : 		}
; 215  : 
; 216  : 	error_code(int _Val, const error_category& _Cat)
; 217  : 		: _Myval(_Val), _Mycat(&_Cat)
; 218  : 		{	// construct from error code and category
; 219  : 		}
; 220  : 
; 221  : 	template<class _Enum>
; 222  : 		error_code(_Enum _Errcode,
; 223  : 			typename enable_if<is_error_code_enum<_Enum>::value,
; 224  : 				void>::type ** = 0)
; 225  : 		: _Myval(0), _Mycat(0)
; 226  : 		{	// construct from enumerated error code
; 227  : 		*this = make_error_code(_Errcode);	// using ADL
; 228  : 		}
; 229  : 
; 230  : 	void assign(int _Val, const error_category& _Cat)
; 231  : 		{	// assign error code and category
; 232  : 		_Myval = _Val;
; 233  : 		_Mycat = &_Cat;
; 234  : 		}
; 235  : 
; 236  : 	template<class _Enum>
; 237  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 238  : 			error_code>::type& operator=(_Enum _Errcode)
; 239  : 		{	// assign enumerated error code
; 240  : 		*this = make_error_code(_Errcode);	// using ADL
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	void clear() _NOEXCEPT
; 245  : 		{	// assign non-error
; 246  : 		_Myval = 0;
; 247  : 		_Mycat = &system_category();
; 248  : 		}
; 249  : 
; 250  : 	int value() const
; 251  : 		{	// get error code
; 252  : 		return (_Myval);
; 253  : 		}
; 254  : 
; 255  : 	const error_category& category() const
; 256  : 		{	// get category
; 257  : 		return (*_Mycat);
; 258  : 		}
; 259  : 
; 260  : 	error_condition default_error_condition() const;
; 261  : 
; 262  : 	string message() const
; 263  : 		{	// get name of error code
; 264  : 		return (category().message(value()));
; 265  : 		}
; 266  : 
; 267  : 	_TYPEDEF_BOOL_TYPE;
; 268  : 
; 269  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 270  : 		{	// test for actual error
; 271  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 272  : 		}
; 273  : 
; 274  : 	bool operator!() const _NOEXCEPT
; 275  : 		{	// test for actual error
; 276  : 		return (value() == 0);
; 277  : 		}
; 278  : 
; 279  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 280  : 		{	// test if *this == _Right
; 281  : 		return (category() == _Right.category()
; 282  : 			&& value() == _Right.value());
; 283  : 		}
; 284  : 
; 285  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 286  : 		{	// test if *this != _Right
; 287  : 		return (!(*this == _Right));
; 288  : 		}
; 289  : 
; 290  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 291  : 		{	// test if *this == _Right
; 292  : 		return (category() < _Right.category()
; 293  : 			|| category() == _Right.category()
; 294  : 				&& value() < _Right.value());
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	int _Myval;	// the stored error number
; 299  : 	const error_category *_Mycat;	// pointer to error category
; 300  : 	};
; 301  : 
; 302  : 		// CLASS error_condition
; 303  : class error_condition
; 304  : 	{	// store an abstract error code and category
; 305  : public:
; 306  : 	typedef error_condition _Myt;
; 307  : 
; 308  : 	error_condition() _NOEXCEPT
; 309  : 		: _Myval(0),
; 310  : 			_Mycat(&generic_category())
; 311  : 		{	// construct non-error
; 312  : 		}
; 313  : 
; 314  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 315  : 		: _Myval(_Val), _Mycat(&_Cat)
; 316  : 		{	// construct from error code and category
; 317  : 		}
; 318  : 
; 319  : 	template<class _Enum>
; 320  : 		error_condition(_Enum _Errcode,
; 321  : 			typename enable_if<is_error_condition_enum<_Enum>::value,
; 322  : 				void>::type ** = 0) _NOEXCEPT
; 323  : 		: _Myval(0), _Mycat(0)
; 324  : 		{	// construct from enumerated error code
; 325  : 		*this = make_error_condition(_Errcode);	// using ADL
; 326  : 		}
; 327  : 
; 328  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 329  : 		{	// assign error code and category
; 330  : 		_Myval = _Val;
; 331  : 		_Mycat = &_Cat;
; 332  : 		}
; 333  : 
; 334  : 	template<class _Enum>
; 335  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 336  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 337  : 		{	// assign enumerated error code
; 338  : 		*this = make_error_condition(_Errcode);	// using ADL
; 339  : 		return (*this);
; 340  : 		}
; 341  : 
; 342  : 	void clear() _NOEXCEPT
; 343  : 		{	// assign non-error
; 344  : 		_Myval = 0;
; 345  : 		_Mycat = &generic_category();
; 346  : 		}
; 347  : 
; 348  : 	int value() const _NOEXCEPT
; 349  : 		{	// get error code
; 350  : 		return (_Myval);
; 351  : 		}
; 352  : 
; 353  : 	const error_category& category() const _NOEXCEPT
; 354  : 		{	// get category
; 355  : 		return (*_Mycat);
; 356  : 		}
; 357  : 
; 358  : 	string message() const
; 359  : 		{	// get name of error code
; 360  : 		return (category().message(value()));
; 361  : 		}
; 362  : 
; 363  : 	_TYPEDEF_BOOL_TYPE;
; 364  : 
; 365  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 366  : 		{	// test for actual error
; 367  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 368  : 		}
; 369  : 
; 370  : 	bool operator!() const _NOEXCEPT
; 371  : 		{	// test for actual error
; 372  : 		return (value() == 0);
; 373  : 		}
; 374  : 
; 375  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 376  : 		{	// test if *this == _Right
; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());
; 379  : 		}
; 380  : 
; 381  : 	bool operator!=(const error_condition& _Right) const _NOEXCEPT
; 382  : 		{	// test if *this != _Right
; 383  : 		return (!(*this == _Right));
; 384  : 		}
; 385  : 
; 386  : 	bool operator<(const error_condition& _Right) const _NOEXCEPT
; 387  : 		{	// test if *this == _Right
; 388  : 		return (category() < _Right.category()
; 389  : 			|| category() == _Right.category()
; 390  : 				&& value() < _Right.value());
; 391  : 		}
; 392  : 
; 393  : private:
; 394  : 	int _Myval;	// the stored error number
; 395  : 	const error_category *_Mycat;	// pointer to error category
; 396  : 	};
; 397  : 
; 398  : 		// VIRTUALS FOR error_category
; 399  : inline error_condition
; 400  : 	error_category::default_error_condition(int _Errval) const _NOEXCEPT
; 401  : 	{	// make error_condition for error code
; 402  : 	return (error_condition(_Errval, *this));
; 403  : 	}
; 404  : 
; 405  : inline bool
; 406  : 	error_category::equivalent(int _Errval,
; 407  : 		const error_condition& _Cond) const _NOEXCEPT
; 408  : 	{	// test if error code same condition
; 409  : 	return (default_error_condition(_Errval) == _Cond);
; 410  : 	}
; 411  : 
; 412  : inline bool
; 413  : 	error_category::equivalent(const error_code& _Code,
; 414  : 		int _Errval) const _NOEXCEPT
; 415  : 	{	// test if conditions same for this category
; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);
; 417  : 	}
; 418  : 
; 419  : 		// MEMBER FUNCTIONS for error_code
; 420  : inline error_condition error_code::default_error_condition() const
; 421  : 	{	// make error_condition for error code
; 422  : 	return (category().default_error_condition(value()));
; 423  : 	}
; 424  : 
; 425  : 		// OPERATOR== FOR error_code/error_condition
; 426  : inline bool operator==(
; 427  : 	const error_code& _Left,
; 428  : 	const error_condition& _Right) _NOEXCEPT
; 429  : 	{	// test errors for equality
; 430  : 	return (_Left.category().equivalent(_Left.value(), _Right)
; 431  : 		|| _Right.category().equivalent(_Left, _Right.value()));
; 432  : 	}
; 433  : 
; 434  : inline bool operator==(
; 435  : 	const error_condition& _Left,
; 436  : 	const error_code& _Right) _NOEXCEPT
; 437  : 	{	// test errors for equality
; 438  : 	return (_Right.category().equivalent(_Right.value(), _Left)
; 439  : 		|| _Left.category().equivalent(_Right, _Left.value()));
; 440  : 	}
; 441  : 
; 442  : 		// OPERATOR!= FOR error_code/error_condition
; 443  : inline bool operator!=(
; 444  : 	const error_code& _Left,
; 445  : 	const error_condition& _Right) _NOEXCEPT
; 446  : 	{	// test errors for inequality
; 447  : 	return (!(_Left == _Right));
; 448  : 	}
; 449  : 
; 450  : inline bool operator!=(
; 451  : 	const error_condition& _Left,
; 452  : 	const error_code& _Right) _NOEXCEPT
; 453  : 	{	// test errors for inequality
; 454  : 	return (!(_Left == _Right));
; 455  : 	}
; 456  : 
; 457  : 		// FUNCTION make_error_code
; 458  : inline error_code make_error_code(generic_errno _Errno) _NOEXCEPT
; 459  : 	{	// make an error_code
; 460  : 	return (error_code((int)_Errno, generic_category()));
; 461  : 	}
; 462  : 
; 463  : inline error_code make_error_code(_Io_errc _Errno) _NOEXCEPT
; 464  : 	{	// make an error_code
; 465  : 	return (error_code((int)_Errno, iostream_category()));
; 466  : 	}
; 467  : 
; 468  : 		// FUNCTION make_error_condition
; 469  : inline error_condition make_error_condition(generic_errno _Errno) _NOEXCEPT
; 470  : 	{	// make an error_condition
; 471  : 	return (error_condition((int)_Errno, generic_category()));
; 472  : 	}
; 473  : 
; 474  : inline error_condition make_error_condition(_Io_errc _Errno) _NOEXCEPT
; 475  : 	{	// make an error_condition
; 476  : 	return (error_condition((int)_Errno, iostream_category()));
; 477  : 	}
; 478  : 
; 479  : 		// TEMPLATE STRUCT SPECIALIZATION hash
; 480  : template<>
; 481  : 	struct hash<error_code>
; 482  : 		: public unary_function<error_code, size_t>
; 483  : 	{	// hash functor for error_code
; 484  : 	typedef error_code _Kty;
; 485  : 
; 486  : 	size_t operator()(const _Kty& _Keyval) const
; 487  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform
; 488  : 		return (hash<int>()(_Keyval.value()));
; 489  : 		}
; 490  : 	};
; 491  : 
; 492  : 		// CLASS system_error
; 493  : class system_error
; 494  : 	: public runtime_error
; 495  : 	{	// base of all system-error exceptions
; 496  : public:
; 497  : 	explicit system_error(error_code _Errcode)
; 498  : 		: runtime_error(_Errcode.message()),
; 499  : 			_Mycode(_Errcode)
; 500  : 		{	// construct from error code and message string
; 501  : 		_Makestr();
; 502  : 		}
; 503  : 
; 504  : 	system_error(error_code _Errcode,
; 505  : 		const string& _Message)
; 506  : 		: runtime_error(_Message), _Mycode(_Errcode)
; 507  : 		{	// construct from error code and message string
; 508  : 		_Makestr();
; 509  : 		}
; 510  : 
; 511  : 	system_error(int _Errval,
; 512  : 		const error_category& _Errcat)
; 513  : 		: runtime_error(error_code(_Errval, _Errcat).message()),
; 514  : 			_Mycode(_Errval, _Errcat)
; 515  : 		{	// construct from error code components and message string
; 516  : 		_Makestr();
; 517  : 		}
; 518  : 
; 519  : 	system_error(int _Errval,
; 520  : 		const error_category& _Errcat,
; 521  : 		const string& _Message)
; 522  : 		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
; 523  : 		{	// construct from error code components and message string
; 524  : 		_Makestr();
; 525  : 		}
; 526  : 
; 527  : 	system_error(int _Errval,
; 528  : 		const error_category& _Errcat,
; 529  : 		const char *_Message)
; 530  : 		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
; 531  : 		{	// construct from error code components and message string
; 532  : 		_Makestr();
; 533  : 		}
; 534  : 
; 535  : //	virtual ~system_error() _NOEXCEPT
; 536  : //		{	// destroy the object
; 537  : //		}
; 538  : 
; 539  : //	virtual const char *what() const _THROW0()
; 540  : //		{	// return pointer to message string
; 541  : //		return (_Mymes.c_str());
; 542  : //		}
; 543  : 
; 544  : 	const error_code& code() const _THROW0()
; 545  : 		{	// return stored error code
; 546  : 		return (_Mycode);
; 547  : 		}
; 548  : 
; 549  :  #if _HAS_EXCEPTIONS
; 550  : 
; 551  :  #else /* _HAS_EXCEPTIONS */
; 552  : protected:
; 553  : 	virtual void _Doraise() const
; 554  : 		{	// perform class-specific exception handling
; 555  : 		_RAISE(*this);
; 556  : 		}
; 557  :  #endif /* _HAS_EXCEPTIONS */
; 558  : 
; 559  : private:
; 560  : 	void _Makestr()
; 561  : 		{	// compose error message
; 562  : //		_Mymes = this->runtime_error::what();
; 563  : //		if (!_Mymes.empty())
; 564  : //			_Mymes.append(": ");
; 565  : //		_Mymes.append(_Mycode.message());
; 566  : 		}
; 567  : 
; 568  : 	error_code _Mycode;	// the stored error code
; 569  : //	string _Mymes;		// the stored error message
; 570  : 	};
; 571  : 
; 572  : _CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Syserror_map(int);
; 573  : _CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Winerror_map(int);
; 574  : 
; 575  : 		// CLASS _Generic_error_category
; 576  : class _Generic_error_category
; 577  : 	: public error_category
; 578  : 	{	// categorize a generic error
; 579  : public:
; 580  : 	_Generic_error_category()

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object

; 581  : 		{	// default constructor
; 582  : 		}
; 583  : 
; 584  : 	virtual const char *name() const _NOEXCEPT
; 585  : 		{	// get name of category
; 586  : 		return ("generic");
; 587  : 		}
; 588  : 
; 589  : 	virtual string message(int _Errcode) const
; 590  : 		{	// convert to name of error
; 591  : 		const char *_Name = _Syserror_map(_Errcode);
; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));
; 593  : 		}
; 594  : 	};
; 595  : 
; 596  : 		// CLASS _Iostream_error_category
; 597  : class _Iostream_error_category
; 598  : 	: public _Generic_error_category
; 599  : 	{	// categorize a Posix error
; 600  : public:
; 601  : 	_Iostream_error_category()

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7_Iostream_error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 627  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp

; 167  : 		{	// destroy the object

	mov	DWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 162  : 	error_category()

	mov	DWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object

; 163  : 		{	// default constructor
; 164  : 		}
; 165  : 
; 166  : 	virtual ~error_category() _NOEXCEPT
; 167  : 		{	// destroy the object
; 168  : 		}
; 169  : 
; 170  : 	virtual const char *name() const _NOEXCEPT = 0;
; 171  : 
; 172  : 	virtual string message(int _Errval) const = 0;
; 173  : 
; 174  : 	virtual error_condition
; 175  : 		default_error_condition(int _Errval) const _NOEXCEPT;
; 176  : 
; 177  : 	virtual bool equivalent(int _Errval,
; 178  : 		const error_condition& _Cond) const _NOEXCEPT;
; 179  : 
; 180  : 	virtual bool equivalent(const error_code& _Code,
; 181  : 		int _Errval) const _NOEXCEPT;
; 182  : 
; 183  : 	bool operator==(const error_category& _Right) const _NOEXCEPT
; 184  : 		{	// compare categories for equality
; 185  : 		return (this == &_Right);
; 186  : 		}
; 187  : 
; 188  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 189  : 		{	// compare categories for inequality
; 190  : 		return (!(*this == _Right));
; 191  : 		}
; 192  : 
; 193  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 194  : 		{	// compare categories for order
; 195  : 		return (this < &_Right);
; 196  : 		}
; 197  : 
; 198  : private:
; 199  : 	error_category(const error_category&);	// not defined
; 200  : 
; 201  : 	error_category& operator=(const error_category&);	// not defined
; 202  : 	};
; 203  : 
; 204  : 		// CLASS error_code
; 205  : class error_code
; 206  : 	{	// store an implementation-specific error code and category
; 207  : public:
; 208  : 	typedef error_code _Myt;
; 209  : 
; 210  : 	error_code()
; 211  : 		: _Myval(0),
; 212  : 			_Mycat(&system_category())
; 213  : 		{	// construct non-error
; 214  : 		}
; 215  : 
; 216  : 	error_code(int _Val, const error_category& _Cat)
; 217  : 		: _Myval(_Val), _Mycat(&_Cat)
; 218  : 		{	// construct from error code and category
; 219  : 		}
; 220  : 
; 221  : 	template<class _Enum>
; 222  : 		error_code(_Enum _Errcode,
; 223  : 			typename enable_if<is_error_code_enum<_Enum>::value,
; 224  : 				void>::type ** = 0)
; 225  : 		: _Myval(0), _Mycat(0)
; 226  : 		{	// construct from enumerated error code
; 227  : 		*this = make_error_code(_Errcode);	// using ADL
; 228  : 		}
; 229  : 
; 230  : 	void assign(int _Val, const error_category& _Cat)
; 231  : 		{	// assign error code and category
; 232  : 		_Myval = _Val;
; 233  : 		_Mycat = &_Cat;
; 234  : 		}
; 235  : 
; 236  : 	template<class _Enum>
; 237  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 238  : 			error_code>::type& operator=(_Enum _Errcode)
; 239  : 		{	// assign enumerated error code
; 240  : 		*this = make_error_code(_Errcode);	// using ADL
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	void clear() _NOEXCEPT
; 245  : 		{	// assign non-error
; 246  : 		_Myval = 0;
; 247  : 		_Mycat = &system_category();
; 248  : 		}
; 249  : 
; 250  : 	int value() const
; 251  : 		{	// get error code
; 252  : 		return (_Myval);
; 253  : 		}
; 254  : 
; 255  : 	const error_category& category() const
; 256  : 		{	// get category
; 257  : 		return (*_Mycat);
; 258  : 		}
; 259  : 
; 260  : 	error_condition default_error_condition() const;
; 261  : 
; 262  : 	string message() const
; 263  : 		{	// get name of error code
; 264  : 		return (category().message(value()));
; 265  : 		}
; 266  : 
; 267  : 	_TYPEDEF_BOOL_TYPE;
; 268  : 
; 269  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 270  : 		{	// test for actual error
; 271  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 272  : 		}
; 273  : 
; 274  : 	bool operator!() const _NOEXCEPT
; 275  : 		{	// test for actual error
; 276  : 		return (value() == 0);
; 277  : 		}
; 278  : 
; 279  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 280  : 		{	// test if *this == _Right
; 281  : 		return (category() == _Right.category()
; 282  : 			&& value() == _Right.value());
; 283  : 		}
; 284  : 
; 285  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 286  : 		{	// test if *this != _Right
; 287  : 		return (!(*this == _Right));
; 288  : 		}
; 289  : 
; 290  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 291  : 		{	// test if *this == _Right
; 292  : 		return (category() < _Right.category()
; 293  : 			|| category() == _Right.category()
; 294  : 				&& value() < _Right.value());
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	int _Myval;	// the stored error number
; 299  : 	const error_category *_Mycat;	// pointer to error category
; 300  : 	};
; 301  : 
; 302  : 		// CLASS error_condition
; 303  : class error_condition
; 304  : 	{	// store an abstract error code and category
; 305  : public:
; 306  : 	typedef error_condition _Myt;
; 307  : 
; 308  : 	error_condition() _NOEXCEPT
; 309  : 		: _Myval(0),
; 310  : 			_Mycat(&generic_category())
; 311  : 		{	// construct non-error
; 312  : 		}
; 313  : 
; 314  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 315  : 		: _Myval(_Val), _Mycat(&_Cat)
; 316  : 		{	// construct from error code and category
; 317  : 		}
; 318  : 
; 319  : 	template<class _Enum>
; 320  : 		error_condition(_Enum _Errcode,
; 321  : 			typename enable_if<is_error_condition_enum<_Enum>::value,
; 322  : 				void>::type ** = 0) _NOEXCEPT
; 323  : 		: _Myval(0), _Mycat(0)
; 324  : 		{	// construct from enumerated error code
; 325  : 		*this = make_error_condition(_Errcode);	// using ADL
; 326  : 		}
; 327  : 
; 328  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 329  : 		{	// assign error code and category
; 330  : 		_Myval = _Val;
; 331  : 		_Mycat = &_Cat;
; 332  : 		}
; 333  : 
; 334  : 	template<class _Enum>
; 335  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 336  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 337  : 		{	// assign enumerated error code
; 338  : 		*this = make_error_condition(_Errcode);	// using ADL
; 339  : 		return (*this);
; 340  : 		}
; 341  : 
; 342  : 	void clear() _NOEXCEPT
; 343  : 		{	// assign non-error
; 344  : 		_Myval = 0;
; 345  : 		_Mycat = &generic_category();
; 346  : 		}
; 347  : 
; 348  : 	int value() const _NOEXCEPT
; 349  : 		{	// get error code
; 350  : 		return (_Myval);
; 351  : 		}
; 352  : 
; 353  : 	const error_category& category() const _NOEXCEPT
; 354  : 		{	// get category
; 355  : 		return (*_Mycat);
; 356  : 		}
; 357  : 
; 358  : 	string message() const
; 359  : 		{	// get name of error code
; 360  : 		return (category().message(value()));
; 361  : 		}
; 362  : 
; 363  : 	_TYPEDEF_BOOL_TYPE;
; 364  : 
; 365  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 366  : 		{	// test for actual error
; 367  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 368  : 		}
; 369  : 
; 370  : 	bool operator!() const _NOEXCEPT
; 371  : 		{	// test for actual error
; 372  : 		return (value() == 0);
; 373  : 		}
; 374  : 
; 375  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 376  : 		{	// test if *this == _Right
; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());
; 379  : 		}
; 380  : 
; 381  : 	bool operator!=(const error_condition& _Right) const _NOEXCEPT
; 382  : 		{	// test if *this != _Right
; 383  : 		return (!(*this == _Right));
; 384  : 		}
; 385  : 
; 386  : 	bool operator<(const error_condition& _Right) const _NOEXCEPT
; 387  : 		{	// test if *this == _Right
; 388  : 		return (category() < _Right.category()
; 389  : 			|| category() == _Right.category()
; 390  : 				&& value() < _Right.value());
; 391  : 		}
; 392  : 
; 393  : private:
; 394  : 	int _Myval;	// the stored error number
; 395  : 	const error_category *_Mycat;	// pointer to error category
; 396  : 	};
; 397  : 
; 398  : 		// VIRTUALS FOR error_category
; 399  : inline error_condition
; 400  : 	error_category::default_error_condition(int _Errval) const _NOEXCEPT
; 401  : 	{	// make error_condition for error code
; 402  : 	return (error_condition(_Errval, *this));
; 403  : 	}
; 404  : 
; 405  : inline bool
; 406  : 	error_category::equivalent(int _Errval,
; 407  : 		const error_condition& _Cond) const _NOEXCEPT
; 408  : 	{	// test if error code same condition
; 409  : 	return (default_error_condition(_Errval) == _Cond);
; 410  : 	}
; 411  : 
; 412  : inline bool
; 413  : 	error_category::equivalent(const error_code& _Code,
; 414  : 		int _Errval) const _NOEXCEPT
; 415  : 	{	// test if conditions same for this category
; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);
; 417  : 	}
; 418  : 
; 419  : 		// MEMBER FUNCTIONS for error_code
; 420  : inline error_condition error_code::default_error_condition() const
; 421  : 	{	// make error_condition for error code
; 422  : 	return (category().default_error_condition(value()));
; 423  : 	}
; 424  : 
; 425  : 		// OPERATOR== FOR error_code/error_condition
; 426  : inline bool operator==(
; 427  : 	const error_code& _Left,
; 428  : 	const error_condition& _Right) _NOEXCEPT
; 429  : 	{	// test errors for equality
; 430  : 	return (_Left.category().equivalent(_Left.value(), _Right)
; 431  : 		|| _Right.category().equivalent(_Left, _Right.value()));
; 432  : 	}
; 433  : 
; 434  : inline bool operator==(
; 435  : 	const error_condition& _Left,
; 436  : 	const error_code& _Right) _NOEXCEPT
; 437  : 	{	// test errors for equality
; 438  : 	return (_Right.category().equivalent(_Right.value(), _Left)
; 439  : 		|| _Left.category().equivalent(_Right, _Left.value()));
; 440  : 	}
; 441  : 
; 442  : 		// OPERATOR!= FOR error_code/error_condition
; 443  : inline bool operator!=(
; 444  : 	const error_code& _Left,
; 445  : 	const error_condition& _Right) _NOEXCEPT
; 446  : 	{	// test errors for inequality
; 447  : 	return (!(_Left == _Right));
; 448  : 	}
; 449  : 
; 450  : inline bool operator!=(
; 451  : 	const error_condition& _Left,
; 452  : 	const error_code& _Right) _NOEXCEPT
; 453  : 	{	// test errors for inequality
; 454  : 	return (!(_Left == _Right));
; 455  : 	}
; 456  : 
; 457  : 		// FUNCTION make_error_code
; 458  : inline error_code make_error_code(generic_errno _Errno) _NOEXCEPT
; 459  : 	{	// make an error_code
; 460  : 	return (error_code((int)_Errno, generic_category()));
; 461  : 	}
; 462  : 
; 463  : inline error_code make_error_code(_Io_errc _Errno) _NOEXCEPT
; 464  : 	{	// make an error_code
; 465  : 	return (error_code((int)_Errno, iostream_category()));
; 466  : 	}
; 467  : 
; 468  : 		// FUNCTION make_error_condition
; 469  : inline error_condition make_error_condition(generic_errno _Errno) _NOEXCEPT
; 470  : 	{	// make an error_condition
; 471  : 	return (error_condition((int)_Errno, generic_category()));
; 472  : 	}
; 473  : 
; 474  : inline error_condition make_error_condition(_Io_errc _Errno) _NOEXCEPT
; 475  : 	{	// make an error_condition
; 476  : 	return (error_condition((int)_Errno, iostream_category()));
; 477  : 	}
; 478  : 
; 479  : 		// TEMPLATE STRUCT SPECIALIZATION hash
; 480  : template<>
; 481  : 	struct hash<error_code>
; 482  : 		: public unary_function<error_code, size_t>
; 483  : 	{	// hash functor for error_code
; 484  : 	typedef error_code _Kty;
; 485  : 
; 486  : 	size_t operator()(const _Kty& _Keyval) const
; 487  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform
; 488  : 		return (hash<int>()(_Keyval.value()));
; 489  : 		}
; 490  : 	};
; 491  : 
; 492  : 		// CLASS system_error
; 493  : class system_error
; 494  : 	: public runtime_error
; 495  : 	{	// base of all system-error exceptions
; 496  : public:
; 497  : 	explicit system_error(error_code _Errcode)
; 498  : 		: runtime_error(_Errcode.message()),
; 499  : 			_Mycode(_Errcode)
; 500  : 		{	// construct from error code and message string
; 501  : 		_Makestr();
; 502  : 		}
; 503  : 
; 504  : 	system_error(error_code _Errcode,
; 505  : 		const string& _Message)
; 506  : 		: runtime_error(_Message), _Mycode(_Errcode)
; 507  : 		{	// construct from error code and message string
; 508  : 		_Makestr();
; 509  : 		}
; 510  : 
; 511  : 	system_error(int _Errval,
; 512  : 		const error_category& _Errcat)
; 513  : 		: runtime_error(error_code(_Errval, _Errcat).message()),
; 514  : 			_Mycode(_Errval, _Errcat)
; 515  : 		{	// construct from error code components and message string
; 516  : 		_Makestr();
; 517  : 		}
; 518  : 
; 519  : 	system_error(int _Errval,
; 520  : 		const error_category& _Errcat,
; 521  : 		const string& _Message)
; 522  : 		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
; 523  : 		{	// construct from error code components and message string
; 524  : 		_Makestr();
; 525  : 		}
; 526  : 
; 527  : 	system_error(int _Errval,
; 528  : 		const error_category& _Errcat,
; 529  : 		const char *_Message)
; 530  : 		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
; 531  : 		{	// construct from error code components and message string
; 532  : 		_Makestr();
; 533  : 		}
; 534  : 
; 535  : //	virtual ~system_error() _NOEXCEPT
; 536  : //		{	// destroy the object
; 537  : //		}
; 538  : 
; 539  : //	virtual const char *what() const _THROW0()
; 540  : //		{	// return pointer to message string
; 541  : //		return (_Mymes.c_str());
; 542  : //		}
; 543  : 
; 544  : 	const error_code& code() const _THROW0()
; 545  : 		{	// return stored error code
; 546  : 		return (_Mycode);
; 547  : 		}
; 548  : 
; 549  :  #if _HAS_EXCEPTIONS
; 550  : 
; 551  :  #else /* _HAS_EXCEPTIONS */
; 552  : protected:
; 553  : 	virtual void _Doraise() const
; 554  : 		{	// perform class-specific exception handling
; 555  : 		_RAISE(*this);
; 556  : 		}
; 557  :  #endif /* _HAS_EXCEPTIONS */
; 558  : 
; 559  : private:
; 560  : 	void _Makestr()
; 561  : 		{	// compose error message
; 562  : //		_Mymes = this->runtime_error::what();
; 563  : //		if (!_Mymes.empty())
; 564  : //			_Mymes.append(": ");
; 565  : //		_Mymes.append(_Mycode.message());
; 566  : 		}
; 567  : 
; 568  : 	error_code _Mycode;	// the stored error code
; 569  : //	string _Mymes;		// the stored error message
; 570  : 	};
; 571  : 
; 572  : _CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Syserror_map(int);
; 573  : _CRTIMP2_PURE const char *__CLRCALL_PURE_OR_CDECL _Winerror_map(int);
; 574  : 
; 575  : 		// CLASS _Generic_error_category
; 576  : class _Generic_error_category
; 577  : 	: public error_category
; 578  : 	{	// categorize a generic error
; 579  : public:
; 580  : 	_Generic_error_category()

	mov	DWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, OFFSET ??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 627  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
_orientation$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_ac$ = 8						; size = 4
_sfxType$ = 12						; size = 4
_pos$ = 16						; size = 4
_vec$ = 20						; size = 4
?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z PROC ; `anonymous namespace'::randomizeBurn

; 1068 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1069 : 		Trotation orientation = static_cast<DrawableBSP*>(ac.drawPointer)->orientation;

	mov	eax, DWORD PTR _ac$[ebp]
	mov	esi, DWORD PTR [eax+332]
	add	esi, 48					; 00000030H
	mov	ecx, 9
	lea	edi, DWORD PTR _orientation$[ebp]
	rep movsd

; 1070 : 		
; 1071 : 		if (ac.burnEffectPosition)

	mov	ecx, DWORD PTR _ac$[ebp]
	movzx	edx, BYTE PTR [ecx+1457]
	test	edx, edx
	je	$LN2@randomizeB
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	eax, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1076 : 			;

	mov	ecx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR _orientation$[ebp]
	mulss	xmm0, DWORD PTR [ecx+1432]
	addss	xmm0, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR _ac$[ebp]
	movss	xmm1, DWORD PTR _orientation$[ebp+4]
	mulss	xmm1, DWORD PTR [edx+1436]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _ac$[ebp]
	movss	xmm1, DWORD PTR _orientation$[ebp+8]
	mulss	xmm1, DWORD PTR [eax+1440]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _pos$[ebp]
	movss	DWORD PTR [ecx], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	edx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1080 : 			;

	mov	eax, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR _orientation$[ebp+12]
	mulss	xmm0, DWORD PTR [eax+1432]
	addss	xmm0, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR _ac$[ebp]
	movss	xmm1, DWORD PTR _orientation$[ebp+16]
	mulss	xmm1, DWORD PTR [ecx+1436]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _ac$[ebp]
	movss	xmm1, DWORD PTR _orientation$[ebp+20]
	mulss	xmm1, DWORD PTR [edx+1440]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _pos$[ebp]
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	ecx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1084 : 			;

	mov	edx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR _orientation$[ebp+24]
	mulss	xmm0, DWORD PTR [edx+1432]
	addss	xmm0, DWORD PTR $T4[ebp]
	mov	eax, DWORD PTR _ac$[ebp]
	movss	xmm1, DWORD PTR _orientation$[ebp+28]
	mulss	xmm1, DWORD PTR [eax+1436]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _ac$[ebp]
	movss	xmm1, DWORD PTR _orientation$[ebp+32]
	mulss	xmm1, DWORD PTR [ecx+1440]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _pos$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 1085 : 		}
; 1086 : 		else 

	jmp	SHORT $LN1@randomizeB
$LN2@randomizeB:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	eax, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1088 : 			pos.x = ac.XPos();

	mov	ecx, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR $T6[ebp]
	movss	DWORD PTR [ecx], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	edx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1089 : 			pos.y = ac.YPos();

	mov	eax, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR $T9[ebp]
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	ecx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1090 : 			pos.z = ac.ZPos();

	mov	edx, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR $T8[ebp]
	movss	DWORD PTR [edx+8], xmm0
$LN1@randomizeB:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	mov	eax, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1093 : 		vec.x = ac.XDelta();

	mov	ecx, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR $T7[ebp]
	movss	DWORD PTR [ecx], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	mov	edx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1094 : 		vec.y = ac.YDelta();

	mov	eax, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR $T5[ebp]
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	mov	ecx, DWORD PTR _ac$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1095 : 		vec.z = ac.ZDelta();

	mov	edx, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR $T3[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 1096 : 
; 1097 : 		DrawableParticleSys::PS_AddParticleEx((sfxType + 1), &pos, &vec);

	mov	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sfxType$[ebp]
	add	edx, 1
	push	edx
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 1098 : 	}

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ENDP ; `anonymous namespace'::randomizeBurn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningDogfight@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv76 = -8						; size = 4
tv84 = -4						; size = 4
?RunningDogfight@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningDogfight, COMDAT
; _this$ = ecx

; 55   : 	bool RunningDogfight() const             { return FalconLocalGame->GetGameType() == game_Dogfight; }

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN9@RunningDog
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN7@RunningDog
$LN9@RunningDog:
	mov	DWORD PTR tv84[ebp], 0
$LN7@RunningDog:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 55   : 	bool RunningDogfight() const             { return FalconLocalGame->GetGameType() == game_Dogfight; }

	movzx	eax, BYTE PTR tv84[ebp]
	test	eax, eax
	je	SHORT $LN3@RunningDog
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T1[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 55   : 	bool RunningDogfight() const             { return FalconLocalGame->GetGameType() == game_Dogfight; }

	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningDog
$LN3@RunningDog:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningDog:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN5@RunningDog
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningDog
$LN5@RunningDog:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningDog:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningDogfight@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningDogfight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningInstantAction@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv76 = -8						; size = 4
tv84 = -4						; size = 4
?RunningInstantAction@SimulationDriver@@QBE_NXZ PROC	; SimulationDriver::RunningInstantAction, COMDAT
; _this$ = ecx

; 53   : 	bool RunningInstantAction() const  { return FalconLocalGame->GetGameType() == game_InstantAction; }

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN9@RunningIns
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN7@RunningIns
$LN9@RunningIns:
	mov	DWORD PTR tv84[ebp], 0
$LN7@RunningIns:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 53   : 	bool RunningInstantAction() const  { return FalconLocalGame->GetGameType() == game_InstantAction; }

	movzx	eax, BYTE PTR tv84[ebp]
	test	eax, eax
	je	SHORT $LN3@RunningIns
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T1[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 53   : 	bool RunningInstantAction() const  { return FalconLocalGame->GetGameType() == game_InstantAction; }

	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningIns
$LN3@RunningIns:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningIns:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	jne	SHORT $LN5@RunningIns
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningIns
$LN5@RunningIns:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningIns:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningInstantAction@SimulationDriver@@QBE_NXZ ENDP	; SimulationDriver::RunningInstantAction
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GAircraftClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAircraftClass@@UAEPAXI@Z PROC			; AircraftClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AircraftClass@@UAE@XZ		; AircraftClass::~AircraftClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAircraftClass@@UAEPAXI@Z ENDP			; AircraftClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTurbulence@AircraftClass@@QAE?AUTpoint@@XZ PROC	; AircraftClass::GetTurbulence
; _this$ = ecx

; 1051 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1052 : 	return TotalTurbulence;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3612				; 00000e1cH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1053 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurbulence@AircraftClass@@QAE?AUTpoint@@XZ ENDP	; AircraftClass::GetTurbulence
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_RateX$ = 8						; size = 4
_RateY$ = 12						; size = 4
_RateZ$ = 16						; size = 4
_Time$ = 20						; size = 4
?SetPulseTurbulence@AircraftClass@@QAEXMMMM@Z PROC	; AircraftClass::SetPulseTurbulence
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1057 : 	PulseTurbulence.x+=RateX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3588]
	addss	xmm0, DWORD PTR _RateX$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+3588], xmm0

; 1058 : 	PulseTurbulence.y+=RateY;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3592]
	addss	xmm0, DWORD PTR _RateY$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+3592], xmm0

; 1059 : 	PulseTurbulence.z+=RateZ;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+3596]
	addss	xmm0, DWORD PTR _RateZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+3596], xmm0

; 1060 : 	if(Time>PulseTurbulenceTime) PulseTurbulenceTime=Time;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Time$[ebp]
	comiss	xmm0, DWORD PTR [eax+3584]
	jbe	SHORT $LN1@SetPulseTu
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Time$[ebp]
	movss	DWORD PTR [ecx+3584], xmm0
$LN1@SetPulseTu:

; 1061 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetPulseTurbulence@AircraftClass@@QAEXMMMM@Z ENDP	; AircraftClass::SetPulseTurbulence
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -64						; size = 8
_pktype$ = -56						; size = 4
_y$2 = -52						; size = 4
_x$3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
_npt$ = -32						; size = 4
$T7 = -28						; size = 4
tv253 = -24						; size = 4
tv206 = -20						; size = 4
_rwindex$ = -16						; size = 4
_info$ = -12						; size = 4
_pt$ = -8						; size = 4
_this$ = -4						; size = 4
_obj$ = 8						; size = 4
_initData$ = 12						; size = 4
?FindBestSpawnPoint@AircraftClass@@AAEHPAVObjectiveClass@@PAVSimInitDataClass@@@Z PROC ; AircraftClass::FindBestSpawnPoint
; _this$ = ecx

; 3255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 3256 : 	int pt = initData->ptIndex;

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _pt$[ebp], ecx

; 3257 : 	int pktype = af->GetParkType();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	mov	DWORD PTR _pktype$[ebp], eax

; 3258 : 	int npt = 0;

	mov	DWORD PTR _npt$[ebp], 0

; 3259 : 	int rwindex = initData->rwIndex;

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _rwindex$[ebp], ecx

; 3260 : 	//ulong takeoffTime;
; 3261 : 	runwayQueueStruct *info = 0;

	mov	DWORD PTR _info$[ebp], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR tv253[ebp], edx
	cmp	DWORD PTR tv253[ebp], 0
	jl	SHORT $LN12@FindBestSp
	cmp	DWORD PTR tv253[ebp], 2
	jle	SHORT $LN11@FindBestSp
	jmp	SHORT $LN12@FindBestSp
$LN11@FindBestSp:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	eax, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR $T7[ebp], eax
	jmp	SHORT $LN14@FindBestSp
$LN12@FindBestSp:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	mov	DWORD PTR $T7[ebp], 0
$LN14@FindBestSp:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3263 : 	if (PlayerOptions.GetStartFlag() == PlayerOptionsClass::START_RUNWAY){

	cmp	DWORD PTR $T7[ebp], 0
	jne	SHORT $LN8@FindBestSp

; 3264 : 		af->vt = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1120], xmm0

; 3265 : 		spawnpoint = initData->ptIndex;	//RAS-11Nov04-store initial spawn point

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+1792], edx

; 3266 : 		return initData->ptIndex;

	mov	eax, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [eax+84]
	jmp	$LN9@FindBestSp
$LN8@FindBestSp:

; 3267 : 	}
; 3268 : 
; 3269 : 	// FRB - CTD's here
; 3270 : 	if (GetNextTaxiPt(initData->ptIndex)== 0 || initData->ptIndex >= -2){ 

	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@FindBestSp
	mov	eax, DWORD PTR _initData$[ebp]
	cmp	DWORD PTR [eax+84], -2			; fffffffeH
	jl	$LN7@FindBestSp
$LN6@FindBestSp:

; 3271 : 		// means were at first point, try and find a parking spot
; 3272 : 		info = 0;

	mov	DWORD PTR _info$[ebp], 0

; 3273 : 		if (obj->brain && initData->campBase->IsUnit()){

	mov	ecx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [ecx+240], 0
	je	SHORT $LN5@FindBestSp
	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	SHORT $LN5@FindBestSp

; 3274 : 			info = obj->brain->InList(initData->campBase->Id());

	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T6[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR $T6[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3274 : 			info = obj->brain->InList(initData->campBase->Id());

	mov	eax, DWORD PTR $T1[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax
$LN5@FindBestSp:

; 3275 : 		}
; 3276 : 		rwindex = 0;

	mov	DWORD PTR _rwindex$[ebp], 0

; 3277 : 		if(info){

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN4@FindBestSp

; 3278 : 			rwindex = info->rwindex;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _rwindex$[ebp], ecx
$LN4@FindBestSp:

; 3279 : 		}
; 3280 : 
; 3281 : 		if (initData->ptIndex < 0){

	mov	edx, DWORD PTR _initData$[ebp]
	cmp	DWORD PTR [edx+84], 0
	jge	SHORT $LN3@FindBestSp

; 3282 : 			pt = GetFirstPt(initData->rwIndex)+1;

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _pt$[ebp], eax
$LN3@FindBestSp:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T5[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T4[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3285 : 		pt = DBrain()->FindDesiredTaxiPoint(waypoint->GetWPDepartureTime(), (int) rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR $T4[ebp]
	call	?FindDesiredTaxiPoint@DigitalBrain@@QAEHKH@Z ; DigitalBrain::FindDesiredTaxiPoint
	mov	DWORD PTR _pt$[ebp], eax

; 3286 : 		if (pt){

	cmp	DWORD PTR _pt$[ebp], 0
	je	$LN2@FindBestSp

; 3287 : 			// found somewhere
; 3288 : 			initData->ptIndex = pt;

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 3289 : 			TranslatePointData(obj, pt, &af->x, &af->y);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	add	eax, 1112				; 00000458H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	add	edx, 1108				; 00000454H
	push	edx
	mov	eax, DWORD PTR _pt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3290 : 			npt = GetPrevTaxiPt(pt); // this is next place to go to

	mov	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _npt$[ebp], eax

; 3291 : 			float x, y;
; 3292 : 			TranslatePointData(obj, npt, &x, &y);

	lea	eax, DWORD PTR _y$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _npt$[ebp]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3293 : 			af->initialPsi = af->psi = af->sigma = (float)atan2 ( (y - af->y), (x - af->x) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR _x$3[ebp]
	subss	xmm0, DWORD PTR [edx+1108]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR _y$2[ebp]
	subss	xmm0, DWORD PTR [ecx+1112]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv206[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR [eax+1176], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR [edx+1168], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR [ecx+1332], xmm0

; 3294 : 			af->initialX = af->groundAnchorX = af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [eax+1108]
	mov	DWORD PTR [edx+112], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx+1316], edx

; 3295 : 			af->initialY = af->groundAnchorY = af->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [ecx+1112]
	mov	DWORD PTR [eax+116], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [eax+116]
	mov	DWORD PTR [edx+1320], eax

; 3296 : 			spawnpoint = pt;	//RAS-11Nov04-store initial spawn point

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [ecx+1792], edx

; 3297 : 			return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	$LN9@FindBestSp
$LN2@FindBestSp:

; 3298 : 		}
; 3299 : 	}
; 3300 : 	else {

	jmp	SHORT $LN1@FindBestSp
$LN7@FindBestSp:

; 3301 : 		PtDataTable[initData->ptIndex].flags |= PT_OCCUPIED;	// 02JAN04 - FRB - Reserve parking spot

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	or	eax, 4
	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [ecx+edx+9], al

; 3302 : 		spawnpoint = initData->ptIndex;	//RAS-11Nov04-store initial spawn point

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR [edx+1792], ecx

; 3303 : 		return initData->ptIndex;

	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+84]
	jmp	SHORT $LN9@FindBestSp
$LN1@FindBestSp:

; 3304 : 	}
; 3305 : 
; 3306 : 	spawnpoint = initData->ptIndex;	//RAS-11Nov04-store initial spawn point

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+1792], edx

; 3307 : 	PtDataTable[initData->ptIndex].flags |= PT_OCCUPIED;	// 02JAN04 - FRB - Reserve parking spot

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	or	eax, 4
	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [ecx+edx+9], al

; 3308 : 	return initData->ptIndex;

	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+84]
$LN9@FindBestSp:

; 3309 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestSpawnPoint@AircraftClass@@AAEHPAVObjectiveClass@@PAVSimInitDataClass@@@Z ENDP ; AircraftClass::FindBestSpawnPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GBombMissileAlt@AircraftClass@@QAEMXZ PROC	; AircraftClass::GetA2GBombMissileAlt
; _this$ = ecx

; 3382 : float AircraftClass::GetA2GBombMissileAlt(void)	{return af->auxaeroData->A2GBombMissileAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3932]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GBombMissileAlt@AircraftClass@@QAEMXZ ENDP	; AircraftClass::GetA2GBombMissileAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GCameraAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GCameraAlt
; _this$ = ecx

; 3381 : float AircraftClass::GetA2GCameraAlt(void)		{return af->auxaeroData->A2GCameraAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3928]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GCameraAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GCameraAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GGunRocketAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GGunRocketAlt
; _this$ = ecx

; 3380 : float AircraftClass::GetA2GGunRocketAlt(void)	{return af->auxaeroData->A2GGunRocketAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3924]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GGunRocketAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GGunRocketAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GGenericBombAlt@AircraftClass@@QAEMXZ PROC	; AircraftClass::GetA2GGenericBombAlt
; _this$ = ecx

; 3379 : float AircraftClass::GetA2GGenericBombAlt(void)		{return af->auxaeroData->A2GGenericBombAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3920]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GGenericBombAlt@AircraftClass@@QAEMXZ ENDP	; AircraftClass::GetA2GGenericBombAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GDumbLDAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GDumbLDAlt
; _this$ = ecx

; 3378 : float AircraftClass::GetA2GDumbLDAlt(void)		{return af->auxaeroData->A2GDumbLDAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3916]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GDumbLDAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GDumbLDAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GClusterAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GClusterAlt
; _this$ = ecx

; 3377 : float AircraftClass::GetA2GClusterAlt(void)		{return af->auxaeroData->A2GClusterAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3912]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GClusterAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GClusterAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GDumbHDAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GDumbHDAlt
; _this$ = ecx

; 3376 : float AircraftClass::GetA2GDumbHDAlt(void)		{return af->auxaeroData->A2GDumbHDAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3908]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GDumbHDAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GDumbHDAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GGBUAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GGBUAlt
; _this$ = ecx

; 3375 : float AircraftClass::GetA2GGBUAlt(void)			{return af->auxaeroData->A2GGBUAlt;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3904]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GGBUAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GGBUAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GAGMAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GAGMAlt
; _this$ = ecx

; 3374 : float AircraftClass::GetA2GAGMAlt(void)			{return af->auxaeroData->A2GAGMAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3900]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GAGMAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GAGMAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GHarmAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GHarmAlt
; _this$ = ecx

; 3373 : float AircraftClass::GetA2GHarmAlt(void)		{return af->auxaeroData->A2GHarmAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3896]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GHarmAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GHarmAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GJSOWAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GJSOWAlt
; _this$ = ecx

; 3372 : float AircraftClass::GetA2GJSOWAlt(void)		{return af->auxaeroData->A2GJSOWAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3892]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GJSOWAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GJSOWAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetA2GJDAMAlt@AircraftClass@@QAEMXZ PROC		; AircraftClass::GetA2GJDAMAlt
; _this$ = ecx

; 3371 : float AircraftClass::GetA2GJDAMAlt(void)		{return af->auxaeroData->A2GJDAMAlt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+3888]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetA2GJDAMAlt@AircraftClass@@QAEMXZ ENDP		; AircraftClass::GetA2GJDAMAlt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?HasPilot@AircraftClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv69 = -8						; size = 4
tv73 = -4						; size = 4
?HasPilot@AircraftClass@@UAEHXZ PROC			; AircraftClass::HasPilot, COMDAT
; _this$ = ecx

; 649  : 	virtual int HasPilot (void) {return (IsAcStatusBitsSet(ACSTATUS_PILOT_EJECTED) ? FALSE : TRUE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, 1
	je	SHORT $LN7@HasPilot
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN5@HasPilot
$LN7@HasPilot:
	mov	DWORD PTR tv73[ebp], 0
$LN5@HasPilot:

; 649  : 	virtual int HasPilot (void) {return (IsAcStatusBitsSet(ACSTATUS_PILOT_EJECTED) ? FALSE : TRUE);};

	movzx	edx, BYTE PTR tv73[ebp]
	test	edx, edx
	je	SHORT $LN3@HasPilot
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@HasPilot
$LN3@HasPilot:
	mov	DWORD PTR tv69[ebp], 1
$LN4@HasPilot:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?HasPilot@AircraftClass@@UAEHXZ ENDP			; AircraftClass::HasPilot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv1422 = -516						; size = 8
tv1409 = -508						; size = 8
$T2 = -500						; size = 4
$T3 = -496						; size = 4
$T4 = -492						; size = 8
$T5 = -484						; size = 4
$T6 = -480						; size = 8
$T7 = -472						; size = 4
$T8 = -468						; size = 8
$T9 = -460						; size = 4
$T10 = -456						; size = 8
$T11 = -448						; size = 4
$T12 = -444						; size = 8
$T13 = -436						; size = 4
$T14 = -432						; size = 8
$T15 = -424						; size = 4
$T16 = -420						; size = 8
$T17 = -412						; size = 4
$T18 = -408						; size = 8
tv1415 = -400						; size = 4
$T19 = -396						; size = 8
_vc$20 = -388						; size = 4
$T21 = -384						; size = 8
$T22 = -376						; size = 4
$T23 = -372						; size = 8
$T24 = -364						; size = 4
$T25 = -360						; size = 8
$T26 = -352						; size = 4
$T27 = -348						; size = 8
$T28 = -340						; size = 4
$T29 = -336						; size = 8
$T30 = -328						; size = 4
$T31 = -324						; size = 8
$T32 = -316						; size = 4
$T33 = -312						; size = 8
$T34 = -304						; size = 4
$T35 = -300						; size = 8
tv1420 = -292						; size = 4
$T36 = -288						; size = 4
tv1600 = -284						; size = 4
$T37 = -280						; size = 4
$T38 = -276						; size = 4
$T39 = -272						; size = 4
$T40 = -268						; size = 4
$T41 = -264						; size = 4
$T42 = -260						; size = 4
$T43 = -256						; size = 4
$T44 = -252						; size = 4
$T45 = -248						; size = 4
$T46 = -244						; size = 4
$T47 = -240						; size = 4
$T48 = -236						; size = 4
$T49 = -232						; size = 4
$T50 = -228						; size = 4
$T51 = -224						; size = 4
$T52 = -220						; size = 4
_radioMessage$53 = -216					; size = 4
tv517 = -212						; size = 4
tv949 = -208						; size = 4
tv229 = -204						; size = 4
$T54 = -200						; size = 4
tv1001 = -196						; size = 4
tv845 = -192						; size = 4
tv138 = -188						; size = 4
tv1117 = -184						; size = 4
tv436 = -180						; size = 4
tv781 = -176						; size = 4
tv240 = -172						; size = 4
$T55 = -168						; size = 4
tv980 = -164						; size = 4
tv770 = -160						; size = 4
tv95 = -156						; size = 4
tv1103 = -152						; size = 4
$T56 = -148						; size = 4
tv1100 = -144						; size = 4
tv362 = -140						; size = 4
tv1093 = -136						; size = 4
tv263 = -132						; size = 4
tv624 = -128						; size = 4
$T57 = -124						; size = 4
tv600 = -120						; size = 4
tv973 = -116						; size = 4
$T58 = -112						; size = 4
tv161 = -108						; size = 4
tv589 = -104						; size = 4
$T59 = -100						; size = 4
tv1030 = -96						; size = 4
tv1405 = -92						; size = 4
tv856 = -88						; size = 4
_lh$60 = -84						; size = 4
$T61 = -78						; size = 2
_lh$62 = -76						; size = 4
$T63 = -72						; size = 2
$T64 = -70						; size = 2
$T65 = -68						; size = 2
$T66 = -66						; size = 2
_pilotno$67 = -64					; size = 4
tv1417 = -58						; size = 2
_i$ = -56						; size = 4
$T68 = -49						; size = 1
_sender$69 = -48					; size = 4
$T70 = -43						; size = 1
$T71 = -42						; size = 1
$T72 = -41						; size = 1
_lastToHit$ = -40					; size = 4
_epc$ = -36						; size = 4
tv1088 = -32						; size = 1
tv976 = -31						; size = 1
tv1089 = -30						; size = 1
tv975 = -29						; size = 1
_ejectMessage$ = -28					; size = 4
_msg$73 = -24						; size = 4
_deathMessage$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Eject@AircraftClass@@QAEXXZ PROC			; AircraftClass::Eject
; _this$ = ecx

; 2576 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Eject@AircraftClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 504				; 000001f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+136]
	and	ecx, 8
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2583 : 	if (IsSetFalcFlag(FEC_REGENERATING)){

	je	$LN18@Eject

; 2586 : 		ejectMessage=new FalconEjectMessage(Id(), FalconLocalGame);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T59[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T59[ebp], 0
	je	$LN23@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN53@Eject
	mov	DWORD PTR tv949[ebp], 1
	jmp	SHORT $LN54@Eject
$LN53@Eject:
	mov	DWORD PTR tv949[ebp], 0
$LN54@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2586 : 		ejectMessage=new FalconEjectMessage(Id(), FalconLocalGame);

	movzx	edx, BYTE PTR tv949[ebp]
	test	edx, edx
	je	SHORT $LN21@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T40[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T40[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2586 : 		ejectMessage=new FalconEjectMessage(Id(), FalconLocalGame);

	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN22@Eject
$LN21@Eject:
	mov	DWORD PTR tv95[ebp], 0
$LN22@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T35[ebp], edx
	mov	DWORD PTR $T35[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2586 : 		ejectMessage=new FalconEjectMessage(Id(), FalconLocalGame);

	push	1
	mov	ecx, DWORD PTR tv95[ebp]
	push	ecx
	mov	edx, DWORD PTR $T35[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T35[ebp]
	push	eax
	mov	ecx, DWORD PTR $T59[ebp]
	call	??0FalconEjectMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconEjectMessage::FalconEjectMessage
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN24@Eject
$LN23@Eject:
	mov	DWORD PTR tv138[ebp], 0
$LN24@Eject:
	mov	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR $T50[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T50[ebp]
	mov	DWORD PTR _ejectMessage$[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T33[ebp], ecx
	mov	DWORD PTR $T33[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2588 : 		ejectMessage->dataBlock.ePlaneID		= Id();

	mov	eax, DWORD PTR $T33[ebp]
	mov	ecx, DWORD PTR $T33[ebp+4]
	mov	edx, DWORD PTR _ejectMessage$[ebp]
	mov	DWORD PTR [edx+48], eax
	mov	DWORD PTR [edx+52], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T13[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2589 : 		ejectMessage->dataBlock.eCampID			= ((CampBaseClass*)GetCampaignObject())->GetCampID();

	mov	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR tv161[ebp], edx
	mov	eax, DWORD PTR tv161[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv161[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	WORD PTR [ecx+64], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T48[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR $T48[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T31[ebp], edx
	mov	DWORD PTR $T31[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2590 : 		ejectMessage->dataBlock.eFlightID		= GetCampaignObject()->Id();

	mov	ecx, DWORD PTR $T31[ebp]
	mov	edx, DWORD PTR $T31[ebp+4]
	mov	eax, DWORD PTR _ejectMessage$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], edx

; 2591 : 		ejectMessage->dataBlock.ePilotID		= pilotSlot;

	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+665]
	mov	BYTE PTR [ecx+66], al
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 262  : 	VU_ID LastShooter (void) { return lastShooter; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR $T29[ebp], edx
	mov	DWORD PTR $T29[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 116  : 		); 

	mov	ecx, DWORD PTR $T29[ebp]
	cmp	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	jne	SHORT $LN79@Eject

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	edx, DWORD PTR $T29[ebp+4]
	cmp	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	jne	SHORT $LN83@Eject
	mov	DWORD PTR tv980[ebp], 1
	jmp	SHORT $LN84@Eject
$LN83@Eject:
	mov	DWORD PTR tv980[ebp], 0
$LN84@Eject:

; 116  : 		); 

	cmp	DWORD PTR tv980[ebp], 0
	je	SHORT $LN77@Eject
	mov	BYTE PTR tv975[ebp], 0
	jmp	SHORT $LN78@Eject
$LN77@Eject:
	mov	BYTE PTR tv975[ebp], 1
$LN78@Eject:
	mov	al, BYTE PTR tv975[ebp]
	mov	BYTE PTR tv976[ebp], al
	jmp	SHORT $LN80@Eject
$LN79@Eject:
	mov	BYTE PTR tv976[ebp], 1
$LN80@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2592 : 		ejectMessage->dataBlock.hadLastShooter	= (uchar)(LastShooter() != FalconNullId);

	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	dl, BYTE PTR tv976[ebp]
	mov	BYTE PTR [ecx+67], dl

; 2593 : 		FalconSendMessage(ejectMessage, TRUE);

	push	1
	mov	eax, DWORD PTR _ejectMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 2595 : 		deathMessage = new FalconDeathMessage (Id(), FalconLocalGame);

	push	94					; 0000005eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T57[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T57[ebp], 0
	je	$LN27@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN87@Eject
	mov	DWORD PTR tv973[ebp], 1
	jmp	SHORT $LN88@Eject
$LN87@Eject:
	mov	DWORD PTR tv973[ebp], 0
$LN88@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2595 : 		deathMessage = new FalconDeathMessage (Id(), FalconLocalGame);

	movzx	ecx, BYTE PTR tv973[ebp]
	test	ecx, ecx
	je	SHORT $LN25@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T24[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T24[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2595 : 		deathMessage = new FalconDeathMessage (Id(), FalconLocalGame);

	mov	DWORD PTR tv229[ebp], eax
	jmp	SHORT $LN26@Eject
$LN25@Eject:
	mov	DWORD PTR tv229[ebp], 0
$LN26@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T27[ebp], ecx
	mov	DWORD PTR $T27[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2595 : 		deathMessage = new FalconDeathMessage (Id(), FalconLocalGame);

	push	1
	mov	eax, DWORD PTR tv229[ebp]
	push	eax
	mov	ecx, DWORD PTR $T27[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T27[ebp]
	push	edx
	mov	ecx, DWORD PTR $T57[ebp]
	call	??0FalconDeathMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconDeathMessage::FalconDeathMessage
	mov	DWORD PTR tv240[ebp], eax
	jmp	SHORT $LN28@Eject
$LN27@Eject:
	mov	DWORD PTR tv240[ebp], 0
$LN28@Eject:
	mov	eax, DWORD PTR tv240[ebp]
	mov	DWORD PTR $T46[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T46[ebp]
	mov	DWORD PTR _deathMessage$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR $T25[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2596 : 		deathMessage->dataBlock.dEntityID			= Id();

	mov	edx, DWORD PTR $T25[ebp]
	mov	eax, DWORD PTR $T25[ebp+4]
	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	DWORD PTR [ecx+56], edx
	mov	DWORD PTR [ecx+60], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T3[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2597 : 		deathMessage->dataBlock.dCampID				= ((CampBaseClass*)GetCampaignObject())->GetCampID();

	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv263[ebp], ecx
	mov	edx, DWORD PTR tv263[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv263[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	WORD PTR [ecx+64], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T44[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	mov	ecx, DWORD PTR $T44[ebp]
	mov	dl, BYTE PTR [ecx+154]
	mov	BYTE PTR $T70[ebp], dl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2598 : 		deathMessage->dataBlock.dSide				= ((CampBaseClass*)GetCampaignObject())->GetOwner();

	mov	eax, DWORD PTR _deathMessage$[ebp]
	mov	cl, BYTE PTR $T70[ebp]
	mov	BYTE PTR [eax+69], cl

; 2599 : 		deathMessage->dataBlock.dPilotID			= pilotSlot;

	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+665]
	mov	BYTE PTR [edx+66], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR $T63[ebp], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2600 : 		deathMessage->dataBlock.dIndex				= Type();

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	dx, WORD PTR $T63[ebp]
	mov	WORD PTR [ecx+67], dx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR $T64[ebp], cx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2601 : 		deathMessage->dataBlock.fWeaponID			= Type();

	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	ax, WORD PTR $T64[ebp]
	mov	WORD PTR [edx+84], ax

; 2602 : 		deathMessage->dataBlock.fWeaponUID			= FalconNullId;

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+86], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+90], eax

; 2603 : 		deathMessage->dataBlock.deathPctStrength	= pctStrength;

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	mov	DWORD PTR [ecx+52], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 262  : 	VU_ID LastShooter (void) { return lastShooter; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR $T23[ebp], edx
	mov	DWORD PTR $T23[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2605 : 		lastToHit = (SimVehicleClass*)vuDatabase->Find(LastShooter());

	mov	ecx, DWORD PTR $T23[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T23[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _lastToHit$[ebp], eax

; 2606 : 		if (lastToHit && !lastToHit->IsEject()){

	cmp	DWORD PTR _lastToHit$[ebp], 0
	je	$LN17@Eject
	mov	eax, DWORD PTR _lastToHit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _lastToHit$[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	test	eax, eax
	jne	$LN17@Eject

; 2607 : 			deathMessage->dataBlock.damageType		= FalconDamageType::OtherDamage;

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	DWORD PTR [ecx+48], 10			; 0000000aH
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	mov	edx, DWORD PTR _lastToHit$[ebp]
	movsx	eax, BYTE PTR [edx+137]
	and	eax, 2
	je	SHORT $LN115@Eject
	mov	DWORD PTR tv1001[ebp], 1
	jmp	SHORT $LN116@Eject
$LN115@Eject:
	mov	DWORD PTR tv1001[ebp], 0
$LN116@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2608 : 			if (lastToHit->IsSim()){

	cmp	DWORD PTR tv1001[ebp], 0
	je	SHORT $LN16@Eject

; 2609 : 				SimVehicleClass *lh = static_cast<SimVehicleClass*>(lastToHit);

	mov	ecx, DWORD PTR _lastToHit$[ebp]
	mov	DWORD PTR _lh$62[ebp], ecx

; 2610 : 				deathMessage->dataBlock.fPilotID	= lh->pilotSlot;

	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	eax, DWORD PTR _lh$62[ebp]
	mov	cl, BYTE PTR [eax+665]
	mov	BYTE PTR [edx+80], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _lh$62[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T22[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2611 : 				deathMessage->dataBlock.fCampID		= lh->GetCampaignObject()->GetCampID();

	mov	ecx, DWORD PTR $T22[ebp]
	mov	DWORD PTR tv362[ebp], ecx
	mov	edx, DWORD PTR tv362[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv362[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	WORD PTR [ecx+78], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _lh$62[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T42[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	mov	ecx, DWORD PTR $T42[ebp]
	mov	dl, BYTE PTR [ecx+154]
	mov	BYTE PTR $T71[ebp], dl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2612 : 				deathMessage->dataBlock.fSide		= lh->GetCampaignObject()->GetOwner();

	mov	eax, DWORD PTR _deathMessage$[ebp]
	mov	cl, BYTE PTR $T71[ebp]
	mov	BYTE PTR [eax+83], cl

; 2613 : 			}
; 2614 : 			else {

	jmp	SHORT $LN15@Eject
$LN16@Eject:

; 2615 : 				CampBaseClass *lh = static_cast<CampBaseClass*>(lastToHit);

	mov	edx, DWORD PTR _lastToHit$[ebp]
	mov	DWORD PTR _lh$60[ebp], edx

; 2616 : 				deathMessage->dataBlock.fPilotID	= 0;

	mov	eax, DWORD PTR _deathMessage$[ebp]
	mov	BYTE PTR [eax+80], 0

; 2617 : 				deathMessage->dataBlock.fCampID		= lh->GetCampID();

	mov	ecx, DWORD PTR _lh$60[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lh$60[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	WORD PTR [ecx+78], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	mov	edx, DWORD PTR _lh$60[ebp]
	mov	al, BYTE PTR [edx+154]
	mov	BYTE PTR $T68[ebp], al
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2618 : 				deathMessage->dataBlock.fSide		= lh->GetOwner();

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	dl, BYTE PTR $T68[ebp]
	mov	BYTE PTR [ecx+83], dl
$LN15@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _lastToHit$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T21[ebp], ecx
	mov	DWORD PTR $T21[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2620 : 			deathMessage->dataBlock.fEntityID		= lastToHit->Id();

	mov	eax, DWORD PTR $T21[ebp]
	mov	ecx, DWORD PTR $T21[ebp+4]
	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	DWORD PTR [edx+70], eax
	mov	DWORD PTR [edx+74], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	eax, DWORD PTR _lastToHit$[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR $T61[ebp], cx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2621 : 			deathMessage->dataBlock.fIndex			= lastToHit->Type();

	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	ax, WORD PTR $T61[ebp]
	mov	WORD PTR [edx+81], ax

; 2622 : 		}
; 2623 : 		else {

	jmp	$LN14@Eject
$LN17@Eject:

; 2624 : 			// If aircraft is undamaged, the death message we send is 'ground collision',
; 2625 : 			// since the aircraft would probably get there eventually
; 2626 : 			deathMessage->dataBlock.damageType		= FalconDamageType::OtherDamage;

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	DWORD PTR [ecx+48], 10			; 0000000aH

; 2627 : 			deathMessage->dataBlock.fPilotID		= pilotSlot;

	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+665]
	mov	BYTE PTR [edx+80], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T11[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2628 : 			deathMessage->dataBlock.fCampID			= GetCampaignObject()->GetCampID();

	mov	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR tv436[ebp], ecx
	mov	edx, DWORD PTR tv436[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv436[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	WORD PTR [ecx+78], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T52[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	mov	ecx, DWORD PTR $T52[ebp]
	mov	dl, BYTE PTR [ecx+154]
	mov	BYTE PTR $T72[ebp], dl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2629 : 			deathMessage->dataBlock.fSide			= GetCampaignObject()->GetOwner();

	mov	eax, DWORD PTR _deathMessage$[ebp]
	mov	cl, BYTE PTR $T72[ebp]
	mov	BYTE PTR [eax+83], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T19[ebp], eax
	mov	DWORD PTR $T19[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2630 : 			deathMessage->dataBlock.fEntityID		= Id();

	mov	edx, DWORD PTR $T19[ebp]
	mov	eax, DWORD PTR $T19[ebp+4]
	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	DWORD PTR [ecx+70], edx
	mov	DWORD PTR [ecx+74], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR $T66[ebp], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2631 : 			deathMessage->dataBlock.fIndex			= Type();

	mov	ecx, DWORD PTR _deathMessage$[ebp]
	mov	dx, WORD PTR $T66[ebp]
	mov	WORD PTR [ecx+81], dx
$LN14@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h

; 181  : 	void RequestOutOfBandTransmit() { flags_ |= VU_OUT_OF_BAND_MSG_FLAG; }

	mov	eax, DWORD PTR _deathMessage$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _deathMessage$[ebp]
	mov	BYTE PTR [edx+6], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2634 : 		FalconSendMessage (deathMessage, TRUE);

	push	1
	mov	eax, DWORD PTR _deathMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 2635 : 		SetDead(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+364]
	call	eax

; 2636 : 	}
; 2637 : 	else {

	jmp	$LN9@Eject
$LN18@Eject:

; 2638 : 		RemovePilot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemovePilot@AircraftClass@@QAEXXZ	; AircraftClass::RemovePilot

; 2639 : 
; 2640 : 		// make sure we're no longer in simple model
; 2641 : 		if (af){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	je	SHORT $LN12@Eject

; 2642 : 			af->SetSimpleMode(SIMPLE_MODE_OFF);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?SetSimpleMode@AirframeClass@@QAEXH@Z	; AirframeClass::SetSimpleMode
$LN12@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR $T65[ebp], cx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2645 : 		VehicleClassDataType *vc = GetVehicleClassData(Type() - VU_LAST_ENTITY_TYPE);

	movzx	edx, WORD PTR $T65[ebp]
	sub	edx, 100				; 00000064H
	push	edx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$20[ebp], eax

; 2646 : 		for (int pilotno = 0; pilotno < vc->NumberOfPilots; pilotno++) {

	mov	DWORD PTR _pilotno$67[ebp], 0
	jmp	SHORT $LN11@Eject
$LN10@Eject:
	mov	eax, DWORD PTR _pilotno$67[ebp]
	add	eax, 1
	mov	DWORD PTR _pilotno$67[ebp], eax
$LN11@Eject:
	mov	ecx, DWORD PTR _vc$20[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	DWORD PTR _pilotno$67[ebp], edx
	jge	$LN9@Eject

; 2647 : 			// Create a new ejected pilot sim object.
; 2648 : 			epc = NULL;

	mov	DWORD PTR _epc$[ebp], 0

; 2649 : 			epc = new EjectedPilotClass(this, EM_F16_MODE1, pilotno);

	push	860					; 0000035cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T56[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T56[ebp], 0
	je	SHORT $LN29@Eject
	mov	eax, DWORD PTR _pilotno$67[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T56[ebp]
	call	??0EjectedPilotClass@@QAE@PAVAircraftClass@@HH@Z ; EjectedPilotClass::EjectedPilotClass
	mov	DWORD PTR tv517[ebp], eax
	jmp	SHORT $LN30@Eject
$LN29@Eject:
	mov	DWORD PTR tv517[ebp], 0
$LN30@Eject:
	mov	edx, DWORD PTR tv517[ebp]
	mov	DWORD PTR $T38[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T38[ebp]
	mov	DWORD PTR _epc$[ebp], eax

; 2650 : 			if (epc != NULL){

	cmp	DWORD PTR _epc$[ebp], 0
	je	$LN155@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 148  : 	void SetSendCreate(VU_SEND_TYPE sc) { share_.flags_.breakdown_.sendCreate_ = sc; }

	mov	ecx, 2
	and	ecx, 3
	shl	ecx, 6
	mov	edx, DWORD PTR _epc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -193				; ffffff3fH
	or	eax, ecx
	mov	ecx, DWORD PTR _epc$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2652 : 				vuDatabase->/*Quick*/Insert(epc);

	mov	edx, DWORD PTR _epc$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 2653 : 				epc->Wake();

	mov	eax, DWORD PTR _epc$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _epc$[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 171  : 	VU_TIME UpdateRate() const { return entityTypePtr_->updateRate_; }

	mov	ecx, DWORD PTR _epc$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T5[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2660 : 				);

	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR tv1405[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1405[ebp]
	mov	edx, DWORD PTR tv1405[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1409[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1409[ebp]
	movss	DWORD PTR tv1600[ebp], xmm0
	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	movss	xmm1, DWORD PTR tv1600[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR tv1415[ebp], xmm0
	fld	DWORD PTR tv1415[ebp]
	fnstcw	WORD PTR tv1417[ebp]
	movzx	eax, WORD PTR tv1417[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv1420[ebp], eax
	fldcw	WORD PTR tv1420[ebp]
	fistp	QWORD PTR tv1422[ebp]
	fldcw	WORD PTR tv1417[ebp]
	mov	eax, DWORD PTR tv1422[ebp]
	add	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	mov	DWORD PTR $T9[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 120  : 	void SetTransmissionTime(VU_TIME currentTime){ lastTransmissionTime_ = currentTime; }

	mov	ecx, DWORD PTR _epc$[ebp]
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR [ecx+108], edx
$LN155@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2663 : 			if ((pilotno == 0) && IsLocal()){

	cmp	DWORD PTR _pilotno$67[ebp], 0
	jne	$LN3@Eject
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN3@Eject

; 2665 : 				ejectMessage = new FalconEjectMessage(epc->Id(), FalconLocalGame);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T58[ebp], 0
	je	SHORT $LN33@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN159@Eject
	mov	DWORD PTR tv1030[ebp], 1
	jmp	SHORT $LN160@Eject
$LN159@Eject:
	mov	DWORD PTR tv1030[ebp], 0
$LN160@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2665 : 				ejectMessage = new FalconEjectMessage(epc->Id(), FalconLocalGame);

	movzx	ecx, BYTE PTR tv1030[ebp]
	test	ecx, ecx
	je	SHORT $LN31@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T34[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T34[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2665 : 				ejectMessage = new FalconEjectMessage(epc->Id(), FalconLocalGame);

	mov	DWORD PTR tv589[ebp], eax
	jmp	SHORT $LN32@Eject
$LN31@Eject:
	mov	DWORD PTR tv589[ebp], 0
$LN32@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _epc$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T18[ebp], ecx
	mov	DWORD PTR $T18[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2665 : 				ejectMessage = new FalconEjectMessage(epc->Id(), FalconLocalGame);

	push	1
	mov	eax, DWORD PTR tv589[ebp]
	push	eax
	mov	ecx, DWORD PTR $T18[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T18[ebp]
	push	edx
	mov	ecx, DWORD PTR $T58[ebp]
	call	??0FalconEjectMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconEjectMessage::FalconEjectMessage
	mov	DWORD PTR tv600[ebp], eax
	jmp	SHORT $LN34@Eject
$LN33@Eject:
	mov	DWORD PTR tv600[ebp], 0
$LN34@Eject:
	mov	eax, DWORD PTR tv600[ebp]
	mov	DWORD PTR $T17[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR _ejectMessage$[ebp], ecx

; 2666 : 				if(ejectMessage != NULL){

	cmp	DWORD PTR _ejectMessage$[ebp], 0
	je	$LN6@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR $T16[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2667 : 					ejectMessage->dataBlock.ePlaneID		= Id();

	mov	edx, DWORD PTR $T16[ebp]
	mov	eax, DWORD PTR $T16[ebp+4]
	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T32[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2669 : 					ejectMessage->dataBlock.eCampID			= ((CampBaseClass*)GetCampaignObject())->GetCampID();

	mov	ecx, DWORD PTR $T32[ebp]
	mov	DWORD PTR tv624[ebp], ecx
	mov	edx, DWORD PTR tv624[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv624[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	WORD PTR [ecx+64], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T2[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T14[ebp], edx
	mov	DWORD PTR $T14[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2670 : 					ejectMessage->dataBlock.eFlightID       = GetCampaignObject()->Id();

	mov	ecx, DWORD PTR $T14[ebp]
	mov	edx, DWORD PTR $T14[ebp+4]
	mov	eax, DWORD PTR _ejectMessage$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], edx

; 2671 : 	//				ejectMessage->dataBlock.eSide			= ((CampBaseClass*)GetCampaignObject())->GetOwner();
; 2672 : 					ejectMessage->dataBlock.ePilotID		= pilotSlot;

	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+665]
	mov	BYTE PTR [ecx+66], al
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 262  : 	VU_ID LastShooter (void) { return lastShooter; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR $T12[ebp], edx
	mov	DWORD PTR $T12[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 116  : 		); 

	mov	ecx, DWORD PTR $T12[ebp]
	cmp	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	jne	SHORT $LN185@Eject

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	edx, DWORD PTR $T12[ebp+4]
	cmp	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	jne	SHORT $LN189@Eject
	mov	DWORD PTR tv1093[ebp], 1
	jmp	SHORT $LN190@Eject
$LN189@Eject:
	mov	DWORD PTR tv1093[ebp], 0
$LN190@Eject:

; 116  : 		); 

	cmp	DWORD PTR tv1093[ebp], 0
	je	SHORT $LN183@Eject
	mov	BYTE PTR tv1088[ebp], 0
	jmp	SHORT $LN184@Eject
$LN183@Eject:
	mov	BYTE PTR tv1088[ebp], 1
$LN184@Eject:
	mov	al, BYTE PTR tv1088[ebp]
	mov	BYTE PTR tv1089[ebp], al
	jmp	SHORT $LN186@Eject
$LN185@Eject:
	mov	BYTE PTR tv1089[ebp], 1
$LN186@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2674 : 					ejectMessage->dataBlock.hadLastShooter	= (uchar)(LastShooter() != FalconNullId);

	mov	ecx, DWORD PTR _ejectMessage$[ebp]
	mov	dl, BYTE PTR tv1089[ebp]
	mov	BYTE PTR [ecx+67], dl

; 2675 : 					FalconSendMessage(ejectMessage, TRUE);

	push	1
	mov	eax, DWORD PTR _ejectMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN6@Eject:

; 2679 : 				for (i=0; i<GetCampaignObject()->NumberOfComponents(); i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@Eject
$LN4@Eject:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN5@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T30[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2679 : 				for (i=0; i<GetCampaignObject()->NumberOfComponents(); i++){

	mov	ecx, DWORD PTR $T30[ebp]
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T15[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2681 : 						!((SimBaseClass*)GetCampaignObject()->GetComponentEntity(i))->IsSetFlag(MOTION_OWNSHIP))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T15[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	cmp	eax, DWORD PTR _this$[ebp]
	je	$LN2@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T28[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2681 : 						!((SimBaseClass*)GetCampaignObject()->GetComponentEntity(i))->IsSetFlag(MOTION_OWNSHIP))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T28[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR $T7[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	mov	ecx, DWORD PTR $T7[ebp]
	mov	edx, DWORD PTR [ecx+172]
	and	edx, 65536				; 00010000H
	je	SHORT $LN205@Eject
	mov	DWORD PTR tv1100[ebp], 1
	jmp	SHORT $LN206@Eject
$LN205@Eject:
	mov	DWORD PTR tv1100[ebp], 0
$LN206@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2681 : 						!((SimBaseClass*)GetCampaignObject()->GetComponentEntity(i))->IsSetFlag(MOTION_OWNSHIP))

	cmp	DWORD PTR tv1100[ebp], 0
	jne	$LN2@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T26[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2683 : 						SimBaseClass* sender = GetCampaignObject()->GetComponentEntity(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T26[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _sender$69[ebp], eax

; 2686 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T55[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T55[ebp], 0
	je	$LN37@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN213@Eject
	mov	DWORD PTR tv1103[ebp], 1
	jmp	SHORT $LN214@Eject
$LN213@Eject:
	mov	DWORD PTR tv1103[ebp], 0
$LN214@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2686 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	movzx	eax, BYTE PTR tv1103[ebp]
	test	eax, eax
	je	SHORT $LN35@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T51[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T51[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2686 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	mov	DWORD PTR tv770[ebp], eax
	jmp	SHORT $LN36@Eject
$LN35@Eject:
	mov	DWORD PTR tv770[ebp], 0
$LN36@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _sender$69[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR $T10[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2686 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	push	1
	mov	edx, DWORD PTR tv770[ebp]
	push	edx
	mov	eax, DWORD PTR $T10[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T10[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T55[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv781[ebp], eax
	jmp	SHORT $LN38@Eject
$LN37@Eject:
	mov	DWORD PTR tv781[ebp], 0
$LN38@Eject:
	mov	edx, DWORD PTR tv781[ebp]
	mov	DWORD PTR $T49[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T49[ebp]
	mov	DWORD PTR _msg$73[ebp], eax

; 2687 : 						msg->dataBlock.message = rcAIRMANDOWNA;

	mov	ecx, 7
	mov	edx, DWORD PTR _msg$73[ebp]
	mov	WORD PTR [edx+62], cx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T8[ebp], ecx
	mov	DWORD PTR $T8[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2688 : 						msg->dataBlock.from = Id();

	mov	eax, DWORD PTR $T8[ebp]
	mov	ecx, DWORD PTR $T8[ebp+4]
	mov	edx, DWORD PTR _msg$73[ebp]
	mov	DWORD PTR [edx+48], eax
	mov	DWORD PTR [edx+52], ecx

; 2689 : 						msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	eax, DWORD PTR _msg$73[ebp]
	mov	BYTE PTR [eax+60], 1

; 2690 : 						msg->dataBlock.voice_id = (uchar)sender->GetPilotVoiceId();

	mov	ecx, DWORD PTR _sender$69[ebp]
	call	?GetPilotVoiceId@SimBaseClass@@QAEHXZ	; SimBaseClass::GetPilotVoiceId
	mov	ecx, DWORD PTR _msg$73[ebp]
	mov	BYTE PTR [ecx+61], al
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 154  : 	int GetCallsignIdx () { return callsignIdx; };

	mov	edx, DWORD PTR _sender$69[ebp]
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR $T47[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2691 : 						msg->dataBlock.edata[0] = (short)sender->GetCallsignIdx();

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _msg$73[ebp]
	mov	ax, WORD PTR $T47[ebp]
	mov	WORD PTR [edx+ecx+64], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 155  : 	int GetSlot () { return slotNumber;};

	mov	ecx, DWORD PTR _sender$69[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	DWORD PTR $T45[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2692 : 						msg->dataBlock.edata[1] = (short)sender->GetSlot();

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _msg$73[ebp]
	mov	dx, WORD PTR $T45[ebp]
	mov	WORD PTR [ecx+eax+64], dx

; 2693 : 						msg->dataBlock.time_to_play = 2 * CampaignSeconds;

	mov	eax, DWORD PTR _msg$73[ebp]
	mov	DWORD PTR [eax+56], 2000		; 000007d0H

; 2694 : 						FalconSendMessage(msg, FALSE);

	push	0
	mov	ecx, DWORD PTR _msg$73[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 2697 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T54[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T54[ebp], 0
	je	$LN41@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN229@Eject
	mov	DWORD PTR tv1117[ebp], 1
	jmp	SHORT $LN230@Eject
$LN229@Eject:
	mov	DWORD PTR tv1117[ebp], 0
$LN230@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2697 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	movzx	edx, BYTE PTR tv1117[ebp]
	test	edx, edx
	je	SHORT $LN39@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T43[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T43[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2697 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	mov	DWORD PTR tv845[ebp], eax
	jmp	SHORT $LN40@Eject
$LN39@Eject:
	mov	DWORD PTR tv845[ebp], 0
$LN40@Eject:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR _sender$69[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR $T6[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2697 : 						msg = new FalconRadioChatterMessage(sender->Id(), FalconLocalGame);

	push	1
	mov	ecx, DWORD PTR tv845[ebp]
	push	ecx
	mov	edx, DWORD PTR $T6[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR $T54[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv856[ebp], eax
	jmp	SHORT $LN42@Eject
$LN41@Eject:
	mov	DWORD PTR tv856[ebp], 0
$LN42@Eject:
	mov	ecx, DWORD PTR tv856[ebp]
	mov	DWORD PTR $T41[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T41[ebp]
	mov	DWORD PTR _msg$73[ebp], edx

; 2698 : 						msg->dataBlock.message = rcAIRMANDOWNF; 

	mov	eax, 11					; 0000000bH
	mov	ecx, DWORD PTR _msg$73[ebp]
	mov	WORD PTR [ecx+62], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _sender$69[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR $T4[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2699 : 						msg->dataBlock.from = sender->Id();

	mov	edx, DWORD PTR $T4[ebp]
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	ecx, DWORD PTR _msg$73[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 2700 : 						msg->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	edx, DWORD PTR _msg$73[ebp]
	mov	BYTE PTR [edx+60], 1

; 2701 : 						msg->dataBlock.voice_id = (uchar)sender->GetPilotVoiceId();

	mov	ecx, DWORD PTR _sender$69[ebp]
	call	?GetPilotVoiceId@SimBaseClass@@QAEHXZ	; SimBaseClass::GetPilotVoiceId
	mov	ecx, DWORD PTR _msg$73[ebp]
	mov	BYTE PTR [ecx+61], al

; 2702 : 						msg->dataBlock.time_to_play = 4 * CampaignSeconds;

	mov	edx, DWORD PTR _msg$73[ebp]
	mov	DWORD PTR [edx+56], 4000		; 00000fa0H

; 2703 : 						msg->dataBlock.edata[0] = -1;

	mov	eax, 2
	imul	eax, 0
	or	ecx, -1
	mov	edx, DWORD PTR _msg$73[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 2704 : 						msg->dataBlock.edata[1] = -1;

	mov	eax, 2
	shl	eax, 0
	or	ecx, -1
	mov	edx, DWORD PTR _msg$73[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 2705 : 						// Using X and Y position doesn't work...we need bearing and distance...
; 2706 : 						//GetCampaignObject()->GetLocation(&msg->dataBlock.edata[0],&msg->dataBlock.edata[1]);
; 2707 : 						FalconSendMessage(msg, FALSE); // Added - why not send when we've set it up ?

	push	0
	mov	eax, DWORD PTR _msg$73[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T39[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2710 : 						if (RequestSARMission((FlightClass*)GetCampaignObject())){

	mov	eax, DWORD PTR $T39[ebp]
	push	eax
	call	?RequestSARMission@@YAHPAVFlightClass@@@Z ; RequestSARMission
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@Eject
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T37[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR $T36[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2713 : 							radioMessage = CreateCallFromAwacs((FlightClass*)GetCampaignObject(), rcSARENROUTE);

	mov	ecx, DWORD PTR $T37[ebp]
	push	ecx
	push	184					; 000000b8H
	mov	edx, DWORD PTR $T36[ebp]
	push	edx
	call	?CreateCallFromAwacs@@YAPAVFalconRadioChatterMessage@@PAVFlightClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromAwacs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _radioMessage$53[ebp], eax

; 2714 : 							radioMessage->dataBlock.time_to_play = (5 + rand() % 5) * CampaignSeconds;

	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 5
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR _radioMessage$53[ebp]
	mov	DWORD PTR [eax+56], edx

; 2715 : 							FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$53[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN1@Eject:

; 2716 : 						}
; 2717 : 						break;

	jmp	SHORT $LN3@Eject
$LN2@Eject:

; 2718 : 					}
; 2719 : 				}

	jmp	$LN4@Eject
$LN3@Eject:

; 2720 : 			}
; 2721 : 		}

	jmp	$LN10@Eject
$LN9@Eject:

; 2722 : 	}
; 2723 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T59[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$1:
	mov	eax, DWORD PTR $T57[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$2:
	mov	eax, DWORD PTR $T56[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$3:
	mov	eax, DWORD PTR $T58[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$4:
	mov	eax, DWORD PTR $T55[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Eject@AircraftClass@@QAEXXZ$5:
	mov	eax, DWORD PTR $T54[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Eject@AircraftClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-508]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Eject@AircraftClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Eject@AircraftClass@@QAEXXZ ENDP			; AircraftClass::Eject
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemovePilot@AircraftClass@@QAEXXZ PROC			; AircraftClass::RemovePilot
; _this$ = ecx

; 2570 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2571 : 	SetAcStatusBits(ACSTATUS_PILOT_EJECTED);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 2572 : 	SetAutopilot(APOff);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAutopilot@AircraftClass@@QAEXW4AutoPilotType@1@@Z ; AircraftClass::SetAutopilot

; 2573 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemovePilot@AircraftClass@@QAEXXZ ENDP			; AircraftClass::RemovePilot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Mass@AircraftClass@@UAEMXZ PROC			; AircraftClass::Mass
; _this$ = ecx

; 2803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1169 : 	float Mass (void)		{return mass;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2804 : 	return af->Mass();

	fld	DWORD PTR $T1[ebp]

; 2805 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Mass@AircraftClass@@UAEMXZ ENDP			; AircraftClass::Mass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsAirplane@AircraftClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirplane@AircraftClass@@UAEHXZ PROC			; AircraftClass::IsAirplane, COMDAT
; _this$ = ecx

; 627  : 	virtual int IsAirplane(void) {return TRUE;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirplane@AircraftClass@@UAEHXZ ENDP			; AircraftClass::IsAirplane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_z$ = -148						; size = 4
_zz$ = -144						; size = 4
_wpTarget$ = -140					; size = 4
$T1 = -136						; size = 4
$T2 = -132						; size = 4
$T3 = -128						; size = 4
$T4 = -124						; size = 4
$T5 = -120						; size = 4
$T6 = -116						; size = 4
$T7 = -112						; size = 4
_yy$ = -108						; size = 4
$T8 = -104						; size = 4
_xx$ = -100						; size = 4
$T9 = -96						; size = 4
$T10 = -92						; size = 4
_oc$ = -88						; size = 4
$T11 = -84						; size = 4
$T12 = -80						; size = 4
$T13 = -76						; size = 4
$T14 = -72						; size = 4
_dx$15 = -68						; size = 4
_flightIdx$ = -64					; size = 4
_dy$16 = -60						; size = 4
_dx$17 = -56						; size = 4
_y$ = -52						; size = 4
_x$ = -48						; size = 4
_dy$18 = -44						; size = 4
$T19 = -40						; size = 4
_flight$ = -36						; size = 4
_tgtnum1$ = -29						; size = 1
$T20 = -28						; size = 4
_featnum$21 = -24					; size = 4
_Priority$22 = -20					; size = 4
$T23 = -13						; size = 1
_w$ = -12						; size = 4
_fc$24 = -8						; size = 4
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
?GetJDAMPBTarget@AircraftClass@@QAEHPAV1@@Z PROC	; AircraftClass::GetJDAMPBTarget
; _this$ = ecx

; 3472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	DWORD PTR _this$[ebp], ecx

; 3473 : 				Flight flight = NULL;

	mov	DWORD PTR _flight$[ebp], 0

; 3474 : 				int flightIdx = 0;

	mov	DWORD PTR _flightIdx$[ebp], 0

; 3475 : 				float x, y, z, xx, yy, zz;
; 3476 : 				FalconEntity *wpTarget = NULL;

	mov	DWORD PTR _wpTarget$[ebp], 0

; 3477 : 				ObjClassDataType*		oc;
; 3478 : 				uchar tgtnum1 = 0;

	mov	BYTE PTR _tgtnum1$[ebp], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T12[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3479 : 				flight = (Flight)GetCampaignObject();

	mov	edx, DWORD PTR $T12[ebp]
	mov	DWORD PTR _flight$[ebp], edx

; 3480 : 				flightIdx = flight->GetComponentIndex(aircraft);

	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR _w$[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3483 : 				JDAMtargetRange = -1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1772], xmm0

; 3484 : 				strcpy(JDAMtargetName, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1604				; 00000644H
	push	ecx
	call	_strcpy
	add	esp, 8

; 3485 : 				strcpy(JDAMtargetName1, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1684				; 00000694H
	push	edx
	call	_strcpy
	add	esp, 8
$LN34@GetJDAMPBT:

; 3486 : 				while (w)

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN33@GetJDAMPBT
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T14[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3488 : 					if (!(w->GetWPFlags() & WPF_TARGET))

	mov	edx, DWORD PTR $T14[ebp]
	and	edx, 1
	jne	SHORT $LN32@GetJDAMPBT
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _w$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3491 : 						continue;

	jmp	SHORT $LN34@GetJDAMPBT

; 3492 : 					}
; 3493 : 					else

	jmp	SHORT $LN31@GetJDAMPBT
$LN32@GetJDAMPBT:

; 3494 : 						break;

	jmp	SHORT $LN33@GetJDAMPBT
$LN31@GetJDAMPBT:

; 3495 : 				}

	jmp	SHORT $LN34@GetJDAMPBT
$LN33@GetJDAMPBT:

; 3496 : 				// FRB - Something is wrong!
; 3497 : 				if (!w)

	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN30@GetJDAMPBT

; 3498 : 					return -1;

	or	eax, -1
	jmp	$LN35@GetJDAMPBT
$LN30@GetJDAMPBT:

; 3499 : 
; 3500 : 				JDAMtarget = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1596], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 168  : 	CampEntity GetWPTarget (void)					{ return (CampEntity)vuDatabase->Find(TargetID); }

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3501 : 				JDAMtarget = w->GetWPTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1596], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 168  : 	CampEntity GetWPTarget (void)					{ return (CampEntity)vuDatabase->Find(TargetID); }

	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3502 : 				wpTarget = w->GetWPTarget();

	mov	DWORD PTR _wpTarget$[ebp], eax

; 3503 : 				if (JDAMtgtnum == -1) // Initialize target selection

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1768], -1
	jne	SHORT $LN29@GetJDAMPBT
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 169  : 	uchar GetWPTargetBuilding (void)				{ return TargetBuilding; }

	mov	eax, DWORD PTR _w$[ebp]
	mov	cl, BYTE PTR [eax+27]
	mov	BYTE PTR $T23[ebp], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3505 : 					JDAMtgtnum = w->GetWPTargetBuilding() + flightIdx; // Cobra - different starting point for each element

	movzx	edx, BYTE PTR $T23[ebp]
	add	edx, DWORD PTR _flightIdx$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1768], edx

; 3506 : 					JDAMStep = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], 1
$LN29@GetJDAMPBT:

; 3507 : 				}
; 3508 : 				// RV - Biker, CTD Fix if target is not a possible objective
; 3509 : 				if (JDAMtarget && JDAMtarget->IsObjective())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1596], 0
	je	$LN28@GetJDAMPBT
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1596]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1596]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	je	$LN28@GetJDAMPBT

; 3510 : 				{
; 3511 : 					FeatureClassDataType	*fc = NULL;

	mov	DWORD PTR _fc$24[ebp], 0

; 3512 : 					oc = ((Objective)JDAMtarget)->GetObjectiveClassData();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1596]
	call	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ ; ObjectiveClass::GetObjectiveClassData
	mov	DWORD PTR _oc$[ebp], eax

; 3513 : 					int featnum = oc->Features;

	mov	ecx, DWORD PTR _oc$[ebp]
	movzx	edx, BYTE PTR [ecx+50]
	mov	DWORD PTR _featnum$21[ebp], edx

; 3514 : 					int Priority = 99;

	mov	DWORD PTR _Priority$22[ebp], 99		; 00000063H

; 3515 : 					if (JDAMStep == 1 && JDAMtgtnum < (featnum-1))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1764], 1
	jne	$LN27@GetJDAMPBT
	mov	ecx, DWORD PTR _featnum$21[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1768], ecx
	jge	$LN27@GetJDAMPBT
$LN79@GetJDAMPBT:

; 3516 : 					{
; 3517 : 						while (Priority > 2)

	cmp	DWORD PTR _Priority$22[ebp], 2
	jle	$LN25@GetJDAMPBT

; 3518 : 						{
; 3519 : 							if (JDAMtgtnum+1 < featnum)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	add	ecx, 1
	cmp	ecx, DWORD PTR _featnum$21[ebp]
	jge	SHORT $LN24@GetJDAMPBT

; 3520 : 							{
; 3521 : 								JDAMtgtnum ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax

; 3522 : 								if (((Objective)JDAMtarget)->GetFeatureStatus(JDAMtgtnum) == VIS_DESTROYED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1596]
	call	?GetFeatureStatus@ObjectiveClass@@QAEHH@Z ; ObjectiveClass::GetFeatureStatus
	cmp	eax, 3
	jne	SHORT $LN23@GetJDAMPBT

; 3523 : 									continue;

	jmp	SHORT $LN79@GetJDAMPBT
$LN23@GetJDAMPBT:

; 3524 : 								fc = GetFeatureClassData(((Objective)JDAMtarget)->GetFeatureID(JDAMtgtnum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1596]
	call	?GetFeatureID@ObjectiveClass@@QAEHH@Z	; ObjectiveClass::GetFeatureID
	push	eax
	call	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z ; GetFeatureClassData
	add	esp, 4
	mov	DWORD PTR _fc$24[ebp], eax

; 3525 : 								if (fc && !F4IsBadReadPtr(fc, sizeof (fc))) // higher priority number = lower priority

	cmp	DWORD PTR _fc$24[ebp], 0
	je	SHORT $LN22@GetJDAMPBT
	push	4
	mov	edx, DWORD PTR _fc$24[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@GetJDAMPBT

; 3526 : 									Priority = fc->Priority;

	mov	ecx, DWORD PTR _fc$24[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _Priority$22[ebp], edx
$LN22@GetJDAMPBT:

; 3527 : 							}
; 3528 : 							else

	jmp	SHORT $LN21@GetJDAMPBT
$LN24@GetJDAMPBT:

; 3529 : 								break;

	jmp	SHORT $LN25@GetJDAMPBT
$LN21@GetJDAMPBT:

; 3530 : 						}

	jmp	$LN79@GetJDAMPBT
$LN25@GetJDAMPBT:

; 3531 : 						JDAMStep = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], 0
	jmp	SHORT $LN19@GetJDAMPBT
$LN27@GetJDAMPBT:

; 3532 : 					}
; 3533 : 					else if (JDAMStep == 1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1764], 1
	jne	SHORT $LN19@GetJDAMPBT

; 3534 : 					{
; 3535 : 						JDAMtgtnum = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1768], 0

; 3536 : 						JDAMStep = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], 0
$LN19@GetJDAMPBT:

; 3537 : 					}
; 3538 : 					if (JDAMStep == -1 && JDAMtgtnum > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1764], -1
	jne	$LN18@GetJDAMPBT
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1768], 1
	jle	$LN18@GetJDAMPBT
$LN80@GetJDAMPBT:

; 3539 : 					{
; 3540 : 						while (Priority > 2)

	cmp	DWORD PTR _Priority$22[ebp], 2
	jle	$LN16@GetJDAMPBT

; 3541 : 						{
; 3542 : 							if (JDAMtgtnum-1 > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	sub	ecx, 1
	test	ecx, ecx
	jle	SHORT $LN15@GetJDAMPBT

; 3543 : 							{
; 3544 : 								JDAMtgtnum --;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax

; 3545 : 								if (((Objective)JDAMtarget)->GetFeatureStatus(JDAMtgtnum) == VIS_DESTROYED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1596]
	call	?GetFeatureStatus@ObjectiveClass@@QAEHH@Z ; ObjectiveClass::GetFeatureStatus
	cmp	eax, 3
	jne	SHORT $LN14@GetJDAMPBT

; 3546 : 									continue;

	jmp	SHORT $LN80@GetJDAMPBT
$LN14@GetJDAMPBT:

; 3547 : 								fc = GetFeatureClassData(((Objective)JDAMtarget)->GetFeatureID(JDAMtgtnum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1596]
	call	?GetFeatureID@ObjectiveClass@@QAEHH@Z	; ObjectiveClass::GetFeatureID
	push	eax
	call	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z ; GetFeatureClassData
	add	esp, 4
	mov	DWORD PTR _fc$24[ebp], eax

; 3548 : 								if (fc && !F4IsBadReadPtr(fc, sizeof (fc))) // higher priority number = lower priority

	cmp	DWORD PTR _fc$24[ebp], 0
	je	SHORT $LN13@GetJDAMPBT
	push	4
	mov	edx, DWORD PTR _fc$24[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@GetJDAMPBT

; 3549 : 									Priority = fc->Priority;

	mov	ecx, DWORD PTR _fc$24[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _Priority$22[ebp], edx
$LN13@GetJDAMPBT:

; 3550 : 							}
; 3551 : 							else

	jmp	SHORT $LN12@GetJDAMPBT
$LN15@GetJDAMPBT:

; 3552 : 								break;

	jmp	SHORT $LN16@GetJDAMPBT
$LN12@GetJDAMPBT:

; 3553 : 						}

	jmp	$LN80@GetJDAMPBT
$LN16@GetJDAMPBT:

; 3554 : 						JDAMStep = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], 0
	jmp	SHORT $LN10@GetJDAMPBT
$LN18@GetJDAMPBT:

; 3555 : 					}
; 3556 : 					else if (JDAMStep == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1764], -1
	jne	SHORT $LN10@GetJDAMPBT

; 3557 : 					{
; 3558 : 						JDAMtgtnum = featnum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _featnum$21[ebp]
	mov	DWORD PTR [edx+1768], eax

; 3559 : 						JDAMStep = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1764], 0
$LN10@GetJDAMPBT:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1596]
	movsx	ecx, WORD PTR [eax+156]
	and	ecx, 128				; 00000080H
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3562 : 					if (!((Objective)JDAMtarget)->IsAggregate() && isDigital && DBrain())

	jne	SHORT $LN9@GetJDAMPBT
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	SHORT $LN9@GetJDAMPBT
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T5[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3562 : 					if (!((Objective)JDAMtarget)->IsAggregate() && isDigital && DBrain())

	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN9@GetJDAMPBT
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T9[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3563 : 						JDAMtgtnum = DBrain()->FindJDAMGroundTarget((CampBaseClass*)JDAMtarget, featnum, 0);

	push	0
	mov	ecx, DWORD PTR _featnum$21[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1596]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	?FindJDAMGroundTarget@DigitalBrain@@QAEHPAVCampBaseClass@@HH@Z ; DigitalBrain::FindJDAMGroundTarget
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax
$LN9@GetJDAMPBT:

; 3564 : 
; 3565 : 					JDAMsbc = JDAMtarget->GetComponentEntity(JDAMtgtnum);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1596]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1600], eax

; 3566 : 					if (JDAMsbc)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1600], 0
	je	$LN8@GetJDAMPBT
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1600]
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR $T1[ebp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3568 : 						float dx = JDAMsbc->XPos() - XPos();

	movss	xmm0, DWORD PTR $T1[ebp]
	subss	xmm0, DWORD PTR $T8[ebp]
	movss	DWORD PTR _dx$17[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1600]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T3[ebp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3569 : 						float dy = JDAMsbc->YPos() - YPos();

	movss	xmm0, DWORD PTR $T3[ebp]
	subss	xmm0, DWORD PTR $T7[ebp]
	movss	DWORD PTR _dy$18[ebp], xmm0

; 3570 :  						JDAMtargetRange = SqrtF(dx*dx+dy*dy) * FT_TO_NM;

	movss	xmm0, DWORD PTR _dy$18[ebp]
	mulss	xmm0, DWORD PTR _dy$18[ebp]
	movss	xmm1, DWORD PTR _dx$17[ebp]
	mulss	xmm1, DWORD PTR _dx$17[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR $T20[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h

; 52   : 		fld f;

	fld	DWORD PTR $T20[ebp]

; 53   : 		fsqrt;

	fsqrt

; 54   : 		fstp f;

	fstp	DWORD PTR $T20[ebp]

; 55   : 	}
; 56   : 
; 57   : 	return f;

	movss	xmm0, DWORD PTR $T20[ebp]
	movss	DWORD PTR $T13[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3570 :  						JDAMtargetRange = SqrtF(dx*dx+dy*dy) * FT_TO_NM;

	movss	xmm0, DWORD PTR $T13[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1772], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1600]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3571 : 						JDAMtgtPos.x = JDAMsbc->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T11[ebp]
	movss	DWORD PTR [ecx+1776], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1600]
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3572 : 						JDAMtgtPos.y = JDAMsbc->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T10[ebp]
	movss	DWORD PTR [ecx+1780], xmm0

; 3573 : 						JDAMtgtPos.z = OTWDriver.GetGroundLevel(JDAMtgtPos.x, JDAMtgtPos.y);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1780]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1776]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1784]

; 3574 : 					}
; 3575 : 					else

	jmp	$LN7@GetJDAMPBT
$LN8@GetJDAMPBT:

; 3576 : 					{
; 3577 : //========================================================================
; 3578 : 						// Not Deagg'ed, so calculate where the Feature is placed in the Objective
; 3579 : 						fc = GetFeatureClassData (((Objective)JDAMtarget)->GetFeatureID(JDAMtgtnum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1768]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1596]
	call	?GetFeatureID@ObjectiveClass@@QAEHH@Z	; ObjectiveClass::GetFeatureID
	push	eax
	call	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z ; GetFeatureClassData
	add	esp, 4
	mov	DWORD PTR _fc$24[ebp], eax

; 3580 : 						if (fc && !F4IsBadReadPtr(fc, sizeof (fc)) && !(fc->Flags & FEAT_VIRTUAL))

	cmp	DWORD PTR _fc$24[ebp], 0
	je	$LN6@GetJDAMPBT
	push	4
	mov	edx, DWORD PTR _fc$24[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	$LN6@GetJDAMPBT
	mov	ecx, DWORD PTR _fc$24[ebp]
	movzx	edx, WORD PTR [ecx+6]
	and	edx, 2
	jne	$LN6@GetJDAMPBT

; 3581 : 						{
; 3582 : 							((Objective)JDAMtarget)->GetFeatureOffset(JDAMtgtnum, &yy, &xx, &zz);

	lea	eax, DWORD PTR _zz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _yy$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1596]
	call	?GetFeatureOffset@ObjectiveClass@@QAEHHPAM00@Z ; ObjectiveClass::GetFeatureOffset

; 3583 : 							w->GetLocation(&x, &y, &z);

	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 3584 : 							JDAMtgtPos.x = xx + x;

	movss	xmm0, DWORD PTR _xx$[ebp]
	addss	xmm0, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1776], xmm0

; 3585 : 							JDAMtgtPos.y = yy + y;

	movss	xmm0, DWORD PTR _yy$[ebp]
	addss	xmm0, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1780], xmm0

; 3586 : 							JDAMtgtPos.z = OTWDriver.GetGroundLevel(JDAMtgtPos.x, JDAMtgtPos.y);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1780]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1776]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1784]
$LN6@GetJDAMPBT:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3589 : 						float dx = x - XPos();

	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR $T6[ebp]
	movss	DWORD PTR _dx$15[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3590 : 						float dy = y - YPos();

	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR $T4[ebp]
	movss	DWORD PTR _dy$16[ebp], xmm0

; 3591 :  						JDAMtargetRange = SqrtF(dx*dx+dy*dy) * FT_TO_NM;

	movss	xmm0, DWORD PTR _dy$16[ebp]
	mulss	xmm0, DWORD PTR _dy$16[ebp]
	movss	xmm1, DWORD PTR _dx$15[ebp]
	mulss	xmm1, DWORD PTR _dx$15[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR $T19[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\fmath.h

; 52   : 		fld f;

	fld	DWORD PTR $T19[ebp]

; 53   : 		fsqrt;

	fsqrt

; 54   : 		fstp f;

	fstp	DWORD PTR $T19[ebp]

; 55   : 	}
; 56   : 
; 57   : 	return f;

	movss	xmm0, DWORD PTR $T19[ebp]
	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3591 :  						JDAMtargetRange = SqrtF(dx*dx+dy*dy) * FT_TO_NM;

	movss	xmm0, DWORD PTR $T2[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1772], xmm0

; 3592 : 						JDAMsbc = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1600], 0
$LN7@GetJDAMPBT:

; 3593 : 					}
; 3594 : 					if (!fc)

	cmp	DWORD PTR _fc$24[ebp], 0
	jne	SHORT $LN5@GetJDAMPBT

; 3595 : 					{
; 3596 : 						fc = GetFeatureClassData(((Objective)JDAMtarget)->GetFeatureID(JDAMtgtnum));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1768]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1596]
	call	?GetFeatureID@ObjectiveClass@@QAEHH@Z	; ObjectiveClass::GetFeatureID
	push	eax
	call	?GetFeatureClassData@@YAPAUFeatureClassDataType@@H@Z ; GetFeatureClassData
	add	esp, 4
	mov	DWORD PTR _fc$24[ebp], eax
$LN5@GetJDAMPBT:

; 3597 : 					}
; 3598 : 					if (fc && !F4IsBadReadPtr(fc, sizeof (fc)))

	cmp	DWORD PTR _fc$24[ebp], 0
	je	SHORT $LN4@GetJDAMPBT
	push	4
	mov	eax, DWORD PTR _fc$24[ebp]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@GetJDAMPBT

; 3599 : 						strcpy(JDAMtargetName1, fc->Name);

	mov	edx, DWORD PTR _fc$24[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1684				; 00000694H
	push	eax
	call	_strcpy
	add	esp, 8

; 3600 : 					else

	jmp	SHORT $LN3@GetJDAMPBT
$LN4@GetJDAMPBT:

; 3601 : 						strcpy(JDAMtargetName1, "xxxx");

	push	OFFSET ??_C@_04ODPAOBIJ@xxxx?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1684				; 00000694H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN3@GetJDAMPBT:

; 3602 : 					JDAMtarget->GetName(JDAMtargetName,79,FALSE);

	push	0
	push	79					; 0000004fH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1604				; 00000644H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1596]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1596]
	mov	edx, DWORD PTR [eax+380]
	call	edx

; 3603 : 					if (!JDAMsbc) // Aggregated

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1600], 0
	jne	SHORT $LN2@GetJDAMPBT

; 3604 : 						strcat(JDAMtargetName1, " >AGG");

	push	OFFSET ??_C@_05LOMFCAFC@?5?$DOAGG?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1684				; 00000694H
	push	ecx
	call	_strcat
	add	esp, 8
$LN2@GetJDAMPBT:

; 3605 : 				}
; 3606 : 				else 

	jmp	SHORT $LN1@GetJDAMPBT
$LN28@GetJDAMPBT:

; 3607 : 				{
; 3608 : 					JDAMtargetRange = -1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+1772], xmm0
$LN1@GetJDAMPBT:

; 3609 : 				}
; 3610 : 	return JDAMtgtnum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1768]
$LN35@GetJDAMPBT:

; 3611 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetJDAMPBTarget@AircraftClass@@QAEHPAV1@@Z ENDP	; AircraftClass::GetJDAMPBTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetSpeedBrake@AircraftClass@@QAEXXZ PROC		; AircraftClass::SetSpeedBrake
; _this$ = ecx

; 3386 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3387 : //F15A/B, C/D, E
; 3388 : 	if (af->auxaeroData->typeAC == 3 || af->auxaeroData->typeAC == 4 || af->auxaeroData->typeAC == 5)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 3
	je	SHORT $LN15@SetSpeedBr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 4
	je	SHORT $LN15@SetSpeedBr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 5
	jne	$LN11@SetSpeedBr
$LN15@SetSpeedBr:

; 3389 : 	{
; 3390 : 		if (af->dbrake > 0 && (brakePos == 0 || brakePos == 3))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1548]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN14@SetSpeedBr
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1588], 0
	je	SHORT $LN13@SetSpeedBr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1588], 3
	jne	SHORT $LN14@SetSpeedBr
$LN13@SetSpeedBr:

; 3391 : 		{
; 3392 : 			brakePos = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1588], 1

; 3393 : 			speedBrakeState = af->dbrake;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1548]
	mov	DWORD PTR [ecx+1592], edx
$LN14@SetSpeedBr:

; 3394 : 		}
; 3395 : 
; 3396 : 		if (af->alpha > 25.0f && brakePos == 1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1152]
	comiss	xmm0, DWORD PTR __real@41c80000
	jbe	SHORT $LN12@SetSpeedBr
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1588], 1
	jne	SHORT $LN12@SetSpeedBr

; 3397 : 		{
; 3398 : 			af->speedBrake = -1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1560], xmm0

; 3399 : 			brakePos = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1588], 2
$LN12@SetSpeedBr:

; 3400 : 		}
; 3401 : 
; 3402 : 		if (af->alpha < 25.0f && brakePos == 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@41c80000
	comiss	xmm0, DWORD PTR [ecx+1152]
	jbe	SHORT $LN11@SetSpeedBr
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1588], 2
	jne	SHORT $LN11@SetSpeedBr

; 3403 : 		{
; 3404 : 			af->speedBrake = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1560], xmm0

; 3405 : 			brakePos = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1588], 1
$LN11@SetSpeedBr:

; 3406 : 		}
; 3407 : 	
; 3408 : 			
; 3409 : 	}
; 3410 : 
; 3411 : 	//F14A-D Speedbrake retracts when MIL power or greater
; 3412 : 	if (af->auxaeroData->typeAC == 6 || af->auxaeroData->typeAC == 7)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 6
	je	SHORT $LN9@SetSpeedBr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 7
	jne	$LN5@SetSpeedBr
$LN9@SetSpeedBr:

; 3413 : 	{
; 3414 : 		if (af->rpm >= 1.0f || af->rpm2 >= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR __real@3f800000
	jae	SHORT $LN7@SetSpeedBr
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1216]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN8@SetSpeedBr
$LN7@SetSpeedBr:

; 3415 : 		{
; 3416 : 			af->speedBrake = -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+1560], xmm0
	jmp	SHORT $LN5@SetSpeedBr
$LN8@SetSpeedBr:

; 3417 : 		}
; 3418 : 		else if (af->vcas > 400.0f)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1124]
	comiss	xmm0, DWORD PTR __real@43c80000
	jbe	SHORT $LN5@SetSpeedBr

; 3419 : 		{
; 3420 : 			af->speedBrake = -1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1560], xmm0
$LN5@SetSpeedBr:

; 3421 : 		}
; 3422 : 
; 3423 : 
; 3424 : 	}
; 3425 : 
; 3426 : 	//F-18A-D if g +6, AOA 28, or tef/down and vcas < 250 retract
; 3427 : 	if (af->auxaeroData->typeAC == 8 || af->auxaeroData->typeAC == 9)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3880], 8
	je	SHORT $LN3@SetSpeedBr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+3880], 9
	jne	$LN2@SetSpeedBr
$LN3@SetSpeedBr:

; 3428 : 	{
; 3429 : 		if (af->nzcgb > 6.0f || af->alpha > 28.0f || (af->gearPos > 0.5f && af->vcas < 250.0f))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1192]
	comiss	xmm0, DWORD PTR __real@40c00000
	ja	SHORT $LN1@SetSpeedBr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1152]
	comiss	xmm0, DWORD PTR __real@41e00000
	ja	SHORT $LN1@SetSpeedBr
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN2@SetSpeedBr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@437a0000
	comiss	xmm0, DWORD PTR [edx+1124]
	jbe	SHORT $LN2@SetSpeedBr
$LN1@SetSpeedBr:

; 3430 : 		{
; 3431 : 			af->speedBrake = -1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1560], xmm0
$LN2@SetSpeedBr:

; 3432 : 		}
; 3433 : 
; 3434 : 	}
; 3435 : 
; 3436 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetSpeedBrake@AircraftClass@@QAEXXZ ENDP		; AircraftClass::SetSpeedBrake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simveh.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -64						; size = 4
_theHTS$2 = -60						; size = 4
tv275 = -56						; size = 4
tv272 = -52						; size = 4
_laserPod$3 = -48					; size = 4
tv269 = -44						; size = 4
tv266 = -40						; size = 4
_theRadar$4 = -36					; size = 4
tv262 = -32						; size = 4
tv261 = -28						; size = 4
_mavDisplay$5 = -24					; size = 4
_yValue$ = -20						; size = 4
_xValue$ = -16						; size = 4
_playerAC$ = -12					; size = 4
_this$ = -8						; size = 4
$T6 = -2						; size = 1
$T7 = -1						; size = 1
?SetCursorCmdsByAnalog@AircraftClass@@QAEXXZ PROC	; AircraftClass::SetCursorCmdsByAnalog
; _this$ = ecx

; 3314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	mov	eax, 11					; 0000000bH
	imul	eax, 28					; 0000001cH
	mov	cl, BYTE PTR ?IO@@3VSIMLIB_IO_CLASS@@A[eax+12]
	mov	BYTE PTR $T7[ebp], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3321 : 	if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == false) || (IO.AnalogIsUsed(AXIS_CURSOR_Y) == false))

	movzx	edx, BYTE PTR $T7[ebp]
	test	edx, edx
	je	SHORT $LN16@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	mov	eax, 12					; 0000000cH
	imul	eax, 28					; 0000001cH
	mov	cl, BYTE PTR ?IO@@3VSIMLIB_IO_CLASS@@A[eax+12]
	mov	BYTE PTR $T6[ebp], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3321 : 	if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == false) || (IO.AnalogIsUsed(AXIS_CURSOR_Y) == false))

	movzx	edx, BYTE PTR $T6[ebp]
	test	edx, edx
	jne	SHORT $LN17@SetCursorC
$LN16@SetCursorC:

; 3322 : 		return;  // shouldn't be needed but this code only makes sense if both are mapped

	jmp	$LN18@SetCursorC
$LN17@SetCursorC:

; 3323 : 	
; 3324 : 	int xValue = IO.GetAxisValue(AXIS_CURSOR_X);

	push	11					; 0000000bH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::GetAxisValue
	mov	DWORD PTR _xValue$[ebp], eax

; 3325 : 	int yValue = IO.GetAxisValue(AXIS_CURSOR_Y);

	push	12					; 0000000cH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::GetAxisValue
	mov	DWORD PTR _yValue$[ebp], eax

; 3326 : 	
; 3327 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3328 : 	if (playerAC != NULL && playerAC->IsSetFlag(MOTION_OWNSHIP)){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN18@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN26@SetCursorC
	mov	DWORD PTR tv261[ebp], 1
	jmp	SHORT $LN24@SetCursorC
$LN26@SetCursorC:
	mov	DWORD PTR tv261[ebp], 0
$LN24@SetCursorC:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3328 : 	if (playerAC != NULL && playerAC->IsSetFlag(MOTION_OWNSHIP)){

	cmp	DWORD PTR tv261[ebp], 0
	je	$LN18@SetCursorC

; 3329 : 		if ((xValue != 0) || (yValue != 0)){

	cmp	DWORD PTR _xValue$[ebp], 0
	jne	SHORT $LN13@SetCursorC
	cmp	DWORD PTR _yValue$[ebp], 0
	je	$LN14@SetCursorC
$LN13@SetCursorC:

; 3330 : 			// we're moving
; 3331 : 			if(g_bRealisticAvionics){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN12@SetCursorC

; 3332 : 
; 3333 : 				RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$4[ebp], eax

; 3334 : 				LaserPodClass* laserPod = (LaserPodClass* )FindLaserPod(playerAC);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	push	ecx
	call	?FindLaserPod@@YAPAVSensorClass@@PAVSimMoverClass@@@Z ; FindLaserPod
	add	esp, 4
	mov	DWORD PTR _laserPod$3[ebp], eax

; 3335 : 				MaverickDisplayClass* mavDisplay = NULL;

	mov	DWORD PTR _mavDisplay$5[ebp], 0

; 3336 : 				HarmTargetingPod *theHTS = (HarmTargetingPod*)FindSensor(playerAC, SensorClass::HTS);

	push	4
	mov	edx, DWORD PTR _playerAC$[ebp]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theHTS$2[ebp], eax

; 3338 : 				if(playerAC->Sms->curWeaponType == wtAgm65 && playerAC->Sms->curWeapon){

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+148], 4
	jne	SHORT $LN11@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+940]
	cmp	DWORD PTR [eax+164], 0
	je	SHORT $LN30@SetCursorC
	mov	DWORD PTR tv262[ebp], 1
	jmp	SHORT $LN28@SetCursorC
$LN30@SetCursorC:
	mov	DWORD PTR tv262[ebp], 0
$LN28@SetCursorC:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3338 : 				if(playerAC->Sms->curWeaponType == wtAgm65 && playerAC->Sms->curWeapon){

	movzx	ecx, BYTE PTR tv262[ebp]
	test	ecx, ecx
	je	SHORT $LN11@SetCursorC

; 3339 : 					mavDisplay = (MaverickDisplayClass*)((MissileClass*)playerAC->Sms->GetCurrentWeapon())->display;

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR [eax+712]
	mov	DWORD PTR _mavDisplay$5[ebp], ecx
$LN11@SetCursorC:

; 3343 : 					(theHTS && playerAC->GetSOI() == SimVehicleClass::SOI_WEAPON))

	cmp	DWORD PTR _theRadar$4[ebp], 0
	je	SHORT $LN8@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	mov	edx, DWORD PTR _theRadar$4[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	je	SHORT $LN34@SetCursorC
	mov	DWORD PTR tv266[ebp], 1
	jmp	SHORT $LN32@SetCursorC
$LN34@SetCursorC:
	mov	DWORD PTR tv266[ebp], 0
$LN32@SetCursorC:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3343 : 					(theHTS && playerAC->GetSOI() == SimVehicleClass::SOI_WEAPON))

	cmp	DWORD PTR tv266[ebp], 0
	jne	$LN9@SetCursorC
$LN8@SetCursorC:
	cmp	DWORD PTR _mavDisplay$5[ebp], 0
	je	SHORT $LN7@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	mov	ecx, DWORD PTR _mavDisplay$5[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 1
	je	SHORT $LN38@SetCursorC
	mov	DWORD PTR tv269[ebp], 1
	jmp	SHORT $LN36@SetCursorC
$LN38@SetCursorC:
	mov	DWORD PTR tv269[ebp], 0
$LN36@SetCursorC:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3343 : 					(theHTS && playerAC->GetSOI() == SimVehicleClass::SOI_WEAPON))

	cmp	DWORD PTR tv269[ebp], 0
	jne	SHORT $LN9@SetCursorC
$LN7@SetCursorC:
	cmp	DWORD PTR _laserPod$3[ebp], 0
	je	SHORT $LN6@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	mov	eax, DWORD PTR _laserPod$3[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN42@SetCursorC
	mov	DWORD PTR tv272[ebp], 1
	jmp	SHORT $LN40@SetCursorC
$LN42@SetCursorC:
	mov	DWORD PTR tv272[ebp], 0
$LN40@SetCursorC:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3343 : 					(theHTS && playerAC->GetSOI() == SimVehicleClass::SOI_WEAPON))

	cmp	DWORD PTR tv272[ebp], 0
	jne	SHORT $LN9@SetCursorC
$LN6@SetCursorC:
	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN5@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	je	SHORT $LN46@SetCursorC
	mov	DWORD PTR tv275[ebp], 1
	jmp	SHORT $LN44@SetCursorC
$LN46@SetCursorC:
	mov	DWORD PTR tv275[ebp], 0
$LN44@SetCursorC:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3343 : 					(theHTS && playerAC->GetSOI() == SimVehicleClass::SOI_WEAPON))

	cmp	DWORD PTR tv275[ebp], 0
	jne	SHORT $LN9@SetCursorC
$LN5@SetCursorC:
	cmp	DWORD PTR _theHTS$2[ebp], 0
	je	SHORT $LN10@SetCursorC
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simveh.h

; 64   : 	SOI GetSOI(void)	{return curSOI;};	//MI

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+724]
	mov	DWORD PTR $T1[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3343 : 					(theHTS && playerAC->GetSOI() == SimVehicleClass::SOI_WEAPON))

	cmp	DWORD PTR $T1[ebp], 2
	jne	SHORT $LN10@SetCursorC
$LN9@SetCursorC:

; 3344 : 				{
; 3345 : 					FCC->cursorXCmd = xValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR _xValue$[ebp]
	mov	DWORD PTR [ecx+196], edx

; 3346 : 					FCC->cursorYCmd = yValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR _yValue$[ebp]
	mov	DWORD PTR [ecx+200], edx
	jmp	SHORT $LN4@SetCursorC
$LN10@SetCursorC:

; 3347 : 				}
; 3348 : 				
; 3349 : 				else if(FCC->IsSOI)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+464]
	test	edx, edx
	je	SHORT $LN4@SetCursorC

; 3350 : 				{
; 3351 : 					FCC->HSDCursorXCmd = xValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR _xValue$[ebp]
	mov	DWORD PTR [ecx+204], edx

; 3352 : 					FCC->HSDCursorYCmd = yValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR _yValue$[ebp]
	mov	DWORD PTR [ecx+208], edx
$LN4@SetCursorC:

; 3353 : 				}
; 3354 : 			}
; 3355 : 			else

	jmp	SHORT $LN2@SetCursorC
$LN12@SetCursorC:

; 3356 : 			{
; 3357 : 				FCC->cursorXCmd = xValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR _xValue$[ebp]
	mov	DWORD PTR [ecx+196], edx

; 3358 : 				FCC->cursorYCmd = yValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR _yValue$[ebp]
	mov	DWORD PTR [ecx+200], edx
$LN2@SetCursorC:

; 3359 : 			}
; 3360 : 		}
; 3361 : 		else  // we're not moving

	jmp	SHORT $LN18@SetCursorC
$LN14@SetCursorC:

; 3362 : 		{
; 3363 : 			FCC->cursorXCmd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+196], 0

; 3364 : 			FCC->cursorYCmd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	DWORD PTR [eax+200], 0

; 3365 : 			FCC->HSDCursorXCmd = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	DWORD PTR [edx+204], 0

; 3366 : 			FCC->HSDCursorYCmd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR [ecx+208], 0
$LN18@SetCursorC:

; 3367 : 		}
; 3368 : 	}
; 3369 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCursorCmdsByAnalog@AircraftClass@@QAEXXZ ENDP	; AircraftClass::SetCursorCmdsByAnalog
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
$T11 = -28						; size = 4
$T12 = -24						; size = 4
_object$ = -20						; size = 4
_i$ = -16						; size = 4
_sensor$ = -12						; size = 4
_this$ = -8						; size = 4
$T13 = -2						; size = 1
$T14 = -1						; size = 1
?RunSensors@AircraftClass@@QAEXXZ PROC			; AircraftClass::RunSensors
; _this$ = ecx

; 2481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 2482 : 	SimObjectType* object;
; 2483 : 	SensorClass *sensor = NULL;

	mov	DWORD PTR _sensor$[ebp], 0

; 2484 : 	int i;
; 2485 : 
; 2486 : 	// RV - MASTERFIX - if It's a player and there is no more the player entity, avoid all this stuff
; 2487 : 	if ((!isDigital) && (!SimDriver.GetPlayerAircraft())) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	jne	SHORT $LN17@RunSensors
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	jne	SHORT $LN17@RunSensors
	jmp	$LN18@RunSensors
$LN17@RunSensors:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	mov	ecx, 11					; 0000000bH
	imul	ecx, 28					; 0000001cH
	mov	dl, BYTE PTR ?IO@@3VSIMLIB_IO_CLASS@@A[ecx+12]
	mov	BYTE PTR $T14[ebp], dl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2491 : 	if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == true) && (IO.AnalogIsUsed(AXIS_CURSOR_Y) == true)){

	movzx	eax, BYTE PTR $T14[ebp]
	cmp	eax, 1
	jne	SHORT $LN16@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	mov	ecx, 12					; 0000000cH
	imul	ecx, 28					; 0000001cH
	mov	dl, BYTE PTR ?IO@@3VSIMLIB_IO_CLASS@@A[ecx+12]
	mov	BYTE PTR $T13[ebp], dl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2491 : 	if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == true) && (IO.AnalogIsUsed(AXIS_CURSOR_Y) == true)){

	movzx	eax, BYTE PTR $T13[ebp]
	cmp	eax, 1
	jne	SHORT $LN16@RunSensors

; 2492 : 		if (!isDigital || autopilotType == CombatAP){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	je	SHORT $LN14@RunSensors
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+968], 2
	jne	SHORT $LN16@RunSensors
$LN14@RunSensors:

; 2493 : 			SetCursorCmdsByAnalog();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCursorCmdsByAnalog@AircraftClass@@QAEXXZ ; AircraftClass::SetCursorCmdsByAnalog
$LN16@RunSensors:

; 2494 : 		}
; 2495 : 	}
; 2496 : 
; 2497 : 	// Now run all our sensors
; 2498 : 	for (i=0; i<numSensors; i++){		

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@RunSensors
$LN12@RunSensors:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@RunSensors:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+652]
	jge	$LN18@RunSensors

; 2499 : 		//if we are in the middle of resetting our sensors bail
; 2500 : 		if( numSensors){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+652], 0
	je	SHORT $LN10@RunSensors

; 2501 : 			sensor = sensorArray[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _sensor$[ebp], ecx

; 2502 : 		}
; 2503 : 		else {

	jmp	SHORT $LN9@RunSensors
$LN10@RunSensors:

; 2504 : 			return;

	jmp	$LN18@RunSensors
$LN9@RunSensors:

; 2505 : 		}
; 2506 : 		// Do player control processing
; 2507 : 		//if (!isDigital){
; 2508 : 		if (!isDigital || autopilotType == CombatAP)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	SHORT $LN7@RunSensors
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+968], 2
	jne	SHORT $LN8@RunSensors
$LN7@RunSensors:

; 2509 : 		{
; 2510 : 			sensor->ExecModes(FCC->designateCmd, FCC->dropTrackCmd);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	movsx	eax, BYTE PTR [edx+185]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	movsx	eax, BYTE PTR [edx+184]
	push	eax
	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 2511 : 			sensor->UpdateState(FCC->cursorXCmd, FCC->cursorYCmd);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	eax, DWORD PTR [edx+200]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	eax, DWORD PTR [edx+196]
	push	eax
	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
$LN8@RunSensors:

; 2527 : 		){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+968], 2
	jne	SHORT $LN6@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 46   : 	SimObjectType* CurrentTarget(void)	{ return lockedTarget; };

	mov	edx, DWORD PTR _sensor$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T12[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2527 : 		){

	cmp	DWORD PTR $T12[ebp], 0
	jne	SHORT $LN6@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 36   : 	SensorType	Type(void)			{ return sensorType; }

	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T11[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2527 : 		){

	cmp	DWORD PTR $T11[ebp], 5
	je	SHORT $LN6@RunSensors
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+656], 0
	je	SHORT $LN6@RunSensors

; 2528 : 			sensor->SetDesiredTarget( targetPtr );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _sensor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN6@RunSensors:

; 2529 : 		}
; 2530 : 		// END OF ADDED SECTION
; 2531 : 
; 2532 : 		// Run the sensor model
; 2533 : 		object = sensor->Exec(targetList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	push	edx
	mov	eax, DWORD PTR _sensor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	mov	DWORD PTR _object$[ebp], eax

; 2536 : 		if (object && sensor->Type() == SensorClass::Visual && sensor->Type() != SensorClass::TargetingPod){

	cmp	DWORD PTR _object$[ebp], 0
	je	SHORT $LN5@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 36   : 	SensorType	Type(void)			{ return sensorType; }

	mov	ecx, DWORD PTR _sensor$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T10[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2536 : 		if (object && sensor->Type() == SensorClass::Visual && sensor->Type() != SensorClass::TargetingPod){

	cmp	DWORD PTR $T10[ebp], 3
	jne	SHORT $LN5@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 36   : 	SensorType	Type(void)			{ return sensorType; }

	mov	eax, DWORD PTR _sensor$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T9[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2536 : 		if (object && sensor->Type() == SensorClass::Visual && sensor->Type() != SensorClass::TargetingPod){

	cmp	DWORD PTR $T9[ebp], 5
	je	SHORT $LN5@RunSensors

; 2537 : 			SetTarget(object);

	mov	edx, DWORD PTR _object$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
$LN5@RunSensors:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 36   : 	SensorType	Type(void)			{ return sensorType; }

	mov	eax, DWORD PTR _sensor$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T8[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2543 : 		if (sensor->Type() == SensorClass::Radar)

	cmp	DWORD PTR $T8[ebp], 1
	jne	$LN4@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T7[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2550 : 			){

	cmp	DWORD PTR $T7[ebp], 5
	je	SHORT $LN3@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T6[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2550 : 			){

	cmp	DWORD PTR $T6[ebp], 13			; 0000000dH
	je	SHORT $LN3@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T5[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2550 : 			){

	cmp	DWORD PTR $T5[ebp], 6
	je	SHORT $LN3@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T4[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2550 : 			){

	cmp	DWORD PTR $T4[ebp], 8
	je	SHORT $LN3@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T3[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2550 : 			){

	cmp	DWORD PTR $T3[ebp], 7
	je	SHORT $LN3@RunSensors

; 2551 : 				// Our system target becomes our radar target
; 2552 : 				SetTarget(object);

	mov	edx, DWORD PTR _object$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget

; 2554 : 			else if (PlayerOptions.GetAvionicsType() == ATEasy && FCC->GetSubMode() == FireControlComputer::CCIP){

	jmp	SHORT $LN4@RunSensors
$LN3@RunSensors:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	mov	eax, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+64
	mov	DWORD PTR $T2[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2554 : 			else if (PlayerOptions.GetAvionicsType() == ATEasy && FCC->GetSubMode() == FireControlComputer::CCIP){

	cmp	DWORD PTR $T2[ebp], 0
	jne	SHORT $LN4@RunSensors
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 281  : 	FCCSubMode GetSubMode (void) {return (subMode);};

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR $T1[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2554 : 			else if (PlayerOptions.GetAvionicsType() == ATEasy && FCC->GetSubMode() == FireControlComputer::CCIP){

	cmp	DWORD PTR $T1[ebp], 7
	jne	SHORT $LN4@RunSensors

; 2555 : 				// Let easy mode players get a TD box even in CCIP
; 2556 : 				SetTarget(object);

	mov	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
$LN4@RunSensors:

; 2557 : 			}
; 2558 : 		}
; 2559 : 	}

	jmp	$LN12@RunSensors
$LN18@RunSensors:

; 2560 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RunSensors@AircraftClass@@QAEXXZ ENDP			; AircraftClass::RunSensors
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?ToggleBetty@AircraftClass@@QAEXXZ PROC			; AircraftClass::ToggleBetty
; _this$ = ecx

; 3232 : void AircraftClass::ToggleBetty(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3233 : 	playBetty = !playBetty;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1516]
	test	ecx, ecx
	jne	SHORT $LN3@ToggleBett
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@ToggleBett
$LN3@ToggleBett:
	mov	DWORD PTR tv68[ebp], 0
$LN4@ToggleBett:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv68[ebp]
	mov	BYTE PTR [edx+1516], al

; 3234 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleBetty@AircraftClass@@QAEXXZ ENDP			; AircraftClass::ToggleBetty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_theRwr$ = -8						; size = 4
_this$ = -4						; size = 4
?IncEWSProg@AircraftClass@@QAEXXZ PROC			; AircraftClass::IncEWSProg
; _this$ = ecx

; 3206 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3207 : 	PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(this, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$[ebp], eax

; 3208 : 
; 3209 : 	if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN2@IncEWSProg

; 3210 : 	{
; 3211 : 		theRwr->InEWSLoop = FALSE;

	mov	ecx, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [ecx+600], 0

; 3212 : 		theRwr->ReleaseManual = FALSE;

	mov	edx, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [edx+604], 0
$LN2@IncEWSProg:

; 3213 : 	}
; 3214 : 
; 3215 :     if(EWSProgNum < 3)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1500], 3
	jae	SHORT $LN3@IncEWSProg

; 3216 : 		EWSProgNum++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1500]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1500], edx
$LN3@IncEWSProg:

; 3217 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncEWSProg@AircraftClass@@QAEXXZ ENDP			; AircraftClass::IncEWSProg
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_theRwr$ = -8						; size = 4
_this$ = -4						; size = 4
?DecEWSProg@AircraftClass@@QAEXXZ PROC			; AircraftClass::DecEWSProg
; _this$ = ecx

; 3220 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3221 : 	PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(this, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$[ebp], eax

; 3222 : 
; 3223 : 	if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN2@DecEWSProg

; 3224 : 	{
; 3225 : 		theRwr->InEWSLoop = FALSE;

	mov	ecx, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [ecx+600], 0

; 3226 : 		theRwr->ReleaseManual = FALSE;

	mov	edx, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [edx+604], 0
$LN2@DecEWSProg:

; 3227 : 	} 
; 3228 : 
; 3229 : 	if(EWSProgNum > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1500], 0
	jbe	SHORT $LN3@DecEWSProg

; 3230 : 		EWSProgNum--;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1500]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1500], edx
$LN3@DecEWSProg:

; 3231 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecEWSProg@AircraftClass@@QAEXXZ ENDP			; AircraftClass::DecEWSProg
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv76 = -12						; size = 4
_this$ = -8						; size = 4
_theRwr$ = -4						; size = 4
?DecEWSPGM@AircraftClass@@QAEXXZ PROC			; AircraftClass::DecEWSPGM
; _this$ = ecx

; 3169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3170 : 	PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(this, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$[ebp], eax

; 3171 : 
; 3172 :     switch (EWSPgm) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1496]
	mov	DWORD PTR tv76[ebp], edx
	cmp	DWORD PTR tv76[ebp], 4
	ja	$LN11@DecEWSPGM
	mov	eax, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN13@DecEWSPGM[eax*4]
$LN8@DecEWSPGM:

; 3173 : 	{
; 3174 :     case Off:
; 3175 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN7@DecEWSPGM

; 3176 : 		{
; 3177 : 			theRwr->InEWSLoop = FALSE;

	mov	ecx, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [ecx+600], 0

; 3178 : 			theRwr->ReleaseManual = FALSE;

	mov	edx, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [edx+604], 0
$LN7@DecEWSPGM:

; 3179 : 		}
; 3180 : 		break;

	jmp	SHORT $LN11@DecEWSPGM
$LN6@DecEWSPGM:

; 3181 :     case Auto:
; 3182 : 		EWSPgm = Semi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1496], 3

; 3183 : 		break;

	jmp	SHORT $LN11@DecEWSPGM
$LN5@DecEWSPGM:

; 3184 :     case Semi:
; 3185 : 		EWSPgm = Man;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1496], 2

; 3186 : 		break;

	jmp	SHORT $LN11@DecEWSPGM
$LN4@DecEWSPGM:

; 3187 : 	case Man:
; 3188 : 		EWSPgm = Stby;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1496], 1

; 3189 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN3@DecEWSPGM

; 3190 : 		{
; 3191 : 			theRwr->InEWSLoop = FALSE;

	mov	eax, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [eax+600], 0

; 3192 : 			theRwr->ReleaseManual = FALSE;

	mov	ecx, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [ecx+604], 0
$LN3@DecEWSPGM:

; 3193 : 		}
; 3194 : 		break;

	jmp	SHORT $LN11@DecEWSPGM
$LN2@DecEWSPGM:

; 3195 : 	case Stby:
; 3196 : 		EWSPgm = Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1496], 0

; 3197 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN11@DecEWSPGM

; 3198 : 		{
; 3199 : 			theRwr->InEWSLoop = FALSE;

	mov	eax, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [eax+600], 0

; 3200 : 			theRwr->ReleaseManual = FALSE;

	mov	ecx, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [ecx+604], 0
$LN11@DecEWSPGM:

; 3201 : 		}
; 3202 : 		break;
; 3203 :     }
; 3204 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN13@DecEWSPGM:
	DD	$LN8@DecEWSPGM
	DD	$LN2@DecEWSPGM
	DD	$LN4@DecEWSPGM
	DD	$LN5@DecEWSPGM
	DD	$LN6@DecEWSPGM
?DecEWSPGM@AircraftClass@@QAEXXZ ENDP			; AircraftClass::DecEWSPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv76 = -12						; size = 4
_this$ = -8						; size = 4
_theRwr$ = -4						; size = 4
?IncEWSPGM@AircraftClass@@QAEXXZ PROC			; AircraftClass::IncEWSPGM
; _this$ = ecx

; 3136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3137 : 	PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(this, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$[ebp], eax

; 3138 : 
; 3139 :     switch (EWSPgm) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1496]
	mov	DWORD PTR tv76[ebp], edx
	cmp	DWORD PTR tv76[ebp], 3
	ja	SHORT $LN10@IncEWSPGM
	mov	eax, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN12@IncEWSPGM[eax*4]
$LN7@IncEWSPGM:

; 3140 : 	{
; 3141 :     case Off:
; 3142 : 		EWSPgm = Stby;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1496], 1

; 3143 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN6@IncEWSPGM

; 3144 : 		{
; 3145 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [edx+600], 0

; 3146 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [eax+604], 0
$LN6@IncEWSPGM:

; 3147 : 		}
; 3148 : 		break;

	jmp	SHORT $LN10@IncEWSPGM
$LN5@IncEWSPGM:

; 3149 : 	case Stby:
; 3150 : 		EWSPgm = Man;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1496], 2

; 3151 : 		if(theRwr)

	cmp	DWORD PTR _theRwr$[ebp], 0
	je	SHORT $LN4@IncEWSPGM

; 3152 : 		{
; 3153 : 			theRwr->InEWSLoop = FALSE;

	mov	edx, DWORD PTR _theRwr$[ebp]
	mov	BYTE PTR [edx+600], 0

; 3154 : 			theRwr->ReleaseManual = FALSE;

	mov	eax, DWORD PTR _theRwr$[ebp]
	mov	DWORD PTR [eax+604], 0
$LN4@IncEWSPGM:

; 3155 : 		}
; 3156 : 		break;

	jmp	SHORT $LN10@IncEWSPGM
$LN3@IncEWSPGM:

; 3157 : 	case Man:
; 3158 : 		EWSPgm = Semi;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1496], 3

; 3159 : 		break;

	jmp	SHORT $LN10@IncEWSPGM
$LN2@IncEWSPGM:

; 3160 :     case Semi:
; 3161 : 		EWSPgm = Auto;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1496], 4
$LN10@IncEWSPGM:

; 3162 : 		break;
; 3163 :     case Auto: // cant go any further
; 3164 : 	break;
; 3165 :     }
; 3166 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@IncEWSPGM:
	DD	$LN7@IncEWSPGM
	DD	$LN5@IncEWSPGM
	DD	$LN3@IncEWSPGM
	DD	$LN2@IncEWSPGM
?IncEWSPGM@AircraftClass@@QAEXXZ ENDP			; AircraftClass::IncEWSPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?DecMainPower@AircraftClass@@QAEXXZ PROC		; AircraftClass::DecMainPower
; _this$ = ecx

; 3111 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3112 :     switch (mainPower) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1484]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN3@DecMainPow
	cmp	DWORD PTR tv65[ebp], 2
	je	$LN1@DecMainPow
	jmp	$LN7@DecMainPow

; 3113 :     case MainPowerOff:
; 3114 : 	break;

	jmp	$LN7@DecMainPow
$LN3@DecMainPow:

; 3115 :     case MainPowerBatt:
; 3116 : 	mainPower = MainPowerOff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1484], 0

; 3117 : 	//MI
; 3118 : 	if(!g_bINS)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	jne	$LN2@DecMainPow
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 210  : 	void INSOff(INSAlignFlags fl) { INSFlags &= ~fl; };

	mov	ecx, 128				; 00000080H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
	mov	ecx, 256				; 00000100H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
	mov	ecx, 1024				; 00000400H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
	mov	ecx, 2048				; 00000800H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
	mov	ecx, 4096				; 00001000H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
	mov	ecx, 8192				; 00002000H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3126 : 		GSValid = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+836], 0

; 3127 : 		LOCValid = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+837], 0
$LN2@DecMainPow:

; 3128 : 	}
; 3129 : 	break;

	jmp	SHORT $LN7@DecMainPow
$LN1@DecMainPow:

; 3130 :     case MainPowerMain:
; 3131 : 	mainPower = MainPowerBatt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1484], 1
$LN7@DecMainPow:

; 3132 : 	break;
; 3133 :     }
; 3134 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecMainPower@AircraftClass@@QAEXXZ ENDP		; AircraftClass::DecMainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?IncMainPower@AircraftClass@@QAEXXZ PROC		; AircraftClass::IncMainPower
; _this$ = ecx

; 3085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3086 :     switch (mainPower) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1484]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN4@IncMainPow
	cmp	DWORD PTR tv65[ebp], 1
	je	$LN2@IncMainPow
	jmp	$LN7@IncMainPow
$LN4@IncMainPow:

; 3087 :     case MainPowerOff:
; 3088 : 	mainPower = MainPowerBatt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1484], 1

; 3089 : 	//MI
; 3090 : 	if(!g_bINS)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	jne	$LN3@IncMainPow
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 2048				; 00000800H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 4096				; 00001000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 8192				; 00002000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3098 : 		GSValid = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+836], 1

; 3099 : 		LOCValid = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+837], 1
$LN3@IncMainPow:

; 3100 : 	}
; 3101 : 	break;

	jmp	SHORT $LN7@IncMainPow
$LN2@IncMainPow:

; 3102 :     case MainPowerBatt:
; 3103 : 	mainPower = MainPowerMain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1484], 2
$LN7@IncMainPow:

; 3104 : 	break;
; 3105 :     case MainPowerMain: // cant go any further
; 3106 : 	break;
; 3107 :     }
; 3108 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncMainPower@AircraftClass@@QAEXXZ ENDP		; AircraftClass::IncMainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
$T8 = -28						; size = 4
$T9 = -24						; size = 4
tv249 = -20						; size = 4
$T10 = -16						; size = 4
tv76 = -12						; size = 4
$T11 = -8						; size = 4
_this$ = -4						; size = 4
?PreFlight@AircraftClass@@QAEXXZ PROC			; AircraftClass::PreFlight
; _this$ = ecx

; 2911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2912 : 	RALTCoolTime = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1008], xmm0

; 2913 : 	RALTStatus = AircraftClass::RaltStatus::RON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1004], 2

; 2914 :     af->ClearEngineFlag(AirframeClass::MasterFuelOff);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR $T11[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1072 : 	void ClearEngineFlag(EngineFlags ef) { engineFlags &= ~ ef; };

	mov	ecx, 2
	not	ecx
	mov	edx, DWORD PTR $T11[ebp]
	and	ecx, DWORD PTR [edx+1676]
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR [eax+1676], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2915 :     af->SetFuelSwitch(AirframeClass::FS_NORM);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T7[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1081 : 	void SetFuelSwitch(FuelSwitch fs) { fuelSwitch = fs; };

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [eax+1680], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2916 :     af->SetFuelPump (AirframeClass::FP_NORM);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T6[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1090 : 	void SetFuelPump(FuelPump fp) { fuelPump = fp; };

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR [eax+1684], 1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2917 :     af->SetAirSource(AirframeClass::AS_NORM);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T5[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1111 : 	void SetAirSource(AirSource as) { airSource = as; };

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [eax+1800], 1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 0
	jl	SHORT $LN24@PreFlight
	cmp	DWORD PTR tv76[ebp], 2
	jle	SHORT $LN23@PreFlight
	jmp	SHORT $LN24@PreFlight
$LN23@PreFlight:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR $T10[ebp], edx
	jmp	SHORT $LN26@PreFlight
$LN24@PreFlight:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	mov	DWORD PTR $T10[ebp], 0
$LN26@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2922 : 	){

	cmp	DWORD PTR $T10[ebp], 0
	je	$LN12@PreFlight
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN12@PreFlight
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN12@PreFlight

; 2923 : 		af->canopyState = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	BYTE PTR [eax+1588], 1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h

; 108  : 	float GetLightLevel()						{ return Ambient + Diffuse; };

	movss	xmm0, DWORD PTR ?TheTimeOfDay@@3VCTimeOfDay@@A+220
	addss	xmm0, DWORD PTR ?TheTimeOfDay@@3VCTimeOfDay@@A+224
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2924 : 		if(TheTimeOfDay.GetLightLevel() < 0.65f){

	movss	xmm1, DWORD PTR __real@3f266666
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@PreFlight
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+604], 127		; 0000007fH
	jle	SHORT $LN30@PreFlight
	mov	edx, 127				; 0000007fH
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	DWORD PTR [edx+ecx], 1
	mov	edx, 127				; 0000007fH
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR [edx+ecx], 1
$LN30@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2926 : 			SetAcStatusBits(ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
$LN11@PreFlight:

; 2927 : 		}
; 2928 : 	}
; 2929 : 	else{

	jmp	SHORT $LN10@PreFlight
$LN12@PreFlight:

; 2930 : 		af->canopyState = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	BYTE PTR [eax+1588], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+604], 127		; 0000007fH
	jle	SHORT $LN33@PreFlight
	mov	edx, 127				; 0000007fH
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	DWORD PTR [edx+ecx], 0
	mov	edx, 127				; 0000007fH
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR [edx+ecx], 1
$LN33@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2932 : 		ClearAcStatusBits(ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN10@PreFlight:

; 2933 : 	}
; 2934 :     af->QuickEngineStart();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?QuickEngineStart@AirframeClass@@QAEXXZ	; AirframeClass::QuickEngineStart

; 2935 : 	//Cobra moved the lights here.  If we start on the ground we can have lights on :)
; 2936 : 	// sfr: check light stuff here
; 2937 :     if (OnGround()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN9@PreFlight

; 2938 : 		af->TEFTakeoff();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?TEFTakeoff@AirframeClass@@QAEXXZ	; AirframeClass::TEFTakeoff

; 2939 : 		af->LEFTakeoff();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?LEFTakeoff@AirframeClass@@QAEXXZ	; AirframeClass::LEFTakeoff
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 186  : 	void ExtlOn(ExtlLightFlags fl) { SetAcStatusBits(fl); }

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2946 : 	else {

	jmp	SHORT $LN50@PreFlight
$LN9@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 187  : 	void ExtlOff(ExtlLightFlags fl){ ClearAcStatusBits(fl); }

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN50@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2954 : 	SeatArmed = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1052], 1

; 2955 : 	mainPower = MainPowerMain;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1484], 2

; 2956 : 	currentPower = PowerNonEssentialBus;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1488], 5

; 2957 : 	EWSPgm = Man;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1496], 2

; 2958 : 	//ATARIBABY ground check added - Removed by JPG - was causing AI problems
; 2959 : 	//if(Sms)
; 2960 : 	//	Sms->SetMasterArm(SMSBaseClass::Arm);	//set it to arm
; 2961 : 	//ATARIBABY Fixed second try to test    
; 2962 : 	if(Sms)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	SHORT $LN56@PreFlight
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T4[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2964 : 		if (this == SimDriver.GetPlayerEntity() && OnGround())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR $T4[ebp]
	jne	SHORT $LN6@PreFlight
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN6@PreFlight

; 2965 : 			Sms->SetMasterArm(SMSBaseClass::Safe);   //if palyer and on ground then set it to safe

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	DWORD PTR $T3[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+8], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2966 : 		else

	jmp	SHORT $LN56@PreFlight
$LN6@PreFlight:

; 2967 : 			Sms->SetMasterArm(SMSBaseClass::Arm);    //set it to arm

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	DWORD PTR $T2[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+8], 2
$LN56@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 748  : 	int GetDataLinkCapLevel() { return auxaeroData->dataLinkCapLevel; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2628]
	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2971 : 	if (af->GetDataLinkCapLevel() > 0) 

	cmp	DWORD PTR $T1[ebp], 0
	jle	SHORT $LN4@PreFlight
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 509  : 	void PowerOn (AvionicsPowerFlags fl) { powerFlags |= fl; };

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1480]
	or	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1480], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2975 : 	else 

	jmp	SHORT $LN64@PreFlight
$LN4@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 509  : 	void PowerOn (AvionicsPowerFlags fl) { powerFlags |= fl; };

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1480]
	or	eax, 16777183				; 00ffffdfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1480], eax

; 510  : 	int HasPower(AvionicsPowerFlags fl);
; 511  : 	void PowerOff (AvionicsPowerFlags fl) { powerFlags &= ~fl; };

	mov	edx, 32					; 00000020H
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+1480]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1480], edx
$LN64@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2983 : 	animStrobeTimer=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1840], 0

; 2984 : 	animWingFlashTimer=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1844], 0

; 2985 : 	MPWingFlashTimer=0;//martinv

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1848], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+768]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 210  : 	void INSOff(INSAlignFlags fl) { INSFlags &= ~fl; };

	mov	edx, 1
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+768]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+768], edx
	mov	edx, 2
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+768]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+768], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2991 : 	if(!g_bINS)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	jne	$LN82@PreFlight
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, 4096				; 00001000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
$LN82@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3000 : 	HasAligned = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+781], 1

; 3001 : 	INSStatus = 10;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+784], 10			; 0000000aH

; 3002 : 	INSAlignmentTimer = 480.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43f00000
	movss	DWORD PTR [edx+772], xmm0

; 3003 : 	INSLatDrift = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+788], xmm0

; 3004 : 	INSAlignmentStart = vuxGameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR [ecx+776], edx

; 3005 : 	BUPADIEnergy = 540.0F;	//9 minutes useable

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44070000
	movss	DWORD PTR [eax+832], xmm0

; 3006 : 	//Set the missile and threat volume
; 3007 : 	MissileVolume = 0;	//max vol

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+876], 0

; 3008 : 	ThreatVolume = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+880], 0

; 3009 : 	//Targeting Pod cooled
; 3010 : 	PodCooling = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+888], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR tv249[ebp], ecx
	cmp	DWORD PTR tv249[ebp], 0
	jl	SHORT $LN85@PreFlight
	cmp	DWORD PTR tv249[ebp], 2
	jle	SHORT $LN84@PreFlight
	jmp	SHORT $LN85@PreFlight
$LN84@PreFlight:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR $T9[ebp], edx
	jmp	SHORT $LN87@PreFlight
$LN85@PreFlight:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	mov	DWORD PTR $T9[ebp], 0
$LN87@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3027 : 	if(PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RAMP && OnGround())

	cmp	DWORD PTR $T9[ebp], 2
	je	SHORT $LN89@PreFlight
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN89@PreFlight

; 3028 : 		af->SetFlag(AirframeClass::NoseSteerOn);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T8[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	mov	eax, DWORD PTR $T8[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, 4194304				; 00400000H
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [edx+88], ecx
$LN89@PreFlight:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PreFlight@AircraftClass@@QAEXXZ ENDP			; AircraftClass::PreFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv85 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?CleanupLitePool@AircraftClass@@QAEXXZ PROC		; AircraftClass::CleanupLitePool
; _this$ = ecx

; 2809 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2810 : 	if(pLandLitePool) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1472], 0
	je	SHORT $LN2@CleanupLit

; 2811 : 		OTWDriver.RemoveObject(pLandLitePool);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1472]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 2812 : 		delete pLandLitePool;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1472]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@CleanupLit
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN5@CleanupLit
$LN4@CleanupLit:
	mov	DWORD PTR tv85[ebp], 0
$LN5@CleanupLit:

; 2813 : 		mInhibitLitePool = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1476], 1

; 2814 : 		pLandLitePool = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1472], 0
$LN2@CleanupLit:

; 2815 : 	}
; 2816 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupLitePool@AircraftClass@@QAEXXZ ENDP		; AircraftClass::CleanupLitePool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepSeatArm@AircraftClass@@QAEXXZ PROC			; AircraftClass::StepSeatArm
; _this$ = ecx

; 3077 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3078 : 	if(SeatArmed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1052]
	test	ecx, ecx
	je	SHORT $LN2@StepSeatAr

; 3079 : 		SeatArmed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1052], 0

; 3080 : 	else

	jmp	SHORT $LN3@StepSeatAr
$LN2@StepSeatAr:

; 3081 : 		SeatArmed = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1052], 1
$LN3@StepSeatAr:

; 3082 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepSeatArm@AircraftClass@@QAEXXZ ENDP			; AircraftClass::StepSeatArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetSMS@AircraftClass@@UAEPAVSMSBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSMS@AircraftClass@@UAEPAVSMSBaseClass@@XZ PROC	; AircraftClass::GetSMS, COMDAT
; _this$ = ecx

; 368  : 	virtual SMSBaseClass* GetSMS(void) { return (SMSBaseClass*)Sms; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+940]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSMS@AircraftClass@@UAEPAVSMSBaseClass@@XZ ENDP	; AircraftClass::GetSMS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetFCC@AircraftClass@@UAEPAVFireControlComputer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFCC@AircraftClass@@UAEPAVFireControlComputer@@XZ PROC ; AircraftClass::GetFCC, COMDAT
; _this$ = ecx

; 367  : 	virtual			FireControlComputer* GetFCC(void) { return FCC; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+936]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFCC@AircraftClass@@UAEPAVFireControlComputer@@XZ ENDP ; AircraftClass::GetFCC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_theEvent$ = 8						; size = 4
?ReceiveOrders@AircraftClass@@UAEXPAVFalconEvent@@@Z PROC ; AircraftClass::ReceiveOrders
; _this$ = ecx

; 2563 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2564 : 	if (theBrain){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $LN2@ReceiveOrd

; 2565 : 		theBrain->ReceiveOrders(theEvent);

	mov	ecx, DWORD PTR _theEvent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+672]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN2@ReceiveOrd:

; 2566 : 	}
; 2567 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ReceiveOrders@AircraftClass@@UAEXPAVFalconEvent@@@Z ENDP ; AircraftClass::ReceiveOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_send$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_diff$ = -12						; size = 4
_value$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetPowerOutput@AircraftClass@@QAEXM@Z PROC		; AircraftClass::SetPowerOutput
; _this$ = ecx

; 2821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2822 : 	int send = FALSE, diff, value;

	mov	DWORD PTR _send$[ebp], 0

; 2823 : 
; 2824 : 	if(af->auxaeroData->nEngines != 2 || af->rpm==af->rpm2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 2
	jne	SHORT $LN9@SetPowerOu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+1212]
	ucomiss	xmm0, DWORD PTR [eax+1216]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@SetPowerOu
$LN9@SetPowerOu:

; 2825 : 	{
; 2826 : 		// xmit as a single event
; 2827 : 		// RPM
; 2828 : 		value = FloatToInt32(af->rpm / 1.5f * 255.0f);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1212]
	divss	xmm0, DWORD PTR __real@3fc00000
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 182  :     fld dword ptr [x];

	fld	DWORD PTR $T3[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR $T3[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR $T3[ebp]

; 181  :   __asm {

	mov	DWORD PTR _value$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2833 : 		specialData.powerOutput = af->rpm;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1212]
	mov	DWORD PTR [edx+188], eax

; 2834 : 
; 2835 : 		diff = specialData.powerOutputNet - value;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+192]
	sub	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _diff$[ebp], edx

; 2836 : 
; 2837 : 		if ((diff < -g_nMPPowerXmitThreshold) || (diff > g_nMPPowerXmitThreshold) || 
; 2838 : 			 !value && specialData.powerOutputNet) // Xmit if RPM just changed to 0

	mov	eax, DWORD PTR ?g_nMPPowerXmitThreshold@@3HA ; g_nMPPowerXmitThreshold
	neg	eax
	cmp	DWORD PTR _diff$[ebp], eax
	jl	SHORT $LN7@SetPowerOu
	mov	ecx, DWORD PTR _diff$[ebp]
	cmp	ecx, DWORD PTR ?g_nMPPowerXmitThreshold@@3HA ; g_nMPPowerXmitThreshold
	jg	SHORT $LN7@SetPowerOu
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN8@SetPowerOu
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+192]
	test	eax, eax
	je	SHORT $LN8@SetPowerOu
$LN7@SetPowerOu:

; 2839 : 		{
; 2840 : 			//MonoPrint ("%08x SPO %f\n", this, powerOutput);
; 2841 : 
; 2842 : 			specialData.powerOutputNet = static_cast<uchar>(value);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [ecx+192], dl

; 2843 : 			send = TRUE;

	mov	DWORD PTR _send$[ebp], 1
$LN8@SetPowerOu:

; 2844 : 		}
; 2845 : 	/*// disabled me123
; 2846 : 		// ENGINE TEMP
; 2847 : 		value = FloatToInt32(engineTempOutput / 1.6f * 255.0f);
; 2848 : 
; 2849 : 		ShiAssert( value >= 0    );
; 2850 : 		ShiAssert( value <= 0xFF );
; 2851 : 
; 2852 : 		specialData.engineHeatOutput = engineTempOutput;
; 2853 : 
; 2854 : 		diff = specialData.engineHeatOutputNet - value;
; 2855 : 
; 2856 : 		if ((diff < -16) || (diff > 16))
; 2857 : 		{
; 2858 : 			//MonoPrint ("%08x SPO %f\n", this, powerOutput);
; 2859 : 
; 2860 : 			specialData.engineHeatOutputNet = static_cast<uchar>(value);
; 2861 : 			send = TRUE;
; 2862 : 		}
; 2863 : 	*/
; 2864 : 		// Send if one of the value changed
; 2865 : 		if (send)

	cmp	DWORD PTR _send$[ebp], 0
	je	SHORT $LN6@SetPowerOu

; 2866 : 			//MakeSimBaseDirty (DIRTY_SIM_POWER_OUTPUT, DDP[162].priority);
; 2867 : 			MakeSimBaseDirty (DIRTY_SIM_POWER_OUTPUT, SEND_SOMETIME);

	push	16					; 00000010H
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeSimBaseDirty@SimBaseClass@@QAEXW4Dirty_Sim_Base@@W4Dirtyness@@@Z ; SimBaseClass::MakeSimBaseDirty
$LN6@SetPowerOu:

; 2868 : 	}
; 2869 : 	else

	jmp	$LN2@SetPowerOu
$LN10@SetPowerOu:

; 2870 : 	{
; 2871 : 		// xmit rpm1
; 2872 : 		value = FloatToInt32(af->rpm / 1.5f * 255.0f);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1212]
	divss	xmm0, DWORD PTR __real@3fc00000
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 182  :     fld dword ptr [x];

	fld	DWORD PTR $T2[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR $T2[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR $T2[ebp]

; 181  :   __asm {

	mov	DWORD PTR _value$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2877 : 		specialData.powerOutput = af->rpm;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1212]
	mov	DWORD PTR [ecx+188], edx

; 2878 : 
; 2879 : 		diff = specialData.powerOutputNet - value;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+192]
	sub	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _diff$[ebp], ecx

; 2880 : 
; 2881 : 		if ((diff < -g_nMPPowerXmitThreshold) || (diff > g_nMPPowerXmitThreshold) ||
; 2882 : 			 !value && specialData.powerOutputNet) // Xmit if RPM just changed to 0

	mov	edx, DWORD PTR ?g_nMPPowerXmitThreshold@@3HA ; g_nMPPowerXmitThreshold
	neg	edx
	cmp	DWORD PTR _diff$[ebp], edx
	jl	SHORT $LN3@SetPowerOu
	mov	eax, DWORD PTR _diff$[ebp]
	cmp	eax, DWORD PTR ?g_nMPPowerXmitThreshold@@3HA ; g_nMPPowerXmitThreshold
	jg	SHORT $LN3@SetPowerOu
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN4@SetPowerOu
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+192]
	test	edx, edx
	je	SHORT $LN4@SetPowerOu
$LN3@SetPowerOu:

; 2883 : 		{
; 2884 : 
; 2885 : 			specialData.powerOutputNet = static_cast<uchar>(value);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [eax+192], cl

; 2886 : 			MakeSimBaseDirty (DIRTY_SIM_POWER_OUTPUT1, DDP[162].priority);

	mov	edx, 4
	imul	edx, 162				; 000000a2H
	mov	eax, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeSimBaseDirty@SimBaseClass@@QAEXW4Dirty_Sim_Base@@W4Dirtyness@@@Z ; SimBaseClass::MakeSimBaseDirty
$LN4@SetPowerOu:

; 2887 : 		}
; 2888 : 		
; 2889 : 		// xmit rpm2
; 2890 : 		value = FloatToInt32(af->rpm2 / 1.5f * 255.0f);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1216]
	divss	xmm0, DWORD PTR __real@3fc00000
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 182  :     fld dword ptr [x];

	fld	DWORD PTR $T1[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR $T1[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR $T1[ebp]

; 181  :   __asm {

	mov	DWORD PTR _value$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2895 : 		specialData.powerOutput2 = af->rpm2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1216]
	mov	DWORD PTR [eax+196], ecx

; 2896 : 
; 2897 : 		diff = specialData.powerOutputNet2 - value;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+200]
	sub	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _diff$[ebp], eax

; 2898 : 
; 2899 : 		if ((diff < -g_nMPPowerXmitThreshold) || (diff > g_nMPPowerXmitThreshold) ||
; 2900 : 			 !value && specialData.powerOutputNet2) // Xmit if RPM just changed to 0

	mov	ecx, DWORD PTR ?g_nMPPowerXmitThreshold@@3HA ; g_nMPPowerXmitThreshold
	neg	ecx
	cmp	DWORD PTR _diff$[ebp], ecx
	jl	SHORT $LN1@SetPowerOu
	mov	edx, DWORD PTR _diff$[ebp]
	cmp	edx, DWORD PTR ?g_nMPPowerXmitThreshold@@3HA ; g_nMPPowerXmitThreshold
	jg	SHORT $LN1@SetPowerOu
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@SetPowerOu
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+200]
	test	ecx, ecx
	je	SHORT $LN2@SetPowerOu
$LN1@SetPowerOu:

; 2901 : 		{
; 2902 : 			specialData.powerOutputNet2 = static_cast<uchar>(value);

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _value$[ebp]
	mov	BYTE PTR [edx+200], al

; 2903 : 			MakeSimBaseDirty (DIRTY_SIM_POWER_OUTPUT2, DDP[162].priority);

	mov	ecx, 4
	imul	ecx, 162				; 000000a2H
	mov	edx, DWORD PTR ?DDP@@3PAUDirtyDataClassType@@A ; DDP
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeSimBaseDirty@SimBaseClass@@QAEXW4Dirty_Sim_Base@@W4Dirtyness@@@Z ; SimBaseClass::MakeSimBaseDirty
$LN2@SetPowerOu:

; 2904 : 		}
; 2905 : 	}
; 2906 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPowerOutput@AircraftClass@@QAEXM@Z ENDP		; AircraftClass::SetPowerOutput
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
_airbase$ = -20						; size = 8
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_tmpWaypoint$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?DivertAirbase@AircraftClass@@QAE?AVVU_ID@@XZ PROC	; AircraftClass::DivertAirbase
; _this$ = ecx

; 2780 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2781 : 	WayPointClass* tmpWaypoint = waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], ecx

; 2782 : 	VU_ID airbase = FalconNullId;

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _airbase$[ebp], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _airbase$[ebp+4], eax
$LN3@DivertAirb:

; 2783 : 	
; 2784 : 	while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN2@DivertAirb
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T2[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2786 : 		if (tmpWaypoint->GetWPFlags() & WPF_ALTERNATE)

	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN1@DivertAirb
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 167  : 	VU_ID GetWPTargetID (void)						{ return TargetID; }

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR $T1[ebp], edx
	mov	DWORD PTR $T1[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2788 : 			airbase = tmpWaypoint->GetWPTargetID();

	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _airbase$[ebp], ecx
	mov	DWORD PTR _airbase$[ebp+4], edx

; 2789 : 			break;

	jmp	SHORT $LN2@DivertAirb
$LN1@DivertAirb:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	eax, DWORD PTR _tmpWaypoint$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tmpWaypoint$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2792 : 	}

	jmp	SHORT $LN3@DivertAirb
$LN2@DivertAirb:

; 2793 : 	
; 2794 : 	return airbase;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _airbase$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _airbase$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2795 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DivertAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ENDP	; AircraftClass::DivertAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
_airbase$ = -16						; size = 8
_this$ = -8						; size = 4
_tmpWaypoint$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?LandingAirbase@AircraftClass@@QAE?AVVU_ID@@XZ PROC	; AircraftClass::LandingAirbase
; _this$ = ecx

; 2762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2763 : 	WayPointClass* tmpWaypoint = waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], ecx

; 2764 : 	VU_ID airbase = FalconNullId;

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _airbase$[ebp], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _airbase$[ebp+4], eax
$LN3@LandingAir:

; 2765 : 	
; 2766 : 	while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN2@LandingAir
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2768 : 		if (tmpWaypoint->GetWPAction() == WP_LAND)

	cmp	edx, 7
	jne	SHORT $LN1@LandingAir
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 167  : 	VU_ID GetWPTargetID (void)						{ return TargetID; }

	mov	eax, DWORD PTR _tmpWaypoint$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2770 : 			airbase = tmpWaypoint->GetWPTargetID();

	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _airbase$[ebp], eax
	mov	DWORD PTR _airbase$[ebp+4], ecx

; 2771 : 			break;

	jmp	SHORT $LN2@LandingAir
$LN1@LandingAir:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	edx, DWORD PTR _tmpWaypoint$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _tmpWaypoint$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2774 : 	}

	jmp	SHORT $LN3@LandingAir
$LN2@LandingAir:

; 2775 : 	
; 2776 : 	return airbase;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _airbase$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _airbase$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2777 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LandingAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ENDP	; AircraftClass::LandingAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
_airbase$ = -16						; size = 8
_this$ = -8						; size = 4
_tmpWaypoint$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?TakeoffAirbase@AircraftClass@@QAE?AVVU_ID@@XZ PROC	; AircraftClass::TakeoffAirbase
; _this$ = ecx

; 2744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2745 : 	WayPointClass* tmpWaypoint = waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], ecx

; 2746 : 	VU_ID airbase = FalconNullId;

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _airbase$[ebp], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _airbase$[ebp+4], eax
$LN3@TakeoffAir:

; 2747 : 	
; 2748 : 	while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN2@TakeoffAir
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2750 : 		if (tmpWaypoint->GetWPAction() == WP_TAKEOFF)

	cmp	edx, 1
	jne	SHORT $LN1@TakeoffAir
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 167  : 	VU_ID GetWPTargetID (void)						{ return TargetID; }

	mov	eax, DWORD PTR _tmpWaypoint$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2752 : 			airbase = tmpWaypoint->GetWPTargetID();

	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _airbase$[ebp], eax
	mov	DWORD PTR _airbase$[ebp+4], ecx

; 2753 : 			break;

	jmp	SHORT $LN2@TakeoffAir
$LN1@TakeoffAir:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	edx, DWORD PTR _tmpWaypoint$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _tmpWaypoint$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2756 : 	}

	jmp	SHORT $LN3@TakeoffAir
$LN2@TakeoffAir:

; 2757 : 	
; 2758 : 	return airbase;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _airbase$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _airbase$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2759 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TakeoffAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ENDP	; AircraftClass::TakeoffAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
_airbase$ = -16						; size = 8
_this$ = -8						; size = 4
_tmpWaypoint$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?HomeAirbase@AircraftClass@@QAE?AVVU_ID@@XZ PROC	; AircraftClass::HomeAirbase
; _this$ = ecx

; 2726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2727 : 	WayPointClass* tmpWaypoint = waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], ecx

; 2728 : 	VU_ID airbase = FalconNullId;

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _airbase$[ebp], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _airbase$[ebp+4], eax
$LN3@HomeAirbas:

; 2729 : 	
; 2730 : 	while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN2@HomeAirbas
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2732 : 		if (tmpWaypoint->GetWPAction() == WP_LAND)

	cmp	edx, 7
	jne	SHORT $LN1@HomeAirbas
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 167  : 	VU_ID GetWPTargetID (void)						{ return TargetID; }

	mov	eax, DWORD PTR _tmpWaypoint$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2734 : 			airbase = tmpWaypoint->GetWPTargetID();

	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _airbase$[ebp], eax
	mov	DWORD PTR _airbase$[ebp+4], ecx

; 2735 : 			break;

	jmp	SHORT $LN2@HomeAirbas
$LN1@HomeAirbas:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	edx, DWORD PTR _tmpWaypoint$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _tmpWaypoint$[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2738 : 	}

	jmp	SHORT $LN3@HomeAirbas
$LN2@HomeAirbas:

; 2739 : 	
; 2740 : 	return airbase;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _airbase$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _airbase$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2741 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HomeAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ENDP	; AircraftClass::HomeAirbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?CombatClass@AircraftClass@@UAEHXZ PROC			; AircraftClass::CombatClass
; _this$ = ecx

; 2798 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2799 :    return SimACDefTable[((Falcon4EntityClassType*)EntityType())->vehicleDataIndex].combatClass;

	mov	edx, DWORD PTR $T1[ebp]
	movsx	eax, WORD PTR [edx+74]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	eax, DWORD PTR [ecx+eax]

; 2800 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CombatClass@AircraftClass@@UAEHXZ ENDP			; AircraftClass::CombatClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\acturbulence.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\bomb.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\lantirn.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv7277 = -2800						; size = 8
$T2 = -2792						; size = 4
tv7265 = -2788						; size = 8
_breathingPitch$3 = -2780				; size = 4
tv6544 = -2776						; size = 8
$T4 = -2768						; size = 4
$T5 = -2764						; size = 4
tv7289 = -2748						; size = 8
$T6 = -2740						; size = 4
$T7 = -2724						; size = 4
$T8 = -2720						; size = 4
$T9 = -2704						; size = 4
tv6348 = -2700						; size = 8
_p$10 = -2692						; size = 4
tv5650 = -2688						; size = 8
tv5525 = -2680						; size = 8
_orientation$11 = -2672					; size = 4
_x$12 = -2668						; size = 4
$T13 = -2664						; size = 4
$T14 = -2660						; size = 4
$T15 = -2656						; size = 4
$T16 = -2652						; size = 4
$T17 = -2648						; size = 4
$T18 = -2644						; size = 4
$T19 = -2640						; size = 4
$T20 = -2636						; size = 4
tv6061 = -2632						; size = 4
$T21 = -2628						; size = 4
_strength$22 = -2624					; size = 4
$T23 = -2620						; size = 4
$T24 = -2616						; size = 4
$T25 = -2612						; size = 4
$T26 = -2608						; size = 4
$T27 = -2604						; size = 4
$T28 = -2600						; size = 4
$T29 = -2596						; size = 4
$T30 = -2592						; size = 4
$T31 = -2588						; size = 4
$T32 = -2584						; size = 4
$T33 = -2580						; size = 8
$T34 = -2572						; size = 4
$T35 = -2568						; size = 8
$T36 = -2560						; size = 4
$T37 = -2556						; size = 8
$T38 = -2548						; size = 4
$T39 = -2544						; size = 8
$T40 = -2536						; size = 4
$T41 = -2532						; size = 8
$T42 = -2524						; size = 4
$T43 = -2520						; size = 8
$T44 = -2512						; size = 4
$T45 = -2508						; size = 4
tv6107 = -2504						; size = 4
$T46 = -2500						; size = 4
tv5964 = -2496						; size = 4
$T47 = -2492						; size = 4
$T48 = -2488						; size = 4
$T49 = -2484						; size = 4
$T50 = -2480						; size = 4
$T51 = -2476						; size = 4
$T52 = -2472						; size = 4
$T53 = -2468						; size = 4
$T54 = -2464						; size = 4
$T55 = -2460						; size = 4
$T56 = -2456						; size = 4
$T57 = -2452						; size = 4
$T58 = -2448						; size = 4
$T59 = -2444						; size = 4
$T60 = -2440						; size = 4
$T61 = -2436						; size = 4
$T62 = -2432						; size = 4
$T63 = -2428						; size = 4
$T64 = -2424						; size = 4
$T65 = -2420						; size = 4
$T66 = -2416						; size = 4
_radioMessage$67 = -2412				; size = 4
$T68 = -2408						; size = 4
$T69 = -2404						; size = 4
$T70 = -2400						; size = 4
$T71 = -2396						; size = 4
$T72 = -2392						; size = 4
$T73 = -2388						; size = 4
$T74 = -2384						; size = 4
$T75 = -2380						; size = 4
$T76 = -2376						; size = 4
$T77 = -2372						; size = 4
$T78 = -2368						; size = 4
$T79 = -2364						; size = 4
$T80 = -2360						; size = 4
$T81 = -2356						; size = 4
$T82 = -2352						; size = 4
$T83 = -2348						; size = 4
$T84 = -2344						; size = 4
$T85 = -2340						; size = 4
$T86 = -2336						; size = 4
$T87 = -2332						; size = 4
$T88 = -2328						; size = 4
$T89 = -2324						; size = 4
$T90 = -2320						; size = 4
$T91 = -2316						; size = 4
$T92 = -2312						; size = 4
tv6155 = -2308						; size = 4
$T93 = -2304						; size = 4
$T94 = -2300						; size = 4
$T95 = -2296						; size = 4
tv6070 = -2292						; size = 4
$T96 = -2288						; size = 4
tv6008 = -2284						; size = 4
$T97 = -2280						; size = 4
tv5920 = -2276						; size = 4
$T98 = -2272						; size = 4
$T99 = -2268						; size = 4
_refuelRate$100 = -2264					; size = 4
$T101 = -2260						; size = 4
$T102 = -2256						; size = 4
$T103 = -2252						; size = 4
$T104 = -2248						; size = 4
$T105 = -2244						; size = 4
$T106 = -2240						; size = 4
$T107 = -2236						; size = 4
$T108 = -2232						; size = 4
$T109 = -2228						; size = 4
tv7023 = -2224						; size = 4
_acweight$110 = -2220					; size = 4
tv7015 = -2216						; size = 4
$T111 = -2212						; size = 4
$T112 = -2208						; size = 4
_x$113 = -2204						; size = 4
$T114 = -2200						; size = 4
$T115 = -2196						; size = 4
$T116 = -2192						; size = 4
$T117 = -2188						; size = 4
_x$118 = -2184						; size = 4
$T119 = -2180						; size = 4
$T120 = -2176						; size = 4
$T121 = -2172						; size = 4
$T122 = -2168						; size = 4
$T123 = -2164						; size = 4
_x$124 = -2160						; size = 4
$T125 = -2156						; size = 4
$T126 = -2152						; size = 4
$T127 = -2148						; size = 4
$T128 = -2144						; size = 4
$T129 = -2140						; size = 4
$T130 = -2136						; size = 4
$T131 = -2132						; size = 4
$T132 = -2128						; size = 4
$T133 = -2124						; size = 4
$T134 = -2120						; size = 4
$T135 = -2116						; size = 4
$T136 = -2112						; size = 4
$T137 = -2108						; size = 4
$T138 = -2104						; size = 4
_flightIdx$ = -2100					; size = 4
$T139 = -2096						; size = 4
$T140 = -2092						; size = 4
_alt$141 = -2088					; size = 4
tv2365 = -2084						; size = 4
_groundAlt$142 = -2080					; size = 4
$T143 = -2076						; size = 4
$T144 = -2072						; size = 4
$T145 = -2068						; size = 4
$T146 = -2064						; size = 4
$T147 = -2060						; size = 4
$T148 = -2056						; size = 4
$T149 = -2052						; size = 4
$T150 = -2048						; size = 4
$T151 = -2044						; size = 4
$T152 = -2040						; size = 4
$T153 = -2036						; size = 4
$T154 = -2032						; size = 4
$T155 = -2028						; size = 4
$T156 = -2024						; size = 4
$T157 = -2020						; size = 4
$T158 = -2016						; size = 4
$T159 = -2012						; size = 4
$T160 = -2008						; size = 4
$T161 = -2004						; size = 4
$T162 = -2000						; size = 4
$T163 = -1996						; size = 4
$T164 = -1992						; size = 4
$T165 = -1988						; size = 4
$T166 = -1984						; size = 4
$T167 = -1980						; size = 4
$T168 = -1976						; size = 4
$T169 = -1972						; size = 4
$T170 = -1968						; size = 4
$T171 = -1964						; size = 4
$T172 = -1960						; size = 4
_groundLevel$173 = -1956				; size = 4
$T174 = -1952						; size = 4
$T175 = -1948						; size = 4
$T176 = -1944						; size = 4
$T177 = -1940						; size = 4
$T178 = -1936						; size = 4
$T179 = -1932						; size = 4
$T180 = -1928						; size = 4
$T181 = -1924						; size = 4
$T182 = -1920						; size = 4
$T183 = -1916						; size = 4
$T184 = -1912						; size = 4
$T185 = -1908						; size = 4
$T186 = -1904						; size = 4
$T187 = -1900						; size = 4
$T188 = -1896						; size = 4
$T189 = -1892						; size = 4
$T190 = -1888						; size = 4
$T191 = -1884						; size = 4
$T192 = -1880						; size = 4
tv6099 = -1876						; size = 4
$T193 = -1872						; size = 4
tv7334 = -1868						; size = 4
$T194 = -1864						; size = 4
tv6031 = -1860						; size = 4
$T195 = -1856						; size = 4
tv5985 = -1852						; size = 4
$T196 = -1848						; size = 4
tv5942 = -1844						; size = 4
$T197 = -1840						; size = 4
$T198 = -1836						; size = 4
$T199 = -1832						; size = 4
$T200 = -1828						; size = 4
$T201 = -1824						; size = 4
_x$202 = -1820						; size = 4
$T203 = -1816						; size = 4
$T204 = -1812						; size = 4
$T205 = -1808						; size = 4
_x$206 = -1804						; size = 4
$T207 = -1800						; size = 4
$T208 = -1796						; size = 4
$T209 = -1792						; size = 4
_x$210 = -1788						; size = 4
$T211 = -1784						; size = 4
$T212 = -1780						; size = 4
$T213 = -1776						; size = 4
$T214 = -1772						; size = 4
$T215 = -1768						; size = 4
$T216 = -1764						; size = 4
$T217 = -1760						; size = 4
$T218 = -1756						; size = 4
$T219 = -1752						; size = 4
$T220 = -1748						; size = 4
$T221 = -1744						; size = 4
$T222 = -1740						; size = 4
$T223 = -1736						; size = 4
_acaoa$224 = -1732					; size = 4
$T225 = -1728						; size = 4
$T226 = -1724						; size = 4
$T227 = -1720						; size = 4
$T228 = -1716						; size = 4
$T229 = -1712						; size = 4
_x$230 = -1708						; size = 4
$T231 = -1704						; size = 4
$T232 = -1700						; size = 4
$T233 = -1696						; size = 4
$T234 = -1692						; size = 4
$T235 = -1688						; size = 4
$T236 = -1684						; size = 4
_vc$237 = -1680						; size = 4
_denom$238 = -1676					; size = 4
tv1091 = -1672						; size = 4
$T239 = -1668						; size = 4
tv4046 = -1664						; size = 4
_sw$240 = -1660						; size = 4
tv813 = -1656						; size = 4
_LiteZ$241 = -1652					; size = 4
tv4017 = -1648						; size = 4
tv2845 = -1644						; size = 4
tv4014 = -1640						; size = 4
$T242 = -1636						; size = 4
tv519 = -1632						; size = 4
$T243 = -1628						; size = 4
$T244 = -1624						; size = 4
tv4063 = -1620						; size = 4
tv3962 = -1616						; size = 4
_num$245 = -1612					; size = 4
tv3943 = -1608						; size = 4
tv2629 = -1604						; size = 4
tv305 = -1600						; size = 4
tv4251 = -1596						; size = 4
tv304 = -1592						; size = 4
tv4205 = -1588						; size = 4
tv4919 = -1584						; size = 4
$T246 = -1580						; size = 4
tv4915 = -1576						; size = 4
tv6344 = -1572						; size = 4
tv7285 = -1568						; size = 4
tv1675 = -1564						; size = 4
tv7273 = -1560						; size = 4
tv4724 = -1556						; size = 4
tv7261 = -1552						; size = 4
_vt$247 = -1548						; size = 4
tv4911 = -1544						; size = 4
tv2969 = -1540						; size = 4
tv4906 = -1536						; size = 4
tv2737 = -1532						; size = 4
tv3423 = -1528						; size = 4
tv4256 = -1524						; size = 4
$T248 = -1520						; size = 4
tv2583 = -1516						; size = 4
tv3419 = -1512						; size = 4
tv6540 = -1508						; size = 4
tv4840 = -1504						; size = 4
tv4224 = -1500						; size = 4
tv3396 = -1496						; size = 4
$T249 = -1492						; size = 4
$T250 = -1488						; size = 4
$T251 = -1484						; size = 4
tv3385 = -1480						; size = 4
$T252 = -1476						; size = 4
tv4827 = -1472						; size = 4
_viewp$253 = -1468					; size = 4
tv4803 = -1464						; size = 4
$T254 = -1460						; size = 4
tv4799 = -1456						; size = 4
_ZDiff$255 = -1452					; size = 4
_connected$256 = -1448					; size = 4
$T257 = -1444						; size = 4
_theSFX$258 = -1440					; size = 4
tv286 = -1436						; size = 4
tv4771 = -1432						; size = 4
tv4060 = -1428						; size = 4
_target$259 = -1424					; size = 4
_clearanceBuffer$260 = -1420				; size = 4
$T261 = -1416						; size = 4
_refuelHelp$262 = -1412					; size = 4
_radar$263 = -1408					; size = 4
$T264 = -1402						; size = 2
_scale$265 = -1400					; size = 4
_groundType$266 = -1396					; size = 4
_inckpt$267 = -1392					; size = 4
tv2824 = -1388						; size = 4
_engines$268 = -1384					; size = 4
_tmpTarget$269 = -1380					; size = 4
_i$270 = -1376						; size = 4
tv3312 = -1372						; size = 4
_orientation$271 = -1368				; size = 4
_turnRadius$272 = -1364					; size = 4
_v$273 = -1360						; size = 4
tv2932 = -1356						; size = 4
$T274 = -1350						; size = 2
tv2716 = -1348						; size = 4
$T275 = -1342						; size = 2
_Div$276 = -1340					; size = 4
$T277 = -1336						; size = 4
_gs$278 = -1332						; size = 4
_i$279 = -1328						; size = 4
_w$280 = -1324						; size = 4
_TankerMsg$281 = -1320					; size = 4
_FastRandom$282 = -1316					; size = 4
_tanker$283 = -1312					; size = 4
_FastRandom$284 = -1308					; size = 4
_FastRandom$285 = -1304					; size = 4
_FastRandom$286 = -1300					; size = 4
_FastRandom$287 = -1296					; size = 4
_FastRandom$288 = -1292					; size = 4
_FastRandom$289 = -1288					; size = 4
_FastRandom$290 = -1284					; size = 4
_v$291 = -1280						; size = 4
_t$292 = -1276						; size = 4
_campObj$293 = -1272					; size = 4
_flight$ = -1268					; size = 4
_p1$294 = -1264						; size = 4
_Turb$295 = -1260					; size = 4
_eng$296 = -1256					; size = 4
_v$297 = -1252						; size = 4
_pwr$298 = -1248					; size = 4
_EvenFrame$ = -1241					; size = 1
_TempTurb$299 = -1240					; size = 4
_this$ = -1236						; size = 4
_rot$300 = -1232					; size = 36
_airPos$ = -1196					; size = 41
_relPos$301 = -1152					; size = 12
_pos$302 = -1140					; size = 12
_pos$303 = -1128					; size = 12
_mvec$304 = -1116					; size = 12
_turb$305 = -1104					; size = 12
_pos$306 = -1092					; size = 12
_vec$307 = -1080					; size = 12
_rotPos$308 = -1068					; size = 12
_rpm$309 = -1056					; size = 16
_tmpchr$310 = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Exec@AircraftClass@@UAEHXZ PROC			; AircraftClass::Exec
; _this$ = ecx

; 1102 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Exec@AircraftClass@@UAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2788				; 00000ae4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 	//START_PROFILE("AC_EXEC");
; 1104 : 	bool	EvenFrame=true;

	mov	BYTE PTR _EvenFrame$[ebp], 1

; 1105 : 	StaticTurbulence.x=StaticTurbulence.y=StaticTurbulence.z=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+3608], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+3604], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+3600], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T87[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1106 : 	if (this == SimDriver.GetPlayerEntity()){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR $T87[ebp]
	jne	$LN228@Exec

; 1107 : 		if(EvenFrame){

	movzx	edx, BYTE PTR _EvenFrame$[ebp]
	test	edx, edx
	je	$LN227@Exec

; 1109 : 			float	Turb=af->dbrake * 0.005f * sqrtf(af->vcas);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1124]
	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR $T8[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR $T8[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	movss	xmm0, DWORD PTR $T8[ebp]
	movss	DWORD PTR $T31[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1109 : 			float	Turb=af->dbrake * 0.005f * sqrtf(af->vcas);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1548]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mulss	xmm0, DWORD PTR $T31[ebp]
	movss	DWORD PTR _Turb$295[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1176 : 	float MaxVcas(void) {return maxVcas;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+80]
	movss	DWORD PTR $T29[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1114 : 			float TempTurb=af->vcas/af->MaxVcas() - 0.7f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1124]
	divss	xmm0, DWORD PTR $T29[ebp]
	subss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _TempTurb$299[ebp], xmm0

; 1115 : 			// if we r over 70% of Max Cas Apply Turbulence
; 1116 : 			if (TempTurb>0.0f) Turb+=6.0f * (TempTurb * TempTurb);

	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN226@Exec
	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	mulss	xmm0, DWORD PTR _TempTurb$299[ebp]
	mulss	xmm0, DWORD PTR __real@40c00000
	addss	xmm0, DWORD PTR _Turb$295[ebp]
	movss	DWORD PTR _Turb$295[ebp], xmm0
$LN226@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR $T20[ebp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR $T18[ebp], xmm0

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR $T23[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR $T21[ebp], xmm0

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR $T27[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR $T25[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1120 : 			TempTurb=sqrtf(XDelta()*XDelta() + ZDelta()*ZDelta() + YDelta()*YDelta());

	movss	xmm0, DWORD PTR $T27[ebp]
	mulss	xmm0, DWORD PTR $T25[ebp]
	movss	xmm1, DWORD PTR $T23[ebp]
	mulss	xmm1, DWORD PTR $T21[ebp]
	movss	xmm2, DWORD PTR $T20[ebp]
	mulss	xmm2, DWORD PTR $T18[ebp]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR $T6[ebp], xmm2
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR $T6[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR $T6[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	movss	xmm0, DWORD PTR $T6[ebp]
	movss	DWORD PTR _TempTurb$299[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1121 : 			TempTurb=TempTurb/1100 - 0.9f;

	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	divss	xmm0, DWORD PTR __real@44898000
	subss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR _TempTurb$299[ebp], xmm0

; 1122 : 			// if we r over 90% of Mach Apply Turbulence
; 1123 : 			if (TempTurb>0.0f && TempTurb<=0.1f)	Turb+=10.0f * (TempTurb * TempTurb);

	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN225@Exec
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _TempTurb$299[ebp]
	jb	SHORT $LN225@Exec
	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	mulss	xmm0, DWORD PTR _TempTurb$299[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR _Turb$295[ebp]
	movss	DWORD PTR _Turb$295[ebp], xmm0
$LN225@Exec:

; 1124 : 			// if Passing Sonic Wave, Bang!!!
; 1125 : 			if (TempTurb>=0.1f && LastMach<0.1f) SetPulseTurbulence(0.3f, 0.3f, 0.3f, 1.0f);

	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN224@Exec
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR ?LastMach@?7??Exec@AircraftClass@@UAEHXZ@4MA
	jbe	SHORT $LN224@Exec
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPulseTurbulence@AircraftClass@@QAEXMMMM@Z ; AircraftClass::SetPulseTurbulence
$LN224@Exec:

; 1126 : 			LastMach=TempTurb;

	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	movss	DWORD PTR ?LastMach@?7??Exec@AircraftClass@@UAEHXZ@4MA, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1174 : 	float MaxGs (void) {return maxGs;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR $T16[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1131 : 			TempTurb=af->nzcgs/af->MaxGs() - 0.7f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+268]
	divss	xmm0, DWORD PTR $T16[ebp]
	subss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _TempTurb$299[ebp], xmm0

; 1132 : 			// if we r over 70% of Max Load Apply Turbulence
; 1133 : 			if ( TempTurb > 0.0f ) Turb+=5.0f * TempTurb * TempTurb;

	movss	xmm0, DWORD PTR _TempTurb$299[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN223@Exec
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR _TempTurb$299[ebp]
	mulss	xmm0, DWORD PTR _TempTurb$299[ebp]
	addss	xmm0, DWORD PTR _Turb$295[ebp]
	movss	DWORD PTR _Turb$295[ebp], xmm0
$LN223@Exec:

; 1134 : 
; 1135 : 			StaticTurbulence.x=StaticTurbulence.y=StaticTurbulence.z=Turb;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Turb$295[ebp]
	movss	DWORD PTR [eax+3608], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Turb$295[ebp]
	movss	DWORD PTR [ecx+3604], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _Turb$295[ebp]
	movss	DWORD PTR [edx+3600], xmm0

; 1136 : 
; 1137 : 			// COBRA - RED - Update Turbulence for the Pit, the Decrement is calculates with a rate of 100 mSecs
; 1138 : 			if (PulseTurbulenceTime){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3584]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN222@Exec

; 1139 : 				float	Div=PulseTurbulenceTime/SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+3584]
	divss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _Div$276[ebp], xmm0

; 1140 : 				// Decrease it with present elapsed time rate
; 1141 : 				PulseTurbulence.x-=PulseTurbulence.x/Div;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3588]
	divss	xmm0, DWORD PTR _Div$276[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+3588]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+3588], xmm1

; 1142 : 				PulseTurbulence.y-=PulseTurbulence.y/Div;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3592]
	divss	xmm0, DWORD PTR _Div$276[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+3592]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+3592], xmm1

; 1143 : 				PulseTurbulence.z-=PulseTurbulence.z/Div;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3596]
	divss	xmm0, DWORD PTR _Div$276[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+3596]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+3596], xmm1

; 1144 : 				PulseTurbulenceTime-=SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3584]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+3584], xmm0

; 1145 : 				if (PulseTurbulenceTime<0.0f) PulseTurbulenceTime=0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+3584]
	jbe	SHORT $LN221@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+3584], xmm0
$LN221@Exec:

; 1146 : 			} 
; 1147 : 			else {

	jmp	SHORT $LN220@Exec
$LN222@Exec:

; 1148 : 				// No time, no Turbulence
; 1149 : 				PulseTurbulence.x=PulseTurbulence.y=PulseTurbulence.z=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+3596], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+3592], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+3588], xmm0
$LN220@Exec:

; 1150 : 			}
; 1151 : 
; 1152 : 			TotalTurbulence.x=(PulseTurbulence.x+StaticTurbulence.x);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3588]
	addss	xmm0, DWORD PTR [ecx+3600]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+3612], xmm0

; 1153 : 			TotalTurbulence.y=(PulseTurbulence.y+StaticTurbulence.y);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3592]
	addss	xmm0, DWORD PTR [ecx+3604]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+3616], xmm0

; 1154 : 			TotalTurbulence.z=(PulseTurbulence.z+StaticTurbulence.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3596]
	addss	xmm0, DWORD PTR [ecx+3608]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+3620], xmm0

; 1155 : 				
; 1156 : 			// Setup the Value for sound stuff
; 1157 : 			Turb=max(TotalTurbulence.x, max(TotalTurbulence.y, TotalTurbulence.z));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3616]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+3620]
	jbe	SHORT $LN231@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3616]
	movss	DWORD PTR tv286[ebp], xmm0
	jmp	SHORT $LN232@Exec
$LN231@Exec:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3620]
	movss	DWORD PTR tv286[ebp], xmm0
$LN232@Exec:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+3612]
	comiss	xmm0, DWORD PTR tv286[ebp]
	jbe	SHORT $LN235@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3612]
	movss	DWORD PTR tv305[ebp], xmm0
	jmp	SHORT $LN236@Exec
$LN235@Exec:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3616]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+3620]
	jbe	SHORT $LN233@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+3616]
	movss	DWORD PTR tv304[ebp], xmm0
	jmp	SHORT $LN234@Exec
$LN233@Exec:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+3620]
	movss	DWORD PTR tv304[ebp], xmm0
$LN234@Exec:
	movss	xmm0, DWORD PTR tv304[ebp]
	movss	DWORD PTR tv305[ebp], xmm0
$LN236@Exec:
	movss	xmm0, DWORD PTR tv305[ebp]
	movss	DWORD PTR _Turb$295[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 420  :         {return ((float)log((double)_X)); }

	cvtss2sd xmm0, DWORD PTR _Turb$295[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log
	add	esp, 8
	fstp	QWORD PTR tv5525[ebp]
	movsd	xmm0, QWORD PTR tv5525[ebp]
	cvtsd2ss xmm0, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1158 : 			Turb=log(Turb)*1000.0f;

	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _Turb$295[ebp], xmm0

; 1159 : 			// The turbulence Noise
; 1160 : 			if (af->nzcgs > 5.5f ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+268]
	comiss	xmm0, DWORD PTR __real@40b00000
	jbe	$LN219@Exec

; 1161 : 				float v;
; 1162 : 
; 1163 : 				//I-Hawk - different calculation for volume based on G...
; 1164 : 
; 1165 : 				v = -2000.0f;

	movss	xmm0, DWORD PTR __real@c4fa0000
	movss	DWORD PTR _v$273[ebp], xmm0

; 1166 : 
; 1167 : 				v += ( af->nzcgs - 5.5f ) * 250.0f ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+268]
	subss	xmm0, DWORD PTR __real@40b00000
	mulss	xmm0, DWORD PTR __real@437a0000
	addss	xmm0, DWORD PTR _v$273[ebp]
	movss	DWORD PTR _v$273[ebp], xmm0

; 1168 : 				//F4SoundFXSetDist(af->auxaeroData->sndOverSpeed2, TRUE, v, ( (GetKias() - af->curMaxStoreSpeed)) / 25);
; 1169 : 				SoundPos.Sfx(af->auxaeroData->sndOverSpeed2, 0, 2 , v); // MLR 5/16/2004 - 

	push	ecx
	movss	xmm0, DWORD PTR _v$273[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+2368]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN219@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$289[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$289[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$289[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$289[ebp]
	mov	DWORD PTR $T14[ebp], eax

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	ecx, DWORD PTR $T14[ebp]
	and	ecx, 65535				; 0000ffffH
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _x$12[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$12[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T36[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1174 : 			TotalTurbulence.x*=PRANDFloat() * 0.01f;

	movss	xmm0, DWORD PTR $T36[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+3612]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+3612], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$288[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$288[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$288[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	ecx, DWORD PTR _FastRandom$288[ebp]
	mov	DWORD PTR $T234[ebp], ecx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	edx, DWORD PTR $T234[ebp]
	and	edx, 65535				; 0000ffffH
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _x$113[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$113[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T232[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1175 : 			TotalTurbulence.y*=PRANDFloat() * 0.01f;

	movss	xmm0, DWORD PTR $T232[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+3616]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+3616], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$284[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$284[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$284[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	edx, DWORD PTR _FastRandom$284[ebp]
	mov	DWORD PTR $T34[ebp], edx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	eax, DWORD PTR $T34[ebp]
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$230[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$230[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T111[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1176 : 			TotalTurbulence.z*=PRANDFloat() * 0.01f;

	movss	xmm0, DWORD PTR $T111[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+3620]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+3620], xmm0
$LN227@Exec:

; 1177 : 		}	
; 1178 : 		EvenFrame^=1;

	movzx	eax, BYTE PTR _EvenFrame$[ebp]
	xor	eax, 1
	mov	BYTE PTR _EvenFrame$[ebp], al
$LN228@Exec:

; 1179 : 	}
; 1180 : 
; 1181 : 	SoundPos.UpdatePos(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?UpdatePos@F4SoundPos@@QAEXPAVSimBaseClass@@@Z ; F4SoundPos::UpdatePos

; 1182 : 
; 1183 : 	if(turbulence)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3572], 0
	je	$LN304@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+88]
	and	edx, 2
	je	SHORT $LN296@Exec
	mov	DWORD PTR tv3943[ebp], 1
	jmp	SHORT $LN297@Exec
$LN296@Exec:
	mov	DWORD PTR tv3943[ebp], 0
$LN297@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1189 : 		if (af->IsSet(AirframeClass::InAir))

	cmp	DWORD PTR tv3943[ebp], 0
	je	$LN217@Exec

; 1190 : 		{
; 1191 : 			Trotation *orientation = &((DrawableBSP*)drawPointer)->orientation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR _orientation$271[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR $T228[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1195 : 			turb.x = XPos() + orientation->M11*-20;//thrx + orientation->M12*thry + orientation->M13*thrz;

	mov	eax, DWORD PTR _orientation$271[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@c1a00000
	addss	xmm0, DWORD PTR $T228[ebp]
	movss	DWORD PTR _turb$305[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T54[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1196 : 			turb.y = YPos() + orientation->M21*-20;//thrx + orientation->M22*thry + orientation->M23*thrz;

	mov	edx, DWORD PTR _orientation$271[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR __real@c1a00000
	addss	xmm0, DWORD PTR $T54[ebp]
	movss	DWORD PTR _turb$305[ebp+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR $T226[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1197 : 			turb.z = ZPos() + orientation->M31*-20;//thrx + orientation->M32*thry + orientation->M33*thrz;

	mov	ecx, DWORD PTR _orientation$271[ebp]
	movss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, DWORD PTR __real@c1a00000
	addss	xmm0, DWORD PTR $T226[ebp]
	movss	DWORD PTR _turb$305[ebp+8], xmm0

; 1198 : 			
; 1199 : 			float acweight = af->weight*0.00001f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR _acweight$110[ebp], xmm0

; 1200 : 			float acaoa = af->alpha*0.1f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1152]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _acaoa$224[ebp], xmm0

; 1201 : 			//float strength = 1; //af->weight * af->nxcgb;
; 1202 : 			float strength = acweight * acaoa;

	movss	xmm0, DWORD PTR _acweight$110[ebp]
	mulss	xmm0, DWORD PTR _acaoa$224[ebp]
	movss	DWORD PTR _strength$22[ebp], xmm0

; 1203 : 
; 1204 : 			turbulence->RecordPosition(strength, turb.x, turb.y, turb.z); // TODO compute a strength value

	push	ecx
	movss	xmm0, DWORD PTR _turb$305[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _turb$305[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _turb$305[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _strength$22[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3572]
	call	?RecordPosition@AircraftTurbulence@@QAEXMMMM@Z ; AircraftTurbulence::RecordPosition

; 1205 : 
; 1206 : 			// the wingtip vortices are in Damage.cpp because the wingtip position is calculated there, and
; 1207 : 			// it takes into account wing sweep and all that jazz.
; 1208 : 		}
; 1209 : 		else

	jmp	SHORT $LN304@Exec
$LN217@Exec:

; 1210 : 		{	
; 1211 : 			turbulence->BreakRecord();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3572]
	mov	DWORD PTR $T222[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\acturbulence.h

; 28   : 	void BreakRecord(void) {breakRecord = 1;}

	mov	eax, DWORD PTR $T222[ebp]
	mov	DWORD PTR [eax+60], 1
$LN304@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1218 : 	Flight flight = NULL;

	mov	DWORD PTR _flight$[ebp], 0

; 1219 : 	int flightIdx;
; 1220 : 
; 1221 :     if (g_nShowDebugLabels & 0x2000)

	mov	ecx, DWORD PTR ?g_nShowDebugLabels@@3HA	; g_nShowDebugLabels
	and	ecx, 8192				; 00002000H
	je	$LN214@Exec

; 1222 :     {
; 1223 : 		if ( drawPointer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+332], 0
	je	$LN214@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1183 : 	float Fuel (void) {return fuel;};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR $T109[ebp], xmm0

; 1184 : 	float ExternalFuel (void) {return externalFuel;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR $T220[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1226 : 			sprintf(tmpchr,"%f",af->Fuel() + af->ExternalFuel());

	movss	xmm0, DWORD PTR $T109[ebp]
	addss	xmm0, DWORD PTR $T220[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	lea	ecx, DWORD PTR _tmpchr$310[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h

; 63   : 	DWORD LabelColor()										{ return labelColor; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR $T52[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1227 : 			((DrawableBSP*)drawPointer)->SetLabel (tmpchr, ((DrawableBSP*)drawPointer)->LabelColor());

	mov	edx, DWORD PTR $T52[ebp]
	push	edx
	lea	eax, DWORD PTR _tmpchr$310[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+332]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN214@Exec:

; 1228 : 		}
; 1229 :     }	
; 1230 : 
; 1231 : 	if ( IsDead() ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	je	SHORT $LN213@Exec

; 1232 : 		return TRUE;

	mov	eax, 1
	jmp	$LN229@Exec
$LN213@Exec:

; 1233 : 	}
; 1234 : 
; 1235 : 	// only do ejection on local entity
; 1236 : 	if ( IsLocal() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN186@Exec

; 1242 : 			PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RAMP)

	movzx	edx, BYTE PTR ?g_bDarkHudFix@@3_NA	; g_bDarkHudFix
	test	edx, edx
	je	$LN211@Exec
	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN211@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T218[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1242 : 			PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RAMP)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR $T218[ebp]
	jne	$LN211@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T107[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1242 : 			PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RAMP)

	cmp	DWORD PTR $T107[ebp], 0
	je	$LN211@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T216[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1242 : 			PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RAMP)

	mov	eax, DWORD PTR $T216[ebp]
	mov	ecx, DWORD PTR [eax+968]
	and	ecx, 64					; 00000040H
	jne	$LN211@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR tv3962[ebp], edx
	cmp	DWORD PTR tv3962[ebp], 0
	jl	SHORT $LN319@Exec
	cmp	DWORD PTR tv3962[ebp], 2
	jle	SHORT $LN318@Exec
	jmp	SHORT $LN319@Exec
$LN318@Exec:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	eax, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR $T244[ebp], eax
	jmp	SHORT $LN321@Exec
$LN319@Exec:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	mov	DWORD PTR $T244[ebp], 0
$LN321@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1242 : 			PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RAMP)

	cmp	DWORD PTR $T244[ebp], 2
	je	SHORT $LN211@Exec

; 1243 : 		{
; 1244 : 			TheHud->SymWheelPos = 1.0F;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+5136], xmm0

; 1245 : 			TheHud->SetLightLevel();

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T32[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1246 : 			DBrain()->moreFlags |= DigitalBrain::HUDSetup; // set the flag so we don't go in here again

	mov	ecx, DWORD PTR $T32[ebp]
	add	ecx, 968				; 000003c8H
	mov	DWORD PTR tv519[ebp], ecx
	mov	edx, DWORD PTR tv519[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR tv519[ebp]
	mov	DWORD PTR [ecx], eax
$LN211@Exec:

; 1250 : 		if(doEjectCountdown && !ejectTriggered && ejectCountdown < 0.0 && fabs(glocFactor) < 0.95F){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1804], 0
	je	$LN210@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 0
	jne	SHORT $LN210@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1800]
	movsd	xmm1, QWORD PTR __real@0000000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN210@Exec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+912]
	movss	DWORD PTR $T214[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtss2sd xmm0, DWORD PTR $T214[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv5650[ebp]
	movsd	xmm0, QWORD PTR tv5650[ebp]
	cvtsd2ss xmm0, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1250 : 		if(doEjectCountdown && !ejectTriggered && ejectCountdown < 0.0 && fabs(glocFactor) < 0.95F){

	movss	xmm1, DWORD PTR __real@3f733333
	comiss	xmm1, xmm0
	jbe	SHORT $LN210@Exec

; 1251 : 			ejectTriggered = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], 1

; 1252 : 			//Make sure the autopilot is off;
; 1253 : 			// sfr: moved below to test
; 1254 : 			//SetAutopilot(APOff);
; 1255 : 			//no radio if you eject :)
; 1256 : 			ResetVoices();

	call	?ResetVoices@@YAXXZ			; ResetVoices
$LN210@Exec:

; 1257 : 		}
; 1258 : 		
; 1259 : 		ejectCountdown -= SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1800]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1800], xmm0

; 1283 : 		)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@becccccd
	comiss	xmm0, DWORD PTR [eax+292]
	jbe	SHORT $LN207@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	comiss	xmm0, DWORD PTR __real@bf19999a
	jbe	SHORT $LN207@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+696], 4
	je	SHORT $LN206@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+696], 2
	je	SHORT $LN206@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+696], 5
	je	SHORT $LN206@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+696], 6
	je	SHORT $LN206@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+696], 0
	jne	SHORT $LN207@Exec
$LN206@Exec:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	jne	SHORT $LN208@Exec
$LN207@Exec:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 0
	je	$LN209@Exec
$LN208@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, 1
	je	SHORT $LN331@Exec
	mov	DWORD PTR tv4014[ebp], 1
	jmp	SHORT $LN332@Exec
$LN331@Exec:
	mov	DWORD PTR tv4014[ebp], 0
$LN332@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1283 : 		)

	movzx	edx, BYTE PTR tv4014[ebp]
	test	edx, edx
	jne	SHORT $LN209@Exec

; 1284 : 		{
; 1285 : 			Eject();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Eject@AircraftClass@@QAEXXZ		; AircraftClass::Eject

; 1286 : 			ResetVoices();

	call	?ResetVoices@@YAXXZ			; ResetVoices

; 1287 : 			SoundPos.Sfx(af->auxaeroData->sndEject, 0, 1.0, 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2344]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN209@Exec:

; 1288 : 		}
; 1289 : 
; 1290 : 		//MI Emergency jettison
; 1291 : 		if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN186@Exec

; 1292 : 		{
; 1293 : 			if(doJettCountdown && !EmerJettTriggered && JettCountown < 0.0)	{

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1816]
	test	eax, eax
	je	SHORT $LN204@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1808]
	test	edx, edx
	jne	SHORT $LN204@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1812]
	movsd	xmm1, QWORD PTR __real@0000000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN204@Exec

; 1294 : 				EmerJettTriggered = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1808], 1
$LN204@Exec:

; 1295 : 			}
; 1296 : 			// MN fix: reset EmerJettTriggered
; 1297 : 			if(EmerJettTriggered && Sms)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1808]
	test	eax, eax
	je	SHORT $LN203@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	je	SHORT $LN203@Exec

; 1298 : 			{
; 1299 : 				Sms->EmergencyJettison();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	call	?EmergencyJettison@SMSClass@@QAEXXZ	; SMSClass::EmergencyJettison

; 1300 : 				EmerJettTriggered = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1808], 0

; 1301 : 				doJettCountdown = false; // Unz and Saint -- This was missing causing MP flooding.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1816], 0
$LN203@Exec:

; 1302 : 			}
; 1303 : 
; 1304 : 			JettCountown -= SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1812]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1812], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 251  : 	int AVTRState(AVTRStateFlags fl) { return (AVTRFlags & fl) == (unsigned int)fl ? 1 : 0; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+840]
	and	edx, 2
	je	SHORT $LN335@Exec
	mov	DWORD PTR tv4017[ebp], 1
	jmp	SHORT $LN336@Exec
$LN335@Exec:
	mov	DWORD PTR tv4017[ebp], 0
$LN336@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1307 : 			if(AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO) && SimDriver.AVTROn())

	cmp	DWORD PTR tv4017[ebp], 0
	je	$LN339@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 100  : 	int AVTROn (void) {return avtrOn;};

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+356
	mov	DWORD PTR $T105[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1307 : 			if(AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO) && SimDriver.AVTROn())

	cmp	DWORD PTR $T105[ebp], 0
	je	SHORT $LN339@Exec

; 1308 : 			{
; 1309 : 				if(AVTRCountown > 0.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+844]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN201@Exec

; 1310 : 					AVTRCountown -= SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+844]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+844], xmm0
	jmp	SHORT $LN339@Exec
$LN201@Exec:

; 1311 : 				else if (AVTRCountown <= 0.0F)	//turn it off

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+844]
	jb	SHORT $LN339@Exec

; 1312 : 				{
; 1313 : 					ACMIToggleRecording(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?ACMIToggleRecording@@YAXKHPAX@Z	; ACMIToggleRecording
	add	esp, 12					; 0000000cH
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 101  : 	void SetAVTR (int newFlag) {avtrOn = newFlag; };

	mov	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+356, 0
$LN339@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1319 : 			if(g_bINS && !isDigital)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	$LN190@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	jne	$LN190@Exec

; 1320 : 			{
; 1321 : 				RunINS();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunINS@AircraftClass@@QAEXXZ		; AircraftClass::RunINS
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 519  : 	MainPowerType MainPower() { return mainPower; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1484]
	mov	DWORD PTR $T212[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1323 : 				if(MainPower() == MainPowerMain)

	cmp	DWORD PTR $T212[ebp], 2
	jne	SHORT $LN197@Exec

; 1324 : 				{
; 1325 : 					if(BUPADIEnergy < 540.0F)	//9 minutes

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44070000
	comiss	xmm0, DWORD PTR [eax+832]
	jbe	SHORT $LN196@Exec

; 1326 : 						BUPADIEnergy += (SimLibMajorFrameTime * 9 * 2);	//full in 1 min

	movss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@41100000
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+832]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+832], xmm0
$LN196@Exec:

; 1327 : 				}

	jmp	SHORT $LN194@Exec
$LN197@Exec:

; 1328 : 				else if(BUPADIEnergy > 0.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+832]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN194@Exec

; 1329 : 					BUPADIEnergy -= SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+832]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+832], xmm0
$LN194@Exec:

; 1330 : 
; 1331 : 				if(BUPADIEnergy > 0.0F) //goes away immediately

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+832]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN193@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 8192				; 00002000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1333 : 				else

	jmp	SHORT $LN345@Exec
$LN193@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 210  : 	void INSOff(INSAlignFlags fl) { INSFlags &= ~fl; };

	mov	ecx, 8192				; 00002000H
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+768]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], ecx
$LN345@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1337 : 				if(HasPower(AircraftClass::RightHptPower) && PodCooling > -1.0F)

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN191@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+888]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN191@Exec

; 1338 : 					PodCooling -= SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+888]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+888], xmm0

; 1339 : 				else	//warm it up if we don't have power

	jmp	SHORT $LN190@Exec
$LN191@Exec:

; 1340 : 					PodCooling += SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+888]
	addss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+888], xmm0
$LN190@Exec:

; 1341 : 			}
; 1342 : 			//RALT stuff
; 1343 : 			//Cobra Hack attempt to keep RALT ON and CoolTime down when Combat AI is engaged
; 1344 : 			//and disengaged.
; 1345 : 			if (autopilotType == CombatAP && RALTCoolTime != -1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+968], 2
	jne	SHORT $LN189@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1008]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN189@Exec

; 1346 : 			{
; 1347 : 				RALTCoolTime = -1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+1008], xmm0

; 1348 : 				RALTStatus = RaltStatus::RON; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1004], 2
	jmp	$LN186@Exec
$LN189@Exec:

; 1349 : 			}
; 1350 : 			//made this an else if, the rest is orig code.
; 1351 : 			else if(HasPower(RaltPower) && RALTCoolTime > -1.0F && RALTStatus != RaltStatus::ROFF) 

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN187@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1008]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN187@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1004], 0
	je	SHORT $LN187@Exec

; 1352 : 				RALTCoolTime -= SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1008]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1008], xmm0

; 1353 : 			else

	jmp	SHORT $LN186@Exec
$LN187@Exec:

; 1354 : 				RALTCoolTime += SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1008]
	addss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1008], xmm0
$LN186@Exec:

; 1355 : 		}
; 1356 : 	}
; 1357 : 
; 1358 : 	//START_PROFILE("AC_EXEC_VEH");
; 1359 : 	// Base Class Exec
; 1360 : 
; 1361 : 	//RV - I-Hawk - Removed the burning SFX stuff here as not handled in simveh.cpp anymore...
; 1362 : 	if ( pctStrength <= 0.0f && !IsExploding() && (DrawableBSP*)drawPointer)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+292]
	jb	$LN174@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+208]
	call	edx
	test	eax, eax
	jne	$LN174@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+332], 0
	je	$LN174@Exec

; 1363 : 	{
; 1364 : 		Trotation *orientation = &((DrawableBSP*)drawPointer)->orientation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	add	edx, 48					; 00000030H
	mov	DWORD PTR _orientation$11[ebp], edx

; 1365 : 		Tpoint pos, vec; 
; 1366 : 
; 1367 : 		if (gSfxLOD >= 0.5f)

	movss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	comiss	xmm0, DWORD PTR __real@3f000000
	jb	$LN174@Exec

; 1368 : 		{
; 1369 : 			// update dying timer
; 1370 : 			dyingTimer += SimLibMajorFrameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+248]
	addss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+248], xmm0

; 1371 : 
; 1372 : 			// Do nothing for the 1st part of dying
; 1373 : 			if ( pctStrength > -0.07f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+292]
	comiss	xmm0, DWORD PTR __real@bd8f5c29
	jbe	SHORT $LN183@Exec
	jmp	$LN174@Exec
$LN183@Exec:

; 1374 : 			{
; 1375 : 			}
; 1376 : 			else if ( pctStrength > -0.3f ) // I-Hawk - was -0.5f before

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+292]
	comiss	xmm0, DWORD PTR __real@be99999a
	jbe	$LN181@Exec

; 1377 : 			{
; 1378 : 				if ( dyingTimer > 0.3f ) // 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+248]
	comiss	xmm0, DWORD PTR __real@3e99999a
	jbe	$LN180@Exec

; 1379 : 				{
; 1380 : 					//RV - I-Hawk - Randomized burning position...
; 1381 : 					randomizeBurn(*this, PSFX_AC_EARLY_BURNING, pos, vec);

	lea	edx, DWORD PTR _vec$307[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$306[ebp]
	push	eax
	push	124					; 0000007cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
	add	esp, 16					; 00000010H

; 1382 : 					
; 1383 : 					for ( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$270[ebp], 0
	jmp	SHORT $LN179@Exec
$LN178@Exec:
	mov	edx, DWORD PTR _i$270[ebp]
	add	edx, 1
	mov	DWORD PTR _i$270[ebp], edx
$LN179@Exec:
	cmp	DWORD PTR _i$270[ebp], 3
	jge	$LN177@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR $T103[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$285[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$285[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$285[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	ecx, DWORD PTR _FastRandom$285[ebp]
	mov	DWORD PTR $T50[ebp], ecx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	edx, DWORD PTR $T50[ebp]
	and	edx, 65535				; 0000ffffH
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _x$210[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$210[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T208[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1385 : 						vec.x = XDelta() * 0.5f + PRANDFloat() * 20.0f;

	movss	xmm0, DWORD PTR $T103[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR $T208[ebp]
	mulss	xmm1, DWORD PTR __real@41a00000
	addss	xmm0, xmm1
	movss	DWORD PTR _vec$307[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR $T101[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$287[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$287[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$287[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	ecx, DWORD PTR _FastRandom$287[ebp]
	mov	DWORD PTR $T17[ebp], ecx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	edx, DWORD PTR $T17[ebp]
	and	edx, 65535				; 0000ffffH
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _x$206[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$206[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T204[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1386 : 						vec.y = YDelta() * 0.5f + PRANDFloat() * 20.0f;

	movss	xmm0, DWORD PTR $T101[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR $T204[ebp]
	mulss	xmm1, DWORD PTR __real@41a00000
	addss	xmm0, xmm1
	movss	DWORD PTR _vec$307[ebp+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR $T99[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$286[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$286[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$286[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	ecx, DWORD PTR _FastRandom$286[ebp]
	mov	DWORD PTR $T48[ebp], ecx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	edx, DWORD PTR $T48[ebp]
	and	edx, 65535				; 0000ffffH
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _x$202[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$202[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T200[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1387 : 						vec.z = ZDelta() * 0.5f + PRANDFloat() * 20.0f;

	movss	xmm0, DWORD PTR $T99[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR $T200[ebp]
	mulss	xmm1, DWORD PTR __real@41a00000
	addss	xmm0, xmm1
	movss	DWORD PTR _vec$307[ebp+8], xmm0

; 1388 : 
; 1389 : 						DrawableParticleSys::PS_AddParticleEx(
; 1390 : 							(SFX_AC_DEBRIS + 1), &pos, &vec
; 1391 : 						);

	lea	eax, DWORD PTR _vec$307[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$306[ebp]
	push	ecx
	push	63					; 0000003fH
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 1392 : 					}

	jmp	$LN178@Exec
$LN177@Exec:

; 1393 : 					
; 1394 : 					// zero out
; 1395 : 					dyingTimer = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+248], xmm0
$LN180@Exec:

; 1396 : 				}
; 1397 : 		   }

	jmp	$LN174@Exec
$LN181@Exec:

; 1398 : 			else switch( dyingType ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+696]
	mov	DWORD PTR tv813[ebp], ecx
	cmp	DWORD PTR tv813[ebp], 6
	ja	$LN165@Exec
	mov	edx, DWORD PTR tv813[ebp]
	jmp	DWORD PTR $LN862@Exec[edx*4]
$LN173@Exec:

; 1399 : 			   case 5:
; 1400 : 			   case SimVehicleClass::DIE_SMOKE:
; 1401 : 					if (dyingTimer > 0.10f + ( 1.0f - gSfxLOD ) * 0.3f){

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+248]
	comiss	xmm1, xmm0
	jbe	SHORT $LN172@Exec

; 1402 : 					   // run stuff here....
; 1403 : 					   //RV - I-Hawk - Randomized burning position...
; 1404 : 						randomizeBurn(*this, PSFX_AC_BURNING_1, pos, vec);

	lea	ecx, DWORD PTR _vec$307[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$306[ebp]
	push	edx
	push	125					; 0000007dH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
	add	esp, 16					; 00000010H

; 1405 : 						dyingTimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+248], xmm0
$LN172@Exec:

; 1406 : 				   }
; 1407 : 				   break;

	jmp	$LN174@Exec
$LN171@Exec:

; 1408 : 			   case 6:
; 1409 : 			   case SimVehicleClass::DIE_SHORT_FIREBALL:
; 1410 : 					if ( dyingTimer > 0.10f + ( 1.0f - gSfxLOD ) * 0.3f ){

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+248]
	comiss	xmm1, xmm0
	jbe	SHORT $LN170@Exec

; 1411 : 					  //RV - I-Hawk - Randomized burning position...
; 1412 : 						randomizeBurn(*this, PSFX_AC_BURNING_3, pos, vec);   

	lea	eax, DWORD PTR _vec$307[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$306[ebp]
	push	ecx
	push	127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
	add	esp, 16					; 00000010H

; 1413 : 					   // reset the timer
; 1414 : 					   dyingTimer = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+248], xmm0
$LN170@Exec:

; 1415 : 				   }
; 1416 : 				   break;

	jmp	$LN174@Exec
$LN169@Exec:

; 1417 : 			   case SimVehicleClass::DIE_INTERMITTENT_SMOKE:
; 1418 : 					if ( dyingTimer > 0.10f + ( 1.0f - gSfxLOD ) * 0.3f ){

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+248]
	comiss	xmm1, xmm0
	jbe	SHORT $LN168@Exec

; 1419 : 					   //RV - I-Hawk - Randomized burning position...
; 1420 : 						randomizeBurn(*this, PSFX_AC_BURNING_2, pos, vec);

	lea	edx, DWORD PTR _vec$307[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$306[ebp]
	push	eax
	push	126					; 0000007eH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
	add	esp, 16					; 00000010H

; 1421 : 						// reset the timer
; 1422 : 						dyingTimer = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+248], xmm0
$LN168@Exec:

; 1423 : 				   }
; 1424 : 				   break;

	jmp	$LN174@Exec
$LN167@Exec:

; 1425 : 			   case SimVehicleClass::DIE_FIREBALL:
; 1426 : 					if ( dyingTimer > 0.10f + ( 1.0f - gSfxLOD ) * 0.3f ){

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+248]
	comiss	xmm1, xmm0
	jbe	SHORT $LN166@Exec

; 1427 : 					   // run stuff here....
; 1428 : 					   //RV - I-Hawk - Randomized burning position...
; 1429 : 						randomizeBurn(*this, PSFX_AC_BURNING_4, pos, vec);

	lea	ecx, DWORD PTR _vec$307[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$306[ebp]
	push	edx
	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
	add	esp, 16					; 00000010H

; 1430 : 					   // reset the timer
; 1431 : 					   dyingTimer = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+248], xmm0
$LN166@Exec:

; 1432 : 				   }
; 1433 : 				   break;

	jmp	SHORT $LN174@Exec
$LN165@Exec:

; 1434 : 			   case SimVehicleClass::DIE_INTERMITTENT_FIRE:
; 1435 : 			   default:
; 1436 : 					if ( dyingTimer > 0.10f + ( 1.0f - gSfxLOD ) * 0.3f ){

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+248]
	comiss	xmm1, xmm0
	jbe	SHORT $LN164@Exec

; 1437 : 						randomizeBurn(*this, PSFX_AC_BURNING_6, pos, vec);

	lea	eax, DWORD PTR _vec$307[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$306[ebp]
	push	ecx
	push	130					; 00000082H
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?randomizeBurn@?A0x19968561@@YAXABVAircraftClass@@IAAUTpoint@@1@Z ; `anonymous namespace'::randomizeBurn
	add	esp, 16					; 00000010H

; 1438 : 					   // reset the timer
; 1439 : 					   dyingTimer = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+248], xmm0
$LN164@Exec:
$LN174@Exec:

; 1440 : 				   }
; 1441 : 				   break;
; 1442 : 			} // end switch
; 1443 : 		} // end if LOD
; 1444 : 	}
; 1445 : 	SimVehicleClass::Exec();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Exec@SimVehicleClass@@UAEHXZ		; SimVehicleClass::Exec

; 1446 : 	//STOP_PROFILE("AC_EXEC_VEH");
; 1447 : 
; 1448 : 	if (IsExploding()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	je	$LN163@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	and	edx, 256				; 00000100H
	je	SHORT $LN367@Exec
	mov	DWORD PTR tv4046[ebp], 1
	jmp	SHORT $LN368@Exec
$LN367@Exec:
	mov	DWORD PTR tv4046[ebp], 0
$LN368@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1449 : 		if ( !IsSetFlag( SHOW_EXPLOSION ) ){

	cmp	DWORD PTR tv4046[ebp], 0
	jne	SHORT $LN162@Exec

; 1450 : 			RunExplosion();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunExplosion@AircraftClass@@QAEXXZ	; AircraftClass::RunExplosion

; 1451 : 			SetFlag(SHOW_EXPLOSION);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T30[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1452 : 			if (this == SimDriver.GetPlayerEntity()){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR $T30[ebp]
	jne	SHORT $LN161@Exec

; 1453 : 				JoystickPlayEffect (JoyHitEffect, 0);

	push	0
	push	1
	call	?JoystickPlayEffect@@YAHHH@Z		; JoystickPlayEffect
	add	esp, 8
$LN161@Exec:

; 1454 : 			}
; 1455 : 			SetDead(TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+364]
	call	edx
$LN162@Exec:

; 1456 : 		}
; 1457 : 		return TRUE;

	mov	eax, 1
	jmp	$LN229@Exec
	jmp	$LN159@Exec
$LN163@Exec:

; 1458 : 	}
; 1459 : 	else if (!IsDead()){	

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	$LN159@Exec

; 1460 : 		// Sound effects....
; 1461 : 		if ( pctStrength > 0.0f ){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN158@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR $T275[ebp], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1462 : 			VehicleClassDataType *vc = GetVehicleClassData(Type() - VU_LAST_ENTITY_TYPE);

	movzx	ecx, WORD PTR $T275[ebp]
	sub	ecx, 100				; 00000064H
	push	ecx
	call	?GetVehicleClassData@@YAPAUVehicleClassDataType@@H@Z ; GetVehicleClassData
	add	esp, 4
	mov	DWORD PTR _vc$237[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h

; 245  : 			if (mOTWDisplayMode >= ModeHud && mOTWDisplayMode <= ModePadlockEFOV )

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32328, 1
	jl	SHORT $LN373@Exec
	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32328, 5
	jg	SHORT $LN373@Exec

; 246  : 		  		return TRUE;

	mov	DWORD PTR _inckpt$267[ebp], 1
	jmp	SHORT $LN374@Exec
$LN373@Exec:

; 247  : 			return FALSE;

	mov	DWORD PTR _inckpt$267[ebp], 0
$LN374@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1467 : 			if ( af && af->GetSimpleMode() == SIMPLE_MODE_HF ){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+932], 0
	je	SHORT $LN157@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1224 : 	int  GetSimpleMode(void) {return simpleMode;};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+824]
	mov	DWORD PTR $T198[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1467 : 			if ( af && af->GetSimpleMode() == SIMPLE_MODE_HF ){

	cmp	DWORD PTR $T198[ebp], 2
	jne	SHORT $LN157@Exec

; 1468 : 				// MLR this appears to not be used anymore
; 1469 : 				SoundPos.Sfx(SFX_ENGHELI, 0, 0.5f + af->rpm/3.0F, 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1212]
	divss	xmm0, DWORD PTR __real@40400000
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 1470 : 			}
; 1471 : 			else {

	jmp	$LN127@Exec
$LN157@Exec:

; 1472 : 				if(g_bNewEngineSounds){

	movzx	edx, BYTE PTR ?g_bNewEngineSounds@@3_NA	; g_bNewEngineSounds
	test	edx, edx
	je	$LN155@Exec

; 1473 : 					float p,p1,v; // pitch, vol
; 1474 : 					int t;
; 1475 : 					int eng;
; 1476 : 					int engines;
; 1477 : 					float rpm[4];
; 1478 : 					float pwr; 
; 1479 : 
; 1480 : 					if(af->auxaeroData->sndInt==-1){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+616], -1
	jne	SHORT $LN154@Exec

; 1481 : 						af->auxaeroData->sndInt=vc->EngineSound;

	mov	eax, DWORD PTR _vc$237[ebp]
	movsx	ecx, WORD PTR [eax+46]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+616], ecx
$LN154@Exec:

; 1482 : 					}
; 1483 : 
; 1484 : 					if(!IsLocal()) // MLR 2/29/2004 - for MP engine sounds

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN153@Exec

; 1485 : 					{
; 1486 : 						af->rpm  = specialData.powerOutput;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR [edx+1212], ecx

; 1487 : 						af->rpm2 = specialData.powerOutput2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+1216], edx
$LN153@Exec:

; 1488 : 					}
; 1489 : 
; 1490 : 					if(af->auxaeroData->nEngines==2){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 2
	jne	SHORT $LN152@Exec

; 1491 : 						engines = 2;

	mov	DWORD PTR _engines$268[ebp], 2

; 1492 : 						rpm[0] = af->rpm;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [ecx+1212]
	mov	DWORD PTR _rpm$309[ebp+edx], eax

; 1493 : 						rpm[1] = af->rpm2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+1216]
	mov	DWORD PTR _rpm$309[ebp+eax], ecx

; 1494 : 					}
; 1495 : 					else{

	jmp	$LN151@Exec
$LN152@Exec:

; 1496 : 						if(g_bMultiEngineSound){

	movzx	edx, BYTE PTR ?g_bMultiEngineSound@@3_NA ; g_bMultiEngineSound
	test	edx, edx
	je	SHORT $LN150@Exec

; 1497 : 							engines = min(af->auxaeroData->nEngines,4);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 4
	jge	SHORT $LN237@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+344]
	mov	DWORD PTR tv1091[ebp], eax
	jmp	SHORT $LN238@Exec
$LN237@Exec:
	mov	DWORD PTR tv1091[ebp], 4
$LN238@Exec:
	mov	ecx, DWORD PTR tv1091[ebp]
	mov	DWORD PTR _engines$268[ebp], ecx

; 1498 : 						}
; 1499 : 						else{

	jmp	SHORT $LN149@Exec
$LN150@Exec:

; 1500 : 							engines = 1;

	mov	DWORD PTR _engines$268[ebp], 1
$LN149@Exec:

; 1501 : 						}
; 1502 : 						rpm[0] = af->rpm;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+1212]
	mov	DWORD PTR _rpm$309[ebp+ecx], edx

; 1503 : 						rpm[1] = af->rpm;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+1212]
	mov	DWORD PTR _rpm$309[ebp+edx], eax

; 1504 : 						rpm[2] = af->rpm;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+1212]
	mov	DWORD PTR _rpm$309[ebp+eax], ecx

; 1505 : 						rpm[3] = af->rpm;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR [eax+1212]
	mov	DWORD PTR _rpm$309[ebp+ecx], edx
$LN151@Exec:

; 1506 : 					}
; 1507 : 
; 1508 : 
; 1509 : 					for(eng=0;eng<engines;eng++)

	mov	DWORD PTR _eng$296[ebp], 0
	jmp	SHORT $LN148@Exec
$LN147@Exec:
	mov	eax, DWORD PTR _eng$296[ebp]
	add	eax, 1
	mov	DWORD PTR _eng$296[ebp], eax
$LN148@Exec:
	mov	ecx, DWORD PTR _eng$296[ebp]
	cmp	ecx, DWORD PTR _engines$268[ebp]
	jge	$LN146@Exec

; 1510 : 					{
; 1511 : 						pwr = rpm[eng];

	mov	edx, DWORD PTR _eng$296[ebp]
	movss	xmm0, DWORD PTR _rpm$309[ebp+edx*4]
	movss	DWORD PTR _pwr$298[ebp], xmm0

; 1512 : 						if ( pwr > 0.01f )

	movss	xmm0, DWORD PTR _pwr$298[ebp]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	$LN145@Exec

; 1513 : 						{							
; 1514 : 							p = pwr / .7f;

	movss	xmm0, DWORD PTR _pwr$298[ebp]
	divss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR _p$10[ebp], xmm0

; 1515 : 							if(!isDigital && inckpt && IsLocal())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	jne	$LN142@Exec
	cmp	DWORD PTR _inckpt$267[ebp], 0
	je	$LN142@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN142@Exec

; 1516 : 							{
; 1517 : 								// internal sounds
; 1518 : 								v=(1.0f - af->auxaeroData->sndIntChart.Lookup(pwr)) * -10000;

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 644				; 00000284H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv5920[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv5920[ebp]
	mulss	xmm0, DWORD PTR __real@c61c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1519 : 								p1=af->auxaeroData->sndIntPitchChart.Lookup(pwr);

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 1148				; 0000047cH
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR _p1$294[ebp]

; 1520 : 								SoundPos.Sfx(af->auxaeroData->sndInt,eng,p1,v);

	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1$294[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _eng$296[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+616]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 1521 : 								
; 1522 : 								if(af->auxaeroData->sndAbInt)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+620], 0
	je	$LN143@Exec

; 1523 : 								{
; 1524 : 									v=(1.0f - af->auxaeroData->sndAbIntChart.Lookup(pwr)) * -10000;

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 728				; 000002d8H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv5942[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv5942[ebp]
	mulss	xmm0, DWORD PTR __real@c61c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1525 : 									p1=af->auxaeroData->sndAbIntPitchChart.Lookup(pwr);

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 1232				; 000004d0H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR _p1$294[ebp]

; 1526 : 									SoundPos.Sfx(af->auxaeroData->sndAbInt,eng,p1,v);

	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1$294[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _eng$296[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+620]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN143@Exec:

; 1527 : 								}
; 1528 : 								
; 1529 : 								if(af->auxaeroData->sndInt2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+624], 0
	je	$LN142@Exec

; 1530 : 								{
; 1531 : 									v=(1.0f - af->auxaeroData->sndInt2Chart.Lookup(pwr)) * -10000;

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 812				; 0000032cH
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv5964[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv5964[ebp]
	mulss	xmm0, DWORD PTR __real@c61c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1532 : 									p1=af->auxaeroData->sndInt2PitchChart.Lookup(pwr);

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 1316				; 00000524H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR _p1$294[ebp]

; 1533 : 									SoundPos.Sfx(af->auxaeroData->sndInt2,eng,p1,v);

	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1$294[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _eng$296[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+624]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN142@Exec:

; 1534 : 								}
; 1535 : 							}
; 1536 : 							
; 1537 : 							// external sounds
; 1538 : 							v=(1.0f - af->auxaeroData->sndExtChart.Lookup(pwr)) * -10000;

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 896				; 00000380H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv5985[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv5985[ebp]
	mulss	xmm0, DWORD PTR __real@c61c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1539 : 							p1=af->auxaeroData->sndExtPitchChart.Lookup(pwr);

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 1400				; 00000578H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR _p1$294[ebp]

; 1540 : 							SoundPos.SfxRel(af->auxaeroData->sndExt,eng,p1,v, af->auxaeroData->engineLocation[eng] );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _eng$296[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR [edx+eax+348]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1$294[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _eng$296[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+628]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?SfxRel@F4SoundPos@@QAEXHHMMAAUTpoint@@@Z ; F4SoundPos::SfxRel

; 1541 : 							
; 1542 : 							v=(1.0f - af->auxaeroData->sndAbExtChart.Lookup(pwr)) * -10000;

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 980				; 000003d4H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv6008[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv6008[ebp]
	mulss	xmm0, DWORD PTR __real@c61c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1543 : 							p1=af->auxaeroData->sndAbExtPitchChart.Lookup(pwr);

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 1484				; 000005ccH
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR _p1$294[ebp]

; 1544 : 							SoundPos.SfxRel(af->auxaeroData->sndAbExt,eng,p1,v, af->auxaeroData->engineLocation[eng] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eng$296[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+edx+348]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1$294[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _eng$296[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+632]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?SfxRel@F4SoundPos@@QAEXHHMMAAUTpoint@@@Z ; F4SoundPos::SfxRel

; 1545 : 							
; 1546 : 							v=(1.0f - af->auxaeroData->sndExt2Chart.Lookup(pwr)) * -10000;

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 1064				; 00000428H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv6031[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv6031[ebp]
	mulss	xmm0, DWORD PTR __real@c61c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1547 : 							p1=af->auxaeroData->sndExt2PitchChart.Lookup(pwr);

	push	ecx
	movss	xmm0, DWORD PTR _pwr$298[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1568				; 00000620H
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR _p1$294[ebp]

; 1548 : 							SoundPos.SfxRel(af->auxaeroData->sndExt2,eng,p1,v,	af->auxaeroData->engineLocation[eng] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _eng$296[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+ecx+348]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1$294[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _eng$296[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+636]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?SfxRel@F4SoundPos@@QAEXHHMMAAUTpoint@@@Z ; F4SoundPos::SfxRel
$LN145@Exec:

; 1549 : 						}
; 1550 : 						pwr=af->rpm2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1216]
	movss	DWORD PTR _pwr$298[ebp], xmm0

; 1551 : 					}

	jmp	$LN147@Exec
$LN146@Exec:

; 1552 : 					
; 1553 : 					for(t=0;t<4 && af->auxaeroData->sndAero[t];t++)

	mov	DWORD PTR _t$292[ebp], 0
	jmp	SHORT $LN141@Exec
$LN140@Exec:
	mov	ecx, DWORD PTR _t$292[ebp]
	add	ecx, 1
	mov	DWORD PTR _t$292[ebp], ecx
$LN141@Exec:
	cmp	DWORD PTR _t$292[ebp], 4
	jge	$LN139@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _t$292[ebp]
	cmp	DWORD PTR [ecx+edx*4+1656], 0
	je	$LN139@Exec

; 1554 : 					{
; 1555 : 						v=( af->auxaeroData->sndAeroAOAChart[t].Lookup(af->alpha) * 
; 1556 : 							af->auxaeroData->sndAeroSpeedChart[t].Lookup(af->mach) - 1.0f) 
; 1557 : 							* 10000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1152]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _t$292[ebp]
	imul	edx, 84					; 00000054H
	lea	ecx, DWORD PTR [ecx+edx+2008]
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv6061[ebp]
	movss	xmm0, DWORD PTR tv6061[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+1144]
	movss	DWORD PTR [esp], xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _t$292[ebp]
	imul	edx, 84					; 00000054H
	lea	ecx, DWORD PTR [ecx+edx+1672]
	movss	DWORD PTR tv7334[ebp], xmm0
	call	?Lookup@LookupTable@@QAEMM@Z		; LookupTable::Lookup
	fstp	DWORD PTR tv6070[ebp]
	movss	xmm0, DWORD PTR tv7334[ebp]
	mulss	xmm0, DWORD PTR tv6070[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR _v$297[ebp], xmm0

; 1558 : 						SoundPos.Sfx(af->auxaeroData->sndAero[t],t,1,v);

	push	ecx
	movss	xmm0, DWORD PTR _v$297[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _t$292[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _t$292[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+1656]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 1559 : 					}

	jmp	$LN140@Exec
$LN139@Exec:

; 1560 : 
; 1561 :                    // RV - I-Hawk - Using Airspeed to manage Envicontrolsys.wav sound emission
; 1562 :                    // in cockpit. If using the constant breathing .wav file, it'll be managed
; 1563 : 				   // properly	
; 1564 : 					if ( af->mach >= 0.55f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1144]
	comiss	xmm0, DWORD PTR __real@3f0ccccd
	jb	$LN138@Exec

; 1565 : 					{
; 1566 : 						float breathingPitch = 0.0f * ( af->nzcgs / 4.5f ) ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+268]
	divss	xmm0, DWORD PTR __real@40900000
	mulss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _breathingPitch$3[ebp], xmm0

; 1567 : 
; 1568 : 						float v;
; 1569 : 
; 1570 : 					   //base volume on Mach speed
; 1571 : 						v = ( ( af->mach - 1.0f ) * ( 5500.0f )   );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1144]
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@45abe000
	movss	DWORD PTR _v$291[ebp], xmm0

; 1572 : 
; 1573 :                        //no need for more volume if it's above 0...
; 1574 : 						if (v > 0)

	movss	xmm0, DWORD PTR _v$291[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN137@Exec

; 1575 : 						{
; 1576 : 							v = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _v$291[ebp], xmm0
$LN137@Exec:

; 1577 : 						}
; 1578 : 
; 1579 : 					   //if entering high G levels, reduce volume here as the other sound is 
; 1580 : 					   // starting...
; 1581 : 						if ( af->nzcgs > 5.5f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+268]
	comiss	xmm0, DWORD PTR __real@40b00000
	jbe	SHORT $LN136@Exec

; 1582 : 						{
; 1583 : 							v += ( ( 5.5f - af->nzcgs ) * 1250.0f );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@40b00000
	subss	xmm0, DWORD PTR [eax+268]
	mulss	xmm0, DWORD PTR __real@449c4000
	addss	xmm0, DWORD PTR _v$291[ebp]
	movss	DWORD PTR _v$291[ebp], xmm0
$LN136@Exec:

; 1584 : 						}
; 1585 : 					   //if velocity gets above stores maximum velocity, reduce volume here as
; 1586 : 					   //the other sound is starting...
; 1587 : 
; 1588 : 						
; 1589 : 						if( GetKias() > af->curMaxStoreSpeed )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv6099[ebp]
	movss	xmm0, DWORD PTR tv6099[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	comiss	xmm0, DWORD PTR [edx+1612]
	jbe	SHORT $LN135@Exec

; 1590 : 						{
; 1591 : 							v += ( ( ( af->curMaxStoreSpeed - GetKias() ) / 50.0f ) * 1250.0f );

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv6107[ebp]
	movss	xmm0, DWORD PTR [esi+1612]
	subss	xmm0, DWORD PTR tv6107[ebp]
	divss	xmm0, DWORD PTR __real@42480000
	mulss	xmm0, DWORD PTR __real@449c4000
	addss	xmm0, DWORD PTR _v$291[ebp]
	movss	DWORD PTR _v$291[ebp], xmm0
$LN135@Exec:

; 1592 : 						}
; 1593 : 						
; 1594 :                         																	 
; 1595 : 					//SoundPos.Sfx( SFX_ENGINEA, 0, GetKias()/450.0f, 0 );
; 1596 : 						SoundPos.Sfx( SFX_ENGINEA, 0, 2, v );

	push	ecx
	movss	xmm0, DWORD PTR _v$291[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	0
	push	33					; 00000021H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN138@Exec:

; 1597 : 					}
; 1598 : 				}
; 1599 : 				else

	jmp	$LN127@Exec
$LN155@Exec:

; 1600 : 				{   // old engine style
; 1601 : 					if(!isDigital && inckpt && IsLocal())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	jne	$LN133@Exec
	cmp	DWORD PTR _inckpt$267[ebp], 0
	je	$LN133@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	$LN133@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+188]
	movss	DWORD PTR $T191[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1604 : 						if ( PowerOutput() > 0.01f )

	movss	xmm0, DWORD PTR $T191[ebp]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	$LN130@Exec

; 1605 : 						{
; 1606 : 							if(af->auxaeroData->sndInt>0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+616], 0
	jle	SHORT $LN131@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	movss	DWORD PTR $T94[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1608 : 								SoundPos.Sfx( af->auxaeroData->sndInt, 0, 0.01f + PowerOutput() , 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c23d70a
	addss	xmm0, DWORD PTR $T94[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+616]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 1609 : 							}
; 1610 : 							else

	jmp	SHORT $LN130@Exec
$LN131@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+188]
	movss	DWORD PTR $T189[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1612 : 								SoundPos.Sfx( vc->EngineSound, 0, 0.01f + PowerOutput() , 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c23d70a
	addss	xmm0, DWORD PTR $T189[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _vc$237[ebp]
	movsx	edx, WORD PTR [ecx+46]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN130@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+188]
	movss	DWORD PTR $T28[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1616 : 						if (PowerOutput() > 1.0F)

	movss	xmm0, DWORD PTR $T28[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN129@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	movss	DWORD PTR $T187[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1617 : 							SoundPos.Sfx( af->auxaeroData->sndAbInt, 0, PowerOutput() - 0.25f , 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR $T187[ebp]
	subss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+620]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN129@Exec:

; 1618 : 
; 1619 : 						// wind noise
; 1620 : 						SoundPos.Sfx( SFX_ENGINEA, 0, GetKias()/450.0f, 0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv6155[ebp]
	movss	xmm0, DWORD PTR tv6155[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	push	33					; 00000021H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN133@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	movss	DWORD PTR $T185[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1626 : 						if ( PowerOutput() > 0.01f )

	movss	xmm0, DWORD PTR $T185[ebp]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN128@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+188]
	movss	DWORD PTR $T44[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1627 : 							SoundPos.Sfx( af->auxaeroData->sndExt, 0, 0.01f + PowerOutput() , 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c23d70a
	addss	xmm0, DWORD PTR $T44[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+628]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN128@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+188]
	movss	DWORD PTR $T183[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1629 : 						if (PowerOutput() > 1.0F)

	movss	xmm0, DWORD PTR $T183[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN127@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+188]
	movss	DWORD PTR $T91[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1630 : 							SoundPos.Sfx( af->auxaeroData->sndAbExt, 0, (PowerOutput() - 0.25f) , 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR $T91[ebp]
	subss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+632]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN127@Exec:

; 1631 : 					}
; 1632 : 				}
; 1633 : 				// stored the original code at the end of file				
; 1634 : 			}
; 1635 : 				
; 1636 : 		}
; 1637 : 		else

	jmp	SHORT $LN125@Exec
$LN158@Exec:

; 1638 : 		{
; 1639 : 			// plane is going down: strength < 0
; 1640 : 			SoundPos.Sfx( SFX_FIRELOOP, 0, 1.0f + pctStrength * 0.2f , 0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	push	105					; 00000069H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx

; 1641 : 			if ( af )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+932], 0
	je	SHORT $LN125@Exec

; 1642 : 				af->SetSimpleMode( SIMPLE_MODE_OFF );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetSimpleMode@AirframeClass@@QAEXH@Z	; AirframeClass::SetSimpleMode
$LN125@Exec:

; 1649 : 		){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN124@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, 28					; 0000001cH
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+1256]
	mov	ecx, DWORD PTR [eax+edx+12]
	and	ecx, 2
	jne	$LN124@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+760]
	and	eax, 32					; 00000020H
	je	SHORT $LN398@Exec
	mov	DWORD PTR tv4060[ebp], 1
	jmp	SHORT $LN399@Exec
$LN398@Exec:
	mov	DWORD PTR tv4060[ebp], 0
$LN399@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1649 : 		){

	movzx	ecx, BYTE PTR tv4060[ebp]
	test	ecx, ecx
	je	$LN124@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+760]
	and	eax, 4
	je	SHORT $LN402@Exec
	mov	DWORD PTR tv4063[ebp], 1
	jmp	SHORT $LN403@Exec
$LN402@Exec:
	mov	DWORD PTR tv4063[ebp], 0
$LN403@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1649 : 		){

	movzx	ecx, BYTE PTR tv4063[ebp]
	test	ecx, ecx
	je	$LN124@Exec

; 1650 : 			if(!pLandLitePool){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1472], 0
	jne	$LN123@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T181[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1652 : 				pos.x = XPos();

	movss	xmm0, DWORD PTR $T181[ebp]
	movss	DWORD PTR _pos$302[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T13[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1653 : 				pos.y = YPos();

	movss	xmm0, DWORD PTR $T13[ebp]
	movss	DWORD PTR _pos$302[ebp+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR $T179[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1654 : 				pos.z = ZPos();

	movss	xmm0, DWORD PTR $T179[ebp]
	movss	DWORD PTR _pos$302[ebp+8], xmm0

; 1655 : 				pLandLitePool = new DrawableGroundVehicle(MapVisId(VIS_LITEPOOL), &pos, Yaw());

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T257[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T257[ebp], 0
	je	SHORT $LN239@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR $T89[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1655 : 				pLandLitePool = new DrawableGroundVehicle(MapVisId(VIS_LITEPOOL), &pos, Yaw());

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T89[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos$302[ebp]
	push	ecx
	push	1332					; 00000534H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T257[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv1675[ebp], eax
	jmp	SHORT $LN240@Exec
$LN239@Exec:
	mov	DWORD PTR tv1675[ebp], 0
$LN240@Exec:
	mov	edx, DWORD PTR tv1675[ebp]
	mov	DWORD PTR $T177[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T177[ebp]
	mov	DWORD PTR [eax+1472], ecx

; 1656 : 				mInhibitLitePool = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1476], 1

; 1657 : 				OTWDriver.InsertObject(pLandLitePool);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1472]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN123@Exec:

; 1658 : 			}
; 1659 : 		} 
; 1660 : 		else {

	jmp	SHORT $LN122@Exec
$LN124@Exec:

; 1661 : 			CleanupLitePool();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLitePool@AircraftClass@@QAEXXZ	; AircraftClass::CleanupLitePool
$LN122@Exec:

; 1662 : 		}
; 1663 : 
; 1664 : 		if(pLandLitePool) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1472], 0
	je	$LN121@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 9
	jle	SHORT $LN412@Exec
	mov	ecx, 9
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 1
	mov	ecx, 9
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN412@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1675 : 			rot.M11		= dmx[0][0];

	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _rot$300[ebp], xmm0

; 1676 : 			rot.M21		= dmx[0][1];

	mov	edx, 12					; 0000000cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR _rot$300[ebp+12], xmm0

; 1677 : 			rot.M31		= dmx[0][2];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _rot$300[ebp+24], xmm0

; 1678 : 			
; 1679 : 			rot.M12		= dmx[1][0];

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _rot$300[ebp+4], xmm0

; 1680 : 			rot.M22		= dmx[1][1];

	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR _rot$300[ebp+16], xmm0

; 1681 : 			rot.M32		= dmx[1][2];

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _rot$300[ebp+28], xmm0

; 1682 : 			
; 1683 : 			rot.M13		= dmx[2][0];

	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _rot$300[ebp+8], xmm0

; 1684 : 			rot.M23		= dmx[2][1];

	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR _rot$300[ebp+20], xmm0

; 1685 : 			rot.M33		= dmx[2][2];

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _rot$300[ebp+32], xmm0

; 1686 : 			
; 1687 : 			// Set the position of the pool relative
; 1688 : 			// to the aircraft with a normalized vector
; 1689 : 			
; 1690 : 			relPos.x	= 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _relPos$301[ebp], xmm0

; 1691 : 			relPos.y	= 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _relPos$301[ebp+4], xmm0

; 1692 : 			relPos.z	= 0.23F; // tangent of 13 degrees (down)

	movss	xmm0, DWORD PTR __real@3e6b851f
	movss	DWORD PTR _relPos$301[ebp+8], xmm0

; 1693 : 			
; 1694 : 			MatrixMult (&rot, &relPos, &rotPos);

	lea	ecx, DWORD PTR _rotPos$308[ebp]
	push	ecx
	lea	edx, DWORD PTR _relPos$301[ebp]
	push	edx
	lea	eax, DWORD PTR _rot$300[ebp]
	push	eax
	call	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z ; MatrixMult
	add	esp, 12					; 0000000cH
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T42[ebp], xmm0

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR $T175[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1697 : 			groundLevel = OTWDriver.GetGroundLevel (XPos(), YPos());

	push	0
	push	ecx
	movss	xmm0, DWORD PTR $T42[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T175[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundLevel$173[ebp]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR $T236[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1701 : 			float	ZDiff=ZPos()-groundLevel;

	movss	xmm0, DWORD PTR $T236[ebp]
	subss	xmm0, DWORD PTR _groundLevel$173[ebp]
	movss	DWORD PTR _ZDiff$255[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1207 : 	float GetAeroData(int which) const { return aeroDataset[vehicleIndex].inputData[which]; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movsx	eax, WORD PTR [edx+92]
	imul	eax, 220				; 000000dcH
	add	eax, DWORD PTR ?aeroDataset@@3PAVAeroDataSet@@A ; aeroDataset
	mov	ecx, 16					; 00000010H
	shl	ecx, 2
	movss	xmm0, DWORD PTR [eax+ecx+16]
	movss	DWORD PTR $T26[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1703 : 			float	LiteZ=af->GetAeroData(AeroDataSet::NosGearZ)/2;

	movss	xmm0, DWORD PTR $T26[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _LiteZ$241[ebp], xmm0

; 1704 : 			/// calculate the light projection at given angle
; 1705 : 			scale			= -(ZDiff-LiteZ)/rotPos.z;

	movss	xmm0, DWORD PTR _ZDiff$255[ebp]
	subss	xmm0, DWORD PTR _LiteZ$241[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _rotPos$308[ebp+8]
	movss	DWORD PTR _scale$265[ebp], xmm0

; 1706 : 			//float z=aeroDataset[af->VehicleIndex()].inputData[AeroDataSet::NosGearY]
; 1707 : 
; 1708 : 			if(rotPos.z <= 0.0F) {

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _rotPos$308[ebp+8]
	jb	SHORT $LN120@Exec

; 1709 : 				mInhibitLitePool = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1476], 1

; 1710 : 			}
; 1711 : 			else {

	jmp	$LN119@Exec
$LN120@Exec:

; 1712 : 				mInhibitLitePool = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1476], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR $T171[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1714 : 				rotPos.x	= XPos() + rotPos.x * (scale + 25.0F);

	movss	xmm0, DWORD PTR _scale$265[ebp]
	addss	xmm0, DWORD PTR __real@41c80000
	mulss	xmm0, DWORD PTR _rotPos$308[ebp]
	addss	xmm0, DWORD PTR $T171[ebp]
	movss	DWORD PTR _rotPos$308[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T85[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1715 : 				rotPos.y	= YPos() + rotPos.y * (scale + 25.0F);

	movss	xmm0, DWORD PTR _scale$265[ebp]
	addss	xmm0, DWORD PTR __real@41c80000
	mulss	xmm0, DWORD PTR _rotPos$308[ebp+4]
	addss	xmm0, DWORD PTR $T85[ebp]
	movss	DWORD PTR _rotPos$308[ebp+4], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR $T169[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1716 : 				rotPos.z	= ZPos() + rotPos.z * scale;

	movss	xmm0, DWORD PTR _rotPos$308[ebp+8]
	mulss	xmm0, DWORD PTR _scale$265[ebp]
	addss	xmm0, DWORD PTR $T169[ebp]
	movss	DWORD PTR _rotPos$308[ebp+8], xmm0

; 1717 : 
; 1718 : 				pLandLitePool->SetScale(1+(2-(LiteZ*4)/-ZDiff));

	movss	xmm0, DWORD PTR _ZDiff$255[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _LiteZ$241[ebp]
	mulss	xmm1, DWORD PTR __real@40800000
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR $T254[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1472]
	mov	DWORD PTR $T277[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h

; 35   :         radius = (s/scale)*radius; 

	mov	eax, DWORD PTR $T277[ebp]
	movss	xmm0, DWORD PTR $T254[ebp]
	divss	xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR $T277[ebp]
	mulss	xmm0, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR $T277[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 36   :         scale = s; 

	mov	eax, DWORD PTR $T277[ebp]
	movss	xmm0, DWORD PTR $T254[ebp]
	movss	DWORD PTR [eax+20], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR $T40[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1719 : 				pLandLitePool->Update (&rotPos, Yaw());

	push	ecx
	movss	xmm0, DWORD PTR $T40[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _rotPos$308[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1472]
	call	?Update@DrawableGroundVehicle@@QAEXPAUTpoint@@M@Z ; DrawableGroundVehicle::Update
$LN119@Exec:

; 1720 : 			}
; 1721 : 
; 1722 : 			pLandLitePool->SetInhibitFlag(mInhibitLitePool);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1476]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1472]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+1472]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1723 : 		} 
; 1724 : 		else {

	jmp	SHORT $LN434@Exec
$LN121@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 9
	jle	SHORT $LN433@Exec
	mov	ecx, 9
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 0
	mov	ecx, 9
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN433@Exec:
$LN434@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	ecx, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T167[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1730 : 		if (gACMIRec.IsRecording() && (SimLibFrameCount & 0x0000000f ) == 0){

	cmp	DWORD PTR $T167[ebp], 0
	je	$LN117@Exec
	mov	edx, DWORD PTR ?SimLibFrameCount@@3IA	; SimLibFrameCount
	and	edx, 15					; 0000000fH
	jne	$LN117@Exec

; 1731 : 			airPos.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv6344[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv6344[ebp]
	mov	ecx, DWORD PTR tv6344[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv6348[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv6348[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR _airPos$[ebp+1], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR $T274[ebp], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1732 : 			airPos.data.type = Type();

	movzx	ecx, WORD PTR $T274[ebp]
	mov	DWORD PTR _airPos$[ebp+5], ecx

; 1735 : 			);//.num_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	DWORD PTR $T83[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h

; 329  : 	int GetColor (void)							{ return (int) teamColor; }

	mov	edx, DWORD PTR $T83[ebp]
	movzx	eax, BYTE PTR [edx+889]
	mov	DWORD PTR $T165[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h

; 62   : 	char *Label()											{ return label; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	add	edx, 128				; 00000080H
	mov	DWORD PTR $T19[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T43[ebp], ecx
	mov	DWORD PTR $T43[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1735 : 			);//.num_;

	mov	eax, DWORD PTR $T165[ebp]
	push	eax
	mov	ecx, DWORD PTR $T19[ebp]
	push	ecx
	mov	edx, DWORD PTR $T43[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T43[ebp]
	push	eax
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z	; ACMI_Hash::Add
	mov	DWORD PTR _airPos$[ebp+9], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR $T163[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1736 : 			airPos.data.x = XPos();

	movss	xmm0, DWORD PTR $T163[ebp]
	movss	DWORD PTR _airPos$[ebp+13], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T81[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1737 : 			airPos.data.y = YPos();

	movss	xmm0, DWORD PTR $T81[ebp]
	movss	DWORD PTR _airPos$[ebp+17], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR $T161[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1738 : 			airPos.data.z = ZPos();

	movss	xmm0, DWORD PTR $T161[ebp]
	movss	DWORD PTR _airPos$[ebp+21], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+68]
	movss	DWORD PTR $T38[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1739 : 			airPos.data.roll = Roll();

	movss	xmm0, DWORD PTR $T38[ebp]
	movss	DWORD PTR _airPos$[ebp+33], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	movss	DWORD PTR $T159[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1740 : 			airPos.data.pitch = Pitch();

	movss	xmm0, DWORD PTR $T159[ebp]
	movss	DWORD PTR _airPos$[ebp+29], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR $T79[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1741 : 			airPos.data.yaw = Yaw();

	movss	xmm0, DWORD PTR $T79[ebp]
	movss	DWORD PTR _airPos$[ebp+25], xmm0

; 1742 : 			RadarClass *radar = (RadarClass*)FindSensor( this, SensorClass::Radar );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _radar$263[ebp], eax

; 1744 : 			if (  radar && radar->CurrentTarget() ){

	cmp	DWORD PTR _radar$263[ebp], 0
	je	SHORT $LN116@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 46   : 	SimObjectType* CurrentTarget(void)	{ return lockedTarget; };

	mov	edx, DWORD PTR _radar$263[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T157[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1744 : 			if (  radar && radar->CurrentTarget() ){

	cmp	DWORD PTR $T157[ebp], 0
	je	SHORT $LN116@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h

; 46   : 	SimObjectType* CurrentTarget(void)	{ return lockedTarget; };

	mov	ecx, DWORD PTR _radar$263[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T24[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR $T24[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T155[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR $T155[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T41[ebp], eax
	mov	DWORD PTR $T41[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1745 : 				airPos.RadarTarget = ACMIIDTable->Add(radar->CurrentTarget()->BaseData()->Id(),NULL,0);//.num_;

	push	0
	push	0
	mov	edx, DWORD PTR $T41[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T41[ebp]
	push	eax
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z	; ACMI_Hash::Add
	mov	DWORD PTR _airPos$[ebp+37], eax

; 1746 : 			}
; 1747 : #else
; 1748 : 			if (radar && radar->RemoteBuggedTarget){
; 1749 : 				//me123 add record for online targets
; 1750 : 				airPos.RadarTarget = ACMIIDTable->Add(radar->RemoteBuggedTarget->Id(),NULL,0);//.num_;
; 1751 : 			}
; 1752 : 			else if (  radar && radar->CurrentTarget() ){
; 1753 : 				airPos.RadarTarget = ACMIIDTable->Add(radar->CurrentTarget()->BaseData()->Id(),NULL,0);//.num_;
; 1754 : 			}
; 1755 : #endif
; 1756 : 			else {

	jmp	SHORT $LN115@Exec
$LN116@Exec:

; 1757 : 				airPos.RadarTarget = -1;

	mov	DWORD PTR _airPos$[ebp+37], -1
$LN115@Exec:

; 1758 : 			}
; 1759 : 			gACMIRec.AircraftPositionRecord( &airPos );

	lea	ecx, DWORD PTR _airPos$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?AircraftPositionRecord@ACMIRecorder@@QAEXPAUACMIAircraftPositionRecord@@@Z ; ACMIRecorder::AircraftPositionRecord
$LN117@Exec:

; 1760 : 		}
; 1761 : 
; 1762 : 		if (!IsLocal()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN114@Exec

; 1763 : 			ShowDamage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowDamage@AircraftClass@@QAEXXZ	; AircraftClass::ShowDamage

; 1764 : 			af->RemoteUpdate();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?RemoteUpdate@AirframeClass@@QAEXXZ	; AirframeClass::RemoteUpdate

; 1765 : 			return FALSE;

	xor	eax, eax
	jmp	$LN229@Exec
$LN114@Exec:

; 1766 : 		}
; 1767 : 
; 1768 : 		//START_PROFILE("AC_EXEC_5d1");
; 1769 : 		// Increment the SendStatus Timer
; 1770 : 		requestCount ++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+628], edx

; 1771 : 		
; 1772 : 		// edg note: this seems to have no ill effects as far as I can
; 1773 : 		// tell.  However I'm commenting it out for the time being until
; 1774 : 		// a better solution for targetlist updates is done.  Also, it should
; 1775 : 		// be done on some sort of timer anyway....
; 1776 : 		
; 1777 : 		// edg note: For AI's I've moved the target list stuff into the digi
; 1778 : 		// code.  I want to synchronize doing this and geom calcs with running
; 1779 : 		// sensor fusion
; 1780 : 		//if ( IsSetFlag( MOTION_OWNSHIP ) )
; 1781 : 		if (autopilotType != CombatAP && HasPilot()){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+968], 2
	je	$LN111@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+472]
	call	edx
	test	eax, eax
	je	$LN111@Exec

; 1782 : 			targetList = UpdateTargetList (targetList, this, SimDriver.combinedList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+16
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	push	eax
	call	?UpdateTargetList@@YAPAVSimObjectType@@PAV1@PAVSimMoverClass@@PAVFalconPrivateOrderedList@@@Z ; UpdateTargetList
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+660], eax

; 1783 : 
; 1784 : 			// edg: all aircraft now get combined list
; 1785 : 			CalcRelGeom(this, targetList, vmat, 1.0F / SimLibMajorFrameTime);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1056				; 00000420H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+660]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?CalcRelGeom@@YAXPAVSimBaseClass@@PAVSimObjectType@@QAY02MM@Z ; CalcRelGeom
	add	esp, 16					; 00000010H

; 1786 : 
; 1787 : 			// Sensors
; 1788 : 			RunSensors();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunSensors@AircraftClass@@QAEXXZ	; AircraftClass::RunSensors

; 1789 : 			// electrics
; 1790 : 			// Have Missiles?
; 1791 : 			if (Sms->HasWeaponClass(wcAimWpn)){

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?HasWeaponClass@SMSClass@@QAEHW4WeaponClass@@@Z ; SMSClass::HasWeaponClass
	test	eax, eax
	je	SHORT $LN112@Exec

; 1792 : 				SetFlag(HAS_MISSILES);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag

; 1793 : 			}
; 1794 : 			else {

	jmp	SHORT $LN111@Exec
$LN112@Exec:

; 1795 : 				UnSetFlag(HAS_MISSILES);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag
$LN111@Exec:

; 1796 : 			}
; 1797 : 		}
; 1798 : 		DoElectrics(); // JPO - well it has to go somewhere

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoElectrics@AircraftClass@@QAEXXZ	; AircraftClass::DoElectrics
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h

; 349  :       int IsActive (void) {return isActive;};

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32152
	mov	DWORD PTR $T77[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1802 : 			&& !OTWDriver.IsShutdown()) // JB - come on, practice safer viewpoints ;-)

	cmp	DWORD PTR $T77[ebp], 0
	je	$LN102@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h

; 351  :       int IsShutdown (void) { return isShutdown;};

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32156
	mov	DWORD PTR $T153[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1802 : 			&& !OTWDriver.IsShutdown()) // JB - come on, practice safer viewpoints ;-)

	cmp	DWORD PTR $T153[ebp], 0
	jne	$LN102@Exec

; 1803 : 		{
; 1804 : 			// JB carrier start
; 1805 : 			RViewPoint* viewp = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	DWORD PTR _viewp$253[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR $T60[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1809 : 			){

	movss	xmm0, DWORD PTR ?g_fCarrierStartTolerance@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR $T60[ebp]
	comiss	xmm1, xmm0
	jbe	$LN109@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	je	$LN109@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	cvtss2sd xmm0, DWORD PTR [eax+1124]
	movsd	xmm1, QWORD PTR __real@3f847ae147ae147b
	comisd	xmm1, xmm0
	jbe	$LN109@Exec
	cmp	DWORD PTR _viewp$253[ebp], 0
	je	$LN109@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T151[ebp], xmm0

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR $T75[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1809 : 			){

	push	ecx
	movss	xmm0, DWORD PTR $T151[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T75[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _viewp$253[ebp]
	call	?GetGroundType@TViewPoint@@QAEHMM@Z	; TViewPoint::GetGroundType
	cmp	eax, 1
	jne	$LN109@Exec

; 1810 : 				// We just started inside the carrier
; 1811 : 				if (isDigital)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	je	$LN108@Exec

; 1812 : 				{
; 1813 : 					af->z = (float)(-500 + rand() % 200);

	call	_rand
	cdq
	mov	ecx, 200				; 000000c8H
	idiv	ecx
	sub	edx, 500				; 000001f4H
	cvtsi2ss xmm0, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1116], xmm0

; 1814 : 					af->vcas = (float)(250 + rand() % 100);

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	edx, 250				; 000000faH
	cvtsi2ss xmm0, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1124], xmm0

; 1815 : 					af->vt = (float)(367 + rand() % 100);

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	edx, 367				; 0000016fH
	cvtsi2ss xmm0, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1120], xmm0

; 1816 : 					af->ClearFlag(AirframeClass::OverRunway);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T243[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	mov	eax, 8388608				; 00800000H
	not	eax
	mov	ecx, DWORD PTR $T243[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR $T243[ebp]
	mov	DWORD PTR [edx+88], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1817 : 					af->ClearFlag(AirframeClass::OnObject);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR $T252[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	mov	edx, 1073741824				; 40000000H
	not	edx
	mov	eax, DWORD PTR $T252[ebp]
	and	edx, DWORD PTR [eax+88]
	mov	ecx, DWORD PTR $T252[ebp]
	mov	DWORD PTR [ecx+88], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1818 : 					af->ClearFlag(AirframeClass::Planted);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR $T246[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	mov	ecx, 4096				; 00001000H
	not	ecx
	mov	edx, DWORD PTR $T246[ebp]
	and	ecx, DWORD PTR [edx+88]
	mov	eax, DWORD PTR $T246[ebp]
	mov	DWORD PTR [eax+88], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1819 : 					af->platform->UnSetFlag( ON_GROUND );

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1088]
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag

; 1820 : 					af->SetFlag (AirframeClass::InAir);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR $T251[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	mov	edx, DWORD PTR $T251[ebp]
	mov	eax, DWORD PTR [edx+88]
	or	eax, 2
	mov	ecx, DWORD PTR $T251[ebp]
	mov	DWORD PTR [ecx+88], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1821 : 					PreFlight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreFlight@AircraftClass@@QAEXXZ	; AircraftClass::PreFlight

; 1822 : 					af->ClearFlag(AirframeClass::EngineOff);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR $T239[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	mov	ecx, 32768				; 00008000H
	not	ecx
	mov	edx, DWORD PTR $T239[ebp]
	and	ecx, DWORD PTR [edx+88]
	mov	eax, DWORD PTR $T239[ebp]
	mov	DWORD PTR [eax+88], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1824 : 					af->ClearFlag(AirframeClass::EngineOff2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T249[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	mov	eax, 536870912				; 20000000H
	not	eax
	mov	ecx, DWORD PTR $T249[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR $T249[ebp]
	mov	DWORD PTR [edx+88], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1826 : 				else{

	jmp	SHORT $LN107@Exec
$LN108@Exec:

; 1827 : 					targetList = UpdateTargetList (targetList, this, SimDriver.combinedList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+16
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	push	eax
	call	?UpdateTargetList@@YAPAVSimObjectType@@PAV1@PAVSimMoverClass@@PAVFalconPrivateOrderedList@@@Z ; UpdateTargetList
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+660], eax
$LN107@Exec:

; 1828 : 				}

	jmp	$LN102@Exec
$LN109@Exec:

; 1831 : 			else if (isDigital && DBrain() && !DBrain()->IsSetATC(DigitalBrain::DonePreflight))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	$LN102@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T149[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1831 : 			else if (isDigital && DBrain() && !DBrain()->IsSetATC(DigitalBrain::DonePreflight))

	cmp	DWORD PTR $T149[ebp], 0
	je	$LN102@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T59[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 709  : 	int		IsSetATC(int flag)								{return (atcFlags & flag) && TRUE;}

	mov	ecx, DWORD PTR $T59[ebp]
	mov	edx, DWORD PTR [ecx+300]
	and	edx, -2147483648			; 80000000H
	je	SHORT $LN496@Exec
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN496@Exec
	mov	DWORD PTR tv4205[ebp], 1
	jmp	SHORT $LN497@Exec
$LN496@Exec:
	mov	DWORD PTR tv4205[ebp], 0
$LN497@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1831 : 			else if (isDigital && DBrain() && !DBrain()->IsSetATC(DigitalBrain::DonePreflight))

	cmp	DWORD PTR tv4205[ebp], 0
	jne	$LN102@Exec

; 1835 : 				if (curWaypoint && curWaypoint->GetWPArrivalTime() - 2*CampaignMinutes < TheCampaign.CurrentTime){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+728], 0
	je	$LN102@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+728]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T147[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1835 : 				if (curWaypoint && curWaypoint->GetWPArrivalTime() - 2*CampaignMinutes < TheCampaign.CurrentTime){

	mov	edx, DWORD PTR $T147[ebp]
	sub	edx, 120000				; 0001d4c0H
	cmp	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jae	$LN102@Exec

; 1836 : 					//me123 this should never happen, but it does sometimes in MP
; 1837 : 					PreFlight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreFlight@AircraftClass@@QAEXXZ	; AircraftClass::PreFlight

; 1839 : 					if(isDigital && DBrain() && !DBrain()->IsSetATC(DigitalBrain::DonePreflight)){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	je	$LN510@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T73[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1839 : 					if(isDigital && DBrain() && !DBrain()->IsSetATC(DigitalBrain::DonePreflight)){

	cmp	DWORD PTR $T73[ebp], 0
	je	SHORT $LN510@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T145[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 709  : 	int		IsSetATC(int flag)								{return (atcFlags & flag) && TRUE;}

	mov	edx, DWORD PTR $T145[ebp]
	mov	eax, DWORD PTR [edx+300]
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN506@Exec
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN506@Exec
	mov	DWORD PTR tv4224[ebp], 1
	jmp	SHORT $LN507@Exec
$LN506@Exec:
	mov	DWORD PTR tv4224[ebp], 0
$LN507@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1839 : 					if(isDigital && DBrain() && !DBrain()->IsSetATC(DigitalBrain::DonePreflight)){

	cmp	DWORD PTR tv4224[ebp], 0
	jne	SHORT $LN510@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T242[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 707  : 	void	SetATCFlag(int flag)							{atcFlags |= flag;}

	mov	ecx, DWORD PTR $T242[ebp]
	mov	edx, DWORD PTR [ecx+300]
	or	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR $T242[ebp]
	mov	DWORD PTR [eax+300], edx
$LN510@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+604], 5
	jle	SHORT $LN512@Exec
	mov	edx, 5
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	DWORD PTR [edx+ecx], 1
	mov	edx, 5
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR [edx+ecx], 1
$LN512@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	edx, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T57[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1845 : 					if ( gACMIRec.IsRecording() ){

	cmp	DWORD PTR $T57[ebp], 0
	je	$LN102@Exec

; 1846 : 						acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv6540[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv6540[ebp]
	mov	ecx, DWORD PTR tv6540[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv6544[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv6544[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR $T264[ebp], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1847 : 						acmiSwitch.data.type = Type();

	movzx	ecx, WORD PTR $T264[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T39[ebp], eax
	mov	DWORD PTR $T39[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 80   : 		return (unsigned long) value_; 

	mov	edx, DWORD PTR $T39[ebp+4]
	mov	DWORD PTR $T143[ebp], edx

; 81   : 	}
; 82   : 
; 83   : 	// note: these are private to prevent (mis)use
; 84   : private:
; 85   : 	int operator == (unsigned long &rhs) const ;
; 86   : 	int operator != (unsigned long &rhs) const ;
; 87   : 	int operator > (unsigned long &rhs) const ;
; 88   : 	int operator >= (unsigned long &rhs) const ;
; 89   : 	int operator < (unsigned long &rhs) const ;
; 90   : 	int operator <= (unsigned long &rhs) const ;
; 91   : 
; 92   : 	// DATA
; 93   : public:
; 94   : 	unsigned long 	value_;
; 95   : };
; 96   : 
; 97   : class VU_ID {
; 98   : public:
; 99   : 	//sfr: vu change
; 100  : 	VU_ID() : num_(0), creator_(0){}
; 101  : 	VU_ID(VU_SESSION_ID sessionpart, VU_ID_NUMBER idpart) : num_(idpart), creator_(sessionpart){}
; 102  : 
; 103  : 	// basic operator overloading
; 104  : 	bool operator == (const VU_ID &rhs) const { 
; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 
; 110  : 	}
; 111  : 	bool operator != (const VU_ID &rhs) const { 
; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 
; 117  : 	}
; 118  : 	bool operator > (const VU_ID &rhs) const {
; 119  : 		if (creator_ > rhs.creator_){
; 120  : 			return true;
; 121  : 		}
; 122  : 		if (creator_ == rhs.creator_)	{
; 123  : 			if (num_ > rhs.num_){
; 124  : 				return true;
; 125  : 			}
; 126  : 		}
; 127  : 		return false;
; 128  : 	}
; 129  : 	bool operator >= (const VU_ID &rhs) const {
; 130  : 		if (creator_ > rhs.creator_){
; 131  : 			return true;
; 132  : 		}
; 133  : 		if (creator_ == rhs.creator_){
; 134  : 			if (num_ >= rhs.num_){
; 135  : 				return true;
; 136  : 			}
; 137  : 		}
; 138  : 		return false;
; 139  : 	}
; 140  : 	bool operator < (const VU_ID &rhs) const {
; 141  : 		if (creator_ < rhs.creator_){
; 142  : 			return true;
; 143  : 		}
; 144  : 		if (creator_ == rhs.creator_){
; 145  : 			if (num_ < rhs.num_){
; 146  : 				return true;
; 147  : 			}
; 148  : 		}
; 149  : 		return false;
; 150  : 	}
; 151  : 	bool operator <= (const VU_ID &rhs) const {
; 152  : 		if (creator_ < rhs.creator_){
; 153  : 			return true;
; 154  : 		}
; 155  : 		if (creator_ == rhs.creator_){
; 156  : 			if (num_ <= rhs.num_){
; 157  : 				return true;
; 158  : 			}
; 159  : 		}
; 160  : 		return false;
; 161  : 	}
; 162  : 	operator VU_KEY() const { 
; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	movzx	eax, WORD PTR $T39[ebp]
	movzx	ecx, WORD PTR $T143[ebp]
	shl	ecx, 16					; 00000010H
	or	ecx, eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1848 : 						acmiSwitch.data.uniqueID = Id();

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, ecx

; 1849 : 						acmiSwitch.data.switchNum = COMP_CANOPY;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, 5

; 1850 : 						acmiSwitch.data.switchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, 1

; 1851 : 						acmiSwitch.data.prevSwitchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, 1

; 1852 : 						gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN102@Exec:

; 1853 : 					}
; 1854 : 				}
; 1855 : 			}
; 1856 : 		}
; 1857 : 
; 1858 : 		//START_PROFILE("AC_EXEC_5d3");
; 1859 : 		// after geometry has been calculated, we can check collisions
; 1860 : 		// digitals don't check collisions.  they just avoid.
; 1861 : 		// this shouldn't really matter much, but it can be easily turned on
; 1862 : 		
; 1863 : 		//if ( !isDigital && PlayerOptions.CollisionsOn() ) // JB carrier
; 1864 : 		if (!isDigital){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	jne	SHORT $LN101@Exec

; 1865 : 			// JB carrier
; 1866 : 			CheckObjectCollision();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckObjectCollision@AircraftClass@@QAEXXZ ; AircraftClass::CheckObjectCollision
$LN101@Exec:

; 1867 : 		}
; 1868 : 
; 1869 : 		// Get the controls
; 1870 : 		GatherInputs();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GatherInputs@AircraftClass@@QAEXXZ	; AircraftClass::GatherInputs

; 1871 : 
; 1872 : 		if(tempSensorArray){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 0
	je	$LN100@Exec

; 1873 : 			//when we need to change the sensors for the player we just set tempSensorArray equal
; 1874 : 			//to sensorarray to save them for deletion at this time, and then 
; 1875 : 			for (int i=0; i<tempNumSensors; i++){

	mov	DWORD PTR _i$279[ebp], 0
	jmp	SHORT $LN99@Exec
$LN98@Exec:
	mov	ecx, DWORD PTR _i$279[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$279[ebp], ecx
$LN99@Exec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$279[ebp]
	cmp	eax, DWORD PTR [edx+1824]
	jge	SHORT $LN97@Exec

; 1876 : 				delete tempSensorArray[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	eax, DWORD PTR _i$279[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T71[ebp], ecx
	mov	edx, DWORD PTR $T71[ebp]
	mov	DWORD PTR $T261[ebp], edx
	cmp	DWORD PTR $T261[ebp], 0
	je	SHORT $LN241@Exec
	push	1
	mov	eax, DWORD PTR $T261[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T261[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv2365[ebp], eax
	jmp	SHORT $LN242@Exec
$LN241@Exec:
	mov	DWORD PTR tv2365[ebp], 0
$LN242@Exec:

; 1877 : 				tempSensorArray[i] = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	eax, DWORD PTR _i$279[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 1878 : 			}

	jmp	$LN98@Exec
$LN97@Exec:

; 1879 : 			delete [] tempSensorArray;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	DWORD PTR $T55[ebp], edx
	mov	eax, DWORD PTR $T55[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 1880 : 			tempSensorArray = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1820], 0

; 1881 : 			tempNumSensors = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1824], 0
$LN100@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T140[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1889 : 		if (SimDriver.GetPlayerEntity() == this /*|| g_bAIGloc*/){

	mov	ecx, DWORD PTR $T140[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $LN94@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 148  : 	int BlackoutOn (void)									{ return !(SimFlags & SIM_NO_BLACKOUT) && TRUE; }

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+52
	and	edx, 2
	jne	SHORT $LN529@Exec
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN529@Exec
	mov	DWORD PTR tv4251[ebp], 1
	jmp	SHORT $LN530@Exec
$LN529@Exec:
	mov	DWORD PTR tv4251[ebp], 0
$LN530@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1890 : 			if(!PlayerOptions.BlackoutOn()){

	cmp	DWORD PTR tv4251[ebp], 0
	jne	SHORT $LN95@Exec

; 1891 : 				glocFactor = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+912], xmm0

; 1892 : 			}
; 1893 : 			else{

	jmp	SHORT $LN94@Exec
$LN95@Exec:

; 1894 : 				glocFactor = GlocPrediction();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GlocPrediction@AircraftClass@@QAEMXZ	; AircraftClass::GlocPrediction
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+912]
$LN94@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T69[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1899 : 		flight = (Flight)GetCampaignObject();

	mov	edx, DWORD PTR $T69[ebp]
	mov	DWORD PTR _flight$[ebp], edx

; 1900 : 		if (flight && (flight->GetUnitMission() > AMIS_SEADESCORT && flight->GetUnitMission() < AMIS_FAC) )

	cmp	DWORD PTR _flight$[ebp], 0
	je	$LN90@Exec
	mov	eax, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 12					; 0000000cH
	jle	$LN90@Exec
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	cmp	eax, 19					; 00000013H
	jge	$LN90@Exec

; 1901 : 		{
; 1902 : 			flightIdx = flight->GetComponentIndex(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1903 : 			if (!AWACSsaidAbort && !flightIdx) // only for flight leaders of course

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1832]
	test	eax, eax
	jne	$LN90@Exec
	cmp	DWORD PTR _flightIdx$[ebp], 0
	jne	$LN90@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	mov	ecx, DWORD PTR _flight$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR _w$280[ebp], edx
$LN535@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1906 : 				while (w)

	cmp	DWORD PTR _w$280[ebp], 0
	je	$LN90@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	mov	eax, DWORD PTR _w$280[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T53[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1908 : 					if (!(w->GetWPFlags() & WPF_TARGET))

	mov	edx, DWORD PTR $T53[ebp]
	and	edx, 1
	jne	SHORT $LN89@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	eax, DWORD PTR _w$280[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _w$280[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1911 : 						continue;

	jmp	SHORT $LN535@Exec
$LN89@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 168  : 	CampEntity GetWPTarget (void)					{ return (CampEntity)vuDatabase->Find(TargetID); }

	mov	edx, DWORD PTR _w$280[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1914 : 					target = w->GetWPTarget();

	mov	DWORD PTR _target$259[ebp], eax

; 1915 : 					if (target && (target->GetTeam() == GetTeam()))

	cmp	DWORD PTR _target$259[ebp], 0
	je	$LN88@Exec
	mov	edx, DWORD PTR _target$259[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _target$259[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	esi, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN88@Exec

; 1916 : 					{
; 1917 : 						AWACSsaidAbort = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1832], 1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T137[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1919 : 						radioMessage = CreateCallFromAwacs(flight, rcAWACSTARGETOCCUPIED); 

	mov	ecx, DWORD PTR $T137[ebp]
	push	ecx
	push	351					; 0000015fH
	mov	edx, DWORD PTR _flight$[ebp]
	push	edx
	call	?CreateCallFromAwacs@@YAPAVFalconRadioChatterMessage@@PAVFlightClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromAwacs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _radioMessage$67[ebp], eax

; 1920 : 						// let AWACS bring the message that we've occupied the target ;)
; 1921 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$67[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1922 : 						TheCampaign.MissionEvaluator->Register3DAWACSabort(flight);

	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+324
	call	?Register3DAWACSabort@MissionEvaluationClass@@QAEXPAVFlightClass@@@Z ; MissionEvaluationClass::Register3DAWACSabort
$LN88@Exec:

; 1923 : 					}
; 1924 : 					break;

	jmp	SHORT $LN90@Exec

; 1925 : 				}

	jmp	$LN535@Exec
$LN90@Exec:

; 1931 : 		if ((isDigital || Sms->JDAMtargeting == SMSBaseClass::PB ) && Sms->GetCurrentHardpoint() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	jne	SHORT $LN86@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+36], 0
	jne	$LN83@Exec
$LN86@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 129  : 	int GetCurrentHardpoint(void) {return curHardpoint;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T135[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1931 : 		if ((isDigital || Sms->JDAMtargeting == SMSBaseClass::PB ) && Sms->GetCurrentHardpoint() > 0)

	cmp	DWORD PTR $T135[ebp], 0
	jle	$LN83@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 129  : 	int GetCurrentHardpoint(void) {return curHardpoint;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T51[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T51[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _sw$240[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 129  : 	int GetCurrentHardpoint(void) {return curHardpoint;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T133[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1935 : 						|| (sw && (((BombClass *)sw)->IsSetBombFlag(BombClass::IsJSOW)))))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T133[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv2583[ebp], eax
	mov	ecx, DWORD PTR tv2583[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv2583[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN84@Exec
	cmp	DWORD PTR _sw$240[ebp], 0
	je	SHORT $LN83@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\bomb.h

; 102  : 	int IsSetBombFlag (int newFlag) {return flags & newFlag ? TRUE : FALSE;};

	mov	ecx, DWORD PTR _sw$240[ebp]
	mov	edx, DWORD PTR [ecx+732]
	and	edx, 512				; 00000200H
	je	SHORT $LN555@Exec
	mov	DWORD PTR tv4256[ebp], 1
	jmp	SHORT $LN556@Exec
$LN555@Exec:
	mov	DWORD PTR tv4256[ebp], 0
$LN556@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1935 : 						|| (sw && (((BombClass *)sw)->IsSetBombFlag(BombClass::IsJSOW)))))

	cmp	DWORD PTR tv4256[ebp], 0
	je	SHORT $LN83@Exec
$LN84@Exec:

; 1936 : 			{
; 1937 : 				if (this)

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $LN83@Exec

; 1938 : 					JDAMtgtnum = GetJDAMPBTarget((AircraftClass*)this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetJDAMPBTarget@AircraftClass@@QAEHPAV1@@Z ; AircraftClass::GetJDAMPBTarget
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], eax
$LN83@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T65[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1945 : 		if ((SimDriver.GetPlayerEntity() == this) && DBrain()) {

	mov	eax, DWORD PTR $T65[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	$LN67@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T131[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1945 : 		if ((SimDriver.GetPlayerEntity() == this) && DBrain()) {

	cmp	DWORD PTR $T131[ebp], 0
	je	$LN67@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T49[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1946 : 			if (DBrain()->targetSpotWing) {

	mov	edx, DWORD PTR $T49[ebp]
	cmp	DWORD PTR [edx+916], 0
	je	$LN77@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T129[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1951 : 				){ 

	mov	edx, DWORD PTR $T129[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+940]
	ja	SHORT $LN79@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T63[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1951 : 				){ 

	mov	eax, DWORD PTR $T63[ebp]
	cmp	DWORD PTR [eax+928], 0
	je	SHORT $LN79@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T127[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1951 : 				){ 

	mov	eax, DWORD PTR $T127[ebp]
	mov	ecx, DWORD PTR [eax+928]
	mov	DWORD PTR tv2629[ebp], ecx
	mov	edx, DWORD PTR tv2629[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv2629[ebp]
	mov	edx, DWORD PTR [eax+212]
	call	edx
	test	eax, eax
	je	$LN80@Exec
$LN79@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T47[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T125[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1956 : 					FalconLocalSession->RemoveCamera(DBrain()->targetSpotWing);

	push	0
	mov	eax, DWORD PTR $T47[ebp]
	mov	ecx, DWORD PTR [eax+916]
	push	ecx
	mov	ecx, DWORD PTR $T125[ebp]
	call	?RemoveCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z ; VuSessionEntity::RemoveCamera
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T61[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1965 : 					vuDatabase->Remove (DBrain()->targetSpotWing); 

	mov	ecx, DWORD PTR $T61[ebp]
	mov	edx, DWORD PTR [ecx+916]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T123[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1967 : 					if (DBrain()->targetSpotWingTarget) {

	mov	edx, DWORD PTR $T123[ebp]
	cmp	DWORD PTR [edx+928], 0
	je	SHORT $LN78@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T46[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1968 : 						VuDeReferenceEntity(DBrain()->targetSpotWingTarget);

	mov	edx, DWORD PTR $T46[ebp]
	mov	eax, DWORD PTR [edx+928]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4
$LN78@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T121[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1970 : 					DBrain()->targetSpotWing = NULL;

	mov	eax, DWORD PTR $T121[ebp]
	mov	DWORD PTR [eax+916], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T45[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1971 : 					DBrain()->targetSpotWingTarget = NULL;

	mov	eax, DWORD PTR $T45[ebp]
	mov	DWORD PTR [eax+928], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T119[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1972 : 					DBrain()->targetSpotWingTimer = 0;

	mov	eax, DWORD PTR $T119[ebp]
	mov	DWORD PTR [eax+940], 0

; 1973 : 				}
; 1974 : 				else {

	jmp	$LN77@Exec
$LN80@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T58[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR $T58[ebp]
	mov	ecx, DWORD PTR [eax+928]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T115[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T117[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR $T117[ebp]
	mov	edx, DWORD PTR [ecx+928]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T56[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T15[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR $T15[ebp]
	mov	eax, DWORD PTR [edx+928]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T235[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T233[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1980 : 					);

	push	ecx
	movss	xmm0, DWORD PTR $T115[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T56[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T235[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR $T233[ebp]
	mov	ecx, DWORD PTR [eax+916]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T231[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1981 : 					DBrain()->targetSpotWing->EntityDriver()->Exec(vuxGameTime);

	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR tv2716[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 180  : 	VuDriver *EntityDriver()	{ return driver_; }

	mov	ecx, DWORD PTR $T231[ebp]
	mov	edx, DWORD PTR [ecx+916]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR tv2716[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1981 : 					DBrain()->targetSpotWing->EntityDriver()->Exec(vuxGameTime);

	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	push	ecx
	mov	edx, DWORD PTR tv2716[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv2716[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN77@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T229[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1985 : 			if (DBrain()->targetSpotElement) {

	mov	edx, DWORD PTR $T229[ebp]
	cmp	DWORD PTR [edx+920], 0
	je	$LN72@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T227[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1991 : 				){ 

	mov	edx, DWORD PTR $T227[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+944]
	ja	SHORT $LN74@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T225[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1991 : 				){ 

	mov	eax, DWORD PTR $T225[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $LN74@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T223[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1991 : 				){ 

	mov	eax, DWORD PTR $T223[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR tv2737[ebp], ecx
	mov	edx, DWORD PTR tv2737[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv2737[ebp]
	mov	edx, DWORD PTR [eax+212]
	call	edx
	test	eax, eax
	je	$LN75@Exec
$LN74@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T221[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T219[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1995 : 					FalconLocalSession->RemoveCamera(DBrain()->targetSpotElement);

	push	0
	mov	eax, DWORD PTR $T221[ebp]
	mov	ecx, DWORD PTR [eax+920]
	push	ecx
	mov	ecx, DWORD PTR $T219[ebp]
	call	?RemoveCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z ; VuSessionEntity::RemoveCamera
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T217[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2004 : 					vuDatabase->Remove(DBrain()->targetSpotElement); 

	mov	ecx, DWORD PTR $T217[ebp]
	mov	edx, DWORD PTR [ecx+920]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T215[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2005 : 					if (DBrain()->targetSpotElementTarget){

	mov	edx, DWORD PTR $T215[ebp]
	cmp	DWORD PTR [edx+932], 0
	je	SHORT $LN73@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T213[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2007 : 						VuDeReferenceEntity(DBrain()->targetSpotElementTarget);

	mov	edx, DWORD PTR $T213[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4
$LN73@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T211[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2009 : 					DBrain()->targetSpotElement = NULL;

	mov	eax, DWORD PTR $T211[ebp]
	mov	DWORD PTR [eax+920], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T209[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2010 : 					DBrain()->targetSpotElementTarget = NULL;

	mov	eax, DWORD PTR $T209[ebp]
	mov	DWORD PTR [eax+932], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T207[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2011 : 					DBrain()->targetSpotElementTimer = 0;

	mov	eax, DWORD PTR $T207[ebp]
	mov	DWORD PTR [eax+944], 0

; 2012 : 				}
; 2013 : 				else {

	jmp	$LN72@Exec
$LN75@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T205[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR $T205[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T199[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T203[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR $T203[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T197[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T201[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR $T201[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T196[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T195[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2019 : 					);

	push	ecx
	movss	xmm0, DWORD PTR $T199[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T197[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T196[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR $T195[ebp]
	mov	ecx, DWORD PTR [eax+920]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T194[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2020 : 					DBrain()->targetSpotElement->EntityDriver()->Exec(vuxGameTime);

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR tv2824[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 180  : 	VuDriver *EntityDriver()	{ return driver_; }

	mov	ecx, DWORD PTR $T194[ebp]
	mov	edx, DWORD PTR [ecx+920]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR tv2824[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2020 : 					DBrain()->targetSpotElement->EntityDriver()->Exec(vuxGameTime);

	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	push	ecx
	mov	edx, DWORD PTR tv2824[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv2824[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN72@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T193[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2024 : 			if (DBrain()->targetSpotFlight){

	mov	edx, DWORD PTR $T193[ebp]
	cmp	DWORD PTR [edx+924], 0
	je	$LN67@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T192[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2029 : 				){

	mov	edx, DWORD PTR $T192[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR [edx+948]
	ja	SHORT $LN69@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T190[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2029 : 				){

	mov	eax, DWORD PTR $T190[ebp]
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN69@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T188[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2029 : 				){

	mov	eax, DWORD PTR $T188[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR tv2845[ebp], ecx
	mov	edx, DWORD PTR tv2845[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv2845[ebp]
	mov	edx, DWORD PTR [eax+212]
	call	edx
	test	eax, eax
	je	$LN70@Exec
$LN69@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T186[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T184[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2034 : 					FalconLocalSession->RemoveCamera(DBrain()->targetSpotFlight);

	push	0
	mov	eax, DWORD PTR $T186[ebp]
	mov	ecx, DWORD PTR [eax+924]
	push	ecx
	mov	ecx, DWORD PTR $T184[ebp]
	call	?RemoveCamera@VuSessionEntity@@QAEHPAVVuEntity@@_N@Z ; VuSessionEntity::RemoveCamera
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T182[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2042 : 					vuDatabase->Remove (DBrain()->targetSpotFlight); 

	mov	ecx, DWORD PTR $T182[ebp]
	mov	edx, DWORD PTR [ecx+924]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T180[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2043 : 					if (DBrain()->targetSpotFlightTarget){

	mov	edx, DWORD PTR $T180[ebp]
	cmp	DWORD PTR [edx+936], 0
	je	SHORT $LN68@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T178[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2045 : 						VuDeReferenceEntity(DBrain()->targetSpotFlightTarget);

	mov	edx, DWORD PTR $T178[ebp]
	mov	eax, DWORD PTR [edx+936]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4
$LN68@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T176[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2047 : 					DBrain()->targetSpotFlight = NULL;

	mov	eax, DWORD PTR $T176[ebp]
	mov	DWORD PTR [eax+924], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T174[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2048 : 					DBrain()->targetSpotFlightTarget = NULL;

	mov	eax, DWORD PTR $T174[ebp]
	mov	DWORD PTR [eax+936], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T172[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2049 : 					DBrain()->targetSpotFlightTimer = 0;

	mov	eax, DWORD PTR $T172[ebp]
	mov	DWORD PTR [eax+948], 0

; 2050 : 				}
; 2051 : 				else {

	jmp	$LN67@Exec
$LN70@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T170[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	eax, DWORD PTR $T170[ebp]
	mov	ecx, DWORD PTR [eax+936]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T164[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T168[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR $T168[ebp]
	mov	edx, DWORD PTR [ecx+936]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T162[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T166[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR $T166[ebp]
	mov	eax, DWORD PTR [edx+936]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T160[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T158[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2057 : 					);

	push	ecx
	movss	xmm0, DWORD PTR $T164[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T162[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T160[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR $T158[ebp]
	mov	ecx, DWORD PTR [eax+924]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T156[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2058 : 					DBrain()->targetSpotFlight->EntityDriver()->Exec(vuxGameTime);

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR tv2932[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 180  : 	VuDriver *EntityDriver()	{ return driver_; }

	mov	ecx, DWORD PTR $T156[ebp]
	mov	edx, DWORD PTR [ecx+924]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR tv2932[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2058 : 					DBrain()->targetSpotFlight->EntityDriver()->Exec(vuxGameTime);

	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	push	ecx
	mov	edx, DWORD PTR tv2932[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv2932[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN67@Exec:

; 2085 : 		){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	jne	$LN66@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T154[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2085 : 		){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR $T154[ebp]
	subss	xmm0, DWORD PTR [eax+1272]
	movss	xmm1, DWORD PTR __real@c2480000
	comiss	xmm1, xmm0
	jbe	$LN66@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+1552]
	jb	$LN66@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1204]
	comiss	xmm0, DWORD PTR __real@41800000
	jbe	$LN66@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	movss	DWORD PTR $T152[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2085 : 		){

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR $T152[ebp]
	jbe	$LN66@Exec

; 2086 : 			float turnRadius,denom, gs, num, alt;
; 2087 : 			float groundAlt;
; 2088 : 			float clearanceBuffer;
; 2089 : 			
; 2090 : 			groundAlt = -af->groundZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _groundAlt$142[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1174 : 	float MaxGs (void) {return maxGs;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR $T150[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2095 : 			gs = af->MaxGs() - 0.5F;

	movss	xmm0, DWORD PTR $T150[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _gs$278[ebp], xmm0

; 2096 : 			gs = min (gs, 7.0F);

	movss	xmm0, DWORD PTR __real@40e00000
	comiss	xmm0, DWORD PTR _gs$278[ebp]
	jbe	SHORT $LN243@Exec
	movss	xmm0, DWORD PTR _gs$278[ebp]
	movss	DWORD PTR tv2969[ebp], xmm0
	jmp	SHORT $LN244@Exec
$LN243@Exec:
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR tv2969[ebp], xmm0
$LN244@Exec:
	movss	xmm0, DWORD PTR tv2969[ebp]
	movss	DWORD PTR _gs$278[ebp], xmm0

; 2097 : 			num = gs*gs - 1.0F;

	movss	xmm0, DWORD PTR _gs$278[ebp]
	mulss	xmm0, DWORD PTR _gs$278[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _num$245[ebp], xmm0

; 2098 : 			
; 2099 : 			if (num <= 0.0)

	cvtss2sd xmm0, DWORD PTR _num$245[ebp]
	movsd	xmm1, QWORD PTR __real@0000000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN65@Exec

; 2100 : 				denom = 0.1F;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _denom$238[ebp], xmm0

; 2101 : 			else

	jmp	SHORT $LN64@Exec
$LN65@Exec:

; 2102 : 				denom = GRAVITY * (float)sqrt(num);

	movss	xmm0, DWORD PTR _num$245[ebp]
	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR $T5[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR $T5[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	movss	xmm0, DWORD PTR $T5[ebp]
	movss	DWORD PTR $T148[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2102 : 				denom = GRAVITY * (float)sqrt(num);

	movss	xmm0, DWORD PTR __real@4200b53f
	mulss	xmm0, DWORD PTR $T148[ebp]
	movss	DWORD PTR _denom$238[ebp], xmm0
$LN64@Exec:

; 2103 : 			
; 2104 : 			// get turn radius length nased on our speed and gs
; 2105 : 			float vt = GetVt();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR _vt$247[ebp]

; 2106 : 			turnRadius = vt * vt / denom;

	movss	xmm0, DWORD PTR _vt$247[ebp]
	mulss	xmm0, DWORD PTR _vt$247[ebp]
	divss	xmm0, DWORD PTR _denom$238[ebp]
	movss	DWORD PTR _turnRadius$272[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	movss	DWORD PTR $T146[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2113 : 			turnRadius *= -Pitch()/( 90.0f * DTR );

	movss	xmm0, DWORD PTR $T146[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@3fc90fd9
	mulss	xmm0, DWORD PTR _turnRadius$272[ebp]
	movss	DWORD PTR _turnRadius$272[ebp], xmm0

; 2114 : 			
; 2115 : 			// clearance buffer depends on vcas
; 2116 : 			if ( af->vcas <= 325.0f )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@43a28000
	comiss	xmm0, DWORD PTR [eax+1124]
	jb	SHORT $LN63@Exec

; 2117 : 			{
; 2118 : 				clearanceBuffer = 150.0f;

	movss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR _clearanceBuffer$260[ebp], xmm0
	jmp	SHORT $LN60@Exec
$LN63@Exec:

; 2119 : 			}
; 2120 : 			else if ( af->vcas >= 375.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1124]
	comiss	xmm0, DWORD PTR __real@43bb8000
	jb	SHORT $LN61@Exec

; 2121 : 			{
; 2122 : 				clearanceBuffer = 50.0f;

	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR _clearanceBuffer$260[ebp], xmm0

; 2123 : 			}
; 2124 : 			else // between 325 and 375

	jmp	SHORT $LN60@Exec
$LN61@Exec:

; 2125 : 			{
; 2126 : 				clearanceBuffer = 150.0f - 2.0f * (af->vcas - 325.0f);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1124]
	subss	xmm0, DWORD PTR __real@43a28000
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@43160000
	subss	xmm1, xmm0
	movss	DWORD PTR _clearanceBuffer$260[ebp], xmm1
$LN60@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR $T144[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2130 : 			alt = (-ZPos()) - groundAlt - clearanceBuffer;

	movss	xmm0, DWORD PTR $T144[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _groundAlt$142[ebp]
	subss	xmm0, DWORD PTR _clearanceBuffer$260[ebp]
	movss	DWORD PTR _alt$141[ebp], xmm0

; 2131 : 			
; 2132 : 			// num = alt / (2.0F*turnRadius);
; 2133 : 			// if (num > 1.0F)
; 2134 : 			
; 2135 : 			// if our AGL is greater than our predicted turn radius plus some
; 2136 : 			// cushion,
; 2137 : 			// the clear the fault.  otherwise issue warning...
; 2138 : 			if ( alt > turnRadius * 1.15f )

	movss	xmm0, DWORD PTR _turnRadius$272[ebp]
	mulss	xmm0, DWORD PTR __real@3f933333
	movss	xmm1, DWORD PTR _alt$141[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN59@Exec

; 2139 : 			{
; 2140 : 				// no pullup needed
; 2141 : 				mFaults->ClearFault(alt_low);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::ClearFault

; 2142 : 			}
; 2143 : 			else

	jmp	$LN58@Exec
$LN59@Exec:

; 2144 : 			{
; 2145 : 				if(!SoundPos.IsPlaying(af->auxaeroData->sndBBPullup))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2384]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?IsPlaying@F4SoundPos@@QAE_NHH@Z	; F4SoundPos::IsPlaying
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN57@Exec

; 2146 : 				{
; 2147 : 					SoundPos.Sfx(af->auxaeroData->sndBBPullup);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+2384]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN57@Exec:

; 2148 : 				}
; 2149 : 				mFaults->SetFault(alt_low);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+928]
	call	?SetFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::SetFault
$LN58@Exec:

; 2150 : 				
; 2151 : 			}

	jmp	SHORT $LN55@Exec
$LN66@Exec:

; 2152 : 		}
; 2153 : 		else if(!isDigital)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	jne	SHORT $LN55@Exec

; 2154 : 		{
; 2155 : 			mFaults->ClearFault(alt_low);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	call	?ClearFault@FackClass@@QAEXW4type_CSubSystem@@@Z ; FackClass::ClearFault
$LN55@Exec:

; 2159 : 		if ( af->vt > 0.0f && !isDigital && PlayerOptions.CollisionsOn() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1120]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN54@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	jne	SHORT $LN54@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 153  : 	int CollisionsOn (void)									{ return !(SimFlags & SIM_NO_COLLISIONS) && TRUE; }

	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+52
	and	ecx, 32					; 00000020H
	jne	SHORT $LN701@Exec
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN701@Exec
	mov	DWORD PTR tv4724[ebp], 1
	jmp	SHORT $LN702@Exec
$LN701@Exec:
	mov	DWORD PTR tv4724[ebp], 0
$LN702@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2159 : 		if ( af->vt > 0.0f && !isDigital && PlayerOptions.CollisionsOn() )

	cmp	DWORD PTR tv4724[ebp], 0
	je	SHORT $LN54@Exec

; 2160 : 			GroundFeatureCheck( af->groundZ );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1272]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GroundFeatureCheck@AircraftClass@@QAEXM@Z ; AircraftClass::GroundFeatureCheck

; 2161 : 		else

	jmp	SHORT $LN53@Exec
$LN54@Exec:

; 2162 : 			FeatureCollision( af->groundZ ); //need onFlatFeature to be correct for landings

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1272]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+444]
	call	eax
$LN53@Exec:

; 2163 : 		//onFlatFeature = TRUE;
; 2164 : 		
; 2165 : 		if (OnGround()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN52@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+136]
	and	edx, 4
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2174 : 			if(IsPlayer() && g_bRealisticAvionics){

	je	SHORT $LN51@Exec
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN51@Exec

; 2175 : 				UnSetFlag(ECM_ON);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag
$LN51@Exec:

; 2178 : 			if (SimDriver.RunningInstantAction() && this == SimDriver.GetPlayerEntity()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningInstantAction@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningInstantAction
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN47@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T139[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2178 : 			if (SimDriver.RunningInstantAction() && this == SimDriver.GetPlayerEntity()){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR $T139[ebp]
	jne	SHORT $LN47@Exec

; 2179 : 				if (af->vt < 5.0F && af->throtl < 0.1F){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR [edx+1120]
	jbe	SHORT $LN49@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [ecx+1512]
	jbe	SHORT $LN49@Exec

; 2180 : 					if (!gPlayerExitMenuShown){

	cmp	DWORD PTR ?gPlayerExitMenuShown@@3HA, 0	; gPlayerExitMenuShown
	jne	SHORT $LN48@Exec

; 2181 : 						gPlayerExitMenuShown = TRUE;

	mov	DWORD PTR ?gPlayerExitMenuShown@@3HA, 1	; gPlayerExitMenuShown

; 2182 : 						OTWDriver.EndFlight();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?EndFlight@OTWDriverClass@@QAEXXZ	; OTWDriverClass::EndFlight
$LN48@Exec:

; 2183 : 					}
; 2184 : 				}
; 2185 : 				else{

	jmp	SHORT $LN47@Exec
$LN49@Exec:

; 2186 : 					gPlayerExitMenuShown = FALSE;

	mov	DWORD PTR ?gPlayerExitMenuShown@@3HA, 0	; gPlayerExitMenuShown
$LN47@Exec:

; 2187 : 				}
; 2188 : 			}
; 2189 : 		}
; 2190 : 		else

	jmp	$LN40@Exec
$LN52@Exec:

; 2191 : 		{
; 2192 : 			// fun stuff: if between 10 and 80 ft of ground, stirr up
; 2193 : 			// dust or water
; 2194 : 			// JAM - FIXME
; 2195 : 			//if ( OTWDriver.renderer && OTWDriver.renderer->GetAlphaMode() )
; 2196 : 			//{
; 2197 : 				int connected=0;

	mov	DWORD PTR _connected$256[ebp], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR $T138[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2201 : 					ZPos() - af->groundZ <= -10.0f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR $T138[ebp]
	subss	xmm0, DWORD PTR [ecx+1272]
	comiss	xmm0, DWORD PTR __real@c2200000
	jb	$LN43@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR $T136[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2201 : 					ZPos() - af->groundZ <= -10.0f )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR $T136[ebp]
	subss	xmm0, DWORD PTR [ecx+1272]
	movss	xmm1, DWORD PTR __real@c1200000
	comiss	xmm1, xmm0
	jb	$LN43@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN729@Exec
	mov	DWORD PTR tv4771[ebp], 1
	jmp	SHORT $LN730@Exec
$LN729@Exec:
	mov	DWORD PTR tv4771[ebp], 0
$LN730@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2204 : 					if(!af->IsSet(AirframeClass::OverRunway) && af->gearPos <= 0.7F)

	cmp	DWORD PTR tv4771[ebp], 0
	jne	$LN43@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f333333
	comiss	xmm0, DWORD PTR [eax+1552]
	jb	$LN43@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T134[ebp], xmm0

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR $T132[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2208 : 						groundType = OTWDriver.GetGroundType( XPos(), YPos() );

	push	ecx
	movss	xmm0, DWORD PTR $T134[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR $T132[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundType@OTWDriverClass@@QAEHMM@Z	; OTWDriverClass::GetGroundType
	mov	DWORD PTR _groundType$266[ebp], eax

; 2209 : 						if(groundType != COVERAGE_ROAD)

	cmp	DWORD PTR _groundType$266[ebp], 10	; 0000000aH
	je	$LN43@Exec

; 2210 : 						{
; 2211 : 							connected=1;

	mov	DWORD PTR _connected$256[ebp], 1

; 2212 : 							dustConnect=1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1464], 1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR $T130[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2217 : 							pos.x = XPos();

	movss	xmm0, DWORD PTR $T130[ebp]
	movss	DWORD PTR _pos$303[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR $T128[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2218 : 							pos.y = YPos();

	movss	xmm0, DWORD PTR $T128[ebp]
	movss	DWORD PTR _pos$303[ebp+4], xmm0

; 2219 : 							pos.z = af->groundZ - 3.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1272]
	subss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _pos$303[ebp+8], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$290[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$290[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$290[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	edx, DWORD PTR _FastRandom$290[ebp]
	mov	DWORD PTR $T126[ebp], edx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	eax, DWORD PTR $T126[ebp]
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$124[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$124[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T122[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2221 : 							mvec.x = 20.0f * PRANDFloat();

	movss	xmm0, DWORD PTR __real@41a00000
	mulss	xmm0, DWORD PTR $T122[ebp]
	movss	DWORD PTR _mvec$304[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$282[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$282[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$282[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	ecx, DWORD PTR _FastRandom$282[ebp]
	mov	DWORD PTR $T120[ebp], ecx

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;
; 131  : 	return((x<5)?x:x-5);
; 132  : }
; 133  : 
; 134  : inline int PRANDInt3( void )
; 135  : {
; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;
; 138  : 	return((x<3)?x:x-3);
; 139  : }
; 140  : 
; 141  : 
; 142  : inline float PRANDFloat( void )
; 143  : {
; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	mov	edx, DWORD PTR $T120[ebp]
	and	edx, 65535				; 0000ffffH
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _x$118[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$118[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR $T116[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2222 : 							mvec.y = 20.0f * PRANDFloat();

	movss	xmm0, DWORD PTR __real@41a00000
	mulss	xmm0, DWORD PTR $T116[ebp]
	movss	DWORD PTR _mvec$304[ebp+4], xmm0

; 2223 : 							mvec.z = -30.0f;

	movss	xmm0, DWORD PTR __real@c1f00000
	movss	DWORD PTR _mvec$304[ebp+8], xmm0

; 2224 : 
; 2225 : 							//RV - I-Hawk - Not using the dust trail anymore
; 2226 : 
; 2227 : 							///*
; 2228 : 							//if (!dustTrail){
; 2229 : 							//	/*
; 2230 : 							//	if (dustTrail=new DrawableTrail(TRAIL_DUSTCLOUD))
; 2231 : 							//	{
; 2232 : 							//		OTWDriver.InsertObject(dustTrail);
; 2233 : 							//	}*/
; 2234 : 							//	dustTrail = TRAIL_DUSTCLOUD;
; 2235 : 							//}
; 2236 : 							//*/
; 2237 : 
; 2238 : 							//I-Hawk - Use PS for dust/mist effect
; 2239 : 							if ( !( groundType == COVERAGE_WATER || groundType == COVERAGE_RIVER ) )

	cmp	DWORD PTR _groundType$266[ebp], 1
	je	SHORT $LN42@Exec
	cmp	DWORD PTR _groundType$266[ebp], 2
	je	SHORT $LN42@Exec

; 2240 : 								{
; 2241 : 								theSFX = SFX_DUSTCLOUD;

	mov	DWORD PTR _theSFX$258[ebp], 46		; 0000002eH

; 2242 : 							}
; 2243 : 
; 2244 : 							else 

	jmp	SHORT $LN41@Exec
$LN42@Exec:

; 2245 : 							{
; 2246 : 								theSFX = SFX_WATERCLOUD;

	mov	DWORD PTR _theSFX$258[ebp], 13		; 0000000dH
$LN41@Exec:

; 2247 : 							}
; 2248 : 
; 2249 : 								//dustTrail->AddPointAtHead(&pos,0);
; 2250 : 								//dustTrail->SetHeadVelocity(&mvec);
; 2251 : 
; 2252 : 							/*
; 2253 : 							dustTrail_trail = DrawableParticleSys::PS_EmitTrail(
; 2254 : 								dustTrail_trail, dustTrail, pos.x, pos.y, pos.z
; 2255 : 								);
; 2256 : 								*/
; 2257 : 
; 2258 : 							DrawableParticleSys::PS_AddParticleEx(
; 2259 : 							(theSFX + 1), &pos, &mvec);

	lea	eax, DWORD PTR _mvec$304[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$303[ebp]
	push	ecx
	mov	edx, DWORD PTR _theSFX$258[ebp]
	add	edx, 1
	push	edx
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH
$LN43@Exec:

; 2260 : 							
; 2261 : 							}
; 2262 : 						}
; 2263 : 					}
; 2264 : 
; 2265 : 				if (!connected && dustConnect && dustTrail){

	cmp	DWORD PTR _connected$256[ebp], 0
	jne	SHORT $LN40@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1464], 0
	je	SHORT $LN40@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1424], 0
	je	SHORT $LN40@Exec

; 2266 : 					//dustTrail->TrimTrail(0);
; 2267 : 					dustConnect=FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1464], 0

; 2268 : 					DrawableParticleSys::PS_KillTrail(dustTrail_trail);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1428]
	push	ecx
	call	?PS_KillTrail@DrawableParticleSys@@SAXK@Z ; DrawableParticleSys::PS_KillTrail
	add	esp, 4

; 2269 : 					dustTrail = dustTrail_trail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1428], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1424], 0
$LN40@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 98   : 	int MotionOn(void) {return motionOn;};

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+352
	mov	DWORD PTR $T114[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2273 : 		if (SimDriver.MotionOn()){

	cmp	DWORD PTR $T114[ebp], 0
	je	SHORT $LN39@Exec

; 2274 : 			af->Exec();	

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?Exec@AirframeClass@@QAEXXZ		; AirframeClass::Exec
$LN39@Exec:

; 2284 : 		if (theLantirn && theLantirn->IsEnabled() && !isDigital){

	cmp	DWORD PTR ?theLantirn@@3PAVLantirnClass@@A, 0 ; theLantirn
	je	SHORT $LN38@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\lantirn.h

; 17   :     bool IsEnabled() { return (m_flags & AVAILABLE) ? TRUE : FALSE; };

	mov	eax, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	mov	ecx, DWORD PTR [eax+156]
	and	ecx, 2
	je	SHORT $LN751@Exec
	mov	DWORD PTR tv4799[ebp], 1
	jmp	SHORT $LN752@Exec
$LN751@Exec:
	mov	DWORD PTR tv4799[ebp], 0
$LN752@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2284 : 		if (theLantirn && theLantirn->IsEnabled() && !isDigital){

	movzx	edx, BYTE PTR tv4799[ebp]
	test	edx, edx
	je	SHORT $LN38@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	jne	SHORT $LN38@Exec

; 2285 : 		    theLantirn->Exec(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?Exec@LantirnClass@@QAEXPAVAircraftClass@@@Z ; LantirnClass::Exec
$LN38@Exec:

; 2286 : 		}
; 2287 : 		
; 2288 : 		//TJL 02/28/04 Speedbrake specific coding
; 2289 : 		SetSpeedBrake();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSpeedBrake@AircraftClass@@QAEXXZ	; AircraftClass::SetSpeedBrake

; 2292 : 		if ( af->dbrake > 0.1f && this == SimDriver.GetPlayerEntity() && GetKias() > 100.0F){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1548]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	$LN37@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T112[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2292 : 		if ( af->dbrake > 0.1f && this == SimDriver.GetPlayerEntity() && GetKias() > 100.0F){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR $T112[ebp]
	jne	$LN37@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv7015[ebp]
	movss	xmm0, DWORD PTR tv7015[ebp]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	$LN37@Exec

; 2293 : 			SoundPos.Sfx( af->auxaeroData->sndSpdBrakeWind, 0, GetKias()/450.0f, (1.0F - af->speedBrake) * -100.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [edx+1560]
	mulss	xmm0, DWORD PTR __real@c2c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv7023[ebp]
	movss	xmm0, DWORD PTR tv7023[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+2360]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN37@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, 16					; 00000010H
	je	SHORT $LN757@Exec
	mov	DWORD PTR tv4803[ebp], 1
	jmp	SHORT $LN758@Exec
$LN757@Exec:
	mov	DWORD PTR tv4803[ebp], 0
$LN758@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2296 : 		if (af->IsSet(AirframeClass::Refueling) && DBrain() && !DBrain()->IsTanker()){

	cmp	DWORD PTR tv4803[ebp], 0
	je	$LN34@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T108[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2296 : 		if (af->IsSet(AirframeClass::Refueling) && DBrain() && !DBrain()->IsTanker()){

	cmp	DWORD PTR $T108[ebp], 0
	je	$LN34@Exec
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv3312[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR tv3312[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2296 : 		if (af->IsSet(AirframeClass::Refueling) && DBrain() && !DBrain()->IsTanker()){

	mov	ecx, DWORD PTR tv3312[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv3312[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	test	eax, eax
	jne	$LN34@Exec

; 2297 : 			AircraftClass *tanker = NULL;

	mov	DWORD PTR _tanker$283[ebp], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T106[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 784  : 	VU_ID			Tanker(void)								{return tankerId;}

	mov	eax, DWORD PTR $T106[ebp]
	mov	ecx, DWORD PTR [eax+352]
	mov	edx, DWORD PTR [eax+356]
	mov	DWORD PTR $T37[ebp], ecx
	mov	DWORD PTR $T37[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2298 : 			tanker = (AircraftClass*)vuDatabase->Find(DBrain()->Tanker());

	mov	eax, DWORD PTR $T37[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T37[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _tanker$283[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1253 : 	float GetRefuelRate(void) {return auxaeroData->refuelRate; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+2556]
	movss	DWORD PTR _refuelRate$100[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 144  : 	int GetRefuelingMode (void)								{ return SimAirRefuelingMode; };

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+72
	mov	DWORD PTR $T104[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2300 : 			float refuelHelp = (float)PlayerOptions.GetRefuelingMode();

	cvtsi2ss xmm0, DWORD PTR $T104[ebp]
	movss	DWORD PTR _refuelHelp$262[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T102[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2301 : 			if (this != SimDriver.GetPlayerEntity() && g_fAIRefuelSpeed)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR $T102[ebp]
	je	SHORT $LN35@Exec
	movss	xmm0, DWORD PTR ?g_fAIRefuelSpeed@@3MA
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN35@Exec

; 2302 : 				refuelHelp = g_fAIRefuelSpeed;

	movss	xmm0, DWORD PTR ?g_fAIRefuelSpeed@@3MA
	movss	DWORD PTR _refuelHelp$262[ebp], xmm0
$LN35@Exec:

; 2303 : 			if (!tanker || !tanker->IsAirplane() || 
; 2304 : 				!af->AddFuel(refuelRate * SimLibMajorFrameTime * refuelHelp * refuelHelp)
; 2305 : 			){

	cmp	DWORD PTR _tanker$283[ebp], 0
	je	SHORT $LN33@Exec
	mov	edx, DWORD PTR _tanker$283[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _tanker$283[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	SHORT $LN33@Exec
	movss	xmm0, DWORD PTR _refuelRate$100[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mulss	xmm0, DWORD PTR _refuelHelp$262[ebp]
	mulss	xmm0, DWORD PTR _refuelHelp$262[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?AddFuel@AirframeClass@@QAEHM@Z		; AirframeClass::AddFuel
	test	eax, eax
	jne	$LN34@Exec
$LN33@Exec:

; 2306 : 				FalconTankerMessage *TankerMsg;
; 2307 : 
; 2308 : 				if(tanker){

	cmp	DWORD PTR _tanker$283[ebp], 0
	je	$LN32@Exec

; 2309 : 					TankerMsg	= new FalconTankerMessage (tanker->Id(), FalconLocalGame);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T250[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T250[ebp], 0
	je	$LN247@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN775@Exec
	mov	DWORD PTR tv4827[ebp], 1
	jmp	SHORT $LN776@Exec
$LN775@Exec:
	mov	DWORD PTR tv4827[ebp], 0
$LN776@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2309 : 					TankerMsg	= new FalconTankerMessage (tanker->Id(), FalconLocalGame);

	movzx	ecx, BYTE PTR tv4827[ebp]
	test	ecx, ecx
	je	SHORT $LN245@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	edx, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T98[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T98[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2309 : 					TankerMsg	= new FalconTankerMessage (tanker->Id(), FalconLocalGame);

	mov	DWORD PTR tv3385[ebp], eax
	jmp	SHORT $LN246@Exec
$LN245@Exec:
	mov	DWORD PTR tv3385[ebp], 0
$LN246@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _tanker$283[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T35[ebp], ecx
	mov	DWORD PTR $T35[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2309 : 					TankerMsg	= new FalconTankerMessage (tanker->Id(), FalconLocalGame);

	push	1
	mov	eax, DWORD PTR tv3385[ebp]
	push	eax
	mov	ecx, DWORD PTR $T35[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T35[ebp]
	push	edx
	mov	ecx, DWORD PTR $T250[ebp]
	call	??0FalconTankerMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTankerMessage::FalconTankerMessage
	mov	DWORD PTR tv3396[ebp], eax
	jmp	SHORT $LN248@Exec
$LN247@Exec:
	mov	DWORD PTR tv3396[ebp], 0
$LN248@Exec:
	mov	eax, DWORD PTR tv3396[ebp]
	mov	DWORD PTR $T97[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T97[ebp]
	mov	DWORD PTR _TankerMsg$281[ebp], ecx

; 2310 : 				}
; 2311 : 				else {

	jmp	$LN31@Exec
$LN32@Exec:

; 2312 : 					TankerMsg	= new FalconTankerMessage (FalconNullId, FalconLocalGame);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T248[ebp], 0
	je	SHORT $LN251@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 41   : 		return e != NULL;

	cmp	DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A, 0 ; vuLocalSessionEntity
	je	SHORT $LN785@Exec
	mov	DWORD PTR tv4840[ebp], 1
	jmp	SHORT $LN786@Exec
$LN785@Exec:
	mov	DWORD PTR tv4840[ebp], 0
$LN786@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2312 : 					TankerMsg	= new FalconTankerMessage (FalconNullId, FalconLocalGame);

	movzx	edx, BYTE PTR tv4840[ebp]
	test	edx, edx
	je	SHORT $LN249@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T96[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	mov	ecx, DWORD PTR $T96[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2312 : 					TankerMsg	= new FalconTankerMessage (FalconNullId, FalconLocalGame);

	mov	DWORD PTR tv3419[ebp], eax
	jmp	SHORT $LN250@Exec
$LN249@Exec:
	mov	DWORD PTR tv3419[ebp], 0
$LN250@Exec:
	push	1
	mov	ecx, DWORD PTR tv3419[ebp]
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	eax
	mov	ecx, DWORD PTR $T248[ebp]
	call	??0FalconTankerMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTankerMessage::FalconTankerMessage
	mov	DWORD PTR tv3423[ebp], eax
	jmp	SHORT $LN252@Exec
$LN251@Exec:
	mov	DWORD PTR tv3423[ebp], 0
$LN252@Exec:
	mov	ecx, DWORD PTR tv3423[ebp]
	mov	DWORD PTR $T95[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T95[ebp]
	mov	DWORD PTR _TankerMsg$281[ebp], edx
$LN31@Exec:

; 2313 : 				}
; 2314 : 
; 2315 : 				TankerMsg->dataBlock.type	= FalconTankerMessage::DoneRefueling;

	mov	eax, DWORD PTR _TankerMsg$281[ebp]
	mov	DWORD PTR [eax+56], 2
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T33[ebp], edx
	mov	DWORD PTR $T33[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2316 : 				TankerMsg->dataBlock.caller	= Id();

	mov	ecx, DWORD PTR $T33[ebp]
	mov	edx, DWORD PTR $T33[ebp+4]
	mov	eax, DWORD PTR _TankerMsg$281[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 2317 : 				TankerMsg->dataBlock.data1  = 0;

	mov	ecx, DWORD PTR _TankerMsg$281[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+60], xmm0

; 2318 : 				FalconSendMessage(TankerMsg);

	push	0
	mov	edx, DWORD PTR _TankerMsg$281[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN34@Exec:

; 2319 : 			}
; 2320 : 		}
; 2321 : 		/*--------------------*/
; 2322 : 		/* Update shared data */
; 2323 : 		/*--------------------*/
; 2324 : 
; 2325 : 		SetPosition (af->x, af->y, af->z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1116]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 2326 : 		SetDelta (af->xdot, af->ydot, af->zdot);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1204]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1200]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1196]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 2327 : 		SetYPR (af->psi, af->theta, af->phi);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1168]
	movss	DWORD PTR $T93[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1160]
	movss	DWORD PTR $T92[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1164]
	movss	DWORD PTR $T90[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T93[ebp]
	movss	DWORD PTR [eax+60], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T92[ebp]
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T90[ebp]
	movss	DWORD PTR [edx+68], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2328 : 		SetYPRDelta (af->r, af->q, af->p);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1140]
	movss	DWORD PTR $T88[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1136]
	movss	DWORD PTR $T86[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1132]
	movss	DWORD PTR $T84[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 117  : 		orient_.dyaw_ = dyaw; orient_.dpitch_ = dpitch; orient_.droll_=droll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T88[ebp]
	movss	DWORD PTR [eax+72], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T86[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T84[ebp]
	movss	DWORD PTR [edx+80], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2334 : 		SetPowerOutput(af->rpm);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1212]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPowerOutput@AircraftClass@@QAEXM@Z	; AircraftClass::SetPowerOutput

; 2335 : 		//me123 back		SetPowerOutput(af->rpm, af->oldp01[0]);
; 2336 : 		// END OF MODIFIED SECTION
; 2337 : 		
; 2338 : 		// Weapons
; 2339 : 		if ( autopilotType != CombatAP ){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+968], 2
	je	SHORT $LN30@Exec

; 2340 : 			SetTarget(FCC->Exec(targetPtr, targetList, theInputs));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	call	?Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV2@0PAVPilotInputs@@@Z ; FireControlComputer::Exec
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget

; 2341 : 		}
; 2342 : 		else {

	jmp	$LN29@Exec
$LN30@Exec:

; 2343 : 			// edg: emperical hack.  The FCC is exec'd in digi anyway
; 2344 : 			// when bombing run.  Doing it here as well also screws up
; 2345 : 			// digi's releasing bombs
; 2346 : 			SimObjectType* tmpTarget = targetPtr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	mov	DWORD PTR _tmpTarget$269[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T82[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2348 : 			if (FCC->GetMasterMode() == FireControlComputer::AirGroundMissile && DBrain()){

	cmp	DWORD PTR $T82[ebp], 6
	jne	SHORT $LN28@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T80[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2348 : 			if (FCC->GetMasterMode() == FireControlComputer::AirGroundMissile && DBrain()){

	cmp	DWORD PTR $T80[ebp], 0
	je	SHORT $LN28@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T78[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 676  : 	SimObjectType* GetGroundTarget( void )				{return groundTargetPtr;};

	mov	ecx, DWORD PTR $T78[ebp]
	mov	edx, DWORD PTR [ecx+224]
	mov	DWORD PTR _tmpTarget$269[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2351 : 			else if (FCC->GetMasterMode() == FireControlComputer::AirGroundLaser){

	jmp	SHORT $LN26@Exec
$LN28@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T76[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2351 : 			else if (FCC->GetMasterMode() == FireControlComputer::AirGroundLaser){

	cmp	DWORD PTR $T76[ebp], 8
	jne	SHORT $LN26@Exec

; 2352 : 			    tmpTarget = NULL;

	mov	DWORD PTR _tmpTarget$269[ebp], 0
$LN26@Exec:

; 2353 : 			}
; 2354 : 
; 2355 : //   		if (FCC->GetMasterMode() != FireControlComputer::AirGroundBomb)
; 2356 : 			// TODO
; 2357 : 			// COBRA - RED - WE HAD A CTD from this following call just entering 3D, still dunno why...
; 2358 :    			SetTarget(FCC->Exec(tmpTarget, targetList, theInputs));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	push	eax
	mov	ecx, DWORD PTR _tmpTarget$269[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?Exec@FireControlComputer@@QAEPAVSimObjectType@@PAV2@0PAVPilotInputs@@@Z ; FireControlComputer::Exec
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
$LN29@Exec:

; 2359 : 		}
; 2360 : 		DoWeapons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoWeapons@AircraftClass@@QAEXXZ	; AircraftClass::DoWeapons

; 2361 : 		
; 2362 : 		// Handle missiles launched but still on the rail
; 2363 : 		Sms->Exec();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?Exec@SMSClass@@QAEXXZ			; SMSClass::Exec

; 2365 : 		if (TheHud && TheHud->Ownship() == this && Guns != NULL)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	$LN25@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h

; 253  : 	AircraftClass*	Ownship(void) {return ownship;};

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T74[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2365 : 		if (TheHud && TheHud->Ownship() == this && Guns != NULL)

	mov	eax, DWORD PTR $T74[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	$LN25@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+944], 0
	je	$LN25@Exec

; 2366 : 		{
; 2367 : 			TheHud->SetEEGSData(af->x, af->y, af->z, af->gmma, af->sigma,
; 2368 : 				af->theta, af->psi, af->vt);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1120]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1168]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1160]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1176]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1172]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1116]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetEEGSData@HudClass@@QAEXMMMMMMMM@Z	; HudClass::SetEEGSData
$LN25@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 175  : 	int IsDying() const { return (specialData.flags & OBJ_DYING ? TRUE : FALSE); }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN811@Exec
	mov	DWORD PTR tv4906[ebp], 1
	jmp	SHORT $LN812@Exec
$LN811@Exec:
	mov	DWORD PTR tv4906[ebp], 0
$LN812@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2371 : 		if (IsDying ())

	cmp	DWORD PTR tv4906[ebp], 0
	je	SHORT $LN24@Exec

; 2372 : 			SetDead(TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+364]
	call	edx
$LN24@Exec:

; 2373 : 		
; 2374 : 		// Do countermeasures
; 2375 : 		DoCountermeasures();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoCountermeasures@AircraftClass@@QAEXXZ ; AircraftClass::DoCountermeasures
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR $T72[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2378 : 		UnitClass	*campObj = (UnitClass*) GetCampaignObject();

	mov	edx, DWORD PTR $T72[ebp]
	mov	DWORD PTR _campObj$293[ebp], edx

; 2379 : 		if (campObj && campObj->IsLocal() && campObj->GetComponentLead() == this)

	cmp	DWORD PTR _campObj$293[ebp], 0
	je	$LN22@Exec
	mov	ecx, DWORD PTR _campObj$293[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	$LN22@Exec
	mov	ecx, DWORD PTR _campObj$293[ebp]
	call	?GetComponentLead@CampBaseClass@@QAEPAVSimBaseClass@@XZ ; CampBaseClass::GetComponentLead
	cmp	eax, DWORD PTR _this$[ebp]
	jne	$LN22@Exec

; 2380 : 		{
; 2381 : 			campObj->SimSetLocation(af->x, af->y, af->z);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1116]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _campObj$293[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campObj$293[ebp]
	mov	eax, DWORD PTR [edx+556]
	call	eax

; 2382 : 			if (campObj->IsFlight())

	mov	ecx, DWORD PTR _campObj$293[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campObj$293[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN22@Exec

; 2383 : 				campObj->SimSetOrientation (af->psi, af->theta, af->phi);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1164]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1160]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1168]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _campObj$293[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campObj$293[ebp]
	mov	eax, DWORD PTR [edx+560]
	call	eax
$LN22@Exec:

; 2384 : 		}
; 2385 : 		
; 2386 : 		//Check cautions
; 2387 : 		CautionCheck();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CautionCheck@AircraftClass@@QAEXXZ	; AircraftClass::CautionCheck
$LN159@Exec:

; 2388 : 		//STOP_PROFILE("AC_EXEC_5h");
; 2389 :    }
; 2390 : 
; 2391 :    //START_PROFILE("AC_EXEC_6");
; 2392 : 
; 2393 :    // If ownship update control surfaces
; 2394 :    if (!IsExploding())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN21@Exec

; 2395 :       MoveSurfaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveSurfaces@AircraftClass@@QAEXXZ	; AircraftClass::MoveSurfaces
$LN21@Exec:

; 2396 : 
; 2397 :    if ( !IsDead() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	SHORT $LN20@Exec

; 2398 :       ShowDamage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowDamage@AircraftClass@@QAEXXZ	; AircraftClass::ShowDamage
$LN20@Exec:

; 2401 : 	if(af && af->IsSet(AirframeClass::InAir) && af->PBON)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	je	SHORT $LN19@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, 2
	je	SHORT $LN819@Exec
	mov	DWORD PTR tv4911[ebp], 1
	jmp	SHORT $LN820@Exec
$LN819@Exec:
	mov	DWORD PTR tv4911[ebp], 0
$LN820@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2401 : 	if(af && af->IsSet(AirframeClass::InAir) && af->PBON)

	cmp	DWORD PTR tv4911[ebp], 0
	je	SHORT $LN19@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movzx	ecx, BYTE PTR [eax+1616]
	test	ecx, ecx
	je	SHORT $LN19@Exec

; 2402 : 		af->PBON = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	BYTE PTR [eax+1616], 0
$LN19@Exec:

; 2403 : 	//TJL 08/01/04 Refuel in DF //Cobra 10/30/04 TJL
; 2404 : 	HotPitRefuel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HotPitRefuel@AircraftClass@@QAEXXZ	; AircraftClass::HotPitRefuel

; 2405 : 	//Cobra 11/20/04 IFF Do we have it? Is it on? Is it working?
; 2406 : 	if (
; 2407 : 		(af->auxaeroData->hasIFF == 1 || g_bAllHaveIFF) && 
; 2408 : 		HasPower(AircraftClass::IFFPower) && (!mFaults->GetFault(FaultClass::iff_fault))
; 2409 : 	){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+4024], 1
	je	SHORT $LN17@Exec
	movzx	ecx, BYTE PTR ?g_bAllHaveIFF@@3_NA	; g_bAllHaveIFF
	test	ecx, ecx
	je	SHORT $LN18@Exec
$LN17@Exec:
	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN18@Exec
	push	19					; 00000013H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN18@Exec

; 2410 : 		iffEnabled = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+896], 1

; 2411 : 	}
; 2412 : 	else {

	jmp	SHORT $LN16@Exec
$LN18@Exec:

; 2413 : 		iffEnabled = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+896], 0
$LN16@Exec:

; 2414 : 	}
; 2415 : 
; 2416 : 	//Cobra 11/21/04 Run Interrogation through modes
; 2417 : 	if (runIFFInt){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+901]
	test	eax, eax
	je	$LN15@Exec

; 2418 : 		if (iffModeChallenge == 99){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+908], 99			; 00000063H
	jne	SHORT $LN14@Exec

; 2419 : 			iffModeChallenge = 4;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], 4

; 2420 : 			iffModeTimer = SimLibElapsedTime + 1000.0f;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv7261[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv7261[ebp]
	mov	ecx, DWORD PTR tv7261[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv7265[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv7265[ebp]
	addss	xmm0, DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+904], xmm0
	jmp	$LN10@Exec
$LN14@Exec:

; 2421 : 		}
; 2422 : 		else if ((iffModeChallenge <=4 && iffModeChallenge > 0) && (iffModeTimer < SimLibElapsedTime)){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+908], 4
	jg	$LN12@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+908], 0
	jle	$LN12@Exec
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv7273[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv7273[ebp]
	mov	eax, DWORD PTR tv7273[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv7277[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv7277[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+904]
	jbe	SHORT $LN12@Exec

; 2423 : 			iffModeChallenge --;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+908]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], eax

; 2424 : 			iffModeTimer = SimLibElapsedTime + 1000.0f;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv7285[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv7285[ebp]
	mov	eax, DWORD PTR tv7285[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv7289[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv7289[ebp]
	addss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+904], xmm0
	jmp	SHORT $LN10@Exec
$LN12@Exec:

; 2425 : 		}
; 2426 : 		else if (iffModeChallenge == 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+908], 0
	jne	SHORT $LN10@Exec

; 2427 : 			interrogating = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+900], 1

; 2428 : 			runIFFInt = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+901], 0
$LN10@Exec:

; 2429 : 		}
; 2430 : 
; 2431 : 	}
; 2432 : 	else {

	jmp	SHORT $LN9@Exec
$LN15@Exec:

; 2433 : 		runIFFInt = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+901], 0

; 2434 : 		iffModeTimer = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+904], xmm0

; 2435 : 		iffModeChallenge = 99;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], 99			; 00000063H

; 2436 : 		interrogating = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+900], 0
$LN9@Exec:

; 2437 : 	}
; 2438 : 
; 2439 : 	//Cobra CombatAP doesn't turn on Master Arm for human pilot .. So, let's fix that.
; 2440 : 	// sfr: TODO must go to initialization. fucking hack
; 2441 : 	if(Sms){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+940], 0
	je	$LN825@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T70[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2445 : 		){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR $T70[ebp]
	jne	SHORT $LN825@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+968], 2
	jne	SHORT $LN825@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T68[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2445 : 		){

	cmp	DWORD PTR $T68[ebp], 0
	jne	SHORT $LN825@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN825@Exec

; 2446 : 			Sms->SetMasterArm(SMSBaseClass::Arm);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	DWORD PTR $T66[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	mov	eax, DWORD PTR $T66[ebp]
	mov	DWORD PTR [eax+8], 2
$LN825@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR $T64[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2451 : 	if(ZPos() < -150.0f || af->Thrust() > 5.0f)

	movss	xmm0, DWORD PTR __real@c3160000
	comiss	xmm0, DWORD PTR $T64[ebp]
	ja	SHORT $LN5@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 840  : 	float Thrust() { return thrust; };

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+188]
	movss	DWORD PTR $T62[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2451 : 	if(ZPos() < -150.0f || af->Thrust() > 5.0f)

	movss	xmm0, DWORD PTR $T62[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	SHORT $LN6@Exec
$LN5@Exec:

; 2452 : 		carrierInitTimer = 35.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@420c0000
	movss	DWORD PTR [ecx+3564], xmm0
$LN6@Exec:

; 2453 : 	
; 2454 : 	//Cobra lights
; 2455 : 	// sfr: check light stuff here
; 2456 : 	if (isDigital && curWaypoint)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	$LN859@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+728], 0
	je	$LN859@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	movzx	eax, BYTE PTR [edx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2462 : 		){

	cmp	eax, 1
	je	SHORT $LN3@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	movzx	eax, BYTE PTR [edx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2462 : 		){

	cmp	eax, 7
	je	SHORT $LN3@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+760]
	and	edx, 4
	je	SHORT $LN837@Exec
	mov	DWORD PTR tv4915[ebp], 1
	jmp	SHORT $LN838@Exec
$LN837@Exec:
	mov	DWORD PTR tv4915[ebp], 0
$LN838@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2462 : 		){

	movzx	eax, BYTE PTR tv4915[ebp]
	test	eax, eax
	je	SHORT $LN3@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 187  : 	void ExtlOff(ExtlLightFlags fl){ ClearAcStatusBits(fl); }

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2468 : 		else if (curWaypoint->GetWPAction() == WP_LAND && !(IsAcStatusBitsSet(ACSTATUS_EXT_LIGHTS))){

	jmp	SHORT $LN859@Exec
$LN3@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	movzx	eax, BYTE PTR [edx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2468 : 		else if (curWaypoint->GetWPAction() == WP_LAND && !(IsAcStatusBitsSet(ACSTATUS_EXT_LIGHTS))){

	cmp	eax, 7
	jne	SHORT $LN859@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+760]
	and	edx, 4
	je	SHORT $LN851@Exec
	mov	DWORD PTR tv4919[ebp], 1
	jmp	SHORT $LN852@Exec
$LN851@Exec:
	mov	DWORD PTR tv4919[ebp], 0
$LN852@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2468 : 		else if (curWaypoint->GetWPAction() == WP_LAND && !(IsAcStatusBitsSet(ACSTATUS_EXT_LIGHTS))){

	movzx	eax, BYTE PTR tv4919[ebp]
	test	eax, eax
	jne	SHORT $LN859@Exec
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 186  : 	void ExtlOn(ExtlLightFlags fl) { SetAcStatusBits(fl); }

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
$LN859@Exec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 2477 : 	return TRUE;

	mov	eax, 1
$LN229@Exec:

; 2478 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN862@Exec:
	DD	$LN173@Exec
	DD	$LN167@Exec
	DD	$LN171@Exec
	DD	$LN165@Exec
	DD	$LN169@Exec
	DD	$LN173@Exec
	DD	$LN171@Exec
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Exec@AircraftClass@@UAEHXZ$0:
	mov	eax, DWORD PTR $T257[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Exec@AircraftClass@@UAEHXZ$1:
	mov	eax, DWORD PTR $T250[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Exec@AircraftClass@@UAEHXZ$2:
	mov	eax, DWORD PTR $T248[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Exec@AircraftClass@@UAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2796]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Exec@AircraftClass@@UAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Exec@AircraftClass@@UAEHXZ ENDP			; AircraftClass::Exec
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fault.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\guns.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbrain.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbrain.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\dogfight.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T2 = -744						; size = 4
tv2262 = -728						; size = 8
tv2726 = -720						; size = 8
tv2622 = -712						; size = 8
tv2702 = -704						; size = 8
tv2646 = -696						; size = 8
_wp2Z$ = -688						; size = 4
$T3 = -684						; size = 8
$T4 = -676						; size = 8
$T5 = -668						; size = 8
$T6 = -660						; size = 4
$T7 = -656						; size = 8
$T8 = -648						; size = 4
$T9 = -644						; size = 8
_z$10 = -636						; size = 4
$T11 = -632						; size = 8
$T12 = -624						; size = 4
$T13 = -620						; size = 4
$T14 = -616						; size = 4
$T15 = -612						; size = 4
$T16 = -608						; size = 4
tv2585 = -604						; size = 4
$T17 = -600						; size = 4
$T18 = -596						; size = 4
$T19 = -592						; size = 4
$T20 = -588						; size = 4
$T21 = -584						; size = 4
$T22 = -580						; size = 4
$T23 = -576						; size = 4
$T24 = -572						; size = 4
$T25 = -568						; size = 4
tv2483 = -564						; size = 4
$T26 = -560						; size = 4
tv3131 = -556						; size = 4
$T27 = -552						; size = 4
$T28 = -548						; size = 4
tv2979 = -544						; size = 4
tv2361 = -540						; size = 4
$T29 = -536						; size = 4
tv178 = -532						; size = 4
$T30 = -528						; size = 4
$T31 = -524						; size = 4
$T32 = -520						; size = 4
$T33 = -516						; size = 4
$T34 = -512						; size = 4
$T35 = -508						; size = 4
$T36 = -504						; size = 4
$T37 = -500						; size = 4
$T38 = -496						; size = 4
$T39 = -492						; size = 4
$T40 = -488						; size = 4
tv2596 = -484						; size = 4
$T41 = -480						; size = 4
$T42 = -476						; size = 4
$T43 = -472						; size = 4
$T44 = -468						; size = 4
$T45 = -464						; size = 4
$T46 = -460						; size = 4
$T47 = -456						; size = 4
$T48 = -452						; size = 4
$T49 = -448						; size = 4
$T50 = -444						; size = 4
$T51 = -440						; size = 4
$T52 = -436						; size = 4
$T53 = -432						; size = 4
$T54 = -428						; size = 4
$T55 = -424						; size = 4
tv3129 = -420						; size = 4
$T56 = -416						; size = 4
tv3127 = -412						; size = 4
$T57 = -408						; size = 4
$T58 = -404						; size = 4
$T59 = -400						; size = 4
$T60 = -396						; size = 4
$T61 = -392						; size = 4
tv2352 = -388						; size = 4
$T62 = -384						; size = 4
$T63 = -380						; size = 4
_sensorType$64 = -376					; size = 4
$T65 = -372						; size = 4
$T66 = -368						; size = 4
$T67 = -364						; size = 4
_x$68 = -360						; size = 4
$T69 = -356						; size = 4
_y$70 = -352						; size = 4
$T71 = -348						; size = 4
tv2033 = -344						; size = 4
tv1922 = -340						; size = 4
$T72 = -336						; size = 4
$T73 = -332						; size = 4
tv1542 = -328						; size = 4
tv639 = -324						; size = 4
tv1564 = -320						; size = 4
tv1069 = -316						; size = 4
$T74 = -312						; size = 4
tv1873 = -308						; size = 4
_pt$75 = -304						; size = 4
tv553 = -300						; size = 4
_obj$76 = -296						; size = 4
$T77 = -292						; size = 4
tv1362 = -288						; size = 4
tv1022 = -284						; size = 4
$T78 = -280						; size = 4
tv1895 = -276						; size = 4
tv1337 = -272						; size = 4
tv1819 = -268						; size = 4
$T79 = -264						; size = 4
tv618 = -260						; size = 4
tv1318 = -256						; size = 4
tv440 = -252						; size = 4
$T80 = -248						; size = 4
$T81 = -244						; size = 4
tv1299 = -240						; size = 4
tv168 = -236						; size = 4
tv1295 = -232						; size = 4
$T82 = -228						; size = 4
tv1267 = -224						; size = 4
tv1929 = -220						; size = 4
$T83 = -216						; size = 4
tv2722 = -212						; size = 4
tv1225 = -208						; size = 4
tv2698 = -204						; size = 4
$T84 = -200						; size = 4
tv2642 = -196						; size = 4
tv1199 = -192						; size = 4
tv2618 = -188						; size = 4
$T85 = -184						; size = 4
tv2258 = -180						; size = 4
tv1173 = -176						; size = 4
$T86 = -172						; size = 4
$T87 = -168						; size = 4
_dt$ = -164						; size = 4
tv1149 = -160						; size = 4
$T88 = -156						; size = 4
$T89 = -152						; size = 4
tv1773 = -148						; size = 4
tv1125 = -144						; size = 4
tv187 = -140						; size = 4
$T90 = -136						; size = 4
$T91 = -132						; size = 4
tv1101 = -128						; size = 4
$T92 = -124						; size = 4
$T93 = -120						; size = 4
$T94 = -116						; size = 4
_hasLGB$95 = -112					; size = 4
$T96 = -106						; size = 2
_hasHarm$97 = -104					; size = 4
$T98 = -98						; size = 2
_sensorIdx$99 = -96					; size = 4
$T100 = -90						; size = 2
$T101 = -88						; size = 4
$T102 = -82						; size = 2
_wp2X$ = -80						; size = 4
$T103 = -74						; size = 2
_wp2Y$ = -72						; size = 4
_wp1Z$ = -68						; size = 4
_st$104 = -64						; size = 4
$T105 = -60						; size = 4
_afIdx$ = -56						; size = 4
_needsRadar$106 = -52					; size = 4
_atWaypoint$ = -48					; size = 4
_classPtr$ = -44					; size = 4
$T107 = -38						; size = 1
$T108 = -37						; size = 1
_wp1Y$ = -36						; size = 4
_ent$109 = -32						; size = 4
_wp1X$ = -28						; size = 4
_allowGroundInit$110 = -21				; size = 1
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_initData$ = 8						; size = 4
?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z PROC	; AircraftClass::Init
; _this$ = ecx

; 533  : void AircraftClass::Init(SimInitDataClass* initData){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 732				; 000002dcH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	SimVehicleClass::Init (initData);

	mov	eax, DWORD PTR _initData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@SimVehicleClass@@UAEXPAVSimInitDataClass@@@Z ; SimVehicleClass::Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR _classPtr$[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 544  : 	if (initData){

	cmp	DWORD PTR _initData$[ebp], 0
	je	$LN6@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR $T71[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 162  : 	uchar GetSType() const					{	return (EntityType())->classInfo_[VU_STYPE]; }

	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR $T71[ebp]
	mov	cl, BYTE PTR [eax+edx+8]
	mov	BYTE PTR $T108[ebp], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 545  : 		if (GetSType() == STYPE_AIR_FIGHTER_BOMBER && GetSPType() == SPTYPE_F16C){

	movzx	edx, BYTE PTR $T108[ebp]
	cmp	edx, 7
	jne	$LN83@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR $T69[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h

; 163  : 	uchar GetSPType() const					{	return (EntityType())->classInfo_[VU_SPTYPE]; }

	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR $T69[ebp]
	mov	cl, BYTE PTR [eax+edx+8]
	mov	BYTE PTR $T107[ebp], cl
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 545  : 		if (GetSType() == STYPE_AIR_FIGHTER_BOMBER && GetSPType() == SPTYPE_F16C){

	movzx	edx, BYTE PTR $T107[ebp]
	cmp	edx, 3
	jne	$LN83@Init

; 546  : 			acFlags |= isF16|isComplex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	or	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 10			; 0000000aH
	jle	SHORT $LN152@Init
	mov	ecx, 10					; 0000000aH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 1
	mov	ecx, 10					; 0000000aH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN152@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	ecx, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T31[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 549  : 			if ( gACMIRec.IsRecording() ){

	cmp	DWORD PTR $T31[ebp], 0
	je	$LN83@Init

; 550  : 				acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv2258[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2258[ebp]
	mov	eax, DWORD PTR tv2258[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2262[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2262[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR $T103[ebp], dx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 551  : 				acmiSwitch.data.type = Type();

	movzx	eax, WORD PTR $T103[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T11[ebp], edx
	mov	DWORD PTR $T11[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 80   : 		return (unsigned long) value_; 

	mov	ecx, DWORD PTR $T11[ebp+4]
	mov	DWORD PTR $T67[ebp], ecx

; 81   : 	}
; 82   : 
; 83   : 	// note: these are private to prevent (mis)use
; 84   : private:
; 85   : 	int operator == (unsigned long &rhs) const ;
; 86   : 	int operator != (unsigned long &rhs) const ;
; 87   : 	int operator > (unsigned long &rhs) const ;
; 88   : 	int operator >= (unsigned long &rhs) const ;
; 89   : 	int operator < (unsigned long &rhs) const ;
; 90   : 	int operator <= (unsigned long &rhs) const ;
; 91   : 
; 92   : 	// DATA
; 93   : public:
; 94   : 	unsigned long 	value_;
; 95   : };
; 96   : 
; 97   : class VU_ID {
; 98   : public:
; 99   : 	//sfr: vu change
; 100  : 	VU_ID() : num_(0), creator_(0){}
; 101  : 	VU_ID(VU_SESSION_ID sessionpart, VU_ID_NUMBER idpart) : num_(idpart), creator_(sessionpart){}
; 102  : 
; 103  : 	// basic operator overloading
; 104  : 	bool operator == (const VU_ID &rhs) const { 
; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 
; 110  : 	}
; 111  : 	bool operator != (const VU_ID &rhs) const { 
; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 
; 117  : 	}
; 118  : 	bool operator > (const VU_ID &rhs) const {
; 119  : 		if (creator_ > rhs.creator_){
; 120  : 			return true;
; 121  : 		}
; 122  : 		if (creator_ == rhs.creator_)	{
; 123  : 			if (num_ > rhs.num_){
; 124  : 				return true;
; 125  : 			}
; 126  : 		}
; 127  : 		return false;
; 128  : 	}
; 129  : 	bool operator >= (const VU_ID &rhs) const {
; 130  : 		if (creator_ > rhs.creator_){
; 131  : 			return true;
; 132  : 		}
; 133  : 		if (creator_ == rhs.creator_){
; 134  : 			if (num_ >= rhs.num_){
; 135  : 				return true;
; 136  : 			}
; 137  : 		}
; 138  : 		return false;
; 139  : 	}
; 140  : 	bool operator < (const VU_ID &rhs) const {
; 141  : 		if (creator_ < rhs.creator_){
; 142  : 			return true;
; 143  : 		}
; 144  : 		if (creator_ == rhs.creator_){
; 145  : 			if (num_ < rhs.num_){
; 146  : 				return true;
; 147  : 			}
; 148  : 		}
; 149  : 		return false;
; 150  : 	}
; 151  : 	bool operator <= (const VU_ID &rhs) const {
; 152  : 		if (creator_ < rhs.creator_){
; 153  : 			return true;
; 154  : 		}
; 155  : 		if (creator_ == rhs.creator_){
; 156  : 			if (num_ <= rhs.num_){
; 157  : 				return true;
; 158  : 			}
; 159  : 		}
; 160  : 		return false;
; 161  : 	}
; 162  : 	operator VU_KEY() const { 
; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	movzx	edx, WORD PTR $T11[ebp]
	movzx	eax, WORD PTR $T67[ebp]
	shl	eax, 16					; 00000010H
	or	eax, edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 552  : 				acmiSwitch.data.uniqueID = Id();

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, eax

; 553  : 				acmiSwitch.data.switchNum = COMP_EXH_NOZZLE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, 10 ; 0000000aH

; 554  : 				acmiSwitch.data.switchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, 1

; 555  : 				acmiSwitch.data.prevSwitchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, 1

; 556  : 				gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN83@Init:

; 557  : 			}
; 558  : 		}
; 559  : 
; 560  : 		// Airframe Stuff
; 561  : 		af = new AirframeClass (this);

	push	1852					; 0000073cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T92[ebp], 0
	je	SHORT $LN88@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T92[ebp]
	call	??0AirframeClass@@QAE@PAVAircraftClass@@@Z ; AirframeClass::AirframeClass
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN89@Init
$LN88@Init:
	mov	DWORD PTR tv168[ebp], 0
$LN89@Init:
	mov	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T16[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR [eax+932], ecx

; 562  : 		af->SetFlag(AirframeClass::IsDigital);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR $T91[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	mov	ecx, DWORD PTR $T91[ebp]
	mov	edx, DWORD PTR [ecx+88]
	or	edx, 1
	mov	eax, DWORD PTR $T91[ebp]
	mov	DWORD PTR [eax+88], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 564  : 		if (mFaults){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+928], 0
	je	SHORT $LN91@Init

; 565  : 			delete mFaults;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+928]
	mov	DWORD PTR $T65[ebp], eax
	mov	ecx, DWORD PTR $T65[ebp]
	mov	DWORD PTR $T105[ebp], ecx
	cmp	DWORD PTR $T105[ebp], 0
	je	SHORT $LN90@Init
	mov	ecx, DWORD PTR $T105[ebp]
	call	??1FackClass@@QAE@XZ			; FackClass::~FackClass
	mov	edx, 1
	and	edx, 1
	je	SHORT $LN167@Init
	mov	eax, DWORD PTR $T105[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN167@Init:
	mov	ecx, DWORD PTR $T105[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN91@Init
$LN90@Init:
	mov	DWORD PTR tv178[ebp], 0
$LN91@Init:

; 566  : 		}
; 567  : 		mFaults = new FackClass;

	push	564					; 00000234H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T77[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77[ebp], 0
	je	SHORT $LN92@Init
	mov	ecx, DWORD PTR $T77[ebp]
	call	??0FackClass@@QAE@XZ			; FackClass::FackClass
	mov	DWORD PTR tv187[ebp], eax
	jmp	SHORT $LN93@Init
$LN92@Init:
	mov	DWORD PTR tv187[ebp], 0
$LN93@Init:
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T63[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T63[ebp]
	mov	DWORD PTR [eax+928], ecx

; 568  : 		if (isDigital){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	SHORT $LN81@Init

; 569  : 			if (SimDriver.RunningInstantAction()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningInstantAction@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningInstantAction
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN184@Init

; 570  : 				af->SetFlag(AirframeClass::NoFuelBurn);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T81[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	mov	eax, DWORD PTR $T81[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR $T81[ebp]
	mov	DWORD PTR [edx+88], ecx
$LN184@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 573  : 		else {

	jmp	$LN194@Init
$LN81@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 150  : 	int UnlimitedFuel (void)								{ return (SimFlags & SIM_UNLIMITED_FUEL) && TRUE; }

	mov	eax, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+52
	and	eax, 4
	je	SHORT $LN188@Init
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN188@Init
	mov	DWORD PTR tv1773[ebp], 1
	jmp	SHORT $LN189@Init
$LN188@Init:
	mov	DWORD PTR tv1773[ebp], 0
$LN189@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 575  : 			if (PlayerOptions.UnlimitedFuel()){

	cmp	DWORD PTR tv1773[ebp], 0
	je	SHORT $LN190@Init

; 576  : 				af->SetFlag(AirframeClass::NoFuelBurn);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR $T73[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	mov	ecx, DWORD PTR $T73[ebp]
	mov	edx, DWORD PTR [ecx+88]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR $T73[ebp]
	mov	DWORD PTR [eax+88], edx
$LN190@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 140  : 	int GetFlightModelType (void)							{ return SimFlightModel; }

	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+56
	mov	DWORD PTR $T6[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 580  : 			if (PlayerOptions.GetFlightModelType() == FMSimplified){

	cmp	DWORD PTR $T6[ebp], 0
	jne	SHORT $LN194@Init

; 581  : 				af->SetFlag(AirframeClass::Simplified);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	DWORD PTR $T88[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	mov	ecx, DWORD PTR $T88[ebp]
	mov	edx, DWORD PTR [ecx+88]
	or	edx, 8192				; 00002000H
	mov	eax, DWORD PTR $T88[ebp]
	mov	DWORD PTR [eax+88], edx
$LN194@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 585  : 		af->initialX    = initData->x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+1316], ecx

; 586  : 		af->initialY    = initData->y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _initData$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+1320], edx

; 587  : 		af->initialZ    = initData->z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+1324], eax

; 588  : 		af->initialFuel = (float)initData->fuel;

	mov	ecx, DWORD PTR _initData$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1336], xmm0

; 589  : 		
; 590  : 		//KCK Kludge
; 591  : 		// sfr: dont need this anymore
; 592  : 		//af->x = af->initialX;
; 593  : 		//af->y = af->initialY;
; 594  : 		//af->z = af->initialZ;
; 595  : 		
; 596  : 		// END Kludge
; 597  : 		waypoint        = initData->waypointList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	DWORD PTR [ecx+732], eax

; 598  : 		numWaypoints    = initData->numWaypoints;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [ecx+736], eax

; 599  : 		curWaypoint     = waypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR [ecx+728], eax

; 600  : 		atWaypoint      = waypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _atWaypoint$[ebp], edx

; 601  : 		for (i=0; i<numWaypoints; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN76@Init
$LN75@Init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN76@Init:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+736]
	jge	$LN74@Init

; 602  : 			// Clear tactic for use as flags
; 603  : 			curWaypoint->GetLocation (&wp1X, &wp1Y, &wp1Z);

	lea	eax, DWORD PTR _wp1Z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wp1Y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wp1X$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 604  : 			if (wp1Z > (OTWDriver.GetGroundLevel(wp1X, wp1Y) - 500.0F))

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _wp1Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wp1X$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2352[ebp]
	movss	xmm0, DWORD PTR tv2352[ebp]
	subss	xmm0, DWORD PTR __real@43fa0000
	movss	xmm1, DWORD PTR _wp1Z$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN73@Init

; 605  : 				curWaypoint->SetLocation (wp1X, wp1Y, OTWDriver.GetGroundLevel(wp1X, wp1Y) + wp1Z);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _wp1Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wp1X$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2361[ebp]
	movss	xmm0, DWORD PTR tv2361[ebp]
	addss	xmm0, DWORD PTR _wp1Z$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wp1Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _wp1X$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+728]
	call	?SetLocation@WayPointClass@@QAEXMMM@Z	; WayPointClass::SetLocation
$LN73@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+728]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T60[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 607  : 			curWaypoint = curWaypoint->GetNextWP();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T60[ebp]
	mov	DWORD PTR [edx+728], eax

; 608  : 		}

	jmp	$LN75@Init
$LN74@Init:

; 609  : 		curWaypoint = waypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR [ecx+728], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _st$104[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 611  : 		if (SimLibElapsedTime < st){

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	ecx, DWORD PTR _st$104[ebp]
	jae	SHORT $LN72@Init

; 612  : 		    st = SimLibElapsedTime;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _st$104[ebp], edx
$LN72@Init:

; 613  : 		}
; 614  : 		mFaults->SetStartTime(st); // set base time

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	mov	DWORD PTR $T14[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fault.h

; 190  :        void SetStartTime(VU_TIME time) { mStartTime = time; };

	mov	edx, DWORD PTR $T14[ebp]
	mov	eax, DWORD PTR _st$104[ebp]
	mov	DWORD PTR [edx+544], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 616  : 		for (i=0; i<initData->currentWaypoint; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN71@Init
$LN70@Init:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN71@Init:
	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+148]
	jge	SHORT $LN69@Init

; 617  : 			atWaypoint = curWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	mov	DWORD PTR _atWaypoint$[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T58[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 618  : 			curWaypoint = curWaypoint->GetNextWP();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T58[ebp]
	mov	DWORD PTR [eax+728], ecx

; 619  : 		}

	jmp	SHORT $LN70@Init
$LN69@Init:

; 620  : 		
; 621  : 		// Calculate current heading
; 622  : 		if (curWaypoint){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+728], 0
	je	$LN68@Init

; 623  : 			// Are we waiting for takeoff ?
; 624  : 
; 625  : 			// RV - Biker - Don't initialize AI on carrier
; 626  : 			bool allowGroundInit = true;

	mov	BYTE PTR _allowGroundInit$110[ebp], 1

; 627  : 
; 628  : 			CampEntity ent = ((Flight)(initData->campBase))->GetUnitAirbase();

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [eax+704]
	call	edx
	mov	DWORD PTR _ent$109[ebp], eax

; 629  : 			if (ent && ent->IsTaskForce() && initData->playerSlot == NO_PILOT)

	cmp	DWORD PTR _ent$109[ebp], 0
	je	SHORT $LN67@Init
	mov	eax, DWORD PTR _ent$109[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$109[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN67@Init
	mov	ecx, DWORD PTR _initData$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN67@Init

; 630  : 				allowGroundInit = false;

	mov	BYTE PTR _allowGroundInit$110[ebp], 0
$LN67@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	movzx	edx, BYTE PTR [ecx+24]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 632  :             if (curWaypoint->GetWPAction() == WP_TAKEOFF && allowGroundInit == true){

	cmp	edx, 1
	jne	SHORT $LN66@Init
	movzx	eax, BYTE PTR _allowGroundInit$110[ebp]
	cmp	eax, 1
	jne	SHORT $LN66@Init

; 633  : 				OnGroundInit(initData);

	mov	ecx, DWORD PTR _initData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnGroundInit@AircraftClass@@QAEXPAVSimInitDataClass@@@Z ; AircraftClass::OnGroundInit

; 634  : 			} 
; 635  : 			else 

	jmp	$LN58@Init
$LN66@Init:

; 636  : 			{
; 637  : 				// RV - Biker - AI start at carrier pos with higher alt
; 638  : 				if (ent && ent->IsTaskForce()) 

	cmp	DWORD PTR _ent$109[ebp], 0
	je	$LN64@Init
	mov	edx, DWORD PTR _ent$109[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ent$109[ebp]
	mov	edx, DWORD PTR [eax+264]
	call	edx
	test	eax, eax
	je	$LN64@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	eax, DWORD PTR _ent$109[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR $T28[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 640  : 					af->initialX = ent->XPos() + 1.0f*NM_TO_FT - rand()%12000;

	movss	xmm0, DWORD PTR $T28[ebp]
	addss	xmm0, DWORD PTR __real@45bde1b0
	movss	DWORD PTR tv3127[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 12000				; 00002ee0H
	idiv	ecx
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR tv3127[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1316], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _ent$109[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 641  : 					af->initialY = ent->YPos() + 1.0f*NM_TO_FT - rand()%12000;

	movss	xmm0, DWORD PTR $T8[ebp]
	addss	xmm0, DWORD PTR __real@45bde1b0
	movss	DWORD PTR tv3129[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 12000				; 00002ee0H
	idiv	ecx
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR tv3129[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1320], xmm1

; 642  : 					af->initialZ = min(af->initialZ, -5000 - rand()%2000);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1324]
	movss	DWORD PTR tv3131[ebp], xmm0
	call	_rand
	cdq
	mov	ecx, 2000				; 000007d0H
	idiv	ecx
	mov	eax, -5000				; ffffec78H
	sub	eax, edx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv3131[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN94@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1324]
	movss	DWORD PTR tv440[ebp], xmm0
	jmp	SHORT $LN95@Init
$LN94@Init:
	call	_rand
	cdq
	mov	ecx, 2000				; 000007d0H
	idiv	ecx
	mov	eax, -5000				; ffffec78H
	sub	eax, edx
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv440[ebp], xmm0
$LN95@Init:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR tv440[ebp]
	movss	DWORD PTR [edx+1324], xmm0
$LN64@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T54[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 645  : 			    mFaults->AddTakeOff(waypoint->GetWPArrivalTime());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	mov	DWORD PTR $T12[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h

; 53   :     void	AddTakeOff(VU_TIME thetime) { mFaults.AddMflList(thetime, FaultClass::takeoff, 0); };

	push	0
	push	31					; 0000001fH
	mov	edx, DWORD PTR $T54[ebp]
	push	edx
	mov	ecx, DWORD PTR $T12[ebp]
	add	ecx, 12					; 0000000cH
	call	?AddMflList@FaultClass@@QAEXKW4type_FSubSystem@1@H@Z ; FaultClass::AddMflList
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 647  : 				if (curWaypoint == atWaypoint)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	cmp	ecx, DWORD PTR _atWaypoint$[ebp]
	jne	SHORT $LN63@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+728]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T52[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 648  : 					curWaypoint = curWaypoint->GetNextWP();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T52[ebp]
	mov	DWORD PTR [edx+728], eax
$LN63@Init:

; 649  : 				
; 650  : 				atWaypoint->GetLocation (&wp1X, &wp1Y, &wp1Z);

	lea	ecx, DWORD PTR _wp1Z$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wp1Y$[ebp]
	push	edx
	lea	eax, DWORD PTR _wp1X$[ebp]
	push	eax
	mov	ecx, DWORD PTR _atWaypoint$[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 651  : 				
; 652  : 				if (curWaypoint == NULL){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+728], 0
	jne	SHORT $LN62@Init

; 653  : 					wp1X = initData->x;

	mov	edx, DWORD PTR _initData$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR _wp1X$[ebp], xmm0

; 654  : 					wp1Y = initData->y;

	mov	eax, DWORD PTR _initData$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR _wp1Y$[ebp], xmm0

; 655  : 					curWaypoint = atWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _atWaypoint$[ebp]
	mov	DWORD PTR [ecx+728], edx
$LN62@Init:

; 656  : 				}
; 657  : 				
; 658  : 				if (SimDriver.RunningInstantAction() && !isDigital)	{

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningInstantAction@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningInstantAction
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN61@Init
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	jne	SHORT $LN61@Init

; 659  : 					af->initialPsi = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1332], xmm0

; 660  : 					af->initialMach = 0.7F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [edx+1328], xmm0

; 661  : 				}
; 662  : 				else{

	jmp	$LN58@Init
$LN61@Init:

; 663  : 					curWaypoint->GetLocation (&wp2X, &wp2Y, &wp2Z);

	lea	eax, DWORD PTR _wp2Z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wp2Y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wp2X$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 664  : 					af->initialPsi = (float)atan2 (wp2Y - wp1Y, wp2X - wp1X);

	movss	xmm0, DWORD PTR _wp2X$[ebp]
	subss	xmm0, DWORD PTR _wp1X$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _wp2Y$[ebp]
	subss	xmm0, DWORD PTR _wp1Y$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv2483[ebp]
	fld	DWORD PTR tv2483[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	fstp	DWORD PTR [edx+1332]
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h

; 202  : 	CampaignTime GetWPArrivalTime()					{ return Arrive; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+728]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T50[ebp], edx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	mov	eax, DWORD PTR _atWaypoint$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T19[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 665  : 					dt = curWaypoint->GetWPArrivalTime() - atWaypoint->GetWPDepartureTime();

	mov	edx, DWORD PTR $T50[ebp]
	sub	edx, DWORD PTR $T19[ebp]
	mov	DWORD PTR _dt$[ebp], edx

; 666  : 					
; 667  : 					if (dt > 10 * SEC_TO_MSEC){

	cmp	DWORD PTR _dt$[ebp], 10000		; 00002710H
	jle	$LN59@Init

; 669  : 							(dt / SEC_TO_MSEC);

	movss	xmm0, DWORD PTR _wp2Y$[ebp]
	subss	xmm0, DWORD PTR _wp1Y$[ebp]
	movss	xmm1, DWORD PTR _wp2Y$[ebp]
	subss	xmm1, DWORD PTR _wp1Y$[ebp]
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR _wp2X$[ebp]
	subss	xmm0, DWORD PTR _wp1X$[ebp]
	movss	xmm2, DWORD PTR _wp2X$[ebp]
	subss	xmm2, DWORD PTR _wp1X$[ebp]
	mulss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR $T2[ebp], xmm2
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR $T2[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR $T2[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	movss	xmm0, DWORD PTR $T2[ebp]
	movss	DWORD PTR $T48[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 669  : 							(dt / SEC_TO_MSEC);

	mov	eax, DWORD PTR _dt$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR $T48[ebp]
	divss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	DWORD PTR [eax+1328], xmm1

; 670  : 						af->initialMach = max (af->initialMach, 200.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1328]
	comiss	xmm0, DWORD PTR __real@43480000
	jbe	SHORT $LN96@Init
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1328]
	movss	DWORD PTR tv553[ebp], xmm0
	jmp	SHORT $LN97@Init
$LN96@Init:
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR tv553[ebp], xmm0
$LN97@Init:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR tv553[ebp]
	movss	DWORD PTR [eax+1328], xmm0

; 671  : 					}
; 672  : 					else{

	jmp	SHORT $LN58@Init
$LN59@Init:

; 673  : 						af->initialMach = 0.7F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [edx+1328], xmm0
$LN58@Init:

; 674  : 					}
; 675  : 				}
; 676  : 				
; 677  : 			}
; 678  : 		}
; 679  : 		else {

	jmp	SHORT $LN57@Init
$LN68@Init:

; 680  : 			af->initialPsi = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1332], xmm0

; 681  : 			af->initialMach = 0.7F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [eax+1328], xmm0
$LN57@Init:

; 682  : 		}
; 683  : 		
; 684  : 		// KCK Hack: To make EOM work ok...
; 685  : 		// REMOVE BEFORE FLIGHT
; 686  : 		if (af->initialMach < 0.01F){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR [edx+1328]
	jbe	SHORT $LN56@Init

; 687  : 			af->initialMach = 0.01F;					// Minimal speed to catch problems -

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [ecx+1328], xmm0
$LN56@Init:

; 688  : 		}
; 689  : 		if (af->initialMach > 2.0F && af->initialMach < 10.0F){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1328]
	comiss	xmm0, DWORD PTR __real@40000000
	jbe	SHORT $LN55@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR [edx+1328]
	jbe	SHORT $LN55@Init

; 690  : 			af->initialMach = 2.0F;					// max mach speed

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [ecx+1328], xmm0
$LN55@Init:

; 691  : 		}
; 692  : 		//if (af->initialMach > 1000.0F)
; 693  : 		//af->initialMach = 1000.F;					// max fps
; 694  : 		
; 695  : 
; 696  : 		afIdx = SimACDefTable[classPtr->vehicleDataIndex].airframeIdx;

	mov	edx, DWORD PTR _classPtr$[ebp]
	movsx	eax, WORD PTR [edx+74]
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _afIdx$[ebp], edx

; 697  : 		// FRB - Garbage check
; 698  : 		if (afIdx > NumACDefEntries)

	movsx	eax, WORD PTR ?NumACDefEntries@@3FA	; NumACDefEntries
	cmp	DWORD PTR _afIdx$[ebp], eax
	jle	SHORT $LN54@Init

; 699  : 			afIdx = 1;

	mov	DWORD PTR _afIdx$[ebp], 1
$LN54@Init:

; 700  : 		af->InitData(afIdx);

	mov	ecx, DWORD PTR _afIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?InitData@AirframeClass@@QAEXH@Z	; AirframeClass::InitData

; 701  : 
; 702  : 		//TJL 12/20/03 This will allow for all F-16's to set the isF16 flag
; 703  : 		// without having to have the same specific type like the code above
; 704  : 		if (af->auxaeroData->typeAC == 1 || af->auxaeroData->typeAC == 2){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 1
	je	SHORT $LN52@Init
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+3880], 2
	jne	SHORT $LN53@Init
$LN52@Init:

; 705  : 		    acFlags |= isF16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], ecx
$LN53@Init:

; 706  : 		}
; 707  : 		//TJL 01/11/04 Set Two Engines
; 708  : 		if (af->auxaeroData->nEngines == 2){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+344], 2
	jne	SHORT $LN51@Init

; 709  : 			acFlags |= hasTwoEngines;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], ecx
$LN51@Init:

; 710  : 		}
; 711  : 
; 712  : 
; 713  : 		// Weapons Stuff
; 714  : 		Sms = new SMSClass (this, initData->weapon, initData->weapons);

	push	280					; 00000118H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T86[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T86[ebp], 0
	je	SHORT $LN98@Init
	mov	eax, DWORD PTR _initData$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, DWORD PTR _initData$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T86[ebp]
	call	??0SMSClass@@QAE@PAVSimVehicleClass@@PAFPAE@Z ; SMSClass::SMSClass
	mov	DWORD PTR tv618[ebp], eax
	jmp	SHORT $LN99@Init
$LN98@Init:
	mov	DWORD PTR tv618[ebp], 0
$LN99@Init:
	mov	eax, DWORD PTR tv618[ebp]
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T24[ebp]
	mov	DWORD PTR [ecx+940], edx

; 715  : 		FCC = new FireControlComputer (this, Sms->NumHardpoints());

	push	524					; 0000020cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T94[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T94[ebp], 0
	je	SHORT $LN100@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T46[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 715  : 		FCC = new FireControlComputer (this, Sms->NumHardpoints());

	mov	eax, DWORD PTR $T46[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T94[ebp]
	call	??0FireControlComputer@@QAE@PAVSimVehicleClass@@H@Z ; FireControlComputer::FireControlComputer
	mov	DWORD PTR tv639[ebp], eax
	jmp	SHORT $LN101@Init
$LN100@Init:
	mov	DWORD PTR tv639[ebp], 0
$LN101@Init:
	mov	edx, DWORD PTR tv639[ebp]
	mov	DWORD PTR $T18[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T18[ebp]
	mov	DWORD PTR [eax+936], ecx

; 716  : 		//FCC->Sms = Sms;
; 717  : 		FCC->SetSms(Sms); // MLR 4/10/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+936]
	call	?SetSms@FireControlComputer@@QAEXPAVSMSClass@@@Z ; FireControlComputer::SetSms
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T44[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 719  : 		if (Sms->NumHardpoints() > 0){

	cmp	DWORD PTR $T44[ebp], 0
	jle	$LN252@Init

; 720  : 			Guns = Sms->hardPoint[0]->GetGun();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax+176]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+944], eax

; 721  : 			if (Guns){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+944], 0
	je	SHORT $LN252@Init

; 722  : 				// MLR 12/13/2003 - Set the guns trail ID
; 723  : 				Guns->SetTrailID(af->auxaeroData->gunTrailID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+328]
	mov	DWORD PTR $T42[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+944]
	mov	DWORD PTR $T22[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\guns.h

; 84   : 	void SetTrailID(int ID) {trailID = ID;} // MLR 12/13/2003 - DrawableTrailID, has to be set before Exec() is called;

	mov	eax, DWORD PTR $T22[ebp]
	mov	ecx, DWORD PTR $T42[ebp]
	mov	DWORD PTR [eax+788], ecx
$LN252@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 733  : 		if ( !OnGround() && af->initialZ > OTWDriver.GetGroundLevel(af->x, af->y) - 500.0f ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	$LN48@Init
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+932]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1112]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2585[ebp]
	movss	xmm0, DWORD PTR tv2585[ebp]
	subss	xmm0, DWORD PTR __real@43fa0000
	movss	xmm1, DWORD PTR [esi+1324]
	comiss	xmm1, xmm0
	jbe	SHORT $LN48@Init

; 734  : 			af->initialZ = OTWDriver.GetGroundLevel( af->x, af->y ) - 500.0F;

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2596[ebp]
	movss	xmm0, DWORD PTR tv2596[ebp]
	subss	xmm0, DWORD PTR __real@43fa0000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	DWORD PTR [ecx+1324], xmm0

; 735  : 			af->z = af->initialZ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [eax+1324]
	mov	DWORD PTR [edx+1116], eax
$LN48@Init:

; 736  : 		}
; 737  : 		// Get the controls
; 738  : 		af->Init(afIdx);

	mov	ecx, DWORD PTR _afIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?Init@AirframeClass@@QAEXH@Z		; AirframeClass::Init

; 739  : 
; 740  : 
; 741  : 		if (af->auxaeroData->hasSwingWing) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN47@Init

; 742  : 		    acFlags |= hasSwing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], ecx
$LN47@Init:

; 743  : 		}
; 744  : 		if (af->auxaeroData->isComplex) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN46@Init

; 745  : 		    acFlags |= isComplex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], ecx

; 746  : 		    MakeComplex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeComplex@SimMoverClass@@IAEXXZ	; SimMoverClass::MakeComplex
$LN46@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 5
	jle	SHORT $LN254@Init
	mov	ecx, 5
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 1
	mov	ecx, 5
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN254@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	ecx, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T20[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 751  : 		if ( gACMIRec.IsRecording() ){

	cmp	DWORD PTR $T20[ebp], 0
	je	$LN45@Init

; 752  : 			acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv2618[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2618[ebp]
	mov	eax, DWORD PTR tv2618[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2622[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2622[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR $T100[ebp], dx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 753  : 			acmiSwitch.data.type = Type();

	movzx	eax, WORD PTR $T100[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T9[ebp], edx
	mov	DWORD PTR $T9[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 80   : 		return (unsigned long) value_; 

	mov	ecx, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR $T39[ebp], ecx

; 81   : 	}
; 82   : 
; 83   : 	// note: these are private to prevent (mis)use
; 84   : private:
; 85   : 	int operator == (unsigned long &rhs) const ;
; 86   : 	int operator != (unsigned long &rhs) const ;
; 87   : 	int operator > (unsigned long &rhs) const ;
; 88   : 	int operator >= (unsigned long &rhs) const ;
; 89   : 	int operator < (unsigned long &rhs) const ;
; 90   : 	int operator <= (unsigned long &rhs) const ;
; 91   : 
; 92   : 	// DATA
; 93   : public:
; 94   : 	unsigned long 	value_;
; 95   : };
; 96   : 
; 97   : class VU_ID {
; 98   : public:
; 99   : 	//sfr: vu change
; 100  : 	VU_ID() : num_(0), creator_(0){}
; 101  : 	VU_ID(VU_SESSION_ID sessionpart, VU_ID_NUMBER idpart) : num_(idpart), creator_(sessionpart){}
; 102  : 
; 103  : 	// basic operator overloading
; 104  : 	bool operator == (const VU_ID &rhs) const { 
; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 
; 110  : 	}
; 111  : 	bool operator != (const VU_ID &rhs) const { 
; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 
; 117  : 	}
; 118  : 	bool operator > (const VU_ID &rhs) const {
; 119  : 		if (creator_ > rhs.creator_){
; 120  : 			return true;
; 121  : 		}
; 122  : 		if (creator_ == rhs.creator_)	{
; 123  : 			if (num_ > rhs.num_){
; 124  : 				return true;
; 125  : 			}
; 126  : 		}
; 127  : 		return false;
; 128  : 	}
; 129  : 	bool operator >= (const VU_ID &rhs) const {
; 130  : 		if (creator_ > rhs.creator_){
; 131  : 			return true;
; 132  : 		}
; 133  : 		if (creator_ == rhs.creator_){
; 134  : 			if (num_ >= rhs.num_){
; 135  : 				return true;
; 136  : 			}
; 137  : 		}
; 138  : 		return false;
; 139  : 	}
; 140  : 	bool operator < (const VU_ID &rhs) const {
; 141  : 		if (creator_ < rhs.creator_){
; 142  : 			return true;
; 143  : 		}
; 144  : 		if (creator_ == rhs.creator_){
; 145  : 			if (num_ < rhs.num_){
; 146  : 				return true;
; 147  : 			}
; 148  : 		}
; 149  : 		return false;
; 150  : 	}
; 151  : 	bool operator <= (const VU_ID &rhs) const {
; 152  : 		if (creator_ < rhs.creator_){
; 153  : 			return true;
; 154  : 		}
; 155  : 		if (creator_ == rhs.creator_){
; 156  : 			if (num_ <= rhs.num_){
; 157  : 				return true;
; 158  : 			}
; 159  : 		}
; 160  : 		return false;
; 161  : 	}
; 162  : 	operator VU_KEY() const { 
; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	movzx	edx, WORD PTR $T9[ebp]
	movzx	eax, WORD PTR $T39[ebp]
	shl	eax, 16					; 00000010H
	or	eax, edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 754  : 			acmiSwitch.data.uniqueID = Id();

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, eax

; 755  : 			acmiSwitch.data.switchNum = COMP_CANOPY;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, 5

; 756  : 			acmiSwitch.data.switchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, 1

; 757  : 			acmiSwitch.data.prevSwitchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, 1

; 758  : 			gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN45@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 336  : 	int            IsComplex (void) {return ((acFlags & isComplex) ? TRUE : FALSE);}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+964]
	and	edx, 4
	je	SHORT $LN269@Init
	mov	DWORD PTR tv1819[ebp], 1
	jmp	SHORT $LN270@Init
$LN269@Init:
	mov	DWORD PTR tv1819[ebp], 0
$LN270@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 762  : 		if (IsComplex()){

	cmp	DWORD PTR tv1819[ebp], 0
	je	$LN39@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 10			; 0000000aH
	jle	SHORT $LN271@Init
	mov	ecx, 10					; 0000000aH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 1
	mov	ecx, 10					; 0000000aH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN271@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	ecx, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T15[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 764  : 			if ( gACMIRec.IsRecording() ){

	cmp	DWORD PTR $T15[ebp], 0
	je	$LN43@Init

; 765  : 				acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv2642[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2642[ebp]
	mov	eax, DWORD PTR tv2642[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2646[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2646[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR $T98[ebp], dx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 766  : 				acmiSwitch.data.type = Type();

	movzx	eax, WORD PTR $T98[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T7[ebp], edx
	mov	DWORD PTR $T7[ebp+4], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 80   : 		return (unsigned long) value_; 

	mov	ecx, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR $T37[ebp], ecx

; 81   : 	}
; 82   : 
; 83   : 	// note: these are private to prevent (mis)use
; 84   : private:
; 85   : 	int operator == (unsigned long &rhs) const ;
; 86   : 	int operator != (unsigned long &rhs) const ;
; 87   : 	int operator > (unsigned long &rhs) const ;
; 88   : 	int operator >= (unsigned long &rhs) const ;
; 89   : 	int operator < (unsigned long &rhs) const ;
; 90   : 	int operator <= (unsigned long &rhs) const ;
; 91   : 
; 92   : 	// DATA
; 93   : public:
; 94   : 	unsigned long 	value_;
; 95   : };
; 96   : 
; 97   : class VU_ID {
; 98   : public:
; 99   : 	//sfr: vu change
; 100  : 	VU_ID() : num_(0), creator_(0){}
; 101  : 	VU_ID(VU_SESSION_ID sessionpart, VU_ID_NUMBER idpart) : num_(idpart), creator_(sessionpart){}
; 102  : 
; 103  : 	// basic operator overloading
; 104  : 	bool operator == (const VU_ID &rhs) const { 
; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 
; 110  : 	}
; 111  : 	bool operator != (const VU_ID &rhs) const { 
; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 
; 117  : 	}
; 118  : 	bool operator > (const VU_ID &rhs) const {
; 119  : 		if (creator_ > rhs.creator_){
; 120  : 			return true;
; 121  : 		}
; 122  : 		if (creator_ == rhs.creator_)	{
; 123  : 			if (num_ > rhs.num_){
; 124  : 				return true;
; 125  : 			}
; 126  : 		}
; 127  : 		return false;
; 128  : 	}
; 129  : 	bool operator >= (const VU_ID &rhs) const {
; 130  : 		if (creator_ > rhs.creator_){
; 131  : 			return true;
; 132  : 		}
; 133  : 		if (creator_ == rhs.creator_){
; 134  : 			if (num_ >= rhs.num_){
; 135  : 				return true;
; 136  : 			}
; 137  : 		}
; 138  : 		return false;
; 139  : 	}
; 140  : 	bool operator < (const VU_ID &rhs) const {
; 141  : 		if (creator_ < rhs.creator_){
; 142  : 			return true;
; 143  : 		}
; 144  : 		if (creator_ == rhs.creator_){
; 145  : 			if (num_ < rhs.num_){
; 146  : 				return true;
; 147  : 			}
; 148  : 		}
; 149  : 		return false;
; 150  : 	}
; 151  : 	bool operator <= (const VU_ID &rhs) const {
; 152  : 		if (creator_ < rhs.creator_){
; 153  : 			return true;
; 154  : 		}
; 155  : 		if (creator_ == rhs.creator_){
; 156  : 			if (num_ <= rhs.num_){
; 157  : 				return true;
; 158  : 			}
; 159  : 		}
; 160  : 		return false;
; 161  : 	}
; 162  : 	operator VU_KEY() const { 
; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	movzx	edx, WORD PTR $T7[ebp]
	movzx	eax, WORD PTR $T37[ebp]
	shl	eax, 16					; 00000010H
	or	eax, edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 767  : 				acmiSwitch.data.uniqueID = Id();

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, eax

; 768  : 				acmiSwitch.data.switchNum = COMP_EXH_NOZZLE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, 10 ; 0000000aH

; 769  : 				acmiSwitch.data.switchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, 1

; 770  : 				acmiSwitch.data.prevSwitchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, 1

; 771  : 				gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN43@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 235  : 	int  HasHarm (void) {return (flags & HTSOnBoard ? TRUE : FALSE);};

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR [edx+52]
	and	eax, 128				; 00000080H
	je	SHORT $LN286@Init
	mov	DWORD PTR tv1873[ebp], 1
	jmp	SHORT $LN287@Init
$LN286@Init:
	mov	DWORD PTR tv1873[ebp], 0
$LN287@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 773  : 			if (Sms->HasHarm()){

	cmp	DWORD PTR tv1873[ebp], 0
	je	$LN41@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+604], 12			; 0000000cH
	jle	SHORT $LN288@Init
	mov	edx, 12					; 0000000cH
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	DWORD PTR [edx+ecx], 1
	mov	edx, 12					; 0000000cH
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR [edx+ecx], 1
$LN288@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	edx, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T13[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 779  : 				if ( gACMIRec.IsRecording() ){

	cmp	DWORD PTR $T13[ebp], 0
	je	$LN41@Init

; 780  : 					acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv2698[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv2698[ebp]
	mov	ecx, DWORD PTR tv2698[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv2702[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2702[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR $T102[ebp], ax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 781  : 					acmiSwitch.data.type = Type();

	movzx	ecx, WORD PTR $T102[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR $T5[ebp+4], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 80   : 		return (unsigned long) value_; 

	mov	edx, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR $T35[ebp], edx

; 81   : 	}
; 82   : 
; 83   : 	// note: these are private to prevent (mis)use
; 84   : private:
; 85   : 	int operator == (unsigned long &rhs) const ;
; 86   : 	int operator != (unsigned long &rhs) const ;
; 87   : 	int operator > (unsigned long &rhs) const ;
; 88   : 	int operator >= (unsigned long &rhs) const ;
; 89   : 	int operator < (unsigned long &rhs) const ;
; 90   : 	int operator <= (unsigned long &rhs) const ;
; 91   : 
; 92   : 	// DATA
; 93   : public:
; 94   : 	unsigned long 	value_;
; 95   : };
; 96   : 
; 97   : class VU_ID {
; 98   : public:
; 99   : 	//sfr: vu change
; 100  : 	VU_ID() : num_(0), creator_(0){}
; 101  : 	VU_ID(VU_SESSION_ID sessionpart, VU_ID_NUMBER idpart) : num_(idpart), creator_(sessionpart){}
; 102  : 
; 103  : 	// basic operator overloading
; 104  : 	bool operator == (const VU_ID &rhs) const { 
; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 
; 110  : 	}
; 111  : 	bool operator != (const VU_ID &rhs) const { 
; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 
; 117  : 	}
; 118  : 	bool operator > (const VU_ID &rhs) const {
; 119  : 		if (creator_ > rhs.creator_){
; 120  : 			return true;
; 121  : 		}
; 122  : 		if (creator_ == rhs.creator_)	{
; 123  : 			if (num_ > rhs.num_){
; 124  : 				return true;
; 125  : 			}
; 126  : 		}
; 127  : 		return false;
; 128  : 	}
; 129  : 	bool operator >= (const VU_ID &rhs) const {
; 130  : 		if (creator_ > rhs.creator_){
; 131  : 			return true;
; 132  : 		}
; 133  : 		if (creator_ == rhs.creator_){
; 134  : 			if (num_ >= rhs.num_){
; 135  : 				return true;
; 136  : 			}
; 137  : 		}
; 138  : 		return false;
; 139  : 	}
; 140  : 	bool operator < (const VU_ID &rhs) const {
; 141  : 		if (creator_ < rhs.creator_){
; 142  : 			return true;
; 143  : 		}
; 144  : 		if (creator_ == rhs.creator_){
; 145  : 			if (num_ < rhs.num_){
; 146  : 				return true;
; 147  : 			}
; 148  : 		}
; 149  : 		return false;
; 150  : 	}
; 151  : 	bool operator <= (const VU_ID &rhs) const {
; 152  : 		if (creator_ < rhs.creator_){
; 153  : 			return true;
; 154  : 		}
; 155  : 		if (creator_ == rhs.creator_){
; 156  : 			if (num_ <= rhs.num_){
; 157  : 				return true;
; 158  : 			}
; 159  : 		}
; 160  : 		return false;
; 161  : 	}
; 162  : 	operator VU_KEY() const { 
; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	movzx	eax, WORD PTR $T5[ebp]
	movzx	ecx, WORD PTR $T35[ebp]
	shl	ecx, 16					; 00000010H
	or	ecx, eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 782  : 					acmiSwitch.data.uniqueID = Id();

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, ecx

; 783  : 					acmiSwitch.data.switchNum = COMP_HTS_POD;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, 12 ; 0000000cH

; 784  : 					acmiSwitch.data.switchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, 1

; 785  : 					acmiSwitch.data.prevSwitchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, 1

; 786  : 					gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN41@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 236  : 	int  HasLGB (void) {return (flags & LGBOnBoard ? TRUE : FALSE);};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 64					; 00000040H
	je	SHORT $LN303@Init
	mov	DWORD PTR tv1895[ebp], 1
	jmp	SHORT $LN304@Init
$LN303@Init:
	mov	DWORD PTR tv1895[ebp], 0
$LN304@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 790  : 			if (Sms->HasLGB()){

	cmp	DWORD PTR tv1895[ebp], 0
	je	$LN39@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+604], 11			; 0000000bH
	jle	SHORT $LN305@Init
	mov	eax, 11					; 0000000bH
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+592]
	mov	DWORD PTR [eax+edx], 1
	mov	eax, 11					; 0000000bH
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+596]
	mov	DWORD PTR [eax+edx], 1
$LN305@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h

; 320  : 		return _recording;

	mov	eax, DWORD PTR ?gACMIRec@@3VACMIRecorder@@A+8
	mov	DWORD PTR $T17[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 795  : 				if ( gACMIRec.IsRecording() ){

	cmp	DWORD PTR $T17[ebp], 0
	je	$LN39@Init

; 796  : 					acmiSwitch.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv2722[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv2722[ebp]
	mov	edx, DWORD PTR tv2722[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv2726[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2726[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+1, xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 154  : 	ushort Type() const       { return share_.entityType_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+4]
	mov	WORD PTR $T96[ebp], cx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 797  : 					acmiSwitch.data.type = Type();

	movzx	edx, WORD PTR $T96[ebp]
	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+5, edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR $T3[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h

; 80   : 		return (unsigned long) value_; 

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR $T33[ebp], eax

; 81   : 	}
; 82   : 
; 83   : 	// note: these are private to prevent (mis)use
; 84   : private:
; 85   : 	int operator == (unsigned long &rhs) const ;
; 86   : 	int operator != (unsigned long &rhs) const ;
; 87   : 	int operator > (unsigned long &rhs) const ;
; 88   : 	int operator >= (unsigned long &rhs) const ;
; 89   : 	int operator < (unsigned long &rhs) const ;
; 90   : 	int operator <= (unsigned long &rhs) const ;
; 91   : 
; 92   : 	// DATA
; 93   : public:
; 94   : 	unsigned long 	value_;
; 95   : };
; 96   : 
; 97   : class VU_ID {
; 98   : public:
; 99   : 	//sfr: vu change
; 100  : 	VU_ID() : num_(0), creator_(0){}
; 101  : 	VU_ID(VU_SESSION_ID sessionpart, VU_ID_NUMBER idpart) : num_(idpart), creator_(sessionpart){}
; 102  : 
; 103  : 	// basic operator overloading
; 104  : 	bool operator == (const VU_ID &rhs) const { 
; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 
; 110  : 	}
; 111  : 	bool operator != (const VU_ID &rhs) const { 
; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 
; 117  : 	}
; 118  : 	bool operator > (const VU_ID &rhs) const {
; 119  : 		if (creator_ > rhs.creator_){
; 120  : 			return true;
; 121  : 		}
; 122  : 		if (creator_ == rhs.creator_)	{
; 123  : 			if (num_ > rhs.num_){
; 124  : 				return true;
; 125  : 			}
; 126  : 		}
; 127  : 		return false;
; 128  : 	}
; 129  : 	bool operator >= (const VU_ID &rhs) const {
; 130  : 		if (creator_ > rhs.creator_){
; 131  : 			return true;
; 132  : 		}
; 133  : 		if (creator_ == rhs.creator_){
; 134  : 			if (num_ >= rhs.num_){
; 135  : 				return true;
; 136  : 			}
; 137  : 		}
; 138  : 		return false;
; 139  : 	}
; 140  : 	bool operator < (const VU_ID &rhs) const {
; 141  : 		if (creator_ < rhs.creator_){
; 142  : 			return true;
; 143  : 		}
; 144  : 		if (creator_ == rhs.creator_){
; 145  : 			if (num_ < rhs.num_){
; 146  : 				return true;
; 147  : 			}
; 148  : 		}
; 149  : 		return false;
; 150  : 	}
; 151  : 	bool operator <= (const VU_ID &rhs) const {
; 152  : 		if (creator_ < rhs.creator_){
; 153  : 			return true;
; 154  : 		}
; 155  : 		if (creator_ == rhs.creator_){
; 156  : 			if (num_ <= rhs.num_){
; 157  : 				return true;
; 158  : 			}
; 159  : 		}
; 160  : 		return false;
; 161  : 	}
; 162  : 	operator VU_KEY() const { 
; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	movzx	ecx, WORD PTR $T3[ebp]
	movzx	edx, WORD PTR $T33[ebp]
	shl	edx, 16					; 00000010H
	or	edx, ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 798  : 					acmiSwitch.data.uniqueID = Id();

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+9, edx

; 799  : 					acmiSwitch.data.switchNum = COMP_TIRN_POD;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+13, 11 ; 0000000bH

; 800  : 					acmiSwitch.data.switchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+17, 1

; 801  : 					acmiSwitch.data.prevSwitchVal = TRUE;

	mov	DWORD PTR ?acmiSwitch@@3UACMISwitchRecord@@A+21, 1

; 802  : 					gACMIRec.SwitchRecord( &acmiSwitch );

	push	OFFSET ?acmiSwitch@@3UACMISwitchRecord@@A ; acmiSwitch
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?SwitchRecord@ACMIRecorder@@QAEXPAUACMISwitchRecord@@@Z ; ACMIRecorder::SwitchRecord
$LN39@Init:

; 803  : 				}
; 804  : 			}
; 805  : 		}
; 806  : 		if (Guns) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+944], 0
	je	$LN38@Init

; 807  : 		    float x, y, z;
; 808  : 		    af->GetGunLocation(&x, &y, &z);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T101[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 708  : 	void GetGunLocation(float *x, float *y, float *z) { *x = auxaeroData->gunLocation.x, *y = auxaeroData->gunLocation.y;*z = auxaeroData->gunLocation.z; };

	mov	eax, DWORD PTR $T101[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+316]
	movss	DWORD PTR _x$68[ebp], xmm0
	mov	edx, DWORD PTR $T101[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+320]
	movss	DWORD PTR _y$70[ebp], xmm0
	mov	ecx, DWORD PTR $T101[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+324]
	movss	DWORD PTR _z$10[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 809  : 		    Guns->SetPosition (x, y, z, af->auxaeroData->gunElevation * DTR, af->auxaeroData->gunAzimuth * DTR);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+336]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+332]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _z$10[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$70[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$68[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+944]
	call	?SetPosition@GunClass@@QAEXMMMMM@Z	; GunClass::SetPosition
$LN38@Init:

; 810  : 		}
; 811  : 		// Add Sensor
; 812  : 		// Quick, count the sensors
; 813  : 		{
; 814  : 			int sensorType, sensorIdx, hasHarm, hasLGB, needsRadar;
; 815  : 			
; 816  : 			numSensors = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+652], 0

; 817  : 			needsRadar = TRUE;

	mov	DWORD PTR _needsRadar$106[ebp], 1

; 818  : 			for (i = 0; i<5; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN37@Init
$LN36@Init:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN37@Init:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN35@Init

; 819  : 				if (SimACDefTable[classPtr->vehicleDataIndex].sensorType[i] > 0){

	mov	eax, DWORD PTR _classPtr$[ebp]
	movsx	ecx, WORD PTR [eax+74]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4+12], 0
	jle	SHORT $LN33@Init

; 820  : 					// MLR TODO, IRST is 0?
; 821  : 					numSensors++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+652]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+652], ecx

; 822  : 					//KLudge until new class table for bombers
; 823  : 					if (SimACDefTable[classPtr->vehicleDataIndex].sensorType[i] == SensorClass::Radar){

	mov	eax, DWORD PTR _classPtr$[ebp]
	movsx	ecx, WORD PTR [eax+74]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4+12], 1
	jne	SHORT $LN33@Init

; 824  : 						needsRadar = FALSE;

	mov	DWORD PTR _needsRadar$106[ebp], 0
$LN33@Init:

; 825  : 					}
; 826  : 				}
; 827  : 			}

	jmp	SHORT $LN36@Init
$LN35@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 235  : 	int  HasHarm (void) {return (flags & HTSOnBoard ? TRUE : FALSE);};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	mov	edx, DWORD PTR [ecx+52]
	and	edx, 128				; 00000080H
	je	SHORT $LN322@Init
	mov	DWORD PTR tv1922[ebp], 1
	jmp	SHORT $LN323@Init
$LN322@Init:
	mov	DWORD PTR tv1922[ebp], 0
$LN323@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 830  : 			hasHarm = Sms->HasHarm();

	mov	eax, DWORD PTR tv1922[ebp]
	mov	DWORD PTR _hasHarm$97[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 236  : 	int  HasLGB (void) {return (flags & LGBOnBoard ? TRUE : FALSE);};

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR [edx+52]
	and	eax, 64					; 00000040H
	je	SHORT $LN326@Init
	mov	DWORD PTR tv1929[ebp], 1
	jmp	SHORT $LN327@Init
$LN326@Init:
	mov	DWORD PTR tv1929[ebp], 0
$LN327@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 833  : 			hasLGB = Sms->HasLGB();

	mov	ecx, DWORD PTR tv1929[ebp]
	mov	DWORD PTR _hasLGB$95[ebp], ecx

; 834  : 			numSensors += hasHarm + hasLGB;

	mov	edx, DWORD PTR _hasHarm$97[ebp]
	add	edx, DWORD PTR _hasLGB$95[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+652]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+652], edx

; 835  : 			if (needsRadar){

	cmp	DWORD PTR _needsRadar$106[ebp], 0
	je	SHORT $LN32@Init

; 836  : 				numSensors ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+652]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+652], eax
$LN32@Init:

; 837  : 			}
; 838  : 			
; 839  : 			sensorArray = new SensorClass*[numSensors];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+652]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T66[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T66[ebp]
	mov	DWORD PTR [eax+648], ecx

; 840  : 			for (i = 0; i<numSensors -(hasHarm + hasLGB + needsRadar); i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN31@Init
$LN30@Init:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN31@Init:
	mov	eax, DWORD PTR _hasHarm$97[ebp]
	add	eax, DWORD PTR _hasLGB$95[ebp]
	add	eax, DWORD PTR _needsRadar$106[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+652]
	sub	edx, eax
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN29@Init

; 841  : 				sensorType = SimACDefTable[classPtr->vehicleDataIndex].sensorType[i];

	mov	eax, DWORD PTR _classPtr$[ebp]
	movsx	ecx, WORD PTR [eax+74]
	imul	ecx, 52					; 00000034H
	add	ecx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	mov	DWORD PTR _sensorType$64[ebp], eax

; 842  : 				sensorIdx	= SimACDefTable[classPtr->vehicleDataIndex].sensorIdx[i];

	mov	ecx, DWORD PTR _classPtr$[ebp]
	movsx	edx, WORD PTR [ecx+74]
	imul	edx, 52					; 00000034H
	add	edx, DWORD PTR ?SimACDefTable@@3PAUSimACDefType@@A ; SimACDefTable
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+32]
	mov	DWORD PTR _sensorIdx$99[ebp], ecx

; 843  : 				
; 844  : 				switch (sensorType)

	mov	edx, DWORD PTR _sensorType$64[ebp]
	mov	DWORD PTR tv1022[ebp], edx
	cmp	DWORD PTR tv1022[ebp], 3
	ja	$LN20@Init
	mov	eax, DWORD PTR tv1022[ebp]
	jmp	DWORD PTR $LN392@Init[eax*4]
$LN26@Init:

; 845  : 				{
; 846  : 				case SensorClass::Radar:
; 847  : 					if (RadarDataTable[GetRadarType()].LookDownPenalty < 0.0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	imul	eax, 58					; 0000003aH
	mov	ecx, DWORD PTR ?RadarDataTable@@3PAURadarDataType@@A ; RadarDataTable
	cvtss2sd xmm0, DWORD PTR [ecx+eax+36]
	movsd	xmm1, QWORD PTR __real@0000000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN25@Init

; 848  : 						sensorArray[i] = new RadarAGOnlyClass (GetRadarType(), this);

	push	144					; 00000090H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T82[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T82[ebp], 0
	je	SHORT $LN102@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	push	eax
	mov	ecx, DWORD PTR $T82[ebp]
	call	??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z ; RadarAGOnlyClass::RadarAGOnlyClass
	mov	DWORD PTR tv1069[ebp], eax
	jmp	SHORT $LN103@Init
$LN102@Init:
	mov	DWORD PTR tv1069[ebp], 0
$LN103@Init:
	mov	ecx, DWORD PTR tv1069[ebp]
	mov	DWORD PTR $T62[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR $T62[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 849  : 					else

	jmp	SHORT $LN24@Init
$LN25@Init:

; 850  : 						sensorArray[i] = new RadarDigiClass (GetRadarType(), this);

	push	144					; 00000090H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T93[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T93[ebp], 0
	je	SHORT $LN104@Init
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	push	eax
	mov	ecx, DWORD PTR $T93[ebp]
	call	??0RadarDigiClass@@QAE@HPAVSimMoverClass@@@Z ; RadarDigiClass::RadarDigiClass
	mov	DWORD PTR tv1101[ebp], eax
	jmp	SHORT $LN105@Init
$LN104@Init:
	mov	DWORD PTR tv1101[ebp], 0
$LN105@Init:
	mov	ecx, DWORD PTR tv1101[ebp]
	mov	DWORD PTR $T61[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR $T61[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$LN24@Init:

; 851  : 					break;

	jmp	$LN27@Init
$LN23@Init:

; 852  : 					
; 853  : 				case SensorClass::RWR:
; 854  : 					sensorArray[i] = new VehRwrClass (sensorIdx, this);

	push	600					; 00000258H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T90[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T90[ebp], 0
	je	SHORT $LN106@Init
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sensorIdx$99[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T90[ebp]
	call	??0VehRwrClass@@QAE@HPAVSimMoverClass@@@Z ; VehRwrClass::VehRwrClass
	mov	DWORD PTR tv1125[ebp], eax
	jmp	SHORT $LN107@Init
$LN106@Init:
	mov	DWORD PTR tv1125[ebp], 0
$LN107@Init:
	mov	edx, DWORD PTR tv1125[ebp]
	mov	DWORD PTR $T59[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR $T59[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 855  : 					break;

	jmp	$LN27@Init
$LN22@Init:

; 856  : 					
; 857  : 				case SensorClass::IRST:
; 858  : 					sensorArray[i] = new IrstClass (sensorIdx, this);

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T89[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T89[ebp], 0
	je	SHORT $LN108@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sensorIdx$99[ebp]
	push	edx
	mov	ecx, DWORD PTR $T89[ebp]
	call	??0IrstClass@@QAE@HPAVSimMoverClass@@@Z	; IrstClass::IrstClass
	mov	DWORD PTR tv1149[ebp], eax
	jmp	SHORT $LN109@Init
$LN108@Init:
	mov	DWORD PTR tv1149[ebp], 0
$LN109@Init:
	mov	eax, DWORD PTR tv1149[ebp]
	mov	DWORD PTR $T57[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR $T57[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 859  : 					break;

	jmp	SHORT $LN27@Init
$LN21@Init:

; 860  : 					
; 861  : 				case SensorClass::Visual:
; 862  : 					sensorArray[i] = new EyeballClass (sensorIdx, this);

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T87[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T87[ebp], 0
	je	SHORT $LN110@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _sensorIdx$99[ebp]
	push	eax
	mov	ecx, DWORD PTR $T87[ebp]
	call	??0EyeballClass@@QAE@HPAVSimMoverClass@@@Z ; EyeballClass::EyeballClass
	mov	DWORD PTR tv1173[ebp], eax
	jmp	SHORT $LN111@Init
$LN110@Init:
	mov	DWORD PTR tv1173[ebp], 0
$LN111@Init:
	mov	ecx, DWORD PTR tv1173[ebp]
	mov	DWORD PTR $T56[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR $T56[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$LN20@Init:
$LN27@Init:

; 863  : 					break;
; 864  : 				default:
; 865  : 					ShiWarning( "Unhandled sensor type during Init" );
; 866  : 					break;
; 867  : 				}
; 868  : 			}

	jmp	$LN30@Init
$LN29@Init:

; 869  : 			
; 870  : 			//Kludge until class table fixed
; 871  : 			if (needsRadar){

	cmp	DWORD PTR _needsRadar$106[ebp], 0
	je	SHORT $LN19@Init

; 872  : 				sensorArray[i] = new RadarAGOnlyClass (1, this);

	push	144					; 00000090H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T85[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T85[ebp], 0
	je	SHORT $LN112@Init
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T85[ebp]
	call	??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z ; RadarAGOnlyClass::RadarAGOnlyClass
	mov	DWORD PTR tv1199[ebp], eax
	jmp	SHORT $LN113@Init
$LN112@Init:
	mov	DWORD PTR tv1199[ebp], 0
$LN113@Init:
	mov	ecx, DWORD PTR tv1199[ebp]
	mov	DWORD PTR $T55[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR $T55[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 873  : 				++i;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@Init:

; 874  : 			}
; 875  : 			
; 876  : 			if (hasHarm){

	cmp	DWORD PTR _hasHarm$97[ebp], 0
	je	$LN18@Init

; 877  : 				sensorArray[i] = new EasyHarmTargetingPod (5, this);

	push	228					; 000000e4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T84[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T84[ebp], 0
	je	SHORT $LN114@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	5
	mov	ecx, DWORD PTR $T84[ebp]
	call	??0EasyHarmTargetingPod@@QAE@HPAVSimMoverClass@@@Z ; EasyHarmTargetingPod::EasyHarmTargetingPod
	mov	DWORD PTR tv1225[ebp], eax
	jmp	SHORT $LN115@Init
$LN114@Init:
	mov	DWORD PTR tv1225[ebp], 0
$LN115@Init:
	mov	edx, DWORD PTR tv1225[ebp]
	mov	DWORD PTR $T53[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR $T53[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 878  : 				// Cobra - new EasyHarmTargetingPod() does not set the sensorType.
; 879  : 				// New function added to set sensorType.
; 880  : 				sensorArray[i]->SetType(SensorClass::HTS);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+24]
	call	eax

; 881  : 				++i;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN18@Init:

; 882  : 			}
; 883  : 			
; 884  : 			if (hasLGB){

	cmp	DWORD PTR _hasLGB$95[ebp], 0
	je	$LN17@Init

; 885  : 				sensorArray[i] = new LaserPodClass (5, this);

	push	116					; 00000074H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T83[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T83[ebp], 0
	je	SHORT $LN116@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	push	5
	mov	ecx, DWORD PTR $T83[ebp]
	call	??0LaserPodClass@@QAE@HPAVSimMoverClass@@@Z ; LaserPodClass::LaserPodClass
	mov	DWORD PTR tv1267[ebp], eax
	jmp	SHORT $LN117@Init
$LN116@Init:
	mov	DWORD PTR tv1267[ebp], 0
$LN117@Init:
	mov	eax, DWORD PTR tv1267[ebp]
	mov	DWORD PTR $T51[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR $T51[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 886  : 				// Cobra - new LaserPodClass() does not set the sensorType.  New function added to set sensorType.
; 887  : 				sensorArray[i]->SetType(SensorClass::TargetingPod);

	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN17@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T49[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 893  : 		switch (((UnitClass*)GetCampaignObject())->GetUnitMission())

	mov	eax, DWORD PTR $T49[ebp]
	mov	DWORD PTR tv1295[ebp], eax
	mov	ecx, DWORD PTR tv1295[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1295[ebp]
	mov	eax, DWORD PTR [edx+664]
	call	eax
	mov	DWORD PTR tv1299[ebp], eax
	cmp	DWORD PTR tv1299[ebp], 19		; 00000013H
	je	SHORT $LN14@Init
	cmp	DWORD PTR tv1299[ebp], 28		; 0000001cH
	je	SHORT $LN13@Init
	jmp	$LN12@Init
$LN14@Init:

; 894  : 		{
; 895  : 		case AMIS_FAC:
; 896  : 			theBrain = new FACBrain (this, af);

	push	996					; 000003e4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T80[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T80[ebp], 0
	je	SHORT $LN118@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T80[ebp]
	call	??0FACBrain@@QAE@PAVAircraftClass@@PAVAirframeClass@@@Z ; FACBrain::FACBrain
	mov	DWORD PTR tv1318[ebp], eax
	jmp	SHORT $LN119@Init
$LN118@Init:
	mov	DWORD PTR tv1318[ebp], 0
$LN119@Init:
	mov	ecx, DWORD PTR tv1318[ebp]
	mov	DWORD PTR $T47[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T47[ebp]
	mov	DWORD PTR [edx+672], eax

; 897  : 			break;

	jmp	$LN15@Init
$LN13@Init:

; 898  : 			
; 899  : 		case AMIS_TANKER:
; 900  : 			theBrain = new TankerBrain (this, af);

	push	1296					; 00000510H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T79[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T79[ebp], 0
	je	SHORT $LN120@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T79[ebp]
	call	??0TankerBrain@@QAE@PAVAircraftClass@@PAVAirframeClass@@@Z ; TankerBrain::TankerBrain
	mov	DWORD PTR tv1337[ebp], eax
	jmp	SHORT $LN121@Init
$LN120@Init:
	mov	DWORD PTR tv1337[ebp], 0
$LN121@Init:
	mov	ecx, DWORD PTR tv1337[ebp]
	mov	DWORD PTR $T45[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T45[ebp]
	mov	DWORD PTR [edx+672], eax

; 901  : 			SetFlag( I_AM_A_TANKER );

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag

; 902  : 			break;

	jmp	SHORT $LN15@Init
$LN12@Init:

; 903  : 			
; 904  : 		default:
; 905  : 			theBrain = new DigitalBrain (this, af);

	push	972					; 000003ccH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T78[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	cmp	DWORD PTR $T78[ebp], 0
	je	SHORT $LN122@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T78[ebp]
	call	??0DigitalBrain@@QAE@PAVAircraftClass@@PAVAirframeClass@@@Z ; DigitalBrain::DigitalBrain
	mov	DWORD PTR tv1362[ebp], eax
	jmp	SHORT $LN123@Init
$LN122@Init:
	mov	DWORD PTR tv1362[ebp], 0
$LN123@Init:
	mov	ecx, DWORD PTR tv1362[ebp]
	mov	DWORD PTR $T43[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T43[ebp]
	mov	DWORD PTR [edx+672], eax
$LN15@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T41[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 909  : 		DBrain()->SetTaxiPoint(initData->ptIndex);

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T40[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 690  : 	void	SetTaxiPoint(int pt)							{curTaxiPoint = pt;}

	mov	edx, DWORD PTR $T41[ebp]
	mov	eax, DWORD PTR $T40[ebp]
	mov	DWORD PTR [edx+332], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T38[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 910  : 		DBrain()->SetSkill(initData->skill);

	mov	eax, DWORD PTR _initData$[ebp]
	movsx	ecx, WORD PTR [eax+44]
	mov	DWORD PTR $T36[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbrain.h

; 41   :       void SetSkill (int newLevel) {skillLevel = newLevel;};

	mov	edx, DWORD PTR $T38[ebp]
	mov	eax, DWORD PTR $T36[ebp]
	mov	DWORD PTR [edx+8], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T34[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbrain.h

; 40   :       int SkillLevel(void) {return skillLevel;};

	mov	eax, DWORD PTR $T34[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T32[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 914  : 		geomCalcRate = geomCalcRate * ((4 - DBrain()->SkillLevel()) * 2 + 1);

	mov	edx, 4
	sub	edx, DWORD PTR $T32[ebp]
	lea	eax, DWORD PTR [edx+edx+1]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+716]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+716], eax

; 915  : 		targetUpdateRate = (5 * SEC_TO_MSEC);/*targetUpdateRate * ((4 - DBrain()->SkillLevel()) * 2 + 1);*/

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+708], 5000		; 00001388H

; 916  : 		
; 917  : 		// DO NOT MOVE THIS CODE OR I WILL BREAK YOUR DAMN FINGERS, VWF 3/11/97
; 918  : 		if (isDigital){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	je	SHORT $LN11@Init

; 919  : 			af->SetSimpleMode( SIMPLE_MODE_AF );

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?SetSimpleMode@AirframeClass@@QAEXH@Z	; AirframeClass::SetSimpleMode
$LN11@Init:

; 920  : 		}
; 921  : 		// END OF WARNING
; 922  : 				
; 923  : 		/*--------------------*/
; 924  : 		/* Update shared data */
; 925  : 		/*--------------------*/
; 926  : 		if (!OnGround()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN10@Init

; 927  : 			SetPosition (af->x, af->y, af->z);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1116]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 928  : 		}
; 929  : 		else {

	jmp	$LN9@Init
$LN10@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T30[ebp], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 770  : 	VU_ID	Airbase(void)	{return airbase;}

	mov	eax, DWORD PTR $T30[ebp]
	mov	ecx, DWORD PTR [eax+308]
	mov	edx, DWORD PTR [eax+312]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR $T4[ebp+4], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 930  : 			Objective obj = (Objective)vuDatabase->Find(DBrain()->Airbase());

	mov	eax, DWORD PTR $T4[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _obj$76[ebp], eax

; 931  : 			int pt = initData->ptIndex;

	mov	edx, DWORD PTR _initData$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _pt$75[ebp], eax

; 932  : 			if (obj){

	cmp	DWORD PTR _obj$76[ebp], 0
	je	SHORT $LN8@Init

; 933  : 				pt = FindBestSpawnPoint(obj, initData);

	mov	ecx, DWORD PTR _initData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _obj$76[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestSpawnPoint@AircraftClass@@AAEHPAVObjectiveClass@@PAVSimInitDataClass@@@Z ; AircraftClass::FindBestSpawnPoint
	mov	DWORD PTR _pt$75[ebp], eax
$LN8@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T29[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h

; 690  : 	void	SetTaxiPoint(int pt)							{curTaxiPoint = pt;}

	mov	edx, DWORD PTR $T29[ebp]
	mov	eax, DWORD PTR _pt$75[ebp]
	mov	DWORD PTR [edx+332], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 936  : 			SetPosition (af->x, af->y, OTWDriver.GetGroundLevel(af->x, af->y) - 5.0F);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1112]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2979[ebp]
	movss	xmm0, DWORD PTR tv2979[ebp]
	subss	xmm0, DWORD PTR __real@40a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 937  : 			af->vt = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1120], xmm0
$LN9@Init:

; 938  : 		}
; 939  : 		SetDelta (0.0F, 0.0F, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 940  : 		SetYPR (af->psi, af->theta, af->phi);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1168]
	movss	DWORD PTR $T27[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1160]
	movss	DWORD PTR $T26[ebp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1164]
	movss	DWORD PTR $T25[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T27[ebp]
	movss	DWORD PTR [edx+60], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T26[ebp]
	movss	DWORD PTR [eax+64], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR $T25[ebp]
	movss	DWORD PTR [ecx+68], xmm0

; 115  : 	}
; 116  : 	void SetYPRDelta(SM_SCALAR dyaw, SM_SCALAR dpitch,SM_SCALAR droll){ 
; 117  : 		orient_.dyaw_ = dyaw; orient_.dpitch_ = dpitch; orient_.droll_=droll; 

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+72], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+76], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+80], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 947  : 		SetPowerOutput(af->rpm);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1212]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPowerOutput@AircraftClass@@QAEXM@Z	; AircraftClass::SetPowerOutput

; 948  : 		//me123 changed back		SetPowerOutput(af->rpm, af->oldp01[0]);
; 949  : 		// END OF MODIFIED SECTION
; 950  : 		
; 951  : 		CalcTransformMatrix (this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z ; CalcTransformMatrix
	add	esp, 4

; 952  : 		theInputs   = new PilotInputs;

	push	104					; 00000068H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T74[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cmp	DWORD PTR $T74[ebp], 0
	je	SHORT $LN124@Init
	mov	ecx, DWORD PTR $T74[ebp]
	call	??0PilotInputs@@QAE@XZ			; PilotInputs::PilotInputs
	mov	DWORD PTR tv1564[ebp], eax
	jmp	SHORT $LN125@Init
$LN124@Init:
	mov	DWORD PTR tv1564[ebp], 0
$LN125@Init:
	mov	edx, DWORD PTR tv1564[ebp]
	mov	DWORD PTR $T23[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR [eax+720], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T21[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 954  : 		if (Sms->NumHardpoints() && isDigital){

	cmp	DWORD PTR $T21[ebp], 0
	je	SHORT $LN7@Init
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	SHORT $LN7@Init

; 955  : 			Sms->SetUnlimitedAmmo (FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?SetUnlimitedAmmo@SMSClass@@QAEXH@Z	; SMSClass::SetUnlimitedAmmo

; 956  : 			FCC->SetMasterMode(FireControlComputer::Missile);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode

; 957  : 			FCC->SetSubMode(FireControlComputer::Aim9);

	push	5
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?SetSubMode@FireControlComputer@@QAEXW4FCCSubMode@1@@Z ; FireControlComputer::SetSubMode
$LN7@Init:

; 958  : 		}
; 959  : 
; 960  : 		if (!g_bRealisticAvionics || !OnGround()){ // JPO set up the systems

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN5@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@Init
$LN5@Init:

; 961  : 			PreFlight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreFlight@AircraftClass@@QAEXXZ	; AircraftClass::PreFlight
$LN6@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	ecx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR tv1542[ebp], ecx
	cmp	DWORD PTR tv1542[ebp], 0
	jl	SHORT $LN359@Init
	cmp	DWORD PTR tv1542[ebp], 2
	jle	SHORT $LN358@Init
	jmp	SHORT $LN359@Init
$LN358@Init:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	edx, DWORD PTR ?PlayerOptions@@3VPlayerOptionsClass@@A+196
	mov	DWORD PTR $T72[ebp], edx
	jmp	SHORT $LN361@Init
$LN359@Init:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	mov	DWORD PTR $T72[ebp], 0
$LN361@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 966  : 				OnGround() /*&& (af->GetParkType() != LargeParkPt)*/) // FRB = BigBoys do things too.

	cmp	DWORD PTR $T72[ebp], 0
	je	$LN4@Init
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN4@Init

; 967  : 	{
; 968  : 			af->canopyState = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	BYTE PTR [edx+1588], 1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h

; 108  : 	float GetLightLevel()						{ return Ambient + Diffuse; };

	movss	xmm0, DWORD PTR ?TheTimeOfDay@@3VCTimeOfDay@@A+220
	addss	xmm0, DWORD PTR ?TheTimeOfDay@@3VCTimeOfDay@@A+224
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 969  : 			if(TheTimeOfDay.GetLightLevel() < 0.65f)

	movss	xmm1, DWORD PTR __real@3f266666
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 127		; 0000007fH
	jle	SHORT $LN365@Init
	mov	ecx, 127				; 0000007fH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 1
	mov	ecx, 127				; 0000007fH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN365@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 972  : 				SetAcStatusBits(ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
$LN3@Init:

; 973  : 			}
; 974  : 	}
; 975  : 	else

	jmp	SHORT $LN2@Init
$LN4@Init:

; 976  : 	{
; 977  : 		af->canopyState = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	BYTE PTR [edx+1588], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+604], 127		; 0000007fH
	jle	SHORT $LN368@Init
	mov	ecx, 127				; 0000007fH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+eax], 0
	mov	ecx, 127				; 0000007fH
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+eax], 1
$LN368@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 979  : 		ClearAcStatusBits(ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN2@Init:

; 983  : 	if (SimDriver.RunningDogfight() && SimDogfight.IsSetFlag (DF_UNLIMITED_GUNS))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningDogfight@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningDogfight
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Init
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\dogfight.h

; 85   : 		int  IsSetFlag (int flag)						{ return (flags & flag) ? 1 : 0;};

	movsx	edx, WORD PTR ?SimDogfight@@3VDogfightClass@@A+40
	and	edx, 1
	je	SHORT $LN387@Init
	mov	DWORD PTR tv2033[ebp], 1
	jmp	SHORT $LN388@Init
$LN387@Init:
	mov	DWORD PTR tv2033[ebp], 0
$LN388@Init:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 983  : 	if (SimDriver.RunningDogfight() && SimDogfight.IsSetFlag (DF_UNLIMITED_GUNS))

	cmp	DWORD PTR tv2033[ebp], 0
	je	SHORT $LN1@Init

; 984  : 	{
; 985  : 		Sms->SetUnlimitedGuns(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?SetUnlimitedGuns@SMSClass@@QAEXH@Z	; SMSClass::SetUnlimitedGuns
$LN1@Init:

; 986  : 	}
; 987  : 
; 988  : 	// timers for targeting
; 989  : 	nextGeomCalc = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+712], edx

; 990  : 	nextTargetUpdate = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+704], ecx

; 991  : 	SOIManager (SimVehicleClass::SOI_RADAR);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SOIManager@SimVehicleClass@@QAEXW4SOI@1@@Z ; SimVehicleClass::SOIManager

; 992  : 
; 993  : 	CleanupLitePool();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLitePool@AircraftClass@@QAEXXZ	; AircraftClass::CleanupLitePool

; 994  : 
; 995  : 	//MI Reset our soundflag
; 996  : 	SpeedSoundsWFuel = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+988], 0

; 997  : 	SpeedSoundsNFuel = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+992], 0

; 998  : 	GSoundsWFuel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+996], 0

; 999  : 	GSoundsNFuel = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1000], 0

; 1000 : 	StationsFailed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+756], 0

; 1001 : 
; 1002 : 	//MI INS
; 1003 : 	INSFlags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+768], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+768]
	or	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+768], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 1005 : 	INSAlignmentTimer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+772], xmm0

; 1006 : 	INSAlignmentStart = vuxGameTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR [eax+776], ecx

; 1007 : 	INSAlign = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+780], 0

; 1008 : 	HasAligned = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+781], 0

; 1009 : 	INSStatus = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+784], 100		; 00000064H

; 1010 : 	INSLatDrift = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+788], xmm0

; 1011 : 	INSLongDrift = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+792], xmm0

; 1012 : 	INSTimeDiff = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+796], xmm0

; 1013 : 	INS60kts = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+800], 0

; 1014 : 	CheckUFC = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+801], 1

; 1015 : 	INSLatOffset = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+804], xmm0

; 1016 : 	INSLongOffset = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+808], xmm0

; 1017 : 	INSAltOffset = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+812], xmm0

; 1018 : 	INSHDGOffset = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+816], xmm0

; 1019 : 	INSDriftLatDirection = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+820], 0

; 1020 : 	INSDriftLongDirection = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+824], 0

; 1021 : 	INSDriftDirectionTimer = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+828], xmm0

; 1022 : 	BUPADIEnergy = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+832], xmm0

; 1023 : 	GSValid = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+836], 1

; 1024 : 	LOCValid = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+837], 1

; 1025 : 
; 1026 : 	//MI MAL and Indicator lights test button and some other stuff
; 1027 : 	CanopyDamaged = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+852], 0

; 1028 : 	TestLights = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+849], 0

; 1029 : 	LEFLocked = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+853], 0

; 1030 : 	LEFFlags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+864], 0

; 1031 : 	LTLEFAOA = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+856], xmm0

; 1032 : 	RTLEFAOA = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+860], xmm0

; 1033 : 	leftLEFAngle = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+868], xmm0

; 1034 : 	rightLEFAngle = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+872], xmm0

; 1035 : 	TrimAPDisc = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+850], 0

; 1036 : 	TEFExtend = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+851], 0

; 1037 : 	MissileVolume = 8;	//no volume

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+876], 8

; 1038 : 	ThreatVolume = 8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+880], 8

; 1039 : 	GunFire = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+884], 0

; 1040 : 	//Targeting pod cooling
; 1041 : 	PodCooling = (float)((7 + rand()%9) * 60);	//7 - 15 Minutes to cool down.

	call	_rand
	cdq
	mov	ecx, 9
	idiv	ecx
	add	edx, 7
	imul	edx, 60					; 0000003cH
	cvtsi2ss xmm0, edx
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+888], xmm0

; 1042 : 	CockpitWingLight = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+892], 0

; 1043 : 	CockpitWingLightFlash = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+893], 0

; 1044 : 	CockpitStrobeLight = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+894], 0

; 1045 : 
; 1046 : 	NightLight = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1817], 0

; 1047 : 	WideView = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1818], 0

; 1048 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN392@Init:
	DD	$LN22@Init
	DD	$LN26@Init
	DD	$LN23@Init
	DD	$LN21@Init
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$0:
	mov	eax, DWORD PTR $T92[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$1:
	mov	eax, DWORD PTR $T77[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$2:
	mov	eax, DWORD PTR $T86[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$3:
	mov	eax, DWORD PTR $T94[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$4:
	mov	eax, DWORD PTR $T82[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$5:
	mov	eax, DWORD PTR $T93[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$6:
	mov	eax, DWORD PTR $T90[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$7:
	mov	eax, DWORD PTR $T89[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$8:
	mov	eax, DWORD PTR $T87[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$9:
	mov	eax, DWORD PTR $T85[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$10:
	mov	eax, DWORD PTR $T84[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$11:
	mov	eax, DWORD PTR $T83[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$12:
	mov	eax, DWORD PTR $T80[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$13:
	mov	eax, DWORD PTR $T79[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$14:
	mov	eax, DWORD PTR $T78[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z$15:
	mov	eax, DWORD PTR $T74[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-740]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@AircraftClass@@UAEXPAVSimInitDataClass@@@Z ENDP	; AircraftClass::Init
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv150 = -56						; size = 4
$T1 = -52						; size = 4
tv135 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
tv80 = -36						; size = 4
$T4 = -32						; size = 4
tv71 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
$T8 = -12						; size = 4
$T9 = -8						; size = 4
_this$ = -4						; size = 4
?CleanupLocalData@AircraftClass@@AAEXXZ PROC		; AircraftClass::CleanupLocalData
; _this$ = ecx

; 518  : void AircraftClass::CleanupLocalData(){

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 519  : 	if (af){ delete (af); af = NULL; }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $LN5@CleanupLoc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T9[ebp], eax
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN8@CleanupLoc
	mov	ecx, DWORD PTR $T9[ebp]
	call	??1AirframeClass@@QAE@XZ		; AirframeClass::~AirframeClass
	mov	ecx, 1
	and	ecx, 1
	je	SHORT $LN17@CleanupLoc
	mov	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@CleanupLoc:
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN9@CleanupLoc
$LN8@CleanupLoc:
	mov	DWORD PTR tv71[ebp], 0
$LN9@CleanupLoc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+932], 0
$LN5@CleanupLoc:

; 520  : 	if (mFaults){ delete mFaults; mFaults = NULL; }

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+928], 0
	je	SHORT $LN4@CleanupLoc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T8[ebp], edx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN10@CleanupLoc
	mov	ecx, DWORD PTR $T8[ebp]
	call	??1FackClass@@QAE@XZ			; FackClass::~FackClass
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN20@CleanupLoc
	mov	ecx, DWORD PTR $T8[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@CleanupLoc:
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN11@CleanupLoc
$LN10@CleanupLoc:
	mov	DWORD PTR tv80[ebp], 0
$LN11@CleanupLoc:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+928], 0
$LN4@CleanupLoc:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+56
	mov	DWORD PTR $T3[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 521  : 	if (SimDriver.GetPlayerEntity() == this) {	//VWF

	mov	edx, DWORD PTR $T3[ebp]
	cmp	edx, DWORD PTR _this$[ebp]
	jne	SHORT $LN3@CleanupLoc

; 522  : 		gNavigationSys->DeleteMissionTacans();

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?DeleteMissionTacans@NavigationSystem@@QAEXXZ ; NavigationSystem::DeleteMissionTacans
$LN3@CleanupLoc:

; 523  : 	}
; 524  : 	if (Sms){ delete Sms; Sms = NULL; }	

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN2@CleanupLoc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T7[ebp], eax
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN12@CleanupLoc
	push	1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN13@CleanupLoc
$LN12@CleanupLoc:
	mov	DWORD PTR tv135[ebp], 0
$LN13@CleanupLoc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+940], 0
$LN2@CleanupLoc:

; 525  : 	if (FCC){ delete FCC; FCC = NULL;}

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+936], 0
	je	SHORT $LN6@CleanupLoc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T6[ebp], edx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN14@CleanupLoc
	push	1
	mov	eax, DWORD PTR $T6[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN15@CleanupLoc
$LN14@CleanupLoc:
	mov	DWORD PTR tv150[ebp], 0
$LN15@CleanupLoc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+936], 0
$LN6@CleanupLoc:

; 526  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupLocalData@AircraftClass@@AAEXXZ ENDP		; AircraftClass::CleanupLocalData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv894 = -56						; size = 8
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
tv890 = -36						; size = 4
tv520 = -32						; size = 4
tv517 = -28						; size = 4
tv308 = -24						; size = 4
$T4 = -20						; size = 4
_x$5 = -16						; size = 4
_FastRandom$6 = -12					; size = 4
_i$7 = -8						; size = 4
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?InitLocalData@AircraftClass@@AAEXH@Z PROC		; AircraftClass::InitLocalData
; _this$ = ecx

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 181  : 	turbulence = 0;// wake turb

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3572], 0

; 182  : 	rVortex = 0; // wingtip turp

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3580], 0

; 183  : 	lVortex = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3576], 0

; 184  : 
; 185  : 	acmiTimer=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1868], xmm0

; 186  : 
; 187  : 	// MLR 2/23/2004 - for recording the ACMI
; 188  : #if 1
; 189  : 	// sfr: changed
; 190  : 	memset(acmiDOFValue, 0, sizeof(acmiDOFValue));

	push	652					; 0000028cH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1872				; 00000750H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 191  : 	memset(acmiSwitchValue, 0, sizeof(acmiSwitchValue));

	push	1020					; 000003fcH
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2524				; 000009dcH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 192  : #else
; 193  : 	for (int l=0;l<COMP_MAX_DOF;l++){
; 194  : 		acmiDOFValue[l] = 0;
; 195  : 	}
; 196  : 	for (int l=0;l<COMP_MAX_SWITCH;l++){
; 197  : 		acmiSwitchValue[l] = 0;
; 198  : 	}
; 199  : #endif
; 200  : 
; 201  : 	dustTrail = 0;  // MLR 1/4/2004 - new dust trail object

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1424], 0

; 202  : 	dustConnect = FALSE; // MLR 1/4/2004 -

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1464], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 388  : 		this->isDigital = isDigital; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _flag$[ebp]
	mov	DWORD PTR [edx+948], eax

; 389  : 		this->autopilotType = isDigital ? CombatAP : APOff; 

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN19@InitLocalD
	mov	DWORD PTR tv517[ebp], 2
	jmp	SHORT $LN20@InitLocalD
$LN19@InitLocalD:
	mov	DWORD PTR tv517[ebp], 4
$LN20@InitLocalD:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv517[ebp]
	mov	DWORD PTR [ecx+968], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 207  : 	lastapType = ThreeAxisAP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+972], 0

; 208  : 	theBrain = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+672], 0

; 209  : 	Guns = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+944], 0

; 210  : 	dropProgrammedStep  = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+980], ax

; 211  : 	dropProgrammedTimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+976], 0

; 212  : 
; 213  : 	// Init targeting 
; 214  : 	targetPtr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+656], 0

; 215  :     acFlags = 0;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+964], 0

; 216  : 	fireGun = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+916], 0

; 217  : 	fireMissile = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+920], 0

; 218  : 	lastPickle = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+924], 0

; 219  : 	curWaypoint = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+728], 0

; 220  : 	glocFactor = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+912], xmm0

; 221  : 	gLoadSeconds = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1092], xmm0

; 222  : 	playerSmokeOn = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1468], 0

; 223  : 	// init JDAM
; 224  : 	JDAMtargetRange = -1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1772], xmm0

; 225  : 	strcpy(JDAMtargetName, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1604				; 00000644H
	push	ecx
	call	_strcpy
	add	esp, 8

; 226  : 	strcpy(JDAMtargetName1, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1684				; 00000694H
	push	edx
	call	_strcpy
	add	esp, 8

; 227  : 	JDAMtarget = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1596], 0

; 228  : 	
; 229  : 	af = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+932], 0

; 230  : 	waypoint = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+732], 0

; 231  : #if 1
; 232  : 	// sfr: changed
; 233  : 	memset(smokeTrail, 0, sizeof(smokeTrail));

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1160				; 00000488H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 234  : 	memset(conTrails, 0, sizeof(conTrails));

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1184				; 000004a0H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 235  : 	memset(engineTrails, 0, sizeof(engineTrails));

	push	32					; 00000020H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1312				; 00000520H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 236  : #else
; 237  : 	for (int stn = 0; stn < TRAIL_MAX; stn++){
; 238  : 	    smokeTrail[stn] = NULL;
; 239  : 	}
; 240  : 	for (stn = 0; stn < MAXENGINES; stn++) {
; 241  : 	    conTrails[stn] = NULL;
; 242  : 	    engineTrails[stn] = NULL;
; 243  : 	}
; 244  : #endif
; 245  : 	lwingvortex = rwingvortex = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1384], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1376], 0

; 246  : 	//wingvapor=NULL;
; 247  : 
; 248  : 	//RV I-Hawk - Damage trail locations are 0 before being set in AircraftClass::ShowDamage 
; 249  :     damageTrailLocation0.x = damageTrailLocation1.x = 0.0f ; 

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1444], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1432], xmm0

; 250  : 	damageTrailLocation0.y = damageTrailLocation1.y = 0.0f ;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1448], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1436], xmm0

; 251  : 	damageTrailLocation0.z = damageTrailLocation1.z = 0.0f ;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1452], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1440], xmm0

; 252  :     damageTrailLocationSet = FALSE; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1456], 0

; 253  : 
; 254  : 	colorContrail = TRAIL_CONTRAIL; //RV - I-Hawk

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1460], 0

; 255  : 
; 256  :    //RV - I-Hawk - determine if the burning position will follow damageLocation or not...
; 257  : 	if (rand() & 1)

	call	_rand
	and	eax, 1
	je	SHORT $LN14@InitLocalD

; 258  : 		burnEffectPosition = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1457], 1

; 259  : 	else

	jmp	SHORT $LN13@InitLocalD
$LN14@InitLocalD:

; 260  : 		burnEffectPosition = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1457], 0
$LN13@InitLocalD:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h

; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$6[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$6[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$6[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$6[ebp]
	mov	DWORD PTR $T3[ebp], eax

; 124  : }
; 125  : 
; 126  : 
; 127  : inline int PRANDInt5( void )
; 128  : {
; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;

	mov	ecx, DWORD PTR $T3[ebp]
	and	ecx, 7
	mov	DWORD PTR _x$5[ebp], ecx

; 131  : 	return((x<5)?x:x-5);

	cmp	DWORD PTR _x$5[ebp], 5
	jge	SHORT $LN23@InitLocalD
	mov	edx, DWORD PTR _x$5[ebp]
	mov	DWORD PTR tv520[ebp], edx
	jmp	SHORT $LN24@InitLocalD
$LN23@InitLocalD:
	mov	eax, DWORD PTR _x$5[ebp]
	sub	eax, 5
	mov	DWORD PTR tv520[ebp], eax
$LN24@InitLocalD:
	mov	ecx, DWORD PTR tv520[ebp]
	mov	DWORD PTR $T2[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 263  : 	dyingTime = PRANDInt5();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+700], eax

; 264  : 		
; 265  : 	dropChaffCmd = dropFlareCmd = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+961], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+960], 0

; 266  : 	ejectTriggered = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], 0

; 267  : 	ejectCountdown = 1.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1800], xmm0

; 268  : 	doEjectCountdown = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1804], 0

; 269  : 
; 270  : 	//MI
; 271  : 	EmerJettTriggered = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1808], 0

; 272  : 	JettCountown = 1.0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1812], xmm0

; 273  : 	doJettCountdown = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1816], 0

; 274  : 	//TJL 01/04/04 
; 275  : 	wingSweep = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1836], xmm0

; 276  : 	
; 277  : 	bingoFuel = 1500;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR [ecx+984], xmm0

; 278  : 	
; 279  : 	MPOCmd = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+956], 0

; 280  : 	
; 281  : 	mFaults = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+928], 0

; 282  : 	lastStatus = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1096], 0

; 283  : 	status_bits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], 0

; 284  : 	dirty_aircraft = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+764], 0

; 285  : 	
; 286  : 	// timers for targeting
; 287  : 	nextGeomCalc = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+712], edx

; 288  : 	nextTargetUpdate = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+704], ecx

; 289  : 	
; 290  : 	mCautionCheckTime = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+952], eax

; 291  : 	
; 292  : 	if ( isDigital ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	je	SHORT $LN12@InitLocalD

; 293  : 		geomCalcRate = FloatToInt32(0.5F * SEC_TO_MSEC);

	movss	xmm0, DWORD PTR __real@43fa0000
	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 182  :     fld dword ptr [x];

	fld	DWORD PTR $T4[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR $T4[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR $T4[ebp]

; 181  :   __asm {

	mov	DWORD PTR $T1[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 293  : 		geomCalcRate = FloatToInt32(0.5F * SEC_TO_MSEC);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+716], eax

; 294  : 		targetUpdateRate = (5 * SEC_TO_MSEC);/*FloatToInt32((1.0f + 3.0f * (float)rand()/RAND_MAX) * SEC_TO_MSEC);*/

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+708], 5000		; 00001388H

; 295  : 	}
; 296  : 	else {

	jmp	SHORT $LN11@InitLocalD
$LN12@InitLocalD:

; 297  : 		geomCalcRate = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+716], 0

; 298  : 		targetUpdateRate = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+708], 0
$LN11@InitLocalD:

; 299  : 	}
; 300  : 	
; 301  : 	// If we're flying dogfight, we mark this entity as nontransferable
; 302  : 	if (SimDriver.RunningDogfight()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningDogfight@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningDogfight
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@InitLocalD

; 303  : 		share_.flags_.breakdown_.transfer_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN10@InitLocalD:

; 304  : 	}
; 305  : 
; 306  : 	pLandLitePool		= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1472], 0

; 307  : 	mInhibitLitePool	= TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1476], 1

; 308  : 
; 309  : 	//used for safe deletion of sensor array when making a player vehicle
; 310  : 	tempSensorArray = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1820], 0

; 311  : 	tempNumSensors = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1824], 0

; 312  : 	powerFlags = 0; // JPO

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1480], 0

; 313  : 	RALTStatus = ROFF; // JPO initialise

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1004], 0

; 314  : 	RALTCoolTime = 5.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [edx+1008], xmm0

; 315  : 
; 316  : 	//MI EWS
; 317  : 	ManualECM = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1012], 0

; 318  : 	EWSProgNum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1500], 0

; 319  : 	APFlag = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1048], 0

; 320  : 
; 321  : 	//MI Seat Arm
; 322  : 	SeatArmed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1052], 0

; 323  : 
; 324  : 	// JPO electrics
; 325  : 	mainPower = MainPowerOff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1484], 0

; 326  : 	currentPower = PowerNone;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1488], 0

; 327  : 	elecLights = ElecNone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1492], 0

; 328  : 	interiorLight = LT_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+744], 0

; 329  : 	instrumentLight = LT_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+748], 0

; 330  : 	spotLight = LT_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+752], 0

; 331  : 	TheColorBank.PitLightLevel = 0;

	mov	DWORD PTR ?PitLightLevel@ColorBankClass@@2HA, 0 ; ColorBankClass::PitLightLevel

; 332  : 
; 333  : 	//MI Caution stuff
; 334  : 	NeedsToPlayCaution = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1504], 0

; 335  : 	NeedsToPlayWarning = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1505], 0

; 336  : 	WhenToPlayWarning = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1512], 0

; 337  : 	WhenToPlayCaution = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1508], 0

; 338  : 
; 339  : 	attachedEntity = NULL; // JB carrier

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1828], 0

; 340  : 
; 341  : 	// 2001-10-21 ADDED BY S.G. INIT THESE SO AI REACTS TO THE FIRST MISSILE LAUNCH
; 342  : 	incomingMissile[0] = NULL;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+420], 0

; 343  : 	incomingMissile[1] = NULL;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+420], 0

; 344  : 	incomingMissileEvadeTimer = 10000000;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], 10000000		; 00989680H

; 345  : 	incomingMissileRange = 500 * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4a396e66
	movss	DWORD PTR [edx+428], xmm0

; 346  : 
; 347  : 	//MI VMS stuff
; 348  : 	playBetty = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1516], 1

; 349  : 	//MI RF Switch
; 350  : 	RFState = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1520], 0

; 351  : 	//MI overSpeed and G stuff
; 352  : 	for(int i = 0; i < 3; i++){

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN9@InitLocalD
$LN8@InitLocalD:
	mov	edx, DWORD PTR _i$7[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7[ebp], edx
$LN9@InitLocalD:
	cmp	DWORD PTR _i$7[ebp], 3
	jge	$LN7@InitLocalD

; 353  : 		switch(i){

	mov	eax, DWORD PTR _i$7[ebp]
	mov	DWORD PTR tv308[ebp], eax
	cmp	DWORD PTR tv308[ebp], 0
	je	SHORT $LN4@InitLocalD
	cmp	DWORD PTR tv308[ebp], 1
	je	$LN3@InitLocalD
	cmp	DWORD PTR tv308[ebp], 2
	je	$LN2@InitLocalD
	jmp	$LN1@InitLocalD
$LN4@InitLocalD:

; 354  : 		case 0:
; 355  : 			//Level one, 60 - 90kts tolerance
; 356  : 			OverSpeedToleranceTanks[i] = 60 + rand() % 30;

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	add	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1540], edx

; 357  : 			OverSpeedToleranceBombs[i] = 60 + rand() % 30;

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	add	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1552], edx

; 358  : 
; 359  : 			//0.5-1G's tolerance
; 360  : 			OverGToleranceTanks[i] = 5 + rand() % 5;

	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 5
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1564], edx

; 361  : 
; 362  : 			//1.8 - 2.2 G tolerance, will be divided by 10
; 363  : 			OverGToleranceBombs[i] = 18 + rand() % 4;

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN59@InitLocalD
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN59@InitLocalD:
	add	eax, 18					; 00000012H
	mov	edx, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+1576], eax

; 364  : 
; 365  : 			//assign them
; 366  : 			SpeedToleranceTanks = OverSpeedToleranceTanks[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1540]
	mov	DWORD PTR [edx+1524], eax

; 367  : 			SpeedToleranceBombs = OverSpeedToleranceBombs[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$7[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+1552]
	mov	DWORD PTR [ecx+1528], edx

; 368  : 
; 369  : 			GToleranceTanks = float(OverGToleranceTanks[i]) / 10.0f;

	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax*4+1564]
	divss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1532], xmm0

; 370  : 			GToleranceBombs = float(OverGToleranceBombs[i]) / 10.0f;

	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax*4+1576]
	divss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1536], xmm0

; 371  : 			break;

	jmp	$LN5@InitLocalD
$LN3@InitLocalD:

; 372  : 		case 1:
; 373  : 			//level two,  90 - 120kts tolerance
; 374  : 			OverSpeedToleranceTanks[i] = 91 + rand() % 30;

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	add	edx, 91					; 0000005bH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1540], edx

; 375  : 			OverSpeedToleranceBombs[i] = 91 + rand() % 30;

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	add	edx, 91					; 0000005bH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1552], edx

; 376  : 
; 377  : 			//1.1 - 1.6G's tolerance, will be divided by 10
; 378  : 			OverGToleranceTanks[i] = 11 + rand() % 5;

	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 11					; 0000000bH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1564], edx

; 379  : 
; 380  : 			//2.3 - 2.7 G tolerance
; 381  : 			OverGToleranceBombs[i] = 23 + rand() % 4;

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN60@InitLocalD
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN60@InitLocalD:
	add	eax, 23					; 00000017H
	mov	edx, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+1576], eax

; 382  : 			break;

	jmp	SHORT $LN5@InitLocalD
$LN2@InitLocalD:

; 383  : 		case 2:
; 384  : 			//level three, 120 - 150kts tolerance
; 385  : 			OverSpeedToleranceTanks[i] = 122 + rand() % 30;

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	add	edx, 122				; 0000007aH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1540], edx

; 386  : 			OverSpeedToleranceBombs[i] = 122 + rand() % 30;

	call	_rand
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	add	edx, 122				; 0000007aH
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1552], edx

; 387  : 
; 388  : 			//1.7 - 2.2G's tolerance, will be divided by 10
; 389  : 			OverGToleranceTanks[i] = 17 + rand() % 5;

	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 17					; 00000011H
	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1564], edx

; 390  : 
; 391  : 			//2.8 - 3.2 G tolerance
; 392  : 			OverGToleranceBombs[i] = 28 + rand() % 4;

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN61@InitLocalD
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN61@InitLocalD:
	add	eax, 28					; 0000001cH
	mov	edx, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+1576], eax
$LN1@InitLocalD:
$LN5@InitLocalD:

; 393  : 			break;
; 394  : 		default:
; 395  : 			break;
; 396  : 		}
; 397  : 	}

	jmp	$LN8@InitLocalD
$LN7@InitLocalD:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 440  : 	void ClearAPFlag (APFlags flag) {APFlag &= ~flag;};

	mov	edx, 1
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+1048]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1048], edx
	mov	edx, 2
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+1048]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1048], edx
	mov	edx, 8
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+1048]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1048], edx
	mov	edx, 16					; 00000010H
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+1048]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1048], edx
	mov	edx, 4
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+1048]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1048], edx

; 441  : 	void SetAPParameters(void);
; 442  : 	void SetNewRoll(void);
; 443  : 	void SetNewPitch(void);
; 444  : 	void SetNewAlt(void);
; 445  : 	//MI seatArm
; 446  : 	bool SeatArmed;
; 447  : 	void StepSeatArm(void);
; 448  : 
; 449  : 	TransformMatrix		vmat;
; 450  : 	float				gLoadSeconds;
; 451  : 	long				lastStatus;
; 452  : 	BasicWeaponStation	counterMeasureStation[3];
; 453  : 	enum { // what trail is used for what
; 454  : 		TRAIL_DAMAGE = 0, // we've been hit
; 455  : 		TRAIL_ENGINE1,
; 456  : 		TRAIL_ENGINE2,
; 457  : 		TRAIL_MAX,
; 458  : 		MAXENGINES = 8,
; 459  : 	};
; 460  : 	//DrawableTrail*		smokeTrail[TRAIL_MAX];
; 461  : 	//DrawableTrail	    *conTrails[MAXENGINES];
; 462  : 	//DrawableTrail	    *engineTrails[MAXENGINES];
; 463  : 	//DrawableTrail	*rwingvortex, *lwingvortex;
; 464  : 	//DrawableTrail   *wingvapor;
; 465  : 	//DrawableTrail   *dustTrail; // MLR 1/3/2004 - for the dumbass dust/mist trail effect!
; 466  : 	// ********** NEW TRAIL STUFF *************
; 467  : 	DWORD       smokeTrail[TRAIL_MAX];
; 468  : 	DWORD       smokeTrail_trail[TRAIL_MAX];
; 469  : 	DWORD       conTrails[MAXENGINES];
; 470  : 	DWORD       conTrails_trail[MAXENGINES];
; 471  : 	DWORD       colorConTrails[MAXENGINES];
; 472  : 	DWORD       colorConTrails_trail[MAXENGINES];
; 473  : 	DWORD       engineTrails[MAXENGINES];
; 474  : 	DWORD       engineTrails_trail[MAXENGINES];
; 475  :     DWORD		lwingvortex;
; 476  : 	DWORD		lwingvortex_trail;
; 477  : 	DWORD		rwingvortex;
; 478  : 	DWORD		rwingvortex_trail;
; 479  : 	DWORD       lvortex1;
; 480  : 	DWORD       lvortex1_trail;
; 481  : 	DWORD       rvortex1;
; 482  : 	DWORD       rvortex1_trail;
; 483  : 	DWORD       lvortex2;
; 484  : 	DWORD       lvortex2_trail;
; 485  : 	DWORD       rvortex2;
; 486  : 	DWORD       rvortex2_trail;
; 487  : 	DWORD       dustTrail;
; 488  : 	DWORD       dustTrail_trail;
; 489  :     
; 490  : 	Tpoint damageTrailLocation0; 
; 491  :     Tpoint damageTrailLocation1;
; 492  : 	bool   damageTrailLocationSet; //RV I-Hawk - added as flag for if damage trail locations are set
; 493  : 	bool burnEffectPosition;
; 494  : 
; 495  : 	//RV I-Hawk - This variable decides the CTRL-S trail color, there are 5 different colors
; 496  : 	int colorContrail;
; 497  : 	void SetColorContrail (int color);
; 498  :     // ****************************************
; 499  :     BOOL             dustConnect;  // MLR 1/4/2004 - 
; 500  : 	BOOL				playerSmokeOn;
; 501  : 	DrawableGroundVehicle* pLandLitePool;
; 502  : 	BOOL				mInhibitLitePool;
; 503  : 	void				CleanupLitePool(void);
; 504  : 	void	AddEngineTrails(int ttype, DWORD *tlist, DWORD *tlist_trail);
; 505  : 	void	CancelEngineTrails(DWORD *tlist, DWORD *tlist_trail);
; 506  : 
; 507  : 	// JPO Avionics power settings;
; 508  : 	unsigned int powerFlags;
; 509  : 	void PowerOn (AvionicsPowerFlags fl) { powerFlags |= fl; };
; 510  : 	int HasPower(AvionicsPowerFlags fl);
; 511  : 	void PowerOff (AvionicsPowerFlags fl) { powerFlags &= ~fl; };
; 512  : 	void PowerToggle (AvionicsPowerFlags fl) { powerFlags ^= fl; };
; 513  : 	int PowerSwitchOn(AvionicsPowerFlags fl) { return (powerFlags & fl) ? TRUE : FALSE; };
; 514  : 
; 515  : 	void PreFlight (); // JPO - do preflight checks.
; 516  : 
; 517  : 	// JPPO Main Power
; 518  : 	MainPowerType mainPower;
; 519  : 	MainPowerType MainPower() { return mainPower; };
; 520  : 	BOOL MainPowerOn() { return mainPower == MainPowerMain; };
; 521  : 	void SetMainPower (MainPowerType t) { mainPower = t; };
; 522  : 	void IncMainPower ();
; 523  : 	void DecMainPower ();
; 524  : 	PowerStates currentPower;
; 525  : 	enum ElectricLights {
; 526  : 	ElecNone = 0x0,
; 527  : 	ElecFlcsPmg = 0x1,
; 528  : 	ElecEpuGen = 0x2,
; 529  : 	ElecEpuPmg = 0x4,
; 530  : 	ElecToFlcs = 0x8,
; 531  : 	ElecFlcsRly = 0x10,
; 532  : 	ElecBatteryFail = 0x20,
; 533  : 	};
; 534  : 	unsigned int elecLights;
; 535  : 	bool ElecIsSet(ElectricLights lt) { return (elecLights & lt) ? true : false; };
; 536  : 	void ElecSet(ElectricLights lt) { elecLights |= lt; };
; 537  : 	void ElecClear(ElectricLights lt) { elecLights &= ~lt; };
; 538  : 	void DoElectrics();
; 539  : 	static const unsigned long systemStates[PowerMaxState];
; 540  : 
; 541  : 	//MI EWS PGM Switch
; 542  : 	EWSPGMSwitch EWSPgm;
; 543  : 	EWSPGMSwitch EWSPGM() { return EWSPgm; };
; 544  : 	void SetPGM (EWSPGMSwitch t) { EWSPgm = t; };

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1496], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 415  : 	CockpitWingLight = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+892], 0

; 416  : 	CockpitWingLightFlash = FALSE; //martinv i have no idea about why these WERE residing under TGP cooling ??

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+893], 0

; 417  : 	CockpitStrobeLight = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+894], 0

; 418  : 
; 419  : 	//MI emergency Jettison
; 420  : 	EmerJettTriggered = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1808], 0

; 421  : 	JettCountown = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1812], xmm0

; 422  : 	doJettCountdown = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1816], 0

; 423  : 
; 424  : 	//MI AVTR
; 425  : 	AVTRFlags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+840], 0

; 426  : 	AVTRCountown = 0;	//AVTR auto

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+844], xmm0

; 427  : 	doAVTRCountdown = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+848], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 249  : 	void AVTROn(AVTRStateFlags fl) { AVTRFlags |= fl; };

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+840], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 431  : 	INSFlags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], 0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+768], edx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 433  : 	INSAlignmentTimer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+772], xmm0

; 434  : 	INSAlignmentStart = vuxGameTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR [edx+776], eax

; 435  : 	INSAlign = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+780], 0

; 436  : 	HasAligned = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+781], 0

; 437  : 	INSStatus = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+784], 100		; 00000064H

; 438  : 	INSLatDrift = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+788], xmm0

; 439  : 	INSLongDrift = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+792], xmm0

; 440  : 	INSTimeDiff = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+796], xmm0

; 441  : 	INS60kts = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+800], 0

; 442  : 	CheckUFC = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+801], 1

; 443  : 	INSLatOffset = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+804], xmm0

; 444  : 	INSLongOffset = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+808], xmm0

; 445  : 	INSAltOffset = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+812], xmm0

; 446  : 	INSHDGOffset = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+816], xmm0

; 447  : 	INSDriftLatDirection = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+820], 0

; 448  : 	INSDriftLongDirection = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+824], 0

; 449  : 	INSDriftDirectionTimer = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+828], xmm0

; 450  : 	BUPADIEnergy = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+832], xmm0

; 451  : 	GSValid = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+836], 1

; 452  : 	LOCValid = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+837], 1

; 453  : 	
; 454  : 	//MI MAL and Indicator lights test button and some other stuff
; 455  : 	CanopyDamaged = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+852], 0

; 456  : 	TestLights = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+849], 0

; 457  : 	LEFLocked = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+853], 0

; 458  : 	LEFFlags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+864], 0

; 459  : 	LTLEFAOA = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+856], xmm0

; 460  : 	RTLEFAOA = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+860], xmm0

; 461  : 	leftLEFAngle = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+868], xmm0

; 462  : 	rightLEFAngle = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+872], xmm0

; 463  : 	TrimAPDisc = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+850], 0

; 464  : 	TEFExtend = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+851], 0

; 465  : 	MissileVolume = 8;	//no volume

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+876], 8

; 466  : 	ThreatVolume = 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+880], 8

; 467  : 	GunFire = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+884], 0

; 468  : 
; 469  : 	//TGP Cooling
; 470  : 	PodCooling = (float)((7 + rand()%9) * 60);	//7 - 15 Minutes to cool down.

	call	_rand
	cdq
	mov	ecx, 9
	idiv	ecx
	add	edx, 7
	imul	edx, 60					; 0000003cH
	cvtsi2ss xmm0, edx
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+888], xmm0

; 471  : 	FCC = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+936], 0

; 472  : 	Sms = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+940], 0

; 473  : 	AWACSsaidAbort = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1832], 0

; 474  : 
; 475  : 	NightLight = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1817], 0

; 476  : 	WideView = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1818], 0

; 477  : 
; 478  : 	flareDispenser=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1852], 0

; 479  : 	flareUsed=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1860], 0

; 480  : 	chaffDispenser=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], 0

; 481  : 	chaffUsed=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1864], 0

; 482  : 
; 483  : 	brakePos = 0;//TJL 02/28/04

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1588], 0

; 484  : 	speedBrakeState = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1592], xmm0

; 485  : 	swingWingAngle = 0; // MLR 3/5/2004 -

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+3544], xmm0

; 486  : 	spawnpoint = 0;	//RAS-11Nov01-for initial spawnpoint

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1792], 0

; 487  : 	requestHotpitRefuel = FALSE; //TJL 08/16/04 //Cobra 10/30/04 TJL

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+895], 0

; 488  : 	iffEnabled = FALSE;//Cobra 11/20/04

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+896], 0

; 489  : 	interrogating = FALSE; //Cobra 11/21/04 True when TMS Left is Held

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+900], 0

; 490  : 	runIFFInt = FALSE;//Cobra 11/21/04

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+901], 0

; 491  : 	iffModeTimer = (float)SimLibElapsedTime;//Cobra 11/21/04

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv890[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv890[ebp]
	mov	eax, DWORD PTR tv890[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv894[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv894[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+904], xmm0

; 492  : 	iffModeChallenge = 99;//Cobra 11/21/04

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], 99			; 00000063H

; 493  : 	JDAMStep = 1; //Cobra - Start by finding a default target (for AI)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], 1

; 494  : 	JDAMtgtnum = -1; //Cobra

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1768], -1

; 495  : 	JDAMsbc = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1600], 0

; 496  : 	JDAMtgtPos.x = -1;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1776], xmm0

; 497  : 	JDAMtgtPos.y = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1780], xmm0

; 498  : 	JDAMAllowAutoStep = true; // RV - I-Hawk

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1788], 1

; 499  : 
; 500  : 	PulseTurbulenceTime=0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+3584], xmm0

; 501  : 	memset(&PulseTurbulence, 0, sizeof(PulseTurbulence));

	push	12					; 0000000cH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3588				; 00000e04H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 502  : 	memset(&TotalTurbulence, 0, sizeof(TotalTurbulence));

	push	12					; 0000000cH
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3612				; 00000e1cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 503  : 	memset(&StaticTurbulence, 0, sizeof(StaticTurbulence));

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3600				; 00000e10H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 504  : 
; 505  : 	//sfr: animwing timers
; 506  : 	animWingFlashTimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1844], 0

; 507  : 
; 508  : 	// RV - Biker
; 509  : 	carrierStartPosEngaged = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3560], 0

; 510  : 	carrierInitTimer = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+3564], xmm0

; 511  : 	takeoffSlot = 99;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3568], 99		; 00000063H

; 512  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?InitLocalData@AircraftClass@@AAEXH@Z ENDP		; AircraftClass::InitLocalData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CleanupData@AircraftClass@@UAEXXZ PROC			; AircraftClass::CleanupData
; _this$ = ecx

; 528  : void AircraftClass::CleanupData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 529  : 	CleanupLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLocalData@AircraftClass@@AAEXXZ	; AircraftClass::CleanupLocalData

; 530  : 	SimVehicleClass::CleanupData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupData@SimVehicleClass@@UAEXXZ	; SimVehicleClass::CleanupData

; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupData@AircraftClass@@UAEXXZ ENDP			; AircraftClass::CleanupData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?InitData@AircraftClass@@UAEXXZ PROC			; AircraftClass::InitData
; _this$ = ecx

; 174  : void AircraftClass::InitData(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	SimVehicleClass::InitData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitData@SimVehicleClass@@UAEXXZ	; SimVehicleClass::InitData
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 385  : 	int IsDigital() { return isDigital; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+948]
	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 176  : 	InitLocalData(IsDigital());

	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@AircraftClass@@AAEXH@Z	; AircraftClass::InitLocalData

; 177  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitData@AircraftClass@@UAEXXZ ENDP			; AircraftClass::InitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AircraftClass@@UAE@XZ PROC				; AircraftClass::~AircraftClass
; _this$ = ecx

; 514  : AircraftClass::~AircraftClass(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AircraftClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AircraftClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 515  : 	CleanupLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLocalData@AircraftClass@@AAEXXZ	; AircraftClass::CleanupLocalData

; 516  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1100				; 0000044cH
	push	ecx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimVehicleClass@@UAE@XZ		; SimVehicleClass::~SimVehicleClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1AircraftClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimVehicleClass@@UAE@XZ		; SimVehicleClass::~SimVehicleClass
__unwindfunclet$??1AircraftClass@@UAE@XZ$1:
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1100				; 0000044cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__ehhandler$??1AircraftClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AircraftClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AircraftClass@@UAE@XZ ENDP				; AircraftClass::~AircraftClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flag$ = 8						; size = 4
_type$ = 12						; size = 4
??0AircraftClass@@QAE@HH@Z PROC				; AircraftClass::AircraftClass
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AircraftClass@@QAE@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimVehicleClass@@QAE@H@Z		; SimVehicleClass::SimVehicleClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7AircraftClass@@6B@
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	OFFSET ??0BasicWeaponStation@@QAE@XZ	; BasicWeaponStation::BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1100				; 0000044cH
	push	edx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 171  : 	InitLocalData(flag);

	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@AircraftClass@@AAEXH@Z	; AircraftClass::InitLocalData

; 172  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AircraftClass@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimVehicleClass@@UAE@XZ		; SimVehicleClass::~SimVehicleClass
__unwindfunclet$??0AircraftClass@@QAE@HH@Z$1:
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1100				; 0000044cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__ehhandler$??0AircraftClass@@QAE@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AircraftClass@@QAE@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AircraftClass@@QAE@HH@Z ENDP				; AircraftClass::AircraftClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flag$ = 8						; size = 4
_filePtr$ = 12						; size = 4
??0AircraftClass@@QAE@HPAU_iobuf@@@Z PROC		; AircraftClass::AircraftClass
; _this$ = ecx

; 165  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AircraftClass@@QAE@HPAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _filePtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimVehicleClass@@QAE@PAU_iobuf@@@Z	; SimVehicleClass::SimVehicleClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7AircraftClass@@6B@
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	OFFSET ??0BasicWeaponStation@@QAE@XZ	; BasicWeaponStation::BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1100				; 0000044cH
	push	edx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 166  : 	InitLocalData(flag);

	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@AircraftClass@@AAEXH@Z	; AircraftClass::InitLocalData

; 167  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AircraftClass@@QAE@HPAU_iobuf@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimVehicleClass@@UAE@XZ		; SimVehicleClass::~SimVehicleClass
__unwindfunclet$??0AircraftClass@@QAE@HPAU_iobuf@@@Z$1:
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1100				; 0000044cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__ehhandler$??0AircraftClass@@QAE@HPAU_iobuf@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AircraftClass@@QAE@HPAU_iobuf@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AircraftClass@@QAE@HPAU_iobuf@@@Z ENDP		; AircraftClass::AircraftClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flag$ = 8						; size = 4
_stream$ = 12						; size = 4
_rem$ = 16						; size = 4
??0AircraftClass@@QAE@HPAPAEPAJ@Z PROC			; AircraftClass::AircraftClass
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AircraftClass@@QAE@HPAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimVehicleClass@@QAE@PAPAEPAJ@Z	; SimVehicleClass::SimVehicleClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7AircraftClass@@6B@
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	OFFSET ??0BasicWeaponStation@@QAE@XZ	; BasicWeaponStation::BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1100				; 0000044cH
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 161  : 	InitLocalData(flag);

	mov	ecx, DWORD PTR _flag$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@AircraftClass@@AAEXH@Z	; AircraftClass::InitLocalData

; 162  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AircraftClass@@QAE@HPAPAEPAJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimVehicleClass@@UAE@XZ		; SimVehicleClass::~SimVehicleClass
__unwindfunclet$??0AircraftClass@@QAE@HPAPAEPAJ@Z$1:
	push	OFFSET ??1BasicWeaponStation@@UAE@XZ	; BasicWeaponStation::~BasicWeaponStation
	push	3
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1100				; 0000044cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__ehhandler$??0AircraftClass@@QAE@HPAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AircraftClass@@QAE@HPAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AircraftClass@@QAE@HPAPAEPAJ@Z ENDP			; AircraftClass::AircraftClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetiffEnabled@AircraftClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetiffEnabled@AircraftClass@@UAEHXZ PROC		; AircraftClass::GetiffEnabled, COMDAT
; _this$ = ecx

; 296  : 	virtual int GetiffEnabled (void){ return iffEnabled; } //Cobra 11/20/04

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+896]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetiffEnabled@AircraftClass@@UAEHXZ ENDP		; AircraftClass::GetiffEnabled
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -72						; size = 4
_refuelRate$3 = -68					; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
_xd$7 = -52						; size = 4
_yd$8 = -48						; size = 4
_refuelRate$9 = -44					; size = 4
tv216 = -40						; size = 4
_dist$10 = -36						; size = 4
_gy$11 = -32						; size = 2
_gx$12 = -28						; size = 2
_nearest$13 = -24					; size = 4
_this$ = -20						; size = 4
_pos$14 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?HotPitRefuel@AircraftClass@@QAEXXZ PROC		; AircraftClass::HotPitRefuel
; _this$ = ecx

; 3438 : void AircraftClass::HotPitRefuel(){

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3439 : 	if (SimDriver.RunningDogfight() && af->vt <= 0.0f && OnGround()){	

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningDogfight@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningDogfight
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@HotPitRefu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+1120]
	jb	SHORT $LN6@HotPitRefu
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN6@HotPitRefu
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1253 : 	float GetRefuelRate(void) {return auxaeroData->refuelRate; }

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+2556]
	movss	DWORD PTR _refuelRate$3[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3441 :  		af->AddFuel(refuelRate * SimLibMajorFrameTime);

	movss	xmm0, DWORD PTR _refuelRate$3[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?AddFuel@AirframeClass@@QAEHM@Z		; AirframeClass::AddFuel
	jmp	$LN1@HotPitRefu
$LN6@HotPitRefu:

; 3443 : 	else if (af->vt <= 0.0f && OnGround() && !af->IsSet(AirframeClass::OverRunway)){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+1120]
	jb	$LN1@HotPitRefu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN1@HotPitRefu
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+88]
	and	eax, 8388608				; 00800000H
	je	SHORT $LN27@HotPitRefu
	mov	DWORD PTR tv216[ebp], 1
	jmp	SHORT $LN28@HotPitRefu
$LN27@HotPitRefu:
	mov	DWORD PTR tv216[ebp], 0
$LN28@HotPitRefu:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3443 : 	else if (af->vt <= 0.0f && OnGround() && !af->IsSet(AirframeClass::OverRunway)){

	cmp	DWORD PTR tv216[ebp], 0
	jne	$LN1@HotPitRefu

; 3444 : 		// sfr: fixing xy order
; 3445 : 		GridIndex gx, gy;
; 3446 : 		::vector pos = { af->x, af->y };

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR _pos$14[ebp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR _pos$14[ebp+4], xmm0
	xor	edx, edx
	mov	DWORD PTR _pos$14[ebp+8], edx

; 3447 : 		ConvertSimToGrid(&pos, &gx, &gy);

	lea	eax, DWORD PTR _gy$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _gx$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$14[ebp]
	push	edx
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h

; 56   : 		return e;

	mov	eax, DWORD PTR ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	mov	DWORD PTR $T6[ebp], eax
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3452 : 		);

	movzx	ecx, WORD PTR _gy$11[ebp]
	push	ecx
	movzx	edx, WORD PTR _gx$12[ebp]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	eax, al
	push	eax
	call	?FindNearestFriendlyRunway@@YAPAVObjectiveClass@@EFF@Z ; FindNearestFriendlyRunway
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nearest$13[ebp], eax

; 3453 :  		if (nearest){

	cmp	DWORD PTR _nearest$13[ebp], 0
	je	$LN1@HotPitRefu

; 3454 :  			float dist = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dist$10[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	mov	ecx, DWORD PTR _nearest$13[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3455 : 			BIG_SCALAR xd = nearest->XPos() - af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR $T4[ebp]
	subss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR _xd$7[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	mov	ecx, DWORD PTR _nearest$13[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3456 : 			BIG_SCALAR yd = nearest->YPos() - af->y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR $T2[ebp]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _yd$8[ebp], xmm0

; 3457 :  			dist = (sqrt(xd * xd + yd * yd)*FT_TO_NM);

	movss	xmm0, DWORD PTR _yd$8[ebp]
	mulss	xmm0, DWORD PTR _yd$8[ebp]
	movss	xmm1, DWORD PTR _xd$7[ebp]
	mulss	xmm1, DWORD PTR _xd$7[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h

; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR $T1[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR $T1[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	movss	xmm0, DWORD PTR $T1[ebp]
	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3457 :  			dist = (sqrt(xd * xd + yd * yd)*FT_TO_NM);

	movss	xmm0, DWORD PTR $T5[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	DWORD PTR _dist$10[ebp], xmm0

; 3458 :   			if (dist < 1.0f && requestHotpitRefuel == TRUE){

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _dist$10[ebp]
	jbe	SHORT $LN1@HotPitRefu
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+895]
	cmp	edx, 1
	jne	SHORT $LN1@HotPitRefu
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h

; 1253 : 	float GetRefuelRate(void) {return auxaeroData->refuelRate; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [edx+2556]
	movss	DWORD PTR _refuelRate$9[ebp], xmm0
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3460 :  				af->AddFuel(refuelRate * SimLibMajorFrameTime);

	movss	xmm0, DWORD PTR _refuelRate$9[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?AddFuel@AirframeClass@@QAEHM@Z		; AirframeClass::AddFuel

; 3461 :  				// Turn it off when full
; 3462 :  				if (af->AddFuel(refuelRate *SimLibMajorFrameTime)== FALSE){

	movss	xmm0, DWORD PTR _refuelRate$9[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?AddFuel@AirframeClass@@QAEHM@Z		; AirframeClass::AddFuel
	test	eax, eax
	jne	SHORT $LN1@HotPitRefu

; 3463 :  					requestHotpitRefuel = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+895], 0
$LN1@HotPitRefu:

; 3464 :  				}
; 3465 :  			}
; 3466 :  		}
; 3467 :  
; 3468 :  	}
; 3469 :   }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?HotPitRefuel@AircraftClass@@QAEXXZ ENDP		; AircraftClass::HotPitRefuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 1
?SetCockpitStrobeLight@AircraftClass@@QAEX_N@Z PROC	; AircraftClass::SetCockpitStrobeLight
; _this$ = ecx

; 3250 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3251 : 	CockpitStrobeLight = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _state$[ebp]
	mov	BYTE PTR [eax+894], cl

; 3252 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCockpitStrobeLight@AircraftClass@@QAEX_N@Z ENDP	; AircraftClass::SetCockpitStrobeLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 1
?SetCockpitWingLightFlash@AircraftClass@@QAEX_N@Z PROC	; AircraftClass::SetCockpitWingLightFlash
; _this$ = ecx

; 3246 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3247 : 	CockpitWingLightFlash = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _state$[ebp]
	mov	BYTE PTR [eax+893], cl

; 3248 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCockpitWingLightFlash@AircraftClass@@QAEX_N@Z ENDP	; AircraftClass::SetCockpitWingLightFlash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 1
?SetCockpitWingLight@AircraftClass@@QAEX_N@Z PROC	; AircraftClass::SetCockpitWingLight
; _this$ = ecx

; 3242 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3243 : 	CockpitWingLight = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _state$[ebp]
	mov	BYTE PTR [eax+892], cl

; 3244 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCockpitWingLight@AircraftClass@@QAEX_N@Z ENDP	; AircraftClass::SetCockpitWingLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -4						; size = 4
?AddAVTRSeconds@AircraftClass@@QAEXXZ PROC		; AircraftClass::AddAVTRSeconds
; _this$ = ecx

; 3237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 251  : 	int AVTRState(AVTRStateFlags fl) { return (AVTRFlags & fl) == (unsigned int)fl ? 1 : 0; };

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	and	ecx, 2
	je	SHORT $LN6@AddAVTRSec
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN7@AddAVTRSec
$LN6@AddAVTRSec:
	mov	DWORD PTR tv72[ebp], 0
$LN7@AddAVTRSec:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3238 : 	if(AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO))

	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN1@AddAVTRSec

; 3239 : 		AVTRCountown = 30.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [edx+844], xmm0
$LN1@AddAVTRSec:

; 3240 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddAVTRSeconds@AircraftClass@@QAEXXZ ENDP		; AircraftClass::AddAVTRSeconds
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
?ClearAcStatusBits@AircraftClass@@QAEXH@Z PROC		; AircraftClass::ClearAcStatusBits
; _this$ = ecx

; 3651 : void AircraftClass::ClearAcStatusBits(int bits){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN6@ClearAcSta
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@ClearAcSta
$LN6@ClearAcSta:
	mov	DWORD PTR tv79[ebp], 0
$LN4@ClearAcSta:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3652 : 	if (IsAcStatusBitsSet(bits)){

	movzx	edx, BYTE PTR tv79[ebp]
	test	edx, edx
	je	SHORT $LN2@ClearAcSta

; 3653 : 		status_bits &= ~bits;

	mov	eax, DWORD PTR _bits$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+760]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], eax

; 3654 : 		MakeAircraftDirty(DIRTY_ACSTATUS_BITS, SEND_NOW);

	push	65536					; 00010000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeAircraftDirty@AircraftClass@@QAEXW4DirtyAircraft@1@W4Dirtyness@@@Z ; AircraftClass::MakeAircraftDirty
$LN2@ClearAcSta:

; 3655 : 	}
; 3656 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearAcStatusBits@AircraftClass@@QAEXH@Z ENDP		; AircraftClass::ClearAcStatusBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
?SetAcStatusBits@AircraftClass@@QAEXH@Z PROC		; AircraftClass::SetAcStatusBits
; _this$ = ecx

; 3644 : void AircraftClass::SetAcStatusBits(int bits){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN6@SetAcStatu
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@SetAcStatu
$LN6@SetAcStatu:
	mov	DWORD PTR tv78[ebp], 0
$LN4@SetAcStatu:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3645 : 	if (!IsAcStatusBitsSet(bits)){

	movzx	edx, BYTE PTR tv78[ebp]
	test	edx, edx
	jne	SHORT $LN2@SetAcStatu

; 3646 : 		status_bits |= bits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	or	ecx, DWORD PTR _bits$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], ecx

; 3647 : 		MakeAircraftDirty(DIRTY_ACSTATUS_BITS, SEND_NOW);

	push	65536					; 00010000H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeAircraftDirty@AircraftClass@@QAEXW4DirtyAircraft@1@W4Dirtyness@@@Z ; AircraftClass::MakeAircraftDirty
$LN2@SetAcStatu:

; 3648 : 	}
; 3649 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetAcStatusBits@AircraftClass@@QAEXH@Z ENDP		; AircraftClass::SetAcStatusBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
?ReadDirty@AircraftClass@@QAEXPAPAEPAJ@Z PROC		; AircraftClass::ReadDirty
; _this$ = ecx

; 3621 : void AircraftClass::ReadDirty(unsigned char **stream, long *rem){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3622 : 	memcpychk(&dirty_aircraft, stream, sizeof(dirty_aircraft), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 764				; 000002fcH
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 3623 : 	if (dirty_aircraft & DIRTY_ACSTATUS_BITS){

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+764]
	and	ecx, 1
	je	SHORT $LN2@ReadDirty

; 3624 : 		memcpychk(&status_bits, stream, sizeof(status_bits), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 760				; 000002f8H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN2@ReadDirty:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+760]
	and	eax, 1
	je	SHORT $LN129@ReadDirty
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN127@ReadDirty
$LN129@ReadDirty:
	mov	DWORD PTR tv91[ebp], 0
$LN127@ReadDirty:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp

; 3628 : 	if (IsAcStatusBitsSet(ACSTATUS_PILOT_EJECTED)){

	movzx	ecx, BYTE PTR tv91[ebp]
	test	ecx, ecx
	je	SHORT $LN3@ReadDirty

; 3629 : 		RemovePilot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemovePilot@AircraftClass@@QAEXXZ	; AircraftClass::RemovePilot
$LN3@ReadDirty:

; 3630 : 	}
; 3631 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ReadDirty@AircraftClass@@QAEXPAPAEPAJ@Z ENDP		; AircraftClass::ReadDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_stream$ = -4						; size = 4
_sAdd$ = 8						; size = 4
?WriteDirty@AircraftClass@@QAEXPAPAE@Z PROC		; AircraftClass::WriteDirty
; _this$ = ecx

; 3633 : void AircraftClass::WriteDirty(unsigned char **sAdd){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3634 : 	unsigned char *stream = *sAdd;

	mov	eax, DWORD PTR _sAdd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _stream$[ebp], ecx

; 3635 : 	memcpy(stream, &dirty_aircraft, sizeof(dirty_aircraft)); stream += sizeof(dirty_aircraft);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 764				; 000002fcH
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _stream$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stream$[ebp], ecx

; 3636 : 	if (dirty_aircraft & DIRTY_ACSTATUS_BITS){

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+764]
	and	eax, 1
	je	SHORT $LN1@WriteDirty

; 3637 : 		memcpy(stream, &status_bits, sizeof(status_bits)); stream += sizeof(status_bits);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 760				; 000002f8H
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	add	eax, 4
	mov	DWORD PTR _stream$[ebp], eax
$LN1@WriteDirty:

; 3638 : 	}
; 3639 : 
; 3640 : 	dirty_aircraft = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+764], 0

; 3641 : 	*sAdd = stream;

	mov	edx, DWORD PTR _sAdd$[ebp]
	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], eax

; 3642 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WriteDirty@AircraftClass@@QAEXPAPAE@Z ENDP		; AircraftClass::WriteDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\aircraft\aircraft.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
_score$ = 12						; size = 4
?MakeAircraftDirty@AircraftClass@@QAEXW4DirtyAircraft@1@W4Dirtyness@@@Z PROC ; AircraftClass::MakeAircraftDirty
; _this$ = ecx

; 3613 : void AircraftClass::MakeAircraftDirty(DirtyAircraft bits, Dirtyness score){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3614 : 	if (!IsLocal()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@MakeAircra

; 3615 : 		return;

	jmp	SHORT $LN2@MakeAircra
$LN1@MakeAircra:

; 3616 : 	}
; 3617 : 	dirty_aircraft |= bits;

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+764]
	or	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+764], dl

; 3618 : 	MakeDirty(DIRTY_AIRCRAFT, score);

	mov	ecx, DWORD PTR _score$[ebp]
	push	ecx
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z ; FalconEntity::MakeDirty
$LN2@MakeAircra:

; 3619 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeAircraftDirty@AircraftClass@@QAEXW4DirtyAircraft@1@W4Dirtyness@@@Z ENDP ; AircraftClass::MakeAircraftDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simveh.h
;	COMDAT ?WeaponKeepAlive@SimVehicleClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?WeaponKeepAlive@SimVehicleClass@@UAEXXZ PROC		; SimVehicleClass::WeaponKeepAlive, COMDAT
; _this$ = ecx

; 117  : 	virtual void WeaponKeepAlive( void ) { return; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?WeaponKeepAlive@SimVehicleClass@@UAEXXZ ENDP		; SimVehicleClass::WeaponKeepAlive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simveh.h
;	COMDAT ?IsVehicle@SimVehicleClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsVehicle@SimVehicleClass@@UAEHXZ PROC			; SimVehicleClass::IsVehicle, COMDAT
; _this$ = ecx

; 112  : 	virtual int IsVehicle (void)		{ return TRUE;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVehicle@SimVehicleClass@@UAEHXZ ENDP			; SimVehicleClass::IsVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ?memcpychk@@YAXPAXPAPAEIPAJ@Z
_TEXT	SEGMENT
$T2 = -152						; size = 12
_s$3 = -140						; size = 24
_err$4 = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_rem$ = 20						; size = 4
?memcpychk@@YAXPAXPAPAEIPAJ@Z PROC			; memcpychk, COMDAT

; 25   : inline void memcpychk(void *dst, VU_BYTE **src, size_t size, long *rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 26   : 	if ((size_t)*rem < size){

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN1@memcpychk

; 27   : 		char err[100];
; 28   : 		sprintf(err, "Trying to write %lu bytes to %ld buffer", static_cast<unsigned long>(size), *rem);

	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
	lea	edx, DWORD PTR _err$4[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 29   : 		std::string s(err);

	lea	eax, DWORD PTR _err$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 19   : 	InvalidBufferException(const std::string &msg) : out_of_range(msg){}

	lea	ecx, DWORD PTR _s$3[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	mov	DWORD PTR $T2[ebp], OFFSET ??_7InvalidBufferException@@6B@

; 30   : 		throw InvalidBufferException(s);

	push	OFFSET __TI4?AVInvalidBufferException@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 31   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 964  : 		_Tidy(true);

	push	0
	push	1
	lea	ecx, DWORD PTR _s$3[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
$LN1@memcpychk:
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h

; 32   : 	memcpy(dst, *src, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 33   : 	*rem -= size;

	mov	ecx, DWORD PTR _rem$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [eax], edx

; 34   : 	*src += size;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax], edx
$LN3@memcpychk:

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0:
	lea	ecx, DWORD PTR _s$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?memcpychk@@YAXPAXPAPAEIPAJ@Z ENDP			; memcpychk
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidBufferException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidBufferException@@UAEPAXI@Z PROC		; InvalidBufferException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidBufferException@@UAEPAXI@Z ENDP		; InvalidBufferException::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0InvalidBufferException@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV0@@Z PROC		; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV0@@Z ENDP		; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1InvalidBufferException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InvalidBufferException@@UAE@XZ PROC			; InvalidBufferException::~InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1InvalidBufferException@@UAE@XZ ENDP			; InvalidBufferException::~InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?IsMover@SimMoverClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMover@SimMoverClass@@UAEHXZ PROC			; SimMoverClass::IsMover, COMDAT
; _this$ = ecx

; 145  : 	virtual int IsMover (void) {return TRUE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@SimMoverClass@@UAEHXZ ENDP			; SimMoverClass::IsMover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsDead@SimBaseClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -1						; size = 1
?IsDead@SimBaseClass@@UBEHXZ PROC			; SimBaseClass::IsDead, COMDAT
; _this$ = ecx

; 174  : 	virtual int IsDead() const { return (specialData.flags & OBJ_DEAD ? true : false); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 32					; 00000020H
	je	SHORT $LN3@IsDead
	mov	BYTE PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsDead
$LN3@IsDead:
	mov	BYTE PTR tv68[ebp], 0
$LN4@IsDead:
	movzx	eax, BYTE PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@SimBaseClass@@UBEHXZ ENDP			; SimBaseClass::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsExploding@SimBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsExploding@SimBaseClass@@UAEHXZ PROC			; SimBaseClass::IsExploding, COMDAT
; _this$ = ecx

; 173  : 	virtual int IsExploding () { return (specialData.flags & OBJ_EXPLODING ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 16					; 00000010H
	je	SHORT $LN3@IsExplodin
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsExplodin
$LN3@IsExplodin:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsExplodin:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExploding@SimBaseClass@@UAEHXZ ENDP			; SimBaseClass::IsExploding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?OnGround@SimBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?OnGround@SimBaseClass@@UAEHXZ PROC			; SimBaseClass::OnGround, COMDAT
; _this$ = ecx

; 172  : 	virtual int OnGround () { return (specialData.flags & ON_GROUND ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 128				; 00000080H
	je	SHORT $LN3@OnGround
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@OnGround
$LN3@OnGround:
	mov	DWORD PTR tv68[ebp], 0
$LN4@OnGround:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGround@SimBaseClass@@UAEHXZ ENDP			; SimBaseClass::OnGround
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCountry@SimBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCountry@SimBaseClass@@UAEEXZ PROC			; SimBaseClass::GetCountry, COMDAT
; _this$ = ecx

; 157  : 	virtual uchar GetCountry() { return (uchar)specialData.country; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+180]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCountry@SimBaseClass@@UAEEXZ ENDP			; SimBaseClass::GetCountry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSimBase@SimBaseClass@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSimBase@SimBaseClass@@UAE_NXZ PROC			; SimBaseClass::IsSimBase, COMDAT
; _this$ = ecx

; 152  : 	virtual bool IsSimBase() { return true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSimBase@SimBaseClass@@UAE_NXZ ENDP			; SimBaseClass::IsSimBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		{	// destroy the object

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@default_er

; 316  : 		{	// construct from error code and category

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+4], OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 643  : 			return (error_condition(_Errval, generic_category()));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN9@default_er:

; 316  : 		{	// construct from error code and category

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+4], OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 645  : 			return (error_condition(_Errval, system_category()));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		{	// destroy the object

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		{	// destroy the object

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
tv78 = -12						; size = 4
_this$ = -8						; size = 4
tv81 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 351  : 		}
; 352  : 
; 353  : 	const error_category& category() const _NOEXCEPT
; 354  : 		{	// get category
; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T4[ebp], eax

; 185  : 		return (this == &_Right);

	mov	ecx, DWORD PTR $T4[ebp]
	cmp	ecx, DWORD PTR $T3[ebp]
	jne	SHORT $LN11@operator
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN9@operator
$LN11@operator:
	mov	DWORD PTR tv81[ebp], 0
$LN9@operator:

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	movzx	edx, BYTE PTR tv81[ebp]
	test	edx, edx
	je	SHORT $LN3@operator

; 186  : 		}
; 187  : 
; 188  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 189  : 		{	// compare categories for inequality
; 190  : 		return (!(*this == _Right));
; 191  : 		}
; 192  : 
; 193  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 194  : 		{	// compare categories for order
; 195  : 		return (this < &_Right);
; 196  : 		}
; 197  : 
; 198  : private:
; 199  : 	error_category(const error_category&);	// not defined
; 200  : 
; 201  : 	error_category& operator=(const error_category&);	// not defined
; 202  : 	};
; 203  : 
; 204  : 		// CLASS error_code
; 205  : class error_code
; 206  : 	{	// store an implementation-specific error code and category
; 207  : public:
; 208  : 	typedef error_code _Myt;
; 209  : 
; 210  : 	error_code()
; 211  : 		: _Myval(0),
; 212  : 			_Mycat(&system_category())
; 213  : 		{	// construct non-error
; 214  : 		}
; 215  : 
; 216  : 	error_code(int _Val, const error_category& _Cat)
; 217  : 		: _Myval(_Val), _Mycat(&_Cat)
; 218  : 		{	// construct from error code and category
; 219  : 		}
; 220  : 
; 221  : 	template<class _Enum>
; 222  : 		error_code(_Enum _Errcode,
; 223  : 			typename enable_if<is_error_code_enum<_Enum>::value,
; 224  : 				void>::type ** = 0)
; 225  : 		: _Myval(0), _Mycat(0)
; 226  : 		{	// construct from enumerated error code
; 227  : 		*this = make_error_code(_Errcode);	// using ADL
; 228  : 		}
; 229  : 
; 230  : 	void assign(int _Val, const error_category& _Cat)
; 231  : 		{	// assign error code and category
; 232  : 		_Myval = _Val;
; 233  : 		_Mycat = &_Cat;
; 234  : 		}
; 235  : 
; 236  : 	template<class _Enum>
; 237  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 238  : 			error_code>::type& operator=(_Enum _Errcode)
; 239  : 		{	// assign enumerated error code
; 240  : 		*this = make_error_code(_Errcode);	// using ADL
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	void clear() _NOEXCEPT
; 245  : 		{	// assign non-error
; 246  : 		_Myval = 0;
; 247  : 		_Mycat = &system_category();
; 248  : 		}
; 249  : 
; 250  : 	int value() const
; 251  : 		{	// get error code
; 252  : 		return (_Myval);
; 253  : 		}
; 254  : 
; 255  : 	const error_category& category() const
; 256  : 		{	// get category
; 257  : 		return (*_Mycat);
; 258  : 		}
; 259  : 
; 260  : 	error_condition default_error_condition() const;
; 261  : 
; 262  : 	string message() const
; 263  : 		{	// get name of error code
; 264  : 		return (category().message(value()));
; 265  : 		}
; 266  : 
; 267  : 	_TYPEDEF_BOOL_TYPE;
; 268  : 
; 269  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 270  : 		{	// test for actual error
; 271  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 272  : 		}
; 273  : 
; 274  : 	bool operator!() const _NOEXCEPT
; 275  : 		{	// test for actual error
; 276  : 		return (value() == 0);
; 277  : 		}
; 278  : 
; 279  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 280  : 		{	// test if *this == _Right
; 281  : 		return (category() == _Right.category()
; 282  : 			&& value() == _Right.value());
; 283  : 		}
; 284  : 
; 285  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 286  : 		{	// test if *this != _Right
; 287  : 		return (!(*this == _Right));
; 288  : 		}
; 289  : 
; 290  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 291  : 		{	// test if *this == _Right
; 292  : 		return (category() < _Right.category()
; 293  : 			|| category() == _Right.category()
; 294  : 				&& value() < _Right.value());
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	int _Myval;	// the stored error number
; 299  : 	const error_category *_Mycat;	// pointer to error category
; 300  : 	};
; 301  : 
; 302  : 		// CLASS error_condition
; 303  : class error_condition
; 304  : 	{	// store an abstract error code and category
; 305  : public:
; 306  : 	typedef error_condition _Myt;
; 307  : 
; 308  : 	error_condition() _NOEXCEPT
; 309  : 		: _Myval(0),
; 310  : 			_Mycat(&generic_category())
; 311  : 		{	// construct non-error
; 312  : 		}
; 313  : 
; 314  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 315  : 		: _Myval(_Val), _Mycat(&_Cat)
; 316  : 		{	// construct from error code and category
; 317  : 		}
; 318  : 
; 319  : 	template<class _Enum>
; 320  : 		error_condition(_Enum _Errcode,
; 321  : 			typename enable_if<is_error_condition_enum<_Enum>::value,
; 322  : 				void>::type ** = 0) _NOEXCEPT
; 323  : 		: _Myval(0), _Mycat(0)
; 324  : 		{	// construct from enumerated error code
; 325  : 		*this = make_error_condition(_Errcode);	// using ADL
; 326  : 		}
; 327  : 
; 328  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 329  : 		{	// assign error code and category
; 330  : 		_Myval = _Val;
; 331  : 		_Mycat = &_Cat;
; 332  : 		}
; 333  : 
; 334  : 	template<class _Enum>
; 335  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 336  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 337  : 		{	// assign enumerated error code
; 338  : 		*this = make_error_condition(_Errcode);	// using ADL
; 339  : 		return (*this);
; 340  : 		}
; 341  : 
; 342  : 	void clear() _NOEXCEPT
; 343  : 		{	// assign non-error
; 344  : 		_Myval = 0;
; 345  : 		_Mycat = &generic_category();
; 346  : 		}
; 347  : 
; 348  : 	int value() const _NOEXCEPT
; 349  : 		{	// get error code
; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T1[ebp], eax

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR $T2[ebp]
	cmp	ecx, DWORD PTR $T1[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		{	// destroy the object

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
tv77 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 253  : 		}
; 254  : 
; 255  : 	const error_category& category() const
; 256  : 		{	// get category
; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR __Code$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR $T2[ebp]
	jne	SHORT $LN9@equivalent
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN7@equivalent
$LN9@equivalent:
	mov	DWORD PTR tv77[ebp], 0
$LN7@equivalent:

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	movzx	eax, BYTE PTR tv77[ebp]
	test	eax, eax
	je	SHORT $LN3@equivalent

; 186  : 		}
; 187  : 
; 188  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 189  : 		{	// compare categories for inequality
; 190  : 		return (!(*this == _Right));
; 191  : 		}
; 192  : 
; 193  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 194  : 		{	// compare categories for order
; 195  : 		return (this < &_Right);
; 196  : 		}
; 197  : 
; 198  : private:
; 199  : 	error_category(const error_category&);	// not defined
; 200  : 
; 201  : 	error_category& operator=(const error_category&);	// not defined
; 202  : 	};
; 203  : 
; 204  : 		// CLASS error_code
; 205  : class error_code
; 206  : 	{	// store an implementation-specific error code and category
; 207  : public:
; 208  : 	typedef error_code _Myt;
; 209  : 
; 210  : 	error_code()
; 211  : 		: _Myval(0),
; 212  : 			_Mycat(&system_category())
; 213  : 		{	// construct non-error
; 214  : 		}
; 215  : 
; 216  : 	error_code(int _Val, const error_category& _Cat)
; 217  : 		: _Myval(_Val), _Mycat(&_Cat)
; 218  : 		{	// construct from error code and category
; 219  : 		}
; 220  : 
; 221  : 	template<class _Enum>
; 222  : 		error_code(_Enum _Errcode,
; 223  : 			typename enable_if<is_error_code_enum<_Enum>::value,
; 224  : 				void>::type ** = 0)
; 225  : 		: _Myval(0), _Mycat(0)
; 226  : 		{	// construct from enumerated error code
; 227  : 		*this = make_error_code(_Errcode);	// using ADL
; 228  : 		}
; 229  : 
; 230  : 	void assign(int _Val, const error_category& _Cat)
; 231  : 		{	// assign error code and category
; 232  : 		_Myval = _Val;
; 233  : 		_Mycat = &_Cat;
; 234  : 		}
; 235  : 
; 236  : 	template<class _Enum>
; 237  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 238  : 			error_code>::type& operator=(_Enum _Errcode)
; 239  : 		{	// assign enumerated error code
; 240  : 		*this = make_error_code(_Errcode);	// using ADL
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	void clear() _NOEXCEPT
; 245  : 		{	// assign non-error
; 246  : 		_Myval = 0;
; 247  : 		_Mycat = &system_category();
; 248  : 		}
; 249  : 
; 250  : 	int value() const
; 251  : 		{	// get error code
; 252  : 		return (_Myval);

	mov	ecx, DWORD PTR __Code$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	eax, DWORD PTR $T1[ebp]
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetSEARCHtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSEARCHtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetSEARCHtimer, COMDAT
; _this$ = ecx

; 198  : 	virtual VU_TIME GetSEARCHtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSEARCHtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetAQUIREtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAQUIREtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetAQUIREtimer, COMDAT
; _this$ = ecx

; 197  : 	virtual VU_TIME GetAQUIREtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAQUIREtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetStepSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetStepSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetStepSearchMode, COMDAT
; _this$ = ecx

; 196  : 	virtual void SetStepSearchMode(uchar)					{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStepSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetStepSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSEARCHtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetSEARCHtimer, COMDAT
; _this$ = ecx

; 194  : 	virtual void SetSEARCHtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetAQUIREtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetAQUIREtimer, COMDAT
; _this$ = ecx

; 193  : 	virtual void SetAQUIREtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTaskForce@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTaskForce@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTaskForce, COMDAT
; _this$ = ecx

; 158  : 	virtual int IsTaskForce (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTaskForce@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTaskForce
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTeam@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeam@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTeam, COMDAT
; _this$ = ecx

; 157  : 	virtual int IsTeam (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeam@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPackage@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPackage@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsPackage, COMDAT
; _this$ = ecx

; 156  : 	virtual int IsPackage (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPackage@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSquadron@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSquadron@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSquadron, COMDAT
; _this$ = ecx

; 155  : 	virtual int IsSquadron (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSquadron@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsFlight@FalconEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlight@FalconEntity@@UBEHXZ PROC			; FalconEntity::IsFlight, COMDAT
; _this$ = ecx

; 154  : 	virtual int IsFlight() const				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlight@FalconEntity@@UBEHXZ ENDP			; FalconEntity::IsFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBrigade@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrigade@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBrigade, COMDAT
; _this$ = ecx

; 153  : 	virtual int IsBrigade (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrigade@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBrigade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBattalion@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBattalion@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBattalion, COMDAT
; _this$ = ecx

; 152  : 	virtual int IsBattalion (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBattalion@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBattalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsObjective@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjective@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsObjective, COMDAT
; _this$ = ecx

; 151  : 	virtual int IsObjective (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsObjective@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsUnit@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnit@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsUnit, COMDAT
; _this$ = ecx

; 150  : 	virtual int IsUnit (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnit@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEmitting@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEmitting, COMDAT
; _this$ = ecx

; 145  : 	virtual int IsEmitting (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsDead@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsDead, COMDAT
; _this$ = ecx

; 144  : 	virtual int IsDead (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsWeapon@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWeapon@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsWeapon, COMDAT
; _this$ = ecx

; 142  : 	virtual int IsWeapon (void)   				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWeapon@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsShip@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShip@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsShip, COMDAT
; _this$ = ecx

; 141  : 	virtual int IsShip (void) 			        { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShip@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGroundVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGroundVehicle@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsGroundVehicle, COMDAT
; _this$ = ecx

; 140  : 	virtual int IsGroundVehicle (void) 			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGroundVehicle@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsGroundVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEject@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEject@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEject, COMDAT
; _this$ = ecx

; 138  : 	virtual int IsEject (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEject@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsHelicopter@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHelicopter@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsHelicopter, COMDAT
; _this$ = ecx

; 137  : 	virtual int IsHelicopter (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHelicopter@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsHelicopter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsStatic@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStatic@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsStatic, COMDAT
; _this$ = ecx

; 136  : 	virtual int IsStatic (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStatic@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsStatic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGun@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGun@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsGun, COMDAT
; _this$ = ecx

; 133  : 	virtual int IsGun (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGun@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBomb@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBomb@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBomb, COMDAT
; _this$ = ecx

; 132  : 	virtual int IsBomb (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBomb@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsLauncher@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsLauncher, COMDAT
; _this$ = ecx

; 131  : 	virtual int IsLauncher (void)               { return FALSE; } // MLR 3/4/2004 - rocket pods

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMissile@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMissile@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMissile, COMDAT
; _this$ = ecx

; 130  : 	virtual int IsMissile (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMissile@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_e$ = 8							; size = 4
?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z PROC	; FalconEntity::HasEntity, COMDAT
; _this$ = ecx

; 129  : 	virtual int HasEntity(VuEntity *e) const    { return this == e; } // sfr: added for new driver

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR _e$[ebp]
	jne	SHORT $LN3@HasEntity
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@HasEntity
$LN3@HasEntity:
	mov	DWORD PTR tv69[ebp], 0
$LN4@HasEntity:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z ENDP	; FalconEntity::HasEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetSearchMode, COMDAT
; _this$ = ecx

; 126  : 	virtual void SetSearchMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?ReturnToSearch@FalconEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReturnToSearch@FalconEntity@@UAEXXZ PROC		; FalconEntity::ReturnToSearch, COMDAT
; _this$ = ecx

; 124  : 	virtual void ReturnToSearch (void)			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReturnToSearch@FalconEntity@@UAEXXZ ENDP		; FalconEntity::ReturnToSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetRadarMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetRadarMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetRadarMode, COMDAT
; _this$ = ecx

; 123  : 	virtual void SetRadarMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRadarMode@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@FalconEntity@@UAEHXZ PROC			; FalconEntity::GetRadarMode, COMDAT
; _this$ = ecx

; 121  : 	virtual int GetRadarMode (void)				{ return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@FalconEntity@@UAEHXZ ENDP			; FalconEntity::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCampBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsCampBase, COMDAT
; _this$ = ecx

; 99   : 	virtual bool IsCampBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsCampBase
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv130 = -8						; size = 4
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR __Message$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN8@out_of_ran
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv130[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR __Message$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv130[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

	jmp	SHORT $LN4@out_of_ran
$LN8@out_of_ran:
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR tv130[ebp], ecx
$LN4@out_of_ran:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept

; 145  : 		{	// construct from message string

	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR $T2[ebp], edx

; 38   : 		{	// construct from message string

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@

; 145  : 		{	// construct from message string

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7out_of_range@std@@6B@

; 146  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv167 = -16						; size = 4
__Ptr$2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN25@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN23@Tidy
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv167[ebp], edx
	jmp	SHORT $LN25@Tidy
$LN23@Tidy:
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$2[ebp]
	push	ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv167[ebp], eax
$LN25@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

	mov	edx, DWORD PTR __Ptr$2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN3@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv131 = -12						; size = 4
tv93 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside

; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN8@Inside
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv93[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv93[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN6@Inside
$LN8@Inside:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv93[ebp], ecx
$LN6@Inside:

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	cmp	edx, DWORD PTR tv93[ebp]
	jb	SHORT $LN2@Inside

; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN14@Inside
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv131[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv131[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN12@Inside
$LN14@Inside:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv131[ebp], ecx
$LN12@Inside:

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv131[ebp]
	add	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -20						; size = 4
tv129 = -16						; size = 4
tv149 = -12						; size = 4
__Num$1 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	mov	DWORD PTR __Num$1[ebp], -1

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$1[ebp], 1
	ja	SHORT $LN15@Grow
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN13@Grow
$LN15@Grow:
	mov	eax, DWORD PTR __Num$1[ebp]
	sub	eax, 1
	mov	DWORD PTR tv149[ebp], eax
$LN13@Grow:

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR tv149[ebp]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN6@Grow:

; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	ecx, BYTE PTR __Trim$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jae	SHORT $LN9@Grow
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], ecx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv129[ebp], eax
$LN10@Grow:
	mov	ecx, DWORD PTR tv129[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
tv88 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 517  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN5@Eos
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv88[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv88[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN3@Eos
$LN5@Eos:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
$LN3@Eos:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	ecx, DWORD PTR tv88[ebp]
	add	ecx, DWORD PTR __Newsize$[ebp]
	mov	dl, BYTE PTR $T2[ebp]
	mov	BYTE PTR [ecx], dl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T2 = -128						; size = 4
$T3 = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
tv335 = -112						; size = 4
$T6 = -108						; size = 4
tv198 = -104						; size = 4
$T7 = -100						; size = 4
tv199 = -96						; size = 4
tv307 = -92						; size = 4
$T8 = -88						; size = 4
tv249 = -84						; size = 4
__Num$9 = -80						; size = 4
tv231 = -76						; size = 4
__Num$10 = -72						; size = 4
tv213 = -68						; size = 4
__Num$11 = -64						; size = 4
tv482 = -60						; size = 4
$T12 = -56						; size = 4
__Ptr$ = -52						; size = 4
$T13 = -48						; size = 4
__Ptr$14 = -44						; size = 4
$T15 = -40						; size = 4
__Ptr$16 = -36						; size = 4
$T17 = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T18 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 518  : 		}
; 519  : 
; 520  : 	const value_type *_Myptr() const
; 521  : 		{	// determine current pointer to buffer for nonmutable string
; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);
; 525  : 		}
; 526  : 
; 527  : 	union _Bxty
; 528  : 		{	// storage for small buffer or pointer to larger one
; 529  : 		value_type _Buf[_BUF_SIZE];
; 530  : 		pointer _Ptr;
; 531  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 532  : 		} _Bx;
; 533  : 
; 534  : 	size_type _Mysize;	// current length of string
; 535  : 	size_type _Myres;	// current storage reserved for string
; 536  : 	};
; 537  : 
; 538  : 		// TEMPLATE CLASS _String_alloc
; 539  : template<bool _Al_has_storage,
; 540  : 	class _Alloc_types>
; 541  : 	class _String_alloc
; 542  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 543  : 	{	// base class for basic_string to hold allocator with storage
; 544  : public:
; 545  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 546  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 547  : 
; 548  : 	typedef typename _Alloc_types::_Alty _Alty;
; 549  : 
; 550  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 551  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 552  : 		: _Alval(_Al)
; 553  : 		{	// construct allocator from _Al
; 554  : 		}
; 555  : 
; 556  : 	void _Change_alloc(const _Alty& _Al)
; 557  : 		{	// replace old allocator
; 558  : 		_Alval = _Al;
; 559  : 		}
; 560  : 
; 561  : 	void _Swap_alloc(_Myt& _Right)
; 562  : 		{	// swap allocators
; 563  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 564  : 		}
; 565  : 
; 566  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 567  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 568  : 		: _Alval(_Al)
; 569  : 		{	// construct allocator from _Al
; 570  : 		_Alloc_proxy();
; 571  : 		}
; 572  : 
; 573  : 	~_String_alloc() _NOEXCEPT
; 574  : 		{	// destroy the object
; 575  : 		_Free_proxy();
; 576  : 		}
; 577  : 
; 578  : 	void _Change_alloc(const _Alty& _Al)
; 579  : 		{	// replace old allocator
; 580  : 		_Free_proxy();
; 581  : 		_Alval = _Al;
; 582  : 		_Alloc_proxy();
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alval, _Right._Alval);
; 588  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 589  : 		}
; 590  : 
; 591  : 	void _Alloc_proxy()
; 592  : 		{	// construct proxy from _Alval
; 593  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 594  : 			_Alproxy(_Alval);
; 595  : 		this->_Myproxy = _Alproxy.allocate(1);
; 596  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 597  : 		this->_Myproxy->_Mycont = this;
; 598  : 		}
; 599  : 
; 600  : 	void _Free_proxy()
; 601  : 		{	// destroy proxy
; 602  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 603  : 			_Alproxy(_Alval);
; 604  : 		this->_Orphan_all();
; 605  : 		_Alproxy.destroy(this->_Myproxy);
; 606  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 607  : 		this->_Myproxy = 0;
; 608  : 		}
; 609  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 610  : 
; 611  : 	_Alty& _Getal()
; 612  : 		{	// get reference to allocator
; 613  : 		return (_Alval);
; 614  : 		}
; 615  : 
; 616  : 	const _Alty& _Getal() const
; 617  : 		{	// get reference to allocator
; 618  : 		return (_Alval);
; 619  : 		}
; 620  : 
; 621  : 	_Alty _Alval;	// allocator object for strings
; 622  : 	};
; 623  : 
; 624  : template<class _Alloc_types>
; 625  : 	class _String_alloc<false, _Alloc_types>
; 626  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 627  : 	{	// base class for basic_string to hold allocator with no storage
; 628  : public:
; 629  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 630  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 631  : 
; 632  : 	typedef typename _Alloc_types::_Alty _Alty;
; 633  : 
; 634  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 635  : 	_String_alloc(const _Alloc& = _Alloc())
; 636  : 		{	// construct allocator from _Al
; 637  : 		}
; 638  : 
; 639  : 	void _Change_alloc(const _Alty&)
; 640  : 		{	// replace old allocator
; 641  : 		}
; 642  : 
; 643  : 	void _Swap_alloc(_Myt&)
; 644  : 		{	// swap allocators
; 645  : 		}
; 646  : 
; 647  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 648  : 	_String_alloc(const _Alloc& = _Alloc())
; 649  : 		{	// construct allocator from _Al
; 650  : 		_Alloc_proxy();
; 651  : 		}
; 652  : 
; 653  : 	~_String_alloc() _NOEXCEPT
; 654  : 		{	// destroy the object
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Change_alloc(const _Alty&)
; 659  : 		{	// replace old allocator
; 660  : 		}
; 661  : 
; 662  : 	void _Swap_alloc(_Myt& _Right)
; 663  : 		{	// swap allocators
; 664  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 665  : 		}
; 666  : 
; 667  : 	void _Alloc_proxy()
; 668  : 		{	// construct proxy from _Alval
; 669  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 670  : 			_Alproxy;
; 671  : 		this->_Myproxy = _Alproxy.allocate(1);
; 672  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 673  : 		this->_Myproxy->_Mycont = this;
; 674  : 		}
; 675  : 
; 676  : 	void _Free_proxy()
; 677  : 		{	// destroy proxy
; 678  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 679  : 			_Alproxy;
; 680  : 		this->_Orphan_all();
; 681  : 		_Alproxy.destroy(this->_Myproxy);
; 682  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 683  : 		this->_Myproxy = 0;
; 684  : 		}
; 685  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 686  : 
; 687  : 	_Alty _Getal() const
; 688  : 		{	// get reference to allocator
; 689  : 		return (_Alty());
; 690  : 		}
; 691  : 	};
; 692  : 
; 693  : 		// TEMPLATE CLASS basic_string
; 694  : template<class _Elem,
; 695  : 	class _Traits,
; 696  : 	class _Alloc>
; 697  : 	class basic_string
; 698  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 699  : 			_String_base_types<_Elem, _Alloc> >
; 700  : 	{	// null-terminated transparent array of elements
; 701  : public:
; 702  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 703  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 704  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 705  : 	typedef _Traits traits_type;
; 706  : 	typedef _Alloc allocator_type;
; 707  : 
; 708  : 	typedef typename _Mybase::_Alty _Alty;
; 709  : 
; 710  : 	typedef typename _Mybase::value_type value_type;
; 711  : 	typedef typename _Mybase::size_type size_type;
; 712  : 	typedef typename _Mybase::difference_type difference_type;
; 713  : 	typedef typename _Mybase::pointer pointer;
; 714  : 	typedef typename _Mybase::const_pointer const_pointer;
; 715  : 	typedef typename _Mybase::reference reference;
; 716  : 	typedef typename _Mybase::const_reference const_reference;
; 717  : 
; 718  : 	typedef typename _Mybase::iterator iterator;
; 719  : 	typedef typename _Mybase::const_iterator const_iterator;
; 720  : 
; 721  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 722  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 723  : 
; 724  : 	basic_string(const _Myt& _Right)
; 725  : 
; 726  :  #if _HAS_CPP0X
; 727  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 728  : 
; 729  :  #else /* _HAS_CPP0X */
; 730  : 		: _Mybase(_Right._Getal())
; 731  :  #endif /* _HAS_CPP0X */
; 732  : 
; 733  : 		{	// construct by copying _Right
; 734  : 		_Tidy();
; 735  : 		assign(_Right, 0, npos);
; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();

	mov	DWORD PTR __Num$11[ebp], -1

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$11[ebp], 1
	ja	SHORT $LN22@Copy
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN20@Copy
$LN22@Copy:
	mov	ecx, DWORD PTR __Num$11[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv213[ebp], ecx
$LN20@Copy:

; 2184 : 		if (max_size() < _Newres)

	mov	edx, DWORD PTR tv213[ebp]
	cmp	edx, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	jmp	$LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN46@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	jmp	SHORT $LN8@Copy
$LN46@Copy:

; 518  : 		}
; 519  : 
; 520  : 	const value_type *_Myptr() const
; 521  : 		{	// determine current pointer to buffer for nonmutable string
; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);
; 525  : 		}
; 526  : 
; 527  : 	union _Bxty
; 528  : 		{	// storage for small buffer or pointer to larger one
; 529  : 		value_type _Buf[_BUF_SIZE];
; 530  : 		pointer _Ptr;
; 531  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 532  : 		} _Bx;
; 533  : 
; 534  : 	size_type _Mysize;	// current length of string
; 535  : 	size_type _Myres;	// current storage reserved for string
; 536  : 	};
; 537  : 
; 538  : 		// TEMPLATE CLASS _String_alloc
; 539  : template<bool _Al_has_storage,
; 540  : 	class _Alloc_types>
; 541  : 	class _String_alloc
; 542  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 543  : 	{	// base class for basic_string to hold allocator with storage
; 544  : public:
; 545  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 546  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 547  : 
; 548  : 	typedef typename _Alloc_types::_Alty _Alty;
; 549  : 
; 550  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 551  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 552  : 		: _Alval(_Al)
; 553  : 		{	// construct allocator from _Al
; 554  : 		}
; 555  : 
; 556  : 	void _Change_alloc(const _Alty& _Al)
; 557  : 		{	// replace old allocator
; 558  : 		_Alval = _Al;
; 559  : 		}
; 560  : 
; 561  : 	void _Swap_alloc(_Myt& _Right)
; 562  : 		{	// swap allocators
; 563  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 564  : 		}
; 565  : 
; 566  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 567  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 568  : 		: _Alval(_Al)
; 569  : 		{	// construct allocator from _Al
; 570  : 		_Alloc_proxy();
; 571  : 		}
; 572  : 
; 573  : 	~_String_alloc() _NOEXCEPT
; 574  : 		{	// destroy the object
; 575  : 		_Free_proxy();
; 576  : 		}
; 577  : 
; 578  : 	void _Change_alloc(const _Alty& _Al)
; 579  : 		{	// replace old allocator
; 580  : 		_Free_proxy();
; 581  : 		_Alval = _Al;
; 582  : 		_Alloc_proxy();
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alval, _Right._Alval);
; 588  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 589  : 		}
; 590  : 
; 591  : 	void _Alloc_proxy()
; 592  : 		{	// construct proxy from _Alval
; 593  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 594  : 			_Alproxy(_Alval);
; 595  : 		this->_Myproxy = _Alproxy.allocate(1);
; 596  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 597  : 		this->_Myproxy->_Mycont = this;
; 598  : 		}
; 599  : 
; 600  : 	void _Free_proxy()
; 601  : 		{	// destroy proxy
; 602  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 603  : 			_Alproxy(_Alval);
; 604  : 		this->_Orphan_all();
; 605  : 		_Alproxy.destroy(this->_Myproxy);
; 606  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 607  : 		this->_Myproxy = 0;
; 608  : 		}
; 609  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 610  : 
; 611  : 	_Alty& _Getal()
; 612  : 		{	// get reference to allocator
; 613  : 		return (_Alval);
; 614  : 		}
; 615  : 
; 616  : 	const _Alty& _Getal() const
; 617  : 		{	// get reference to allocator
; 618  : 		return (_Alval);
; 619  : 		}
; 620  : 
; 621  : 	_Alty _Alval;	// allocator object for strings
; 622  : 	};
; 623  : 
; 624  : template<class _Alloc_types>
; 625  : 	class _String_alloc<false, _Alloc_types>
; 626  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 627  : 	{	// base class for basic_string to hold allocator with no storage
; 628  : public:
; 629  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 630  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 631  : 
; 632  : 	typedef typename _Alloc_types::_Alty _Alty;
; 633  : 
; 634  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 635  : 	_String_alloc(const _Alloc& = _Alloc())
; 636  : 		{	// construct allocator from _Al
; 637  : 		}
; 638  : 
; 639  : 	void _Change_alloc(const _Alty&)
; 640  : 		{	// replace old allocator
; 641  : 		}
; 642  : 
; 643  : 	void _Swap_alloc(_Myt&)
; 644  : 		{	// swap allocators
; 645  : 		}
; 646  : 
; 647  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 648  : 	_String_alloc(const _Alloc& = _Alloc())
; 649  : 		{	// construct allocator from _Al
; 650  : 		_Alloc_proxy();
; 651  : 		}
; 652  : 
; 653  : 	~_String_alloc() _NOEXCEPT
; 654  : 		{	// destroy the object
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Change_alloc(const _Alty&)
; 659  : 		{	// replace old allocator
; 660  : 		}
; 661  : 
; 662  : 	void _Swap_alloc(_Myt& _Right)
; 663  : 		{	// swap allocators
; 664  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 665  : 		}
; 666  : 
; 667  : 	void _Alloc_proxy()
; 668  : 		{	// construct proxy from _Alval
; 669  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 670  : 			_Alproxy;
; 671  : 		this->_Myproxy = _Alproxy.allocate(1);
; 672  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 673  : 		this->_Myproxy->_Mycont = this;
; 674  : 		}
; 675  : 
; 676  : 	void _Free_proxy()
; 677  : 		{	// destroy proxy
; 678  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 679  : 			_Alproxy;
; 680  : 		this->_Orphan_all();
; 681  : 		_Alproxy.destroy(this->_Myproxy);
; 682  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 683  : 		this->_Myproxy = 0;
; 684  : 		}
; 685  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 686  : 
; 687  : 	_Alty _Getal() const
; 688  : 		{	// get reference to allocator
; 689  : 		return (_Alty());
; 690  : 		}
; 691  : 	};
; 692  : 
; 693  : 		// TEMPLATE CLASS basic_string
; 694  : template<class _Elem,
; 695  : 	class _Traits,
; 696  : 	class _Alloc>
; 697  : 	class basic_string
; 698  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 699  : 			_String_base_types<_Elem, _Alloc> >
; 700  : 	{	// null-terminated transparent array of elements
; 701  : public:
; 702  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 703  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 704  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 705  : 	typedef _Traits traits_type;
; 706  : 	typedef _Alloc allocator_type;
; 707  : 
; 708  : 	typedef typename _Mybase::_Alty _Alty;
; 709  : 
; 710  : 	typedef typename _Mybase::value_type value_type;
; 711  : 	typedef typename _Mybase::size_type size_type;
; 712  : 	typedef typename _Mybase::difference_type difference_type;
; 713  : 	typedef typename _Mybase::pointer pointer;
; 714  : 	typedef typename _Mybase::const_pointer const_pointer;
; 715  : 	typedef typename _Mybase::reference reference;
; 716  : 	typedef typename _Mybase::const_reference const_reference;
; 717  : 
; 718  : 	typedef typename _Mybase::iterator iterator;
; 719  : 	typedef typename _Mybase::const_iterator const_iterator;
; 720  : 
; 721  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 722  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 723  : 
; 724  : 	basic_string(const _Myt& _Right)
; 725  : 
; 726  :  #if _HAS_CPP0X
; 727  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 728  : 
; 729  :  #else /* _HAS_CPP0X */
; 730  : 		: _Mybase(_Right._Getal())
; 731  :  #endif /* _HAS_CPP0X */
; 732  : 
; 733  : 		{	// construct by copying _Right
; 734  : 		_Tidy();
; 735  : 		assign(_Right, 0, npos);
; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();

	mov	DWORD PTR __Num$10[ebp], -1

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$10[ebp], 1
	ja	SHORT $LN38@Copy
	mov	DWORD PTR tv231[ebp], 1
	jmp	SHORT $LN36@Copy
$LN38@Copy:
	mov	edx, DWORD PTR __Num$10[ebp]
	sub	edx, 1
	mov	DWORD PTR tv231[ebp], edx
$LN36@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shr	ecx, 1
	mov	edx, DWORD PTR tv231[ebp]
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], edx
	ja	SHORT $LN62@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	shr	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Newres$[ebp], edx

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN62@Copy:

; 518  : 		}
; 519  : 
; 520  : 	const value_type *_Myptr() const
; 521  : 		{	// determine current pointer to buffer for nonmutable string
; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);
; 525  : 		}
; 526  : 
; 527  : 	union _Bxty
; 528  : 		{	// storage for small buffer or pointer to larger one
; 529  : 		value_type _Buf[_BUF_SIZE];
; 530  : 		pointer _Ptr;
; 531  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 532  : 		} _Bx;
; 533  : 
; 534  : 	size_type _Mysize;	// current length of string
; 535  : 	size_type _Myres;	// current storage reserved for string
; 536  : 	};
; 537  : 
; 538  : 		// TEMPLATE CLASS _String_alloc
; 539  : template<bool _Al_has_storage,
; 540  : 	class _Alloc_types>
; 541  : 	class _String_alloc
; 542  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 543  : 	{	// base class for basic_string to hold allocator with storage
; 544  : public:
; 545  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 546  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 547  : 
; 548  : 	typedef typename _Alloc_types::_Alty _Alty;
; 549  : 
; 550  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 551  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 552  : 		: _Alval(_Al)
; 553  : 		{	// construct allocator from _Al
; 554  : 		}
; 555  : 
; 556  : 	void _Change_alloc(const _Alty& _Al)
; 557  : 		{	// replace old allocator
; 558  : 		_Alval = _Al;
; 559  : 		}
; 560  : 
; 561  : 	void _Swap_alloc(_Myt& _Right)
; 562  : 		{	// swap allocators
; 563  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 564  : 		}
; 565  : 
; 566  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 567  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 568  : 		: _Alval(_Al)
; 569  : 		{	// construct allocator from _Al
; 570  : 		_Alloc_proxy();
; 571  : 		}
; 572  : 
; 573  : 	~_String_alloc() _NOEXCEPT
; 574  : 		{	// destroy the object
; 575  : 		_Free_proxy();
; 576  : 		}
; 577  : 
; 578  : 	void _Change_alloc(const _Alty& _Al)
; 579  : 		{	// replace old allocator
; 580  : 		_Free_proxy();
; 581  : 		_Alval = _Al;
; 582  : 		_Alloc_proxy();
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alval, _Right._Alval);
; 588  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 589  : 		}
; 590  : 
; 591  : 	void _Alloc_proxy()
; 592  : 		{	// construct proxy from _Alval
; 593  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 594  : 			_Alproxy(_Alval);
; 595  : 		this->_Myproxy = _Alproxy.allocate(1);
; 596  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 597  : 		this->_Myproxy->_Mycont = this;
; 598  : 		}
; 599  : 
; 600  : 	void _Free_proxy()
; 601  : 		{	// destroy proxy
; 602  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 603  : 			_Alproxy(_Alval);
; 604  : 		this->_Orphan_all();
; 605  : 		_Alproxy.destroy(this->_Myproxy);
; 606  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 607  : 		this->_Myproxy = 0;
; 608  : 		}
; 609  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 610  : 
; 611  : 	_Alty& _Getal()
; 612  : 		{	// get reference to allocator
; 613  : 		return (_Alval);
; 614  : 		}
; 615  : 
; 616  : 	const _Alty& _Getal() const
; 617  : 		{	// get reference to allocator
; 618  : 		return (_Alval);
; 619  : 		}
; 620  : 
; 621  : 	_Alty _Alval;	// allocator object for strings
; 622  : 	};
; 623  : 
; 624  : template<class _Alloc_types>
; 625  : 	class _String_alloc<false, _Alloc_types>
; 626  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 627  : 	{	// base class for basic_string to hold allocator with no storage
; 628  : public:
; 629  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 630  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 631  : 
; 632  : 	typedef typename _Alloc_types::_Alty _Alty;
; 633  : 
; 634  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 635  : 	_String_alloc(const _Alloc& = _Alloc())
; 636  : 		{	// construct allocator from _Al
; 637  : 		}
; 638  : 
; 639  : 	void _Change_alloc(const _Alty&)
; 640  : 		{	// replace old allocator
; 641  : 		}
; 642  : 
; 643  : 	void _Swap_alloc(_Myt&)
; 644  : 		{	// swap allocators
; 645  : 		}
; 646  : 
; 647  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 648  : 	_String_alloc(const _Alloc& = _Alloc())
; 649  : 		{	// construct allocator from _Al
; 650  : 		_Alloc_proxy();
; 651  : 		}
; 652  : 
; 653  : 	~_String_alloc() _NOEXCEPT
; 654  : 		{	// destroy the object
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Change_alloc(const _Alty&)
; 659  : 		{	// replace old allocator
; 660  : 		}
; 661  : 
; 662  : 	void _Swap_alloc(_Myt& _Right)
; 663  : 		{	// swap allocators
; 664  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 665  : 		}
; 666  : 
; 667  : 	void _Alloc_proxy()
; 668  : 		{	// construct proxy from _Alval
; 669  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 670  : 			_Alproxy;
; 671  : 		this->_Myproxy = _Alproxy.allocate(1);
; 672  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 673  : 		this->_Myproxy->_Mycont = this;
; 674  : 		}
; 675  : 
; 676  : 	void _Free_proxy()
; 677  : 		{	// destroy proxy
; 678  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 679  : 			_Alproxy;
; 680  : 		this->_Orphan_all();
; 681  : 		_Alproxy.destroy(this->_Myproxy);
; 682  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 683  : 		this->_Myproxy = 0;
; 684  : 		}
; 685  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 686  : 
; 687  : 	_Alty _Getal() const
; 688  : 		{	// get reference to allocator
; 689  : 		return (_Alty());
; 690  : 		}
; 691  : 	};
; 692  : 
; 693  : 		// TEMPLATE CLASS basic_string
; 694  : template<class _Elem,
; 695  : 	class _Traits,
; 696  : 	class _Alloc>
; 697  : 	class basic_string
; 698  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 699  : 			_String_base_types<_Elem, _Alloc> >
; 700  : 	{	// null-terminated transparent array of elements
; 701  : public:
; 702  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 703  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 704  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 705  : 	typedef _Traits traits_type;
; 706  : 	typedef _Alloc allocator_type;
; 707  : 
; 708  : 	typedef typename _Mybase::_Alty _Alty;
; 709  : 
; 710  : 	typedef typename _Mybase::value_type value_type;
; 711  : 	typedef typename _Mybase::size_type size_type;
; 712  : 	typedef typename _Mybase::difference_type difference_type;
; 713  : 	typedef typename _Mybase::pointer pointer;
; 714  : 	typedef typename _Mybase::const_pointer const_pointer;
; 715  : 	typedef typename _Mybase::reference reference;
; 716  : 	typedef typename _Mybase::const_reference const_reference;
; 717  : 
; 718  : 	typedef typename _Mybase::iterator iterator;
; 719  : 	typedef typename _Mybase::const_iterator const_iterator;
; 720  : 
; 721  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 722  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 723  : 
; 724  : 	basic_string(const _Myt& _Right)
; 725  : 
; 726  :  #if _HAS_CPP0X
; 727  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 728  : 
; 729  :  #else /* _HAS_CPP0X */
; 730  : 		: _Mybase(_Right._Getal())
; 731  :  #endif /* _HAS_CPP0X */
; 732  : 
; 733  : 		{	// construct by copying _Right
; 734  : 		_Tidy();
; 735  : 		assign(_Right, 0, npos);
; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();

	mov	DWORD PTR __Num$9[ebp], -1

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$9[ebp], 1
	ja	SHORT $LN54@Copy
	mov	DWORD PTR tv249[ebp], 1
	jmp	SHORT $LN52@Copy
$LN54@Copy:
	mov	ecx, DWORD PTR __Num$9[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv249[ebp], ecx
$LN52@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	edx, DWORD PTR tv249[ebp]
	mov	DWORD PTR __Newres$[ebp], edx
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	mov	DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$16[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR $T17[ebp], 0
	jne	SHORT $LN81@Copy

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN80@Copy
$LN81@Copy:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR $T17[ebp], -1
	ja	SHORT $LN78@Copy
	mov	ecx, DWORD PTR $T17[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv199[ebp], eax
	mov	edx, DWORD PTR tv199[ebp]
	mov	DWORD PTR __Ptr$16[ebp], edx
	cmp	DWORD PTR __Ptr$16[ebp], 0
	jne	SHORT $LN80@Copy
$LN78@Copy:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN80@Copy:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$16[ebp]
	mov	DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	$LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	mov	DWORD PTR $T15[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$14[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR $T15[ebp], 0
	jne	SHORT $LN97@Copy

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN96@Copy
$LN97@Copy:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR $T15[ebp], -1
	ja	SHORT $LN94@Copy
	mov	ecx, DWORD PTR $T15[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv198[ebp], eax
	mov	edx, DWORD PTR tv198[ebp]
	mov	DWORD PTR __Ptr$14[ebp], edx
	cmp	DWORD PTR __Ptr$14[ebp], 0
	jne	SHORT $LN96@Copy
$LN94@Copy:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN96@Copy:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$14[ebp]
	mov	DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 517  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN146@Copy
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T13[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T13[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN144@Copy
$LN146@Copy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T13[ebp], eax
$LN144@Copy:

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jne	SHORT $LN152@Copy
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR tv335[ebp], edx
	jmp	SHORT $LN1@Copy
$LN152@Copy:
	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T13[ebp]
	push	ecx
	mov	edx, DWORD PTR $T8[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv335[ebp], eax
$LN1@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T12[ebp], ecx
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN214@Copy
	mov	edx, DWORD PTR $T12[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR tv307[ebp], ecx
	jmp	SHORT $LN215@Copy
$LN214@Copy:
	mov	DWORD PTR tv307[ebp], 0
$LN215@Copy:
	mov	edx, DWORD PTR tv307[ebp]
	mov	DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2212 : 		this->_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T18[ebp], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Oldlen$[ebp]
	mov	DWORD PTR [edx+16], eax

; 517  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN225@Copy
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv482[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv482[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN223@Copy
$LN225@Copy:
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv482[ebp], edx
$LN223@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR tv482[ebp]
	add	eax, DWORD PTR __Oldlen$[ebp]
	mov	cl, BYTE PTR $T18[ebp]
	mov	BYTE PTR [eax], cl
$LN11@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
__Newsize$2 = -20					; size = 4
$T3 = -16						; size = 4
__Ptr$4 = -12						; size = 4
tv149 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");
; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN4@erase:

; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 517  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN21@erase
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv149[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv149[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN19@erase
$LN21@erase:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], eax
$LN19@erase:

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR tv149[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$4[ebp], ecx

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$2[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$2[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jne	SHORT $LN27@erase
	mov	edx, DWORD PTR __Ptr$4[ebp]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN25@erase
$LN27@erase:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Ptr$4[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	ecx
	mov	edx, DWORD PTR __Ptr$4[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv70[ebp], eax
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1327 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
tv167 = -16						; size = 4
tv153 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 517  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN24@assign
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv153[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv153[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN22@assign
$LN24@assign:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv153[ebp], eax
$LN22@assign:

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	sub	edx, DWORD PTR tv153[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@assign

; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN114@assign
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN112@assign
$LN114@assign:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
$LN112@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN120@assign
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv167[ebp], edx
	jmp	SHORT $LN118@assign
$LN120@assign:
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv167[ebp], eax
$LN118@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1136 : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
tv212 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
tv233 = -16						; size = 4
$T6 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T4[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	edx, DWORD PTR $T4[ebp]
	cmp	edx, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");
; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN5@assign:

; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T3[ebp], ecx

; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	edx, DWORD PTR $T3[ebp]
	sub	edx, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], edx

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	mov	DWORD PTR $T5[ebp], eax

; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR $T5[ebp]
	jae	SHORT $LN14@assign

; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");
; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN14@assign:

; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);

	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	$LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 524  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN109@assign
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv233[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv233[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

	jmp	SHORT $LN107@assign
$LN109@assign:
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv233[ebp], edx
$LN107@assign:

; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN115@assign
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

	jmp	SHORT $LN113@assign
$LN115@assign:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T6[ebp], ecx
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Num$[ebp], 0
	jne	SHORT $LN121@assign
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv212[ebp], edx
	jmp	SHORT $LN119@assign
$LN121@assign:
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR tv233[ebp]
	add	ecx, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ecx
	mov	edx, DWORD PTR $T6[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv212[ebp], eax
$LN119@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1117 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
tv183 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN57@basic_stri
	mov	DWORD PTR tv183[ebp], 0
	jmp	SHORT $LN55@basic_stri
$LN57@basic_stri:
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv183[ebp], eax
$LN55@basic_stri:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	edx, DWORD PTR tv183[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 793  : 		assign(_Ptr);
; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
