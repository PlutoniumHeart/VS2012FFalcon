; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\Cockpit\cbbuttons.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?GetSwitch@SimMoverClass@@QAEHH@Z		; SimMoverClass::GetSwitch
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
PUBLIC	?DidEmergencyJettison@SMSClass@@QAEHXZ		; SMSClass::DidEmergencyJettison
PUBLIC	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
PUBLIC	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
PUBLIC	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
PUBLIC	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z	; AircraftClass::IsAcStatusBitsSet
PUBLIC	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
PUBLIC	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z		; AircraftClass::IsOn
PUBLIC	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
PUBLIC	?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ; AircraftClass::MainPower
PUBLIC	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ	; AircraftClass::EWSPGM
PUBLIC	?AVTROn@SimulationDriver@@QAEHXZ		; SimulationDriver::AVTROn
PUBLIC	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
PUBLIC	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
PUBLIC	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag
PUBLIC	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
PUBLIC	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
PUBLIC	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
PUBLIC	?SetFlag@AirframeClass@@QAEXH@Z			; AirframeClass::SetFlag
PUBLIC	?ClearFlag@AirframeClass@@QAEXH@Z		; AirframeClass::ClearFlag
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?AutoDrop@VehRwrClass@@QAEHXZ			; VehRwrClass::AutoDrop
PUBLIC	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
PUBLIC	?SetPage@KneeBoard@@QAEXW4Page@1@@Z		; KneeBoard::SetPage
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	?CBEKneeboardMap@@YAXPAXH@Z			; CBEKneeboardMap
PUBLIC	?CBEKneeboardBrief@@YAXPAXH@Z			; CBEKneeboardBrief
PUBLIC	?CBEKneeboardStpt@@YAXPAXH@Z			; CBEKneeboardStpt
PUBLIC	?CBEAMChaffFlare@@YAXPAXH@Z			; CBEAMChaffFlare
PUBLIC	?CBExAMChaffFlare@@YAXPAXH@Z			; CBExAMChaffFlare
PUBLIC	?CBEHandoffB@@YAXPAXH@Z				; CBEHandoffB
PUBLIC	?CBEPriModeB@@YAXPAXH@Z				; CBEPriModeB
PUBLIC	?CBEUnknownB@@YAXPAXH@Z				; CBEUnknownB
PUBLIC	?CBENavalB@@YAXPAXH@Z				; CBENavalB
PUBLIC	?CBETgtSepB@@YAXPAXH@Z				; CBETgtSepB
PUBLIC	?CBEAuxWarnSearchB@@YAXPAXH@Z			; CBEAuxWarnSearchB
PUBLIC	?CBEAuxWarnAltB@@YAXPAXH@Z			; CBEAuxWarnAltB
PUBLIC	?CBEAuxWarnPwrB@@YAXPAXH@Z			; CBEAuxWarnPwrB
PUBLIC	?CBELandGearSelect@@YAXPAXH@Z			; CBELandGearSelect
PUBLIC	?CBEMasterCaution@@YAXPAXH@Z			; CBEMasterCaution
PUBLIC	?CBEAutoPilot@@YAXPAXH@Z			; CBEAutoPilot
PUBLIC	?CBExAutoPilot@@YAXPAXH@Z			; CBExAutoPilot
PUBLIC	?CBECourseSelect@@YAXPAXH@Z			; CBECourseSelect
PUBLIC	?CBExCourseSelect@@YAXPAXH@Z			; CBExCourseSelect
PUBLIC	?CBEHeadingSelect@@YAXPAXH@Z			; CBEHeadingSelect
PUBLIC	?CBExHeadingSelect@@YAXPAXH@Z			; CBExHeadingSelect
PUBLIC	?CBEChaffDispense@@YAXPAXH@Z			; CBEChaffDispense
PUBLIC	?CBExChaffDispense@@YAXPAXH@Z			; CBExChaffDispense
PUBLIC	?CBEFlareDispense@@YAXPAXH@Z			; CBEFlareDispense
PUBLIC	?CBExFlareDispense@@YAXPAXH@Z			; CBExFlareDispense
PUBLIC	?CBEStoresJettison@@YAXPAXH@Z			; CBEStoresJettison
PUBLIC	?CBExStoresJettison@@YAXPAXH@Z			; CBExStoresJettison
PUBLIC	?CBEAVTRControl@@YAXPAXH@Z			; CBEAVTRControl
PUBLIC	?CBExAVTRControl@@YAXPAXH@Z			; CBExAVTRControl
PUBLIC	?CBExModeSelect@@YAXPAXH@Z			; CBExModeSelect
PUBLIC	?CBEModeSelect@@YAXPAXH@Z			; CBEModeSelect
PUBLIC	?CBExMPO@@YAXPAXH@Z				; CBExMPO
PUBLIC	?CBEMPO@@YAXPAXH@Z				; CBEMPO
PUBLIC	?CBExHornSilencer@@YAXPAXH@Z			; CBExHornSilencer
PUBLIC	?CBEHornSilencer@@YAXPAXH@Z			; CBEHornSilencer
PUBLIC	?CBExHUDColor@@YAXPAXH@Z			; CBExHUDColor
PUBLIC	?CBExMFDButton@@YAXPAXH@Z			; CBExMFDButton
PUBLIC	?CBEOSB_1L@@YAXPAXH@Z				; CBEOSB_1L
PUBLIC	?CBEOSB_2L@@YAXPAXH@Z				; CBEOSB_2L
PUBLIC	?CBEOSB_3L@@YAXPAXH@Z				; CBEOSB_3L
PUBLIC	?CBEOSB_4L@@YAXPAXH@Z				; CBEOSB_4L
PUBLIC	?CBEOSB_5L@@YAXPAXH@Z				; CBEOSB_5L
PUBLIC	?CBEOSB_6L@@YAXPAXH@Z				; CBEOSB_6L
PUBLIC	?CBEOSB_7L@@YAXPAXH@Z				; CBEOSB_7L
PUBLIC	?CBEOSB_8L@@YAXPAXH@Z				; CBEOSB_8L
PUBLIC	?CBEOSB_9L@@YAXPAXH@Z				; CBEOSB_9L
PUBLIC	?CBEOSB_10L@@YAXPAXH@Z				; CBEOSB_10L
PUBLIC	?CBEOSB_11L@@YAXPAXH@Z				; CBEOSB_11L
PUBLIC	?CBEOSB_12L@@YAXPAXH@Z				; CBEOSB_12L
PUBLIC	?CBEOSB_13L@@YAXPAXH@Z				; CBEOSB_13L
PUBLIC	?CBEOSB_14L@@YAXPAXH@Z				; CBEOSB_14L
PUBLIC	?CBEOSB_15L@@YAXPAXH@Z				; CBEOSB_15L
PUBLIC	?CBEOSB_16L@@YAXPAXH@Z				; CBEOSB_16L
PUBLIC	?CBEOSB_17L@@YAXPAXH@Z				; CBEOSB_17L
PUBLIC	?CBEOSB_18L@@YAXPAXH@Z				; CBEOSB_18L
PUBLIC	?CBEOSB_19L@@YAXPAXH@Z				; CBEOSB_19L
PUBLIC	?CBEOSB_20L@@YAXPAXH@Z				; CBEOSB_20L
PUBLIC	?CBEOSB_1R@@YAXPAXH@Z				; CBEOSB_1R
PUBLIC	?CBEOSB_2R@@YAXPAXH@Z				; CBEOSB_2R
PUBLIC	?CBEOSB_3R@@YAXPAXH@Z				; CBEOSB_3R
PUBLIC	?CBEOSB_4R@@YAXPAXH@Z				; CBEOSB_4R
PUBLIC	?CBEOSB_5R@@YAXPAXH@Z				; CBEOSB_5R
PUBLIC	?CBEOSB_6R@@YAXPAXH@Z				; CBEOSB_6R
PUBLIC	?CBEOSB_7R@@YAXPAXH@Z				; CBEOSB_7R
PUBLIC	?CBEOSB_8R@@YAXPAXH@Z				; CBEOSB_8R
PUBLIC	?CBEOSB_9R@@YAXPAXH@Z				; CBEOSB_9R
PUBLIC	?CBEOSB_10R@@YAXPAXH@Z				; CBEOSB_10R
PUBLIC	?CBEOSB_11R@@YAXPAXH@Z				; CBEOSB_11R
PUBLIC	?CBEOSB_12R@@YAXPAXH@Z				; CBEOSB_12R
PUBLIC	?CBEOSB_13R@@YAXPAXH@Z				; CBEOSB_13R
PUBLIC	?CBEOSB_14R@@YAXPAXH@Z				; CBEOSB_14R
PUBLIC	?CBEOSB_15R@@YAXPAXH@Z				; CBEOSB_15R
PUBLIC	?CBEOSB_16R@@YAXPAXH@Z				; CBEOSB_16R
PUBLIC	?CBEOSB_17R@@YAXPAXH@Z				; CBEOSB_17R
PUBLIC	?CBEOSB_18R@@YAXPAXH@Z				; CBEOSB_18R
PUBLIC	?CBEOSB_19R@@YAXPAXH@Z				; CBEOSB_19R
PUBLIC	?CBEOSB_20R@@YAXPAXH@Z				; CBEOSB_20R
PUBLIC	?CBEOSB_1T@@YAXPAXH@Z				; CBEOSB_1T
PUBLIC	?CBEOSB_2T@@YAXPAXH@Z				; CBEOSB_2T
PUBLIC	?CBEOSB_3T@@YAXPAXH@Z				; CBEOSB_3T
PUBLIC	?CBEOSB_4T@@YAXPAXH@Z				; CBEOSB_4T
PUBLIC	?CBEOSB_5T@@YAXPAXH@Z				; CBEOSB_5T
PUBLIC	?CBEOSB_6T@@YAXPAXH@Z				; CBEOSB_6T
PUBLIC	?CBEOSB_7T@@YAXPAXH@Z				; CBEOSB_7T
PUBLIC	?CBEOSB_8T@@YAXPAXH@Z				; CBEOSB_8T
PUBLIC	?CBEOSB_9T@@YAXPAXH@Z				; CBEOSB_9T
PUBLIC	?CBEOSB_10T@@YAXPAXH@Z				; CBEOSB_10T
PUBLIC	?CBEOSB_11T@@YAXPAXH@Z				; CBEOSB_11T
PUBLIC	?CBEOSB_12T@@YAXPAXH@Z				; CBEOSB_12T
PUBLIC	?CBEOSB_13T@@YAXPAXH@Z				; CBEOSB_13T
PUBLIC	?CBEOSB_14T@@YAXPAXH@Z				; CBEOSB_14T
PUBLIC	?CBEOSB_15T@@YAXPAXH@Z				; CBEOSB_15T
PUBLIC	?CBEOSB_16T@@YAXPAXH@Z				; CBEOSB_16T
PUBLIC	?CBEOSB_17T@@YAXPAXH@Z				; CBEOSB_17T
PUBLIC	?CBEOSB_18T@@YAXPAXH@Z				; CBEOSB_18T
PUBLIC	?CBEOSB_19T@@YAXPAXH@Z				; CBEOSB_19T
PUBLIC	?CBEOSB_20T@@YAXPAXH@Z				; CBEOSB_20T
PUBLIC	?CBEOSB_1F@@YAXPAXH@Z				; CBEOSB_1F
PUBLIC	?CBEOSB_2F@@YAXPAXH@Z				; CBEOSB_2F
PUBLIC	?CBEOSB_3F@@YAXPAXH@Z				; CBEOSB_3F
PUBLIC	?CBEOSB_4F@@YAXPAXH@Z				; CBEOSB_4F
PUBLIC	?CBEOSB_5F@@YAXPAXH@Z				; CBEOSB_5F
PUBLIC	?CBEOSB_6F@@YAXPAXH@Z				; CBEOSB_6F
PUBLIC	?CBEOSB_7F@@YAXPAXH@Z				; CBEOSB_7F
PUBLIC	?CBEOSB_8F@@YAXPAXH@Z				; CBEOSB_8F
PUBLIC	?CBEOSB_9F@@YAXPAXH@Z				; CBEOSB_9F
PUBLIC	?CBEOSB_10F@@YAXPAXH@Z				; CBEOSB_10F
PUBLIC	?CBEOSB_11F@@YAXPAXH@Z				; CBEOSB_11F
PUBLIC	?CBEOSB_12F@@YAXPAXH@Z				; CBEOSB_12F
PUBLIC	?CBEOSB_13F@@YAXPAXH@Z				; CBEOSB_13F
PUBLIC	?CBEOSB_14F@@YAXPAXH@Z				; CBEOSB_14F
PUBLIC	?CBEOSB_15F@@YAXPAXH@Z				; CBEOSB_15F
PUBLIC	?CBEOSB_16F@@YAXPAXH@Z				; CBEOSB_16F
PUBLIC	?CBEOSB_17F@@YAXPAXH@Z				; CBEOSB_17F
PUBLIC	?CBEOSB_18F@@YAXPAXH@Z				; CBEOSB_18F
PUBLIC	?CBEOSB_19F@@YAXPAXH@Z				; CBEOSB_19F
PUBLIC	?CBEOSB_20F@@YAXPAXH@Z				; CBEOSB_20F
PUBLIC	?CBEThreeGainUp@@YAXPAXH@Z			; CBEThreeGainUp
PUBLIC	?CBEThreeGainDown@@YAXPAXH@Z			; CBEThreeGainDown
PUBLIC	?CBEFourGainDown@@YAXPAXH@Z			; CBEFourGainDown
PUBLIC	?CBEFourGainUp@@YAXPAXH@Z			; CBEFourGainUp
PUBLIC	?CBEICPTILS@@YAXPAXH@Z				; CBEICPTILS
PUBLIC	?CBEICPALOW@@YAXPAXH@Z				; CBEICPALOW
PUBLIC	?CBEICPFAck@@YAXPAXH@Z				; CBEICPFAck
PUBLIC	?CBEICPPrevious@@YAXPAXH@Z			; CBEICPPrevious
PUBLIC	?CBExICPPrevious@@YAXPAXH@Z			; CBExICPPrevious
PUBLIC	?CBEICPNext@@YAXPAXH@Z				; CBEICPNext
PUBLIC	?CBExICPNext@@YAXPAXH@Z				; CBExICPNext
PUBLIC	?CBEICPLink@@YAXPAXH@Z				; CBEICPLink
PUBLIC	?CBEICPCrus@@YAXPAXH@Z				; CBEICPCrus
PUBLIC	?CBEICPStpt@@YAXPAXH@Z				; CBEICPStpt
PUBLIC	?CBEICPMark@@YAXPAXH@Z				; CBEICPMark
PUBLIC	?CBEICPEnter@@YAXPAXH@Z				; CBEICPEnter
PUBLIC	?CBExICPEnter@@YAXPAXH@Z			; CBExICPEnter
PUBLIC	?CBEICPCom1@@YAXPAXH@Z				; CBEICPCom1
PUBLIC	?CBEICPCom2@@YAXPAXH@Z				; CBEICPCom2
PUBLIC	?CBEICPNav@@YAXPAXH@Z				; CBEICPNav
PUBLIC	?CBEICPAA@@YAXPAXH@Z				; CBEICPAA
PUBLIC	?CBEICPAG@@YAXPAXH@Z				; CBEICPAG
PUBLIC	?CBExICPPrimaryExclusive@@YAXPAXH@Z		; CBExICPPrimaryExclusive
PUBLIC	?CBExICPSecondaryExclusive@@YAXPAXH@Z		; CBExICPSecondaryExclusive
PUBLIC	?CBExICPTertiaryExclusive@@YAXPAXH@Z		; CBExICPTertiaryExclusive
PUBLIC	?CBExHUDScales@@YAXPAXH@Z			; CBExHUDScales
PUBLIC	?CBEHUDScales@@YAXPAXH@Z			; CBEHUDScales
PUBLIC	?CBExHUDFPM@@YAXPAXH@Z				; CBExHUDFPM
PUBLIC	?CBEHUDFPM@@YAXPAXH@Z				; CBEHUDFPM
PUBLIC	?CBExHUDDED@@YAXPAXH@Z				; CBExHUDDED
PUBLIC	?CBEHUDDED@@YAXPAXH@Z				; CBEHUDDED
PUBLIC	?CBExHUDDriftCO@@YAXPAXH@Z			; CBExHUDDriftCO
PUBLIC	?CBEHUDDriftCO@@YAXPAXH@Z			; CBEHUDDriftCO
PUBLIC	?CBExHUDVelocity@@YAXPAXH@Z			; CBExHUDVelocity
PUBLIC	?CBEHUDVelocity@@YAXPAXH@Z			; CBEHUDVelocity
PUBLIC	?CBExHUDRadar@@YAXPAXH@Z			; CBExHUDRadar
PUBLIC	?CBEHUDRadar@@YAXPAXH@Z				; CBEHUDRadar
PUBLIC	?CBExHUDBrightness@@YAXPAXH@Z			; CBExHUDBrightness
PUBLIC	?CBEHUDBrightness@@YAXPAXH@Z			; CBEHUDBrightness
PUBLIC	?CBExECMSwitch@@YAXPAXH@Z			; CBExECMSwitch
PUBLIC	?CBEECMSwitch@@YAXPAXH@Z			; CBEECMSwitch
PUBLIC	?CBExUHFSwitch@@YAXPAXH@Z			; CBExUHFSwitch
PUBLIC	?CBEUHFSwitch@@YAXPAXH@Z			; CBEUHFSwitch
PUBLIC	?CBExAuxCommLeft@@YAXPAXH@Z			; CBExAuxCommLeft
PUBLIC	?CBEAuxCommLeft@@YAXPAXH@Z			; CBEAuxCommLeft
PUBLIC	?CBExAuxCommCenter@@YAXPAXH@Z			; CBExAuxCommCenter
PUBLIC	?CBEAuxCommCenter@@YAXPAXH@Z			; CBEAuxCommCenter
PUBLIC	?CBExAuxCommRight@@YAXPAXH@Z			; CBExAuxCommRight
PUBLIC	?CBEAuxCommRight@@YAXPAXH@Z			; CBEAuxCommRight
PUBLIC	?CBExAuxCommBand@@YAXPAXH@Z			; CBExAuxCommBand
PUBLIC	?CBEAuxCommBand@@YAXPAXH@Z			; CBEAuxCommBand
PUBLIC	?CBExEject@@YAXPAXH@Z				; CBExEject
PUBLIC	?CBEEject@@YAXPAXH@Z				; CBEEject
PUBLIC	?CBExAuxCommMaster@@YAXPAXH@Z			; CBExAuxCommMaster
PUBLIC	?CBEAuxCommMaster@@YAXPAXH@Z			; CBEAuxCommMaster
PUBLIC	?CBExAuxCommAATR@@YAXPAXH@Z			; CBExAuxCommAATR
PUBLIC	?CBEAuxCommAATR@@YAXPAXH@Z			; CBEAuxCommAATR
PUBLIC	?CBExUHFMaster@@YAXPAXH@Z			; CBExUHFMaster
PUBLIC	?CBEUHFMaster@@YAXPAXH@Z			; CBEUHFMaster
PUBLIC	?CBExExteriorLite@@YAXPAXH@Z			; CBExExteriorLite
PUBLIC	?CBEExteriorLite@@YAXPAXH@Z			; CBEExteriorLite
PUBLIC	?CBEMasterArm@@YAXPAXH@Z			; CBEMasterArm
PUBLIC	?CBECatIII@@YAXPAXH@Z				; CBECatIII
PUBLIC	?CBERightGainUp@@YAXPAXH@Z			; CBERightGainUp
PUBLIC	?CBERightGainDown@@YAXPAXH@Z			; CBERightGainDown
PUBLIC	?CBELeftGainDown@@YAXPAXH@Z			; CBELeftGainDown
PUBLIC	?CBELeftGainUp@@YAXPAXH@Z			; CBELeftGainUp
PUBLIC	?CBEHUDColor@@YAXPAXH@Z				; CBEHUDColor
PUBLIC	?CBExMasterArm@@YAXPAXH@Z			; CBExMasterArm
PUBLIC	?CBExCatIII@@YAXPAXH@Z				; CBExCatIII
PUBLIC	?CBEJfs@@YAXPAXH@Z				; CBEJfs
PUBLIC	?CBExJfs@@YAXPAXH@Z				; CBExJfs
PUBLIC	?CBEEpu@@YAXPAXH@Z				; CBEEpu
PUBLIC	?CBExEpu@@YAXPAXH@Z				; CBExEpu
PUBLIC	?CBEAltLGear@@YAXPAXH@Z				; CBEAltLGear
PUBLIC	?CBEAltLGearReset@@YAXPAXH@Z			; CBEAltLGearReset
PUBLIC	?CBExAltLGear@@YAXPAXH@Z			; CBExAltLGear
PUBLIC	?CBEICPIFF@@YAXPAXH@Z				; CBEICPIFF
PUBLIC	?CBEICPLIST@@YAXPAXH@Z				; CBEICPLIST
PUBLIC	?CBETHREEButton@@YAXPAXH@Z			; CBETHREEButton
PUBLIC	?CBESIXButton@@YAXPAXH@Z			; CBESIXButton
PUBLIC	?CBEEIGHTButton@@YAXPAXH@Z			; CBEEIGHTButton
PUBLIC	?CBENINEButton@@YAXPAXH@Z			; CBENINEButton
PUBLIC	?CBEZEROButton@@YAXPAXH@Z			; CBEZEROButton
PUBLIC	?CBEResetDEDPage@@YAXPAXH@Z			; CBEResetDEDPage
PUBLIC	?CBEICPDEDUP@@YAXPAXH@Z				; CBEICPDEDUP
PUBLIC	?CBEICPDEDDOWN@@YAXPAXH@Z			; CBEICPDEDDOWN
PUBLIC	?CBEICPDEDSEQ@@YAXPAXH@Z			; CBEICPDEDSEQ
PUBLIC	?CBEICPCLEAR@@YAXPAXH@Z				; CBEICPCLEAR
PUBLIC	?CBExRALTSwitch@@YAXPAXH@Z			; CBExRALTSwitch
PUBLIC	?CBERALTSTDBY@@YAXPAXH@Z			; CBERALTSTDBY
PUBLIC	?CBERALTON@@YAXPAXH@Z				; CBERALTON
PUBLIC	?CBERALTOFF@@YAXPAXH@Z				; CBERALTOFF
PUBLIC	?CBERALTSwitch@@YAXPAXH@Z			; CBERALTSwitch
PUBLIC	?CBESmsPower@@YAXPAXH@Z				; CBESmsPower
PUBLIC	?CBExSmsPower@@YAXPAXH@Z			; CBExSmsPower
PUBLIC	?CBEFCCPower@@YAXPAXH@Z				; CBEFCCPower
PUBLIC	?CBExFCCPower@@YAXPAXH@Z			; CBExFCCPower
PUBLIC	?CBEMFDPower@@YAXPAXH@Z				; CBEMFDPower
PUBLIC	?CBExMFDPower@@YAXPAXH@Z			; CBExMFDPower
PUBLIC	?CBEUFCPower@@YAXPAXH@Z				; CBEUFCPower
PUBLIC	?CBExUFCPower@@YAXPAXH@Z			; CBExUFCPower
PUBLIC	?CBEGPSPower@@YAXPAXH@Z				; CBEGPSPower
PUBLIC	?CBExGPSPower@@YAXPAXH@Z			; CBExGPSPower
PUBLIC	?CBEDLPower@@YAXPAXH@Z				; CBEDLPower
PUBLIC	?CBExDLPower@@YAXPAXH@Z				; CBExDLPower
PUBLIC	?CBEMAPPower@@YAXPAXH@Z				; CBEMAPPower
PUBLIC	?CBExMAPPower@@YAXPAXH@Z			; CBExMAPPower
PUBLIC	?CBELEFTHPTPower@@YAXPAXH@Z			; CBELEFTHPTPower
PUBLIC	?CBExLEFTHPTPower@@YAXPAXH@Z			; CBExLEFTHPTPower
PUBLIC	?CBERIGHTHPTPower@@YAXPAXH@Z			; CBERIGHTHPTPower
PUBLIC	?CBExRIGHTHPTPower@@YAXPAXH@Z			; CBExRIGHTHPTPower
PUBLIC	?CBETISLPower@@YAXPAXH@Z			; CBETISLPower
PUBLIC	?CBExTISLPower@@YAXPAXH@Z			; CBExTISLPower
PUBLIC	?CBEFCRPower@@YAXPAXH@Z				; CBEFCRPower
PUBLIC	?CBExFCRPower@@YAXPAXH@Z			; CBExFCRPower
PUBLIC	?CBEHUDPower@@YAXPAXH@Z				; CBEHUDPower
PUBLIC	?CBExHUDPower@@YAXPAXH@Z			; CBExHUDPower
PUBLIC	?CBEFuelSwitch@@YAXPAXH@Z			; CBEFuelSwitch
PUBLIC	?CBExFuelDisplay@@YAXPAXH@Z			; CBExFuelDisplay
PUBLIC	?CBEFuelPump@@YAXPAXH@Z				; CBEFuelPump
PUBLIC	?CBExFuelPump@@YAXPAXH@Z			; CBExFuelPump
PUBLIC	?CBEFuelCock@@YAXPAXH@Z				; CBEFuelCock
PUBLIC	?CBExFuelCock@@YAXPAXH@Z			; CBExFuelCock
PUBLIC	?CBEFuelExtTrans@@YAXPAXH@Z			; CBEFuelExtTrans
PUBLIC	?CBExFuelExtTrans@@YAXPAXH@Z			; CBExFuelExtTrans
PUBLIC	?CBEAirSource@@YAXPAXH@Z			; CBEAirSource
PUBLIC	?CBExAirSource@@YAXPAXH@Z			; CBExAirSource
PUBLIC	?CBELandingLightToggle@@YAXPAXH@Z		; CBELandingLightToggle
PUBLIC	?CBExLandingLightToggle@@YAXPAXH@Z		; CBExLandingLightToggle
PUBLIC	?CBEParkingBrakeToggle@@YAXPAXH@Z		; CBEParkingBrakeToggle
PUBLIC	?CBExParkingBrakeToggle@@YAXPAXH@Z		; CBExParkingBrakeToggle
PUBLIC	?CBEHookToggle@@YAXPAXH@Z			; CBEHookToggle
PUBLIC	?CBExHookToggle@@YAXPAXH@Z			; CBExHookToggle
PUBLIC	?CBELaserArmToggle@@YAXPAXH@Z			; CBELaserArmToggle
PUBLIC	?CBExLaserArmToggle@@YAXPAXH@Z			; CBExLaserArmToggle
PUBLIC	?CBEFuelDoorToggle@@YAXPAXH@Z			; CBEFuelDoorToggle
PUBLIC	?CBExFuelDoorToggle@@YAXPAXH@Z			; CBExFuelDoorToggle
PUBLIC	?CBERightAPSwitch@@YAXPAXH@Z			; CBERightAPSwitch
PUBLIC	?CBExRightAPSwitch@@YAXPAXH@Z			; CBExRightAPSwitch
PUBLIC	?CBELeftAPSwitch@@YAXPAXH@Z			; CBELeftAPSwitch
PUBLIC	?CBExLeftAPSwitch@@YAXPAXH@Z			; CBExLeftAPSwitch
PUBLIC	?CBEAPOverride@@YAXPAXH@Z			; CBEAPOverride
PUBLIC	?CBEWarnReset@@YAXPAXH@Z			; CBEWarnReset
PUBLIC	?CBExWarnReset@@YAXPAXH@Z			; CBExWarnReset
PUBLIC	?CBEReticleSwitch@@YAXPAXH@Z			; CBEReticleSwitch
PUBLIC	?CBExReticleSwitch@@YAXPAXH@Z			; CBExReticleSwitch
PUBLIC	?CBEInteriorLightSwitch@@YAXPAXH@Z		; CBEInteriorLightSwitch
PUBLIC	?CBExInteriorLightSwitch@@YAXPAXH@Z		; CBExInteriorLightSwitch
PUBLIC	?CBEInstrumentLightSwitch@@YAXPAXH@Z		; CBEInstrumentLightSwitch
PUBLIC	?CBExInstrumentLightSwitch@@YAXPAXH@Z		; CBExInstrumentLightSwitch
PUBLIC	?CBESpotLightSwitch@@YAXPAXH@Z			; CBESpotLightSwitch
PUBLIC	?CBExSpotLightSwitch@@YAXPAXH@Z			; CBExSpotLightSwitch
PUBLIC	?CBESeatArmSwitch@@YAXPAXH@Z			; CBESeatArmSwitch
PUBLIC	?CBExSeatArmSwitch@@YAXPAXH@Z			; CBExSeatArmSwitch
PUBLIC	?CBExEWSRWRPowerSwitch@@YAXPAXH@Z		; CBExEWSRWRPowerSwitch
PUBLIC	?CBEEWSRWRPower@@YAXPAXH@Z			; CBEEWSRWRPower
PUBLIC	?CBExEWSJammerPowerSwitch@@YAXPAXH@Z		; CBExEWSJammerPowerSwitch
PUBLIC	?CBEEWSJammerPower@@YAXPAXH@Z			; CBEEWSJammerPower
PUBLIC	?CBExEWSChaffPowerSwitch@@YAXPAXH@Z		; CBExEWSChaffPowerSwitch
PUBLIC	?CBEEWSChaffPower@@YAXPAXH@Z			; CBEEWSChaffPower
PUBLIC	?CBExEWSFlarePowerSwitch@@YAXPAXH@Z		; CBExEWSFlarePowerSwitch
PUBLIC	?CBEEWSFlarePower@@YAXPAXH@Z			; CBEEWSFlarePower
PUBLIC	?CBExEWSPGMButton@@YAXPAXH@Z			; CBExEWSPGMButton
PUBLIC	?CBEEWSPGMButton@@YAXPAXH@Z			; CBEEWSPGMButton
PUBLIC	?CBExEWSProgButton@@YAXPAXH@Z			; CBExEWSProgButton
PUBLIC	?CBEEWSProgButton@@YAXPAXH@Z			; CBEEWSProgButton
PUBLIC	?CBEMainPower@@YAXPAXH@Z			; CBEMainPower
PUBLIC	?CBExMainPower@@YAXPAXH@Z			; CBExMainPower
PUBLIC	?CBENwsToggle@@YAXPAXH@Z			; CBENwsToggle
PUBLIC	?CBExNwsToggle@@YAXPAXH@Z			; CBExNwsToggle
PUBLIC	?CBEIdleDetent@@YAXPAXH@Z			; CBEIdleDetent
PUBLIC	?CBExIdleDetent@@YAXPAXH@Z			; CBExIdleDetent
PUBLIC	?CBEInhibitVMS@@YAXPAXH@Z			; CBEInhibitVMS
PUBLIC	?CBExInhibitVMS@@YAXPAXH@Z			; CBExInhibitVMS
PUBLIC	?CBERFSwitch@@YAXPAXH@Z				; CBERFSwitch
PUBLIC	?CBExRFSwitch@@YAXPAXH@Z			; CBExRFSwitch
PUBLIC	?CBEGearHandle@@YAXPAXH@Z			; CBEGearHandle
PUBLIC	?CBExGearHandle@@YAXPAXH@Z			; CBExGearHandle
PUBLIC	?CBEPinkySwitch@@YAXPAXH@Z			; CBEPinkySwitch
PUBLIC	?CBEGndJettEnable@@YAXPAXH@Z			; CBEGndJettEnable
PUBLIC	?CBExGndJettEnable@@YAXPAXH@Z			; CBExGndJettEnable
PUBLIC	?CBEExtlPower@@YAXPAXH@Z			; CBEExtlPower
PUBLIC	?CBExExtlPower@@YAXPAXH@Z			; CBExExtlPower
PUBLIC	?CBEExtlAntiColl@@YAXPAXH@Z			; CBEExtlAntiColl
PUBLIC	?CBExExtlAntiColl@@YAXPAXH@Z			; CBExExtlAntiColl
PUBLIC	?CBEExtlSteady@@YAXPAXH@Z			; CBEExtlSteady
PUBLIC	?CBExExtlSteady@@YAXPAXH@Z			; CBExExtlSteady
PUBLIC	?CBEExtlWing@@YAXPAXH@Z				; CBEExtlWing
PUBLIC	?CBExExtlWing@@YAXPAXH@Z			; CBExExtlWing
PUBLIC	?CBEAVTRSwitch@@YAXPAXH@Z			; CBEAVTRSwitch
PUBLIC	?CBExAVTRSwitch@@YAXPAXH@Z			; CBExAVTRSwitch
PUBLIC	?CBEIFFPower@@YAXPAXH@Z				; CBEIFFPower
PUBLIC	?CBExIFFPower@@YAXPAXH@Z			; CBExIFFPower
PUBLIC	?CBEINSSwitch@@YAXPAXH@Z			; CBEINSSwitch
PUBLIC	?CBExINSSwitch@@YAXPAXH@Z			; CBExINSSwitch
PUBLIC	?CBELEFLockSwitch@@YAXPAXH@Z			; CBELEFLockSwitch
PUBLIC	?CBExLEFLockSwitch@@YAXPAXH@Z			; CBExLEFLockSwitch
PUBLIC	?CBEDigitalBUP@@YAXPAXH@Z			; CBEDigitalBUP
PUBLIC	?CBExDigitalBUP@@YAXPAXH@Z			; CBExDigitalBUP
PUBLIC	?CBEAltFlaps@@YAXPAXH@Z				; CBEAltFlaps
PUBLIC	?CBExAltFlaps@@YAXPAXH@Z			; CBExAltFlaps
PUBLIC	?CBEManualFlyup@@YAXPAXH@Z			; CBEManualFlyup
PUBLIC	?CBExManualFlyup@@YAXPAXH@Z			; CBExManualFlyup
PUBLIC	?CBEFLCSReset@@YAXPAXH@Z			; CBEFLCSReset
PUBLIC	?CBExFLCSReset@@YAXPAXH@Z			; CBExFLCSReset
PUBLIC	?CBEFLTBIT@@YAXPAXH@Z				; CBEFLTBIT
PUBLIC	?CBExFLTBIT@@YAXPAXH@Z				; CBExFLTBIT
PUBLIC	?CBEOBOGSBit@@YAXPAXH@Z				; CBEOBOGSBit
PUBLIC	?CBExOBOGSBit@@YAXPAXH@Z			; CBExOBOGSBit
PUBLIC	?CBEMalIndLights@@YAXPAXH@Z			; CBEMalIndLights
PUBLIC	?CBExMalIndLights@@YAXPAXH@Z			; CBExMalIndLights
PUBLIC	?CBEProbeHeat@@YAXPAXH@Z			; CBEProbeHeat
PUBLIC	?CBExProbeHeat@@YAXPAXH@Z			; CBExProbeHeat
PUBLIC	?CBEEPUGEN@@YAXPAXH@Z				; CBEEPUGEN
PUBLIC	?CBExEPUGEN@@YAXPAXH@Z				; CBExEPUGEN
PUBLIC	?CBETestSwitch@@YAXPAXH@Z			; CBETestSwitch
PUBLIC	?CBExTestSwitch@@YAXPAXH@Z			; CBExTestSwitch
PUBLIC	?CBEOverHeat@@YAXPAXH@Z				; CBEOverHeat
PUBLIC	?CBExOverHeat@@YAXPAXH@Z			; CBExOverHeat
PUBLIC	?CBETrimAPDisc@@YAXPAXH@Z			; CBETrimAPDisc
PUBLIC	?CBExTrimAPDisc@@YAXPAXH@Z			; CBExTrimAPDisc
PUBLIC	?CBEMaxPower@@YAXPAXH@Z				; CBEMaxPower
PUBLIC	?CBExMaxPower@@YAXPAXH@Z			; CBExMaxPower
PUBLIC	?CBEABReset@@YAXPAXH@Z				; CBEABReset
PUBLIC	?CBExABReset@@YAXPAXH@Z				; CBExABReset
PUBLIC	?CBETrimNose@@YAXPAXH@Z				; CBETrimNose
PUBLIC	?CBETrimYaw@@YAXPAXH@Z				; CBETrimYaw
PUBLIC	?CBExTrimYaw@@YAXPAXH@Z				; CBExTrimYaw
PUBLIC	?CBETrimRoll@@YAXPAXH@Z				; CBETrimRoll
PUBLIC	?CBEMissileVol@@YAXPAXH@Z			; CBEMissileVol
PUBLIC	?CBExMissileVol@@YAXPAXH@Z			; CBExMissileVol
PUBLIC	?CBEThreatVol@@YAXPAXH@Z			; CBEThreatVol
PUBLIC	?CBExThreatVol@@YAXPAXH@Z			; CBExThreatVol
PUBLIC	?CBEDeprRet@@YAXPAXH@Z				; CBEDeprRet
PUBLIC	?CBExDeprRet@@YAXPAXH@Z				; CBExDeprRet
PUBLIC	?CBETFRButton@@YAXPAXH@Z			; CBETFRButton
PUBLIC	?CBEThrRevButton@@YAXPAXH@Z			; CBEThrRevButton
PUBLIC	?CBEFlap@@YAXPAXH@Z				; CBEFlap
PUBLIC	?CBExFlap@@YAXPAXH@Z				; CBExFlap
PUBLIC	?CBELef@@YAXPAXH@Z				; CBELef
PUBLIC	?CBEDragChute@@YAXPAXH@Z			; CBEDragChute
PUBLIC	?CBExDragChute@@YAXPAXH@Z			; CBExDragChute
PUBLIC	?CBECanopy@@YAXPAXH@Z				; CBECanopy
PUBLIC	?CBExCanopy@@YAXPAXH@Z				; CBExCanopy
PUBLIC	?CBEComm1Vol@@YAXPAXH@Z				; CBEComm1Vol
PUBLIC	?CBExComm1Vol@@YAXPAXH@Z			; CBExComm1Vol
PUBLIC	?CBEComm2Vol@@YAXPAXH@Z				; CBEComm2Vol
PUBLIC	?CBExComm2Vol@@YAXPAXH@Z			; CBExComm2Vol
PUBLIC	?CBESymWheel@@YAXPAXH@Z				; CBESymWheel
PUBLIC	?CBExSymWheel@@YAXPAXH@Z			; CBExSymWheel
PUBLIC	?CBESetNightPanel@@YAXPAXH@Z			; CBESetNightPanel
PUBLIC	?CBEDummyCallback@@YAXPAXH@Z			; CBEDummyCallback
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?SimHookToggle@@YAXKHPAX@Z:PROC			; SimHookToggle
EXTRN	?SimThrottleIdleDetent@@YAXKHPAX@Z:PROC		; SimThrottleIdleDetent
EXTRN	?SimJfsStart@@YAXKHPAX@Z:PROC			; SimJfsStart
EXTRN	?SimEpuToggle@@YAXKHPAX@Z:PROC			; SimEpuToggle
EXTRN	?AFAlternateGear@@YAXKHPAX@Z:PROC		; AFAlternateGear
EXTRN	?AFAlternateGearReset@@YAXKHPAX@Z:PROC		; AFAlternateGearReset
EXTRN	?SimDecLeftAuxComDigit@@YAXKHPAX@Z:PROC		; SimDecLeftAuxComDigit
EXTRN	?SimDecCenterAuxComDigit@@YAXKHPAX@Z:PROC	; SimDecCenterAuxComDigit
EXTRN	?SimDecRightAuxComDigit@@YAXKHPAX@Z:PROC	; SimDecRightAuxComDigit
EXTRN	?SimInteriorLight@@YAXKHPAX@Z:PROC		; SimInteriorLight
EXTRN	?SimInstrumentLight@@YAXKHPAX@Z:PROC		; SimInstrumentLight
EXTRN	?SimSpotLight@@YAXKHPAX@Z:PROC			; SimSpotLight
EXTRN	?SimToggleTFR@@YAXKHPAX@Z:PROC			; SimToggleTFR
EXTRN	?SimMainPowerDec@@YAXKHPAX@Z:PROC		; SimMainPowerDec
EXTRN	?SimMainPowerInc@@YAXKHPAX@Z:PROC		; SimMainPowerInc
EXTRN	?AFIncFlap@@YAXKHPAX@Z:PROC			; AFIncFlap
EXTRN	?AFDecFlap@@YAXKHPAX@Z:PROC			; AFDecFlap
EXTRN	?AFIncLEF@@YAXKHPAX@Z:PROC			; AFIncLEF
EXTRN	?AFDecLEF@@YAXKHPAX@Z:PROC			; AFDecLEF
EXTRN	?AFDragChute@@YAXKHPAX@Z:PROC			; AFDragChute
EXTRN	?AFCanopyToggle@@YAXKHPAX@Z:PROC		; AFCanopyToggle
EXTRN	?SimReverseThrusterToggle@@YAXKHPAX@Z:PROC	; SimReverseThrusterToggle
EXTRN	?SimICPIFF@@YAXKHPAX@Z:PROC			; SimICPIFF
EXTRN	?SimICPLIST@@YAXKHPAX@Z:PROC			; SimICPLIST
EXTRN	?SimICPTHREE@@YAXKHPAX@Z:PROC			; SimICPTHREE
EXTRN	?SimICPSIX@@YAXKHPAX@Z:PROC			; SimICPSIX
EXTRN	?SimICPEIGHT@@YAXKHPAX@Z:PROC			; SimICPEIGHT
EXTRN	?SimICPNINE@@YAXKHPAX@Z:PROC			; SimICPNINE
EXTRN	?SimICPZERO@@YAXKHPAX@Z:PROC			; SimICPZERO
EXTRN	?SimICPResetDED@@YAXKHPAX@Z:PROC		; SimICPResetDED
EXTRN	?SimICPDEDUP@@YAXKHPAX@Z:PROC			; SimICPDEDUP
EXTRN	?SimICPDEDDOWN@@YAXKHPAX@Z:PROC			; SimICPDEDDOWN
EXTRN	?SimICPCLEAR@@YAXKHPAX@Z:PROC			; SimICPCLEAR
EXTRN	?SimICPDEDSEQ@@YAXKHPAX@Z:PROC			; SimICPDEDSEQ
EXTRN	?SimRALTSTDBY@@YAXKHPAX@Z:PROC			; SimRALTSTDBY
EXTRN	?SimRALTON@@YAXKHPAX@Z:PROC			; SimRALTON
EXTRN	?SimRALTOFF@@YAXKHPAX@Z:PROC			; SimRALTOFF
EXTRN	?SimLandingLightToggle@@YAXKHPAX@Z:PROC		; SimLandingLightToggle
EXTRN	?SimParkingBrakeToggle@@YAXKHPAX@Z:PROC		; SimParkingBrakeToggle
EXTRN	?SimLaserArmToggle@@YAXKHPAX@Z:PROC		; SimLaserArmToggle
EXTRN	?SimFuelDoorToggle@@YAXKHPAX@Z:PROC		; SimFuelDoorToggle
EXTRN	?SimRightAPSwitch@@YAXKHPAX@Z:PROC		; SimRightAPSwitch
EXTRN	?SimLeftAPSwitch@@YAXKHPAX@Z:PROC		; SimLeftAPSwitch
EXTRN	?SimAPOverride@@YAXKHPAX@Z:PROC			; SimAPOverride
EXTRN	?SimWarnReset@@YAXKHPAX@Z:PROC			; SimWarnReset
EXTRN	?SimReticleSwitch@@YAXKHPAX@Z:PROC		; SimReticleSwitch
EXTRN	?SimSeatArm@@YAXKHPAX@Z:PROC			; SimSeatArm
EXTRN	?SimEWSRWRPower@@YAXKHPAX@Z:PROC		; SimEWSRWRPower
EXTRN	?SimEWSJammerPower@@YAXKHPAX@Z:PROC		; SimEWSJammerPower
EXTRN	?SimEWSChaffPower@@YAXKHPAX@Z:PROC		; SimEWSChaffPower
EXTRN	?SimEWSFlarePower@@YAXKHPAX@Z:PROC		; SimEWSFlarePower
EXTRN	?SimEWSPGMDec@@YAXKHPAX@Z:PROC			; SimEWSPGMDec
EXTRN	?SimEWSPGMInc@@YAXKHPAX@Z:PROC			; SimEWSPGMInc
EXTRN	?SimEWSProgDec@@YAXKHPAX@Z:PROC			; SimEWSProgDec
EXTRN	?SimEWSProgInc@@YAXKHPAX@Z:PROC			; SimEWSProgInc
EXTRN	?SimInhibitVMS@@YAXKHPAX@Z:PROC			; SimInhibitVMS
EXTRN	?SimRFSwitch@@YAXKHPAX@Z:PROC			; SimRFSwitch
EXTRN	?SimPinkySwitch@@YAXKHPAX@Z:PROC		; SimPinkySwitch
EXTRN	?SimGndJettEnable@@YAXKHPAX@Z:PROC		; SimGndJettEnable
EXTRN	?SimExtlPower@@YAXKHPAX@Z:PROC			; SimExtlPower
EXTRN	?SimExtlAntiColl@@YAXKHPAX@Z:PROC		; SimExtlAntiColl
EXTRN	?SimExtlSteady@@YAXKHPAX@Z:PROC			; SimExtlSteady
EXTRN	?SimExtlWing@@YAXKHPAX@Z:PROC			; SimExtlWing
EXTRN	?SimAVTRSwitch@@YAXKHPAX@Z:PROC			; SimAVTRSwitch
EXTRN	?SimIFFPower@@YAXKHPAX@Z:PROC			; SimIFFPower
EXTRN	?SimINSInc@@YAXKHPAX@Z:PROC			; SimINSInc
EXTRN	?SimINSDec@@YAXKHPAX@Z:PROC			; SimINSDec
EXTRN	?SimLEFLockSwitch@@YAXKHPAX@Z:PROC		; SimLEFLockSwitch
EXTRN	?SimDigitalBUP@@YAXKHPAX@Z:PROC			; SimDigitalBUP
EXTRN	?SimAltFlaps@@YAXKHPAX@Z:PROC			; SimAltFlaps
EXTRN	?SimManualFlyup@@YAXKHPAX@Z:PROC		; SimManualFlyup
EXTRN	?SimFLCSReset@@YAXKHPAX@Z:PROC			; SimFLCSReset
EXTRN	?SimFLTBIT@@YAXKHPAX@Z:PROC			; SimFLTBIT
EXTRN	?SimOBOGSBit@@YAXKHPAX@Z:PROC			; SimOBOGSBit
EXTRN	?SimMalIndLights@@YAXKHPAX@Z:PROC		; SimMalIndLights
EXTRN	?SimProbeHeat@@YAXKHPAX@Z:PROC			; SimProbeHeat
EXTRN	?SimEPUGEN@@YAXKHPAX@Z:PROC			; SimEPUGEN
EXTRN	?SimTestSwitch@@YAXKHPAX@Z:PROC			; SimTestSwitch
EXTRN	?SimOverHeat@@YAXKHPAX@Z:PROC			; SimOverHeat
EXTRN	?SimTrimAPDisc@@YAXKHPAX@Z:PROC			; SimTrimAPDisc
EXTRN	?SimMaxPower@@YAXKHPAX@Z:PROC			; SimMaxPower
EXTRN	?SimABReset@@YAXKHPAX@Z:PROC			; SimABReset
EXTRN	?SimTrimNoseUp@@YAXKHPAX@Z:PROC			; SimTrimNoseUp
EXTRN	?SimTrimNoseDown@@YAXKHPAX@Z:PROC		; SimTrimNoseDown
EXTRN	?SimTrimYawLeft@@YAXKHPAX@Z:PROC		; SimTrimYawLeft
EXTRN	?SimTrimYawRight@@YAXKHPAX@Z:PROC		; SimTrimYawRight
EXTRN	?SimTrimRollLeft@@YAXKHPAX@Z:PROC		; SimTrimRollLeft
EXTRN	?SimTrimRollRight@@YAXKHPAX@Z:PROC		; SimTrimRollRight
EXTRN	?SimStepMissileVolumeDown@@YAXKHPAX@Z:PROC	; SimStepMissileVolumeDown
EXTRN	?SimStepMissileVolumeUp@@YAXKHPAX@Z:PROC	; SimStepMissileVolumeUp
EXTRN	?SimStepThreatVolumeDown@@YAXKHPAX@Z:PROC	; SimStepThreatVolumeDown
EXTRN	?SimStepThreatVolumeUp@@YAXKHPAX@Z:PROC		; SimStepThreatVolumeUp
EXTRN	?SimRetUp@@YAXKHPAX@Z:PROC			; SimRetUp
EXTRN	?SimRetDn@@YAXKHPAX@Z:PROC			; SimRetDn
EXTRN	?SimStepComm1VolumeUp@@YAXKHPAX@Z:PROC		; SimStepComm1VolumeUp
EXTRN	?SimStepComm1VolumeDown@@YAXKHPAX@Z:PROC	; SimStepComm1VolumeDown
EXTRN	?SimStepComm2VolumeUp@@YAXKHPAX@Z:PROC		; SimStepComm2VolumeUp
EXTRN	?SimStepComm2VolumeDown@@YAXKHPAX@Z:PROC	; SimStepComm2VolumeDown
EXTRN	?SimSymWheelUp@@YAXKHPAX@Z:PROC			; SimSymWheelUp
EXTRN	?SimSymWheelDn@@YAXKHPAX@Z:PROC			; SimSymWheelDn
EXTRN	?SimSMSPower@@YAXKHPAX@Z:PROC			; SimSMSPower
EXTRN	?SimFCCPower@@YAXKHPAX@Z:PROC			; SimFCCPower
EXTRN	?SimMFDPower@@YAXKHPAX@Z:PROC			; SimMFDPower
EXTRN	?SimUFCPower@@YAXKHPAX@Z:PROC			; SimUFCPower
EXTRN	?SimGPSPower@@YAXKHPAX@Z:PROC			; SimGPSPower
EXTRN	?SimDLPower@@YAXKHPAX@Z:PROC			; SimDLPower
EXTRN	?SimMAPPower@@YAXKHPAX@Z:PROC			; SimMAPPower
EXTRN	?SimTISLPower@@YAXKHPAX@Z:PROC			; SimTISLPower
EXTRN	?SimRightHptPower@@YAXKHPAX@Z:PROC		; SimRightHptPower
EXTRN	?SimLeftHptPower@@YAXKHPAX@Z:PROC		; SimLeftHptPower
EXTRN	?SimFCRPower@@YAXKHPAX@Z:PROC			; SimFCRPower
EXTRN	?SimHUDPower@@YAXKHPAX@Z:PROC			; SimHUDPower
EXTRN	?SimHUDOn@@YAXKHPAX@Z:PROC			; SimHUDOn
EXTRN	?SimHUDOff@@YAXKHPAX@Z:PROC			; SimHUDOff
EXTRN	?SimToggleAutopilot@@YAXKHPAX@Z:PROC		; SimToggleAutopilot
EXTRN	?SimDropChaff@@YAXKHPAX@Z:PROC			; SimDropChaff
EXTRN	?SimDropFlare@@YAXKHPAX@Z:PROC			; SimDropFlare
EXTRN	?SimToggleDropPattern@@YAXKHPAX@Z:PROC		; SimToggleDropPattern
EXTRN	?SimEject@@YAXKHPAX@Z:PROC			; SimEject
EXTRN	?AFGearToggle@@YAXKHPAX@Z:PROC			; AFGearToggle
EXTRN	?SimDriftCO@@YAXKHPAX@Z:PROC			; SimDriftCO
EXTRN	?SimCATSwitch@@YAXKHPAX@Z:PROC			; SimCATSwitch
EXTRN	?SimEmergencyJettison@@YAXKHPAX@Z:PROC		; SimEmergencyJettison
EXTRN	?SimECMOn@@YAXKHPAX@Z:PROC			; SimECMOn
EXTRN	?SimHsiCourseInc@@YAXKHPAX@Z:PROC		; SimHsiCourseInc
EXTRN	?SimHsiCourseDec@@YAXKHPAX@Z:PROC		; SimHsiCourseDec
EXTRN	?SimHsiHeadingInc@@YAXKHPAX@Z:PROC		; SimHsiHeadingInc
EXTRN	?SimHsiHeadingDec@@YAXKHPAX@Z:PROC		; SimHsiHeadingDec
EXTRN	?SimAVTRToggle@@YAXKHPAX@Z:PROC			; SimAVTRToggle
EXTRN	?SimMPOToggle@@YAXKHPAX@Z:PROC			; SimMPOToggle
EXTRN	?SimSilenceHorn@@YAXKHPAX@Z:PROC		; SimSilenceHorn
EXTRN	?SimStepHSIMode@@YAXKHPAX@Z:PROC		; SimStepHSIMode
EXTRN	?SimCBEOSB_1L@@YAXKHPAX@Z:PROC			; SimCBEOSB_1L
EXTRN	?SimCBEOSB_2L@@YAXKHPAX@Z:PROC			; SimCBEOSB_2L
EXTRN	?SimCBEOSB_3L@@YAXKHPAX@Z:PROC			; SimCBEOSB_3L
EXTRN	?SimCBEOSB_4L@@YAXKHPAX@Z:PROC			; SimCBEOSB_4L
EXTRN	?SimCBEOSB_5L@@YAXKHPAX@Z:PROC			; SimCBEOSB_5L
EXTRN	?SimCBEOSB_6L@@YAXKHPAX@Z:PROC			; SimCBEOSB_6L
EXTRN	?SimCBEOSB_7L@@YAXKHPAX@Z:PROC			; SimCBEOSB_7L
EXTRN	?SimCBEOSB_8L@@YAXKHPAX@Z:PROC			; SimCBEOSB_8L
EXTRN	?SimCBEOSB_9L@@YAXKHPAX@Z:PROC			; SimCBEOSB_9L
EXTRN	?SimCBEOSB_10L@@YAXKHPAX@Z:PROC			; SimCBEOSB_10L
EXTRN	?SimCBEOSB_11L@@YAXKHPAX@Z:PROC			; SimCBEOSB_11L
EXTRN	?SimCBEOSB_12L@@YAXKHPAX@Z:PROC			; SimCBEOSB_12L
EXTRN	?SimCBEOSB_13L@@YAXKHPAX@Z:PROC			; SimCBEOSB_13L
EXTRN	?SimCBEOSB_14L@@YAXKHPAX@Z:PROC			; SimCBEOSB_14L
EXTRN	?SimCBEOSB_15L@@YAXKHPAX@Z:PROC			; SimCBEOSB_15L
EXTRN	?SimCBEOSB_16L@@YAXKHPAX@Z:PROC			; SimCBEOSB_16L
EXTRN	?SimCBEOSB_17L@@YAXKHPAX@Z:PROC			; SimCBEOSB_17L
EXTRN	?SimCBEOSB_18L@@YAXKHPAX@Z:PROC			; SimCBEOSB_18L
EXTRN	?SimCBEOSB_19L@@YAXKHPAX@Z:PROC			; SimCBEOSB_19L
EXTRN	?SimCBEOSB_20L@@YAXKHPAX@Z:PROC			; SimCBEOSB_20L
EXTRN	?SimCBEOSB_1R@@YAXKHPAX@Z:PROC			; SimCBEOSB_1R
EXTRN	?SimCBEOSB_2R@@YAXKHPAX@Z:PROC			; SimCBEOSB_2R
EXTRN	?SimCBEOSB_3R@@YAXKHPAX@Z:PROC			; SimCBEOSB_3R
EXTRN	?SimCBEOSB_4R@@YAXKHPAX@Z:PROC			; SimCBEOSB_4R
EXTRN	?SimCBEOSB_5R@@YAXKHPAX@Z:PROC			; SimCBEOSB_5R
EXTRN	?SimCBEOSB_6R@@YAXKHPAX@Z:PROC			; SimCBEOSB_6R
EXTRN	?SimCBEOSB_7R@@YAXKHPAX@Z:PROC			; SimCBEOSB_7R
EXTRN	?SimCBEOSB_8R@@YAXKHPAX@Z:PROC			; SimCBEOSB_8R
EXTRN	?SimCBEOSB_9R@@YAXKHPAX@Z:PROC			; SimCBEOSB_9R
EXTRN	?SimCBEOSB_10R@@YAXKHPAX@Z:PROC			; SimCBEOSB_10R
EXTRN	?SimCBEOSB_11R@@YAXKHPAX@Z:PROC			; SimCBEOSB_11R
EXTRN	?SimCBEOSB_12R@@YAXKHPAX@Z:PROC			; SimCBEOSB_12R
EXTRN	?SimCBEOSB_13R@@YAXKHPAX@Z:PROC			; SimCBEOSB_13R
EXTRN	?SimCBEOSB_14R@@YAXKHPAX@Z:PROC			; SimCBEOSB_14R
EXTRN	?SimCBEOSB_15R@@YAXKHPAX@Z:PROC			; SimCBEOSB_15R
EXTRN	?SimCBEOSB_16R@@YAXKHPAX@Z:PROC			; SimCBEOSB_16R
EXTRN	?SimCBEOSB_17R@@YAXKHPAX@Z:PROC			; SimCBEOSB_17R
EXTRN	?SimCBEOSB_18R@@YAXKHPAX@Z:PROC			; SimCBEOSB_18R
EXTRN	?SimCBEOSB_19R@@YAXKHPAX@Z:PROC			; SimCBEOSB_19R
EXTRN	?SimCBEOSB_20R@@YAXKHPAX@Z:PROC			; SimCBEOSB_20R
EXTRN	?SimCBEOSB_1T@@YAXKHPAX@Z:PROC			; SimCBEOSB_1T
EXTRN	?SimCBEOSB_2T@@YAXKHPAX@Z:PROC			; SimCBEOSB_2T
EXTRN	?SimCBEOSB_3T@@YAXKHPAX@Z:PROC			; SimCBEOSB_3T
EXTRN	?SimCBEOSB_4T@@YAXKHPAX@Z:PROC			; SimCBEOSB_4T
EXTRN	?SimCBEOSB_5T@@YAXKHPAX@Z:PROC			; SimCBEOSB_5T
EXTRN	?SimCBEOSB_6T@@YAXKHPAX@Z:PROC			; SimCBEOSB_6T
EXTRN	?SimCBEOSB_7T@@YAXKHPAX@Z:PROC			; SimCBEOSB_7T
EXTRN	?SimCBEOSB_8T@@YAXKHPAX@Z:PROC			; SimCBEOSB_8T
EXTRN	?SimCBEOSB_9T@@YAXKHPAX@Z:PROC			; SimCBEOSB_9T
EXTRN	?SimCBEOSB_10T@@YAXKHPAX@Z:PROC			; SimCBEOSB_10T
EXTRN	?SimCBEOSB_11T@@YAXKHPAX@Z:PROC			; SimCBEOSB_11T
EXTRN	?SimCBEOSB_12T@@YAXKHPAX@Z:PROC			; SimCBEOSB_12T
EXTRN	?SimCBEOSB_13T@@YAXKHPAX@Z:PROC			; SimCBEOSB_13T
EXTRN	?SimCBEOSB_14T@@YAXKHPAX@Z:PROC			; SimCBEOSB_14T
EXTRN	?SimCBEOSB_15T@@YAXKHPAX@Z:PROC			; SimCBEOSB_15T
EXTRN	?SimCBEOSB_16T@@YAXKHPAX@Z:PROC			; SimCBEOSB_16T
EXTRN	?SimCBEOSB_17T@@YAXKHPAX@Z:PROC			; SimCBEOSB_17T
EXTRN	?SimCBEOSB_18T@@YAXKHPAX@Z:PROC			; SimCBEOSB_18T
EXTRN	?SimCBEOSB_19T@@YAXKHPAX@Z:PROC			; SimCBEOSB_19T
EXTRN	?SimCBEOSB_20T@@YAXKHPAX@Z:PROC			; SimCBEOSB_20T
EXTRN	?SimCBEOSB_1F@@YAXKHPAX@Z:PROC			; SimCBEOSB_1F
EXTRN	?SimCBEOSB_2F@@YAXKHPAX@Z:PROC			; SimCBEOSB_2F
EXTRN	?SimCBEOSB_3F@@YAXKHPAX@Z:PROC			; SimCBEOSB_3F
EXTRN	?SimCBEOSB_4F@@YAXKHPAX@Z:PROC			; SimCBEOSB_4F
EXTRN	?SimCBEOSB_5F@@YAXKHPAX@Z:PROC			; SimCBEOSB_5F
EXTRN	?SimCBEOSB_6F@@YAXKHPAX@Z:PROC			; SimCBEOSB_6F
EXTRN	?SimCBEOSB_7F@@YAXKHPAX@Z:PROC			; SimCBEOSB_7F
EXTRN	?SimCBEOSB_8F@@YAXKHPAX@Z:PROC			; SimCBEOSB_8F
EXTRN	?SimCBEOSB_9F@@YAXKHPAX@Z:PROC			; SimCBEOSB_9F
EXTRN	?SimCBEOSB_10F@@YAXKHPAX@Z:PROC			; SimCBEOSB_10F
EXTRN	?SimCBEOSB_11F@@YAXKHPAX@Z:PROC			; SimCBEOSB_11F
EXTRN	?SimCBEOSB_12F@@YAXKHPAX@Z:PROC			; SimCBEOSB_12F
EXTRN	?SimCBEOSB_13F@@YAXKHPAX@Z:PROC			; SimCBEOSB_13F
EXTRN	?SimCBEOSB_14F@@YAXKHPAX@Z:PROC			; SimCBEOSB_14F
EXTRN	?SimCBEOSB_15F@@YAXKHPAX@Z:PROC			; SimCBEOSB_15F
EXTRN	?SimCBEOSB_16F@@YAXKHPAX@Z:PROC			; SimCBEOSB_16F
EXTRN	?SimCBEOSB_17F@@YAXKHPAX@Z:PROC			; SimCBEOSB_17F
EXTRN	?SimCBEOSB_18F@@YAXKHPAX@Z:PROC			; SimCBEOSB_18F
EXTRN	?SimCBEOSB_19F@@YAXKHPAX@Z:PROC			; SimCBEOSB_19F
EXTRN	?SimCBEOSB_20F@@YAXKHPAX@Z:PROC			; SimCBEOSB_20F
EXTRN	?SimCBEOSB_GAINUP_T@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINUP_T
EXTRN	?SimCBEOSB_GAINUP_F@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINUP_F
EXTRN	?SimCBEOSB_GAINDOWN_T@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINDOWN_T
EXTRN	?SimCBEOSB_GAINDOWN_F@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINDOWN_F
EXTRN	?SimCBEOSB_GAINUP_R@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINUP_R
EXTRN	?SimCBEOSB_GAINUP_L@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINUP_L
EXTRN	?SimCBEOSB_GAINDOWN_R@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINDOWN_R
EXTRN	?SimCBEOSB_GAINDOWN_L@@YAXKHPAX@Z:PROC		; SimCBEOSB_GAINDOWN_L
EXTRN	?SimICPTILS@@YAXKHPAX@Z:PROC			; SimICPTILS
EXTRN	?SimICPALOW@@YAXKHPAX@Z:PROC			; SimICPALOW
EXTRN	?SimICPFAck@@YAXKHPAX@Z:PROC			; SimICPFAck
EXTRN	?SimICPPrevious@@YAXKHPAX@Z:PROC		; SimICPPrevious
EXTRN	?SimICPNext@@YAXKHPAX@Z:PROC			; SimICPNext
EXTRN	?SimICPLink@@YAXKHPAX@Z:PROC			; SimICPLink
EXTRN	?SimICPCrus@@YAXKHPAX@Z:PROC			; SimICPCrus
EXTRN	?SimICPStpt@@YAXKHPAX@Z:PROC			; SimICPStpt
EXTRN	?SimICPMark@@YAXKHPAX@Z:PROC			; SimICPMark
EXTRN	?SimICPEnter@@YAXKHPAX@Z:PROC			; SimICPEnter
EXTRN	?SimICPCom1@@YAXKHPAX@Z:PROC			; SimICPCom1
EXTRN	?SimICPCom2@@YAXKHPAX@Z:PROC			; SimICPCom2
EXTRN	?SimICPNav@@YAXKHPAX@Z:PROC			; SimICPNav
EXTRN	?SimICPAA@@YAXKHPAX@Z:PROC			; SimICPAA
EXTRN	?SimICPAG@@YAXKHPAX@Z:PROC			; SimICPAG
EXTRN	?SimHUDScales@@YAXKHPAX@Z:PROC			; SimHUDScales
EXTRN	?SimHUDFPM@@YAXKHPAX@Z:PROC			; SimHUDFPM
EXTRN	?SimHUDDED@@YAXKHPAX@Z:PROC			; SimHUDDED
EXTRN	?SimHUDVelocity@@YAXKHPAX@Z:PROC		; SimHUDVelocity
EXTRN	?SimHUDRadar@@YAXKHPAX@Z:PROC			; SimHUDRadar
EXTRN	?SimHUDBrightness@@YAXKHPAX@Z:PROC		; SimHUDBrightness
EXTRN	?SimCycleRadioChannel@@YAXKHPAX@Z:PROC		; SimCycleRadioChannel
EXTRN	?ExtinguishMasterCaution@@YAXKHPAX@Z:PROC	; ExtinguishMasterCaution
EXTRN	?SimCycleLeftAuxComDigit@@YAXKHPAX@Z:PROC	; SimCycleLeftAuxComDigit
EXTRN	?SimCycleCenterAuxComDigit@@YAXKHPAX@Z:PROC	; SimCycleCenterAuxComDigit
EXTRN	?SimCycleRightAuxComDigit@@YAXKHPAX@Z:PROC	; SimCycleRightAuxComDigit
EXTRN	?SimCycleBandAuxComDigit@@YAXKHPAX@Z:PROC	; SimCycleBandAuxComDigit
EXTRN	?SimToggleAuxComMaster@@YAXKHPAX@Z:PROC		; SimToggleAuxComMaster
EXTRN	?SimToggleAuxComAATR@@YAXKHPAX@Z:PROC		; SimToggleAuxComAATR
EXTRN	?SimToggleUHFMaster@@YAXKHPAX@Z:PROC		; SimToggleUHFMaster
EXTRN	?SimToggleExtLights@@YAXKHPAX@Z:PROC		; SimToggleExtLights
EXTRN	?OTWStepHudContrastDn@@YAXKHPAX@Z:PROC		; OTWStepHudContrastDn
EXTRN	?OTWStepHudContrastUp@@YAXKHPAX@Z:PROC		; OTWStepHudContrastUp
EXTRN	?IncFuelSwitch@AirframeClass@@QAEXXZ:PROC	; AirframeClass::IncFuelSwitch
EXTRN	?DecFuelSwitch@AirframeClass@@QAEXXZ:PROC	; AirframeClass::DecFuelSwitch
EXTRN	?IncFuelPump@AirframeClass@@QAEXXZ:PROC		; AirframeClass::IncFuelPump
EXTRN	?DecFuelPump@AirframeClass@@QAEXXZ:PROC		; AirframeClass::DecFuelPump
EXTRN	?IncAirSource@AirframeClass@@QAEXXZ:PROC	; AirframeClass::IncAirSource
EXTRN	?DecAirSource@AirframeClass@@QAEXXZ:PROC	; AirframeClass::DecAirSource
EXTRN	?GetTertiaryExclusiveButton@ICPClass@@QAEPAVCPButtonObject@@XZ:PROC ; ICPClass::GetTertiaryExclusiveButton
EXTRN	?GetSecondaryExclusiveButton@ICPClass@@QAEPAVCPButtonObject@@XZ:PROC ; ICPClass::GetSecondaryExclusiveButton
EXTRN	?GetPrimaryExclusiveButton@ICPClass@@QAEPAVCPButtonObject@@XZ:PROC ; ICPClass::GetPrimaryExclusiveButton
EXTRN	?StepUHFPostion@CPMisc@@QAEXXZ:PROC		; CPMisc::StepUHFPostion
EXTRN	?SetEjectButtonState@CPMisc@@QAEXH@Z:PROC	; CPMisc::SetEjectButtonState
EXTRN	?GetEjectButtonState@CPMisc@@QAEHXZ:PROC	; CPMisc::GetEjectButtonState
EXTRN	?SetActivePanel@CockpitManager@@QAE_NH@Z:PROC	; CockpitManager::SetActivePanel
EXTRN	?SetCurrentState@CPButtonObject@@QAEXH@Z:PROC	; CPButtonObject::SetCurrentState
EXTRN	?IncrementState@CPButtonObject@@QAEXXZ:PROC	; CPButtonObject::IncrementState
EXTRN	?DecrementState@CPButtonObject@@QAEXXZ:PROC	; CPButtonObject::DecrementState
EXTRN	?GetScalesSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetScalesSwitch
EXTRN	?GetFPMSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetFPMSwitch
EXTRN	?GetDriftCOSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDriftCOSwitch
EXTRN	?GetDEDSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDEDSwitch
EXTRN	?GetVelocitySwitch@HudClass@@QAEHXZ:PROC	; HudClass::GetVelocitySwitch
EXTRN	?GetRadarSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetRadarSwitch
EXTRN	?GetBrightnessSwitch@HudClass@@QAEHXZ:PROC	; HudClass::GetBrightnessSwitch
EXTRN	?GetUHFSrc@NavigationSystem@@QAE?AW4UHF_Mode_Type@1@XZ:PROC ; NavigationSystem::GetUHFSrc
EXTRN	?GetDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::GetDomain
EXTRN	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ:PROC ; NavigationSystem::GetControlSrc
EXTRN	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ:PROC ; NavigationSystem::GetInstrumentMode
EXTRN	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z:PROC ; NavigationSystem::GetTacanChannel
EXTRN	?GetTacanBand@NavigationSystem@@QAE?AW4StationSet@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::GetTacanBand
EXTRN	?GetState@CPHsi@@QAEHW4HSIButtonStates@1@@Z:PROC ; CPHsi::GetState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
EXTRN	?UserStickInputs@@3VPilotInputs@@A:BYTE		; UserStickInputs
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?g_bIFF@@3_NA:BYTE				; g_bIFF
EXTRN	?g_bMLU@@3_NA:BYTE				; g_bMLU
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEDummyCallback@@YAXPAXH@Z PROC			; CBEDummyCallback

; 3990 : void CBEDummyCallback(void *pButton, int event){

	push	ebp
	mov	ebp, esp
	push	ecx

; 3991 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3992 : 	if (event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBEDummyCa

; 3993 : 		pCPButton->IncrementState();

	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?IncrementState@CPButtonObject@@QAEXXZ	; CPButtonObject::IncrementState
	jmp	SHORT $LN4@CBEDummyCa
$LN3@CBEDummyCa:

; 3994 : 	}
; 3995 : 	else if (event == CP_MOUSE_BUTTON1){

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN4@CBEDummyCa

; 3996 : 		pCPButton->DecrementState();

	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?DecrementState@CPButtonObject@@QAEXXZ	; CPButtonObject::DecrementState
$LN4@CBEDummyCa:

; 3997 : 	}
; 3998 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEDummyCallback@@YAXPAXH@Z ENDP			; CBEDummyCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_curPanel$1 = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBESetNightPanel@@YAXPAXH@Z PROC			; CBESetNightPanel

; 3953 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3954 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3955 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBESetNigh

; 3956 : 		return;

	jmp	SHORT $LN5@CBESetNigh
$LN4@CBESetNigh:

; 3957 : 	}
; 3958 : 
; 3959 : 	if(OTWDriver.pCockpitManager)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN5@CBESetNigh

; 3960 : 	{
; 3961 : 		CPPanel* curPanel = OTWDriver.pCockpitManager->GetActivePanel();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ; CockpitManager::GetActivePanel
	mov	DWORD PTR _curPanel$1[ebp], eax

; 3962 : 
; 3963 : 		if(curPanel->mIdNum == 94700)

	mov	eax, DWORD PTR _curPanel$1[ebp]
	cmp	DWORD PTR [eax+4], 94700		; 000171ecH
	jne	SHORT $LN2@CBESetNigh

; 3964 : 		{
; 3965 : 			OTWDriver.pCockpitManager->SetActivePanel(4700);

	push	4700					; 0000125cH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel

; 3966 : 			playerAC->NightLight = FALSE;

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	BYTE PTR [ecx+1817], 0

; 3967 : 		}
; 3968 : 		else

	jmp	SHORT $LN5@CBESetNigh
$LN2@CBESetNigh:

; 3969 : 		{
; 3970 : 			OTWDriver.pCockpitManager->SetActivePanel(94700);

	push	94700					; 000171ecH
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?SetActivePanel@CockpitManager@@QAE_NH@Z ; CockpitManager::SetActivePanel

; 3971 : 			playerAC->NightLight = TRUE;

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	BYTE PTR [edx+1817], 1
$LN5@CBESetNigh:

; 3972 : 		}
; 3973 : 	}
; 3974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBESetNightPanel@@YAXPAXH@Z ENDP			; CBESetNightPanel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -16					; size = 4
_pos$ = -12						; size = 4
tv72 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExSymWheel@@YAXPAXH@Z PROC				; CBExSymWheel

; 3916 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3917 : 	int pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 3918 : 	if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN11@CBExSymWhe

; 3919 : 		pos = (int)(TheHud->SymWheelPos * 10);

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [eax+5136]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _pos$[ebp], ecx
$LN11@CBExSymWhe:

; 3920 : 
; 3921 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3922 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN10@CBExSymWhe

; 3923 : 		return;

	jmp	SHORT $LN12@CBExSymWhe
$LN10@CBExSymWhe:

; 3924 : 	}
; 3925 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	edx, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], edx

; 3926 : 	switch(pos)

	mov	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, 5
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 5
	ja	SHORT $LN1@CBExSymWhe
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN14@CBExSymWhe[edx*4]
$LN7@CBExSymWhe:

; 3927 : 	{
; 3928 : 		case 10:	//max vol
; 3929 : 			pCPButton->SetCurrentState(5);

	push	5
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3930 : 			break;

	jmp	SHORT $LN8@CBExSymWhe
$LN6@CBExSymWhe:

; 3931 : 		case 9:
; 3932 : 			pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3933 : 			break;

	jmp	SHORT $LN8@CBExSymWhe
$LN5@CBExSymWhe:

; 3934 : 		case 8:
; 3935 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3936 : 			break;

	jmp	SHORT $LN8@CBExSymWhe
$LN4@CBExSymWhe:

; 3937 : 		case 7:
; 3938 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3939 : 			break;

	jmp	SHORT $LN8@CBExSymWhe
$LN3@CBExSymWhe:

; 3940 : 		case 6:
; 3941 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3942 : 			break;

	jmp	SHORT $LN8@CBExSymWhe
$LN2@CBExSymWhe:

; 3943 : 		case 5:
; 3944 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN1@CBExSymWhe:
$LN8@CBExSymWhe:
$LN12@CBExSymWhe:

; 3945 : 			break;
; 3946 : 		default:
; 3947 : //			ShiWarning("No good state!");
; 3948 : 		break;
; 3949 : 	}
; 3950 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@CBExSymWhe:
	DD	$LN2@CBExSymWhe
	DD	$LN3@CBExSymWhe
	DD	$LN4@CBExSymWhe
	DD	$LN5@CBExSymWhe
	DD	$LN6@CBExSymWhe
	DD	$LN7@CBExSymWhe
?CBExSymWheel@@YAXPAXH@Z ENDP				; CBExSymWheel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBESymWheel@@YAXPAXH@Z PROC				; CBESymWheel

; 3898 : {

	push	ebp
	mov	ebp, esp

; 3899 : 	// MD -- 20040703: if analog control is mapped, then change this
; 3900 : 	// mouse behavior to be a power on/off toggle instead of changing
; 3901 : 	// both power on/off and brightness.
; 3902 : 	if (IO.AnalogIsUsed(AXIS_HUD_BRIGHTNESS) == true) {

	push	18					; 00000012H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN6@CBESymWhee

; 3903 : 		if(event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN5@CBESymWhee

; 3904 : 			SimHUDOn(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDOn@@YAXKHPAX@Z			; SimHUDOn
	add	esp, 12					; 0000000cH

; 3905 : 		else

	jmp	SHORT $LN4@CBESymWhee
$LN5@CBESymWhee:

; 3906 : 			SimHUDOff(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDOff@@YAXKHPAX@Z			; SimHUDOff
	add	esp, 12					; 0000000cH
$LN4@CBESymWhee:

; 3907 : 	}
; 3908 : 	else {

	jmp	SHORT $LN7@CBESymWhee
$LN6@CBESymWhee:

; 3909 : 		if(event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBESymWhee

; 3910 : 			SimSymWheelUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimSymWheelUp@@YAXKHPAX@Z		; SimSymWheelUp
	add	esp, 12					; 0000000cH

; 3911 : 		else

	jmp	SHORT $LN7@CBESymWhee
$LN2@CBESymWhee:

; 3912 : 			SimSymWheelDn(0, KEY_DOWN, NULL);	

	push	0
	push	8
	push	0
	call	?SimSymWheelDn@@YAXKHPAX@Z		; SimSymWheelDn
	add	esp, 12					; 0000000cH
$LN7@CBESymWhee:

; 3913 : 	}
; 3914 : }

	pop	ebp
	ret	0
?CBESymWheel@@YAXPAXH@Z ENDP				; CBESymWheel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -16					; size = 4
tv72 = -12						; size = 4
_pos$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExComm2Vol@@YAXPAXH@Z PROC				; CBExComm2Vol

; 3854 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3855 : 	int pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 3856 : 	if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp)

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN14@CBExComm2V
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [eax+688], 0
	je	SHORT $LN14@CBExComm2V

; 3857 : 		pos = OTWDriver.pCockpitManager->mpIcp->Comm2Volume;

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR [edx+1672]
	mov	DWORD PTR _pos$[ebp], eax
$LN14@CBExComm2V:

; 3858 : 
; 3859 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3860 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN13@CBExComm2V

; 3861 : 		return;

	jmp	$LN15@CBExComm2V
$LN13@CBExComm2V:

; 3862 : 	}
; 3863 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	ecx, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], ecx

; 3864 : 	switch(pos)

	mov	edx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	cmp	DWORD PTR tv72[ebp], 8
	ja	SHORT $LN15@CBExComm2V
	mov	eax, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN17@CBExComm2V[eax*4]
$LN10@CBExComm2V:

; 3865 : 	{
; 3866 : 		case 0:	//max vol
; 3867 : 			pCPButton->SetCurrentState(8);

	push	8
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3868 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN9@CBExComm2V:

; 3869 : 		case 1:
; 3870 : 			pCPButton->SetCurrentState(7);

	push	7
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3871 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN8@CBExComm2V:

; 3872 : 		case 2:
; 3873 : 			pCPButton->SetCurrentState(6);

	push	6
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3874 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN7@CBExComm2V:

; 3875 : 		case 3:
; 3876 : 			pCPButton->SetCurrentState(5);

	push	5
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3877 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN6@CBExComm2V:

; 3878 : 		case 4:
; 3879 : 			pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3880 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN5@CBExComm2V:

; 3881 : 		case 5:
; 3882 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3883 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN4@CBExComm2V:

; 3884 : 		case 6:
; 3885 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3886 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN3@CBExComm2V:

; 3887 : 		case 7:
; 3888 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3889 : 			break;

	jmp	SHORT $LN15@CBExComm2V
$LN2@CBExComm2V:

; 3890 : 		case 8:
; 3891 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN15@CBExComm2V:

; 3892 : 			break;
; 3893 : 		default:
; 3894 : 			break;
; 3895 : 	}
; 3896 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@CBExComm2V:
	DD	$LN10@CBExComm2V
	DD	$LN9@CBExComm2V
	DD	$LN8@CBExComm2V
	DD	$LN7@CBExComm2V
	DD	$LN6@CBExComm2V
	DD	$LN5@CBExComm2V
	DD	$LN4@CBExComm2V
	DD	$LN3@CBExComm2V
	DD	$LN2@CBExComm2V
?CBExComm2Vol@@YAXPAXH@Z ENDP				; CBExComm2Vol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEComm2Vol@@YAXPAXH@Z PROC				; CBEComm2Vol

; 3847 : {

	push	ebp
	mov	ebp, esp

; 3848 : 	if(event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEComm2Vo

; 3849 : 		SimStepComm2VolumeUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepComm2VolumeUp@@YAXKHPAX@Z	; SimStepComm2VolumeUp
	add	esp, 12					; 0000000cH

; 3850 : 	else

	jmp	SHORT $LN3@CBEComm2Vo
$LN2@CBEComm2Vo:

; 3851 : 		SimStepComm2VolumeDown(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepComm2VolumeDown@@YAXKHPAX@Z	; SimStepComm2VolumeDown
	add	esp, 12					; 0000000cH
$LN3@CBEComm2Vo:

; 3852 : }

	pop	ebp
	ret	0
?CBEComm2Vol@@YAXPAXH@Z ENDP				; CBEComm2Vol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -16					; size = 4
tv72 = -12						; size = 4
_pos$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExComm1Vol@@YAXPAXH@Z PROC				; CBExComm1Vol

; 3798 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3799 : 	int pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 3800 : 	if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp){

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN14@CBExComm1V
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [eax+688], 0
	je	SHORT $LN14@CBExComm1V

; 3801 : 		pos = OTWDriver.pCockpitManager->mpIcp->Comm1Volume;

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR [edx+1668]
	mov	DWORD PTR _pos$[ebp], eax
$LN14@CBExComm1V:

; 3802 : 	}
; 3803 : 
; 3804 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3805 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN13@CBExComm1V

; 3806 : 		return;

	jmp	$LN15@CBExComm1V
$LN13@CBExComm1V:

; 3807 : 	}
; 3808 : 
; 3809 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	ecx, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], ecx

; 3810 : 	switch(pos)

	mov	edx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	cmp	DWORD PTR tv72[ebp], 8
	ja	SHORT $LN15@CBExComm1V
	mov	eax, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN17@CBExComm1V[eax*4]
$LN10@CBExComm1V:

; 3811 : 	{
; 3812 : 		case 0:	//max vol
; 3813 : 			pCPButton->SetCurrentState(8);

	push	8
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3814 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN9@CBExComm1V:

; 3815 : 		case 1:
; 3816 : 			pCPButton->SetCurrentState(7);

	push	7
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3817 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN8@CBExComm1V:

; 3818 : 		case 2:
; 3819 : 			pCPButton->SetCurrentState(6);

	push	6
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3820 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN7@CBExComm1V:

; 3821 : 		case 3:
; 3822 : 			pCPButton->SetCurrentState(5);

	push	5
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3823 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN6@CBExComm1V:

; 3824 : 		case 4:
; 3825 : 			pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3826 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN5@CBExComm1V:

; 3827 : 		case 5:
; 3828 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3829 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN4@CBExComm1V:

; 3830 : 		case 6:
; 3831 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3832 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN3@CBExComm1V:

; 3833 : 		case 7:
; 3834 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3835 : 			break;

	jmp	SHORT $LN15@CBExComm1V
$LN2@CBExComm1V:

; 3836 : 		case 8:
; 3837 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN15@CBExComm1V:

; 3838 : 			break;
; 3839 : 		default:
; 3840 : 			break;
; 3841 : 	}
; 3842 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@CBExComm1V:
	DD	$LN10@CBExComm1V
	DD	$LN9@CBExComm1V
	DD	$LN8@CBExComm1V
	DD	$LN7@CBExComm1V
	DD	$LN6@CBExComm1V
	DD	$LN5@CBExComm1V
	DD	$LN4@CBExComm1V
	DD	$LN3@CBExComm1V
	DD	$LN2@CBExComm1V
?CBExComm1Vol@@YAXPAXH@Z ENDP				; CBExComm1Vol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEComm1Vol@@YAXPAXH@Z PROC				; CBEComm1Vol

; 3791 : {

	push	ebp
	mov	ebp, esp

; 3792 : 	if(event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEComm1Vo

; 3793 : 		SimStepComm1VolumeUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepComm1VolumeUp@@YAXKHPAX@Z	; SimStepComm1VolumeUp
	add	esp, 12					; 0000000cH

; 3794 : 	else

	jmp	SHORT $LN3@CBEComm1Vo
$LN2@CBEComm1Vo:

; 3795 : 		SimStepComm1VolumeDown(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepComm1VolumeDown@@YAXKHPAX@Z	; SimStepComm1VolumeDown
	add	esp, 12					; 0000000cH
$LN3@CBEComm1Vo:

; 3796 : }

	pop	ebp
	ret	0
?CBEComm1Vol@@YAXPAXH@Z ENDP				; CBEComm1Vol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExCanopy@@YAXPAXH@Z PROC				; CBExCanopy

; 3775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3776 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3777 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExCanopy

; 3778 : 		return;

	jmp	SHORT $LN4@CBExCanopy
$LN3@CBExCanopy:

; 3779 : 	}
; 3780 : 
; 3781 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3782 : 	if(playerAC->af->canopyState)

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movzx	eax, BYTE PTR [edx+1588]
	test	eax, eax
	je	SHORT $LN2@CBExCanopy

; 3783 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3784 : 	else

	jmp	SHORT $LN4@CBExCanopy
$LN2@CBExCanopy:

; 3785 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExCanopy:

; 3786 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExCanopy@@YAXPAXH@Z ENDP				; CBExCanopy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBECanopy@@YAXPAXH@Z PROC				; CBECanopy

; 3770 : {

	push	ebp
	mov	ebp, esp

; 3771 :     AFCanopyToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFCanopyToggle@@YAXKHPAX@Z		; AFCanopyToggle
	add	esp, 12					; 0000000cH

; 3772 : }

	pop	ebp
	ret	0
?CBECanopy@@YAXPAXH@Z ENDP				; CBECanopy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExDragChute@@YAXPAXH@Z PROC				; CBExDragChute

; 3751 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3752 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3753 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExDragCh

; 3754 : 		return;

	jmp	SHORT $LN4@CBExDragCh
$LN3@CBExDragCh:

; 3755 : 	}
; 3756 : 
; 3757 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3758 : 	if(playerAC->af->dragChute != AirframeClass::DRAGC_STOWED){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	cmp	DWORD PTR [edx+1584], 0
	je	SHORT $LN2@CBExDragCh

; 3759 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3760 : 	}
; 3761 : 	else{

	jmp	SHORT $LN4@CBExDragCh
$LN2@CBExDragCh:

; 3762 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExDragCh:

; 3763 : 	}
; 3764 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExDragChute@@YAXPAXH@Z ENDP				; CBExDragChute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEDragChute@@YAXPAXH@Z PROC				; CBEDragChute

; 3746 : {

	push	ebp
	mov	ebp, esp

; 3747 :     AFDragChute(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFDragChute@@YAXKHPAX@Z		; AFDragChute
	add	esp, 12					; 0000000cH

; 3748 : }

	pop	ebp
	ret	0
?CBEDragChute@@YAXPAXH@Z ENDP				; CBEDragChute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBELef@@YAXPAXH@Z PROC					; CBELef

; 3730 : void CBELef(void * pButton, int event){

	push	ebp
	mov	ebp, esp
	push	ecx

; 3731 : 	CPButtonObject *pCPButton	= static_cast<CPButtonObject*>(pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3732 : 	if (event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBELef

; 3733 : 	    AFIncLEF(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFIncLEF@@YAXKHPAX@Z			; AFIncLEF
	add	esp, 12					; 0000000cH

; 3734 : 		//if (pCPButton != NULL){ pCPButton->IncrementState(); }
; 3735 : 	}
; 3736 : 	else {

	jmp	SHORT $LN3@CBELef
$LN2@CBELef:

; 3737 : 	    AFDecLEF(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFDecLEF@@YAXKHPAX@Z			; AFDecLEF
	add	esp, 12					; 0000000cH
$LN3@CBELef:

; 3738 : 		//if (pCPButton != NULL){ pCPButton->DecrementState(); }
; 3739 : 	}
; 3740 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBELef@@YAXPAXH@Z ENDP					; CBELef
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExFlap@@YAXPAXH@Z PROC				; CBExFlap

; 3712 : void CBExFlap(void * pButton, int event){

	push	ebp
	mov	ebp, esp
	push	ecx

; 3713 : 	return;

	jmp	SHORT $LN5@CBExFlap

; 3714 : 	CPButtonObject *pCPButton	= static_cast<CPButtonObject*>(pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3715 : 	if (pCPButton == NULL){ return; }

	cmp	DWORD PTR _pCPButton$[ebp], 0
	jne	SHORT $LN4@CBExFlap
	jmp	SHORT $LN5@CBExFlap
$LN4@CBExFlap:

; 3716 : 
; 3717 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBExFlap

; 3718 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN5@CBExFlap
$LN3@CBExFlap:

; 3719 : 	}
; 3720 : 	else if (event == CP_MOUSE_BUTTON1){

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN5@CBExFlap

; 3721 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExFlap:

; 3722 : 	}
; 3723 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFlap@@YAXPAXH@Z ENDP				; CBExFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFlap@@YAXPAXH@Z PROC				; CBEFlap

; 3698 : void CBEFlap(void * pButton, int event){

	push	ebp
	mov	ebp, esp
	push	ecx

; 3699 : 	CPButtonObject *pCPButton	= static_cast<CPButtonObject*>(pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3700 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEFlap

; 3701 : 	    AFIncFlap(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFIncFlap@@YAXKHPAX@Z			; AFIncFlap
	add	esp, 12					; 0000000cH

; 3702 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3703 : 		//if (pCPButton != NULL){ pCPButton->IncrementState(); }
; 3704 : 	}
; 3705 : 	else{

	jmp	SHORT $LN3@CBEFlap
$LN2@CBEFlap:

; 3706 : 	    AFDecFlap(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFDecFlap@@YAXKHPAX@Z			; AFDecFlap
	add	esp, 12					; 0000000cH

; 3707 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN3@CBEFlap:

; 3708 : 		//if (pCPButton != NULL){ pCPButton->DecrementState(); }
; 3709 : 	}
; 3710 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEFlap@@YAXPAXH@Z ENDP				; CBEFlap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEThrRevButton@@YAXPAXH@Z PROC			; CBEThrRevButton

; 3690 : {

	push	ebp
	mov	ebp, esp

; 3691 : 	SimReverseThrusterToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimReverseThrusterToggle@@YAXKHPAX@Z	; SimReverseThrusterToggle
	add	esp, 12					; 0000000cH

; 3692 : }

	pop	ebp
	ret	0
?CBEThrRevButton@@YAXPAXH@Z ENDP			; CBEThrRevButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBETFRButton@@YAXPAXH@Z PROC				; CBETFRButton

; 3682 : {

	push	ebp
	mov	ebp, esp

; 3683 : 	SimToggleTFR(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleTFR@@YAXKHPAX@Z		; SimToggleTFR
	add	esp, 12					; 0000000cH

; 3684 : }

	pop	ebp
	ret	0
?CBETFRButton@@YAXPAXH@Z ENDP				; CBETFRButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_Pos$1 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExDeprRet@@YAXPAXH@Z PROC				; CBExDeprRet

; 3670 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3671 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3672 : 	if(TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN2@CBExDeprRe

; 3673 : 	{
; 3674 : 		int Pos = -TheHud->ReticlePosition;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR [ecx+5128]
	neg	edx
	mov	DWORD PTR _Pos$1[ebp], edx

; 3675 : 		pCPButton->SetCurrentState(Pos);

	mov	eax, DWORD PTR _Pos$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExDeprRe:

; 3676 : 	}
; 3677 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExDeprRet@@YAXPAXH@Z ENDP				; CBExDeprRet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEDeprRet@@YAXPAXH@Z PROC				; CBEDeprRet

; 3661 : {

	push	ebp
	mov	ebp, esp

; 3662 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEDeprRet

; 3663 : 		SimRetUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimRetUp@@YAXKHPAX@Z			; SimRetUp
	add	esp, 12					; 0000000cH

; 3664 : 	}
; 3665 : 	else{

	jmp	SHORT $LN3@CBEDeprRet
$LN2@CBEDeprRet:

; 3666 : 		SimRetDn(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimRetDn@@YAXKHPAX@Z			; SimRetDn
	add	esp, 12					; 0000000cH
$LN3@CBEDeprRet:

; 3667 : 	}
; 3668 : }

	pop	ebp
	ret	0
?CBEDeprRet@@YAXPAXH@Z ENDP				; CBEDeprRet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pos$ = -16						; size = 4
tv68 = -12						; size = 4
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExThreatVol@@YAXPAXH@Z PROC				; CBExThreatVol

; 3616 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3617 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3618 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN13@CBExThreat

; 3619 : 		return;

	jmp	$LN14@CBExThreat
$LN13@CBExThreat:

; 3620 : 	}
; 3621 : 
; 3622 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3623 : 	int pos = playerAC->ThreatVolume;

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+880]
	mov	DWORD PTR _pos$[ebp], edx

; 3624 : 	switch(pos)

	mov	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 8
	ja	SHORT $LN14@CBExThreat
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN16@CBExThreat[ecx*4]
$LN10@CBExThreat:

; 3625 : 	{
; 3626 : 		case 0:	//max vol
; 3627 : 			pCPButton->SetCurrentState(8);

	push	8
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3628 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN9@CBExThreat:

; 3629 : 		case 1:
; 3630 : 			pCPButton->SetCurrentState(7);

	push	7
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3631 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN8@CBExThreat:

; 3632 : 		case 2:
; 3633 : 			pCPButton->SetCurrentState(6);

	push	6
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3634 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN7@CBExThreat:

; 3635 : 		case 3:
; 3636 : 			pCPButton->SetCurrentState(5);

	push	5
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3637 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN6@CBExThreat:

; 3638 : 		case 4:
; 3639 : 			pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3640 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN5@CBExThreat:

; 3641 : 		case 5:
; 3642 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3643 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN4@CBExThreat:

; 3644 : 		case 6:
; 3645 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3646 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN3@CBExThreat:

; 3647 : 		case 7:
; 3648 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3649 : 			break;

	jmp	SHORT $LN14@CBExThreat
$LN2@CBExThreat:

; 3650 : 		case 8:
; 3651 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN14@CBExThreat:

; 3652 : 			break;
; 3653 : 		default:
; 3654 : 			break;
; 3655 : 	}
; 3656 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@CBExThreat:
	DD	$LN10@CBExThreat
	DD	$LN9@CBExThreat
	DD	$LN8@CBExThreat
	DD	$LN7@CBExThreat
	DD	$LN6@CBExThreat
	DD	$LN5@CBExThreat
	DD	$LN4@CBExThreat
	DD	$LN3@CBExThreat
	DD	$LN2@CBExThreat
?CBExThreatVol@@YAXPAXH@Z ENDP				; CBExThreatVol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEThreatVol@@YAXPAXH@Z PROC				; CBEThreatVol

; 3607 : {

	push	ebp
	mov	ebp, esp

; 3608 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEThreatV

; 3609 : 		SimStepThreatVolumeUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepThreatVolumeUp@@YAXKHPAX@Z	; SimStepThreatVolumeUp
	add	esp, 12					; 0000000cH

; 3610 : 	}
; 3611 : 	else{

	jmp	SHORT $LN3@CBEThreatV
$LN2@CBEThreatV:

; 3612 : 		SimStepThreatVolumeDown(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepThreatVolumeDown@@YAXKHPAX@Z	; SimStepThreatVolumeDown
	add	esp, 12					; 0000000cH
$LN3@CBEThreatV:

; 3613 : 	}
; 3614 : }

	pop	ebp
	ret	0
?CBEThreatVol@@YAXPAXH@Z ENDP				; CBEThreatVol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pos$ = -16						; size = 4
tv68 = -12						; size = 4
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExMissileVol@@YAXPAXH@Z PROC				; CBExMissileVol

; 3562 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3563 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3564 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN13@CBExMissil

; 3565 : 		return;

	jmp	$LN14@CBExMissil
$LN13@CBExMissil:

; 3566 : 	}
; 3567 : 
; 3568 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3569 : 	int pos = playerAC->MissileVolume;

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	mov	DWORD PTR _pos$[ebp], edx

; 3570 : 	switch(pos)

	mov	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 8
	ja	SHORT $LN14@CBExMissil
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN16@CBExMissil[ecx*4]
$LN10@CBExMissil:

; 3571 : 	{
; 3572 : 		case 0:	//max vol
; 3573 : 			pCPButton->SetCurrentState(8);

	push	8
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3574 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN9@CBExMissil:

; 3575 : 		case 1:
; 3576 : 			pCPButton->SetCurrentState(7);

	push	7
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3577 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN8@CBExMissil:

; 3578 : 		case 2:
; 3579 : 			pCPButton->SetCurrentState(6);

	push	6
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3580 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN7@CBExMissil:

; 3581 : 		case 3:
; 3582 : 			pCPButton->SetCurrentState(5);

	push	5
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3583 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN6@CBExMissil:

; 3584 : 		case 4:
; 3585 : 			pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3586 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN5@CBExMissil:

; 3587 : 		case 5:
; 3588 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3589 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN4@CBExMissil:

; 3590 : 		case 6:
; 3591 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3592 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN3@CBExMissil:

; 3593 : 		case 7:
; 3594 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3595 : 			break;

	jmp	SHORT $LN14@CBExMissil
$LN2@CBExMissil:

; 3596 : 		case 8:
; 3597 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN14@CBExMissil:

; 3598 : 			break;
; 3599 : 		default:
; 3600 : 			break;
; 3601 : 	}
; 3602 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@CBExMissil:
	DD	$LN10@CBExMissil
	DD	$LN9@CBExMissil
	DD	$LN8@CBExMissil
	DD	$LN7@CBExMissil
	DD	$LN6@CBExMissil
	DD	$LN5@CBExMissil
	DD	$LN4@CBExMissil
	DD	$LN3@CBExMissil
	DD	$LN2@CBExMissil
?CBExMissileVol@@YAXPAXH@Z ENDP				; CBExMissileVol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEMissileVol@@YAXPAXH@Z PROC				; CBEMissileVol

; 3553 : {

	push	ebp
	mov	ebp, esp

; 3554 : 	if (event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEMissile

; 3555 : 		SimStepMissileVolumeUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepMissileVolumeUp@@YAXKHPAX@Z	; SimStepMissileVolumeUp
	add	esp, 12					; 0000000cH

; 3556 : 	}
; 3557 : 	else {

	jmp	SHORT $LN3@CBEMissile
$LN2@CBEMissile:

; 3558 : 		SimStepMissileVolumeDown(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepMissileVolumeDown@@YAXKHPAX@Z	; SimStepMissileVolumeDown
	add	esp, 12					; 0000000cH
$LN3@CBEMissile:

; 3559 : 	}
; 3560 : }

	pop	ebp
	ret	0
?CBEMissileVol@@YAXPAXH@Z ENDP				; CBEMissileVol
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBETrimRoll@@YAXPAXH@Z PROC				; CBETrimRoll

; 3540 : {

	push	ebp
	mov	ebp, esp

; 3541 : 	if (event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBETrimRol

; 3542 : 		SimTrimRollLeft(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimRollLeft@@YAXKHPAX@Z		; SimTrimRollLeft
	add	esp, 12					; 0000000cH

; 3543 : 	}
; 3544 : 	else {

	jmp	SHORT $LN3@CBETrimRol
$LN2@CBETrimRol:

; 3545 : 		SimTrimRollRight(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimRollRight@@YAXKHPAX@Z		; SimTrimRollRight
	add	esp, 12					; 0000000cH
$LN3@CBETrimRol:

; 3546 : 	}
; 3547 : }

	pop	ebp
	ret	0
?CBETrimRoll@@YAXPAXH@Z ENDP				; CBETrimRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_state$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExTrimYaw@@YAXPAXH@Z PROC				; CBExTrimYaw

; 3510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3511 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3512 : 	int state = -(int)(UserStickInputs.ytrim * 100);

	movss	xmm0, DWORD PTR ?UserStickInputs@@3VPilotInputs@@A+92
	mulss	xmm0, DWORD PTR __real@42c80000
	cvttss2si ecx, xmm0
	neg	ecx
	mov	DWORD PTR _state$[ebp], ecx

; 3513 : 	if(state <= -50)

	cmp	DWORD PTR _state$[ebp], -50		; ffffffceH
	jg	SHORT $LN21@CBExTrimYa

; 3514 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	$LN1@CBExTrimYa
$LN21@CBExTrimYa:

; 3515 : 	else if(state <= -40 && state > -50)

	cmp	DWORD PTR _state$[ebp], -40		; ffffffd8H
	jg	SHORT $LN19@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], -50		; ffffffceH
	jle	SHORT $LN19@CBExTrimYa

; 3516 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	$LN1@CBExTrimYa
$LN19@CBExTrimYa:

; 3517 : 	else if(state <= -30 && state > -40)

	cmp	DWORD PTR _state$[ebp], -30		; ffffffe2H
	jg	SHORT $LN17@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], -40		; ffffffd8H
	jle	SHORT $LN17@CBExTrimYa

; 3518 : 		pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	$LN1@CBExTrimYa
$LN17@CBExTrimYa:

; 3519 : 	else if(state <= -20 && state > -30)

	cmp	DWORD PTR _state$[ebp], -20		; ffffffecH
	jg	SHORT $LN15@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], -30		; ffffffe2H
	jle	SHORT $LN15@CBExTrimYa

; 3520 : 		pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	$LN1@CBExTrimYa
$LN15@CBExTrimYa:

; 3521 : 	else if(state <= -10 && state > -20)

	cmp	DWORD PTR _state$[ebp], -10		; fffffff6H
	jg	SHORT $LN13@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], -20		; ffffffecH
	jle	SHORT $LN13@CBExTrimYa

; 3522 : 		pCPButton->SetCurrentState(5);

	push	5
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	$LN1@CBExTrimYa
$LN13@CBExTrimYa:

; 3523 : 	else if(state <= 9 && state > -10)

	cmp	DWORD PTR _state$[ebp], 9
	jg	SHORT $LN11@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], -10		; fffffff6H
	jle	SHORT $LN11@CBExTrimYa

; 3524 : 		pCPButton->SetCurrentState(6);

	push	6
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN1@CBExTrimYa
$LN11@CBExTrimYa:

; 3525 : 	else if(state >= 10 && state < 20)

	cmp	DWORD PTR _state$[ebp], 10		; 0000000aH
	jl	SHORT $LN9@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], 20		; 00000014H
	jge	SHORT $LN9@CBExTrimYa

; 3526 : 		pCPButton->SetCurrentState(7);

	push	7
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN1@CBExTrimYa
$LN9@CBExTrimYa:

; 3527 : 	else if(state >= 20 && state < 30)

	cmp	DWORD PTR _state$[ebp], 20		; 00000014H
	jl	SHORT $LN7@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], 30		; 0000001eH
	jge	SHORT $LN7@CBExTrimYa

; 3528 : 		pCPButton->SetCurrentState(8);

	push	8
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN1@CBExTrimYa
$LN7@CBExTrimYa:

; 3529 : 	else if(state >= 30 && state < 40)

	cmp	DWORD PTR _state$[ebp], 30		; 0000001eH
	jl	SHORT $LN5@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], 40		; 00000028H
	jge	SHORT $LN5@CBExTrimYa

; 3530 : 		pCPButton->SetCurrentState(9);

	push	9
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN1@CBExTrimYa
$LN5@CBExTrimYa:

; 3531 : 	else if(state >= 40 && state < 50)

	cmp	DWORD PTR _state$[ebp], 40		; 00000028H
	jl	SHORT $LN3@CBExTrimYa
	cmp	DWORD PTR _state$[ebp], 50		; 00000032H
	jge	SHORT $LN3@CBExTrimYa

; 3532 : 		pCPButton->SetCurrentState(10);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN1@CBExTrimYa
$LN3@CBExTrimYa:

; 3533 : 	else if(state >= 50)

	cmp	DWORD PTR _state$[ebp], 50		; 00000032H
	jl	SHORT $LN1@CBExTrimYa

; 3534 : 		pCPButton->SetCurrentState(11);

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN1@CBExTrimYa:

; 3535 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExTrimYaw@@YAXPAXH@Z ENDP				; CBExTrimYaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBETrimYaw@@YAXPAXH@Z PROC				; CBETrimYaw

; 3500 : {

	push	ebp
	mov	ebp, esp

; 3501 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBETrimYaw

; 3502 : 		SimTrimYawLeft(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimYawLeft@@YAXKHPAX@Z		; SimTrimYawLeft
	add	esp, 12					; 0000000cH

; 3503 : 	}
; 3504 : 	else{

	jmp	SHORT $LN3@CBETrimYaw
$LN2@CBETrimYaw:

; 3505 : 		SimTrimYawRight(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimYawRight@@YAXKHPAX@Z		; SimTrimYawRight
	add	esp, 12					; 0000000cH
$LN3@CBETrimYaw:

; 3506 : 	}
; 3507 : }

	pop	ebp
	ret	0
?CBETrimYaw@@YAXPAXH@Z ENDP				; CBETrimYaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBETrimNose@@YAXPAXH@Z PROC				; CBETrimNose

; 3488 : {

	push	ebp
	mov	ebp, esp

; 3489 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBETrimNos

; 3490 : 		SimTrimNoseUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimNoseUp@@YAXKHPAX@Z		; SimTrimNoseUp
	add	esp, 12					; 0000000cH

; 3491 : 	}
; 3492 : 	else{

	jmp	SHORT $LN3@CBETrimNos
$LN2@CBETrimNos:

; 3493 : 		SimTrimNoseDown(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimNoseDown@@YAXKHPAX@Z		; SimTrimNoseDown
	add	esp, 12					; 0000000cH
$LN3@CBETrimNos:

; 3494 : 	}
; 3495 : }

	pop	ebp
	ret	0
?CBETrimNose@@YAXPAXH@Z ENDP				; CBETrimNose
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExABReset@@YAXPAXH@Z PROC				; CBExABReset

; 3481 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3482 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3483 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExABReset@@YAXPAXH@Z ENDP				; CBExABReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEABReset@@YAXPAXH@Z PROC				; CBEABReset

; 3476 : {

	push	ebp
	mov	ebp, esp

; 3477 :     SimABReset(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimABReset@@YAXKHPAX@Z			; SimABReset
	add	esp, 12					; 0000000cH

; 3478 : }

	pop	ebp
	ret	0
?CBEABReset@@YAXPAXH@Z ENDP				; CBEABReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExMaxPower@@YAXPAXH@Z PROC				; CBExMaxPower

; 3469 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3470 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3471 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMaxPower@@YAXPAXH@Z ENDP				; CBExMaxPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEMaxPower@@YAXPAXH@Z PROC				; CBEMaxPower

; 3464 : {

	push	ebp
	mov	ebp, esp

; 3465 :     SimMaxPower(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimMaxPower@@YAXKHPAX@Z		; SimMaxPower
	add	esp, 12					; 0000000cH

; 3466 : }

	pop	ebp
	ret	0
?CBEMaxPower@@YAXPAXH@Z ENDP				; CBEMaxPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExTrimAPDisc@@YAXPAXH@Z PROC				; CBExTrimAPDisc

; 3445 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3446 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3447 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExTrimAP

; 3448 : 		return;

	jmp	SHORT $LN4@CBExTrimAP
$LN3@CBExTrimAP:

; 3449 : 	}
; 3450 : 
; 3451 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3452 : 
; 3453 : 	if(playerAC->TrimAPDisc){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+850]
	test	edx, edx
	je	SHORT $LN2@CBExTrimAP

; 3454 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3455 : 	}
; 3456 : 	else{

	jmp	SHORT $LN4@CBExTrimAP
$LN2@CBExTrimAP:

; 3457 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExTrimAP:

; 3458 : 	}
; 3459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExTrimAPDisc@@YAXPAXH@Z ENDP				; CBExTrimAPDisc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBETrimAPDisc@@YAXPAXH@Z PROC				; CBETrimAPDisc

; 3440 : {

	push	ebp
	mov	ebp, esp

; 3441 :     SimTrimAPDisc(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTrimAPDisc@@YAXKHPAX@Z		; SimTrimAPDisc
	add	esp, 12					; 0000000cH

; 3442 : }

	pop	ebp
	ret	0
?CBETrimAPDisc@@YAXPAXH@Z ENDP				; CBETrimAPDisc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExOverHeat@@YAXPAXH@Z PROC				; CBExOverHeat

; 3433 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3434 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3435 : }		

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExOverHeat@@YAXPAXH@Z ENDP				; CBExOverHeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEOverHeat@@YAXPAXH@Z PROC				; CBEOverHeat

; 3428 : {

	push	ebp
	mov	ebp, esp

; 3429 : 	SimOverHeat(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimOverHeat@@YAXKHPAX@Z		; SimOverHeat
	add	esp, 12					; 0000000cH

; 3430 : }

	pop	ebp
	ret	0
?CBEOverHeat@@YAXPAXH@Z ENDP				; CBEOverHeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExTestSwitch@@YAXPAXH@Z PROC				; CBExTestSwitch

; 3421 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3422 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3423 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExTestSwitch@@YAXPAXH@Z ENDP				; CBExTestSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBETestSwitch@@YAXPAXH@Z PROC				; CBETestSwitch

; 3416 : {

	push	ebp
	mov	ebp, esp

; 3417 :     SimTestSwitch(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimTestSwitch@@YAXKHPAX@Z		; SimTestSwitch
	add	esp, 12					; 0000000cH

; 3418 : }

	pop	ebp
	ret	0
?CBETestSwitch@@YAXPAXH@Z ENDP				; CBETestSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEPUGEN@@YAXPAXH@Z PROC				; CBExEPUGEN

; 3409 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3410 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3411 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEPUGEN@@YAXPAXH@Z ENDP				; CBExEPUGEN
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEPUGEN@@YAXPAXH@Z PROC				; CBEEPUGEN

; 3404 : {

	push	ebp
	mov	ebp, esp

; 3405 :     SimEPUGEN(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEPUGEN@@YAXKHPAX@Z			; SimEPUGEN
	add	esp, 12					; 0000000cH

; 3406 : }

	pop	ebp
	ret	0
?CBEEPUGEN@@YAXPAXH@Z ENDP				; CBEEPUGEN
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExProbeHeat@@YAXPAXH@Z PROC				; CBExProbeHeat

; 3397 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3398 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3399 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExProbeHeat@@YAXPAXH@Z ENDP				; CBExProbeHeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEProbeHeat@@YAXPAXH@Z PROC				; CBEProbeHeat

; 3392 : {

	push	ebp
	mov	ebp, esp

; 3393 :     SimProbeHeat(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimProbeHeat@@YAXKHPAX@Z		; SimProbeHeat
	add	esp, 12					; 0000000cH

; 3394 : }

	pop	ebp
	ret	0
?CBEProbeHeat@@YAXPAXH@Z ENDP				; CBEProbeHeat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExMalIndLights@@YAXPAXH@Z PROC			; CBExMalIndLights

; 3373 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3374 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3375 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExMalInd

; 3376 : 		return;

	jmp	SHORT $LN4@CBExMalInd
$LN3@CBExMalInd:

; 3377 : 	}
; 3378 : 
; 3379 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3380 : 
; 3381 : 	if(playerAC->TestLights){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+849]
	test	edx, edx
	je	SHORT $LN2@CBExMalInd

; 3382 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3383 : 	}
; 3384 : 	else{

	jmp	SHORT $LN4@CBExMalInd
$LN2@CBExMalInd:

; 3385 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExMalInd:

; 3386 : 	}
; 3387 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMalIndLights@@YAXPAXH@Z ENDP			; CBExMalIndLights
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEMalIndLights@@YAXPAXH@Z PROC			; CBEMalIndLights

; 3365 : {

	push	ebp
	mov	ebp, esp

; 3366 : 	if(event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEMalIndL

; 3367 : 		SimMalIndLights(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimMalIndLights@@YAXKHPAX@Z		; SimMalIndLights
	add	esp, 12					; 0000000cH

; 3368 : 	else

	jmp	SHORT $LN3@CBEMalIndL
$LN2@CBEMalIndL:

; 3369 : 		SimMalIndLights(0, 0, NULL);

	push	0
	push	0
	push	0
	call	?SimMalIndLights@@YAXKHPAX@Z		; SimMalIndLights
	add	esp, 12					; 0000000cH
$LN3@CBEMalIndL:

; 3370 : }

	pop	ebp
	ret	0
?CBEMalIndLights@@YAXPAXH@Z ENDP			; CBEMalIndLights
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExOBOGSBit@@YAXPAXH@Z PROC				; CBExOBOGSBit

; 3358 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3359 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3360 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExOBOGSBit@@YAXPAXH@Z ENDP				; CBExOBOGSBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEOBOGSBit@@YAXPAXH@Z PROC				; CBEOBOGSBit

; 3353 : {

	push	ebp
	mov	ebp, esp

; 3354 :     SimOBOGSBit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimOBOGSBit@@YAXKHPAX@Z		; SimOBOGSBit
	add	esp, 12					; 0000000cH

; 3355 : }

	pop	ebp
	ret	0
?CBEOBOGSBit@@YAXPAXH@Z ENDP				; CBEOBOGSBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExFLTBIT@@YAXPAXH@Z PROC				; CBExFLTBIT

; 3346 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3347 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3348 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFLTBIT@@YAXPAXH@Z ENDP				; CBExFLTBIT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFLTBIT@@YAXPAXH@Z PROC				; CBEFLTBIT

; 3341 : {

	push	ebp
	mov	ebp, esp

; 3342 :     SimFLTBIT(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimFLTBIT@@YAXKHPAX@Z			; SimFLTBIT
	add	esp, 12					; 0000000cH

; 3343 : }

	pop	ebp
	ret	0
?CBEFLTBIT@@YAXPAXH@Z ENDP				; CBEFLTBIT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExFLCSReset@@YAXPAXH@Z PROC				; CBExFLCSReset

; 3334 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3335 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3336 : }			

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFLCSReset@@YAXPAXH@Z ENDP				; CBExFLCSReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFLCSReset@@YAXPAXH@Z PROC				; CBEFLCSReset

; 3329 : {

	push	ebp
	mov	ebp, esp

; 3330 :     SimFLCSReset(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimFLCSReset@@YAXKHPAX@Z		; SimFLCSReset
	add	esp, 12					; 0000000cH

; 3331 : }

	pop	ebp
	ret	0
?CBEFLCSReset@@YAXPAXH@Z ENDP				; CBEFLCSReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExManualFlyup@@YAXPAXH@Z PROC			; CBExManualFlyup

; 3322 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3323 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3324 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExManualFlyup@@YAXPAXH@Z ENDP			; CBExManualFlyup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEManualFlyup@@YAXPAXH@Z PROC				; CBEManualFlyup

; 3317 : {

	push	ebp
	mov	ebp, esp

; 3318 :     SimManualFlyup(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimManualFlyup@@YAXKHPAX@Z		; SimManualFlyup
	add	esp, 12					; 0000000cH

; 3319 : }

	pop	ebp
	ret	0
?CBEManualFlyup@@YAXPAXH@Z ENDP				; CBEManualFlyup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExAltFlaps@@YAXPAXH@Z PROC				; CBExAltFlaps

; 3298 : void CBExAltFlaps(void * pButton, int event){

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3299 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3300 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExAltFla

; 3301 : 		return;

	jmp	SHORT $LN4@CBExAltFla
$LN3@CBExAltFla:

; 3302 : 	}
; 3303 : 
; 3304 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3305 : 
; 3306 : 	if (playerAC->TEFExtend){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+851]
	test	edx, edx
	je	SHORT $LN2@CBExAltFla

; 3307 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3308 : 	}
; 3309 : 	else{

	jmp	SHORT $LN4@CBExAltFla
$LN2@CBExAltFla:

; 3310 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExAltFla:

; 3311 : 	}
; 3312 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAltFlaps@@YAXPAXH@Z ENDP				; CBExAltFlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAltFlaps@@YAXPAXH@Z PROC				; CBEAltFlaps

; 3294 : void CBEAltFlaps(void * pButton, int event){

	push	ebp
	mov	ebp, esp

; 3295 :     SimAltFlaps(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimAltFlaps@@YAXKHPAX@Z		; SimAltFlaps
	add	esp, 12					; 0000000cH

; 3296 : }

	pop	ebp
	ret	0
?CBEAltFlaps@@YAXPAXH@Z ENDP				; CBEAltFlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExDigitalBUP@@YAXPAXH@Z PROC				; CBExDigitalBUP

; 3288 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3289 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3290 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExDigitalBUP@@YAXPAXH@Z ENDP				; CBExDigitalBUP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEDigitalBUP@@YAXPAXH@Z PROC				; CBEDigitalBUP

; 3283 : {

	push	ebp
	mov	ebp, esp

; 3284 :     SimDigitalBUP(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDigitalBUP@@YAXKHPAX@Z		; SimDigitalBUP
	add	esp, 12					; 0000000cH

; 3285 : }

	pop	ebp
	ret	0
?CBEDigitalBUP@@YAXPAXH@Z ENDP				; CBEDigitalBUP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExLEFLockSwitch@@YAXPAXH@Z PROC			; CBExLEFLockSwitch

; 3265 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3266 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3267 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExLEFLoc

; 3268 : 		return;

	jmp	SHORT $LN4@CBExLEFLoc
$LN3@CBExLEFLoc:

; 3269 : 	}
; 3270 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3271 : 
; 3272 : 	if(playerAC->LEFLocked){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+853]
	test	edx, edx
	je	SHORT $LN2@CBExLEFLoc

; 3273 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3274 : 	}
; 3275 : 	else{

	jmp	SHORT $LN4@CBExLEFLoc
$LN2@CBExLEFLoc:

; 3276 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExLEFLoc:

; 3277 : 	}
; 3278 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExLEFLockSwitch@@YAXPAXH@Z ENDP			; CBExLEFLockSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBELEFLockSwitch@@YAXPAXH@Z PROC			; CBELEFLockSwitch

; 3260 : {

	push	ebp
	mov	ebp, esp

; 3261 :     SimLEFLockSwitch(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimLEFLockSwitch@@YAXKHPAX@Z		; SimLEFLockSwitch
	add	esp, 12					; 0000000cH

; 3262 : }

	pop	ebp
	ret	0
?CBELEFLockSwitch@@YAXPAXH@Z ENDP			; CBELEFLockSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExINSSwitch@@YAXPAXH@Z PROC				; CBExINSSwitch

; 3235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3236 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3237 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN8@CBExINSSwi

; 3238 : 		return;

	jmp	SHORT $LN9@CBExINSSwi
$LN8@CBExINSSwi:

; 3239 : 	}
; 3240 : 
; 3241 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3242 : 
; 3243 : 	if(playerAC->INSState(AircraftClass::INS_PowerOff)){

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN7@CBExINSSwi

; 3244 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN9@CBExINSSwi
$LN7@CBExINSSwi:

; 3245 : 	}
; 3246 : 	else if(playerAC->INSState(AircraftClass::INS_AlignNorm)){

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN5@CBExINSSwi

; 3247 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN9@CBExINSSwi
$LN5@CBExINSSwi:

; 3248 : 	}
; 3249 : 	else if(playerAC->INSState(AircraftClass::INS_Nav)){

	push	32					; 00000020H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN3@CBExINSSwi

; 3250 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN9@CBExINSSwi
$LN3@CBExINSSwi:

; 3251 : 	}
; 3252 : 	else if(playerAC->INSState(AircraftClass::INS_AlignFlight)){

	push	16					; 00000010H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN9@CBExINSSwi

; 3253 : 		pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN9@CBExINSSwi:

; 3254 : 	}
; 3255 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExINSSwitch@@YAXPAXH@Z ENDP				; CBExINSSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEINSSwitch@@YAXPAXH@Z PROC				; CBEINSSwitch

; 3225 : {

	push	ebp
	mov	ebp, esp

; 3226 : 	if (event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEINSSwit

; 3227 : 		SimINSInc(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimINSInc@@YAXKHPAX@Z			; SimINSInc
	add	esp, 12					; 0000000cH

; 3228 : 	}
; 3229 : 	else {

	jmp	SHORT $LN3@CBEINSSwit
$LN2@CBEINSSwit:

; 3230 : 		SimINSDec(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimINSDec@@YAXKHPAX@Z			; SimINSDec
	add	esp, 12					; 0000000cH
$LN3@CBEINSSwit:

; 3231 : 	}
; 3232 : }

	pop	ebp
	ret	0
?CBEINSSwitch@@YAXPAXH@Z ENDP				; CBEINSSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExIFFPower@@YAXPAXH@Z PROC				; CBExIFFPower

; 3202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3203 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3204 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN6@CBExIFFPow

; 3205 : 		return;

	jmp	SHORT $LN7@CBExIFFPow
$LN6@CBExIFFPow:

; 3206 : 	}
; 3207 : 
; 3208 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3209 : 	if(g_bIFF || g_bMLU){

	movzx	ecx, BYTE PTR ?g_bIFF@@3_NA		; g_bIFF
	test	ecx, ecx
	jne	SHORT $LN4@CBExIFFPow
	movzx	edx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	edx, edx
	je	SHORT $LN5@CBExIFFPow
$LN4@CBExIFFPow:

; 3210 : 		if(playerAC->PowerSwitchOn(AircraftClass::IFFPower)){

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN3@CBExIFFPow

; 3211 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3212 : 		}
; 3213 : 		else {

	jmp	SHORT $LN2@CBExIFFPow
$LN3@CBExIFFPow:

; 3214 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExIFFPow:

; 3215 : 		}
; 3216 : 	}
; 3217 : 	else{

	jmp	SHORT $LN7@CBExIFFPow
$LN5@CBExIFFPow:

; 3218 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExIFFPow:

; 3219 : 	}
; 3220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExIFFPower@@YAXPAXH@Z ENDP				; CBExIFFPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEIFFPower@@YAXPAXH@Z PROC				; CBEIFFPower

; 3197 : {

	push	ebp
	mov	ebp, esp

; 3198 :     SimIFFPower(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimIFFPower@@YAXKHPAX@Z		; SimIFFPower
	add	esp, 12					; 0000000cH

; 3199 : }

	pop	ebp
	ret	0
?CBEIFFPower@@YAXPAXH@Z ENDP				; CBEIFFPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExAVTRSwitch@@YAXPAXH@Z PROC				; CBExAVTRSwitch

; 3176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3177 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3178 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN5@CBExAVTRSw

; 3179 : 		return;

	jmp	SHORT $LN6@CBExAVTRSw
$LN5@CBExAVTRSw:

; 3180 : 	}
; 3181 : 
; 3182 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3183 : 	if(playerAC->AVTRState(AircraftClass::AVTRStateFlags::AVTR_ON)){

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN4@CBExAVTRSw

; 3184 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN6@CBExAVTRSw
$LN4@CBExAVTRSw:

; 3185 : 	}
; 3186 : 	else if(playerAC->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO)){

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN2@CBExAVTRSw

; 3187 : 		pCPButton->SetCurrentState(2);	//middle

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3188 : 	}
; 3189 : 	else{

	jmp	SHORT $LN6@CBExAVTRSw
$LN2@CBExAVTRSw:

; 3190 : 		pCPButton->SetCurrentState(0);	//down

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN6@CBExAVTRSw:

; 3191 : 	}
; 3192 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAVTRSwitch@@YAXPAXH@Z ENDP				; CBExAVTRSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAVTRSwitch@@YAXPAXH@Z PROC				; CBEAVTRSwitch

; 3171 : {

	push	ebp
	mov	ebp, esp

; 3172 :     SimAVTRSwitch(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimAVTRSwitch@@YAXKHPAX@Z		; SimAVTRSwitch
	add	esp, 12					; 0000000cH

; 3173 : }

	pop	ebp
	ret	0
?CBEAVTRSwitch@@YAXPAXH@Z ENDP				; CBEAVTRSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExExtlWing@@YAXPAXH@Z PROC				; CBExExtlWing

; 3153 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3154 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3155 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3156 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExExtlWi

; 3157 : 		return;

	jmp	SHORT $LN4@CBExExtlWi
$LN3@CBExExtlWi:

; 3158 : 	}
; 3159 : 
; 3160 : 	if (playerAC->ExtlState(AircraftClass::ExtlLightFlags::Extl_Wing_Tail)){

	push	8
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN2@CBExExtlWi

; 3161 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3162 : 	}
; 3163 : 	else {

	jmp	SHORT $LN4@CBExExtlWi
$LN2@CBExExtlWi:

; 3164 : 		pCPButton->SetCurrentState(0);	//down

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExExtlWi:

; 3165 : 	}
; 3166 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExExtlWing@@YAXPAXH@Z ENDP				; CBExExtlWing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEExtlWing@@YAXPAXH@Z PROC				; CBEExtlWing

; 3148 : {

	push	ebp
	mov	ebp, esp

; 3149 :     SimExtlWing(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimExtlWing@@YAXKHPAX@Z		; SimExtlWing
	add	esp, 12					; 0000000cH

; 3150 : }

	pop	ebp
	ret	0
?CBEExtlWing@@YAXPAXH@Z ENDP				; CBEExtlWing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExExtlSteady@@YAXPAXH@Z PROC				; CBExExtlSteady

; 3131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3132 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3133 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3134 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExExtlSt

; 3135 : 		return;

	jmp	SHORT $LN4@CBExExtlSt
$LN3@CBExExtlSt:

; 3136 : 	}
; 3137 : 	if (playerAC->ExtlState(AircraftClass::ExtlLightFlags::Extl_Flash)){

	push	64					; 00000040H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN2@CBExExtlSt

; 3138 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3139 : 	}
; 3140 : 	else{

	jmp	SHORT $LN4@CBExExtlSt
$LN2@CBExExtlSt:

; 3141 : 		pCPButton->SetCurrentState(0);	//down

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExExtlSt:

; 3142 : 	}
; 3143 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExExtlSteady@@YAXPAXH@Z ENDP				; CBExExtlSteady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEExtlSteady@@YAXPAXH@Z PROC				; CBEExtlSteady

; 3126 : {

	push	ebp
	mov	ebp, esp

; 3127 :     SimExtlSteady(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimExtlSteady@@YAXKHPAX@Z		; SimExtlSteady
	add	esp, 12					; 0000000cH

; 3128 : }

	pop	ebp
	ret	0
?CBEExtlSteady@@YAXPAXH@Z ENDP				; CBEExtlSteady
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExExtlAntiColl@@YAXPAXH@Z PROC			; CBExExtlAntiColl

; 3108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3109 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3110 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3111 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExExtlAn

; 3112 : 		return;

	jmp	SHORT $LN4@CBExExtlAn
$LN3@CBExExtlAn:

; 3113 : 	}
; 3114 : 
; 3115 : 	if (playerAC->ExtlState(AircraftClass::ExtlLightFlags::Extl_Anti_Coll)){

	push	16					; 00000010H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN2@CBExExtlAn

; 3116 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3117 : 	}
; 3118 : 	else {

	jmp	SHORT $LN4@CBExExtlAn
$LN2@CBExExtlAn:

; 3119 : 		pCPButton->SetCurrentState(0);	//down

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExExtlAn:

; 3120 : 	}
; 3121 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExExtlAntiColl@@YAXPAXH@Z ENDP			; CBExExtlAntiColl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEExtlAntiColl@@YAXPAXH@Z PROC			; CBEExtlAntiColl

; 3103 : {

	push	ebp
	mov	ebp, esp

; 3104 :     SimExtlAntiColl(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimExtlAntiColl@@YAXKHPAX@Z		; SimExtlAntiColl
	add	esp, 12					; 0000000cH

; 3105 : }

	pop	ebp
	ret	0
?CBEExtlAntiColl@@YAXPAXH@Z ENDP			; CBEExtlAntiColl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExExtlPower@@YAXPAXH@Z PROC				; CBExExtlPower

; 3085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3086 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3087 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3088 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExExtlPo

; 3089 : 		return;

	jmp	SHORT $LN4@CBExExtlPo
$LN3@CBExExtlPo:

; 3090 : 	}
; 3091 : 
; 3092 : 	if (playerAC->ExtlState(AircraftClass::ExtlLightFlags::Extl_Main_Power)){

	push	4
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN2@CBExExtlPo

; 3093 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3094 : 	}
; 3095 : 	else {

	jmp	SHORT $LN4@CBExExtlPo
$LN2@CBExExtlPo:

; 3096 : 		pCPButton->SetCurrentState(0);	//down

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExExtlPo:

; 3097 : 	}
; 3098 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExExtlPower@@YAXPAXH@Z ENDP				; CBExExtlPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEExtlPower@@YAXPAXH@Z PROC				; CBEExtlPower

; 3080 : {

	push	ebp
	mov	ebp, esp

; 3081 :     SimExtlPower(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimExtlPower@@YAXKHPAX@Z		; SimExtlPower
	add	esp, 12					; 0000000cH

; 3082 : }

	pop	ebp
	ret	0
?CBEExtlPower@@YAXPAXH@Z ENDP				; CBEExtlPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExGndJettEnable@@YAXPAXH@Z PROC			; CBExGndJettEnable

; 3062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3063 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3064 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3065 : 	if (playerAC == NULL || playerAC->Sms == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN3@CBExGndJet
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	jne	SHORT $LN4@CBExGndJet
$LN3@CBExGndJet:

; 3066 : 		return;

	jmp	SHORT $LN5@CBExGndJet
$LN4@CBExGndJet:

; 3067 : 	}
; 3068 : 
; 3069 : 	if (playerAC->Sms->GndJett){

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	eax, DWORD PTR [edx+940]
	movzx	ecx, BYTE PTR [eax+13]
	test	ecx, ecx
	je	SHORT $LN2@CBExGndJet

; 3070 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3071 : 	}
; 3072 : 	else {

	jmp	SHORT $LN5@CBExGndJet
$LN2@CBExGndJet:

; 3073 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExGndJet:

; 3074 : 	}
; 3075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExGndJettEnable@@YAXPAXH@Z ENDP			; CBExGndJettEnable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEGndJettEnable@@YAXPAXH@Z PROC			; CBEGndJettEnable

; 3057 : {

	push	ebp
	mov	ebp, esp

; 3058 :     SimGndJettEnable(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimGndJettEnable@@YAXKHPAX@Z		; SimGndJettEnable
	add	esp, 12					; 0000000cH

; 3059 : }

	pop	ebp
	ret	0
?CBEGndJettEnable@@YAXPAXH@Z ENDP			; CBEGndJettEnable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEPinkySwitch@@YAXPAXH@Z PROC				; CBEPinkySwitch

; 3050 : {

	push	ebp
	mov	ebp, esp

; 3051 :     SimPinkySwitch(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimPinkySwitch@@YAXKHPAX@Z		; SimPinkySwitch
	add	esp, 12					; 0000000cH

; 3052 : }

	pop	ebp
	ret	0
?CBEPinkySwitch@@YAXPAXH@Z ENDP				; CBEPinkySwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExGearHandle@@YAXPAXH@Z PROC				; CBExGearHandle

; 3032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3033 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3034 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3035 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBExGearHa

; 3036 : 		return;

	jmp	SHORT $LN5@CBExGearHa
$LN4@CBExGearHa:

; 3037 : 	}
; 3038 : 
; 3039 : 	if (playerAC->af->gearHandle <= 0.0F){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+1556]
	jb	SHORT $LN3@CBExGearHa

; 3040 : 		pCPButton->SetCurrentState(0);	//Gear up

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN1@CBExGearHa
$LN3@CBExGearHa:

; 3041 : 	}
; 3042 : 	else if (playerAC->af->gearHandle > 0.0F){

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1556]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@CBExGearHa

; 3043 :         pCPButton->SetCurrentState(1);	//Gear Down	

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN1@CBExGearHa:
$LN5@CBExGearHa:

; 3044 : 	}
; 3045 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExGearHandle@@YAXPAXH@Z ENDP				; CBExGearHandle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEGearHandle@@YAXPAXH@Z PROC				; CBEGearHandle

; 3027 : {

	push	ebp
	mov	ebp, esp

; 3028 :     AFGearToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFGearToggle@@YAXKHPAX@Z		; AFGearToggle
	add	esp, 12					; 0000000cH

; 3029 : }

	pop	ebp
	ret	0
?CBEGearHandle@@YAXPAXH@Z ENDP				; CBEGearHandle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv68 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExRFSwitch@@YAXPAXH@Z PROC				; CBExRFSwitch

; 2998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2999 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 3000 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN7@CBExRFSwit

; 3001 : 		return;

	jmp	SHORT $LN8@CBExRFSwit
$LN7@CBExRFSwit:

; 3002 : 	}
; 3003 : 
; 3004 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 3005 : 	switch (playerAC->RFState){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+1520]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN4@CBExRFSwit
	cmp	DWORD PTR tv68[ebp], 1
	je	SHORT $LN3@CBExRFSwit
	cmp	DWORD PTR tv68[ebp], 2
	je	SHORT $LN2@CBExRFSwit
	jmp	SHORT $LN8@CBExRFSwit
$LN4@CBExRFSwit:

; 3006 : 		case 0:
; 3007 : 			//NORM
; 3008 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3009 : 		break;

	jmp	SHORT $LN8@CBExRFSwit
$LN3@CBExRFSwit:

; 3010 : 		case 1:
; 3011 : 			//QUIET
; 3012 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 3013 : 		break;

	jmp	SHORT $LN8@CBExRFSwit
$LN2@CBExRFSwit:

; 3014 : 		case 2:
; 3015 : 			//SILENT
; 3016 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN8@CBExRFSwit:

; 3017 : 		break;
; 3018 : 		default:
; 3019 : 			;
; 3020 : 	}
; 3021 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExRFSwitch@@YAXPAXH@Z ENDP				; CBExRFSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBERFSwitch@@YAXPAXH@Z PROC				; CBERFSwitch

; 2993 : {

	push	ebp
	mov	ebp, esp

; 2994 :     SimRFSwitch(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRFSwitch@@YAXKHPAX@Z		; SimRFSwitch
	add	esp, 12					; 0000000cH

; 2995 : }

	pop	ebp
	ret	0
?CBERFSwitch@@YAXPAXH@Z ENDP				; CBERFSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExInhibitVMS@@YAXPAXH@Z PROC				; CBExInhibitVMS

; 2975 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2976 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2977 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExInhibi

; 2978 : 		return;

	jmp	SHORT $LN4@CBExInhibi
$LN3@CBExInhibi:

; 2979 : 	}
; 2980 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2981 : 	if(!playerAC->playBetty){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+1516]
	test	edx, edx
	jne	SHORT $LN2@CBExInhibi

; 2982 : 		pCPButton->SetCurrentState(1); // Betty Off

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2983 : 	}
; 2984 : 	else{

	jmp	SHORT $LN4@CBExInhibi
$LN2@CBExInhibi:

; 2985 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExInhibi:

; 2986 : 	}
; 2987 : 
; 2988 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExInhibitVMS@@YAXPAXH@Z ENDP				; CBExInhibitVMS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEInhibitVMS@@YAXPAXH@Z PROC				; CBEInhibitVMS

; 2970 : {

	push	ebp
	mov	ebp, esp

; 2971 :     SimInhibitVMS(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimInhibitVMS@@YAXKHPAX@Z		; SimInhibitVMS
	add	esp, 12					; 0000000cH

; 2972 : }

	pop	ebp
	ret	0
?CBEInhibitVMS@@YAXPAXH@Z ENDP				; CBEInhibitVMS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExIdleDetent@@YAXPAXH@Z PROC				; CBExIdleDetent

; 2962 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2963 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2964 :     pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExIdleDe
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExIdleDe
$LN3@CBExIdleDe:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExIdleDe:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2965 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExIdleDetent@@YAXPAXH@Z ENDP				; CBExIdleDetent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEIdleDetent@@YAXPAXH@Z PROC				; CBEIdleDetent

; 2957 : {

	push	ebp
	mov	ebp, esp

; 2958 :     SimThrottleIdleDetent(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimThrottleIdleDetent@@YAXKHPAX@Z	; SimThrottleIdleDetent
	add	esp, 12					; 0000000cH

; 2959 : }

	pop	ebp
	ret	0
?CBEIdleDetent@@YAXPAXH@Z ENDP				; CBEIdleDetent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExNwsToggle@@YAXPAXH@Z PROC				; CBExNwsToggle

; 2938 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2939 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2940 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExNwsTog

; 2941 : 		return;

	jmp	SHORT $LN4@CBExNwsTog
$LN3@CBExNwsTog:

; 2942 : 	}
; 2943 : 
; 2944 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2945 : 	if(playerAC->af->IsSet(AirframeClass::NoseSteerOn)) {

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@CBExNwsTog

; 2946 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2947 : 	}
; 2948 : 	else {

	jmp	SHORT $LN4@CBExNwsTog
$LN2@CBExNwsTog:

; 2949 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExNwsTog:

; 2950 : 	}
; 2951 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExNwsToggle@@YAXPAXH@Z ENDP				; CBExNwsToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBENwsToggle@@YAXPAXH@Z PROC				; CBENwsToggle

; 2923 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2924 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2925 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBENwsTogg

; 2926 : 		return;

	jmp	SHORT $LN4@CBENwsTogg
$LN3@CBENwsTogg:

; 2927 : 	}
; 2928 : 
; 2929 : 	if (!playerAC->af->IsSet(AirframeClass::NoseSteerOn)){

	push	4194304					; 00400000H
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN2@CBENwsTogg

; 2930 : 		playerAC->af->SetFlag(AirframeClass::NoseSteerOn);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 2931 : 	}
; 2932 : 	else {

	jmp	SHORT $LN4@CBENwsTogg
$LN2@CBENwsTogg:

; 2933 : 		playerAC->af->ClearFlag(AirframeClass::NoseSteerOn);

	push	4194304					; 00400000H
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN4@CBENwsTogg:

; 2934 : 	}
; 2935 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBENwsToggle@@YAXPAXH@Z ENDP				; CBENwsToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv69 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExMainPower@@YAXPAXH@Z PROC				; CBExMainPower

; 2893 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2894 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2895 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN7@CBExMainPo

; 2896 : 		return;

	jmp	SHORT $LN8@CBExMainPo
$LN7@CBExMainPo:

; 2897 : 	}
; 2898 : 
; 2899 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2900 : 	switch(playerAC->MainPower())

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ; AircraftClass::MainPower
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN4@CBExMainPo
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $LN3@CBExMainPo
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN2@CBExMainPo
	jmp	SHORT $LN8@CBExMainPo
$LN4@CBExMainPo:

; 2901 : 	{
; 2902 : 		case AircraftClass::MainPowerOff:
; 2903 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2904 : 			break;

	jmp	SHORT $LN8@CBExMainPo
$LN3@CBExMainPo:

; 2905 : 		case AircraftClass::MainPowerBatt:
; 2906 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2907 : 			break;

	jmp	SHORT $LN8@CBExMainPo
$LN2@CBExMainPo:

; 2908 : 		case AircraftClass::MainPowerMain:
; 2909 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN8@CBExMainPo:

; 2910 : 			break;
; 2911 : 		default:
; 2912 : 			ShiWarning("Unknown main power state");
; 2913 : 			break;
; 2914 : 	}
; 2915 : 
; 2916 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMainPower@@YAXPAXH@Z ENDP				; CBExMainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEMainPower@@YAXPAXH@Z PROC				; CBEMainPower

; 2883 : {

	push	ebp
	mov	ebp, esp

; 2884 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEMainPow

; 2885 : 		SimMainPowerInc (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimMainPowerInc@@YAXKHPAX@Z		; SimMainPowerInc
	add	esp, 12					; 0000000cH

; 2886 : 	}
; 2887 : 	else {

	jmp	SHORT $LN3@CBEMainPow
$LN2@CBEMainPow:

; 2888 : 		SimMainPowerDec(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimMainPowerDec@@YAXKHPAX@Z		; SimMainPowerDec
	add	esp, 12					; 0000000cH
$LN3@CBEMainPow:

; 2889 : 	}
; 2890 : }

	pop	ebp
	ret	0
?CBEMainPower@@YAXPAXH@Z ENDP				; CBEMainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEWSProgButton@@YAXPAXH@Z PROC			; CBEEWSProgButton

; 2872 : {

	push	ebp
	mov	ebp, esp

; 2873 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEEWSProg

; 2874 : 		SimEWSProgInc (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEWSProgInc@@YAXKHPAX@Z		; SimEWSProgInc
	add	esp, 12					; 0000000cH

; 2875 : 	}
; 2876 : 	else {

	jmp	SHORT $LN3@CBEEWSProg
$LN2@CBEEWSProg:

; 2877 : 		SimEWSProgDec(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEWSProgDec@@YAXKHPAX@Z		; SimEWSProgDec
	add	esp, 12					; 0000000cH
$LN3@CBEEWSProg:

; 2878 : 	}
; 2879 : }

	pop	ebp
	ret	0
?CBEEWSProgButton@@YAXPAXH@Z ENDP			; CBEEWSProgButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv68 = -12						; size = 4
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEWSProgButton@@YAXPAXH@Z PROC			; CBExEWSProgButton

; 2844 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2845 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2846 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN8@CBExEWSPro

; 2847 : 		return;

	jmp	SHORT $LN9@CBExEWSPro
$LN8@CBExEWSPro:

; 2848 : 	}
; 2849 : 
; 2850 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2851 : 	switch(playerAC->EWSProgNum){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+1500]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 3
	ja	SHORT $LN9@CBExEWSPro
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN11@CBExEWSPro[eax*4]
$LN5@CBExEWSPro:

; 2852 : 		case 0:
; 2853 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2854 : 		break;

	jmp	SHORT $LN9@CBExEWSPro
$LN4@CBExEWSPro:

; 2855 : 		case 1:
; 2856 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2857 : 		break;

	jmp	SHORT $LN9@CBExEWSPro
$LN3@CBExEWSPro:

; 2858 : 		case 2:
; 2859 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2860 : 		break;

	jmp	SHORT $LN9@CBExEWSPro
$LN2@CBExEWSPro:

; 2861 : 		case 3:
; 2862 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN9@CBExEWSPro:

; 2863 : 		break;
; 2864 : 		default:
; 2865 : 			ShiWarning("Unknown EWS Program state");
; 2866 : 		break;
; 2867 : 	}
; 2868 : 
; 2869 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN11@CBExEWSPro:
	DD	$LN5@CBExEWSPro
	DD	$LN4@CBExEWSPro
	DD	$LN3@CBExEWSPro
	DD	$LN2@CBExEWSPro
?CBExEWSProgButton@@YAXPAXH@Z ENDP			; CBExEWSProgButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEWSPGMButton@@YAXPAXH@Z PROC			; CBEEWSPGMButton

; 2833 : {

	push	ebp
	mov	ebp, esp

; 2834 : 	if (event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEEWSPGMB

; 2835 : 		SimEWSPGMInc (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEWSPGMInc@@YAXKHPAX@Z		; SimEWSPGMInc
	add	esp, 12					; 0000000cH

; 2836 : 	}
; 2837 : 	else {

	jmp	SHORT $LN3@CBEEWSPGMB
$LN2@CBEEWSPGMB:

; 2838 : 		SimEWSPGMDec(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEWSPGMDec@@YAXKHPAX@Z		; SimEWSPGMDec
	add	esp, 12					; 0000000cH
$LN3@CBEEWSPGMB:

; 2839 : 	}
; 2840 : }

	pop	ebp
	ret	0
?CBEEWSPGMButton@@YAXPAXH@Z ENDP			; CBEEWSPGMButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv69 = -12						; size = 4
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEWSPGMButton@@YAXPAXH@Z PROC			; CBExEWSPGMButton

; 2803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2804 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2805 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2806 :     if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN9@CBExEWSPGM

; 2807 : 		return;

	jmp	SHORT $LN10@CBExEWSPGM
$LN9@CBExEWSPGM:

; 2808 : 	}
; 2809 : 
; 2810 : 	switch (playerAC->EWSPGM()){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 4
	ja	SHORT $LN10@CBExEWSPGM
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN12@CBExEWSPGM[ecx*4]
$LN6@CBExEWSPGM:

; 2811 : 		case AircraftClass::EWSPGMSwitch::Off:
; 2812 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2813 : 		break;

	jmp	SHORT $LN10@CBExEWSPGM
$LN5@CBExEWSPGM:

; 2814 : 		case AircraftClass::EWSPGMSwitch::Stby:
; 2815 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2816 : 		break;

	jmp	SHORT $LN10@CBExEWSPGM
$LN4@CBExEWSPGM:

; 2817 : 		case AircraftClass::EWSPGMSwitch::Man:
; 2818 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2819 : 		break;

	jmp	SHORT $LN10@CBExEWSPGM
$LN3@CBExEWSPGM:

; 2820 : 		case AircraftClass::EWSPGMSwitch::Semi:
; 2821 : 			pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2822 : 		break;

	jmp	SHORT $LN10@CBExEWSPGM
$LN2@CBExEWSPGM:

; 2823 : 		case AircraftClass::EWSPGMSwitch::Auto:
; 2824 : 			pCPButton->SetCurrentState(4);

	push	4
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN10@CBExEWSPGM:

; 2825 : 		break;
; 2826 : 		default:
; 2827 : 			ShiWarning("Unknown EWS PGM state");
; 2828 : 		break;
; 2829 : 	}
; 2830 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@CBExEWSPGM:
	DD	$LN6@CBExEWSPGM
	DD	$LN5@CBExEWSPGM
	DD	$LN4@CBExEWSPGM
	DD	$LN3@CBExEWSPGM
	DD	$LN2@CBExEWSPGM
?CBExEWSPGMButton@@YAXPAXH@Z ENDP			; CBExEWSPGMButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEWSFlarePower@@YAXPAXH@Z PROC			; CBEEWSFlarePower

; 2798 : {

	push	ebp
	mov	ebp, esp

; 2799 :     SimEWSFlarePower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimEWSFlarePower@@YAXKHPAX@Z		; SimEWSFlarePower
	add	esp, 12					; 0000000cH

; 2800 : }

	pop	ebp
	ret	0
?CBEEWSFlarePower@@YAXPAXH@Z ENDP			; CBEEWSFlarePower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEWSFlarePowerSwitch@@YAXPAXH@Z PROC		; CBExEWSFlarePowerSwitch

; 2776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2777 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2778 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBExEWSFla

; 2779 : 		return;

	jmp	SHORT $LN5@CBExEWSFla
$LN4@CBExEWSFla:

; 2780 : 	}
; 2781 : 
; 2782 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2783 : 
; 2784 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@CBExEWSFla

; 2785 : 	{
; 2786 : 		//MI we need this
; 2787 : 		if(playerAC->PowerSwitchOn(AircraftClass::EWSFlarePower)){

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExEWSFla

; 2788 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2789 : 		}
; 2790 : 		else{

	jmp	SHORT $LN5@CBExEWSFla
$LN2@CBExEWSFla:

; 2791 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExEWSFla:

; 2792 : 		}
; 2793 : 		//pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO
; 2794 : 	}
; 2795 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEWSFlarePowerSwitch@@YAXPAXH@Z ENDP		; CBExEWSFlarePowerSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEWSChaffPower@@YAXPAXH@Z PROC			; CBEEWSChaffPower

; 2771 : {

	push	ebp
	mov	ebp, esp

; 2772 :     SimEWSChaffPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimEWSChaffPower@@YAXKHPAX@Z		; SimEWSChaffPower
	add	esp, 12					; 0000000cH

; 2773 : }

	pop	ebp
	ret	0
?CBEEWSChaffPower@@YAXPAXH@Z ENDP			; CBEEWSChaffPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEWSChaffPowerSwitch@@YAXPAXH@Z PROC		; CBExEWSChaffPowerSwitch

; 2749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2750 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2751 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBExEWSCha

; 2752 : 		return;

	jmp	SHORT $LN5@CBExEWSCha
$LN4@CBExEWSCha:

; 2753 : 	}
; 2754 : 
; 2755 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2756 : 
; 2757 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@CBExEWSCha

; 2758 : 	{
; 2759 : 		//MI we need this
; 2760 : 		if(playerAC->PowerSwitchOn(AircraftClass::EWSChaffPower)){

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExEWSCha

; 2761 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2762 : 		}
; 2763 : 		else{

	jmp	SHORT $LN5@CBExEWSCha
$LN2@CBExEWSCha:

; 2764 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExEWSCha:

; 2765 : 		}
; 2766 : 		//pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO
; 2767 : 	}
; 2768 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEWSChaffPowerSwitch@@YAXPAXH@Z ENDP		; CBExEWSChaffPowerSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEWSJammerPower@@YAXPAXH@Z PROC			; CBEEWSJammerPower

; 2744 : {

	push	ebp
	mov	ebp, esp

; 2745 :     SimEWSJammerPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimEWSJammerPower@@YAXKHPAX@Z		; SimEWSJammerPower
	add	esp, 12					; 0000000cH

; 2746 : }

	pop	ebp
	ret	0
?CBEEWSJammerPower@@YAXPAXH@Z ENDP			; CBEEWSJammerPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEWSJammerPowerSwitch@@YAXPAXH@Z PROC		; CBExEWSJammerPowerSwitch

; 2722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2723 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2724 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBExEWSJam

; 2725 : 		return;

	jmp	SHORT $LN5@CBExEWSJam
$LN4@CBExEWSJam:

; 2726 : 	}
; 2727 : 
; 2728 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2729 : 
; 2730 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@CBExEWSJam

; 2731 : 	{
; 2732 : 		//MI we need this
; 2733 : 		if(playerAC->PowerSwitchOn(AircraftClass::EWSJammerPower)){

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExEWSJam

; 2734 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2735 : 		}
; 2736 : 		else{

	jmp	SHORT $LN5@CBExEWSJam
$LN2@CBExEWSJam:

; 2737 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExEWSJam:

; 2738 : 		}
; 2739 : 		//pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO
; 2740 : 	}
; 2741 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEWSJammerPowerSwitch@@YAXPAXH@Z ENDP		; CBExEWSJammerPowerSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEEWSRWRPower@@YAXPAXH@Z PROC				; CBEEWSRWRPower

; 2717 : {

	push	ebp
	mov	ebp, esp

; 2718 :     SimEWSRWRPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimEWSRWRPower@@YAXKHPAX@Z		; SimEWSRWRPower
	add	esp, 12					; 0000000cH

; 2719 : }

	pop	ebp
	ret	0
?CBEEWSRWRPower@@YAXPAXH@Z ENDP				; CBEEWSRWRPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExEWSRWRPowerSwitch@@YAXPAXH@Z PROC			; CBExEWSRWRPowerSwitch

; 2696 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2697 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2698 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBExEWSRWR

; 2699 : 		return;

	jmp	SHORT $LN5@CBExEWSRWR
$LN4@CBExEWSRWR:

; 2700 : 	}
; 2701 : 
; 2702 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2703 : 
; 2704 : 	if(g_bRealisticAvionics){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN5@CBExEWSRWR

; 2705 : 		//MI we need this
; 2706 : 		if(playerAC->PowerSwitchOn(AircraftClass::EWSRWRPower)){

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExEWSRWR

; 2707 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2708 : 		}
; 2709 : 		else{

	jmp	SHORT $LN5@CBExEWSRWR
$LN2@CBExEWSRWR:

; 2710 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExEWSRWR:

; 2711 : 		}
; 2712 : 	    //pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO
; 2713 : 	}
; 2714 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEWSRWRPowerSwitch@@YAXPAXH@Z ENDP			; CBExEWSRWRPowerSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExSeatArmSwitch@@YAXPAXH@Z PROC			; CBExSeatArmSwitch

; 2679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2680 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2681 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExSeatAr

; 2682 : 		return;

	jmp	SHORT $LN4@CBExSeatAr
$LN3@CBExSeatAr:

; 2683 : 	}
; 2684 : 
; 2685 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2686 : 	if(playerAC->SeatArmed){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+1052]
	test	edx, edx
	je	SHORT $LN2@CBExSeatAr

; 2687 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2688 : 	}
; 2689 : 	else{

	jmp	SHORT $LN4@CBExSeatAr
$LN2@CBExSeatAr:

; 2690 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExSeatAr:

; 2691 :     }
; 2692 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExSeatArmSwitch@@YAXPAXH@Z ENDP			; CBExSeatArmSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBESeatArmSwitch@@YAXPAXH@Z PROC			; CBESeatArmSwitch

; 2674 : {

	push	ebp
	mov	ebp, esp

; 2675 :     SimSeatArm(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimSeatArm@@YAXKHPAX@Z			; SimSeatArm
	add	esp, 12					; 0000000cH

; 2676 : }

	pop	ebp
	ret	0
?CBESeatArmSwitch@@YAXPAXH@Z ENDP			; CBESeatArmSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv69 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExSpotLightSwitch@@YAXPAXH@Z PROC			; CBExSpotLightSwitch

; 2650 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2651 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2652 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN6@CBExSpotLi

; 2653 : 		return;

	jmp	SHORT $LN7@CBExSpotLi
$LN6@CBExSpotLi:

; 2654 : 	}
; 2655 : 
; 2656 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2657 : 	switch (playerAC->GetSpotLight()) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@CBExSpotLi
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $LN2@CBExSpotLi
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN1@CBExSpotLi
	jmp	SHORT $LN7@CBExSpotLi
$LN3@CBExSpotLi:

; 2658 : 		case AircraftClass::LT_OFF:
; 2659 : 		    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2660 : 	    break;

	jmp	SHORT $LN7@CBExSpotLi
$LN2@CBExSpotLi:

; 2661 : 		case AircraftClass::LT_LOW:
; 2662 : 		    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2663 : 	    break;

	jmp	SHORT $LN7@CBExSpotLi
$LN1@CBExSpotLi:

; 2664 : 		case AircraftClass::LT_NORMAL:
; 2665 : 		    pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExSpotLi:

; 2666 : 	    break;
; 2667 :     }
; 2668 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExSpotLightSwitch@@YAXPAXH@Z ENDP			; CBExSpotLightSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBESpotLightSwitch@@YAXPAXH@Z PROC			; CBESpotLightSwitch

; 2645 : {

	push	ebp
	mov	ebp, esp

; 2646 :     SimSpotLight(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimSpotLight@@YAXKHPAX@Z		; SimSpotLight
	add	esp, 12					; 0000000cH

; 2647 : }

	pop	ebp
	ret	0
?CBESpotLightSwitch@@YAXPAXH@Z ENDP			; CBESpotLightSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv69 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExInstrumentLightSwitch@@YAXPAXH@Z PROC		; CBExInstrumentLightSwitch

; 2617 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2618 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2619 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN6@CBExInstru

; 2620 : 		return;

	jmp	SHORT $LN7@CBExInstru
$LN6@CBExInstru:

; 2621 : 	}
; 2622 : 
; 2623 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2624 : 	switch (playerAC->GetInstrumentLight()) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@CBExInstru
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $LN2@CBExInstru
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN1@CBExInstru
	jmp	SHORT $LN7@CBExInstru
$LN3@CBExInstru:

; 2625 : 		case AircraftClass::LT_OFF:
; 2626 : 		    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2627 : 	    break;

	jmp	SHORT $LN7@CBExInstru
$LN2@CBExInstru:

; 2628 : 		case AircraftClass::LT_LOW:
; 2629 : 		    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2630 : 	    break;

	jmp	SHORT $LN7@CBExInstru
$LN1@CBExInstru:

; 2631 : 		case AircraftClass::LT_NORMAL:
; 2632 : 		    pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExInstru:

; 2633 : 	    break;
; 2634 :     }
; 2635 : //	if (OTWDriver.pCockpitManager != NULL){
; 2636 : //		OTWDriver.pCockpitManager->UpdatePalette();
; 2637 : //	}
; 2638 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExInstrumentLightSwitch@@YAXPAXH@Z ENDP		; CBExInstrumentLightSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEInstrumentLightSwitch@@YAXPAXH@Z PROC		; CBEInstrumentLightSwitch

; 2612 : {

	push	ebp
	mov	ebp, esp

; 2613 :     SimInstrumentLight(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimInstrumentLight@@YAXKHPAX@Z		; SimInstrumentLight
	add	esp, 12					; 0000000cH

; 2614 : }

	pop	ebp
	ret	0
?CBEInstrumentLightSwitch@@YAXPAXH@Z ENDP		; CBEInstrumentLightSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv69 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExInteriorLightSwitch@@YAXPAXH@Z PROC		; CBExInteriorLightSwitch

; 2583 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2584 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2585 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN6@CBExInteri

; 2586 : 		return;

	jmp	SHORT $LN7@CBExInteri
$LN6@CBExInteri:

; 2587 : 	}
; 2588 : 
; 2589 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2590 : 	switch (playerAC->GetInteriorLight()) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@CBExInteri
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $LN2@CBExInteri
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN1@CBExInteri
	jmp	SHORT $LN7@CBExInteri
$LN3@CBExInteri:

; 2591 : 		case AircraftClass::LT_OFF:
; 2592 : 		    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2593 : 	    break;

	jmp	SHORT $LN7@CBExInteri
$LN2@CBExInteri:

; 2594 : 		case AircraftClass::LT_LOW:
; 2595 : 		    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2596 : 	    break;

	jmp	SHORT $LN7@CBExInteri
$LN1@CBExInteri:

; 2597 : 		case AircraftClass::LT_NORMAL:
; 2598 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExInteri:

; 2599 : 	    break;
; 2600 :     }
; 2601 : //	if (OTWDriver.pCockpitManager != NULL){
; 2602 : //		OTWDriver.pCockpitManager->UpdatePalette();
; 2603 : //	}
; 2604 : 
; 2605 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExInteriorLightSwitch@@YAXPAXH@Z ENDP		; CBExInteriorLightSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEInteriorLightSwitch@@YAXPAXH@Z PROC			; CBEInteriorLightSwitch

; 2578 : {

	push	ebp
	mov	ebp, esp

; 2579 :     SimInteriorLight(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimInteriorLight@@YAXKHPAX@Z		; SimInteriorLight
	add	esp, 12					; 0000000cH

; 2580 : }

	pop	ebp
	ret	0
?CBEInteriorLightSwitch@@YAXPAXH@Z ENDP			; CBEInteriorLightSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExReticleSwitch@@YAXPAXH@Z PROC			; CBExReticleSwitch

; 2553 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2554 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2555 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN5@CBExReticl

; 2556 : 		return;

	jmp	SHORT $LN6@CBExReticl
$LN5@CBExReticl:

; 2557 : 	}
; 2558 : 
; 2559 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2560 : 	if(TheHud->WhichMode == 1){

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [ecx+5016], 1
	jne	SHORT $LN4@CBExReticl

; 2561 : 		//normal
; 2562 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN6@CBExReticl
$LN4@CBExReticl:

; 2563 : 	}
; 2564 : 	else if (TheHud->WhichMode == 2){

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [edx+5016], 2
	jne	SHORT $LN2@CBExReticl

; 2565 : 		//backup
; 2566 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2567 : 	}
; 2568 : 	else{

	jmp	SHORT $LN6@CBExReticl
$LN2@CBExReticl:

; 2569 : 		pCPButton->SetCurrentState(0);	//off

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN6@CBExReticl:

; 2570 : 	}
; 2571 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExReticleSwitch@@YAXPAXH@Z ENDP			; CBExReticleSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEReticleSwitch@@YAXPAXH@Z PROC			; CBEReticleSwitch

; 2548 : {

	push	ebp
	mov	ebp, esp

; 2549 :     SimReticleSwitch(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimReticleSwitch@@YAXKHPAX@Z		; SimReticleSwitch
	add	esp, 12					; 0000000cH

; 2550 : }

	pop	ebp
	ret	0
?CBEReticleSwitch@@YAXPAXH@Z ENDP			; CBEReticleSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv68 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExWarnReset@@YAXPAXH@Z PROC				; CBExWarnReset

; 2536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2537 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2538 : 
; 2539 : 	if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN2@CBExWarnRe

; 2540 : 	{
; 2541 : 	    pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN4@CBExWarnRe
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN5@CBExWarnRe
$LN4@CBExWarnRe:
	mov	DWORD PTR tv68[ebp], 1
$LN5@CBExWarnRe:
	mov	edx, DWORD PTR tv68[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExWarnRe:

; 2542 : 	}
; 2543 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExWarnReset@@YAXPAXH@Z ENDP				; CBExWarnReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEWarnReset@@YAXPAXH@Z PROC				; CBEWarnReset

; 2529 : {

	push	ebp
	mov	ebp, esp

; 2530 :     SimWarnReset(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimWarnReset@@YAXKHPAX@Z		; SimWarnReset
	add	esp, 12					; 0000000cH

; 2531 : }

	pop	ebp
	ret	0
?CBEWarnReset@@YAXPAXH@Z ENDP				; CBEWarnReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAPOverride@@YAXPAXH@Z PROC				; CBEAPOverride

; 2521 : {

	push	ebp
	mov	ebp, esp

; 2522 :     SimAPOverride(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimAPOverride@@YAXKHPAX@Z		; SimAPOverride
	add	esp, 12					; 0000000cH

; 2523 : }

	pop	ebp
	ret	0
?CBEAPOverride@@YAXPAXH@Z ENDP				; CBEAPOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExLeftAPSwitch@@YAXPAXH@Z PROC			; CBExLeftAPSwitch

; 2500 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2501 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2502 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN5@CBExLeftAP

; 2503 : 		return;

	jmp	SHORT $LN6@CBExLeftAP
$LN5@CBExLeftAP:

; 2504 : 	}
; 2505 : 
; 2506 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2507 : 	if(playerAC->IsOn(AircraftClass::HDGSel)){

	push	16					; 00000010H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN4@CBExLeftAP

; 2508 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN6@CBExLeftAP
$LN4@CBExLeftAP:

; 2509 : 	}
; 2510 : 	else if(playerAC->IsOn(AircraftClass::StrgSel)) {

	push	4
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN2@CBExLeftAP

; 2511 : 		pCPButton->SetCurrentState(2);	//down

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2512 : 	}
; 2513 : 	else{

	jmp	SHORT $LN6@CBExLeftAP
$LN2@CBExLeftAP:

; 2514 : 		pCPButton->SetCurrentState(0);	//middle*/

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN6@CBExLeftAP:

; 2515 : 	}
; 2516 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExLeftAPSwitch@@YAXPAXH@Z ENDP			; CBExLeftAPSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBELeftAPSwitch@@YAXPAXH@Z PROC			; CBELeftAPSwitch

; 2495 : {

	push	ebp
	mov	ebp, esp

; 2496 :     SimLeftAPSwitch(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimLeftAPSwitch@@YAXKHPAX@Z		; SimLeftAPSwitch
	add	esp, 12					; 0000000cH

; 2497 : }

	pop	ebp
	ret	0
?CBELeftAPSwitch@@YAXPAXH@Z ENDP			; CBELeftAPSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExRightAPSwitch@@YAXPAXH@Z PROC			; CBExRightAPSwitch

; 2474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2475 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2476 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN5@CBExRightA

; 2477 : 		return;

	jmp	SHORT $LN6@CBExRightA
$LN5@CBExRightA:

; 2478 : 	}
; 2479 : 
; 2480 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2481 : 	if(playerAC->IsOn(AircraftClass::AttHold)){

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN4@CBExRightA

; 2482 : 		pCPButton->SetCurrentState(2);	//down

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
	jmp	SHORT $LN6@CBExRightA
$LN4@CBExRightA:

; 2483 : 	}
; 2484 : 	else if(playerAC->IsOn(AircraftClass::AltHold)) {

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN2@CBExRightA

; 2485 : 		pCPButton->SetCurrentState(1);	//up

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2486 : 	}
; 2487 : 	else{

	jmp	SHORT $LN6@CBExRightA
$LN2@CBExRightA:

; 2488 : 		pCPButton->SetCurrentState(0);	//middle

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN6@CBExRightA:

; 2489 : 	}
; 2490 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExRightAPSwitch@@YAXPAXH@Z ENDP			; CBExRightAPSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBERightAPSwitch@@YAXPAXH@Z PROC			; CBERightAPSwitch

; 2469 : {

	push	ebp
	mov	ebp, esp

; 2470 :     SimRightAPSwitch(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRightAPSwitch@@YAXKHPAX@Z		; SimRightAPSwitch
	add	esp, 12					; 0000000cH

; 2471 : }

	pop	ebp
	ret	0
?CBERightAPSwitch@@YAXPAXH@Z ENDP			; CBERightAPSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFuelDoorToggle@@YAXPAXH@Z PROC			; CBExFuelDoorToggle

; 2451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2452 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2453 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExFuelDo

; 2454 : 		return;

	jmp	SHORT $LN4@CBExFuelDo
$LN3@CBExFuelDo:

; 2455 : 	}
; 2456 : 
; 2457 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2458 : 	if(playerAC->af->IsEngineFlag(AirframeClass::FuelDoorOpen)) {

	push	4
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN2@CBExFuelDo

; 2459 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2460 : 	}
; 2461 : 	else {

	jmp	SHORT $LN4@CBExFuelDo
$LN2@CBExFuelDo:

; 2462 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExFuelDo:

; 2463 :     }
; 2464 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFuelDoorToggle@@YAXPAXH@Z ENDP			; CBExFuelDoorToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFuelDoorToggle@@YAXPAXH@Z PROC			; CBEFuelDoorToggle

; 2446 : {

	push	ebp
	mov	ebp, esp

; 2447 :     SimFuelDoorToggle(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimFuelDoorToggle@@YAXKHPAX@Z		; SimFuelDoorToggle
	add	esp, 12					; 0000000cH

; 2448 : }

	pop	ebp
	ret	0
?CBEFuelDoorToggle@@YAXPAXH@Z ENDP			; CBEFuelDoorToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExLaserArmToggle@@YAXPAXH@Z PROC			; CBExLaserArmToggle

; 2428 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2429 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2430 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2431 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExLaserA

; 2432 : 		return;

	jmp	SHORT $LN4@CBExLaserA
$LN3@CBExLaserA:

; 2433 : 	}
; 2434 : 
; 2435 : 	if(playerAC->FCC->LaserArm) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	movzx	eax, BYTE PTR [edx+420]
	test	eax, eax
	je	SHORT $LN2@CBExLaserA

; 2436 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2437 : 	}
; 2438 : 	else{

	jmp	SHORT $LN4@CBExLaserA
$LN2@CBExLaserA:

; 2439 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExLaserA:

; 2440 : 	}
; 2441 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExLaserArmToggle@@YAXPAXH@Z ENDP			; CBExLaserArmToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBELaserArmToggle@@YAXPAXH@Z PROC			; CBELaserArmToggle

; 2423 : {

	push	ebp
	mov	ebp, esp

; 2424 :     SimLaserArmToggle(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimLaserArmToggle@@YAXKHPAX@Z		; SimLaserArmToggle
	add	esp, 12					; 0000000cH

; 2425 : }

	pop	ebp
	ret	0
?CBELaserArmToggle@@YAXPAXH@Z ENDP			; CBELaserArmToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHookToggle@@YAXPAXH@Z PROC				; CBExHookToggle

; 2391 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2392 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2393 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExHookTo

; 2394 : 		return;

	jmp	SHORT $LN4@CBExHookTo
$LN3@CBExHookTo:

; 2395 : 	}
; 2396 : 
; 2397 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2398 : 	//MI if the hook is not up, we get the caution
; 2399 : 	// MD -- 20031006: true but that should be moved to ToggleHook() in Airframe.cpp
; 2400 : 	// to ensure that the fault is set regardless of whether we are looking at the cockpit
; 2401 : 	//FackClass*		faultSys;
; 2402 : 	//faultSys	= playerAC->mFaults;
; 2403 : 
; 2404 : 	if(playerAC->af->IsSet(AirframeClass::Hook)){

	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@CBExHookTo

; 2405 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2406 : 		//MI
; 2407 : 		//if(faultSys && playerAC->af->platform->IsF16())
; 2408 : 		//	faultSys->SetCaution(hook_fault);
; 2409 : 	}
; 2410 : 	else {

	jmp	SHORT $LN4@CBExHookTo
$LN2@CBExHookTo:

; 2411 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExHookTo:

; 2412 : 		//MI
; 2413 : 		//if(faultSys && faultSys->GetFault(hook_fault) && playerAC->af->platform->IsF16())
; 2414 : 		//	faultSys->ClearFault(hook_fault);
; 2415 : 	}
; 2416 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHookToggle@@YAXPAXH@Z ENDP				; CBExHookToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEHookToggle@@YAXPAXH@Z PROC				; CBEHookToggle

; 2386 : {

	push	ebp
	mov	ebp, esp

; 2387 :     SimHookToggle(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimHookToggle@@YAXKHPAX@Z		; SimHookToggle
	add	esp, 12					; 0000000cH

; 2388 : }

	pop	ebp
	ret	0
?CBEHookToggle@@YAXPAXH@Z ENDP				; CBEHookToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExParkingBrakeToggle@@YAXPAXH@Z PROC			; CBExParkingBrakeToggle

; 2366 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2367 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2368 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExParkin

; 2369 : 		return;

	jmp	SHORT $LN4@CBExParkin
$LN3@CBExParkin:

; 2370 : 	}
; 2371 : 
; 2372 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2373 : 	if(playerAC->af->PBON) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movzx	eax, BYTE PTR [edx+1616]
	test	eax, eax
	je	SHORT $LN2@CBExParkin

; 2374 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2375 : 	}
; 2376 : 	else {

	jmp	SHORT $LN4@CBExParkin
$LN2@CBExParkin:

; 2377 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExParkin:

; 2378 : 	}
; 2379 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExParkingBrakeToggle@@YAXPAXH@Z ENDP			; CBExParkingBrakeToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEParkingBrakeToggle@@YAXPAXH@Z PROC			; CBEParkingBrakeToggle

; 2361 : {

	push	ebp
	mov	ebp, esp

; 2362 :     SimParkingBrakeToggle(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimParkingBrakeToggle@@YAXKHPAX@Z	; SimParkingBrakeToggle
	add	esp, 12					; 0000000cH

; 2363 : }

	pop	ebp
	ret	0
?CBEParkingBrakeToggle@@YAXPAXH@Z ENDP			; CBEParkingBrakeToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExLandingLightToggle@@YAXPAXH@Z PROC			; CBExLandingLightToggle

; 2343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2344 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2345 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExLandin

; 2346 : 		return;

	jmp	SHORT $LN4@CBExLandin
$LN3@CBExLandin:

; 2347 : 	}
; 2348 : 
; 2349 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2350 : 	if (playerAC->IsAcStatusBitsSet(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT)) {

	push	32					; 00000020H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@CBExLandin

; 2351 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2352 : 	}
; 2353 : 	else {

	jmp	SHORT $LN4@CBExLandin
$LN2@CBExLandin:

; 2354 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExLandin:

; 2355 : 	}
; 2356 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExLandingLightToggle@@YAXPAXH@Z ENDP			; CBExLandingLightToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBELandingLightToggle@@YAXPAXH@Z PROC			; CBELandingLightToggle

; 2338 : {

	push	ebp
	mov	ebp, esp

; 2339 :     SimLandingLightToggle(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimLandingLightToggle@@YAXKHPAX@Z	; SimLandingLightToggle
	add	esp, 12					; 0000000cH

; 2340 : }

	pop	ebp
	ret	0
?CBELandingLightToggle@@YAXPAXH@Z ENDP			; CBELandingLightToggle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAirSource@@YAXPAXH@Z PROC				; CBExAirSource

; 2325 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2326 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2327 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExAirSou

; 2328 : 		return;

	jmp	SHORT $LN2@CBExAirSou
$LN1@CBExAirSou:

; 2329 : 	}
; 2330 : 
; 2331 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2332 : 	pCPButton->SetCurrentState((int)playerAC->af->GetAirSource());

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExAirSou:

; 2333 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAirSource@@YAXPAXH@Z ENDP				; CBExAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAirSource@@YAXPAXH@Z PROC				; CBEAirSource

; 2310 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2311 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2312 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEAirSour

; 2313 : 		return;

	jmp	SHORT $LN4@CBEAirSour
$LN3@CBEAirSour:

; 2314 : 	}
; 2315 : 
; 2316 : 	if(event == CP_MOUSE_BUTTON0) {

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEAirSour

; 2317 : 	    playerAC->af->IncAirSource();

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IncAirSource@AirframeClass@@QAEXXZ	; AirframeClass::IncAirSource

; 2318 : 	}
; 2319 : 	else {

	jmp	SHORT $LN4@CBEAirSour
$LN2@CBEAirSour:

; 2320 : 	    playerAC->af->DecAirSource();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?DecAirSource@AirframeClass@@QAEXXZ	; AirframeClass::DecAirSource
$LN4@CBEAirSour:

; 2321 : 	}
; 2322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEAirSource@@YAXPAXH@Z ENDP				; CBEAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFuelExtTrans@@YAXPAXH@Z PROC			; CBExFuelExtTrans

; 2292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2293 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2294 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExFuelEx

; 2295 : 		return;

	jmp	SHORT $LN4@CBExFuelEx
$LN3@CBExFuelEx:

; 2296 : 	}
; 2297 : 
; 2298 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2299 : 	if(playerAC->af->IsEngineFlag(AirframeClass::WingFirst)) {

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN2@CBExFuelEx

; 2300 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2301 : 	}
; 2302 : 	else {

	jmp	SHORT $LN4@CBExFuelEx
$LN2@CBExFuelEx:

; 2303 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExFuelEx:

; 2304 :     }
; 2305 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFuelExtTrans@@YAXPAXH@Z ENDP			; CBExFuelExtTrans
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFuelExtTrans@@YAXPAXH@Z PROC			; CBEFuelExtTrans

; 2283 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2284 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2285 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBEFuelExt

; 2286 : 		return;

	jmp	SHORT $LN2@CBEFuelExt
$LN1@CBEFuelExt:

; 2287 : 	}
; 2288 :     playerAC->af->ToggleEngineFlag(AirframeClass::WingFirst);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag
$LN2@CBEFuelExt:

; 2289 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEFuelExtTrans@@YAXPAXH@Z ENDP			; CBEFuelExtTrans
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFuelCock@@YAXPAXH@Z PROC				; CBExFuelCock

; 2264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2265 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2266 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExFuelCo

; 2267 : 		return;

	jmp	SHORT $LN4@CBExFuelCo
$LN3@CBExFuelCo:

; 2268 : 	}
; 2269 : 
; 2270 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2271 : 	if(playerAC->af->IsEngineFlag(AirframeClass::MasterFuelOff)) {

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN2@CBExFuelCo

; 2272 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2273 : 	}
; 2274 : 	else {

	jmp	SHORT $LN4@CBExFuelCo
$LN2@CBExFuelCo:

; 2275 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExFuelCo:

; 2276 :     }
; 2277 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFuelCock@@YAXPAXH@Z ENDP				; CBExFuelCock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFuelCock@@YAXPAXH@Z PROC				; CBEFuelCock

; 2254 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2255 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2256 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBEFuelCoc

; 2257 : 		return;

	jmp	SHORT $LN2@CBEFuelCoc
$LN1@CBEFuelCoc:

; 2258 : 	}
; 2259 : 
; 2260 :     playerAC->af->ToggleEngineFlag(AirframeClass::MasterFuelOff);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ToggleEngineFlag
$LN2@CBEFuelCoc:

; 2261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEFuelCock@@YAXPAXH@Z ENDP				; CBEFuelCock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFuelPump@@YAXPAXH@Z PROC				; CBExFuelPump

; 2240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2241 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2242 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExFuelPu

; 2243 : 		return;

	jmp	SHORT $LN2@CBExFuelPu
$LN1@CBExFuelPu:

; 2244 : 	}
; 2245 : 
; 2246 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2247 : 	pCPButton->SetCurrentState((int)playerAC->af->GetFuelPump());

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExFuelPu:

; 2248 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFuelPump@@YAXPAXH@Z ENDP				; CBExFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFuelPump@@YAXPAXH@Z PROC				; CBEFuelPump

; 2225 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2226 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2227 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEFuelPum

; 2228 : 		return;

	jmp	SHORT $LN4@CBEFuelPum
$LN3@CBEFuelPum:

; 2229 : 	}
; 2230 : 
; 2231 : 	if(event == CP_MOUSE_BUTTON0) {

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEFuelPum

; 2232 : 	    playerAC->af->IncFuelPump();

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IncFuelPump@AirframeClass@@QAEXXZ	; AirframeClass::IncFuelPump

; 2233 : 	}
; 2234 : 	else {

	jmp	SHORT $LN4@CBEFuelPum
$LN2@CBEFuelPum:

; 2235 : 	    playerAC->af->DecFuelPump();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?DecFuelPump@AirframeClass@@QAEXXZ	; AirframeClass::DecFuelPump
$LN4@CBEFuelPum:

; 2236 : 	}
; 2237 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEFuelPump@@YAXPAXH@Z ENDP				; CBEFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFuelDisplay@@YAXPAXH@Z PROC			; CBExFuelDisplay

; 2212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2213 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2214 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExFuelDi

; 2215 : 		return;

	jmp	SHORT $LN2@CBExFuelDi
$LN1@CBExFuelDi:

; 2216 : 	}
; 2217 : 
; 2218 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2219 : 	pCPButton->SetCurrentState((int)playerAC->af->GetFuelSwitch());

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExFuelDi:

; 2220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFuelDisplay@@YAXPAXH@Z ENDP			; CBExFuelDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEFuelSwitch@@YAXPAXH@Z PROC				; CBEFuelSwitch

; 2197 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2198 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2199 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEFuelSwi

; 2200 : 		return;

	jmp	SHORT $LN4@CBEFuelSwi
$LN3@CBEFuelSwi:

; 2201 : 	}
; 2202 : 
; 2203 : 	if(event == CP_MOUSE_BUTTON0) {

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEFuelSwi

; 2204 : 	    playerAC->af->IncFuelSwitch();

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IncFuelSwitch@AirframeClass@@QAEXXZ	; AirframeClass::IncFuelSwitch

; 2205 : 	}
; 2206 : 	else {

	jmp	SHORT $LN4@CBEFuelSwi
$LN2@CBEFuelSwi:

; 2207 : 	    playerAC->af->DecFuelSwitch();

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?DecFuelSwitch@AirframeClass@@QAEXXZ	; AirframeClass::DecFuelSwitch
$LN4@CBEFuelSwi:

; 2208 : 	}
; 2209 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEFuelSwitch@@YAXPAXH@Z ENDP				; CBEFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDPower@@YAXPAXH@Z PROC				; CBExHUDPower

; 2178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2179 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2180 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExHUDPow

; 2181 : 		return;

	jmp	SHORT $LN4@CBExHUDPow
$LN3@CBExHUDPow:

; 2182 : 	}
; 2183 : 
; 2184 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2185 : 	if(playerAC->PowerSwitchOn(AircraftClass::HUDPower)) {

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExHUDPow

; 2186 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2187 : 	}
; 2188 : 	else {

	jmp	SHORT $LN4@CBExHUDPow
$LN2@CBExHUDPow:

; 2189 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExHUDPow:

; 2190 :     }
; 2191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDPower@@YAXPAXH@Z ENDP				; CBExHUDPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDPower@@YAXPAXH@Z PROC				; CBEHUDPower

; 2173 : {

	push	ebp
	mov	ebp, esp

; 2174 :     SimHUDPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimHUDPower@@YAXKHPAX@Z		; SimHUDPower
	add	esp, 12					; 0000000cH

; 2175 : }

	pop	ebp
	ret	0
?CBEHUDPower@@YAXPAXH@Z ENDP				; CBEHUDPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFCRPower@@YAXPAXH@Z PROC				; CBExFCRPower

; 2154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2155 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2156 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExFCRPow

; 2157 : 		return;

	jmp	SHORT $LN4@CBExFCRPow
$LN3@CBExFCRPow:

; 2158 : 	}
; 2159 : 
; 2160 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2161 : 	if(playerAC->PowerSwitchOn(AircraftClass::FCRPower)) {

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExFCRPow

; 2162 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2163 : 	}
; 2164 : 	else {

	jmp	SHORT $LN4@CBExFCRPow
$LN2@CBExFCRPow:

; 2165 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExFCRPow:

; 2166 :     }
; 2167 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFCRPower@@YAXPAXH@Z ENDP				; CBExFCRPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEFCRPower@@YAXPAXH@Z PROC				; CBEFCRPower

; 2149 : {

	push	ebp
	mov	ebp, esp

; 2150 :     SimFCRPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimFCRPower@@YAXKHPAX@Z		; SimFCRPower
	add	esp, 12					; 0000000cH

; 2151 : }

	pop	ebp
	ret	0
?CBEFCRPower@@YAXPAXH@Z ENDP				; CBEFCRPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExTISLPower@@YAXPAXH@Z PROC				; CBExTISLPower

; 2129 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2130 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2131 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExTISLPo

; 2132 : 		return;

	jmp	SHORT $LN4@CBExTISLPo
$LN3@CBExTISLPo:

; 2133 : 	}
; 2134 : 
; 2135 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2136 : 	if(playerAC->PowerSwitchOn(AircraftClass::TISLPower)) {

	push	512					; 00000200H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExTISLPo

; 2137 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2138 : 	}
; 2139 : 	else {

	jmp	SHORT $LN4@CBExTISLPo
$LN2@CBExTISLPo:

; 2140 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExTISLPo:

; 2141 : 	}
; 2142 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExTISLPower@@YAXPAXH@Z ENDP				; CBExTISLPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBETISLPower@@YAXPAXH@Z PROC				; CBETISLPower

; 2124 : {

	push	ebp
	mov	ebp, esp

; 2125 :     SimTISLPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimTISLPower@@YAXKHPAX@Z		; SimTISLPower
	add	esp, 12					; 0000000cH

; 2126 : }

	pop	ebp
	ret	0
?CBETISLPower@@YAXPAXH@Z ENDP				; CBETISLPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExRIGHTHPTPower@@YAXPAXH@Z PROC			; CBExRIGHTHPTPower

; 2104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2105 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2106 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExRIGHTH

; 2107 : 		return;

	jmp	SHORT $LN4@CBExRIGHTH
$LN3@CBExRIGHTH:

; 2108 : 	}
; 2109 : 
; 2110 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2111 : 	if (playerAC->PowerSwitchOn(AircraftClass::RightHptPower)) {

	push	256					; 00000100H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExRIGHTH

; 2112 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2113 : 	}
; 2114 : 	else {

	jmp	SHORT $LN4@CBExRIGHTH
$LN2@CBExRIGHTH:

; 2115 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExRIGHTH:

; 2116 : 	}
; 2117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExRIGHTHPTPower@@YAXPAXH@Z ENDP			; CBExRIGHTHPTPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBERIGHTHPTPower@@YAXPAXH@Z PROC			; CBERIGHTHPTPower

; 2099 : {

	push	ebp
	mov	ebp, esp

; 2100 :     SimRightHptPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRightHptPower@@YAXKHPAX@Z		; SimRightHptPower
	add	esp, 12					; 0000000cH

; 2101 : }

	pop	ebp
	ret	0
?CBERIGHTHPTPower@@YAXPAXH@Z ENDP			; CBERIGHTHPTPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExLEFTHPTPower@@YAXPAXH@Z PROC			; CBExLEFTHPTPower

; 2079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2080 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2081 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExLEFTHP

; 2082 : 		return;

	jmp	SHORT $LN4@CBExLEFTHP
$LN3@CBExLEFTHP:

; 2083 : 	}
; 2084 : 
; 2085 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2086 : 	if(playerAC->PowerSwitchOn(AircraftClass::LeftHptPower)) {

	push	128					; 00000080H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExLEFTHP

; 2087 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2088 : 	}
; 2089 : 	else {

	jmp	SHORT $LN4@CBExLEFTHP
$LN2@CBExLEFTHP:

; 2090 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExLEFTHP:

; 2091 :     }
; 2092 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExLEFTHPTPower@@YAXPAXH@Z ENDP			; CBExLEFTHPTPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBELEFTHPTPower@@YAXPAXH@Z PROC			; CBELEFTHPTPower

; 2074 : {

	push	ebp
	mov	ebp, esp

; 2075 :     SimLeftHptPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimLeftHptPower@@YAXKHPAX@Z		; SimLeftHptPower
	add	esp, 12					; 0000000cH

; 2076 : }

	pop	ebp
	ret	0
?CBELEFTHPTPower@@YAXPAXH@Z ENDP			; CBELEFTHPTPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExMAPPower@@YAXPAXH@Z PROC				; CBExMAPPower

; 2054 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2055 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2056 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExMAPPow

; 2057 : 		return;

	jmp	SHORT $LN4@CBExMAPPow
$LN3@CBExMAPPow:

; 2058 : 	}
; 2059 : 
; 2060 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2061 : 	if(playerAC->PowerSwitchOn(AircraftClass::MAPPower)) {

	push	64					; 00000040H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExMAPPow

; 2062 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2063 : 	}
; 2064 : 	else {

	jmp	SHORT $LN4@CBExMAPPow
$LN2@CBExMAPPow:

; 2065 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExMAPPow:

; 2066 :     }
; 2067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMAPPower@@YAXPAXH@Z ENDP				; CBExMAPPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEMAPPower@@YAXPAXH@Z PROC				; CBEMAPPower

; 2049 : {

	push	ebp
	mov	ebp, esp

; 2050 :     SimMAPPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimMAPPower@@YAXKHPAX@Z		; SimMAPPower
	add	esp, 12					; 0000000cH

; 2051 : }

	pop	ebp
	ret	0
?CBEMAPPower@@YAXPAXH@Z ENDP				; CBEMAPPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExDLPower@@YAXPAXH@Z PROC				; CBExDLPower

; 2028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2029 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2030 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExDLPowe

; 2031 : 		return;

	jmp	SHORT $LN4@CBExDLPowe
$LN3@CBExDLPowe:

; 2032 : 	}
; 2033 : 
; 2034 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2035 : 	if (playerAC->PowerSwitchOn(AircraftClass::DLPower)) {

	push	32					; 00000020H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExDLPowe

; 2036 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2037 : 	}
; 2038 : 	else {

	jmp	SHORT $LN4@CBExDLPowe
$LN2@CBExDLPowe:

; 2039 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExDLPowe:

; 2040 :     }
; 2041 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExDLPower@@YAXPAXH@Z ENDP				; CBExDLPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEDLPower@@YAXPAXH@Z PROC				; CBEDLPower

; 2023 : {

	push	ebp
	mov	ebp, esp

; 2024 :     SimDLPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimDLPower@@YAXKHPAX@Z			; SimDLPower
	add	esp, 12					; 0000000cH

; 2025 : }

	pop	ebp
	ret	0
?CBEDLPower@@YAXPAXH@Z ENDP				; CBEDLPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExGPSPower@@YAXPAXH@Z PROC				; CBExGPSPower

; 2002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2003 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2004 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExGPSPow

; 2005 : 		return;

	jmp	SHORT $LN4@CBExGPSPow
$LN3@CBExGPSPow:

; 2006 : 	}
; 2007 : 
; 2008 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 2009 : 	if(playerAC->PowerSwitchOn(AircraftClass::GPSPower)) {

	push	16					; 00000010H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExGPSPow

; 2010 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 2011 : 	}
; 2012 : 	else {

	jmp	SHORT $LN4@CBExGPSPow
$LN2@CBExGPSPow:

; 2013 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExGPSPow:

; 2014 :     }
; 2015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExGPSPower@@YAXPAXH@Z ENDP				; CBExGPSPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEGPSPower@@YAXPAXH@Z PROC				; CBEGPSPower

; 1997 : {

	push	ebp
	mov	ebp, esp

; 1998 :     SimGPSPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimGPSPower@@YAXKHPAX@Z		; SimGPSPower
	add	esp, 12					; 0000000cH

; 1999 : }

	pop	ebp
	ret	0
?CBEGPSPower@@YAXPAXH@Z ENDP				; CBEGPSPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExUFCPower@@YAXPAXH@Z PROC				; CBExUFCPower

; 1976 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1977 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1978 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExUFCPow

; 1979 : 		return;

	jmp	SHORT $LN4@CBExUFCPow
$LN3@CBExUFCPow:

; 1980 : 	}
; 1981 : 
; 1982 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1983 : 	if(playerAC->PowerSwitchOn(AircraftClass::UFCPower)) {

	push	8
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExUFCPow

; 1984 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1985 : 	}
; 1986 : 	else {

	jmp	SHORT $LN4@CBExUFCPow
$LN2@CBExUFCPow:

; 1987 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExUFCPow:

; 1988 :     }
; 1989 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExUFCPower@@YAXPAXH@Z ENDP				; CBExUFCPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEUFCPower@@YAXPAXH@Z PROC				; CBEUFCPower

; 1971 : {

	push	ebp
	mov	ebp, esp

; 1972 :     SimUFCPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimUFCPower@@YAXKHPAX@Z		; SimUFCPower
	add	esp, 12					; 0000000cH

; 1973 : }

	pop	ebp
	ret	0
?CBEUFCPower@@YAXPAXH@Z ENDP				; CBEUFCPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExMFDPower@@YAXPAXH@Z PROC				; CBExMFDPower

; 1950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1951 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1952 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExMFDPow

; 1953 : 		return;

	jmp	SHORT $LN4@CBExMFDPow
$LN3@CBExMFDPow:

; 1954 : 	}
; 1955 : 
; 1956 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1957 : 	if (playerAC->PowerSwitchOn(AircraftClass::MFDPower)) {

	push	4
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExMFDPow

; 1958 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1959 : 	}
; 1960 : 	else {

	jmp	SHORT $LN4@CBExMFDPow
$LN2@CBExMFDPow:

; 1961 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExMFDPow:

; 1962 :     }
; 1963 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMFDPower@@YAXPAXH@Z ENDP				; CBExMFDPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEMFDPower@@YAXPAXH@Z PROC				; CBEMFDPower

; 1945 : {

	push	ebp
	mov	ebp, esp

; 1946 :     SimMFDPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimMFDPower@@YAXKHPAX@Z		; SimMFDPower
	add	esp, 12					; 0000000cH

; 1947 : }

	pop	ebp
	ret	0
?CBEMFDPower@@YAXPAXH@Z ENDP				; CBEMFDPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExFCCPower@@YAXPAXH@Z PROC				; CBExFCCPower

; 1924 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1925 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1926 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExFCCPow

; 1927 : 		return;

	jmp	SHORT $LN4@CBExFCCPow
$LN3@CBExFCCPow:

; 1928 : 	}
; 1929 : 
; 1930 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1931 : 	if (playerAC->PowerSwitchOn(AircraftClass::FCCPower)) {

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExFCCPow

; 1932 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1933 : 	}
; 1934 : 	else {

	jmp	SHORT $LN4@CBExFCCPow
$LN2@CBExFCCPow:

; 1935 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExFCCPow:

; 1936 : 	}
; 1937 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFCCPower@@YAXPAXH@Z ENDP				; CBExFCCPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEFCCPower@@YAXPAXH@Z PROC				; CBEFCCPower

; 1919 : {

	push	ebp
	mov	ebp, esp

; 1920 :     SimFCCPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimFCCPower@@YAXKHPAX@Z		; SimFCCPower
	add	esp, 12					; 0000000cH

; 1921 : }

	pop	ebp
	ret	0
?CBEFCCPower@@YAXPAXH@Z ENDP				; CBEFCCPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExSmsPower@@YAXPAXH@Z PROC				; CBExSmsPower

; 1899 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1900 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1901 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExSmsPow

; 1902 : 		return;

	jmp	SHORT $LN4@CBExSmsPow
$LN3@CBExSmsPow:

; 1903 : 	}
; 1904 : 
; 1905 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1906 : 	if(playerAC->PowerSwitchOn(AircraftClass::SMSPower)) {

	push	1
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	je	SHORT $LN2@CBExSmsPow

; 1907 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1908 : 	}
; 1909 : 	else {

	jmp	SHORT $LN4@CBExSmsPow
$LN2@CBExSmsPow:

; 1910 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExSmsPow:

; 1911 : 	}
; 1912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExSmsPower@@YAXPAXH@Z ENDP				; CBExSmsPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBESmsPower@@YAXPAXH@Z PROC				; CBESmsPower

; 1894 : {

	push	ebp
	mov	ebp, esp

; 1895 :     SimSMSPower(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimSMSPower@@YAXKHPAX@Z		; SimSMSPower
	add	esp, 12					; 0000000cH

; 1896 : }

	pop	ebp
	ret	0
?CBESmsPower@@YAXPAXH@Z ENDP				; CBESmsPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_rs$ = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBERALTSwitch@@YAXPAXH@Z PROC				; CBERALTSwitch

; 1863 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1864 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1865 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN9@CBERALTSwi

; 1866 : 		return;

	jmp	SHORT $LN10@CBERALTSwi
$LN9@CBERALTSwi:

; 1867 : 	}
; 1868 : 
; 1869 :     AircraftClass::RaltStatus rs = playerAC->RALTStatus;

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+1004]
	mov	DWORD PTR _rs$[ebp], ecx

; 1870 :     if(event == CP_MOUSE_BUTTON0) 

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN8@CBERALTSwi

; 1871 : 	{
; 1872 : 		if (rs == AircraftClass::RaltStatus::ROFF){

	cmp	DWORD PTR _rs$[ebp], 0
	jne	SHORT $LN7@CBERALTSwi

; 1873 : 			SimRALTSTDBY(0, KEY_DOWN, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	8
	push	0
	call	?SimRALTSTDBY@@YAXKHPAX@Z		; SimRALTSTDBY
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@CBERALTSwi
$LN7@CBERALTSwi:

; 1874 : 		}
; 1875 : 		else if (rs == AircraftClass::RaltStatus::RSTANDBY){

	cmp	DWORD PTR _rs$[ebp], 1
	jne	SHORT $LN6@CBERALTSwi

; 1876 : 			SimRALTON(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRALTON@@YAXKHPAX@Z			; SimRALTON
	add	esp, 12					; 0000000cH
$LN6@CBERALTSwi:

; 1877 : 		}
; 1878 :     }
; 1879 :     else {

	jmp	SHORT $LN10@CBERALTSwi
$LN8@CBERALTSwi:

; 1880 : 		if (rs == AircraftClass::RaltStatus::RON){

	cmp	DWORD PTR _rs$[ebp], 2
	jne	SHORT $LN3@CBERALTSwi

; 1881 : 			SimRALTSTDBY(0, KEY_DOWN, pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	8
	push	0
	call	?SimRALTSTDBY@@YAXKHPAX@Z		; SimRALTSTDBY
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@CBERALTSwi
$LN3@CBERALTSwi:

; 1882 : 		}
; 1883 : 		else if (rs == AircraftClass::RaltStatus::RSTANDBY){

	cmp	DWORD PTR _rs$[ebp], 1
	jne	SHORT $LN10@CBERALTSwi

; 1884 : 			SimRALTOFF(0, KEY_DOWN, pButton);

	mov	edx, DWORD PTR _pButton$[ebp]
	push	edx
	push	8
	push	0
	call	?SimRALTOFF@@YAXKHPAX@Z			; SimRALTOFF
	add	esp, 12					; 0000000cH
$LN10@CBERALTSwi:

; 1885 : 		}
; 1886 :     }
; 1887 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBERALTSwitch@@YAXPAXH@Z ENDP				; CBERALTSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBERALTOFF@@YAXPAXH@Z PROC				; CBERALTOFF

; 1855 : {

	push	ebp
	mov	ebp, esp

; 1856 : 	SimRALTOFF(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRALTOFF@@YAXKHPAX@Z			; SimRALTOFF
	add	esp, 12					; 0000000cH

; 1857 : }

	pop	ebp
	ret	0
?CBERALTOFF@@YAXPAXH@Z ENDP				; CBERALTOFF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBERALTON@@YAXPAXH@Z PROC				; CBERALTON

; 1847 : {

	push	ebp
	mov	ebp, esp

; 1848 : 	SimRALTON(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRALTON@@YAXKHPAX@Z			; SimRALTON
	add	esp, 12					; 0000000cH

; 1849 : }

	pop	ebp
	ret	0
?CBERALTON@@YAXPAXH@Z ENDP				; CBERALTON
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBERALTSTDBY@@YAXPAXH@Z PROC				; CBERALTSTDBY

; 1839 : {

	push	ebp
	mov	ebp, esp

; 1840 : 	SimRALTSTDBY(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimRALTSTDBY@@YAXKHPAX@Z		; SimRALTSTDBY
	add	esp, 12					; 0000000cH

; 1841 : }

	pop	ebp
	ret	0
?CBERALTSTDBY@@YAXPAXH@Z ENDP				; CBERALTSTDBY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv68 = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExRALTSwitch@@YAXPAXH@Z PROC				; CBExRALTSwitch

; 1810 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1811 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1812 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN7@CBExRALTSw

; 1813 : 		return;

	jmp	SHORT $LN8@CBExRALTSw
$LN7@CBExRALTSw:

; 1814 : 	}
; 1815 : 
; 1816 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1817 : 	//MI reported CTD check
; 1818 : 	switch (playerAC->RALTStatus) 

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+1004]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN4@CBExRALTSw
	cmp	DWORD PTR tv68[ebp], 1
	je	SHORT $LN3@CBExRALTSw
	cmp	DWORD PTR tv68[ebp], 2
	je	SHORT $LN2@CBExRALTSw
	jmp	SHORT $LN8@CBExRALTSw
$LN4@CBExRALTSw:

; 1819 : 	{
; 1820 : 		case AircraftClass::RaltStatus::ROFF:
; 1821 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1822 : 		break;

	jmp	SHORT $LN8@CBExRALTSw
$LN3@CBExRALTSw:

; 1823 : 		case AircraftClass::RaltStatus::RSTANDBY:
; 1824 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1825 : 		break;

	jmp	SHORT $LN8@CBExRALTSw
$LN2@CBExRALTSw:

; 1826 : 		case AircraftClass::RaltStatus::RON:
; 1827 : 			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN8@CBExRALTSw:

; 1828 : 		break;
; 1829 : 		default:
; 1830 : 			ShiWarning("Inconsistant ralt state");
; 1831 : 		break;
; 1832 : 	}
; 1833 : }	

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExRALTSwitch@@YAXPAXH@Z ENDP				; CBExRALTSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPCLEAR@@YAXPAXH@Z PROC				; CBEICPCLEAR

; 1802 : {

	push	ebp
	mov	ebp, esp

; 1803 : 	SimICPCLEAR(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPCLEAR@@YAXKHPAX@Z		; SimICPCLEAR
	add	esp, 12					; 0000000cH

; 1804 : }

	pop	ebp
	ret	0
?CBEICPCLEAR@@YAXPAXH@Z ENDP				; CBEICPCLEAR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPDEDSEQ@@YAXPAXH@Z PROC				; CBEICPDEDSEQ

; 1795 : {

	push	ebp
	mov	ebp, esp

; 1796 : 	SimICPDEDSEQ(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPDEDSEQ@@YAXKHPAX@Z		; SimICPDEDSEQ
	add	esp, 12					; 0000000cH

; 1797 : }

	pop	ebp
	ret	0
?CBEICPDEDSEQ@@YAXPAXH@Z ENDP				; CBEICPDEDSEQ
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPDEDDOWN@@YAXPAXH@Z PROC				; CBEICPDEDDOWN

; 1788 : {

	push	ebp
	mov	ebp, esp

; 1789 : 	SimICPDEDDOWN(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPDEDDOWN@@YAXKHPAX@Z		; SimICPDEDDOWN
	add	esp, 12					; 0000000cH

; 1790 : }

	pop	ebp
	ret	0
?CBEICPDEDDOWN@@YAXPAXH@Z ENDP				; CBEICPDEDDOWN
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPDEDUP@@YAXPAXH@Z PROC				; CBEICPDEDUP

; 1781 : {

	push	ebp
	mov	ebp, esp

; 1782 : 	SimICPDEDUP(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPDEDUP@@YAXKHPAX@Z		; SimICPDEDUP
	add	esp, 12					; 0000000cH

; 1783 : }

	pop	ebp
	ret	0
?CBEICPDEDUP@@YAXPAXH@Z ENDP				; CBEICPDEDUP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEResetDEDPage@@YAXPAXH@Z PROC			; CBEResetDEDPage

; 1774 : {

	push	ebp
	mov	ebp, esp

; 1775 : 	SimICPResetDED(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPResetDED@@YAXKHPAX@Z		; SimICPResetDED
	add	esp, 12					; 0000000cH

; 1776 : }

	pop	ebp
	ret	0
?CBEResetDEDPage@@YAXPAXH@Z ENDP			; CBEResetDEDPage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEZEROButton@@YAXPAXH@Z PROC				; CBEZEROButton

; 1767 : {

	push	ebp
	mov	ebp, esp

; 1768 : 	SimICPZERO(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPZERO@@YAXKHPAX@Z			; SimICPZERO
	add	esp, 12					; 0000000cH

; 1769 : }

	pop	ebp
	ret	0
?CBEZEROButton@@YAXPAXH@Z ENDP				; CBEZEROButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBENINEButton@@YAXPAXH@Z PROC				; CBENINEButton

; 1760 : {

	push	ebp
	mov	ebp, esp

; 1761 : 	SimICPNINE(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPNINE@@YAXKHPAX@Z			; SimICPNINE
	add	esp, 12					; 0000000cH

; 1762 : }

	pop	ebp
	ret	0
?CBENINEButton@@YAXPAXH@Z ENDP				; CBENINEButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEEIGHTButton@@YAXPAXH@Z PROC				; CBEEIGHTButton

; 1753 : {

	push	ebp
	mov	ebp, esp

; 1754 : 	SimICPEIGHT(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPEIGHT@@YAXKHPAX@Z		; SimICPEIGHT
	add	esp, 12					; 0000000cH

; 1755 : }

	pop	ebp
	ret	0
?CBEEIGHTButton@@YAXPAXH@Z ENDP				; CBEEIGHTButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBESIXButton@@YAXPAXH@Z PROC				; CBESIXButton

; 1746 : {

	push	ebp
	mov	ebp, esp

; 1747 : 	SimICPSIX(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPSIX@@YAXKHPAX@Z			; SimICPSIX
	add	esp, 12					; 0000000cH

; 1748 : }

	pop	ebp
	ret	0
?CBESIXButton@@YAXPAXH@Z ENDP				; CBESIXButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBETHREEButton@@YAXPAXH@Z PROC				; CBETHREEButton

; 1739 : {

	push	ebp
	mov	ebp, esp

; 1740 : 	SimICPTHREE(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPTHREE@@YAXKHPAX@Z		; SimICPTHREE
	add	esp, 12					; 0000000cH

; 1741 : }

	pop	ebp
	ret	0
?CBETHREEButton@@YAXPAXH@Z ENDP				; CBETHREEButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPLIST@@YAXPAXH@Z PROC				; CBEICPLIST

; 1731 : {

	push	ebp
	mov	ebp, esp

; 1732 : 	SimICPLIST(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPLIST@@YAXKHPAX@Z			; SimICPLIST
	add	esp, 12					; 0000000cH

; 1733 : }

	pop	ebp
	ret	0
?CBEICPLIST@@YAXPAXH@Z ENDP				; CBEICPLIST
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPIFF@@YAXPAXH@Z PROC				; CBEICPIFF

; 1723 : {

	push	ebp
	mov	ebp, esp

; 1724 : 	SimICPIFF(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPIFF@@YAXKHPAX@Z			; SimICPIFF
	add	esp, 12					; 0000000cH

; 1725 : }

	pop	ebp
	ret	0
?CBEICPIFF@@YAXPAXH@Z ENDP				; CBEICPIFF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -12					; size = 4
tv72 = -8						; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAltLGear@@YAXPAXH@Z PROC				; CBExAltLGear

; 1709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1710 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1711 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExAltLGe

; 1712 : 		return;

	jmp	SHORT $LN2@CBExAltLGe
$LN1@CBExAltLGe:

; 1713 : 	}
; 1714 :     CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1715 : 	pCPButton->SetCurrentState(playerAC->af->altGearDeployed ? 1 : 0);

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movzx	eax, BYTE PTR [edx+1572]
	test	eax, eax
	je	SHORT $LN4@CBExAltLGe
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN5@CBExAltLGe
$LN4@CBExAltLGe:
	mov	DWORD PTR tv72[ebp], 0
$LN5@CBExAltLGe:
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExAltLGe:

; 1716 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAltLGear@@YAXPAXH@Z ENDP				; CBExAltLGear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAltLGearReset@@YAXPAXH@Z PROC			; CBEAltLGearReset

; 1704 : void CBEAltLGearReset(void *, int) {

	push	ebp
	mov	ebp, esp

; 1705 :     AFAlternateGearReset(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFAlternateGearReset@@YAXKHPAX@Z	; AFAlternateGearReset
	add	esp, 12					; 0000000cH

; 1706 : }

	pop	ebp
	ret	0
?CBEAltLGearReset@@YAXPAXH@Z ENDP			; CBEAltLGearReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAltLGear@@YAXPAXH@Z PROC				; CBEAltLGear

; 1700 : void CBEAltLGear(void *, int) {

	push	ebp
	mov	ebp, esp

; 1701 :     AFAlternateGear(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFAlternateGear@@YAXKHPAX@Z		; AFAlternateGear
	add	esp, 12					; 0000000cH

; 1702 : }

	pop	ebp
	ret	0
?CBEAltLGear@@YAXPAXH@Z ENDP				; CBEAltLGear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
_pCPButton$ = -8					; size = 4
tv70 = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExEpu@@YAXPAXH@Z PROC				; CBExEpu

; 1679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1680 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1681 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN6@CBExEpu

; 1682 : 		return;

	jmp	SHORT $LN7@CBExEpu
$LN6@CBExEpu:

; 1683 : 	}
; 1684 : 
; 1685 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1686 :     
; 1687 : 	switch (playerAC->af->GetEpuSwitch()) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN3@CBExEpu
	cmp	DWORD PTR tv70[ebp], 1
	je	SHORT $LN2@CBExEpu
	cmp	DWORD PTR tv70[ebp], 2
	je	SHORT $LN1@CBExEpu
	jmp	SHORT $LN7@CBExEpu
$LN3@CBExEpu:

; 1688 : 		case AirframeClass::EpuState::OFF:
; 1689 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1690 : 		break;

	jmp	SHORT $LN7@CBExEpu
$LN2@CBExEpu:

; 1691 : 		case AirframeClass::EpuState::AUTO:
; 1692 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1693 : 		break;

	jmp	SHORT $LN7@CBExEpu
$LN1@CBExEpu:

; 1694 : 		case AirframeClass::EpuState::ON:
; 1695 :    			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExEpu:

; 1696 : 		break;
; 1697 : 	}
; 1698 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEpu@@YAXPAXH@Z ENDP				; CBExEpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEEpu@@YAXPAXH@Z PROC					; CBEEpu

; 1674 : void CBEEpu(void *, int) {

	push	ebp
	mov	ebp, esp

; 1675 :     SimEpuToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEpuToggle@@YAXKHPAX@Z		; SimEpuToggle
	add	esp, 12					; 0000000cH

; 1676 : }

	pop	ebp
	ret	0
?CBEEpu@@YAXPAXH@Z ENDP					; CBEEpu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExJfs@@YAXPAXH@Z PROC				; CBExJfs

; 1658 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1659 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1660 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExJfs

; 1661 : 		return;

	jmp	SHORT $LN4@CBExJfs
$LN3@CBExJfs:

; 1662 : 	}
; 1663 : 
; 1664 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1665 :     
; 1666 : 	if (playerAC->af->IsSet(AirframeClass::JfsStart)) {

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@CBExJfs

; 1667 : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1668 : 	}
; 1669 : 	else {

	jmp	SHORT $LN4@CBExJfs
$LN2@CBExJfs:

; 1670 : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExJfs:

; 1671 : 	}
; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExJfs@@YAXPAXH@Z ENDP				; CBExJfs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEJfs@@YAXPAXH@Z PROC					; CBEJfs

; 1653 : void CBEJfs(void *, int) {

	push	ebp
	mov	ebp, esp

; 1654 :     SimJfsStart(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimJfsStart@@YAXKHPAX@Z		; SimJfsStart
	add	esp, 12					; 0000000cH

; 1655 : }

	pop	ebp
	ret	0
?CBEJfs@@YAXPAXH@Z ENDP					; CBEJfs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -12					; size = 4
tv75 = -8						; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExCatIII@@YAXPAXH@Z PROC				; CBExCatIII

; 1642 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1643 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1644 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1645 : 	if ((playerAC == NULL) || (playerAC->af == NULL)){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN1@CBExCatIII
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	jne	SHORT $LN2@CBExCatIII
$LN1@CBExCatIII:

; 1646 : 		return;

	jmp	SHORT $LN3@CBExCatIII
$LN2@CBExCatIII:

; 1647 : 	}
; 1648 : 	pCPButton->SetCurrentState(playerAC->af->IsSet(AirframeClass::CATLimiterIII) ? 1 : 0);

	push	2097152					; 00200000H
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN5@CBExCatIII
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN6@CBExCatIII
$LN5@CBExCatIII:
	mov	DWORD PTR tv75[ebp], 0
$LN6@CBExCatIII:
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN3@CBExCatIII:

; 1649 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExCatIII@@YAXPAXH@Z ENDP				; CBExCatIII
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -12					; size = 4
tv85 = -8						; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExMasterArm@@YAXPAXH@Z PROC				; CBExMasterArm

; 1612 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1613 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1614 : 	if (playerAC == NULL) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN7@CBExMaster

; 1615 : 		return;

	jmp	$LN8@CBExMaster
$LN7@CBExMaster:

; 1616 : 	}
; 1617 : 
; 1618 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1619 : 
; 1620 : 	// sfr: TODO this MUST go away!!!!
; 1621 : 	if (
; 1622 : 		!F4IsBadReadPtr(playerAC, sizeof(AircraftClass*)) && 
; 1623 : 		!F4IsBadReadPtr(playerAC->Sms, sizeof(SMSClass))
; 1624 : 	){ // JB 010326 CTD

	push	4
	mov	ecx, DWORD PTR _playerAC$[ebp]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@CBExMaster
	push	280					; 00000118H
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@CBExMaster

; 1625 : 		switch (playerAC->Sms->MasterArm())

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	mov	DWORD PTR tv85[ebp], eax
	cmp	DWORD PTR tv85[ebp], 0
	je	SHORT $LN3@CBExMaster
	cmp	DWORD PTR tv85[ebp], 1
	je	SHORT $LN2@CBExMaster
	cmp	DWORD PTR tv85[ebp], 2
	je	SHORT $LN1@CBExMaster
	jmp	SHORT $LN8@CBExMaster
$LN3@CBExMaster:

; 1626 : 		{
; 1627 : 			case SMSBaseClass::Safe:
; 1628 :    			pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1629 : 			break;

	jmp	SHORT $LN8@CBExMaster
$LN2@CBExMaster:

; 1630 : 			case SMSBaseClass::Sim:
; 1631 :    			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1632 : 			break;

	jmp	SHORT $LN8@CBExMaster
$LN1@CBExMaster:

; 1633 : 			case SMSBaseClass::Arm:
; 1634 :    			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN8@CBExMaster:

; 1635 : 			break;
; 1636 : 		}
; 1637 : 	}
; 1638 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMasterArm@@YAXPAXH@Z ENDP				; CBExMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEHUDColor@@YAXPAXH@Z PROC				; CBEHUDColor

; 1603 : void CBEHUDColor(void *, int event) {

	push	ebp
	mov	ebp, esp

; 1604 : //	OTWStepHudColor (0, KEY_DOWN, NULL);
; 1605 : 	if(event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEHUDColo

; 1606 : 		OTWStepHudContrastUp(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?OTWStepHudContrastUp@@YAXKHPAX@Z	; OTWStepHudContrastUp
	add	esp, 12					; 0000000cH

; 1607 : 	else

	jmp	SHORT $LN3@CBEHUDColo
$LN2@CBEHUDColo:

; 1608 : 		OTWStepHudContrastDn(0, KEY_DOWN, NULL);	

	push	0
	push	8
	push	0
	call	?OTWStepHudContrastDn@@YAXKHPAX@Z	; OTWStepHudContrastDn
	add	esp, 12					; 0000000cH
$LN3@CBEHUDColo:

; 1609 : }

	pop	ebp
	ret	0
?CBEHUDColor@@YAXPAXH@Z ENDP				; CBEHUDColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBELeftGainUp@@YAXPAXH@Z PROC				; CBELeftGainUp

; 1599 : void CBELeftGainUp(void *, int) {

	push	ebp
	mov	ebp, esp

; 1600 : 	SimCBEOSB_GAINUP_L (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINUP_L@@YAXKHPAX@Z		; SimCBEOSB_GAINUP_L
	add	esp, 12					; 0000000cH

; 1601 : }

	pop	ebp
	ret	0
?CBELeftGainUp@@YAXPAXH@Z ENDP				; CBELeftGainUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBELeftGainDown@@YAXPAXH@Z PROC			; CBELeftGainDown

; 1595 : void CBELeftGainDown(void *, int) {

	push	ebp
	mov	ebp, esp

; 1596 : 	SimCBEOSB_GAINDOWN_L (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINDOWN_L@@YAXKHPAX@Z	; SimCBEOSB_GAINDOWN_L
	add	esp, 12					; 0000000cH

; 1597 : }

	pop	ebp
	ret	0
?CBELeftGainDown@@YAXPAXH@Z ENDP			; CBELeftGainDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBERightGainDown@@YAXPAXH@Z PROC			; CBERightGainDown

; 1591 : void CBERightGainDown(void *, int) {

	push	ebp
	mov	ebp, esp

; 1592 : 	SimCBEOSB_GAINDOWN_R (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINDOWN_R@@YAXKHPAX@Z	; SimCBEOSB_GAINDOWN_R
	add	esp, 12					; 0000000cH

; 1593 : }

	pop	ebp
	ret	0
?CBERightGainDown@@YAXPAXH@Z ENDP			; CBERightGainDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBERightGainUp@@YAXPAXH@Z PROC				; CBERightGainUp

; 1587 : void CBERightGainUp(void *, int) {

	push	ebp
	mov	ebp, esp

; 1588 : 	SimCBEOSB_GAINUP_R (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINUP_R@@YAXKHPAX@Z		; SimCBEOSB_GAINUP_R
	add	esp, 12					; 0000000cH

; 1589 : }

	pop	ebp
	ret	0
?CBERightGainUp@@YAXPAXH@Z ENDP				; CBERightGainUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBECatIII@@YAXPAXH@Z PROC				; CBECatIII

; 1581 : void CBECatIII(void *, int) {

	push	ebp
	mov	ebp, esp

; 1582 : //   OTWTimeOfDayStep (0, KEY_DOWN, NULL);
; 1583 : // 2000-11-23 S.G. NOW USING ITS OWN ENTRY
; 1584 : 	SimCATSwitch(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCATSwitch@@YAXKHPAX@Z		; SimCATSwitch
	add	esp, 12					; 0000000cH

; 1585 : }

	pop	ebp
	ret	0
?CBECatIII@@YAXPAXH@Z ENDP				; CBECatIII
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv131 = -12						; size = 4
tv75 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEMasterArm@@YAXPAXH@Z PROC				; CBEMasterArm

; 1552 : void CBEMasterArm(void *, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1553 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1554 : 	if (playerAC == NULL) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN11@CBEMasterA

; 1555 : 		return;

	jmp	$LN12@CBEMasterA
$LN11@CBEMasterA:

; 1556 : 	}
; 1557 : 
; 1558 :     if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN10@CBEMasterA

; 1559 : 		switch (playerAC->Sms->MasterArm()) {

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	mov	DWORD PTR tv75[ebp], eax
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN6@CBEMasterA
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN7@CBEMasterA
	jmp	SHORT $LN8@CBEMasterA
$LN7@CBEMasterA:

; 1560 : 			case SMSBaseClass::Sim:
; 1561 : 				playerAC->Sms->SetMasterArm(SMSBaseClass::Safe);

	push	0
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 1562 : 			break;

	jmp	SHORT $LN8@CBEMasterA
$LN6@CBEMasterA:

; 1563 : 			case SMSBaseClass::Safe:
; 1564 : 				playerAC->Sms->SetMasterArm(SMSBaseClass::Arm);

	push	2
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
$LN8@CBEMasterA:

; 1565 : 			break;
; 1566 : 		}
; 1567 :     }
; 1568 : 	else {

	jmp	SHORT $LN12@CBEMasterA
$LN10@CBEMasterA:

; 1569 : 		switch (playerAC->Sms->MasterArm()) {

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	mov	DWORD PTR tv131[ebp], eax
	cmp	DWORD PTR tv131[ebp], 0
	je	SHORT $LN1@CBEMasterA
	cmp	DWORD PTR tv131[ebp], 2
	je	SHORT $LN2@CBEMasterA
	jmp	SHORT $LN12@CBEMasterA
$LN2@CBEMasterA:

; 1570 : 			case SMSBaseClass::Arm:
; 1571 : 				playerAC->Sms->SetMasterArm(SMSBaseClass::Safe);

	push	0
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 1572 : 			break;

	jmp	SHORT $LN12@CBEMasterA
$LN1@CBEMasterA:

; 1573 : 			case SMSBaseClass::Safe:
; 1574 : 				playerAC->Sms->SetMasterArm(SMSBaseClass::Sim);

	push	1
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
$LN12@CBEMasterA:

; 1575 : 			break;
; 1576 : 		}
; 1577 :     }
; 1578 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEMasterArm@@YAXPAXH@Z ENDP				; CBEMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEExteriorLite@@YAXPAXH@Z PROC			; CBEExteriorLite

; 1548 : void CBEExteriorLite(void *, int) {

	push	ebp
	mov	ebp, esp

; 1549 : 	SimToggleExtLights(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleExtLights@@YAXKHPAX@Z		; SimToggleExtLights
	add	esp, 12					; 0000000cH

; 1550 : }

	pop	ebp
	ret	0
?CBEExteriorLite@@YAXPAXH@Z ENDP			; CBEExteriorLite
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExExteriorLite@@YAXPAXH@Z PROC			; CBExExteriorLite

; 1531 : void CBExExteriorLite(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1532 : 
; 1533 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1534 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1535 : 
; 1536 : 	if (playerAC == NULL) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExExteri

; 1537 : 		return;

	jmp	SHORT $LN4@CBExExteri
$LN3@CBExExteri:

; 1538 : 	}
; 1539 : 
; 1540 : 	if (playerAC->af->IsSet(AirframeClass::HasComplexGear) && playerAC->GetSwitch(COMP_NAV_LIGHTS)) {

	push	16777216				; 01000000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@CBExExteri
	push	8
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	test	eax, eax
	je	SHORT $LN2@CBExExteri

; 1541 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1542 : 	}
; 1543 : 	else {

	jmp	SHORT $LN4@CBExExteri
$LN2@CBExExteri:

; 1544 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExExteri:

; 1545 : 	}
; 1546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExExteriorLite@@YAXPAXH@Z ENDP			; CBExExteriorLite
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEUHFMaster@@YAXPAXH@Z PROC				; CBEUHFMaster

; 1522 : void CBEUHFMaster(void *, int) {

	push	ebp
	mov	ebp, esp

; 1523 : 	SimToggleUHFMaster(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleUHFMaster@@YAXKHPAX@Z		; SimToggleUHFMaster
	add	esp, 12					; 0000000cH

; 1524 : }

	pop	ebp
	ret	0
?CBEUHFMaster@@YAXPAXH@Z ENDP				; CBEUHFMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExUHFMaster@@YAXPAXH@Z PROC				; CBExUHFMaster

; 1506 : void CBExUHFMaster(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 1507 : 
; 1508 : #if 0
; 1509 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;
; 1510 : 
; 1511 : 	if (playerAC) {
; 1512 : 		if(gNavigationSys->GetUHFSrc() == NavigationSystem::UHF_NORM) {
; 1513 : 			pCPButton->SetCurrentState(0);
; 1514 : 		}
; 1515 : 		else {
; 1516 : 			pCPButton->SetCurrentState(1);
; 1517 : 		}
; 1518 : 	}
; 1519 : #endif
; 1520 : }

	pop	ebp
	ret	0
?CBExUHFMaster@@YAXPAXH@Z ENDP				; CBExUHFMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAuxCommAATR@@YAXPAXH@Z PROC				; CBEAuxCommAATR

; 1493 : void CBEAuxCommAATR(void *, int) {

	push	ebp
	mov	ebp, esp

; 1494 : 	SimToggleAuxComAATR(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleAuxComAATR@@YAXKHPAX@Z	; SimToggleAuxComAATR
	add	esp, 12					; 0000000cH

; 1495 : }

	pop	ebp
	ret	0
?CBEAuxCommAATR@@YAXPAXH@Z ENDP				; CBEAuxCommAATR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAuxCommAATR@@YAXPAXH@Z PROC			; CBExAuxCommAATR

; 1477 : void CBExAuxCommAATR(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1478 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1479 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExAuxCom

; 1480 : 		return;

	jmp	SHORT $LN4@CBExAuxCom
$LN3@CBExAuxCom:

; 1481 : 	}
; 1482 : 	
; 1483 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1484 : 
; 1485 : 	if(gNavigationSys->GetDomain(NavigationSystem::AUXCOMM) == TacanList::AA) {

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::GetDomain
	test	eax, eax
	jne	SHORT $LN2@CBExAuxCom

; 1486 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1487 : 	}
; 1488 : 	else {

	jmp	SHORT $LN4@CBExAuxCom
$LN2@CBExAuxCom:

; 1489 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExAuxCom:

; 1490 : 	}
; 1491 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAuxCommAATR@@YAXPAXH@Z ENDP			; CBExAuxCommAATR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAuxCommMaster@@YAXPAXH@Z PROC			; CBEAuxCommMaster

; 1469 : void CBEAuxCommMaster(void *, int) {

	push	ebp
	mov	ebp, esp

; 1470 : 	SimToggleAuxComMaster(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleAuxComMaster@@YAXKHPAX@Z	; SimToggleAuxComMaster
	add	esp, 12					; 0000000cH

; 1471 : }

	pop	ebp
	ret	0
?CBEAuxCommMaster@@YAXPAXH@Z ENDP			; CBEAuxCommMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -12					; size = 4
_playerAC$ = -8						; size = 4
_state$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAuxCommMaster@@YAXPAXH@Z PROC			; CBExAuxCommMaster

; 1454 : void CBExAuxCommMaster(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1455 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1456 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN2@CBExAuxCom

; 1457 : 		return;

	jmp	SHORT $LN3@CBExAuxCom
$LN2@CBExAuxCom:

; 1458 : 	}
; 1459 : 
; 1460 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1461 : 	int	state = 0;

	mov	DWORD PTR _state$[ebp], 0

; 1462 : 
; 1463 : 	if(gNavigationSys->GetControlSrc() == NavigationSystem::AUXCOMM) {

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ ; NavigationSystem::GetControlSrc
	cmp	eax, 1
	jne	SHORT $LN1@CBExAuxCom

; 1464 : 		state = 1;

	mov	DWORD PTR _state$[ebp], 1
$LN1@CBExAuxCom:

; 1465 : 	}
; 1466 : 	pCPButton->SetCurrentState(state);

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN3@CBExAuxCom:

; 1467 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAuxCommMaster@@YAXPAXH@Z ENDP			; CBExAuxCommMaster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEEject@@YAXPAXH@Z PROC				; CBEEject

; 1431 : void CBEEject(void *pButton, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1432 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1433 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN4@CBEEject

; 1434 : 		return;

	jmp	SHORT $LN5@CBEEject
$LN4@CBEEject:

; 1435 : 	}
; 1436 : 
; 1437 : 	//MI
; 1438 : 	if(g_bRealisticAvionics){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN3@CBEEject

; 1439 : 		if (playerAC->SeatArmed){

	mov	ecx, DWORD PTR _playerAC$[ebp]
	movzx	edx, BYTE PTR [ecx+1052]
	test	edx, edx
	je	SHORT $LN2@CBEEject

; 1440 : 			OTWDriver.pCockpitManager->mMiscStates.SetEjectButtonState(TRUE);

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetEjectButtonState@CPMisc@@QAEXH@Z	; CPMisc::SetEjectButtonState

; 1441 : 			SimEject(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimEject@@YAXKHPAX@Z			; SimEject
	add	esp, 12					; 0000000cH
$LN2@CBEEject:

; 1442 : 		}
; 1443 : 	}
; 1444 : 	else {

	jmp	SHORT $LN5@CBEEject
$LN3@CBEEject:

; 1445 : 		OTWDriver.pCockpitManager->mMiscStates.SetEjectButtonState(TRUE);

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?SetEjectButtonState@CPMisc@@QAEXH@Z	; CPMisc::SetEjectButtonState

; 1446 : 		SimEject(0, KEY_DOWN, pButton);

	mov	ecx, DWORD PTR _pButton$[ebp]
	push	ecx
	push	8
	push	0
	call	?SimEject@@YAXKHPAX@Z			; SimEject
	add	esp, 12					; 0000000cH
$LN5@CBEEject:

; 1447 : 	}
; 1448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEEject@@YAXPAXH@Z ENDP				; CBEEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExEject@@YAXPAXH@Z PROC				; CBExEject

; 1425 : void CBExEject(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1426 : 
; 1427 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1428 : 	pCPButton->SetCurrentState(OTWDriver.pCockpitManager->mMiscStates.GetEjectButtonState());

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?GetEjectButtonState@CPMisc@@QAEHXZ	; CPMisc::GetEjectButtonState
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1429 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExEject@@YAXPAXH@Z ENDP				; CBExEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAuxCommBand@@YAXPAXH@Z PROC				; CBEAuxCommBand

; 1417 : void CBEAuxCommBand(void *, int) {

	push	ebp
	mov	ebp, esp

; 1418 : 
; 1419 : 	SimCycleBandAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCycleBandAuxComDigit@@YAXKHPAX@Z	; SimCycleBandAuxComDigit
	add	esp, 12					; 0000000cH

; 1420 : }

	pop	ebp
	ret	0
?CBEAuxCommBand@@YAXPAXH@Z ENDP				; CBEAuxCommBand
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAuxCommBand@@YAXPAXH@Z PROC			; CBExAuxCommBand

; 1403 : void CBExAuxCommBand(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1404 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1405 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExAuxCom

; 1406 : 		return;

	jmp	SHORT $LN4@CBExAuxCom
$LN3@CBExAuxCom:

; 1407 : 	}
; 1408 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1409 : 	if(gNavigationSys->GetTacanBand(NavigationSystem::AUXCOMM) == TacanList::X) {

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanBand@NavigationSystem@@QAE?AW4StationSet@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::GetTacanBand
	test	eax, eax
	jne	SHORT $LN2@CBExAuxCom

; 1410 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1411 : 	}
; 1412 : 	else {

	jmp	SHORT $LN4@CBExAuxCom
$LN2@CBExAuxCom:

; 1413 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExAuxCom:

; 1414 : 	}
; 1415 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAuxCommBand@@YAXPAXH@Z ENDP			; CBExAuxCommBand
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAuxCommRight@@YAXPAXH@Z PROC			; CBEAuxCommRight

; 1393 : void CBEAuxCommRight(void *, int event) {

	push	ebp
	mov	ebp, esp

; 1394 : 	if(event == CP_MOUSE_BUTTON0){ 

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBEAuxComm

; 1395 : 		// allow right key decrement
; 1396 : 		SimCycleRightAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCycleRightAuxComDigit@@YAXKHPAX@Z	; SimCycleRightAuxComDigit
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@CBEAuxComm
$LN3@CBEAuxComm:

; 1397 : 	}
; 1398 : 	else if (event == CP_MOUSE_BUTTON1){

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN4@CBEAuxComm

; 1399 : 		SimDecRightAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDecRightAuxComDigit@@YAXKHPAX@Z	; SimDecRightAuxComDigit
	add	esp, 12					; 0000000cH
$LN4@CBEAuxComm:

; 1400 : 	}
; 1401 : }

	pop	ebp
	ret	0
?CBEAuxCommRight@@YAXPAXH@Z ENDP			; CBEAuxCommRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAuxCommRight@@YAXPAXH@Z PROC			; CBExAuxCommRight

; 1384 : void CBExAuxCommRight(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1385 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1386 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExAuxCom

; 1387 : 		return;

	jmp	SHORT $LN2@CBExAuxCom
$LN1@CBExAuxCom:

; 1388 : 	}
; 1389 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1390 : 	pCPButton->SetCurrentState(gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 0));

	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExAuxCom:

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAuxCommRight@@YAXPAXH@Z ENDP			; CBExAuxCommRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAuxCommCenter@@YAXPAXH@Z PROC			; CBEAuxCommCenter

; 1374 : void CBEAuxCommCenter(void *, int event) {

	push	ebp
	mov	ebp, esp

; 1375 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBEAuxComm

; 1376 : 		// allow right key decrement
; 1377 : 	    SimCycleCenterAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCycleCenterAuxComDigit@@YAXKHPAX@Z	; SimCycleCenterAuxComDigit
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@CBEAuxComm
$LN3@CBEAuxComm:

; 1378 : 	}
; 1379 : 	else if(event == CP_MOUSE_BUTTON1){

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN4@CBEAuxComm

; 1380 : 	    SimDecCenterAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDecCenterAuxComDigit@@YAXKHPAX@Z	; SimDecCenterAuxComDigit
	add	esp, 12					; 0000000cH
$LN4@CBEAuxComm:

; 1381 : 	}
; 1382 : }

	pop	ebp
	ret	0
?CBEAuxCommCenter@@YAXPAXH@Z ENDP			; CBEAuxCommCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAuxCommCenter@@YAXPAXH@Z PROC			; CBExAuxCommCenter

; 1365 : void CBExAuxCommCenter(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1366 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1367 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExAuxCom

; 1368 : 		return;

	jmp	SHORT $LN2@CBExAuxCom
$LN1@CBExAuxCom:

; 1369 : 	}
; 1370 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1371 : 	pCPButton->SetCurrentState(gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 1));

	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExAuxCom:

; 1372 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAuxCommCenter@@YAXPAXH@Z ENDP			; CBExAuxCommCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEAuxCommLeft@@YAXPAXH@Z PROC				; CBEAuxCommLeft

; 1355 : void CBEAuxCommLeft(void *, int event) {

	push	ebp
	mov	ebp, esp

; 1356 : 	if(event == CP_MOUSE_BUTTON0){

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBEAuxComm

; 1357 : 		// JPO allow right key decrement
; 1358 : 		SimCycleLeftAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCycleLeftAuxComDigit@@YAXKHPAX@Z	; SimCycleLeftAuxComDigit
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@CBEAuxComm
$LN3@CBEAuxComm:

; 1359 : 	}
; 1360 : 	else if(event == CP_MOUSE_BUTTON1){

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN4@CBEAuxComm

; 1361 : 		SimDecLeftAuxComDigit(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDecLeftAuxComDigit@@YAXKHPAX@Z	; SimDecLeftAuxComDigit
	add	esp, 12					; 0000000cH
$LN4@CBEAuxComm:

; 1362 : 	}
; 1363 : }

	pop	ebp
	ret	0
?CBEAuxCommLeft@@YAXPAXH@Z ENDP				; CBEAuxCommLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAuxCommLeft@@YAXPAXH@Z PROC			; CBExAuxCommLeft

; 1345 : void CBExAuxCommLeft(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1346 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1347 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN1@CBExAuxCom

; 1348 : 		return;

	jmp	SHORT $LN2@CBExAuxCom
$LN1@CBExAuxCom:

; 1349 : 	}
; 1350 : 	
; 1351 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1352 : 	pCPButton->SetCurrentState(gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 2));

	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExAuxCom:

; 1353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAuxCommLeft@@YAXPAXH@Z ENDP			; CBExAuxCommLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEUHFSwitch@@YAXPAXH@Z PROC				; CBEUHFSwitch

; 1331 : void CBEUHFSwitch(void *, int) {

	push	ebp
	mov	ebp, esp

; 1332 : 
; 1333 : 	if(gNavigationSys->GetUHFSrc() == NavigationSystem::UHF_BACKUP) {

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetUHFSrc@NavigationSystem@@QAE?AW4UHF_Mode_Type@1@XZ ; NavigationSystem::GetUHFSrc
	cmp	eax, 1
	jne	SHORT $LN2@CBEUHFSwit

; 1334 : 		SimCycleRadioChannel(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCycleRadioChannel@@YAXKHPAX@Z	; SimCycleRadioChannel
	add	esp, 12					; 0000000cH

; 1335 : 	}
; 1336 : 	else {

	jmp	SHORT $LN3@CBEUHFSwit
$LN2@CBEUHFSwit:

; 1337 : 		OTWDriver.pCockpitManager->mMiscStates.StepUHFPostion();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	add	ecx, 284				; 0000011cH
	call	?StepUHFPostion@CPMisc@@QAEXXZ		; CPMisc::StepUHFPostion
$LN3@CBEUHFSwit:

; 1338 : 	}
; 1339 : }

	pop	ebp
	ret	0
?CBEUHFSwitch@@YAXPAXH@Z ENDP				; CBEUHFSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExUHFSwitch@@YAXPAXH@Z PROC				; CBExUHFSwitch

; 1325 : void CBExUHFSwitch(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1326 : 
; 1327 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1328 : 	pCPButton->SetCurrentState(OTWDriver.pCockpitManager->mMiscStates.mUHFPosition);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+316]
	push	edx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1329 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExUHFSwitch@@YAXPAXH@Z ENDP				; CBExUHFSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEECMSwitch@@YAXPAXH@Z PROC				; CBEECMSwitch

; 1316 : void CBEECMSwitch(void *, int) {

	push	ebp
	mov	ebp, esp

; 1317 : 
; 1318 : 	SimECMOn(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimECMOn@@YAXKHPAX@Z			; SimECMOn
	add	esp, 12					; 0000000cH

; 1319 : }

	pop	ebp
	ret	0
?CBEECMSwitch@@YAXPAXH@Z ENDP				; CBEECMSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExECMSwitch@@YAXPAXH@Z PROC				; CBExECMSwitch

; 1300 : void CBExECMSwitch(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1301 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1302 : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExECMSwi

; 1303 : 		return;

	jmp	SHORT $LN4@CBExECMSwi
$LN3@CBExECMSwi:

; 1304 : 	}
; 1305 : 
; 1306 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1307 : 
; 1308 : 	if (playerAC->IsSetFlag(ECM_ON)){

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN2@CBExECMSwi

; 1309 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1310 : 	}
; 1311 : 	else {

	jmp	SHORT $LN4@CBExECMSwi
$LN2@CBExECMSwi:

; 1312 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExECMSwi:

; 1313 : 	}
; 1314 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExECMSwitch@@YAXPAXH@Z ENDP				; CBExECMSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEHUDBrightness@@YAXPAXH@Z PROC			; CBEHUDBrightness

; 1292 : {

	push	ebp
	mov	ebp, esp

; 1293 : 	SimHUDBrightness(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDBrightness@@YAXKHPAX@Z		; SimHUDBrightness
	add	esp, 12					; 0000000cH

; 1294 : }

	pop	ebp
	ret	0
?CBEHUDBrightness@@YAXPAXH@Z ENDP			; CBEHUDBrightness
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDBrightness@@YAXPAXH@Z PROC			; CBExHUDBrightness

; 1268 : void CBExHUDBrightness(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1269 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1270 : 
; 1271 : 	switch (TheHud->GetBrightnessSwitch()) 

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetBrightnessSwitch@HudClass@@QAEHXZ	; HudClass::GetBrightnessSwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@CBExHUDBri
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN3@CBExHUDBri
	cmp	DWORD PTR tv66[ebp], 3
	je	SHORT $LN2@CBExHUDBri
	jmp	SHORT $LN1@CBExHUDBri
$LN4@CBExHUDBri:

; 1272 : 	{
; 1273 : 	case HudClass::DAY:
; 1274 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1275 : 	break;

	jmp	SHORT $LN7@CBExHUDBri
$LN3@CBExHUDBri:

; 1276 : 
; 1277 : 	case HudClass::BRIGHT_AUTO:
; 1278 : 		pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1279 : 	break;

	jmp	SHORT $LN7@CBExHUDBri
$LN2@CBExHUDBri:

; 1280 : 
; 1281 : 	case HudClass::NIGHT:
; 1282 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1283 : 	break;

	jmp	SHORT $LN7@CBExHUDBri
$LN1@CBExHUDBri:

; 1284 : 
; 1285 : 	default:
; 1286 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExHUDBri:

; 1287 : 	break;
; 1288 : 	}
; 1289 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDBrightness@@YAXPAXH@Z ENDP			; CBExHUDBrightness
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDRadar@@YAXPAXH@Z PROC				; CBEHUDRadar

; 1259 : void CBEHUDRadar(void *, int) {

	push	ebp
	mov	ebp, esp

; 1260 : 
; 1261 : 	SimHUDRadar(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDRadar@@YAXKHPAX@Z		; SimHUDRadar
	add	esp, 12					; 0000000cH

; 1262 : }

	pop	ebp
	ret	0
?CBEHUDRadar@@YAXPAXH@Z ENDP				; CBEHUDRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDRadar@@YAXPAXH@Z PROC				; CBExHUDRadar

; 1237 : void CBExHUDRadar(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1238 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1239 : 
; 1240 : 	switch (TheHud->GetRadarSwitch()) {

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetRadarSwitch@HudClass@@QAEHXZ	; HudClass::GetRadarSwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@CBExHUDRad
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN3@CBExHUDRad
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN2@CBExHUDRad
	jmp	SHORT $LN1@CBExHUDRad
$LN4@CBExHUDRad:

; 1241 : 	case HudClass::ALT_RADAR:
; 1242 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1243 : 	break;

	jmp	SHORT $LN7@CBExHUDRad
$LN3@CBExHUDRad:

; 1244 : 
; 1245 : 	case HudClass::BARO:
; 1246 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1247 : 	break;

	jmp	SHORT $LN7@CBExHUDRad
$LN2@CBExHUDRad:

; 1248 : 
; 1249 : 	case HudClass::RADAR_AUTO:
; 1250 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1251 : 	break;

	jmp	SHORT $LN7@CBExHUDRad
$LN1@CBExHUDRad:

; 1252 : 
; 1253 : 	default:
; 1254 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExHUDRad:

; 1255 : 	break;
; 1256 : 	}
; 1257 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDRadar@@YAXPAXH@Z ENDP				; CBExHUDRadar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDVelocity@@YAXPAXH@Z PROC				; CBEHUDVelocity

; 1228 : void CBEHUDVelocity(void *, int) {

	push	ebp
	mov	ebp, esp

; 1229 : 
; 1230 : 	SimHUDVelocity(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDVelocity@@YAXKHPAX@Z		; SimHUDVelocity
	add	esp, 12					; 0000000cH

; 1231 : }

	pop	ebp
	ret	0
?CBEHUDVelocity@@YAXPAXH@Z ENDP				; CBEHUDVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDVelocity@@YAXPAXH@Z PROC			; CBExHUDVelocity

; 1206 : void CBExHUDVelocity(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1207 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1208 : 
; 1209 : 	switch (TheHud->GetVelocitySwitch()) {

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetVelocitySwitch@HudClass@@QAEHXZ	; HudClass::GetVelocitySwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@CBExHUDVel
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN3@CBExHUDVel
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN2@CBExHUDVel
	jmp	SHORT $LN1@CBExHUDVel
$LN4@CBExHUDVel:

; 1210 : 	case HudClass::CAS:
; 1211 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1212 : 	break;

	jmp	SHORT $LN7@CBExHUDVel
$LN3@CBExHUDVel:

; 1213 : 
; 1214 : 	case HudClass::TAS:
; 1215 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1216 : 	break;

	jmp	SHORT $LN7@CBExHUDVel
$LN2@CBExHUDVel:

; 1217 : 
; 1218 : 	case HudClass::GND_SPD:
; 1219 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1220 : 	break;

	jmp	SHORT $LN7@CBExHUDVel
$LN1@CBExHUDVel:

; 1221 : 
; 1222 : 	default:
; 1223 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExHUDVel:

; 1224 : 	break;
; 1225 : 	}
; 1226 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDVelocity@@YAXPAXH@Z ENDP			; CBExHUDVelocity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDDriftCO@@YAXPAXH@Z PROC				; CBEHUDDriftCO

; 1193 : void CBEHUDDriftCO(void *, int) {

	push	ebp
	mov	ebp, esp

; 1194 : 
; 1195 : 	SimDriftCO(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDriftCO@@YAXKHPAX@Z			; SimDriftCO
	add	esp, 12					; 0000000cH

; 1196 : }

	pop	ebp
	ret	0
?CBEHUDDriftCO@@YAXPAXH@Z ENDP				; CBEHUDDriftCO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDDriftCO@@YAXPAXH@Z PROC				; CBExHUDDriftCO

; 1175 : void CBExHUDDriftCO(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1176 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1177 : 
; 1178 : 	switch (TheHud->GetDriftCOSwitch()) {

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN3@CBExHUDDri
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN2@CBExHUDDri
	jmp	SHORT $LN1@CBExHUDDri
$LN3@CBExHUDDri:

; 1179 : 	case HudClass::DRIFT_CO_OFF:
; 1180 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1181 : 	break;

	jmp	SHORT $LN6@CBExHUDDri
$LN2@CBExHUDDri:

; 1182 : 
; 1183 : 	case HudClass::DRIFT_CO_ON:
; 1184 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1185 : 	break;

	jmp	SHORT $LN6@CBExHUDDri
$LN1@CBExHUDDri:

; 1186 : 
; 1187 : 	default:
; 1188 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN6@CBExHUDDri:

; 1189 : 	break;
; 1190 : 	}	
; 1191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDDriftCO@@YAXPAXH@Z ENDP				; CBExHUDDriftCO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDDED@@YAXPAXH@Z PROC				; CBEHUDDED

; 1164 : void CBEHUDDED(void *, int) {

	push	ebp
	mov	ebp, esp

; 1165 : 
; 1166 : 	SimHUDDED(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDDED@@YAXKHPAX@Z			; SimHUDDED
	add	esp, 12					; 0000000cH

; 1167 : }

	pop	ebp
	ret	0
?CBEHUDDED@@YAXPAXH@Z ENDP				; CBEHUDDED
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDDED@@YAXPAXH@Z PROC				; CBExHUDDED

; 1142 : void CBExHUDDED(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1143 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1144 : 
; 1145 : 	switch (TheHud->GetDEDSwitch()) {

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDEDSwitch@HudClass@@QAEHXZ		; HudClass::GetDEDSwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN3@CBExHUDDED
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@CBExHUDDED
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN2@CBExHUDDED
	jmp	SHORT $LN1@CBExHUDDED
$LN4@CBExHUDDED:

; 1146 : 	case HudClass::DED_OFF:
; 1147 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1148 : 	break;

	jmp	SHORT $LN7@CBExHUDDED
$LN3@CBExHUDDED:

; 1149 : 
; 1150 : 	case HudClass::DED_DATA:
; 1151 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1152 : 	break;

	jmp	SHORT $LN7@CBExHUDDED
$LN2@CBExHUDDED:

; 1153 : 
; 1154 : 	case HudClass::PFL_DATA:
; 1155 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1156 : 	break;

	jmp	SHORT $LN7@CBExHUDDED
$LN1@CBExHUDDED:

; 1157 : 
; 1158 : 	default:
; 1159 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExHUDDED:

; 1160 : 	break;
; 1161 : 	}	
; 1162 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDDED@@YAXPAXH@Z ENDP				; CBExHUDDED
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDFPM@@YAXPAXH@Z PROC				; CBEHUDFPM

; 1133 : void CBEHUDFPM(void *, int) {

	push	ebp
	mov	ebp, esp

; 1134 : 
; 1135 : 	SimHUDFPM(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDFPM@@YAXKHPAX@Z			; SimHUDFPM
	add	esp, 12					; 0000000cH

; 1136 : }

	pop	ebp
	ret	0
?CBEHUDFPM@@YAXPAXH@Z ENDP				; CBEHUDFPM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDFPM@@YAXPAXH@Z PROC				; CBExHUDFPM

; 1111 : void CBExHUDFPM(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1112 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1113 : 
; 1114 : 	switch (TheHud->GetFPMSwitch()) {

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetFPMSwitch@HudClass@@QAEHXZ		; HudClass::GetFPMSwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN3@CBExHUDFPM
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@CBExHUDFPM
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN2@CBExHUDFPM
	jmp	SHORT $LN1@CBExHUDFPM
$LN4@CBExHUDFPM:

; 1115 : 	case HudClass::FPM:
; 1116 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1117 : 	break;

	jmp	SHORT $LN7@CBExHUDFPM
$LN3@CBExHUDFPM:

; 1118 : 
; 1119 : 	case HudClass::ATT_FPM:
; 1120 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1121 : 	break;

	jmp	SHORT $LN7@CBExHUDFPM
$LN2@CBExHUDFPM:

; 1122 : 
; 1123 : 	case HudClass::FPM_OFF:
; 1124 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1125 : 	break;

	jmp	SHORT $LN7@CBExHUDFPM
$LN1@CBExHUDFPM:

; 1126 : 
; 1127 : 	default:
; 1128 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExHUDFPM:

; 1129 : 	break;
; 1130 : 	}	
; 1131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDFPM@@YAXPAXH@Z ENDP				; CBExHUDFPM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHUDScales@@YAXPAXH@Z PROC				; CBEHUDScales

; 1102 : void CBEHUDScales(void *, int) {

	push	ebp
	mov	ebp, esp

; 1103 : 
; 1104 : 	SimHUDScales(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHUDScales@@YAXKHPAX@Z		; SimHUDScales
	add	esp, 12					; 0000000cH

; 1105 : }

	pop	ebp
	ret	0
?CBEHUDScales@@YAXPAXH@Z ENDP				; CBEHUDScales
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHUDScales@@YAXPAXH@Z PROC				; CBExHUDScales

; 1080 : void CBExHUDScales(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1081 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1082 : 
; 1083 : 	switch (TheHud->GetScalesSwitch()) {

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetScalesSwitch@HudClass@@QAEHXZ	; HudClass::GetScalesSwitch
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN3@CBExHUDSca
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@CBExHUDSca
	cmp	DWORD PTR tv66[ebp], 3
	je	SHORT $LN2@CBExHUDSca
	jmp	SHORT $LN1@CBExHUDSca
$LN4@CBExHUDSca:

; 1084 : 	case HudClass::VAH:
; 1085 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1086 : 	break;

	jmp	SHORT $LN7@CBExHUDSca
$LN3@CBExHUDSca:

; 1087 : 
; 1088 : 	case HudClass::VV_VAH:
; 1089 : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1090 : 	break;

	jmp	SHORT $LN7@CBExHUDSca
$LN2@CBExHUDSca:

; 1091 : 
; 1092 : 	case HudClass::SS_OFF:
; 1093 : 		pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1094 : 	break;

	jmp	SHORT $LN7@CBExHUDSca
$LN1@CBExHUDSca:

; 1095 : 
; 1096 : 	default:
; 1097 : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN7@CBExHUDSca:

; 1098 : 	break;
; 1099 : 	}	
; 1100 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDScales@@YAXPAXH@Z ENDP				; CBExHUDScales
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExICPTertiaryExclusive@@YAXPAXH@Z PROC		; CBExICPTertiaryExclusive

; 1055 : void CBExICPTertiaryExclusive(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1056 : 
; 1057 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1058 : 
; 1059 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@CBExICPTer

; 1060 : 	{
; 1061 : 		//MI original code
; 1062 : 		if(OTWDriver.pCockpitManager->mpIcp->GetTertiaryExclusiveButton() == pButton){

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?GetTertiaryExclusiveButton@ICPClass@@QAEPAVCPButtonObject@@XZ ; ICPClass::GetTertiaryExclusiveButton
	cmp	eax, DWORD PTR _pButton$[ebp]
	jne	SHORT $LN3@CBExICPTer

; 1063 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1064 : 		}
; 1065 : 		else {

	jmp	SHORT $LN2@CBExICPTer
$LN3@CBExICPTer:

; 1066 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExICPTer:

; 1067 : 		}
; 1068 : 	}
; 1069 : 	else

	jmp	SHORT $LN5@CBExICPTer
$LN4@CBExICPTer:

; 1070 : 	{
; 1071 : 		//MI modified code
; 1072 : 		//pCPButton->SetCurrentState(0);
; 1073 : 	    pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN7@CBExICPTer
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN8@CBExICPTer
$LN7@CBExICPTer:
	mov	DWORD PTR tv76[ebp], 1
$LN8@CBExICPTer:
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExICPTer:

; 1074 : 	}
; 1075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExICPTertiaryExclusive@@YAXPAXH@Z ENDP		; CBExICPTertiaryExclusive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExICPSecondaryExclusive@@YAXPAXH@Z PROC		; CBExICPSecondaryExclusive

; 1032 : void CBExICPSecondaryExclusive(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1033 : 	
; 1034 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1035 : 
; 1036 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@CBExICPSec

; 1037 : 	{
; 1038 : 		//MI original code
; 1039 : 		if(OTWDriver.pCockpitManager->mpIcp->GetSecondaryExclusiveButton() == pButton){

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?GetSecondaryExclusiveButton@ICPClass@@QAEPAVCPButtonObject@@XZ ; ICPClass::GetSecondaryExclusiveButton
	cmp	eax, DWORD PTR _pButton$[ebp]
	jne	SHORT $LN3@CBExICPSec

; 1040 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1041 : 		}
; 1042 : 		else {

	jmp	SHORT $LN2@CBExICPSec
$LN3@CBExICPSec:

; 1043 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExICPSec:

; 1044 : 		}
; 1045 : 	}
; 1046 : 	else

	jmp	SHORT $LN5@CBExICPSec
$LN4@CBExICPSec:

; 1047 : 	{
; 1048 : 		//MI modified code
; 1049 : 		//pCPButton->SetCurrentState(1);
; 1050 : 	    pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN7@CBExICPSec
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN8@CBExICPSec
$LN7@CBExICPSec:
	mov	DWORD PTR tv76[ebp], 1
$LN8@CBExICPSec:
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExICPSec:

; 1051 : 	}
; 1052 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExICPSecondaryExclusive@@YAXPAXH@Z ENDP		; CBExICPSecondaryExclusive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExICPPrimaryExclusive@@YAXPAXH@Z PROC		; CBExICPPrimaryExclusive

; 1008 : void CBExICPPrimaryExclusive(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1009 : 
; 1010 : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 1011 : 
; 1012 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN4@CBExICPPri

; 1013 : 	{
; 1014 : 		//MI original code
; 1015 : 		if(OTWDriver.pCockpitManager->mpIcp->GetPrimaryExclusiveButton() == pButton)

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?GetPrimaryExclusiveButton@ICPClass@@QAEPAVCPButtonObject@@XZ ; ICPClass::GetPrimaryExclusiveButton
	cmp	eax, DWORD PTR _pButton$[ebp]
	jne	SHORT $LN3@CBExICPPri

; 1016 : 		{
; 1017 : 			pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 1018 : 		}
; 1019 : 		else 

	jmp	SHORT $LN2@CBExICPPri
$LN3@CBExICPPri:

; 1020 : 		{
; 1021 : 			pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN2@CBExICPPri:

; 1022 : 		}
; 1023 : 	}
; 1024 : 	else

	jmp	SHORT $LN5@CBExICPPri
$LN4@CBExICPPri:

; 1025 : 	{
; 1026 : 		//MI modified code
; 1027 : 		//pCPButton->SetCurrentState(1);
; 1028 : 	    pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN7@CBExICPPri
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN8@CBExICPPri
$LN7@CBExICPPri:
	mov	DWORD PTR tv76[ebp], 1
$LN8@CBExICPPri:
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExICPPri:

; 1029 : 	}
; 1030 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExICPPrimaryExclusive@@YAXPAXH@Z ENDP		; CBExICPPrimaryExclusive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPAG@@YAXPAXH@Z PROC				; CBEICPAG

; 1001 : void CBEICPAG(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 1002 : 	
; 1003 : 	SimICPAG(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPAG@@YAXKHPAX@Z			; SimICPAG
	add	esp, 12					; 0000000cH

; 1004 : }

	pop	ebp
	ret	0
?CBEICPAG@@YAXPAXH@Z ENDP				; CBEICPAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPAA@@YAXPAXH@Z PROC				; CBEICPAA

; 992  : void CBEICPAA(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 993  : 	
; 994  : 	SimICPAA(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPAA@@YAXKHPAX@Z			; SimICPAA
	add	esp, 12					; 0000000cH

; 995  : }

	pop	ebp
	ret	0
?CBEICPAA@@YAXPAXH@Z ENDP				; CBEICPAA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPNav@@YAXPAXH@Z PROC				; CBEICPNav

; 983  : void CBEICPNav(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 984  : 	
; 985  : 	SimICPNav(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPNav@@YAXKHPAX@Z			; SimICPNav
	add	esp, 12					; 0000000cH

; 986  : }

	pop	ebp
	ret	0
?CBEICPNav@@YAXPAXH@Z ENDP				; CBEICPNav
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPCom2@@YAXPAXH@Z PROC				; CBEICPCom2

; 974  : void CBEICPCom2(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 975  : 	
; 976  : 	SimICPCom2(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPCom2@@YAXKHPAX@Z			; SimICPCom2
	add	esp, 12					; 0000000cH

; 977  : }

	pop	ebp
	ret	0
?CBEICPCom2@@YAXPAXH@Z ENDP				; CBEICPCom2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPCom1@@YAXPAXH@Z PROC				; CBEICPCom1

; 964  : void CBEICPCom1(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 965  : 	
; 966  : 	SimICPCom1(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPCom1@@YAXKHPAX@Z			; SimICPCom1
	add	esp, 12					; 0000000cH

; 967  : }

	pop	ebp
	ret	0
?CBEICPCom1@@YAXPAXH@Z ENDP				; CBEICPCom1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExICPEnter@@YAXPAXH@Z PROC				; CBExICPEnter

; 952  : void CBExICPEnter(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 953  : 	
; 954  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 955  : 	//pCPButton->SetCurrentState(1);
; 956  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExICPEnt
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExICPEnt
$LN3@CBExICPEnt:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExICPEnt:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 957  : 
; 958  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExICPEnter@@YAXPAXH@Z ENDP				; CBExICPEnter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPEnter@@YAXPAXH@Z PROC				; CBEICPEnter

; 947  : void CBEICPEnter(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 948  : 
; 949  : 	SimICPEnter(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPEnter@@YAXKHPAX@Z		; SimICPEnter
	add	esp, 12					; 0000000cH

; 950  : }

	pop	ebp
	ret	0
?CBEICPEnter@@YAXPAXH@Z ENDP				; CBEICPEnter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPMark@@YAXPAXH@Z PROC				; CBEICPMark

; 938  : void CBEICPMark(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 939  : 
; 940  : 	SimICPMark(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPMark@@YAXKHPAX@Z			; SimICPMark
	add	esp, 12					; 0000000cH

; 941  : }

	pop	ebp
	ret	0
?CBEICPMark@@YAXPAXH@Z ENDP				; CBEICPMark
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPStpt@@YAXPAXH@Z PROC				; CBEICPStpt

; 929  : void CBEICPStpt(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 930  : 
; 931  : 	SimICPStpt(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPStpt@@YAXKHPAX@Z			; SimICPStpt
	add	esp, 12					; 0000000cH

; 932  : }

	pop	ebp
	ret	0
?CBEICPStpt@@YAXPAXH@Z ENDP				; CBEICPStpt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPCrus@@YAXPAXH@Z PROC				; CBEICPCrus

; 920  : void CBEICPCrus(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 921  : 
; 922  : 	SimICPCrus(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPCrus@@YAXKHPAX@Z			; SimICPCrus
	add	esp, 12					; 0000000cH

; 923  : }

	pop	ebp
	ret	0
?CBEICPCrus@@YAXPAXH@Z ENDP				; CBEICPCrus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPLink@@YAXPAXH@Z PROC				; CBEICPLink

; 911  : void CBEICPLink(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 912  : 
; 913  : 	SimICPLink(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPLink@@YAXKHPAX@Z			; SimICPLink
	add	esp, 12					; 0000000cH

; 914  : }

	pop	ebp
	ret	0
?CBEICPLink@@YAXPAXH@Z ENDP				; CBEICPLink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExICPNext@@YAXPAXH@Z PROC				; CBExICPNext

; 900  : void CBExICPNext(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 901  : 	
; 902  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 903  : 	//pCPButton->SetCurrentState(1);
; 904  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExICPNex
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExICPNex
$LN3@CBExICPNex:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExICPNex:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 905  : 
; 906  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExICPNext@@YAXPAXH@Z ENDP				; CBExICPNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPNext@@YAXPAXH@Z PROC				; CBEICPNext

; 895  : void CBEICPNext(void * pButton, int) {

	push	ebp
	mov	ebp, esp

; 896  : 
; 897  : 	SimICPNext(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPNext@@YAXKHPAX@Z			; SimICPNext
	add	esp, 12					; 0000000cH

; 898  : }

	pop	ebp
	ret	0
?CBEICPNext@@YAXPAXH@Z ENDP				; CBEICPNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExICPPrevious@@YAXPAXH@Z PROC			; CBExICPPrevious

; 882  : void CBExICPPrevious(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 883  : 	
; 884  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 885  : 	//pCPButton->SetCurrentState(1);
; 886  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExICPPre
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExICPPre
$LN3@CBExICPPre:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExICPPre:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 887  : 
; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExICPPrevious@@YAXPAXH@Z ENDP			; CBExICPPrevious
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPPrevious@@YAXPAXH@Z PROC				; CBEICPPrevious

; 877  : void CBEICPPrevious(void *pButton, int) {

	push	ebp
	mov	ebp, esp

; 878  : 
; 879  : 	SimICPPrevious(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPPrevious@@YAXKHPAX@Z		; SimICPPrevious
	add	esp, 12					; 0000000cH

; 880  : }

	pop	ebp
	ret	0
?CBEICPPrevious@@YAXPAXH@Z ENDP				; CBEICPPrevious
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPFAck@@YAXPAXH@Z PROC				; CBEICPFAck

; 868  : void CBEICPFAck(void *pButton, int) {

	push	ebp
	mov	ebp, esp

; 869  : 
; 870  : 	SimICPFAck(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPFAck@@YAXKHPAX@Z			; SimICPFAck
	add	esp, 12					; 0000000cH

; 871  : }

	pop	ebp
	ret	0
?CBEICPFAck@@YAXPAXH@Z ENDP				; CBEICPFAck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPALOW@@YAXPAXH@Z PROC				; CBEICPALOW

; 857  : void CBEICPALOW(void *pButton, int) {

	push	ebp
	mov	ebp, esp

; 858  : 
; 859  : 	SimICPALOW(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPALOW@@YAXKHPAX@Z			; SimICPALOW
	add	esp, 12					; 0000000cH

; 860  : }

	pop	ebp
	ret	0
?CBEICPALOW@@YAXPAXH@Z ENDP				; CBEICPALOW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEICPTILS@@YAXPAXH@Z PROC				; CBEICPTILS

; 848  : void CBEICPTILS(void *pButton, int) {

	push	ebp
	mov	ebp, esp

; 849  : 
; 850  : 	SimICPTILS(0, KEY_DOWN, pButton);

	mov	eax, DWORD PTR _pButton$[ebp]
	push	eax
	push	8
	push	0
	call	?SimICPTILS@@YAXKHPAX@Z			; SimICPTILS
	add	esp, 12					; 0000000cH

; 851  : }

	pop	ebp
	ret	0
?CBEICPTILS@@YAXPAXH@Z ENDP				; CBEICPTILS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEFourGainUp@@YAXPAXH@Z PROC				; CBEFourGainUp

; 836  : void CBEFourGainUp(void *, int) {

	push	ebp
	mov	ebp, esp

; 837  : 	SimCBEOSB_GAINUP_F (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINUP_F@@YAXKHPAX@Z		; SimCBEOSB_GAINUP_F
	add	esp, 12					; 0000000cH

; 838  : }

	pop	ebp
	ret	0
?CBEFourGainUp@@YAXPAXH@Z ENDP				; CBEFourGainUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEFourGainDown@@YAXPAXH@Z PROC			; CBEFourGainDown

; 832  : void CBEFourGainDown(void *, int) {

	push	ebp
	mov	ebp, esp

; 833  : 	SimCBEOSB_GAINDOWN_F (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINDOWN_F@@YAXKHPAX@Z	; SimCBEOSB_GAINDOWN_F
	add	esp, 12					; 0000000cH

; 834  : }

	pop	ebp
	ret	0
?CBEFourGainDown@@YAXPAXH@Z ENDP			; CBEFourGainDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEThreeGainDown@@YAXPAXH@Z PROC			; CBEThreeGainDown

; 828  : void CBEThreeGainDown(void *, int) {

	push	ebp
	mov	ebp, esp

; 829  : 	SimCBEOSB_GAINDOWN_T (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINDOWN_T@@YAXKHPAX@Z	; SimCBEOSB_GAINDOWN_T
	add	esp, 12					; 0000000cH

; 830  : }

	pop	ebp
	ret	0
?CBEThreeGainDown@@YAXPAXH@Z ENDP			; CBEThreeGainDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEThreeGainUp@@YAXPAXH@Z PROC				; CBEThreeGainUp

; 824  : void CBEThreeGainUp(void *, int) {

	push	ebp
	mov	ebp, esp

; 825  : 	SimCBEOSB_GAINUP_T (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_GAINUP_T@@YAXKHPAX@Z		; SimCBEOSB_GAINUP_T
	add	esp, 12					; 0000000cH

; 826  : }

	pop	ebp
	ret	0
?CBEThreeGainUp@@YAXPAXH@Z ENDP				; CBEThreeGainUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_20F@@YAXPAXH@Z PROC				; CBEOSB_20F

; 819  : void CBEOSB_20F(void *, int) {

	push	ebp
	mov	ebp, esp

; 820  : 
; 821  : 	SimCBEOSB_20F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_20F@@YAXKHPAX@Z		; SimCBEOSB_20F
	add	esp, 12					; 0000000cH

; 822  : }

	pop	ebp
	ret	0
?CBEOSB_20F@@YAXPAXH@Z ENDP				; CBEOSB_20F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_19F@@YAXPAXH@Z PROC				; CBEOSB_19F

; 814  : void CBEOSB_19F(void *, int) {

	push	ebp
	mov	ebp, esp

; 815  : 
; 816  : 	SimCBEOSB_19F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_19F@@YAXKHPAX@Z		; SimCBEOSB_19F
	add	esp, 12					; 0000000cH

; 817  : }

	pop	ebp
	ret	0
?CBEOSB_19F@@YAXPAXH@Z ENDP				; CBEOSB_19F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_18F@@YAXPAXH@Z PROC				; CBEOSB_18F

; 809  : void CBEOSB_18F(void *, int) {

	push	ebp
	mov	ebp, esp

; 810  : 
; 811  : 	SimCBEOSB_18F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_18F@@YAXKHPAX@Z		; SimCBEOSB_18F
	add	esp, 12					; 0000000cH

; 812  : }

	pop	ebp
	ret	0
?CBEOSB_18F@@YAXPAXH@Z ENDP				; CBEOSB_18F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_17F@@YAXPAXH@Z PROC				; CBEOSB_17F

; 804  : void CBEOSB_17F(void *, int) {

	push	ebp
	mov	ebp, esp

; 805  : 
; 806  : 	SimCBEOSB_17F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_17F@@YAXKHPAX@Z		; SimCBEOSB_17F
	add	esp, 12					; 0000000cH

; 807  : }

	pop	ebp
	ret	0
?CBEOSB_17F@@YAXPAXH@Z ENDP				; CBEOSB_17F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_16F@@YAXPAXH@Z PROC				; CBEOSB_16F

; 799  : void CBEOSB_16F(void *, int) {

	push	ebp
	mov	ebp, esp

; 800  : 
; 801  : 	SimCBEOSB_16F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_16F@@YAXKHPAX@Z		; SimCBEOSB_16F
	add	esp, 12					; 0000000cH

; 802  : }

	pop	ebp
	ret	0
?CBEOSB_16F@@YAXPAXH@Z ENDP				; CBEOSB_16F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_15F@@YAXPAXH@Z PROC				; CBEOSB_15F

; 794  : void CBEOSB_15F(void *, int) {

	push	ebp
	mov	ebp, esp

; 795  : 
; 796  : 	SimCBEOSB_15F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_15F@@YAXKHPAX@Z		; SimCBEOSB_15F
	add	esp, 12					; 0000000cH

; 797  : }

	pop	ebp
	ret	0
?CBEOSB_15F@@YAXPAXH@Z ENDP				; CBEOSB_15F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_14F@@YAXPAXH@Z PROC				; CBEOSB_14F

; 789  : void CBEOSB_14F(void *, int) {

	push	ebp
	mov	ebp, esp

; 790  : 
; 791  : 	SimCBEOSB_14F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_14F@@YAXKHPAX@Z		; SimCBEOSB_14F
	add	esp, 12					; 0000000cH

; 792  : }

	pop	ebp
	ret	0
?CBEOSB_14F@@YAXPAXH@Z ENDP				; CBEOSB_14F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_13F@@YAXPAXH@Z PROC				; CBEOSB_13F

; 784  : void CBEOSB_13F(void *, int) {

	push	ebp
	mov	ebp, esp

; 785  : 
; 786  : 	SimCBEOSB_13F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_13F@@YAXKHPAX@Z		; SimCBEOSB_13F
	add	esp, 12					; 0000000cH

; 787  : }

	pop	ebp
	ret	0
?CBEOSB_13F@@YAXPAXH@Z ENDP				; CBEOSB_13F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_12F@@YAXPAXH@Z PROC				; CBEOSB_12F

; 779  : void CBEOSB_12F(void *, int) {

	push	ebp
	mov	ebp, esp

; 780  : 
; 781  : 	SimCBEOSB_12F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_12F@@YAXKHPAX@Z		; SimCBEOSB_12F
	add	esp, 12					; 0000000cH

; 782  : }

	pop	ebp
	ret	0
?CBEOSB_12F@@YAXPAXH@Z ENDP				; CBEOSB_12F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_11F@@YAXPAXH@Z PROC				; CBEOSB_11F

; 774  : void CBEOSB_11F(void *, int) {

	push	ebp
	mov	ebp, esp

; 775  : 
; 776  : 	SimCBEOSB_11F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_11F@@YAXKHPAX@Z		; SimCBEOSB_11F
	add	esp, 12					; 0000000cH

; 777  : }

	pop	ebp
	ret	0
?CBEOSB_11F@@YAXPAXH@Z ENDP				; CBEOSB_11F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_10F@@YAXPAXH@Z PROC				; CBEOSB_10F

; 769  : void CBEOSB_10F(void *, int) {

	push	ebp
	mov	ebp, esp

; 770  : 
; 771  : 	SimCBEOSB_10F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_10F@@YAXKHPAX@Z		; SimCBEOSB_10F
	add	esp, 12					; 0000000cH

; 772  : }

	pop	ebp
	ret	0
?CBEOSB_10F@@YAXPAXH@Z ENDP				; CBEOSB_10F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_9F@@YAXPAXH@Z PROC				; CBEOSB_9F

; 764  : void CBEOSB_9F(void *, int) {

	push	ebp
	mov	ebp, esp

; 765  : 
; 766  : 	SimCBEOSB_9F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_9F@@YAXKHPAX@Z		; SimCBEOSB_9F
	add	esp, 12					; 0000000cH

; 767  : }

	pop	ebp
	ret	0
?CBEOSB_9F@@YAXPAXH@Z ENDP				; CBEOSB_9F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_8F@@YAXPAXH@Z PROC				; CBEOSB_8F

; 759  : void CBEOSB_8F(void *, int) {

	push	ebp
	mov	ebp, esp

; 760  : 
; 761  : 	SimCBEOSB_8F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_8F@@YAXKHPAX@Z		; SimCBEOSB_8F
	add	esp, 12					; 0000000cH

; 762  : }

	pop	ebp
	ret	0
?CBEOSB_8F@@YAXPAXH@Z ENDP				; CBEOSB_8F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_7F@@YAXPAXH@Z PROC				; CBEOSB_7F

; 754  : void CBEOSB_7F(void *, int) {

	push	ebp
	mov	ebp, esp

; 755  : 
; 756  : 	SimCBEOSB_7F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_7F@@YAXKHPAX@Z		; SimCBEOSB_7F
	add	esp, 12					; 0000000cH

; 757  : }

	pop	ebp
	ret	0
?CBEOSB_7F@@YAXPAXH@Z ENDP				; CBEOSB_7F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_6F@@YAXPAXH@Z PROC				; CBEOSB_6F

; 749  : void CBEOSB_6F(void *, int) {

	push	ebp
	mov	ebp, esp

; 750  : 
; 751  : 	SimCBEOSB_6F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_6F@@YAXKHPAX@Z		; SimCBEOSB_6F
	add	esp, 12					; 0000000cH

; 752  : }

	pop	ebp
	ret	0
?CBEOSB_6F@@YAXPAXH@Z ENDP				; CBEOSB_6F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_5F@@YAXPAXH@Z PROC				; CBEOSB_5F

; 744  : void CBEOSB_5F(void *, int) {

	push	ebp
	mov	ebp, esp

; 745  : 
; 746  : 	SimCBEOSB_5F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_5F@@YAXKHPAX@Z		; SimCBEOSB_5F
	add	esp, 12					; 0000000cH

; 747  : }

	pop	ebp
	ret	0
?CBEOSB_5F@@YAXPAXH@Z ENDP				; CBEOSB_5F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_4F@@YAXPAXH@Z PROC				; CBEOSB_4F

; 739  : void CBEOSB_4F(void *, int) {

	push	ebp
	mov	ebp, esp

; 740  : 
; 741  : 	SimCBEOSB_4F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_4F@@YAXKHPAX@Z		; SimCBEOSB_4F
	add	esp, 12					; 0000000cH

; 742  : }

	pop	ebp
	ret	0
?CBEOSB_4F@@YAXPAXH@Z ENDP				; CBEOSB_4F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_3F@@YAXPAXH@Z PROC				; CBEOSB_3F

; 734  : void CBEOSB_3F(void *, int) {

	push	ebp
	mov	ebp, esp

; 735  : 
; 736  : 	SimCBEOSB_3F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_3F@@YAXKHPAX@Z		; SimCBEOSB_3F
	add	esp, 12					; 0000000cH

; 737  : }

	pop	ebp
	ret	0
?CBEOSB_3F@@YAXPAXH@Z ENDP				; CBEOSB_3F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_2F@@YAXPAXH@Z PROC				; CBEOSB_2F

; 729  : void CBEOSB_2F(void *, int) {

	push	ebp
	mov	ebp, esp

; 730  : 
; 731  : 	SimCBEOSB_2F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_2F@@YAXKHPAX@Z		; SimCBEOSB_2F
	add	esp, 12					; 0000000cH

; 732  : }

	pop	ebp
	ret	0
?CBEOSB_2F@@YAXPAXH@Z ENDP				; CBEOSB_2F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_1F@@YAXPAXH@Z PROC				; CBEOSB_1F

; 724  : void CBEOSB_1F(void *, int) {

	push	ebp
	mov	ebp, esp

; 725  : 
; 726  : 	SimCBEOSB_1F(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_1F@@YAXKHPAX@Z		; SimCBEOSB_1F
	add	esp, 12					; 0000000cH

; 727  : }

	pop	ebp
	ret	0
?CBEOSB_1F@@YAXPAXH@Z ENDP				; CBEOSB_1F
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_20T@@YAXPAXH@Z PROC				; CBEOSB_20T

; 718  : void CBEOSB_20T(void *, int) {

	push	ebp
	mov	ebp, esp

; 719  : 
; 720  : 	SimCBEOSB_20T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_20T@@YAXKHPAX@Z		; SimCBEOSB_20T
	add	esp, 12					; 0000000cH

; 721  : }

	pop	ebp
	ret	0
?CBEOSB_20T@@YAXPAXH@Z ENDP				; CBEOSB_20T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_19T@@YAXPAXH@Z PROC				; CBEOSB_19T

; 713  : void CBEOSB_19T(void *, int) {

	push	ebp
	mov	ebp, esp

; 714  : 
; 715  : 	SimCBEOSB_19T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_19T@@YAXKHPAX@Z		; SimCBEOSB_19T
	add	esp, 12					; 0000000cH

; 716  : }

	pop	ebp
	ret	0
?CBEOSB_19T@@YAXPAXH@Z ENDP				; CBEOSB_19T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_18T@@YAXPAXH@Z PROC				; CBEOSB_18T

; 708  : void CBEOSB_18T(void *, int) {

	push	ebp
	mov	ebp, esp

; 709  : 
; 710  : 	SimCBEOSB_18T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_18T@@YAXKHPAX@Z		; SimCBEOSB_18T
	add	esp, 12					; 0000000cH

; 711  : }

	pop	ebp
	ret	0
?CBEOSB_18T@@YAXPAXH@Z ENDP				; CBEOSB_18T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_17T@@YAXPAXH@Z PROC				; CBEOSB_17T

; 703  : void CBEOSB_17T(void *, int) {

	push	ebp
	mov	ebp, esp

; 704  : 
; 705  : 	SimCBEOSB_17T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_17T@@YAXKHPAX@Z		; SimCBEOSB_17T
	add	esp, 12					; 0000000cH

; 706  : }

	pop	ebp
	ret	0
?CBEOSB_17T@@YAXPAXH@Z ENDP				; CBEOSB_17T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_16T@@YAXPAXH@Z PROC				; CBEOSB_16T

; 698  : void CBEOSB_16T(void *, int) {

	push	ebp
	mov	ebp, esp

; 699  : 
; 700  : 	SimCBEOSB_16T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_16T@@YAXKHPAX@Z		; SimCBEOSB_16T
	add	esp, 12					; 0000000cH

; 701  : }

	pop	ebp
	ret	0
?CBEOSB_16T@@YAXPAXH@Z ENDP				; CBEOSB_16T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_15T@@YAXPAXH@Z PROC				; CBEOSB_15T

; 693  : void CBEOSB_15T(void *, int) {

	push	ebp
	mov	ebp, esp

; 694  : 
; 695  : 	SimCBEOSB_15T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_15T@@YAXKHPAX@Z		; SimCBEOSB_15T
	add	esp, 12					; 0000000cH

; 696  : }

	pop	ebp
	ret	0
?CBEOSB_15T@@YAXPAXH@Z ENDP				; CBEOSB_15T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_14T@@YAXPAXH@Z PROC				; CBEOSB_14T

; 688  : void CBEOSB_14T(void *, int) {

	push	ebp
	mov	ebp, esp

; 689  : 
; 690  : 	SimCBEOSB_14T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_14T@@YAXKHPAX@Z		; SimCBEOSB_14T
	add	esp, 12					; 0000000cH

; 691  : }

	pop	ebp
	ret	0
?CBEOSB_14T@@YAXPAXH@Z ENDP				; CBEOSB_14T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_13T@@YAXPAXH@Z PROC				; CBEOSB_13T

; 683  : void CBEOSB_13T(void *, int) {

	push	ebp
	mov	ebp, esp

; 684  : 
; 685  : 	SimCBEOSB_13T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_13T@@YAXKHPAX@Z		; SimCBEOSB_13T
	add	esp, 12					; 0000000cH

; 686  : }

	pop	ebp
	ret	0
?CBEOSB_13T@@YAXPAXH@Z ENDP				; CBEOSB_13T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_12T@@YAXPAXH@Z PROC				; CBEOSB_12T

; 678  : void CBEOSB_12T(void *, int) {

	push	ebp
	mov	ebp, esp

; 679  : 
; 680  : 	SimCBEOSB_12T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_12T@@YAXKHPAX@Z		; SimCBEOSB_12T
	add	esp, 12					; 0000000cH

; 681  : }

	pop	ebp
	ret	0
?CBEOSB_12T@@YAXPAXH@Z ENDP				; CBEOSB_12T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_11T@@YAXPAXH@Z PROC				; CBEOSB_11T

; 673  : void CBEOSB_11T(void *, int) {

	push	ebp
	mov	ebp, esp

; 674  : 
; 675  : 	SimCBEOSB_11T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_11T@@YAXKHPAX@Z		; SimCBEOSB_11T
	add	esp, 12					; 0000000cH

; 676  : }

	pop	ebp
	ret	0
?CBEOSB_11T@@YAXPAXH@Z ENDP				; CBEOSB_11T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_10T@@YAXPAXH@Z PROC				; CBEOSB_10T

; 668  : void CBEOSB_10T(void *, int) {

	push	ebp
	mov	ebp, esp

; 669  : 
; 670  : 	SimCBEOSB_10T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_10T@@YAXKHPAX@Z		; SimCBEOSB_10T
	add	esp, 12					; 0000000cH

; 671  : }

	pop	ebp
	ret	0
?CBEOSB_10T@@YAXPAXH@Z ENDP				; CBEOSB_10T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_9T@@YAXPAXH@Z PROC				; CBEOSB_9T

; 663  : void CBEOSB_9T(void *, int) {

	push	ebp
	mov	ebp, esp

; 664  : 
; 665  : 	SimCBEOSB_9T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_9T@@YAXKHPAX@Z		; SimCBEOSB_9T
	add	esp, 12					; 0000000cH

; 666  : }

	pop	ebp
	ret	0
?CBEOSB_9T@@YAXPAXH@Z ENDP				; CBEOSB_9T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_8T@@YAXPAXH@Z PROC				; CBEOSB_8T

; 658  : void CBEOSB_8T(void *, int) {

	push	ebp
	mov	ebp, esp

; 659  : 
; 660  : 	SimCBEOSB_8T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_8T@@YAXKHPAX@Z		; SimCBEOSB_8T
	add	esp, 12					; 0000000cH

; 661  : }

	pop	ebp
	ret	0
?CBEOSB_8T@@YAXPAXH@Z ENDP				; CBEOSB_8T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_7T@@YAXPAXH@Z PROC				; CBEOSB_7T

; 653  : void CBEOSB_7T(void *, int) {

	push	ebp
	mov	ebp, esp

; 654  : 
; 655  : 	SimCBEOSB_7T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_7T@@YAXKHPAX@Z		; SimCBEOSB_7T
	add	esp, 12					; 0000000cH

; 656  : }

	pop	ebp
	ret	0
?CBEOSB_7T@@YAXPAXH@Z ENDP				; CBEOSB_7T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_6T@@YAXPAXH@Z PROC				; CBEOSB_6T

; 648  : void CBEOSB_6T(void *, int) {

	push	ebp
	mov	ebp, esp

; 649  : 
; 650  : 	SimCBEOSB_6T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_6T@@YAXKHPAX@Z		; SimCBEOSB_6T
	add	esp, 12					; 0000000cH

; 651  : }

	pop	ebp
	ret	0
?CBEOSB_6T@@YAXPAXH@Z ENDP				; CBEOSB_6T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_5T@@YAXPAXH@Z PROC				; CBEOSB_5T

; 643  : void CBEOSB_5T(void *, int) {

	push	ebp
	mov	ebp, esp

; 644  : 
; 645  : 	SimCBEOSB_5T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_5T@@YAXKHPAX@Z		; SimCBEOSB_5T
	add	esp, 12					; 0000000cH

; 646  : }

	pop	ebp
	ret	0
?CBEOSB_5T@@YAXPAXH@Z ENDP				; CBEOSB_5T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_4T@@YAXPAXH@Z PROC				; CBEOSB_4T

; 638  : void CBEOSB_4T(void *, int) {

	push	ebp
	mov	ebp, esp

; 639  : 
; 640  : 	SimCBEOSB_4T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_4T@@YAXKHPAX@Z		; SimCBEOSB_4T
	add	esp, 12					; 0000000cH

; 641  : }

	pop	ebp
	ret	0
?CBEOSB_4T@@YAXPAXH@Z ENDP				; CBEOSB_4T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_3T@@YAXPAXH@Z PROC				; CBEOSB_3T

; 633  : void CBEOSB_3T(void *, int) {

	push	ebp
	mov	ebp, esp

; 634  : 
; 635  : 	SimCBEOSB_3T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_3T@@YAXKHPAX@Z		; SimCBEOSB_3T
	add	esp, 12					; 0000000cH

; 636  : }

	pop	ebp
	ret	0
?CBEOSB_3T@@YAXPAXH@Z ENDP				; CBEOSB_3T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_2T@@YAXPAXH@Z PROC				; CBEOSB_2T

; 628  : void CBEOSB_2T(void *, int) {

	push	ebp
	mov	ebp, esp

; 629  : 
; 630  : 	SimCBEOSB_2T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_2T@@YAXKHPAX@Z		; SimCBEOSB_2T
	add	esp, 12					; 0000000cH

; 631  : }

	pop	ebp
	ret	0
?CBEOSB_2T@@YAXPAXH@Z ENDP				; CBEOSB_2T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_1T@@YAXPAXH@Z PROC				; CBEOSB_1T

; 623  : void CBEOSB_1T(void *, int) {

	push	ebp
	mov	ebp, esp

; 624  : 
; 625  : 	SimCBEOSB_1T(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_1T@@YAXKHPAX@Z		; SimCBEOSB_1T
	add	esp, 12					; 0000000cH

; 626  : }

	pop	ebp
	ret	0
?CBEOSB_1T@@YAXPAXH@Z ENDP				; CBEOSB_1T
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_20R@@YAXPAXH@Z PROC				; CBEOSB_20R

; 616  : void CBEOSB_20R(void *, int) {

	push	ebp
	mov	ebp, esp

; 617  : 
; 618  : 	SimCBEOSB_20R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_20R@@YAXKHPAX@Z		; SimCBEOSB_20R
	add	esp, 12					; 0000000cH

; 619  : }

	pop	ebp
	ret	0
?CBEOSB_20R@@YAXPAXH@Z ENDP				; CBEOSB_20R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_19R@@YAXPAXH@Z PROC				; CBEOSB_19R

; 611  : void CBEOSB_19R(void *, int) {

	push	ebp
	mov	ebp, esp

; 612  : 
; 613  : 	SimCBEOSB_19R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_19R@@YAXKHPAX@Z		; SimCBEOSB_19R
	add	esp, 12					; 0000000cH

; 614  : }

	pop	ebp
	ret	0
?CBEOSB_19R@@YAXPAXH@Z ENDP				; CBEOSB_19R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_18R@@YAXPAXH@Z PROC				; CBEOSB_18R

; 606  : void CBEOSB_18R(void *, int) {

	push	ebp
	mov	ebp, esp

; 607  : 
; 608  : 	SimCBEOSB_18R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_18R@@YAXKHPAX@Z		; SimCBEOSB_18R
	add	esp, 12					; 0000000cH

; 609  : }

	pop	ebp
	ret	0
?CBEOSB_18R@@YAXPAXH@Z ENDP				; CBEOSB_18R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_17R@@YAXPAXH@Z PROC				; CBEOSB_17R

; 601  : void CBEOSB_17R(void *, int) {

	push	ebp
	mov	ebp, esp

; 602  : 
; 603  : 	SimCBEOSB_17R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_17R@@YAXKHPAX@Z		; SimCBEOSB_17R
	add	esp, 12					; 0000000cH

; 604  : }

	pop	ebp
	ret	0
?CBEOSB_17R@@YAXPAXH@Z ENDP				; CBEOSB_17R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_16R@@YAXPAXH@Z PROC				; CBEOSB_16R

; 596  : void CBEOSB_16R(void *, int) {

	push	ebp
	mov	ebp, esp

; 597  : 
; 598  : 	SimCBEOSB_16R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_16R@@YAXKHPAX@Z		; SimCBEOSB_16R
	add	esp, 12					; 0000000cH

; 599  : }

	pop	ebp
	ret	0
?CBEOSB_16R@@YAXPAXH@Z ENDP				; CBEOSB_16R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_15R@@YAXPAXH@Z PROC				; CBEOSB_15R

; 591  : void CBEOSB_15R(void *, int) {

	push	ebp
	mov	ebp, esp

; 592  : 
; 593  : 	SimCBEOSB_15R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_15R@@YAXKHPAX@Z		; SimCBEOSB_15R
	add	esp, 12					; 0000000cH

; 594  : }

	pop	ebp
	ret	0
?CBEOSB_15R@@YAXPAXH@Z ENDP				; CBEOSB_15R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_14R@@YAXPAXH@Z PROC				; CBEOSB_14R

; 586  : void CBEOSB_14R(void *, int) {

	push	ebp
	mov	ebp, esp

; 587  : 
; 588  : 	SimCBEOSB_14R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_14R@@YAXKHPAX@Z		; SimCBEOSB_14R
	add	esp, 12					; 0000000cH

; 589  : }

	pop	ebp
	ret	0
?CBEOSB_14R@@YAXPAXH@Z ENDP				; CBEOSB_14R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_13R@@YAXPAXH@Z PROC				; CBEOSB_13R

; 581  : void CBEOSB_13R(void *, int) {

	push	ebp
	mov	ebp, esp

; 582  : 
; 583  : 	SimCBEOSB_13R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_13R@@YAXKHPAX@Z		; SimCBEOSB_13R
	add	esp, 12					; 0000000cH

; 584  : }

	pop	ebp
	ret	0
?CBEOSB_13R@@YAXPAXH@Z ENDP				; CBEOSB_13R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_12R@@YAXPAXH@Z PROC				; CBEOSB_12R

; 576  : void CBEOSB_12R(void *, int) {

	push	ebp
	mov	ebp, esp

; 577  : 
; 578  : 	SimCBEOSB_12R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_12R@@YAXKHPAX@Z		; SimCBEOSB_12R
	add	esp, 12					; 0000000cH

; 579  : }

	pop	ebp
	ret	0
?CBEOSB_12R@@YAXPAXH@Z ENDP				; CBEOSB_12R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_11R@@YAXPAXH@Z PROC				; CBEOSB_11R

; 571  : void CBEOSB_11R(void *, int) {

	push	ebp
	mov	ebp, esp

; 572  : 
; 573  : 	SimCBEOSB_11R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_11R@@YAXKHPAX@Z		; SimCBEOSB_11R
	add	esp, 12					; 0000000cH

; 574  : }

	pop	ebp
	ret	0
?CBEOSB_11R@@YAXPAXH@Z ENDP				; CBEOSB_11R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_10R@@YAXPAXH@Z PROC				; CBEOSB_10R

; 566  : void CBEOSB_10R(void *, int) {

	push	ebp
	mov	ebp, esp

; 567  : 
; 568  : 	SimCBEOSB_10R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_10R@@YAXKHPAX@Z		; SimCBEOSB_10R
	add	esp, 12					; 0000000cH

; 569  : }

	pop	ebp
	ret	0
?CBEOSB_10R@@YAXPAXH@Z ENDP				; CBEOSB_10R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_9R@@YAXPAXH@Z PROC				; CBEOSB_9R

; 561  : void CBEOSB_9R(void *, int) {

	push	ebp
	mov	ebp, esp

; 562  : 
; 563  : 	SimCBEOSB_9R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_9R@@YAXKHPAX@Z		; SimCBEOSB_9R
	add	esp, 12					; 0000000cH

; 564  : }

	pop	ebp
	ret	0
?CBEOSB_9R@@YAXPAXH@Z ENDP				; CBEOSB_9R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_8R@@YAXPAXH@Z PROC				; CBEOSB_8R

; 556  : void CBEOSB_8R(void *, int) {

	push	ebp
	mov	ebp, esp

; 557  : 
; 558  : 	SimCBEOSB_8R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_8R@@YAXKHPAX@Z		; SimCBEOSB_8R
	add	esp, 12					; 0000000cH

; 559  : }

	pop	ebp
	ret	0
?CBEOSB_8R@@YAXPAXH@Z ENDP				; CBEOSB_8R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_7R@@YAXPAXH@Z PROC				; CBEOSB_7R

; 551  : void CBEOSB_7R(void *, int) {

	push	ebp
	mov	ebp, esp

; 552  : 
; 553  : 	SimCBEOSB_7R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_7R@@YAXKHPAX@Z		; SimCBEOSB_7R
	add	esp, 12					; 0000000cH

; 554  : }

	pop	ebp
	ret	0
?CBEOSB_7R@@YAXPAXH@Z ENDP				; CBEOSB_7R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_6R@@YAXPAXH@Z PROC				; CBEOSB_6R

; 546  : void CBEOSB_6R(void *, int) {

	push	ebp
	mov	ebp, esp

; 547  : 
; 548  : 	SimCBEOSB_6R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_6R@@YAXKHPAX@Z		; SimCBEOSB_6R
	add	esp, 12					; 0000000cH

; 549  : }

	pop	ebp
	ret	0
?CBEOSB_6R@@YAXPAXH@Z ENDP				; CBEOSB_6R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_5R@@YAXPAXH@Z PROC				; CBEOSB_5R

; 541  : void CBEOSB_5R(void *, int) {

	push	ebp
	mov	ebp, esp

; 542  : 
; 543  : 	SimCBEOSB_5R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_5R@@YAXKHPAX@Z		; SimCBEOSB_5R
	add	esp, 12					; 0000000cH

; 544  : }

	pop	ebp
	ret	0
?CBEOSB_5R@@YAXPAXH@Z ENDP				; CBEOSB_5R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_4R@@YAXPAXH@Z PROC				; CBEOSB_4R

; 536  : void CBEOSB_4R(void *, int) {

	push	ebp
	mov	ebp, esp

; 537  : 
; 538  : 	SimCBEOSB_4R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_4R@@YAXKHPAX@Z		; SimCBEOSB_4R
	add	esp, 12					; 0000000cH

; 539  : }

	pop	ebp
	ret	0
?CBEOSB_4R@@YAXPAXH@Z ENDP				; CBEOSB_4R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_3R@@YAXPAXH@Z PROC				; CBEOSB_3R

; 531  : void CBEOSB_3R(void *, int) {

	push	ebp
	mov	ebp, esp

; 532  : 
; 533  : 	SimCBEOSB_3R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_3R@@YAXKHPAX@Z		; SimCBEOSB_3R
	add	esp, 12					; 0000000cH

; 534  : }

	pop	ebp
	ret	0
?CBEOSB_3R@@YAXPAXH@Z ENDP				; CBEOSB_3R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_2R@@YAXPAXH@Z PROC				; CBEOSB_2R

; 526  : void CBEOSB_2R(void *, int) {

	push	ebp
	mov	ebp, esp

; 527  : 
; 528  : 	SimCBEOSB_2R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_2R@@YAXKHPAX@Z		; SimCBEOSB_2R
	add	esp, 12					; 0000000cH

; 529  : }

	pop	ebp
	ret	0
?CBEOSB_2R@@YAXPAXH@Z ENDP				; CBEOSB_2R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_1R@@YAXPAXH@Z PROC				; CBEOSB_1R

; 521  : void CBEOSB_1R(void *, int) {

	push	ebp
	mov	ebp, esp

; 522  : 
; 523  : 	SimCBEOSB_1R(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_1R@@YAXKHPAX@Z		; SimCBEOSB_1R
	add	esp, 12					; 0000000cH

; 524  : }

	pop	ebp
	ret	0
?CBEOSB_1R@@YAXPAXH@Z ENDP				; CBEOSB_1R
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_20L@@YAXPAXH@Z PROC				; CBEOSB_20L

; 515  : void CBEOSB_20L(void *, int) {

	push	ebp
	mov	ebp, esp

; 516  : 
; 517  : 	SimCBEOSB_20L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_20L@@YAXKHPAX@Z		; SimCBEOSB_20L
	add	esp, 12					; 0000000cH

; 518  : }

	pop	ebp
	ret	0
?CBEOSB_20L@@YAXPAXH@Z ENDP				; CBEOSB_20L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_19L@@YAXPAXH@Z PROC				; CBEOSB_19L

; 510  : void CBEOSB_19L(void *, int) {

	push	ebp
	mov	ebp, esp

; 511  : 
; 512  : 	SimCBEOSB_19L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_19L@@YAXKHPAX@Z		; SimCBEOSB_19L
	add	esp, 12					; 0000000cH

; 513  : }

	pop	ebp
	ret	0
?CBEOSB_19L@@YAXPAXH@Z ENDP				; CBEOSB_19L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_18L@@YAXPAXH@Z PROC				; CBEOSB_18L

; 505  : void CBEOSB_18L(void *, int) {

	push	ebp
	mov	ebp, esp

; 506  : 
; 507  : 	SimCBEOSB_18L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_18L@@YAXKHPAX@Z		; SimCBEOSB_18L
	add	esp, 12					; 0000000cH

; 508  : }

	pop	ebp
	ret	0
?CBEOSB_18L@@YAXPAXH@Z ENDP				; CBEOSB_18L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_17L@@YAXPAXH@Z PROC				; CBEOSB_17L

; 500  : void CBEOSB_17L(void *, int) {

	push	ebp
	mov	ebp, esp

; 501  : 
; 502  : 	SimCBEOSB_17L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_17L@@YAXKHPAX@Z		; SimCBEOSB_17L
	add	esp, 12					; 0000000cH

; 503  : }

	pop	ebp
	ret	0
?CBEOSB_17L@@YAXPAXH@Z ENDP				; CBEOSB_17L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_16L@@YAXPAXH@Z PROC				; CBEOSB_16L

; 495  : void CBEOSB_16L(void *, int) {

	push	ebp
	mov	ebp, esp

; 496  : 
; 497  : 	SimCBEOSB_16L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_16L@@YAXKHPAX@Z		; SimCBEOSB_16L
	add	esp, 12					; 0000000cH

; 498  : }

	pop	ebp
	ret	0
?CBEOSB_16L@@YAXPAXH@Z ENDP				; CBEOSB_16L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_15L@@YAXPAXH@Z PROC				; CBEOSB_15L

; 490  : void CBEOSB_15L(void *, int) {

	push	ebp
	mov	ebp, esp

; 491  : 
; 492  : 	SimCBEOSB_15L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_15L@@YAXKHPAX@Z		; SimCBEOSB_15L
	add	esp, 12					; 0000000cH

; 493  : }

	pop	ebp
	ret	0
?CBEOSB_15L@@YAXPAXH@Z ENDP				; CBEOSB_15L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_14L@@YAXPAXH@Z PROC				; CBEOSB_14L

; 485  : void CBEOSB_14L(void *, int) {

	push	ebp
	mov	ebp, esp

; 486  : 
; 487  : 	SimCBEOSB_14L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_14L@@YAXKHPAX@Z		; SimCBEOSB_14L
	add	esp, 12					; 0000000cH

; 488  : }

	pop	ebp
	ret	0
?CBEOSB_14L@@YAXPAXH@Z ENDP				; CBEOSB_14L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_13L@@YAXPAXH@Z PROC				; CBEOSB_13L

; 480  : void CBEOSB_13L(void *, int) {

	push	ebp
	mov	ebp, esp

; 481  : 
; 482  : 	SimCBEOSB_13L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_13L@@YAXKHPAX@Z		; SimCBEOSB_13L
	add	esp, 12					; 0000000cH

; 483  : }

	pop	ebp
	ret	0
?CBEOSB_13L@@YAXPAXH@Z ENDP				; CBEOSB_13L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_12L@@YAXPAXH@Z PROC				; CBEOSB_12L

; 475  : void CBEOSB_12L(void *, int) {

	push	ebp
	mov	ebp, esp

; 476  : 
; 477  : 	SimCBEOSB_12L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_12L@@YAXKHPAX@Z		; SimCBEOSB_12L
	add	esp, 12					; 0000000cH

; 478  : }

	pop	ebp
	ret	0
?CBEOSB_12L@@YAXPAXH@Z ENDP				; CBEOSB_12L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_11L@@YAXPAXH@Z PROC				; CBEOSB_11L

; 470  : void CBEOSB_11L(void *, int) {

	push	ebp
	mov	ebp, esp

; 471  : 
; 472  : 	SimCBEOSB_11L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_11L@@YAXKHPAX@Z		; SimCBEOSB_11L
	add	esp, 12					; 0000000cH

; 473  : }

	pop	ebp
	ret	0
?CBEOSB_11L@@YAXPAXH@Z ENDP				; CBEOSB_11L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_10L@@YAXPAXH@Z PROC				; CBEOSB_10L

; 465  : void CBEOSB_10L(void *, int) {

	push	ebp
	mov	ebp, esp

; 466  : 
; 467  : 	SimCBEOSB_10L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_10L@@YAXKHPAX@Z		; SimCBEOSB_10L
	add	esp, 12					; 0000000cH

; 468  : }

	pop	ebp
	ret	0
?CBEOSB_10L@@YAXPAXH@Z ENDP				; CBEOSB_10L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_9L@@YAXPAXH@Z PROC				; CBEOSB_9L

; 460  : void CBEOSB_9L(void *, int) {

	push	ebp
	mov	ebp, esp

; 461  : 
; 462  : 	SimCBEOSB_9L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_9L@@YAXKHPAX@Z		; SimCBEOSB_9L
	add	esp, 12					; 0000000cH

; 463  : }

	pop	ebp
	ret	0
?CBEOSB_9L@@YAXPAXH@Z ENDP				; CBEOSB_9L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_8L@@YAXPAXH@Z PROC				; CBEOSB_8L

; 455  : void CBEOSB_8L(void *, int) {

	push	ebp
	mov	ebp, esp

; 456  : 
; 457  : 	SimCBEOSB_8L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_8L@@YAXKHPAX@Z		; SimCBEOSB_8L
	add	esp, 12					; 0000000cH

; 458  : }

	pop	ebp
	ret	0
?CBEOSB_8L@@YAXPAXH@Z ENDP				; CBEOSB_8L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_7L@@YAXPAXH@Z PROC				; CBEOSB_7L

; 450  : void CBEOSB_7L(void *, int) {

	push	ebp
	mov	ebp, esp

; 451  : 
; 452  : 	SimCBEOSB_7L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_7L@@YAXKHPAX@Z		; SimCBEOSB_7L
	add	esp, 12					; 0000000cH

; 453  : }

	pop	ebp
	ret	0
?CBEOSB_7L@@YAXPAXH@Z ENDP				; CBEOSB_7L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_6L@@YAXPAXH@Z PROC				; CBEOSB_6L

; 445  : void CBEOSB_6L(void *, int) {

	push	ebp
	mov	ebp, esp

; 446  : 
; 447  : 	SimCBEOSB_6L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_6L@@YAXKHPAX@Z		; SimCBEOSB_6L
	add	esp, 12					; 0000000cH

; 448  : }

	pop	ebp
	ret	0
?CBEOSB_6L@@YAXPAXH@Z ENDP				; CBEOSB_6L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_5L@@YAXPAXH@Z PROC				; CBEOSB_5L

; 440  : void CBEOSB_5L(void *, int) {

	push	ebp
	mov	ebp, esp

; 441  : 
; 442  : 	SimCBEOSB_5L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_5L@@YAXKHPAX@Z		; SimCBEOSB_5L
	add	esp, 12					; 0000000cH

; 443  : }

	pop	ebp
	ret	0
?CBEOSB_5L@@YAXPAXH@Z ENDP				; CBEOSB_5L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_4L@@YAXPAXH@Z PROC				; CBEOSB_4L

; 435  : void CBEOSB_4L(void *, int) {

	push	ebp
	mov	ebp, esp

; 436  : 
; 437  : 	SimCBEOSB_4L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_4L@@YAXKHPAX@Z		; SimCBEOSB_4L
	add	esp, 12					; 0000000cH

; 438  : }

	pop	ebp
	ret	0
?CBEOSB_4L@@YAXPAXH@Z ENDP				; CBEOSB_4L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_3L@@YAXPAXH@Z PROC				; CBEOSB_3L

; 430  : void CBEOSB_3L(void *, int) {

	push	ebp
	mov	ebp, esp

; 431  : 
; 432  : 	SimCBEOSB_3L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_3L@@YAXKHPAX@Z		; SimCBEOSB_3L
	add	esp, 12					; 0000000cH

; 433  : }

	pop	ebp
	ret	0
?CBEOSB_3L@@YAXPAXH@Z ENDP				; CBEOSB_3L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_2L@@YAXPAXH@Z PROC				; CBEOSB_2L

; 425  : void CBEOSB_2L(void *, int) {

	push	ebp
	mov	ebp, esp

; 426  : 
; 427  : 	SimCBEOSB_2L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_2L@@YAXKHPAX@Z		; SimCBEOSB_2L
	add	esp, 12					; 0000000cH

; 428  : }

	pop	ebp
	ret	0
?CBEOSB_2L@@YAXPAXH@Z ENDP				; CBEOSB_2L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEOSB_1L@@YAXPAXH@Z PROC				; CBEOSB_1L

; 420  : void CBEOSB_1L(void *, int) {

	push	ebp
	mov	ebp, esp

; 421  : 
; 422  : 	SimCBEOSB_1L(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimCBEOSB_1L@@YAXKHPAX@Z		; SimCBEOSB_1L
	add	esp, 12					; 0000000cH

; 423  : }

	pop	ebp
	ret	0
?CBEOSB_1L@@YAXPAXH@Z ENDP				; CBEOSB_1L
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExMFDButton@@YAXPAXH@Z PROC				; CBExMFDButton

; 413  : void CBExMFDButton(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 414  : 	
; 415  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 416  : 	//pCPButton->SetCurrentState(1);
; 417  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExMFDBut
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExMFDBut
$LN3@CBExMFDBut:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExMFDBut:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 418  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMFDButton@@YAXPAXH@Z ENDP				; CBExMFDButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExHUDColor@@YAXPAXH@Z PROC				; CBExHUDColor

; 408  : void CBExHUDColor (void* pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 409  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 410  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExHUDCol
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExHUDCol
$LN3@CBExHUDCol:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExHUDCol:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 411  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHUDColor@@YAXPAXH@Z ENDP				; CBExHUDColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHornSilencer@@YAXPAXH@Z PROC			; CBEHornSilencer

; 403  : void CBEHornSilencer(void *, int) {

	push	ebp
	mov	ebp, esp

; 404  : 
; 405  : 	SimSilenceHorn(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimSilenceHorn@@YAXKHPAX@Z		; SimSilenceHorn
	add	esp, 12					; 0000000cH

; 406  : }

	pop	ebp
	ret	0
?CBEHornSilencer@@YAXPAXH@Z ENDP			; CBEHornSilencer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExHornSilencer@@YAXPAXH@Z PROC			; CBExHornSilencer

; 396  : void CBExHornSilencer(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 397  : 	
; 398  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 399  : 
; 400  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExHornSi
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExHornSi
$LN3@CBExHornSi:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExHornSi:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 401  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHornSilencer@@YAXPAXH@Z ENDP			; CBExHornSilencer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEMPO@@YAXPAXH@Z PROC					; CBEMPO

; 391  : void CBEMPO(void *, int) {

	push	ebp
	mov	ebp, esp

; 392  : 
; 393  : 	SimMPOToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimMPOToggle@@YAXKHPAX@Z		; SimMPOToggle
	add	esp, 12					; 0000000cH

; 394  : }

	pop	ebp
	ret	0
?CBEMPO@@YAXPAXH@Z ENDP					; CBEMPO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExMPO@@YAXPAXH@Z PROC				; CBExMPO

; 376  : void CBExMPO(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 377  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 378  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExMPO

; 379  : 		return;

	jmp	SHORT $LN4@CBExMPO
$LN3@CBExMPO:

; 380  : 	}
; 381  : 
; 382  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 383  : 	if(playerAC->af->IsSet(AirframeClass::MPOverride)){

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@CBExMPO

; 384  : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 385  : 	}
; 386  : 	else {

	jmp	SHORT $LN4@CBExMPO
$LN2@CBExMPO:

; 387  : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExMPO:

; 388  : 	}
; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExMPO@@YAXPAXH@Z ENDP				; CBExMPO
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEModeSelect@@YAXPAXH@Z PROC				; CBEModeSelect

; 363  : void CBEModeSelect(void *, int event) {

	push	ebp
	mov	ebp, esp

; 364  : 	if (event == CP_MOUSE_BUTTON0)

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN2@CBEModeSel

; 365  : 	    SimStepHSIMode(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepHSIMode@@YAXKHPAX@Z		; SimStepHSIMode
	add	esp, 12					; 0000000cH

; 366  : 	else {

	jmp	SHORT $LN3@CBEModeSel
$LN2@CBEModeSel:

; 367  : 	    SimStepHSIMode(0, KEY_DOWN, NULL); // JPO - surely one of the grossest hacks you ever did see

	push	0
	push	8
	push	0
	call	?SimStepHSIMode@@YAXKHPAX@Z		; SimStepHSIMode
	add	esp, 12					; 0000000cH

; 368  : 	    SimStepHSIMode(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepHSIMode@@YAXKHPAX@Z		; SimStepHSIMode
	add	esp, 12					; 0000000cH

; 369  : 	    SimStepHSIMode(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimStepHSIMode@@YAXKHPAX@Z		; SimStepHSIMode
	add	esp, 12					; 0000000cH
$LN3@CBEModeSel:

; 370  : 	}
; 371  : }

	pop	ebp
	ret	0
?CBEModeSelect@@YAXPAXH@Z ENDP				; CBEModeSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv66 = -8						; size = 4
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExModeSelect@@YAXPAXH@Z PROC				; CBExModeSelect

; 336  : void CBExModeSelect(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 337  : 
; 338  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 339  : 	
; 340  : 	switch (gNavigationSys->GetInstrumentMode()) {

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 3
	ja	SHORT $LN1@CBExModeSe
	mov	ecx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN10@CBExModeSe[ecx*4]
$LN5@CBExModeSe:

; 341  : 	case NavigationSystem::NAV:
; 342  : 	    pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 343  : 	break;

	jmp	SHORT $LN8@CBExModeSe
$LN4@CBExModeSe:

; 344  : 
; 345  : 	case NavigationSystem::ILS_NAV:
; 346  : 	    pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 347  : 	break;

	jmp	SHORT $LN8@CBExModeSe
$LN3@CBExModeSe:

; 348  : 
; 349  : 	case NavigationSystem::ILS_TACAN:
; 350  : 	    pCPButton->SetCurrentState(2);

	push	2
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 351  : 	break;

	jmp	SHORT $LN8@CBExModeSe
$LN2@CBExModeSe:

; 352  : 
; 353  : 	case NavigationSystem::TACAN:
; 354  : 	    pCPButton->SetCurrentState(3);

	push	3
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 355  : 	break;

	jmp	SHORT $LN8@CBExModeSe
$LN1@CBExModeSe:

; 356  : 
; 357  : 	default:
; 358  : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN8@CBExModeSe:

; 359  : 	break;
; 360  : 	}
; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@CBExModeSe:
	DD	$LN5@CBExModeSe
	DD	$LN4@CBExModeSe
	DD	$LN3@CBExModeSe
	DD	$LN2@CBExModeSe
?CBExModeSelect@@YAXPAXH@Z ENDP				; CBExModeSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAVTRControl@@YAXPAXH@Z PROC			; CBExAVTRControl

; 323  : void CBExAVTRControl(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 324  : 
; 325  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 326  : 
; 327  : 	if(SimDriver.AVTROn() == TRUE) {

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	cmp	eax, 1
	jne	SHORT $LN2@CBExAVTRCo

; 328  : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 329  : 	}
; 330  : 	else {

	jmp	SHORT $LN3@CBExAVTRCo
$LN2@CBExAVTRCo:

; 331  : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN3@CBExAVTRCo:

; 332  : 	}
; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAVTRControl@@YAXPAXH@Z ENDP			; CBExAVTRControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAVTRControl@@YAXPAXH@Z PROC				; CBEAVTRControl

; 318  : void CBEAVTRControl(void *, int) {

	push	ebp
	mov	ebp, esp

; 319  : 
; 320  : 	SimAVTRToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimAVTRToggle@@YAXKHPAX@Z		; SimAVTRToggle
	add	esp, 12					; 0000000cH

; 321  : }

	pop	ebp
	ret	0
?CBEAVTRControl@@YAXPAXH@Z ENDP				; CBEAVTRControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExStoresJettison@@YAXPAXH@Z PROC			; CBExStoresJettison

; 299  : void CBExStoresJettison(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 300  : 
; 301  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 302  : //	pCPButton->SetCurrentState(1);
; 303  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 304  : 	if (playerAC == NULL || playerAC->Sms == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN3@CBExStores
	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+940], 0
	jne	SHORT $LN4@CBExStores
$LN3@CBExStores:

; 305  : 		return;

	jmp	SHORT $LN5@CBExStores
$LN4@CBExStores:

; 306  : 	}
; 307  : 
; 308  : 	if (playerAC->Sms->DidEmergencyJettison()){

	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	call	?DidEmergencyJettison@SMSClass@@QAEHXZ	; SMSClass::DidEmergencyJettison
	test	eax, eax
	je	SHORT $LN2@CBExStores

; 309  : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 310  : 	}
; 311  : 	else {

	jmp	SHORT $LN5@CBExStores
$LN2@CBExStores:

; 312  : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExStores:

; 313  : 	}
; 314  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExStoresJettison@@YAXPAXH@Z ENDP			; CBExStoresJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEStoresJettison@@YAXPAXH@Z PROC			; CBEStoresJettison

; 286  : void CBEStoresJettison(void *, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 287  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 288  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN2@CBEStoresJ

; 289  : 		return;

	jmp	SHORT $LN3@CBEStoresJ
$LN2@CBEStoresJ:

; 290  : 	}
; 291  : 	
; 292  : 	SimEmergencyJettison(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimEmergencyJettison@@YAXKHPAX@Z	; SimEmergencyJettison
	add	esp, 12					; 0000000cH

; 293  : 	if(playerAC->Sms != NULL && playerAC->Sms->DidEmergencyJettison()){

	mov	eax, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@CBEStoresJ
	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [ecx+940]
	call	?DidEmergencyJettison@SMSClass@@QAEHXZ	; SMSClass::DidEmergencyJettison
	test	eax, eax
	je	SHORT $LN3@CBEStoresJ

; 294  : 		SimEmergencyJettison(0, 0, NULL);

	push	0
	push	0
	push	0
	call	?SimEmergencyJettison@@YAXKHPAX@Z	; SimEmergencyJettison
	add	esp, 12					; 0000000cH
$LN3@CBEStoresJ:

; 295  : 	}
; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEStoresJettison@@YAXPAXH@Z ENDP			; CBEStoresJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExFlareDispense@@YAXPAXH@Z PROC			; CBExFlareDispense

; 280  : void CBExFlareDispense(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 281  : 
; 282  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 283  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExFlareD
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExFlareD
$LN3@CBExFlareD:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExFlareD:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExFlareDispense@@YAXPAXH@Z ENDP			; CBExFlareDispense
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEFlareDispense@@YAXPAXH@Z PROC			; CBEFlareDispense

; 275  : void CBEFlareDispense(void *, int) {

	push	ebp
	mov	ebp, esp

; 276  : 
; 277  : 	SimDropFlare (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDropFlare@@YAXKHPAX@Z		; SimDropFlare
	add	esp, 12					; 0000000cH

; 278  : }

	pop	ebp
	ret	0
?CBEFlareDispense@@YAXPAXH@Z ENDP			; CBEFlareDispense
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
tv66 = -4						; size = 4
_pButton$ = 8						; size = 4
_event$ = 12						; size = 4
?CBExChaffDispense@@YAXPAXH@Z PROC			; CBExChaffDispense

; 269  : void CBExChaffDispense(void * pButton, int event) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 270  : 
; 271  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 272  : 	pCPButton->SetCurrentState(event == CP_CHECK_EVENT ? 0 : 1); // JPO

	cmp	DWORD PTR _event$[ebp], -1
	jne	SHORT $LN3@CBExChaffD
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN4@CBExChaffD
$LN3@CBExChaffD:
	mov	DWORD PTR tv66[ebp], 1
$LN4@CBExChaffD:
	mov	ecx, DWORD PTR tv66[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 273  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExChaffDispense@@YAXPAXH@Z ENDP			; CBExChaffDispense
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEChaffDispense@@YAXPAXH@Z PROC			; CBEChaffDispense

; 264  : void CBEChaffDispense(void *, int) {

	push	ebp
	mov	ebp, esp

; 265  : 
; 266  : 	SimDropChaff (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimDropChaff@@YAXKHPAX@Z		; SimDropChaff
	add	esp, 12					; 0000000cH

; 267  : }

	pop	ebp
	ret	0
?CBEChaffDispense@@YAXPAXH@Z ENDP			; CBEChaffDispense
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExHeadingSelect@@YAXPAXH@Z PROC			; CBExHeadingSelect

; 256  : void CBExHeadingSelect(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 257  : 
; 258  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 259  : 
; 260  : 	pCPButton->SetCurrentState(OTWDriver.pCockpitManager->mpHsi->GetState(CPHsi::HSI_STA_HDG_STATE));

	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?GetState@CPHsi@@QAEHW4HSIButtonStates@1@@Z ; CPHsi::GetState
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExHeadingSelect@@YAXPAXH@Z ENDP			; CBExHeadingSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBEHeadingSelect@@YAXPAXH@Z PROC			; CBEHeadingSelect

; 246  : void CBEHeadingSelect(void *, int event) {

	push	ebp
	mov	ebp, esp

; 247  : 
; 248  : 	if(event == CP_MOUSE_BUTTON0) {

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBEHeading

; 249  : 		SimHsiHeadingInc (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHsiHeadingInc@@YAXKHPAX@Z		; SimHsiHeadingInc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@CBEHeading
$LN3@CBEHeading:

; 250  : 	}
; 251  : 	else if(event == CP_MOUSE_BUTTON1) {		

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN4@CBEHeading

; 252  : 		SimHsiHeadingDec (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHsiHeadingDec@@YAXKHPAX@Z		; SimHsiHeadingDec
	add	esp, 12					; 0000000cH
$LN4@CBEHeading:

; 253  : 	}
; 254  : }

	pop	ebp
	ret	0
?CBEHeadingSelect@@YAXPAXH@Z ENDP			; CBEHeadingSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -4					; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExCourseSelect@@YAXPAXH@Z PROC			; CBExCourseSelect

; 240  : void CBExCourseSelect(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 241  : 
; 242  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 243  : 	pCPButton->SetCurrentState(OTWDriver.pCockpitManager->mpHsi->GetState(CPHsi::HSI_STA_CRS_STATE));

	push	0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+692]
	call	?GetState@CPHsi@@QAEHW4HSIButtonStates@1@@Z ; CPHsi::GetState
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExCourseSelect@@YAXPAXH@Z ENDP			; CBExCourseSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_event$ = 12						; size = 4
?CBECourseSelect@@YAXPAXH@Z PROC			; CBECourseSelect

; 230  : void CBECourseSelect(void *, int event) {

	push	ebp
	mov	ebp, esp

; 231  : 
; 232  : 	if(event == CP_MOUSE_BUTTON0) {

	cmp	DWORD PTR _event$[ebp], 3
	jne	SHORT $LN3@CBECourseS

; 233  : 		SimHsiCourseInc (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHsiCourseInc@@YAXKHPAX@Z		; SimHsiCourseInc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@CBECourseS
$LN3@CBECourseS:

; 234  : 	}
; 235  : 	else if(event == CP_MOUSE_BUTTON1) {		

	cmp	DWORD PTR _event$[ebp], 4
	jne	SHORT $LN4@CBECourseS

; 236  : 		SimHsiCourseDec (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimHsiCourseDec@@YAXKHPAX@Z		; SimHsiCourseDec
	add	esp, 12					; 0000000cH
$LN4@CBECourseS:

; 237  : 	}
; 238  : }

	pop	ebp
	ret	0
?CBECourseSelect@@YAXPAXH@Z ENDP			; CBECourseSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -8					; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAutoPilot@@YAXPAXH@Z PROC				; CBExAutoPilot

; 213  : void CBExAutoPilot(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 214  : 
; 215  : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 216  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 217  : 
; 218  : 	if ( (playerAC == NULL) || !playerAC->IsSetFlag(MOTION_OWNSHIP) ){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN3@CBExAutoPi
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN4@CBExAutoPi
$LN3@CBExAutoPi:

; 219  : 		return;

	jmp	SHORT $LN5@CBExAutoPi
$LN4@CBExAutoPi:

; 220  : 	}
; 221  : 
; 222  : 	if (playerAC->autopilotType == AircraftClass::APOff) {

	mov	ecx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [ecx+968], 4
	jne	SHORT $LN2@CBExAutoPi

; 223  : 		pCPButton->SetCurrentState(0);

	push	0
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState

; 224  : 	}
; 225  : 	else {

	jmp	SHORT $LN5@CBExAutoPi
$LN2@CBExAutoPi:

; 226  : 		pCPButton->SetCurrentState(1);

	push	1
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN5@CBExAutoPi:

; 227  : 	}
; 228  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAutoPilot@@YAXPAXH@Z ENDP				; CBExAutoPilot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAutoPilot@@YAXPAXH@Z PROC				; CBEAutoPilot

; 208  : void CBEAutoPilot(void *, int) {

	push	ebp
	mov	ebp, esp

; 209  : 	
; 210  : 	SimToggleAutopilot(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleAutopilot@@YAXKHPAX@Z		; SimToggleAutopilot
	add	esp, 12					; 0000000cH

; 211  : }

	pop	ebp
	ret	0
?CBEAutoPilot@@YAXPAXH@Z ENDP				; CBEAutoPilot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEMasterCaution@@YAXPAXH@Z PROC			; CBEMasterCaution

; 203  : void CBEMasterCaution(void *, int) {

	push	ebp
	mov	ebp, esp

; 204  : 
; 205  : 	ExtinguishMasterCaution(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?ExtinguishMasterCaution@@YAXKHPAX@Z	; ExtinguishMasterCaution
	add	esp, 12					; 0000000cH

; 206  : }

	pop	ebp
	ret	0
?CBEMasterCaution@@YAXPAXH@Z ENDP			; CBEMasterCaution
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBELandGearSelect@@YAXPAXH@Z PROC			; CBELandGearSelect

; 198  : void CBELandGearSelect(void *, int) {

	push	ebp
	mov	ebp, esp

; 199  : 
; 200  : 	AFGearToggle(0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?AFGearToggle@@YAXKHPAX@Z		; AFGearToggle
	add	esp, 12					; 0000000cH

; 201  : }

	pop	ebp
	ret	0
?CBELandGearSelect@@YAXPAXH@Z ENDP			; CBELandGearSelect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
tv135 = -12						; size = 4
_playerAC$ = -8						; size = 4
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAuxWarnPwrB@@YAXPAXH@Z PROC				; CBEAuxWarnPwrB

; 181  : void CBEAuxWarnPwrB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 182  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 183  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEAuxWarn

; 184  : 		return;

	jmp	SHORT $LN4@CBEAuxWarn
$LN3@CBEAuxWarn:

; 185  : 	}
; 186  : 
; 187  : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBEAuxWarn

; 188  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 189  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBEAuxWarn

; 190  : 			theRwr->SetPower(!theRwr->IsOn());

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	test	eax, eax
	jne	SHORT $LN6@CBEAuxWarn
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN7@CBEAuxWarn
$LN6@CBEAuxWarn:
	mov	DWORD PTR tv135[ebp], 0
$LN7@CBEAuxWarn:
	mov	ecx, DWORD PTR tv135[ebp]
	push	ecx
	mov	edx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
$LN4@CBEAuxWarn:

; 191  : 		}
; 192  : 	}
; 193  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEAuxWarnPwrB@@YAXPAXH@Z ENDP				; CBEAuxWarnPwrB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAuxWarnAltB@@YAXPAXH@Z PROC				; CBEAuxWarnAltB

; 167  : void CBEAuxWarnAltB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 168  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 169  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEAuxWarn

; 170  : 		return;

	jmp	SHORT $LN4@CBEAuxWarn
$LN3@CBEAuxWarn:

; 171  : 	}
; 172  : 
; 173  : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBEAuxWarn

; 174  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 175  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBEAuxWarn

; 176  : 			theRwr->ToggleLowAltPriority();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
$LN4@CBEAuxWarn:

; 177  : 		}
; 178  : 	}
; 179  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEAuxWarnAltB@@YAXPAXH@Z ENDP				; CBEAuxWarnAltB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAuxWarnSearchB@@YAXPAXH@Z PROC			; CBEAuxWarnSearchB

; 153  : void CBEAuxWarnSearchB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 154  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 155  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEAuxWarn

; 156  : 		return;

	jmp	SHORT $LN4@CBEAuxWarn
$LN3@CBEAuxWarn:

; 157  : 	}
; 158  : 
; 159  : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBEAuxWarn

; 160  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 161  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBEAuxWarn

; 162  : 			theRwr->ToggleSearch();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax
$LN4@CBEAuxWarn:

; 163  : 		}
; 164  : 	}
; 165  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEAuxWarnSearchB@@YAXPAXH@Z ENDP			; CBEAuxWarnSearchB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBETgtSepB@@YAXPAXH@Z PROC				; CBETgtSepB

; 138  : void CBETgtSepB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 139  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 140  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBETgtSepB

; 141  : 		return;

	jmp	SHORT $LN4@CBETgtSepB
$LN3@CBETgtSepB:

; 142  : 	}
; 143  : 
; 144  : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBETgtSepB

; 145  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 146  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBETgtSepB

; 147  : 			theRwr->ToggleTargetSep();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN4@CBETgtSepB:

; 148  : 		}
; 149  : 	}
; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBETgtSepB@@YAXPAXH@Z ENDP				; CBETgtSepB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBENavalB@@YAXPAXH@Z PROC				; CBENavalB

; 124  : void CBENavalB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 125  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 126  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBENavalB

; 127  : 		return;

	jmp	SHORT $LN4@CBENavalB
$LN3@CBENavalB:

; 128  : 	}
; 129  : 
; 130  : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBENavalB

; 131  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 132  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBENavalB

; 133  : 			theRwr->ToggleNaval();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN4@CBENavalB:

; 134  : 		}
; 135  : 	}
; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBENavalB@@YAXPAXH@Z ENDP				; CBENavalB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEUnknownB@@YAXPAXH@Z PROC				; CBEUnknownB

; 110  : void CBEUnknownB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 111  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 112  : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEUnknown

; 113  : 		return;

	jmp	SHORT $LN4@CBEUnknown
$LN3@CBEUnknown:

; 114  : 	}
; 115  : 
; 116  : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBEUnknown

; 117  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 118  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBEUnknown

; 119  : 			theRwr->ToggleUnknowns();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+96]
	call	eax
$LN4@CBEUnknown:

; 120  : 		}
; 121  : 	}
; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEUnknownB@@YAXPAXH@Z ENDP				; CBEUnknownB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEPriModeB@@YAXPAXH@Z PROC				; CBEPriModeB

; 95   : void CBEPriModeB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 96   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 97   : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEPriMode

; 98   : 		return;

	jmp	SHORT $LN4@CBEPriMode
$LN3@CBEPriMode:

; 99   : 	}
; 100  : 
; 101  : 	if (playerAC->IsSetFlag(MOTION_OWNSHIP)) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBEPriMode

; 102  : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 103  : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBEPriMode

; 104  : 			theRwr->TogglePriority();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
$LN4@CBEPriMode:

; 105  : 		}
; 106  : 	}
; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEPriModeB@@YAXPAXH@Z ENDP				; CBEPriModeB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_playerAC$ = -8						; size = 4
_theRwr$1 = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEHandoffB@@YAXPAXH@Z PROC				; CBEHandoffB

; 71   : void CBEHandoffB(void *, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 72   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 73   : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBEHandoff

; 74   : 		return;

	jmp	SHORT $LN4@CBEHandoff
$LN3@CBEHandoff:

; 75   : 	}
; 76   : 
; 77   : 	if ((playerAC->IsSetFlag(MOTION_OWNSHIP))) {

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBEHandoff

; 78   : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 79   : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBEHandoff

; 80   : 			theRwr->SelectNextEmitter();

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax

; 81   : 
; 82   : // JB 010727 RP5 RWR
; 83   : // 2001-02-15 ADDED BY S.G. SO WE HEAR THE SOUND ***RIGHT AWAY*** 
; 84   : //            I WON'T PASS A targetList (although I could) SO NOT ALL OF THE ROUTINE IS DONE
; 85   : //            IN 1.08i2, DoAudio PROCESSES THE WHOLE CONTACT LIST BY ITSELF AND 
; 86   : //            NOT JUST THE PASSED CONTACT. SINCE 1.07 DOESN'T I'M STUCK AT DOING THIS :-(
; 87   : //            THIS WON'T BE FPS INTENSIVE ANYWAY SINCE IT ONLY RUNS WHEN THE HANDOFF BUTTON IS PRESSED
; 88   : //            LATER ON, I MIGHT MAKE THIS CODE 1.08i2 'COMPATIBLE'
; 89   : 			theRwr->Exec(NULL);

	push	0
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$1[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
$LN4@CBEHandoff:

; 90   : 		}
; 91   : 	}
; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEHandoffB@@YAXPAXH@Z ENDP				; CBEHandoffB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_pCPButton$ = -12					; size = 4
_theRwr$1 = -8						; size = 4
_playerAC$ = -4						; size = 4
_pButton$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBExAMChaffFlare@@YAXPAXH@Z PROC			; CBExAMChaffFlare

; 53   : void CBExAMChaffFlare(void * pButton, int) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 54   : 
; 55   : 	CPButtonObject *pCPButton	= (CPButtonObject*) pButton;

	mov	eax, DWORD PTR _pButton$[ebp]
	mov	DWORD PTR _pCPButton$[ebp], eax

; 56   : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 57   : 	if (playerAC == NULL){

	cmp	DWORD PTR _playerAC$[ebp], 0
	jne	SHORT $LN3@CBExAMChaf

; 58   : 		return;

	jmp	SHORT $LN4@CBExAMChaf
$LN3@CBExAMChaf:

; 59   : 	}
; 60   : 
; 61   : 	if (playerAC->IsSetFlag(MOTION_OWNSHIP)){

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN4@CBExAMChaf

; 62   : 		PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(playerAC, SensorClass::RWR);

	push	2
	mov	ecx, DWORD PTR _playerAC$[ebp]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$1[ebp], eax

; 63   : 		if(theRwr) {

	cmp	DWORD PTR _theRwr$1[ebp], 0
	je	SHORT $LN4@CBExAMChaf

; 64   : 			pCPButton->SetCurrentState(theRwr->AutoDrop());

	mov	ecx, DWORD PTR _theRwr$1[ebp]
	call	?AutoDrop@VehRwrClass@@QAEHXZ		; VehRwrClass::AutoDrop
	push	eax
	mov	ecx, DWORD PTR _pCPButton$[ebp]
	call	?SetCurrentState@CPButtonObject@@QAEXH@Z ; CPButtonObject::SetCurrentState
$LN4@CBExAMChaf:

; 65   : 		}
; 66   : 	}
; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBExAMChaffFlare@@YAXPAXH@Z ENDP			; CBExAMChaffFlare
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEAMChaffFlare@@YAXPAXH@Z PROC			; CBEAMChaffFlare

; 48   : void CBEAMChaffFlare(void *, int) {

	push	ebp
	mov	ebp, esp

; 49   : 	SimToggleDropPattern (0, KEY_DOWN, NULL);

	push	0
	push	8
	push	0
	call	?SimToggleDropPattern@@YAXKHPAX@Z	; SimToggleDropPattern
	add	esp, 12					; 0000000cH

; 50   : }

	pop	ebp
	ret	0
?CBEAMChaffFlare@@YAXPAXH@Z ENDP			; CBEAMChaffFlare
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_board$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEKneeboardStpt@@YAXPAXH@Z PROC			; CBEKneeboardStpt

; 42   : void CBEKneeboardStpt(void *, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 	KneeBoard *board = OTWDriver.pCockpitManager->mpKneeBoard;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+700]
	mov	DWORD PTR _board$[ebp], ecx

; 44   : 	board->SetPage( KneeBoard::STEERPOINT );

	push	2
	mov	ecx, DWORD PTR _board$[ebp]
	call	?SetPage@KneeBoard@@QAEXW4Page@1@@Z	; KneeBoard::SetPage

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEKneeboardStpt@@YAXPAXH@Z ENDP			; CBEKneeboardStpt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_board$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEKneeboardBrief@@YAXPAXH@Z PROC			; CBEKneeboardBrief

; 37   : void CBEKneeboardBrief(void *, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 38   : 	KneeBoard *board = OTWDriver.pCockpitManager->mpKneeBoard;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+700]
	mov	DWORD PTR _board$[ebp], ecx

; 39   : 	board->SetPage( KneeBoard::BRIEF );

	push	0
	mov	ecx, DWORD PTR _board$[ebp]
	call	?SetPage@KneeBoard@@QAEXW4Page@1@@Z	; KneeBoard::SetPage

; 40   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEKneeboardBrief@@YAXPAXH@Z ENDP			; CBEKneeboardBrief
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\cockpit\cbbuttons.cpp
_TEXT	SEGMENT
_board$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?CBEKneeboardMap@@YAXPAXH@Z PROC			; CBEKneeboardMap

; 32   : void CBEKneeboardMap(void *, int) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 33   : 	KneeBoard *board = OTWDriver.pCockpitManager->mpKneeBoard;

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+700]
	mov	DWORD PTR _board$[ebp], ecx

; 34   : 	board->SetPage( KneeBoard::MAP );

	push	1
	mov	ecx, DWORD PTR _board$[ebp]
	call	?SetPage@KneeBoard@@QAEXW4Page@1@@Z	; KneeBoard::SetPage

; 35   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CBEKneeboardMap@@YAXPAXH@Z ENDP			; CBEKneeboardMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\kneeboard.h
;	COMDAT ?SetPage@KneeBoard@@QAEXW4Page@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?SetPage@KneeBoard@@QAEXW4Page@1@@Z PROC		; KneeBoard::SetPage, COMDAT
; _this$ = ecx

; 30   : 	void SetPage( Page p )	{ page = p; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPage@KneeBoard@@QAEXW4Page@1@@Z ENDP		; KneeBoard::SetPage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\cpmanager.h
;	COMDAT ?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ PROC	; CockpitManager::GetActivePanel, COMDAT
; _this$ = ecx

; 576  : 	CPPanel*	GetActivePanel()	{return mpActivePanel;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+172]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetActivePanel@CockpitManager@@QAEPAVCPPanel@@XZ ENDP	; CockpitManager::GetActivePanel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\vehrwr.h
;	COMDAT ?AutoDrop@VehRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutoDrop@VehRwrClass@@QAEHXZ PROC			; VehRwrClass::AutoDrop, COMDAT
; _this$ = ecx

; 27   : 	int  AutoDrop (void)		{return dropPattern;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+596]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutoDrop@VehRwrClass@@QAEHXZ ENDP			; VehRwrClass::AutoDrop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::ClearFlag, COMDAT
; _this$ = ecx

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::SetFlag, COMDAT
; _this$ = ecx

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ PROC	; AirframeClass::GetAirSource, COMDAT
; _this$ = ecx

; 1112 : 	AirSource GetAirSource() { return airSource; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1800]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ENDP	; AirframeClass::GetAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ PROC	; AirframeClass::GetFuelPump, COMDAT
; _this$ = ecx

; 1091 : 	FuelPump GetFuelPump() { return fuelPump; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1684]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ENDP	; AirframeClass::GetFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ PROC ; AirframeClass::GetFuelSwitch, COMDAT
; _this$ = ecx

; 1082 : 	FuelSwitch GetFuelSwitch() { return fuelSwitch; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1680]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ENDP ; AirframeClass::GetFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::ToggleEngineFlag, COMDAT
; _this$ = ecx

; 1073 : 	void ToggleEngineFlag(EngineFlags ef) { engineFlags ^= ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	xor	ecx, DWORD PTR _ef$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::ToggleEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_ef$ = 8						; size = 4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z PROC ; AirframeClass::IsEngineFlag, COMDAT
; _this$ = ecx

; 1070 : 	int IsEngineFlag(EngineFlags ef) { return (engineFlags & ef) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	and	ecx, DWORD PTR _ef$[ebp]
	je	SHORT $LN3@IsEngineFl
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEngineFl
$LN3@IsEngineFl:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEngineFl:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ENDP ; AirframeClass::IsEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ PROC	; AirframeClass::GetEpuSwitch, COMDAT
; _this$ = ecx

; 1021 : 	EpuState GetEpuSwitch () { return epuState; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1596]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ENDP	; AirframeClass::GetEpuSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?AVTROn@SimulationDriver@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AVTROn@SimulationDriver@@QAEHXZ PROC			; SimulationDriver::AVTROn, COMDAT
; _this$ = ecx

; 100  : 	int AVTROn (void) {return avtrOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]
	mov	esp, ebp
	pop	ebp
	ret	0
?AVTROn@SimulationDriver@@QAEHXZ ENDP			; SimulationDriver::AVTROn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ PROC	; AircraftClass::EWSPGM, COMDAT
; _this$ = ecx

; 543  : 	EWSPGMSwitch EWSPGM() { return EWSPgm; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1496]
	mov	esp, ebp
	pop	ebp
	ret	0
?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ENDP	; AircraftClass::EWSPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ PROC ; AircraftClass::MainPower, COMDAT
; _this$ = ecx

; 519  : 	MainPowerType MainPower() { return mainPower; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1484]
	mov	esp, ebp
	pop	ebp
	ret	0
?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ENDP ; AircraftClass::MainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z PROC ; AircraftClass::PowerSwitchOn, COMDAT
; _this$ = ecx

; 513  : 	int PowerSwitchOn(AvionicsPowerFlags fl) { return (powerFlags & fl) ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1480]
	and	ecx, DWORD PTR _fl$[ebp]
	je	SHORT $LN3@PowerSwitc
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@PowerSwitc
$LN3@PowerSwitc:
	mov	DWORD PTR tv67[ebp], 0
$LN4@PowerSwitc:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ENDP ; AircraftClass::PowerSwitchOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_flag$ = 8						; size = 4
?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z PROC		; AircraftClass::IsOn, COMDAT
; _this$ = ecx

; 438  : 	int IsOn (APFlags flag) {return APFlag & flag ? 1 : 0;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1048]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsOn
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsOn
$LN3@IsOn:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsOn:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z ENDP		; AircraftClass::IsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z PROC ; AircraftClass::AVTRState, COMDAT
; _this$ = ecx

; 251  : 	int AVTRState(AVTRStateFlags fl) { return (AVTRFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@AVTRState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@AVTRState
$LN3@AVTRState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@AVTRState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ENDP ; AircraftClass::AVTRState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z PROC ; AircraftClass::ExtlState, COMDAT
; _this$ = ecx

; 188  : 	int ExtlState(ExtlLightFlags fl) const { return (IsAcStatusBitsSet(fl) ? 1 : 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExtlState
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@ExtlState
$LN3@ExtlState:
	mov	DWORD PTR tv69[ebp], 0
$LN4@ExtlState:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ENDP ; AircraftClass::ExtlState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_bits$ = 8						; size = 4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z PROC		; AircraftClass::IsAcStatusBitsSet, COMDAT
; _this$ = ecx

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN3@IsAcStatus
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAcStatus
$LN3@IsAcStatus:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAcStatus:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ENDP		; AircraftClass::IsAcStatusBitsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetSpotLight, COMDAT
; _this$ = ecx

; 113  : 	LightSwitch GetSpotLight() const { return spotLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+752]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetSpotLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetInstrumentLight, COMDAT
; _this$ = ecx

; 112  : 	LightSwitch GetInstrumentLight() const { return instrumentLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+748]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetInstrumentLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetInteriorLight, COMDAT
; _this$ = ecx

; 111  : 	LightSwitch GetInteriorLight() const { return interiorLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+744]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetInteriorLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?DidEmergencyJettison@SMSClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DidEmergencyJettison@SMSClass@@QAEHXZ PROC		; SMSClass::DidEmergencyJettison, COMDAT
; _this$ = ecx

; 222  : 	int  DidEmergencyJettison (void)		{ return flags & EmergencyJettisonFlag; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	and	eax, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
?DidEmergencyJettison@SMSClass@@QAEHXZ ENDP		; SMSClass::DidEmergencyJettison
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newState$ = 8						; size = 4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z PROC ; SMSBaseClass::SetMasterArm, COMDAT
; _this$ = ecx

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newState$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ENDP ; SMSBaseClass::SetMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?GetSwitch@SimMoverClass@@QAEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?GetSwitch@SimMoverClass@@QAEHH@Z PROC			; SimMoverClass::GetSwitch, COMDAT
; _this$ = ecx

; 135  : 	int GetSwitch (int num) { return num < numSwitches ? switchData[num] : 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN3@GetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@GetSwitch
$LN3@GetSwitch:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetSwitch:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSwitch@SimMoverClass@@QAEHH@Z ENDP			; SimMoverClass::GetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Where$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
