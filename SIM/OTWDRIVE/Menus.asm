; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\OTWDRIVE\Menus.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Axis2Text@@3PAU<unnamed-type-Axis2Text>@@A	; Axis2Text
PUBLIC	??_C@_0L@CAGMKAJ@AXIS_PITCH?$AA@		; `string'
PUBLIC	??_C@_09NJFICINK@AXIS_ROLL?$AA@			; `string'
PUBLIC	??_C@_08IFLBGKMD@AXIS_YAW?$AA@			; `string'
PUBLIC	??_C@_0O@EHACCIDN@AXIS_THROTTLE?$AA@		; `string'
PUBLIC	??_C@_0P@LFFPBKEI@AXIS_THROTTLE2?$AA@		; `string'
PUBLIC	??_C@_0BA@PAMODCEE@AXIS_TRIM_PITCH?$AA@		; `string'
PUBLIC	??_C@_0O@HHPOGGKN@AXIS_TRIM_YAW?$AA@		; `string'
PUBLIC	??_C@_0P@HDKACLIJ@AXIS_TRIM_ROLL?$AA@		; `string'
PUBLIC	??_C@_0BA@DJDLMGDK@AXIS_BRAKE_LEFT?$AA@		; `string'
PUBLIC	??_C@_08JOEODBEB@AXIS_FOV?$AA@			; `string'
PUBLIC	??_C@_0O@KBCPKKHK@AXIS_ANT_ELEV?$AA@		; `string'
PUBLIC	??_C@_0O@MPFOGJOF@AXIS_CURSOR_X?$AA@		; `string'
PUBLIC	??_C@_0O@NGEFFIKE@AXIS_CURSOR_Y?$AA@		; `string'
PUBLIC	??_C@_0BA@KFCKDHMN@AXIS_RANGE_KNOB?$AA@		; `string'
PUBLIC	??_C@_0BD@OEDBPPDP@AXIS_COMM_VOLUME_1?$AA@	; `string'
PUBLIC	??_C@_0BD@MPBMKMPM@AXIS_COMM_VOLUME_2?$AA@	; `string'
PUBLIC	??_C@_0BA@BGMKJOOC@AXIS_MSL_VOLUME?$AA@		; `string'
PUBLIC	??_C@_0BD@GNDDADEL@AXIS_THREAT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0BE@EJNNFAEE@AXIS_HUD_BRIGHTNESS?$AA@	; `string'
PUBLIC	??_C@_0O@FHOBAKDN@AXIS_RET_DEPR?$AA@		; `string'
PUBLIC	??_C@_09PCHFOMAD@AXIS_ZOOM?$AA@			; `string'
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?MouseMenuActive@@3_NA				; MouseMenuActive
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?endsAvail@@3PAHA				; endsAvail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?start@@3HA					; start
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
_BSS	SEGMENT
?MouseMenuActive@@3_NA DB 01H DUP (?)			; MouseMenuActive
	ALIGN	4

?endsAvail@@3PAHA DD 03H DUP (?)			; endsAvail
?start@@3HA DD	01H DUP (?)				; start
_exitMenuDesired DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ??_C@_09PCHFOMAD@AXIS_ZOOM?$AA@
CONST	SEGMENT
??_C@_09PCHFOMAD@AXIS_ZOOM?$AA@ DB 'AXIS_ZOOM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHOBAKDN@AXIS_RET_DEPR?$AA@
CONST	SEGMENT
??_C@_0O@FHOBAKDN@AXIS_RET_DEPR?$AA@ DB 'AXIS_RET_DEPR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJNNFAEE@AXIS_HUD_BRIGHTNESS?$AA@
CONST	SEGMENT
??_C@_0BE@EJNNFAEE@AXIS_HUD_BRIGHTNESS?$AA@ DB 'AXIS_HUD_BRIGHTNESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNDDADEL@AXIS_THREAT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BD@GNDDADEL@AXIS_THREAT_VOLUME?$AA@ DB 'AXIS_THREAT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BGMKJOOC@AXIS_MSL_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BA@BGMKJOOC@AXIS_MSL_VOLUME?$AA@ DB 'AXIS_MSL_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MPBMKMPM@AXIS_COMM_VOLUME_2?$AA@
CONST	SEGMENT
??_C@_0BD@MPBMKMPM@AXIS_COMM_VOLUME_2?$AA@ DB 'AXIS_COMM_VOLUME_2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEDBPPDP@AXIS_COMM_VOLUME_1?$AA@
CONST	SEGMENT
??_C@_0BD@OEDBPPDP@AXIS_COMM_VOLUME_1?$AA@ DB 'AXIS_COMM_VOLUME_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KFCKDHMN@AXIS_RANGE_KNOB?$AA@
CONST	SEGMENT
??_C@_0BA@KFCKDHMN@AXIS_RANGE_KNOB?$AA@ DB 'AXIS_RANGE_KNOB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGEFFIKE@AXIS_CURSOR_Y?$AA@
CONST	SEGMENT
??_C@_0O@NGEFFIKE@AXIS_CURSOR_Y?$AA@ DB 'AXIS_CURSOR_Y', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MPFOGJOF@AXIS_CURSOR_X?$AA@
CONST	SEGMENT
??_C@_0O@MPFOGJOF@AXIS_CURSOR_X?$AA@ DB 'AXIS_CURSOR_X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCPKKHK@AXIS_ANT_ELEV?$AA@
CONST	SEGMENT
??_C@_0O@KBCPKKHK@AXIS_ANT_ELEV?$AA@ DB 'AXIS_ANT_ELEV', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOEODBEB@AXIS_FOV?$AA@
CONST	SEGMENT
??_C@_08JOEODBEB@AXIS_FOV?$AA@ DB 'AXIS_FOV', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DJDLMGDK@AXIS_BRAKE_LEFT?$AA@
CONST	SEGMENT
??_C@_0BA@DJDLMGDK@AXIS_BRAKE_LEFT?$AA@ DB 'AXIS_BRAKE_LEFT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDKACLIJ@AXIS_TRIM_ROLL?$AA@
CONST	SEGMENT
??_C@_0P@HDKACLIJ@AXIS_TRIM_ROLL?$AA@ DB 'AXIS_TRIM_ROLL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHPOGGKN@AXIS_TRIM_YAW?$AA@
CONST	SEGMENT
??_C@_0O@HHPOGGKN@AXIS_TRIM_YAW?$AA@ DB 'AXIS_TRIM_YAW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAMODCEE@AXIS_TRIM_PITCH?$AA@
CONST	SEGMENT
??_C@_0BA@PAMODCEE@AXIS_TRIM_PITCH?$AA@ DB 'AXIS_TRIM_PITCH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LFFPBKEI@AXIS_THROTTLE2?$AA@
CONST	SEGMENT
??_C@_0P@LFFPBKEI@AXIS_THROTTLE2?$AA@ DB 'AXIS_THROTTLE2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EHACCIDN@AXIS_THROTTLE?$AA@
CONST	SEGMENT
??_C@_0O@EHACCIDN@AXIS_THROTTLE?$AA@ DB 'AXIS_THROTTLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFLBGKMD@AXIS_YAW?$AA@
CONST	SEGMENT
??_C@_08IFLBGKMD@AXIS_YAW?$AA@ DB 'AXIS_YAW', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NJFICINK@AXIS_ROLL?$AA@
CONST	SEGMENT
??_C@_09NJFICINK@AXIS_ROLL?$AA@ DB 'AXIS_ROLL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CAGMKAJ@AXIS_PITCH?$AA@
CONST	SEGMENT
??_C@_0L@CAGMKAJ@AXIS_PITCH?$AA@ DB 'AXIS_PITCH', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?Axis2Text@@3PAU<unnamed-type-Axis2Text>@@A DD 00H	; Axis2Text
	DD	FLAT:??_C@_0L@CAGMKAJ@AXIS_PITCH?$AA@
	DD	01H
	DD	FLAT:??_C@_09NJFICINK@AXIS_ROLL?$AA@
	DD	02H
	DD	FLAT:??_C@_08IFLBGKMD@AXIS_YAW?$AA@
	DD	03H
	DD	FLAT:??_C@_0O@EHACCIDN@AXIS_THROTTLE?$AA@
	DD	04H
	DD	FLAT:??_C@_0P@LFFPBKEI@AXIS_THROTTLE2?$AA@
	DD	05H
	DD	FLAT:??_C@_0BA@PAMODCEE@AXIS_TRIM_PITCH?$AA@
	DD	06H
	DD	FLAT:??_C@_0O@HHPOGGKN@AXIS_TRIM_YAW?$AA@
	DD	07H
	DD	FLAT:??_C@_0P@HDKACLIJ@AXIS_TRIM_ROLL?$AA@
	DD	08H
	DD	FLAT:??_C@_0BA@DJDLMGDK@AXIS_BRAKE_LEFT?$AA@
	DD	09H
	DD	FLAT:??_C@_08JOEODBEB@AXIS_FOV?$AA@
	DD	0aH
	DD	FLAT:??_C@_0O@KBCPKKHK@AXIS_ANT_ELEV?$AA@
	DD	0bH
	DD	FLAT:??_C@_0O@MPFOGJOF@AXIS_CURSOR_X?$AA@
	DD	0cH
	DD	FLAT:??_C@_0O@NGEFFIKE@AXIS_CURSOR_Y?$AA@
	DD	0dH
	DD	FLAT:??_C@_0BA@KFCKDHMN@AXIS_RANGE_KNOB?$AA@
	DD	0eH
	DD	FLAT:??_C@_0BD@OEDBPPDP@AXIS_COMM_VOLUME_1?$AA@
	DD	0fH
	DD	FLAT:??_C@_0BD@MPBMKMPM@AXIS_COMM_VOLUME_2?$AA@
	DD	010H
	DD	FLAT:??_C@_0BA@BGMKJOOC@AXIS_MSL_VOLUME?$AA@
	DD	011H
	DD	FLAT:??_C@_0BD@GNDDADEL@AXIS_THREAT_VOLUME?$AA@
	DD	012H
	DD	FLAT:??_C@_0BE@EJNNFAEE@AXIS_HUD_BRIGHTNESS?$AA@
	DD	013H
	DD	FLAT:??_C@_0O@FHOBAKDN@AXIS_RET_DEPR?$AA@
	DD	014H
	DD	FLAT:??_C@_09PCHFOMAD@AXIS_ZOOM?$AA@
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?ExitMenu@OTWDriverClass@@QAEXK@Z		; OTWDriverClass::ExitMenu
PUBLIC	?Timeout@OTWDriverClass@@QAEXXZ			; OTWDriverClass::Timeout
PUBLIC	?SetExitMenu@OTWDriverClass@@QAEXH@Z		; OTWDriverClass::SetExitMenu
PUBLIC	?ChangeExitMenu@OTWDriverClass@@QAEXH@Z		; OTWDriverClass::ChangeExitMenu
PUBLIC	?InExitMenu@OTWDriverClass@@QAEHXZ		; OTWDriverClass::InExitMenu
PUBLIC	?StartExitMenuCountdown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::StartExitMenuCountdown
PUBLIC	?CancelExitMenuCountdown@OTWDriverClass@@QAEXXZ	; OTWDriverClass::CancelExitMenuCountdown
PUBLIC	?HandleMouseClick@OTWDriverClass@@QAEHJJ@Z	; OTWDriverClass::HandleMouseClick
PUBLIC	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z	; OTWDriverClass::SetEndFlightPoint
PUBLIC	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z	; OTWDriverClass::SetEndFlightVec
PUBLIC	?GetEyePosition@OTWDriverClass@@QAE?AUTpoint@@XZ ; OTWDriverClass::GetEyePosition
PUBLIC	?ShowVersionString@OTWDriverClass@@AAEXXZ	; OTWDriverClass::ShowVersionString
PUBLIC	?ShowPosition@OTWDriverClass@@AAEXXZ		; OTWDriverClass::ShowPosition
PUBLIC	?ShowAerodynamics@OTWDriverClass@@AAEXXZ	; OTWDriverClass::ShowAerodynamics
PUBLIC	?ShowFlaps@OTWDriverClass@@AAEXXZ		; OTWDriverClass::ShowFlaps
PUBLIC	?ShowEngine@OTWDriverClass@@AAEXXZ		; OTWDriverClass::ShowEngine
PUBLIC	?ShowCatMessage@OTWDriverClass@@AAEXXZ		; OTWDriverClass::ShowCatMessage
PUBLIC	?TakeScreenShot@OTWDriverClass@@AAEXXZ		; OTWDriverClass::TakeScreenShot
PUBLIC	?DrawExitMenu@OTWDriverClass@@AAEXXZ		; OTWDriverClass::DrawExitMenu
PUBLIC	?ShowThrustReverse@OTWDriverClass@@AAEXXZ	; OTWDriverClass::ShowThrustReverse
PUBLIC	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ		; VuBin<SimBaseClass>::operator bool
PUBLIC	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
PUBLIC	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
PUBLIC	?DisplayAxisValues@OTWDriverClass@@QAEXXZ	; OTWDriverClass::DisplayAxisValues
PUBLIC	?GetXRes@VirtualDisplay@@QAEHXZ			; VirtualDisplay::GetXRes
PUBLIC	?GetYRes@VirtualDisplay@@QAEHXZ			; VirtualDisplay::GetYRes
PUBLIC	?SetTextureSet@DrawableBSP@@QAEXK@Z		; DrawableBSP::SetTextureSet
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?RunningInstantAction@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningInstantAction
PUBLIC	?RunningDogfight@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningDogfight
PUBLIC	?RunningTactical@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningTactical
PUBLIC	?RunningCampaign@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningCampaign
PUBLIC	?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaignOrTactical
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
PUBLIC	?SetState@CDXEngine@@QAEXW4DX_StateType@@@Z	; CDXEngine::SetState
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDFloat@@YAMXZ				; PRANDFloat
PUBLIC	?Online@UIComms@@QAEHXZ				; UIComms::Online
PUBLIC	?GetNumberEngines@AirframeClass@@QAEHXZ		; AirframeClass::GetNumberEngines
PUBLIC	?Cd@AirframeClass@@QAEMXZ			; AirframeClass::Cd
PUBLIC	?Cl@AirframeClass@@QAEMXZ			; AirframeClass::Cl
PUBLIC	?Cy@AirframeClass@@QAEMXZ			; AirframeClass::Cy
PUBLIC	?XSAero@AirframeClass@@QAEMXZ			; AirframeClass::XSAero
PUBLIC	?ZSAero@AirframeClass@@QAEMXZ			; AirframeClass::ZSAero
PUBLIC	?ZSProp@AirframeClass@@QAEMXZ			; AirframeClass::ZSProp
PUBLIC	?AOABias@AirframeClass@@QAEMXZ			; AirframeClass::AOABias
PUBLIC	?Thrust@AirframeClass@@QAEMXZ			; AirframeClass::Thrust
PUBLIC	?HasManualFlaps@AirframeClass@@QAE_NXZ		; AirframeClass::HasManualFlaps
PUBLIC	?TefDegrees@AirframeClass@@QAEMXZ		; AirframeClass::TefDegrees
PUBLIC	?LefDegrees@AirframeClass@@QAEMXZ		; AirframeClass::LefDegrees
PUBLIC	?Mass@AirframeClass@@QAEMXZ			; AirframeClass::Mass
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_C@_07LGGAIHJM@?$CFd?4?$CF02d?$AA@		; `string'
PUBLIC	??_C@_0M@JJCAFCEI@?$CFd?4?$CF02d?$CFd?$CFc?$AA@	; `string'
PUBLIC	??_C@_0BB@ONGNLEIL@?5?5?5?5?5?5X?5?$DN?5?$CF10?42f?$AA@ ; `string'
PUBLIC	??_C@_0BB@CMODGLEL@?5?5?5?5?5?5Y?5?$DN?5?$CF10?42f?$AA@ ; `string'
PUBLIC	??_C@_0BB@LFABANEK@?5?5?5?5?5?5Z?5?$DN?5?$CF10?42f?$AA@ ; `string'
PUBLIC	??_C@_0BB@FPHCBPPP@Heading?5?$DN?5?$CF10?42f?$AA@ ; `string'
PUBLIC	??_C@_0BB@KCHKBFGN@?5?5Pitch?5?$DN?5?$CF10?42f?$AA@ ; `string'
PUBLIC	??_C@_0BB@NBELEFBC@?5?5?5Roll?5?$DN?5?$CF10?42f?$AA@ ; `string'
PUBLIC	??_C@_0CE@NALMCJJD@Cd?5?$CF8?44f?5Cl?5?$CF8?44f?5Cy?5?$CF8?44f?5Mu?5?$CF8@ ; `string'
PUBLIC	??_C@_0CE@NALPMFDE@XDrag?5?$CF6?44f?5Thrust?5?$CF8?41f?5Mass?5?$CF8@ ; `string'
PUBLIC	??_C@_0CE@EMHHJKOE@AoABias?5?$CF5?42f?5Lift?5?$CF5?42f?5Down?5?$CF6@ ; `string'
PUBLIC	??_C@_0CA@LOCKLHGF@AOA?5?$CF5?42f?5Tef?5?$CF10?44f?5Lef?5?$CF10?44f?$AA@ ; `string'
PUBLIC	??_C@_0CB@BKKFLAGM@HALF?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@ ; `string'
PUBLIC	??_C@_0CB@OMALPPEN@FULL?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@ ; `string'
PUBLIC	??_C@_0CB@LBDGODBE@AUTO?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@ ; `string'
PUBLIC	??_C@_0BH@PPDDNFH@Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f?$AA@ ; `string'
PUBLIC	??_C@_0CB@EMOFKDJJ@Left?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42f@ ; `string'
PUBLIC	??_C@_0CC@GBPHMDBM@Right?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@ ; `string'
PUBLIC	??_C@_0CC@HMHCONGA@Both?5Engines?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@ ; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_0BF@FGPLOIAD@Attached?5to?5catapult?$AA@	; `string'
PUBLIC	??_C@_0N@KDJNKAGH@GetAxisValue?$AA@		; `string'
PUBLIC	??_C@_0L@PAMKKJLI@ReadAnalog?$AA@		; `string'
PUBLIC	??_C@_06NOADDNNE@Center?$AA@			; `string'
PUBLIC	??_C@_06FMHFAJPO@Cutoff?$AA@			; `string'
PUBLIC	??_C@_09IAGFJCLC@Smoothing?$AA@			; `string'
PUBLIC	??_C@_03DKEJHHJP@?$CFs?3?$AA@			; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi?$AA@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_0BA@IPALCOCA@Throttle?5?$CFi?5OFF?$AA@	; `string'
PUBLIC	??_C@_0BA@DMMPHDKL@?$CFY?9?$CFm?9?$CFd_?$CFH?$CFM?$CFS?$AA@ ; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BK@GBPMLGCO@Thrust?5Reverser?5ACTIVATED?$AA@ ; `string'
PUBLIC	??_C@_0BG@ELFALNCI@Thrust?5Reverser?5ARMED?$AA@	; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3eb80000
PUBLIC	__real@3ec80000
PUBLIC	__real@3ed55555
PUBLIC	__real@3eeaaaab
PUBLIC	__real@3efaaaab
PUBLIC	__real@3f000000
PUBLIC	__real@3f080000
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f100000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f1aaaab
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f59999a
PUBLIC	__real@3f6147ae
PUBLIC	__real@3f666666
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	__real@42480000
PUBLIC	__real@42652ee1
PUBLIC	__real@42c80000
PUBLIC	__real@454cffae
PUBLIC	__real@477fff00
PUBLIC	__real@be19999a
PUBLIC	__real@be99999a
PUBLIC	__real@bee66666
PUBLIC	__real@bf19999a
PUBLIC	__real@bf333333
PUBLIC	__real@bf400000
PUBLIC	__real@bf666666
PUBLIC	__real@bf733333
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_strftime:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	_sprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z:PROC ; OTWDriverClass::SetOTWDisplayMode
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?SetFOV@OTWDriverClass@@QAEXM@Z:PROC		; OTWDriverClass::SetFOV
EXTRN	?GetFOV@OTWDriverClass@@QAEMXZ:PROC		; OTWDriverClass::GetFOV
EXTRN	?ToggleEyeFly@OTWDriverClass@@QAEXXZ:PROC	; OTWDriverClass::ToggleEyeFly
EXTRN	?BackBufferToRAW@ImageBuffer@@QAEXPAD@Z:PROC	; ImageBuffer::BackBufferToRAW
EXTRN	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; Render3D::SetCamera
EXTRN	?SetTextureSet@ObjectInstance@@QAEXH@Z:PROC	; ObjectInstance::SetTextureSet
EXTRN	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z:PROC ; DrawableBSP::DrawableBSP
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?ResetFuel@AircraftClass@@QAEXXZ:PROC		; AircraftClass::ResetFuel
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?ReadAnalog@SIMLIB_IO_CLASS@@QAEMW4GameAxis_t@@@Z:PROC ; SIMLIB_IO_CLASS::ReadAnalog
EXTRN	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z:PROC ; SIMLIB_IO_CLASS::GetAxisValue
EXTRN	?FlushBuffers@CDXEngine@@QAEXXZ:PROC		; CDXEngine::FlushBuffers
EXTRN	?SaveState@CDXEngine@@QAEXXZ:PROC		; CDXEngine::SaveState
EXTRN	?RestoreState@CDXEngine@@QAEXXZ:PROC		; CDXEngine::RestoreState
EXTRN	?tactical_is_training@@YAHXZ:PROC		; tactical_is_training
EXTRN	?ResetVoices@@YAXXZ:PROC			; ResetVoices
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?IMatrix@@3UTrotation@@B:BYTE			; IMatrix
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?m_RenderState@CDXEngine@@0W4DX_StateType@@A:DWORD ; CDXEngine::m_RenderState
EXTRN	?TheDXEngine@@3VCDXEngine@@A:BYTE		; TheDXEngine
EXTRN	?gameCompressionRatio@@3HA:DWORD		; gameCompressionRatio
EXTRN	?gLangIDNum@@3HA:DWORD				; gLangIDNum
EXTRN	?gCommsMgr@@3PAVUIComms@@A:DWORD		; gCommsMgr
EXTRN	?MajorVersion@@3HA:DWORD			; MajorVersion
EXTRN	?MinorVersion@@3HA:DWORD			; MinorVersion
EXTRN	?ShowVersion@@3HA:DWORD				; ShowVersion
EXTRN	?endAbort@@3HA:DWORD				; endAbort
EXTRN	?endDialogObject@@3PAVDrawableBSP@@A:DWORD	; endDialogObject
EXTRN	?FalconPictureDirectory@@3PADA:BYTE		; FalconPictureDirectory
EXTRN	?g_intellivibeData@@3VIntellivibeData@@A:BYTE	; g_intellivibeData
EXTRN	?gSharedIntellivibe@@3PAXA:DWORD		; gSharedIntellivibe
EXTRN	?UserStickInputs@@3VPilotInputs@@A:BYTE		; UserStickInputs
EXTRN	?clickableMouseMode@@3_NA:BYTE			; clickableMouseMode
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
;	COMDAT ?lastclickablepitmode@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4_NA
_BSS	SEGMENT
?lastclickablepitmode@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4_NA DB 01H DUP (?) ; `OTWDriverClass::SetExitMenu'::`2'::lastclickablepitmode
_BSS	ENDS
;	COMDAT ?$S1@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4IA
_BSS	SEGMENT
?$S1@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4IA DD 01H DUP (?) ; `OTWDriverClass::SetExitMenu'::`2'::$S1
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf733333
CONST	SEGMENT
__real@bf733333 DD 0bf733333r			; -0.95
CONST	ENDS
;	COMDAT __real@bf666666
CONST	SEGMENT
__real@bf666666 DD 0bf666666r			; -0.9
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@bf333333
CONST	SEGMENT
__real@bf333333 DD 0bf333333r			; -0.7
CONST	ENDS
;	COMDAT __real@bf19999a
CONST	SEGMENT
__real@bf19999a DD 0bf19999ar			; -0.6
CONST	ENDS
;	COMDAT __real@bee66666
CONST	SEGMENT
__real@bee66666 DD 0bee66666r			; -0.45
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@be19999a
CONST	SEGMENT
__real@be19999a DD 0be19999ar			; -0.15
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f6147ae
CONST	SEGMENT
__real@3f6147ae DD 03f6147aer			; 0.88
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f1aaaab
CONST	SEGMENT
__real@3f1aaaab DD 03f1aaaabr			; 0.604167
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f100000
CONST	SEGMENT
__real@3f100000 DD 03f100000r			; 0.5625
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f080000
CONST	SEGMENT
__real@3f080000 DD 03f080000r			; 0.53125
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3efaaaab
CONST	SEGMENT
__real@3efaaaab DD 03efaaaabr			; 0.489583
CONST	ENDS
;	COMDAT __real@3eeaaaab
CONST	SEGMENT
__real@3eeaaaab DD 03eeaaaabr			; 0.458333
CONST	ENDS
;	COMDAT __real@3ed55555
CONST	SEGMENT
__real@3ed55555 DD 03ed55555r			; 0.416667
CONST	ENDS
;	COMDAT __real@3ec80000
CONST	SEGMENT
__real@3ec80000 DD 03ec80000r			; 0.390625
CONST	ENDS
;	COMDAT __real@3eb80000
CONST	SEGMENT
__real@3eb80000 DD 03eb80000r			; 0.359375
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ELFALNCI@Thrust?5Reverser?5ARMED?$AA@
CONST	SEGMENT
??_C@_0BG@ELFALNCI@Thrust?5Reverser?5ARMED?$AA@ DB 'Thrust Reverser ARMED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GBPMLGCO@Thrust?5Reverser?5ACTIVATED?$AA@
CONST	SEGMENT
??_C@_0BK@GBPMLGCO@Thrust?5Reverser?5ACTIVATED?$AA@ DB 'Thrust Reverser A'
	DB	'CTIVATED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMMPHDKL@?$CFY?9?$CFm?9?$CFd_?$CFH?$CFM?$CFS?$AA@
CONST	SEGMENT
??_C@_0BA@DMMPHDKL@?$CFY?9?$CFm?9?$CFd_?$CFH?$CFM?$CFS?$AA@ DB '%Y-%m-%d_'
	DB	'%H%M%S', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPALCOCA@Throttle?5?$CFi?5OFF?$AA@
CONST	SEGMENT
??_C@_0BA@IPALCOCA@Throttle?5?$CFi?5OFF?$AA@ DB 'Throttle %i OFF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi?$AA@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi?$AA@ DB '%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKEJHHJP@?$CFs?3?$AA@
CONST	SEGMENT
??_C@_03DKEJHHJP@?$CFs?3?$AA@ DB '%s:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IAGFJCLC@Smoothing?$AA@
CONST	SEGMENT
??_C@_09IAGFJCLC@Smoothing?$AA@ DB 'Smoothing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FMHFAJPO@Cutoff?$AA@
CONST	SEGMENT
??_C@_06FMHFAJPO@Cutoff?$AA@ DB 'Cutoff', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOADDNNE@Center?$AA@
CONST	SEGMENT
??_C@_06NOADDNNE@Center?$AA@ DB 'Center', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PAMKKJLI@ReadAnalog?$AA@
CONST	SEGMENT
??_C@_0L@PAMKKJLI@ReadAnalog?$AA@ DB 'ReadAnalog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDJNKAGH@GetAxisValue?$AA@
CONST	SEGMENT
??_C@_0N@KDJNKAGH@GetAxisValue?$AA@ DB 'GetAxisValue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FGPLOIAD@Attached?5to?5catapult?$AA@
CONST	SEGMENT
??_C@_0BF@FGPLOIAD@Attached?5to?5catapult?$AA@ DB 'Attached to catapult', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HMHCONGA@Both?5Engines?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@
CONST	SEGMENT
??_C@_0CC@HMHCONGA@Both?5Engines?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@ DB 'Bot'
	DB	'h Engines rpm %5.2f rpm2 %5.2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBPHMDBM@Right?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@
CONST	SEGMENT
??_C@_0CC@GBPHMDBM@Right?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@ DB 'Rig'
	DB	'ht Engine rpm %5.2f rpm2 %5.2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EMOFKDJJ@Left?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42f@
CONST	SEGMENT
??_C@_0CB@EMOFKDJJ@Left?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42f@ DB 'Lef'
	DB	't Engine rpm %5.2f rpm2 %5.2f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PPDDNFH@Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f?$AA@
CONST	SEGMENT
??_C@_0BH@PPDDNFH@Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f?$AA@ DB 'Flaps %3.0f '
	DB	'LEFs %3.0f', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LBDGODBE@AUTO?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@
CONST	SEGMENT
??_C@_0CB@LBDGODBE@AUTO?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@ DB 'AUT'
	DB	'O MODE Flaps %3.0f LEFs %3.0f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OMALPPEN@FULL?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@
CONST	SEGMENT
??_C@_0CB@OMALPPEN@FULL?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@ DB 'FUL'
	DB	'L MODE Flaps %3.0f LEFs %3.0f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKKFLAGM@HALF?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@
CONST	SEGMENT
??_C@_0CB@BKKFLAGM@HALF?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@ DB 'HAL'
	DB	'F MODE Flaps %3.0f LEFs %3.0f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LOCKLHGF@AOA?5?$CF5?42f?5Tef?5?$CF10?44f?5Lef?5?$CF10?44f?$AA@
CONST	SEGMENT
??_C@_0CA@LOCKLHGF@AOA?5?$CF5?42f?5Tef?5?$CF10?44f?5Lef?5?$CF10?44f?$AA@ DB 'A'
	DB	'OA %5.2f Tef %10.4f Lef %10.4f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EMHHJKOE@AoABias?5?$CF5?42f?5Lift?5?$CF5?42f?5Down?5?$CF6@
CONST	SEGMENT
??_C@_0CE@EMHHJKOE@AoABias?5?$CF5?42f?5Lift?5?$CF5?42f?5Down?5?$CF6@ DB 'A'
	DB	'oABias %5.2f Lift %5.2f Down %6.4f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NALPMFDE@XDrag?5?$CF6?44f?5Thrust?5?$CF8?41f?5Mass?5?$CF8@
CONST	SEGMENT
??_C@_0CE@NALPMFDE@XDrag?5?$CF6?44f?5Thrust?5?$CF8?41f?5Mass?5?$CF8@ DB 'X'
	DB	'Drag %6.4f Thrust %8.1f Mass %8.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NALMCJJD@Cd?5?$CF8?44f?5Cl?5?$CF8?44f?5Cy?5?$CF8?44f?5Mu?5?$CF8@
CONST	SEGMENT
??_C@_0CE@NALMCJJD@Cd?5?$CF8?44f?5Cl?5?$CF8?44f?5Cy?5?$CF8?44f?5Mu?5?$CF8@ DB 'C'
	DB	'd %8.4f Cl %8.4f Cy %8.4f Mu %8.4f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NBELEFBC@?5?5?5Roll?5?$DN?5?$CF10?42f?$AA@
CONST	SEGMENT
??_C@_0BB@NBELEFBC@?5?5?5Roll?5?$DN?5?$CF10?42f?$AA@ DB '   Roll = %10.2f'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KCHKBFGN@?5?5Pitch?5?$DN?5?$CF10?42f?$AA@
CONST	SEGMENT
??_C@_0BB@KCHKBFGN@?5?5Pitch?5?$DN?5?$CF10?42f?$AA@ DB '  Pitch = %10.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPHCBPPP@Heading?5?$DN?5?$CF10?42f?$AA@
CONST	SEGMENT
??_C@_0BB@FPHCBPPP@Heading?5?$DN?5?$CF10?42f?$AA@ DB 'Heading = %10.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFABANEK@?5?5?5?5?5?5Z?5?$DN?5?$CF10?42f?$AA@
CONST	SEGMENT
??_C@_0BB@LFABANEK@?5?5?5?5?5?5Z?5?$DN?5?$CF10?42f?$AA@ DB '      Z = %10'
	DB	'.2f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CMODGLEL@?5?5?5?5?5?5Y?5?$DN?5?$CF10?42f?$AA@
CONST	SEGMENT
??_C@_0BB@CMODGLEL@?5?5?5?5?5?5Y?5?$DN?5?$CF10?42f?$AA@ DB '      Y = %10'
	DB	'.2f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ONGNLEIL@?5?5?5?5?5?5X?5?$DN?5?$CF10?42f?$AA@
CONST	SEGMENT
??_C@_0BB@ONGNLEIL@?5?5?5?5?5?5X?5?$DN?5?$CF10?42f?$AA@ DB '      X = %10'
	DB	'.2f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JJCAFCEI@?$CFd?4?$CF02d?$CFd?$CFc?$AA@
CONST	SEGMENT
??_C@_0M@JJCAFCEI@?$CFd?4?$CF02d?$CFd?$CFc?$AA@ DB '%d.%02d%d%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGGAIHJM@?$CFd?4?$CF02d?$AA@
CONST	SEGMENT
??_C@_07LGGAIHJM@?$CFd?4?$CF02d?$AA@ DB '%d.%02d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z$0
__ehfuncinfo$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\pilotinputs.h
;	COMDAT ?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ PROC ; PilotInputs::getCurrentEngine, COMDAT
; _this$ = ecx

; 49   : 	  Engine_t getCurrentEngine() { return currentlyActiveEngine; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ENDP ; PilotInputs::getCurrentEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Mass@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Mass@AirframeClass@@QAEMXZ PROC			; AirframeClass::Mass, COMDAT
; _this$ = ecx

; 1169 : 	float Mass (void)		{return mass;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?Mass@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Mass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?LefDegrees@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
?LefDegrees@AirframeClass@@QAEMXZ PROC			; AirframeClass::LefDegrees, COMDAT
; _this$ = ecx

; 1011 : 	float LefDegrees() { return lefFactor * auxaeroData->lefMaxAngle; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1240]
	mulss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?LefDegrees@AirframeClass@@QAEMXZ ENDP			; AirframeClass::LefDegrees
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?TefDegrees@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
?TefDegrees@AirframeClass@@QAEMXZ PROC			; AirframeClass::TefDegrees, COMDAT
; _this$ = ecx

; 1010 : 	float TefDegrees() { return tefFactor * auxaeroData->tefMaxAngle; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1236]
	mulss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TefDegrees@AirframeClass@@QAEMXZ ENDP			; AirframeClass::TefDegrees
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HasManualFlaps@AirframeClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?HasManualFlaps@AirframeClass@@QAE_NXZ PROC		; AirframeClass::HasManualFlaps, COMDAT
; _this$ = ecx

; 1009 : 	bool HasManualFlaps() { return auxaeroData->hasTef == AUX_LEFTEF_MANUAL; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+84], 1
	jne	SHORT $LN3@HasManualF
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@HasManualF
$LN3@HasManualF:
	mov	DWORD PTR tv67[ebp], 0
$LN4@HasManualF:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?HasManualFlaps@AirframeClass@@QAE_NXZ ENDP		; AirframeClass::HasManualFlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Thrust@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Thrust@AirframeClass@@QAEMXZ PROC			; AirframeClass::Thrust, COMDAT
; _this$ = ecx

; 840  : 	float Thrust() { return thrust; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+188]
	mov	esp, ebp
	pop	ebp
	ret	0
?Thrust@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Thrust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?AOABias@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AOABias@AirframeClass@@QAEMXZ PROC			; AirframeClass::AOABias, COMDAT
; _this$ = ecx

; 838  : 	float AOABias() { return aoabias; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?AOABias@AirframeClass@@QAEMXZ ENDP			; AirframeClass::AOABias
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ZSProp@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZSProp@AirframeClass@@QAEMXZ PROC			; AirframeClass::ZSProp, COMDAT
; _this$ = ecx

; 837  : 	float ZSProp() { return zsprop; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+780]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZSProp@AirframeClass@@QAEMXZ ENDP			; AirframeClass::ZSProp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ZSAero@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZSAero@AirframeClass@@QAEMXZ PROC			; AirframeClass::ZSAero, COMDAT
; _this$ = ecx

; 834  : 	float ZSAero() { return zsaero; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+744]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZSAero@AirframeClass@@QAEMXZ ENDP			; AirframeClass::ZSAero
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?XSAero@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XSAero@AirframeClass@@QAEMXZ PROC			; AirframeClass::XSAero, COMDAT
; _this$ = ecx

; 832  : 	float XSAero() { return xsaero; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+736]
	mov	esp, ebp
	pop	ebp
	ret	0
?XSAero@AirframeClass@@QAEMXZ ENDP			; AirframeClass::XSAero
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Cy@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cy@AirframeClass@@QAEMXZ PROC				; AirframeClass::Cy, COMDAT
; _this$ = ecx

; 825  : 	float Cy() { return cy; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?Cy@AirframeClass@@QAEMXZ ENDP				; AirframeClass::Cy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Cl@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cl@AirframeClass@@QAEMXZ PROC				; AirframeClass::Cl, COMDAT
; _this$ = ecx

; 824  : 	float Cl() { return cl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?Cl@AirframeClass@@QAEMXZ ENDP				; AirframeClass::Cl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Cd@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cd@AirframeClass@@QAEMXZ PROC				; AirframeClass::Cd, COMDAT
; _this$ = ecx

; 823  : 	float Cd() { return cd; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+156]
	mov	esp, ebp
	pop	ebp
	ret	0
?Cd@AirframeClass@@QAEMXZ ENDP				; AirframeClass::Cd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetNumberEngines@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumberEngines@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetNumberEngines, COMDAT
; _this$ = ecx

; 802  : 	int GetNumberEngines() {return auxaeroData->nEngines;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+344]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberEngines@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetNumberEngines
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui\include\uicomms.h
;	COMDAT ?Online@UIComms@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Online@UIComms@@QAEHXZ PROC				; UIComms::Online, COMDAT
; _this$ = ecx

; 118  : 		BOOL Online()					{ return(Online_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Online@UIComms@@QAEHXZ ENDP				; UIComms::Online
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloat@@YAMXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloat@@YAMXZ PROC					; PRANDFloat, COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR tv75[ebp], xmm1
	fld	DWORD PTR tv75[ebp]

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloat@@YAMXZ ENDP					; PRANDFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\dxengine\dxengine.h
;	COMDAT ?SetState@CDXEngine@@QAEXW4DX_StateType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Mode$ = 8						; size = 4
?SetState@CDXEngine@@QAEXW4DX_StateType@@@Z PROC	; CDXEngine::SetState, COMDAT
; _this$ = ecx

; 145  : 	void			SetState(DX_StateType	Mode)	{ m_RenderState = Mode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _Mode$[ebp]
	mov	DWORD PTR ?m_RenderState@CDXEngine@@0W4DX_StateType@@A, eax ; CDXEngine::m_RenderState
	mov	esp, ebp
	pop	ebp
	ret	4
?SetState@CDXEngine@@QAEXW4DX_StateType@@@Z ENDP	; CDXEngine::SetState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::IsAxisCutOff, COMDAT
; _this$ = ecx

; 244  : 	bool	IsAxisCutOff(GameAxis_t id) { return (analog[id].ioVal > (analog[id].cutoff + idleCutoffPad)); } // MD -- 20040210

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _id$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1660]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+eax+8], ecx
	jle	SHORT $LN3@IsAxisCutO
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@IsAxisCutO
$LN3@IsAxisCutO:
	mov	DWORD PTR tv75[ebp], 0
$LN4@IsAxisCutO:
	mov	al, BYTE PTR tv75[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::IsAxisCutOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ PROC ; SimulationDriver::RunningCampaignOrTactical, COMDAT
; _this$ = ecx

; 61   : 	bool RunningCampaignOrTactical() const   { return RunningCampaign() || RunningTactical(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunningCampaign@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaign
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@RunningCam
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunningTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningTactical
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@RunningCam
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@RunningCam
$LN3@RunningCam:
	mov	DWORD PTR tv72[ebp], 1
$LN4@RunningCam:
	mov	al, BYTE PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ENDP ; SimulationDriver::RunningCampaignOrTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningCampaign@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningCampaign@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningCampaign, COMDAT
; _this$ = ecx

; 59   : 	bool RunningCampaign() const             { return FalconLocalGame->GetGameType() == game_Campaign; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningCam
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningCam
$LN3@RunningCam:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningCam:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	SHORT $LN5@RunningCam
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningCam
$LN5@RunningCam:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningCam:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningCampaign@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningTactical@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningTactical, COMDAT
; _this$ = ecx

; 57   : 	bool RunningTactical() const             { return FalconLocalGame->GetGameType() == game_TacticalEngagement; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningTac
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningTac
$LN3@RunningTac:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningTac:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN5@RunningTac
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningTac
$LN5@RunningTac:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningTac:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningTactical@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningDogfight@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningDogfight@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningDogfight, COMDAT
; _this$ = ecx

; 55   : 	bool RunningDogfight() const             { return FalconLocalGame->GetGameType() == game_Dogfight; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningDog
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningDog
$LN3@RunningDog:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningDog:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN5@RunningDog
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningDog
$LN5@RunningDog:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningDog:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningDogfight@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningDogfight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningInstantAction@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningInstantAction@SimulationDriver@@QBE_NXZ PROC	; SimulationDriver::RunningInstantAction, COMDAT
; _this$ = ecx

; 53   : 	bool RunningInstantAction() const  { return FalconLocalGame->GetGameType() == game_InstantAction; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningIns
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningIns
$LN3@RunningIns:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningIns:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	jne	SHORT $LN5@RunningIns
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningIns
$LN5@RunningIns:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningIns:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningInstantAction@SimulationDriver@@QBE_NXZ ENDP	; SimulationDriver::RunningInstantAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?SetTextureSet@DrawableBSP@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_set$ = 8						; size = 4
?SetTextureSet@DrawableBSP@@QAEXK@Z PROC		; DrawableBSP::SetTextureSet, COMDAT
; _this$ = ecx

; 49   : 	void SetTextureSet( UInt32 set )	{ instance.SetTextureSet( set ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?SetTextureSet@ObjectInstance@@QAEXH@Z	; ObjectInstance::SetTextureSet
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTextureSet@DrawableBSP@@QAEXK@Z ENDP		; DrawableBSP::SetTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?GetYRes@VirtualDisplay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYRes@VirtualDisplay@@QAEHXZ PROC			; VirtualDisplay::GetYRes, COMDAT
; _this$ = ecx

; 149  :     int GetYRes(void) { return yRes; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetYRes@VirtualDisplay@@QAEHXZ ENDP			; VirtualDisplay::GetYRes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?GetXRes@VirtualDisplay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetXRes@VirtualDisplay@@QAEHXZ PROC			; VirtualDisplay::GetXRes, COMDAT
; _this$ = ecx

; 148  :     int GetXRes(void) { return xRes; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetXRes@VirtualDisplay@@QAEHXZ ENDP			; VirtualDisplay::GetXRes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_this$ = -140						; size = 4
_i$1 = -136						; size = 4
_tmp$2 = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
?DisplayAxisValues@OTWDriverClass@@QAEXXZ PROC		; OTWDriverClass::DisplayAxisValues
; _this$ = ecx

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 255  : extern GameAxisSetup_t AxisSetup[AXIS_MAX];
; 256  : 
; 257  : 	OTWDriver.renderer->SetColor(0xFFFF0000);

	push	-65536					; ffff0000H
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 258  : 	
; 259  : 	OTWDriver.renderer->TextLeft(-0.75F,0.9F,"GetAxisValue");

	push	0
	push	OFFSET ??_C@_0N@KDJNKAGH@GetAxisValue?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 260  : 	OTWDriver.renderer->TextLeft(-0.60F,0.9F,"ReadAnalog");

	push	0
	push	OFFSET ??_C@_0L@PAMKKJLI@ReadAnalog?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 261  : 	OTWDriver.renderer->TextLeft(-0.45F,0.9F,"Center");

	push	0
	push	OFFSET ??_C@_06NOADDNNE@Center?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bee66666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 262  : 	OTWDriver.renderer->TextLeft(-0.30F,0.9F,"Cutoff");

	push	0
	push	OFFSET ??_C@_06FMHFAJPO@Cutoff?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 263  : 	OTWDriver.renderer->TextLeft(-0.15F,0.9F,"Smoothing");

	push	0
	push	OFFSET ??_C@_09IAGFJCLC@Smoothing?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 264  : 	for (int i = AXIS_START; i < AXIS_MAX; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@DisplayAxi
$LN6@DisplayAxi:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN7@DisplayAxi:
	cmp	DWORD PTR _i$1[ebp], 22			; 00000016H
	jge	$LN5@DisplayAxi

; 265  : 	{
; 266  : 		char tmp[128] = {0};

	mov	BYTE PTR _tmp$2[ebp], 0
	push	127					; 0000007fH
	push	0
	lea	edx, DWORD PTR _tmp$2[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 267  : 
; 268  : 		sprintf(tmp,"%s:",Axis2Text[i].theText);

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?Axis2Text@@3PAU<unnamed-type-Axis2Text>@@A[eax*8+4]
	push	ecx
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3?$AA@
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 269  : 
; 270  : 		OTWDriver.renderer->TextLeft(-0.95F,0.85F-(i*0.05f),tmp);

	push	0
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _i$1[ebp]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 271  : 
; 272  : 		if (IO.AnalogIsUsed((GameAxis_t)i) == true)

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	edx, al
	cmp	edx, 1
	jne	$LN1@DisplayAxi

; 273  : 		{
; 274  : 			sprintf(tmp,"%i",IO.GetAxisValue((GameAxis_t)i));

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::GetAxisValue
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi?$AA@
	lea	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 275  : 			OTWDriver.renderer->TextLeft(-0.70F,0.85F-(i*0.05f),tmp);

	push	0
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	cvtsi2ss xmm0, DWORD PTR _i$1[ebp]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bf333333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 276  : 
; 277  : 			sprintf(tmp,"%f",IO.ReadAnalog((GameAxis_t)i));

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?ReadAnalog@SIMLIB_IO_CLASS@@QAEMW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::ReadAnalog
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 278  : 			OTWDriver.renderer->TextLeft(-0.60F,0.85F-(i*0.05f),tmp);

	push	0
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _i$1[ebp]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 279  : 
; 280  : 			sprintf(tmp,"%i",IO.analog[i].center);

	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?IO@@3VSIMLIB_IO_CLASS@@A[ecx]
	push	edx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi?$AA@
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 281  : 			OTWDriver.renderer->TextLeft(-0.45F,0.85F-(i*0.05f),tmp);

	push	0
	lea	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	cvtsi2ss xmm0, DWORD PTR _i$1[ebp]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@bee66666
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 282  : 
; 283  : 			sprintf(tmp,"%i",IO.analog[i].cutoff);

	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?IO@@3VSIMLIB_IO_CLASS@@A[eax+4]
	push	ecx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi?$AA@
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 284  : 			OTWDriver.renderer->TextLeft(-0.30F,0.85F-(i*0.05f),tmp);

	push	0
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _i$1[ebp]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 285  : 
; 286  : 			if ((i == AXIS_THROTTLE)||(i == AXIS_THROTTLE2))

	cmp	DWORD PTR _i$1[ebp], 3
	je	SHORT $LN2@DisplayAxi
	cmp	DWORD PTR _i$1[ebp], 4
	jne	$LN1@DisplayAxi
$LN2@DisplayAxi:

; 287  : 			{
; 288  : 				if (IO.IsAxisCutOff((GameAxis_t)i) == true)

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?IsAxisCutOff@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::IsAxisCutOff
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN1@DisplayAxi

; 289  : 				{
; 290  : 					sprintf(tmp,"Throttle %i OFF",i-AXIS_THROTTLE+1);

	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 2
	push	eax
	push	OFFSET ??_C@_0BA@IPALCOCA@Throttle?5?$CFi?5OFF?$AA@
	lea	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 291  : 					OTWDriver.renderer->TextLeft(0.0F,0.85F-(i*0.05f),tmp);

	push	0
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	cvtsi2ss xmm0, DWORD PTR _i$1[ebp]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN1@DisplayAxi:

; 292  : 				}
; 293  : 			}
; 294  : 
; 295  : //			sprintf(tmp,"%i",IO.analog[i].smoothingFactor);
; 296  : //			OTWDriver.renderer->TextLeft(-0.15F,0.85F-(i*0.05F),tmp);
; 297  : 		}
; 298  : 	}

	jmp	$LN6@DisplayAxi
$LN5@DisplayAxi:

; 299  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayAxisValues@OTWDriverClass@@QAEXXZ ENDP		; OTWDriverClass::DisplayAxisValues
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ PROC ; VuBin<SimBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ENDP ; VuBin<SimBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ PROC	; VuBin<SimBaseClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ENDP	; VuBin<SimBaseClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimBaseClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimBaseClass@@@@QBE_NXZ PROC		; VuBin<SimBaseClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimBaseClass@@@@QBE_NXZ ENDP		; VuBin<SimBaseClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_af$1 = -16						; size = 4
tv139 = -12						; size = 4
tv87 = -8						; size = 4
_this$ = -4						; size = 4
?ShowThrustReverse@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::ShowThrustReverse
; _this$ = ecx

; 695  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 696  : 	if	(otwPlatform && 
; 697  : 		otwPlatform.get() == SimDriver.GetPlayerAircraft() && 
; 698  : 		otwPlatform->IsAirplane())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN1@ShowThrust
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	esi, eax
	jne	$LN1@ShowThrust
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN1@ShowThrust

; 699  : 		{
; 700  : 		AirframeClass *af = ((AircraftClass*)otwPlatform.get())->af;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR _af$1[ebp], ecx

; 701  : 
; 702  : 		if (SimDriver.GetPlayerAircraft()->OnGround() && af->thrustReverse == 2)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR tv139[ebp], eax
	mov	edx, DWORD PTR tv139[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN3@ShowThrust
	mov	eax, DWORD PTR _af$1[ebp]
	cmp	DWORD PTR [eax+1592], 2
	jne	SHORT $LN3@ShowThrust

; 703  : 			{
; 704  : 			renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 705  : 			renderer->TextRight(0.95F,0.9F,"Thrust Reverser ACTIVATED");

	push	0
	push	OFFSET ??_C@_0BK@GBPMLGCO@Thrust?5Reverser?5ACTIVATED?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	jmp	SHORT $LN1@ShowThrust
$LN3@ShowThrust:

; 706  : 			}
; 707  : 		else if (af->thrustReverse == 2)

	mov	ecx, DWORD PTR _af$1[ebp]
	cmp	DWORD PTR [ecx+1592], 2
	jne	SHORT $LN1@ShowThrust

; 708  : 			{
; 709  : 			renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 710  : 			renderer->TextRight(0.95F,0.9F,"Thrust Reverser ARMED");

	push	0
	push	OFFSET ??_C@_0BG@ELFALNCI@Thrust?5Reverser?5ARMED?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+60]
	call	eax
$LN1@ShowThrust:

; 711  : 			}
; 712  : 		}
; 713  : 
; 714  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowThrustReverse@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::ShowThrustReverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_tempFOV$ = -24						; size = 4
_this$ = -20						; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?DrawExitMenu@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::DrawExitMenu
; _this$ = ecx

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 335  : 	Tpoint origin = {0.0f,0.0f,0.0f};

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _origin$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _origin$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _origin$[ebp+8], xmm0

; 336  : 
; 337  :    float tempFOV = GetFOV();		//Wombat778 3-26-04 Save the current FOV;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR _tempFOV$[ebp]

; 338  :    SetFOV(45.0f*DTR);				//Wombat778 3-26-04 Set the FOV to 45 degrees to make it not dark (temporary fix till jam comes up with the real solution, then change to 60.0f)

	push	ecx
	movss	xmm0, DWORD PTR __real@3f490fd9
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 339  : 
; 340  : 
; 341  :    if(exitMenuOn != exitMenuDesired)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32208]
	cmp	ecx, DWORD PTR _exitMenuDesired
	je	SHORT $LN12@DrawExitMe

; 342  :    {
; 343  :       ChangeExitMenu (exitMenuDesired);

	mov	edx, DWORD PTR _exitMenuDesired
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeExitMenu@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::ChangeExitMenu
$LN12@DrawExitMe:

; 344  :    }
; 345  : 
; 346  :    if (exitMenuOn)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32208], 0
	je	$LN11@DrawExitMe

; 347  :    {
; 348  : 	   ShiAssert( endDialogObject );
; 349  : 
; 350  :       if (SimDriver.RunningDogfight())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningDogfight@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningDogfight
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@DrawExitMe

; 351  :       {
; 352  :          // TODO: Show final score board
; 353  :          endDialogObject->SetSwitchMask( 0, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 354  :          endDialogObject->SetSwitchMask( 1, FALSE);

	push	0
	push	1
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 355  :          endDialogObject->SetSwitchMask( 2, FALSE);

	push	0
	push	2
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 356  :          endsAvail[0] = TRUE;

	mov	edx, 4
	imul	edx, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[edx], 1

; 357  :          endsAvail[1] = FALSE;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[eax], 0

; 358  :          endsAvail[2] = FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR ?endsAvail@@3PAHA[ecx], 0
	jmp	$LN1@DrawExitMe
$LN10@DrawExitMe:

; 359  :       }
; 360  :       else if (SimDriver.RunningInstantAction())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningInstantAction@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningInstantAction
	movzx	edx, al
	test	edx, edx
	je	$LN8@DrawExitMe

; 361  :       {
; 362  :          endDialogObject->SetSwitchMask( 0, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 363  :          endDialogObject->SetSwitchMask( 2, FALSE);

	push	0
	push	2
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 364  :          endsAvail[0] = TRUE;

	mov	eax, 4
	imul	eax, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[eax], 1

; 365  :          endsAvail[2] = FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR ?endsAvail@@3PAHA[ecx], 0

; 366  : 
; 367  :          if (SimDriver.GetPlayerAircraft())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN7@DrawExitMe

; 368  :          {
; 369  :             endDialogObject->SetSwitchMask( 1, TRUE);

	push	1
	push	1
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 370  :             endsAvail[1] = TRUE;

	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[edx], 1

; 371  :          }
; 372  :          else

	jmp	SHORT $LN6@DrawExitMe
$LN7@DrawExitMe:

; 373  :          {
; 374  :             endDialogObject->SetSwitchMask( 1, FALSE);

	push	0
	push	1
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 375  :             endsAvail[1] = FALSE;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[eax], 0
$LN6@DrawExitMe:

; 376  :          }

	jmp	$LN1@DrawExitMe
$LN8@DrawExitMe:

; 377  :       }
; 378  :       else if (SimDriver.RunningCampaignOrTactical())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaignOrTactical
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@DrawExitMe

; 379  :       {
; 380  :          endDialogObject->SetSwitchMask( 0, TRUE);

	push	1
	push	0
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 381  :          endDialogObject->SetSwitchMask( 1, TRUE);

	push	1
	push	1
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 382  :          endsAvail[0] = TRUE;

	mov	edx, 4
	imul	edx, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[edx], 1

; 383  :          endsAvail[1] = TRUE;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR ?endsAvail@@3PAHA[eax], 1

; 384  : 		 if (tactical_is_training() || (gCommsMgr && gCommsMgr->Online()))

	call	?tactical_is_training@@YAHXZ		; tactical_is_training
	test	eax, eax
	jne	SHORT $LN2@DrawExitMe
	cmp	DWORD PTR ?gCommsMgr@@3PAVUIComms@@A, 0	; gCommsMgr
	je	SHORT $LN3@DrawExitMe
	mov	ecx, DWORD PTR ?gCommsMgr@@3PAVUIComms@@A ; gCommsMgr
	call	?Online@UIComms@@QAEHXZ			; UIComms::Online
	test	eax, eax
	je	SHORT $LN3@DrawExitMe
$LN2@DrawExitMe:

; 385  :             {
; 386  :             endDialogObject->SetSwitchMask( 2, FALSE);

	push	0
	push	2
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 387  :             endsAvail[2] = FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR ?endsAvail@@3PAHA[ecx], 0

; 388  :             }
; 389  :          else

	jmp	SHORT $LN1@DrawExitMe
$LN3@DrawExitMe:

; 390  :             {
; 391  :             endDialogObject->SetSwitchMask( 2, TRUE);

	push	1
	push	2
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 392  :             endsAvail[2] = TRUE;

	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR ?endsAvail@@3PAHA[edx], 1
$LN1@DrawExitMe:

; 393  :             }
; 394  : 
; 395  :       }
; 396  : 	// DX - Not necessary
; 397  : 	//oldState = renderer->GetObjectTextureState();
; 398  : 	//renderer->SetObjectTextureState( TRUE );
; 399  : 	// DX - End
; 400  : 	renderer->StartDraw();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 401  : 	renderer->SetViewport(-1.0F, 1.0F, 1.0F, -1.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 402  : 	renderer->SetCamera( &origin, &IMatrix );

	push	OFFSET ?IMatrix@@3UTrotation@@B		; IMatrix
	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera

; 403  : 	endDialogObject->Draw( renderer );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	push	eax
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 404  :     renderer->EndDraw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 405  : 
; 406  : 	// Set new DX Engine state as NORMAL
; 407  : 	TheDXEngine.SaveState();

	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?SaveState@CDXEngine@@QAEXXZ		; CDXEngine::SaveState

; 408  : 	TheDXEngine.SetState(DX_OTW);

	push	0
	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?SetState@CDXEngine@@QAEXW4DX_StateType@@@Z ; CDXEngine::SetState

; 409  : 	// Draw the Dialog
; 410  : 	TheDXEngine.FlushBuffers();

	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?FlushBuffers@CDXEngine@@QAEXXZ		; CDXEngine::FlushBuffers

; 411  : 	// And restore previous state
; 412  : 	TheDXEngine.RestoreState();

	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?RestoreState@CDXEngine@@QAEXXZ		; CDXEngine::RestoreState
$LN11@DrawExitMe:

; 413  : 	// DX - Not necessary
; 414  : 	//renderer->SetObjectTextureState( oldState );
; 415  : 	// DX - End
; 416  : 
; 417  :    }
; 418  : 
; 419  :    SetFOV(tempFOV);			//Wombat778 3-26-04 Restore the FOV

	push	ecx
	movss	xmm0, DWORD PTR _tempFOV$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 420  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawExitMenu@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::DrawExitMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_ltime$ = -540						; size = 8
_today$ = -532						; size = 4
_this$ = -528						; size = 4
_tmpStr$ = -524						; size = 260
_fileName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
?TakeScreenShot@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::TakeScreenShot
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 540				; 0000021cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 304  : char fileName[_MAX_PATH];
; 305  : char tmpStr[_MAX_PATH];
; 306  : time_t ltime;
; 307  : struct tm* today;
; 308  : 
; 309  :    time( &ltime );

	lea	eax, DWORD PTR _ltime$[ebp]
	push	eax
	call	_time
	add	esp, 4

; 310  :    takeScreenShot = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32028], 0

; 311  :    today = localtime (&ltime);

	lea	edx, DWORD PTR _ltime$[ebp]
	push	edx
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _today$[ebp], eax

; 312  :    //strftime( tmpStr, _MAX_PATH-1,"%m_%d_%Y-%H_%M_%S", today );
; 313  :    strftime( tmpStr, _MAX_PATH-1, "%Y-%m-%d_%H%M%S", today ); //THW Let's have ISO-Dates! Darn Americans :)

	mov	eax, DWORD PTR _today$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@DMMPHDKL@?$CFY?9?$CFm?9?$CFd_?$CFH?$CFM?$CFS?$AA@
	push	259					; 00000103H
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_strftime
	add	esp, 16					; 00000010H

; 314  :    //MI put them where they belong
; 315  : #if 0
; 316  :    sprintf (fileName, "%s\\%s", FalconDataDirectory, tmpStr);
; 317  : #else
; 318  :    sprintf (fileName, "%s\\%s", FalconPictureDirectory, tmpStr);

	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	OFFSET ?FalconPictureDirectory@@3PADA	; FalconPictureDirectory
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 319  : #endif
; 320  : 
; 321  :    OTWImage->BackBufferToRAW(fileName);

	lea	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32040]
	call	?BackBufferToRAW@ImageBuffer@@QAEXPAD@Z	; ImageBuffer::BackBufferToRAW

; 322  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?TakeScreenShot@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::TakeScreenShot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_af$1 = -96						; size = 4
tv86 = -92						; size = 4
_this$ = -88						; size = 4
_tmp$2 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
?ShowCatMessage@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::ShowCatMessage
; _this$ = ecx

; 211  : void OTWDriverClass::ShowCatMessage(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 212  :     if	(otwPlatform.get() && otwPlatform.get() == SimDriver.GetPlayerAircraft() && otwPlatform->IsAirplane()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	test	eax, eax
	je	$LN1@ShowCatMes
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	esi, eax
	jne	$LN1@ShowCatMes
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR tv86[ebp], eax
	mov	eax, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN1@ShowCatMes

; 213  : 		AirframeClass *af = ((AircraftClass*)otwPlatform.get())->af;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR _af$1[ebp], ecx

; 214  : 
; 215  : 		if (af->IsSet(AirframeClass::OnObject) && af->IsSet(AirframeClass::Hook)) {

	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN1@ShowCatMes
	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN1@ShowCatMes

; 216  : 			renderer->SetColor (0xff0000ff);

	push	-16776961				; ff0000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 217  : 			char tmp[80];
; 218  : 			sprintf(tmp, "Attached to catapult");

	push	OFFSET ??_C@_0BF@FGPLOIAD@Attached?5to?5catapult?$AA@
	lea	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 219  : 			renderer->TextLeft (-0.95F, 0.88F, tmp);

	push	0
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+56]
	call	edx
$LN1@ShowCatMes:

; 220  : 		}
; 221  : 	}
; 222  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowCatMessage@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::ShowCatMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
tv86 = -100						; size = 4
tv148 = -96						; size = 4
_af$1 = -92						; size = 4
_this$ = -88						; size = 4
_tmp$2 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
?ShowEngine@OTWDriverClass@@AAEXXZ PROC			; OTWDriverClass::ShowEngine
; _this$ = ecx

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 	if	(otwPlatform.get() && 
; 183  : 		otwPlatform.get() == SimDriver.GetPlayerAircraft() && 
; 184  : 		otwPlatform->IsAirplane())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	test	eax, eax
	je	$LN1@ShowEngine
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	esi, eax
	jne	$LN1@ShowEngine
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR tv86[ebp], eax
	mov	eax, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN1@ShowEngine

; 185  : 	{
; 186  : 		AirframeClass *af = ((AircraftClass*)otwPlatform.get())->af;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR _af$1[ebp], ecx

; 187  : 		if (af->GetNumberEngines() == 2)

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?GetNumberEngines@AirframeClass@@QAEHXZ	; AirframeClass::GetNumberEngines
	cmp	eax, 2
	jne	$LN8@ShowEngine

; 188  : 		{
; 189  : 			renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 190  : 			char tmp[80];
; 191  : 			//TJL 02/16/04 Added RPM output to engine select
; 192  : 			switch (UserStickInputs.getCurrentEngine())

	mov	ecx, OFFSET ?UserStickInputs@@3VPilotInputs@@A ; UserStickInputs
	call	?getCurrentEngine@PilotInputs@@QAE?AW4Engine_t@1@XZ ; PilotInputs::getCurrentEngine
	mov	DWORD PTR tv148[ebp], eax
	cmp	DWORD PTR tv148[ebp], 0
	je	SHORT $LN5@ShowEngine
	cmp	DWORD PTR tv148[ebp], 1
	je	SHORT $LN4@ShowEngine
	cmp	DWORD PTR tv148[ebp], 2
	je	SHORT $LN3@ShowEngine
	jmp	$LN2@ShowEngine
$LN5@ShowEngine:

; 193  : 			{
; 194  : 			case PilotInputs::Left_Engine:	sprintf(tmp,"Left Engine rpm %5.2f rpm2 %5.2f", af->rpm, af->rpm2); break;

	mov	ecx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1216]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+1212]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CB@EMOFKDJJ@Left?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42f@
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H
	jmp	$LN6@ShowEngine
$LN4@ShowEngine:

; 195  : 			case PilotInputs::Right_Engine:	sprintf(tmp,"Right Engine rpm %5.2f rpm2 %5.2f", af->rpm, af->rpm2); break;

	mov	ecx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1216]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+1212]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CC@GBPHMDBM@Right?5Engine?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN6@ShowEngine
$LN3@ShowEngine:

; 196  : 			case PilotInputs::Both_Engines:	sprintf(tmp,"Both Engines rpm %5.2f rpm2 %5.2f", af->rpm, af->rpm2); break;

	mov	ecx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1216]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+1212]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CC@HMHCONGA@Both?5Engines?5rpm?5?$CF5?42f?5rpm2?5?$CF5?42@
	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN6@ShowEngine
$LN2@ShowEngine:

; 197  : 			default:	sprintf(tmp,"Unknown");break;

	push	OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
	lea	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN6@ShowEngine:

; 198  : 			}
; 199  : 
; 200  : //			renderer->TextLeft(0.1F,0.9F,tmp);
; 201  : 			renderer->TextLeft (-0.95F, 0.88F, tmp);

	push	0
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 202  : 			
; 203  : 		}
; 204  : 		else

	jmp	SHORT $LN1@ShowEngine
$LN8@ShowEngine:

; 205  : 			showEngine = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32192], 0
$LN1@ShowEngine:

; 206  : 	}
; 207  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowEngine@OTWDriverClass@@AAEXXZ ENDP			; OTWDriverClass::ShowEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
tv87 = -136						; size = 4
_this$ = -132						; size = 4
_af$1 = -128						; size = 4
_posStr$ = -124						; size = 120
__$ArrayPad$ = -4					; size = 4
?ShowFlaps@OTWDriverClass@@AAEXXZ PROC			; OTWDriverClass::ShowFlaps
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 129  :     char posStr[120];
; 130  :     
; 131  : 	//TJL 11/09/03 Removing AOA since AOA is now in HUD for non-F16's
; 132  : 	// Making this always on and with a keystroke to turn it off
; 133  : 	// Human players need to know flap positions and most don't know about
; 134  : 	// g_bShowFlaps.
; 135  :     if(
; 136  : 		otwPlatform && 
; 137  : 		otwPlatform.get() == SimDriver.GetPlayerAircraft() && 
; 138  : 		otwPlatform->IsAirplane()
; 139  : 	){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN1@ShowFlaps
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	esi, eax
	jne	$LN1@ShowFlaps
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN1@ShowFlaps

; 140  : 		AirframeClass *af = ((AircraftClass*)otwPlatform.get())->af;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR _af$1[ebp], ecx

; 141  : 		if (af->HasManualFlaps()) 

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?HasManualFlaps@AirframeClass@@QAE_NXZ	; AirframeClass::HasManualFlaps
	movzx	edx, al
	test	edx, edx
	je	$LN8@ShowFlaps

; 142  : 		{
; 143  : 			renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 144  : 			//TJL 02/28/04 F18 AUTO/HALF/FULL code
; 145  : 			if (af->flapPos == 20)

	mov	eax, DWORD PTR _af$1[ebp]
	cmp	DWORD PTR [eax+836], 20			; 00000014H
	jne	SHORT $LN7@ShowFlaps

; 146  : 			{ 
; 147  : 				sprintf (posStr, "HALF MODE Flaps %3.0f LEFs %3.0f",
; 148  : 				af->TefDegrees(), 
; 149  : 				af->LefDegrees());

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?LefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::LefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?TefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::TefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CB@BKKFLAGM@HALF?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H
	jmp	$LN2@ShowFlaps
$LN7@ShowFlaps:

; 150  : 			}
; 151  : 			else if (af->flapPos == 30)

	mov	edx, DWORD PTR _af$1[ebp]
	cmp	DWORD PTR [edx+836], 30			; 0000001eH
	jne	SHORT $LN5@ShowFlaps

; 152  : 			{
; 153  : 				sprintf (posStr, "FULL MODE Flaps %3.0f LEFs %3.0f",
; 154  : 				af->TefDegrees(), 
; 155  : 				af->LefDegrees());

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?LefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::LefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?TefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::TefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CB@OMALPPEN@FULL?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@
	lea	eax, DWORD PTR _posStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN2@ShowFlaps
$LN5@ShowFlaps:

; 156  : 			}
; 157  : 			else if (af->flapPos == 10)

	mov	ecx, DWORD PTR _af$1[ebp]
	cmp	DWORD PTR [ecx+836], 10			; 0000000aH
	jne	SHORT $LN3@ShowFlaps

; 158  : 			{
; 159  : 				sprintf (posStr, "AUTO MODE Flaps %3.0f LEFs %3.0f",
; 160  : 				af->TefDegrees(), 
; 161  : 				af->LefDegrees());

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?LefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::LefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?TefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::TefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CB@LBDGODBE@AUTO?5MODE?5Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f@
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 162  : 			}
; 163  : 			else

	jmp	SHORT $LN2@ShowFlaps
$LN3@ShowFlaps:

; 164  : 			{
; 165  : 				sprintf (posStr, "Flaps %3.0f LEFs %3.0f",
; 166  : 				af->TefDegrees(), 
; 167  : 				af->LefDegrees());

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?LefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::LefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?TefDegrees@AirframeClass@@QAEMXZ	; AirframeClass::TefDegrees
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BH@PPDDNFH@Flaps?5?$CF3?40f?5LEFs?5?$CF3?40f?$AA@
	lea	eax, DWORD PTR _posStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H
$LN2@ShowFlaps:

; 168  : 			}
; 169  : 			renderer->TextLeft (-0.95F, 0.90F, posStr);

	push	0
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 170  : 		}
; 171  : 		else{

	jmp	SHORT $LN1@ShowFlaps
$LN8@ShowFlaps:

; 172  : 			showFlaps = true;	// Retro 1Feb2004 so that we dont enter here if the ac has no flaps anyway

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32188], 1
$LN1@ShowFlaps:

; 173  : 		}
; 174  :     }
; 175  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowFlaps@OTWDriverClass@@AAEXXZ ENDP			; OTWDriverClass::ShowFlaps
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
tv383 = -152						; size = 4
tv324 = -148						; size = 4
tv348 = -144						; size = 4
tv320 = -140						; size = 4
tv87 = -136						; size = 4
_af$1 = -132						; size = 4
_this$ = -128						; size = 4
_posStr$ = -124						; size = 120
__$ArrayPad$ = -4					; size = 4
?ShowAerodynamics@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::ShowAerodynamics
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 105  :     char posStr[120];
; 106  :     
; 107  :     if(
; 108  : 		otwPlatform && 
; 109  : 		otwPlatform.get() == SimDriver.GetPlayerAircraft() && 
; 110  : 		otwPlatform->IsAirplane()
; 111  : 	)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN1@ShowAerody
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	esi, eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	esi, eax
	jne	$LN1@ShowAerody
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN1@ShowAerody

; 112  : 	{
; 113  : 		AirframeClass *af = ((AircraftClass*)otwPlatform.get())->af;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR _af$1[ebp], ecx

; 114  : 		renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 115  : 		sprintf (posStr, "Cd %8.4f Cl %8.4f Cy %8.4f Mu %8.4f", af->Cd(), af->Cl(), af->Cy(), af->mu);

	mov	ecx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1180]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?Cy@AirframeClass@@QAEMXZ		; AirframeClass::Cy
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?Cl@AirframeClass@@QAEMXZ		; AirframeClass::Cl
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?Cd@AirframeClass@@QAEMXZ		; AirframeClass::Cd
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CE@NALMCJJD@Cd?5?$CF8?44f?5Cl?5?$CF8?44f?5Cy?5?$CF8?44f?5Mu?5?$CF8@
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 40					; 00000028H

; 116  : 		renderer->TextRight (0.95F, 0.65F, posStr);

	push	0
	lea	eax, DWORD PTR _posStr$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f266666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 117  : 		sprintf (posStr, "XDrag %6.4f Thrust %8.1f Mass %8.1f", af->XSAero(), af->Thrust()*af->Mass(), af->Mass());

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?Mass@AirframeClass@@QAEMXZ		; AirframeClass::Mass
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?Thrust@AirframeClass@@QAEMXZ		; AirframeClass::Thrust
	fstp	DWORD PTR tv320[ebp]
	movss	xmm0, DWORD PTR tv320[ebp]
	mov	ecx, DWORD PTR _af$1[ebp]
	movss	DWORD PTR tv383[ebp], xmm0
	call	?Mass@AirframeClass@@QAEMXZ		; AirframeClass::Mass
	fstp	DWORD PTR tv324[ebp]
	movss	xmm0, DWORD PTR tv383[ebp]
	mulss	xmm0, DWORD PTR tv324[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?XSAero@AirframeClass@@QAEMXZ		; AirframeClass::XSAero
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CE@NALPMFDE@XDrag?5?$CF6?44f?5Thrust?5?$CF8?41f?5Mass?5?$CF8@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 32					; 00000020H

; 118  : 		renderer->TextRight (0.95F, 0.60F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 119  : 		sprintf (posStr, "AoABias %5.2f Lift %5.2f Down %6.4f", af->AOABias(), -af->ZSAero(), af->ZSProp());

	mov	ecx, DWORD PTR _af$1[ebp]
	call	?ZSProp@AirframeClass@@QAEMXZ		; AirframeClass::ZSProp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?ZSAero@AirframeClass@@QAEMXZ		; AirframeClass::ZSAero
	fstp	DWORD PTR tv348[ebp]
	movss	xmm0, DWORD PTR tv348[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _af$1[ebp]
	call	?AOABias@AirframeClass@@QAEMXZ		; AirframeClass::AOABias
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CE@EMHHJKOE@AoABias?5?$CF5?42f?5Lift?5?$CF5?42f?5Down?5?$CF6@
	lea	eax, DWORD PTR _posStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 32					; 00000020H

; 120  : 		renderer->TextRight (0.95F, 0.55F, posStr);

	push	0
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 121  : 		sprintf (posStr, "AOA %5.2f Tef %10.4f Lef %10.4f", af->alpha, af->tefFactor, af->lefFactor);

	mov	ecx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1240]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+1236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _af$1[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1152]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CA@LOCKLHGF@AOA?5?$CF5?42f?5Tef?5?$CF10?44f?5Lef?5?$CF10?44f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 32					; 00000020H

; 122  : 		renderer->TextRight (0.95F, 0.50F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx
$LN1@ShowAerody:

; 123  : 	}
; 124  : 	
; 125  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowAerodynamics@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::ShowAerodynamics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
tv302 = -68						; size = 4
tv287 = -64						; size = 4
tv362 = -60						; size = 4
tv347 = -56						; size = 4
tv332 = -52						; size = 4
_this$ = -48						; size = 4
_posStr$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
?ShowPosition@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::ShowPosition
; _this$ = ecx

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 73   : char posStr[40];
; 74   : 
; 75   :    renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 76   :    sprintf (posStr, "      X = %10.2f", flyingEye->XPos() / FEET_PER_KM);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv287[ebp]
	movss	xmm0, DWORD PTR tv287[ebp]
	divss	xmm0, DWORD PTR __real@454cffae
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@ONGNLEIL@?5?5?5?5?5?5X?5?$DN?5?$CF10?42f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 77   :    renderer->TextRight (0.95F, 0.95F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 78   :    sprintf (posStr, "      Y = %10.2f", flyingEye->YPos() / FEET_PER_KM);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv302[ebp]
	movss	xmm0, DWORD PTR tv302[ebp]
	divss	xmm0, DWORD PTR __real@454cffae
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@CMODGLEL@?5?5?5?5?5?5Y?5?$DN?5?$CF10?42f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 79   :    renderer->TextRight (0.95F, 0.90F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 80   :    sprintf (posStr, "      Z = %10.2f", flyingEye->ZPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BB@LFABANEK@?5?5?5?5?5?5Z?5?$DN?5?$CF10?42f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 81   :    renderer->TextRight (0.95F, 0.85F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 82   :    sprintf (posStr, "Heading = %10.2f", flyingEye->Yaw() * RTD);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv332[ebp]
	movss	xmm0, DWORD PTR tv332[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@FPHCBPPP@Heading?5?$DN?5?$CF10?42f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 83   :    renderer->TextRight (0.95F, 0.80F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 84   :    sprintf (posStr, "  Pitch = %10.2f", flyingEye->Pitch() * RTD);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv347[ebp]
	movss	xmm0, DWORD PTR tv347[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@KCHKBFGN@?5?5Pitch?5?$DN?5?$CF10?42f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 85   :    renderer->TextRight (0.95F, 0.75F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 86   :    sprintf (posStr, "   Roll = %10.2f", flyingEye->Roll() * RTD); // 2002-01-31 ADDED BY S.G. Added roll to the readout

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv362[ebp]
	movss	xmm0, DWORD PTR tv362[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@NBELEFBC@?5?5?5Roll?5?$DN?5?$CF10?42f?$AA@
	lea	ecx, DWORD PTR _posStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 87   :    renderer->TextRight (0.95F, 0.70F, posStr);

	push	0
	lea	edx, DWORD PTR _posStr$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 88   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowPosition@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::ShowPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_this$ = -32						; size = 4
_verStr$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?ShowVersionString@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::ShowVersionString
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 61   : char verStr[24];
; 62   : 
; 63   :    if (ShowVersion == 1)

	cmp	DWORD PTR ?ShowVersion@@3HA, 1		; ShowVersion
	jne	SHORT $LN2@ShowVersio

; 64   :       sprintf (verStr, "%d.%02d", MajorVersion, MinorVersion);

	mov	eax, DWORD PTR ?MinorVersion@@3HA	; MinorVersion
	push	eax
	mov	ecx, DWORD PTR ?MajorVersion@@3HA	; MajorVersion
	push	ecx
	push	OFFSET ??_C@_07LGGAIHJM@?$CFd?4?$CF02d?$AA@
	lea	edx, DWORD PTR _verStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 65   :    else

	jmp	SHORT $LN1@ShowVersio
$LN2@ShowVersio:

; 66   :       sprintf (verStr, "%d.%02d%d%c", MajorVersion, MinorVersion, gLangIDNum);

	mov	eax, DWORD PTR ?gLangIDNum@@3HA		; gLangIDNum
	push	eax
	mov	ecx, DWORD PTR ?MinorVersion@@3HA	; MinorVersion
	push	ecx
	mov	edx, DWORD PTR ?MajorVersion@@3HA	; MajorVersion
	push	edx
	push	OFFSET ??_C@_0M@JJCAFCEI@?$CFd?4?$CF02d?$CFd?$CFc?$AA@
	lea	eax, DWORD PTR _verStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
$LN1@ShowVersio:

; 67   :    renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 68   :    renderer->TextCenter (-0.9F, 0.9F, verStr);

	push	0
	lea	ecx, DWORD PTR _verStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 69   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowVersionString@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::ShowVersionString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetEyePosition@OTWDriverClass@@QAE?AUTpoint@@XZ PROC	; OTWDriverClass::GetEyePosition
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 	Tpoint	pos;
; 95   : 
; 96   : 	pos.x=flyingEye->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32348]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _pos$[ebp]

; 97   : 	pos.y=flyingEye->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32348]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _pos$[ebp+4]

; 98   : 	pos.z=flyingEye->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32348]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _pos$[ebp+8]

; 99   : 
; 100  : 	return(pos);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _pos$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _pos$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?GetEyePosition@OTWDriverClass@@QAE?AUTpoint@@XZ ENDP	; OTWDriverClass::GetEyePosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z PROC		; OTWDriverClass::SetEndFlightVec, COMDAT
; _this$ = ecx

; 468  : 	  {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 		  endFlightVec.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+33528], xmm0

; 470  : 		  endFlightVec.y = y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+33532], xmm0

; 471  : 		  endFlightVec.z = z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [edx+33536], xmm0

; 472  : 	  }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ENDP		; OTWDriverClass::SetEndFlightVec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z
_TEXT	SEGMENT
_Z$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z PROC	; OTWDriverClass::SetEndFlightPoint, COMDAT
; _this$ = ecx

; 456  : 	  {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		  endFlightPoint.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+33516], xmm0

; 458  : 		  endFlightPoint.y = y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+33520], xmm0

; 459  : 		  endFlightPoint.z = z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [edx+33524], xmm0

; 460  : 		  endFlightPointSet = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33552], 1

; 461  : 	      float Z = GetGroundLevel( x, y );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _Z$[ebp]

; 462  : 		  if ( z + 50.0f > Z )

	movss	xmm0, DWORD PTR _z$[ebp]
	addss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR _Z$[ebp]
	jbe	SHORT $LN1@SetEndFlig

; 463  : 			  endFlightPoint.z = Z - 50.0f;

	movss	xmm0, DWORD PTR _Z$[ebp]
	subss	xmm0, DWORD PTR __real@42480000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+33524], xmm0
$LN1@SetEndFlig:

; 464  : 
; 465  : 	  }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ENDP	; OTWDriverClass::SetEndFlightPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_yRes$ = -28						; size = 4
_xRes$ = -24						; size = 4
_passThru$ = -20					; size = 4
_logicalX$ = -16					; size = 4
_this$ = -12						; size = 4
_key$ = -8						; size = 4
_logicalY$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?HandleMouseClick@OTWDriverClass@@QAEHJJ@Z PROC		; OTWDriverClass::HandleMouseClick
; _this$ = ecx

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 	int key = 0;

	mov	DWORD PTR _key$[ebp], 0

; 558  : 	float xRes = (float)renderer->GetXRes();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	call	?GetXRes@VirtualDisplay@@QAEHXZ		; VirtualDisplay::GetXRes
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _xRes$[ebp], xmm0

; 559  : 	float yRes = (float)renderer->GetYRes();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?GetYRes@VirtualDisplay@@QAEHXZ		; VirtualDisplay::GetYRes
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _yRes$[ebp], xmm0

; 560  : 	float logicalX, logicalY;
; 561  : 	int	passThru = TRUE;

	mov	DWORD PTR _passThru$[ebp], 1

; 562  : 
; 563  : 	if(InExitMenu()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InExitMenu@OTWDriverClass@@QAEHXZ	; OTWDriverClass::InExitMenu
	test	eax, eax
	je	$LN1@HandleMous

; 564  : 
; 565  : 		passThru = FALSE;

	mov	DWORD PTR _passThru$[ebp], 0

; 566  : 
; 567  : 		// Correct for screen resolution
; 568  : 		logicalX = (float)x / xRes;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR _xRes$[ebp]
	movss	DWORD PTR _logicalX$[ebp], xmm0

; 569  : 		logicalY = (float)y / yRes;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	divss	xmm0, DWORD PTR _yRes$[ebp]
	movss	DWORD PTR _logicalY$[ebp], xmm0

; 570  : 
; 571  : 		if (logicalX >= 230.0F/640.0F && logicalX <= 250.0F/640.0F)

	movss	xmm0, DWORD PTR _logicalX$[ebp]
	comiss	xmm0, DWORD PTR __real@3eb80000
	jb	$LN2@HandleMous
	movss	xmm0, DWORD PTR __real@3ec80000
	comiss	xmm0, DWORD PTR _logicalX$[ebp]
	jb	$LN2@HandleMous

; 572  : 		{
; 573  : 			if (logicalY >= 200.0F/480.0F && logicalY <= 220.0F/480.0F && endsAvail[0])

	movss	xmm0, DWORD PTR _logicalY$[ebp]
	comiss	xmm0, DWORD PTR __real@3ed55555
	jb	SHORT $LN6@HandleMous
	movss	xmm0, DWORD PTR __real@3eeaaaab
	comiss	xmm0, DWORD PTR _logicalY$[ebp]
	jb	SHORT $LN6@HandleMous
	mov	edx, 4
	imul	edx, 0
	cmp	DWORD PTR ?endsAvail@@3PAHA[edx], 0
	je	SHORT $LN6@HandleMous

; 574  : 			{
; 575  : 				key = DIK_E;

	mov	DWORD PTR _key$[ebp], 18		; 00000012H
	jmp	SHORT $LN2@HandleMous
$LN6@HandleMous:

; 576  : 			}
; 577  : 			else if (logicalY >= 235.0F/480.0F && logicalY <= 255.0F/480.0F && endsAvail[1])

	movss	xmm0, DWORD PTR _logicalY$[ebp]
	comiss	xmm0, DWORD PTR __real@3efaaaab
	jb	SHORT $LN4@HandleMous
	movss	xmm0, DWORD PTR __real@3f080000
	comiss	xmm0, DWORD PTR _logicalY$[ebp]
	jb	SHORT $LN4@HandleMous
	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR ?endsAvail@@3PAHA[eax], 0
	je	SHORT $LN4@HandleMous

; 578  : 			{
; 579  : 				key = DIK_R;

	mov	DWORD PTR _key$[ebp], 19		; 00000013H
	jmp	SHORT $LN2@HandleMous
$LN4@HandleMous:

; 580  : 			}
; 581  : 			else if (logicalY >= 270.0F/480.0F && logicalY <= 290.0F/480.0F && endsAvail[2])

	movss	xmm0, DWORD PTR _logicalY$[ebp]
	comiss	xmm0, DWORD PTR __real@3f100000
	jb	SHORT $LN2@HandleMous
	movss	xmm0, DWORD PTR __real@3f1aaaab
	comiss	xmm0, DWORD PTR _logicalY$[ebp]
	jb	SHORT $LN2@HandleMous
	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR ?endsAvail@@3PAHA[ecx], 0
	je	SHORT $LN2@HandleMous

; 582  : 			{
; 583  : 				key = DIK_D;

	mov	DWORD PTR _key$[ebp], 32		; 00000020H
$LN2@HandleMous:

; 584  : 			}
; 585  : 		}
; 586  : 
; 587  : 		if (key){

	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN1@HandleMous

; 588  : 			ExitMenu(key);

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExitMenu@OTWDriverClass@@QAEXK@Z	; OTWDriverClass::ExitMenu
$LN1@HandleMous:

; 589  : 		}
; 590  : 	}
; 591  : 
; 592  : 	return passThru;

	mov	eax, DWORD PTR _passThru$[ebp]

; 593  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HandleMouseClick@OTWDriverClass@@QAEHJJ@Z ENDP		; OTWDriverClass::HandleMouseClick
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CancelExitMenuCountdown@OTWDriverClass@@QAEXXZ PROC	; OTWDriverClass::CancelExitMenuCountdown
; _this$ = ecx

; 690  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 691  : 	exitMenuTimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33548], 0

; 692  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?CancelExitMenuCountdown@OTWDriverClass@@QAEXXZ ENDP	; OTWDriverClass::CancelExitMenuCountdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartExitMenuCountdown@OTWDriverClass@@QAEXXZ PROC	; OTWDriverClass::StartExitMenuCountdown
; _this$ = ecx

; 685  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 	exitMenuTimer = vuxRealTime + EXITMENU_POPUP_TIME;

	mov	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	add	eax, 15000				; 00003a98H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33548], eax

; 687  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?StartExitMenuCountdown@OTWDriverClass@@QAEXXZ ENDP	; OTWDriverClass::StartExitMenuCountdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?InExitMenu@OTWDriverClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InExitMenu@OTWDriverClass@@QAEHXZ PROC			; OTWDriverClass::InExitMenu, COMDAT
; _this$ = ecx

; 448  :       int InExitMenu (void) {return exitMenuOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32208]
	mov	esp, ebp
	pop	ebp
	ret	0
?InExitMenu@OTWDriverClass@@QAEHXZ ENDP			; OTWDriverClass::InExitMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
$T2 = -68						; size = 4
tv147 = -64						; size = 4
tv133 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
tv86 = -48						; size = 4
$T5 = -44						; size = 4
tv76 = -40						; size = 4
_this$ = -36						; size = 4
_texSet$ = -32						; size = 4
_pos$6 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_newVal$ = 8						; size = 4
?ChangeExitMenu@OTWDriverClass@@QAEXH@Z PROC		; OTWDriverClass::ChangeExitMenu
; _this$ = ecx

; 624  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 625  : int texSet;
; 626  : 
; 627  : 	if (newVal == TRUE)

	cmp	DWORD PTR _newVal$[ebp], 1
	jne	$LN14@ChangeExit

; 628  :    {
; 629  :       // if already set end now
; 630  :       if ( endFlightTimer)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+33540], 0
	je	SHORT $LN13@ChangeExit

; 631  :       {
; 632  :    	   endFlightTimer = vuxRealTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	mov	DWORD PTR [ecx+33540], edx

; 633  :          newVal = FALSE;

	mov	DWORD PTR _newVal$[ebp], 0
	jmp	$LN11@ChangeExit
$LN13@ChangeExit:

; 634  :       }
; 635  :       else if (!endDialogObject)

	cmp	DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A, 0 ; endDialogObject
	jne	$LN11@ChangeExit

; 636  :       {
; 637  : 				Tpoint	pos = {4.0f, 0.f, 0.0f };

	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR _pos$6[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _pos$6[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _pos$6[ebp+8], xmm0

; 638  :          pos.x *= (60.0F * DTR) / GetFOV();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv147[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	divss	xmm0, DWORD PTR tv147[ebp]
	mulss	xmm0, DWORD PTR _pos$6[ebp]
	movss	DWORD PTR _pos$6[ebp], xmm0

; 639  : 			endDialogObject = new DrawableBSP(MapVisId(VIS_END_MISSION), &pos, &IMatrix, 1.0f );

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN17@ChangeExit
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?IMatrix@@3UTrotation@@B		; IMatrix
	lea	eax, DWORD PTR _pos$6[ebp]
	push	eax
	push	4
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z ; DrawableBSP::DrawableBSP
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN18@ChangeExit
$LN17@ChangeExit:
	mov	DWORD PTR tv86[ebp], 0
$LN18@ChangeExit:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A, edx ; endDialogObject

; 640  : 
; 641  :          switch (gLangIDNum)

	mov	eax, DWORD PTR ?gLangIDNum@@3HA		; gLangIDNum
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 6
	ja	SHORT $LN2@ChangeExit
	mov	edx, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN23@ChangeExit[edx*4]
$LN8@ChangeExit:

; 642  :          {
; 643  :             case F4LANG_UK:               // UK
; 644  :             case F4LANG_ENGLISH:          // US
; 645  :                texSet = 0;

	mov	DWORD PTR _texSet$[ebp], 0

; 646  :             break;

	jmp	SHORT $LN9@ChangeExit
$LN7@ChangeExit:

; 647  : 
; 648  :             case F4LANG_GERMAN:           // DE
; 649  :                texSet = 1;

	mov	DWORD PTR _texSet$[ebp], 1

; 650  :             break;

	jmp	SHORT $LN9@ChangeExit
$LN6@ChangeExit:

; 651  : 
; 652  :             case F4LANG_FRENCH:           // FR
; 653  :                texSet = 2;

	mov	DWORD PTR _texSet$[ebp], 2

; 654  :             break;

	jmp	SHORT $LN9@ChangeExit
$LN5@ChangeExit:

; 655  : 
; 656  : 		      case F4LANG_SPANISH:
; 657  :    				texSet = 3;

	mov	DWORD PTR _texSet$[ebp], 3

; 658  :             break;

	jmp	SHORT $LN9@ChangeExit
$LN4@ChangeExit:

; 659  : 
; 660  : 		      case F4LANG_ITALIAN:
; 661  :    				texSet = 4;

	mov	DWORD PTR _texSet$[ebp], 4

; 662  :             break;

	jmp	SHORT $LN9@ChangeExit
$LN3@ChangeExit:

; 663  : 
; 664  : 		      case F4LANG_PORTUGESE:
; 665  :    				texSet = 5;

	mov	DWORD PTR _texSet$[ebp], 5

; 666  :             break;

	jmp	SHORT $LN9@ChangeExit
$LN2@ChangeExit:

; 667  : 
; 668  :             default:
; 669  :                texSet = 0;

	mov	DWORD PTR _texSet$[ebp], 0
$LN9@ChangeExit:

; 670  :             break;
; 671  :          }
; 672  :          endDialogObject->SetTextureSet(texSet);

	mov	eax, DWORD PTR _texSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	call	?SetTextureSet@DrawableBSP@@QAEXK@Z	; DrawableBSP::SetTextureSet
$LN11@ChangeExit:

; 673  : 		}
; 674  : 	}
; 675  :    else

	jmp	SHORT $LN1@ChangeExit
$LN14@ChangeExit:

; 676  :    {
; 677  : 		delete endDialogObject;

	mov	ecx, DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A ; endDialogObject
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN19@ChangeExit
	push	1
	mov	eax, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN20@ChangeExit
$LN19@ChangeExit:
	mov	DWORD PTR tv133[ebp], 0
$LN20@ChangeExit:

; 678  : 		endDialogObject = NULL;

	mov	DWORD PTR ?endDialogObject@@3PAVDrawableBSP@@A, 0 ; endDialogObject
$LN1@ChangeExit:

; 679  : 	}
; 680  : 
; 681  : 	exitMenuOn = newVal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [ecx+32208], edx

; 682  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN23@ChangeExit:
	DD	$LN8@ChangeExit
	DD	$LN8@ChangeExit
	DD	$LN7@ChangeExit
	DD	$LN6@ChangeExit
	DD	$LN5@ChangeExit
	DD	$LN4@ChangeExit
	DD	$LN3@ChangeExit
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChangeExitMenu@OTWDriverClass@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangeExitMenu@OTWDriverClass@@QAEXH@Z ENDP		; OTWDriverClass::ChangeExitMenu
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newVal$ = 8						; size = 4
?SetExitMenu@OTWDriverClass@@QAEXH@Z PROC		; OTWDriverClass::SetExitMenu
; _this$ = ecx

; 599  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 600  : 	static bool lastclickablepitmode = clickableMouseMode;

	mov	eax, DWORD PTR ?$S1@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4IA
	and	eax, 1
	jne	SHORT $LN3@SetExitMen
	mov	ecx, DWORD PTR ?$S1@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4IA, ecx
	mov	dl, BYTE PTR ?clickableMouseMode@@3_NA	; clickableMouseMode
	mov	BYTE PTR ?lastclickablepitmode@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4_NA, dl
$LN3@SetExitMen:

; 601  : 
; 602  : 	if (newVal==TRUE)

	cmp	DWORD PTR _newVal$[ebp], 1
	jne	SHORT $LN2@SetExitMen

; 603  : 	{
; 604  : 
; 605  : 
; 606  : 		//Wombat778 3-26-04 Moved all this crap to DrawExitMenu and made the change ONLY affect the drawing of the exit menu.
; 607  : 		//Retro25Mar2004		OTWDriver.SetFOV( 60.0f * DTR );									//Wombat778 11-2-2003	Added so that exit dialog box is the right size on exit
; 608  : 		//OTWDriver.SetFOV( 45.0f * DTR );	// Retro 25Mar2004 - nailed it down to 45 for now, so that text is readable again
; 609  : 		lastclickablepitmode = clickableMouseMode;

	mov	al, BYTE PTR ?clickableMouseMode@@3_NA	; clickableMouseMode
	mov	BYTE PTR ?lastclickablepitmode@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4_NA, al

; 610  : 		clickableMouseMode = true;

	mov	BYTE PTR ?clickableMouseMode@@3_NA, 1	; clickableMouseMode

; 611  : 		MouseMenuActive = true;	// Retro 15Feb2004

	mov	BYTE PTR ?MouseMenuActive@@3_NA, 1	; MouseMenuActive

; 612  : 	}
; 613  : 	else

	jmp	SHORT $LN1@SetExitMen
$LN2@SetExitMen:

; 614  : 	{
; 615  : 		clickableMouseMode = lastclickablepitmode;

	mov	cl, BYTE PTR ?lastclickablepitmode@?1??SetExitMenu@OTWDriverClass@@QAEXH@Z@4_NA
	mov	BYTE PTR ?clickableMouseMode@@3_NA, cl	; clickableMouseMode

; 616  : 		MouseMenuActive = false;	// Retro 15Feb2004

	mov	BYTE PTR ?MouseMenuActive@@3_NA, 0	; MouseMenuActive
$LN1@SetExitMen:

; 617  : 	}
; 618  : 
; 619  : 	exitMenuDesired = newVal;

	mov	edx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR _exitMenuDesired, edx

; 620  : 	exitMenuTimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33548], 0

; 621  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetExitMenu@OTWDriverClass@@QAEXH@Z ENDP		; OTWDriverClass::SetExitMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
tv319 = -60						; size = 4
tv312 = -56						; size = 4
tv344 = -52						; size = 4
tv297 = -48						; size = 4
tv342 = -44						; size = 4
tv286 = -40						; size = 4
tv340 = -36						; size = 4
tv280 = -32						; size = 4
tv338 = -28						; size = 4
tv269 = -24						; size = 4
tv336 = -20						; size = 4
tv263 = -16						; size = 4
tv334 = -12						; size = 4
tv252 = -8						; size = 4
_this$ = -4						; size = 4
?Timeout@OTWDriverClass@@QAEXXZ PROC			; OTWDriverClass::Timeout
; _this$ = ecx

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	SetExitMenu( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetExitMenu@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::SetExitMenu

; 425  : 
; 426  : 	// See if we were already on the way out...
; 427  : 	if (endFlightTimer)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+33540], 0
	je	SHORT $LN6@Timeout

; 428  : 	{
; 429  : 		// Just ignore this case - we are exiting and that's all we care about
; 430  : 	}
; 431  : 	else

	jmp	SHORT $LN5@Timeout
$LN6@Timeout:

; 432  : 	{
; 433  : 		// end in 5 seconds
; 434  : 		endFlightTimer = vuxRealTime + 5000;

	mov	ecx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	add	ecx, 5000				; 00001388H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+33540], ecx

; 435  : 		ResetVoices();

	call	?ResetVoices@@YAXXZ			; ResetVoices
$LN5@Timeout:

; 436  : 	}
; 437  : 	
; 438  : 	// no hud when ending flight -- may want to make sure other stuff
; 439  : 	// isn't set too....
; 440  : 	SetOTWDisplayMode(ModeNone);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 441  : 	
; 442  : 	// Get out of eyeFly if we were in it
; 443  : 	if (eyeFly)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32200], 0
	je	SHORT $LN4@Timeout

; 444  : 	{
; 445  : #if 1
; 446  : 		ToggleEyeFly();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleEyeFly@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleEyeFly
$LN4@Timeout:

; 447  : #else
; 448  : 		otwPlatform = lastotwPlatform;
; 449  : 		lastotwPlatform = NULL;
; 450  : 		eyeFly = FALSE;
; 451  : #endif
; 452  : 	}
; 453  : 
; 454  : 	// if we've got an otwplatform (ie the f16) jump out ahead of it for
; 455  : 	// a ways to get a fly-by effect
; 456  : 	if ( endFlightPointSet == FALSE )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33552], 0
	jne	$LN1@Timeout

; 457  : 	{
; 458  : 		if ( otwPlatform.get() != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	test	eax, eax
	je	$LN2@Timeout

; 459  : 		{
; 460  : //			MonoPrint ("Panning exit\n");
; 461  : 			SetEndFlightPoint( otwPlatform->XPos() + otwPlatform->dmx[0][0] * 10.0f + otwPlatform->XDelta() * 2.0f,
; 462  : 							   otwPlatform->YPos() + otwPlatform->dmx[0][1] * 10.0f + otwPlatform->YDelta() * 2.0f,
; 463  : 							   otwPlatform->ZPos() + otwPlatform->dmx[0][2] * 10.0f + otwPlatform->ZDelta() * 2.0f - 20.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv252[ebp]
	movss	xmm0, DWORD PTR tv252[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv334[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR tv334[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv336[ebp], xmm1
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR tv263[ebp]
	movss	xmm0, DWORD PTR tv263[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv336[ebp]
	addss	xmm1, xmm0
	subss	xmm1, DWORD PTR __real@41a00000
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv269[ebp]
	movss	xmm0, DWORD PTR tv269[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv338[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR tv338[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv340[ebp], xmm1
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv280[ebp]
	movss	xmm0, DWORD PTR tv280[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv340[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv286[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv342[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR tv342[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv344[ebp], xmm1
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv297[ebp]
	movss	xmm0, DWORD PTR tv297[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv344[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightPoint

; 464  : 			SetEndFlightVec(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightVec

; 465  : 		}
; 466  : 		else

	jmp	$LN1@Timeout
$LN2@Timeout:

; 467  : 		{
; 468  : //          MonoPrint ("Fixed exit\n");
; 469  : 			// not otwplatform, use last focus point with some randomness...
; 470  : 			SetEndFlightPoint(	focusPoint.x + 100.0f * PRANDFloat(), 
; 471  : 								focusPoint.y + 100.0f * PRANDFloat(), 
; 472  : 								focusPoint.z - 100.0f );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+33436]
	subss	xmm0, DWORD PTR __real@42c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv312[ebp]
	movss	xmm0, DWORD PTR tv312[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+33432]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv319[ebp]
	movss	xmm0, DWORD PTR tv319[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+33428]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightPoint

; 473  : 			SetEndFlightVec(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightVec
$LN1@Timeout:

; 474  : 		}
; 475  : 	}
; 476  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Timeout@OTWDriverClass@@QAEXXZ ENDP			; OTWDriverClass::Timeout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\menus.cpp
_TEXT	SEGMENT
tv370 = -60						; size = 4
tv363 = -56						; size = 4
tv402 = -52						; size = 4
tv348 = -48						; size = 4
tv400 = -44						; size = 4
tv337 = -40						; size = 4
tv398 = -36						; size = 4
tv331 = -32						; size = 4
tv396 = -28						; size = 4
tv320 = -24						; size = 4
tv394 = -20						; size = 4
tv314 = -16						; size = 4
tv392 = -12						; size = 4
tv303 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?ExitMenu@OTWDriverClass@@QAEXK@Z PROC			; OTWDriverClass::ExitMenu
; _this$ = ecx

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 480  :    if (i == DIK_ESCAPE)

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN17@ExitMenu

; 481  :    {
; 482  :       SetExitMenu( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetExitMenu@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::SetExitMenu
	jmp	$LN2@ExitMenu
$LN17@ExitMenu:

; 483  :    }
; 484  :    else if ((i == DIK_E && endsAvail[0]) || (i == DIK_D && endsAvail[2]))

	cmp	DWORD PTR _i$[ebp], 18			; 00000012H
	jne	SHORT $LN13@ExitMenu
	mov	eax, 4
	imul	eax, 0
	cmp	DWORD PTR ?endsAvail@@3PAHA[eax], 0
	jne	SHORT $LN14@ExitMenu
$LN13@ExitMenu:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jne	$LN15@ExitMenu
	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR ?endsAvail@@3PAHA[ecx], 0
	je	$LN15@ExitMenu
$LN14@ExitMenu:

; 485  :    {
; 486  :      g_intellivibeData.IsEndFlight = true;

	mov	BYTE PTR ?g_intellivibeData@@3VIntellivibeData@@A+13, 1

; 487  : 		 memcpy (gSharedIntellivibe, &g_intellivibeData, sizeof(g_intellivibeData));

	push	52					; 00000034H
	push	OFFSET ?g_intellivibeData@@3VIntellivibeData@@A ; g_intellivibeData
	mov	edx, DWORD PTR ?gSharedIntellivibe@@3PAXA ; gSharedIntellivibe
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 488  : 
; 489  :      if (i == DIK_D || tactical_is_training())

	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	je	SHORT $LN11@ExitMenu
	call	?tactical_is_training@@YAHXZ		; tactical_is_training
	test	eax, eax
	je	SHORT $LN12@ExitMenu
$LN11@ExitMenu:

; 490  :          endAbort = TRUE;

	mov	DWORD PTR ?endAbort@@3HA, 1		; endAbort
$LN12@ExitMenu:

; 491  : 
; 492  :       SetExitMenu( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetExitMenu@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::SetExitMenu

; 493  : 
; 494  :       // if already set end now
; 495  :       if ( endFlightTimer || !gameCompressionRatio )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+33540], 0
	jne	SHORT $LN9@ExitMenu
	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 0	; gameCompressionRatio
	jne	SHORT $LN10@ExitMenu
$LN9@ExitMenu:

; 496  :       {
; 497  :    	   endFlightTimer = vuxRealTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	mov	DWORD PTR [ecx+33540], edx

; 498  :       }
; 499  :       else

	jmp	SHORT $LN8@ExitMenu
$LN10@ExitMenu:

; 500  :       {
; 501  :          // end in 5 seconds
; 502  :          endFlightTimer = vuxRealTime + 5000;

	mov	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	add	eax, 5000				; 00001388H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33540], eax

; 503  : 		 ResetVoices();

	call	?ResetVoices@@YAXXZ			; ResetVoices
$LN8@ExitMenu:

; 504  :       }
; 505  : 
; 506  :        // no hud when ending flight -- may want to make sure other stuff
; 507  :       // isn't set too....
; 508  :       SetOTWDisplayMode(ModeChase);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOTWDisplayMode@OTWDriverClass@@QAEXW4OTWDisplayMode@1@@Z ; OTWDriverClass::SetOTWDisplayMode

; 509  : 
; 510  :       // if we've got an otwplatform (ie the f16) jump out ahead of it for
; 511  :       // a ways to get a fly-by effect
; 512  :       if ( endFlightPointSet == FALSE )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33552], 0
	jne	$LN5@ExitMenu

; 513  :       {
; 514  : 	      if ( otwPlatform )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN6@ExitMenu

; 515  : 	      {
; 516  : //			   MonoPrint ("Panning exit\n");
; 517  : 			   SetEndFlightPoint( otwPlatform->XPos() + otwPlatform->dmx[0][0] * 10.0f + otwPlatform->XDelta() * 2.0f,
; 518  : 			                      otwPlatform->YPos() + otwPlatform->dmx[0][1] * 10.0f + otwPlatform->YDelta() * 2.0f,
; 519  : 			                      otwPlatform->ZPos() + otwPlatform->dmx[0][2] * 10.0f + otwPlatform->ZDelta() * 2.0f - 20.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv303[ebp]
	movss	xmm0, DWORD PTR tv303[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv392[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR tv392[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv394[ebp], xmm1
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR tv314[ebp]
	movss	xmm0, DWORD PTR tv314[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv394[ebp]
	addss	xmm1, xmm0
	subss	xmm1, DWORD PTR __real@41a00000
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv320[ebp]
	movss	xmm0, DWORD PTR tv320[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv396[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR tv396[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv398[ebp], xmm1
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv331[ebp]
	movss	xmm0, DWORD PTR tv331[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv398[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv337[ebp]
	movss	xmm0, DWORD PTR tv337[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv400[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	xmm1, DWORD PTR tv400[ebp]
	addss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	movss	DWORD PTR tv402[ebp], xmm1
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv348[ebp]
	movss	xmm0, DWORD PTR tv348[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv402[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightPoint

; 520  : 			   SetEndFlightVec(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightVec

; 521  : 	      }
; 522  : 	      else

	jmp	$LN5@ExitMenu
$LN6@ExitMenu:

; 523  : 	      {
; 524  : //          MonoPrint ("Fixed exit\n");
; 525  : 		       // not otwplatform, use last focus point with some randomness...
; 526  :                SetEndFlightPoint(focusPoint.x + 100.0f * PRANDFloat(), focusPoint.y + 100.0f * PRANDFloat(), focusPoint.z - 100.0f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33436]
	subss	xmm0, DWORD PTR __real@42c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv363[ebp]
	movss	xmm0, DWORD PTR tv363[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+33432]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv370[ebp]
	movss	xmm0, DWORD PTR tv370[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+33428]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightPoint

; 527  :                SetEndFlightVec(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightVec
$LN5@ExitMenu:

; 528  : 	      }
; 529  :       }
; 530  : 
; 531  :       if (eyeFly)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32200], 0
	je	SHORT $LN4@ExitMenu

; 532  :       {
; 533  : #if 1
; 534  : 		ToggleEyeFly();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleEyeFly@OTWDriverClass@@QAEXXZ	; OTWDriverClass::ToggleEyeFly
$LN4@ExitMenu:

; 535  : #else
; 536  : 		otwPlatform = lastotwPlatform;
; 537  : 		lastotwPlatform = NULL;
; 538  : 		eyeFly = FALSE;
; 539  : #endif
; 540  :       }
; 541  :    }

	jmp	SHORT $LN2@ExitMenu
$LN15@ExitMenu:

; 542  :    else if (i == DIK_R && endsAvail[1])

	cmp	DWORD PTR _i$[ebp], 19			; 00000013H
	jne	SHORT $LN2@ExitMenu
	mov	edx, 4
	shl	edx, 0
	cmp	DWORD PTR ?endsAvail@@3PAHA[edx], 0
	je	SHORT $LN2@ExitMenu

; 543  :    {
; 544  : 	   // Start E3 HACK
; 545  : 	   if (SimDriver.RunningInstantAction () && SimDriver.GetPlayerAircraft() && SimDriver.GetPlayerAircraft()->IsSetFlag (MOTION_OWNSHIP))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningInstantAction@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningInstantAction
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@ExitMenu
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN1@ExitMenu
	push	65536					; 00010000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN1@ExitMenu

; 546  : 	   {
; 547  : 		   SimDriver.GetPlayerAircraft()->ResetFuel ();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ResetFuel@AircraftClass@@QAEXXZ	; AircraftClass::ResetFuel
$LN1@ExitMenu:

; 548  : 	   }
; 549  : 	   // End E3 HACK
; 550  : 
; 551  : 	   SetExitMenu( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetExitMenu@OTWDriverClass@@QAEXH@Z	; OTWDriverClass::SetExitMenu
$LN2@ExitMenu:

; 552  :    }
; 553  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ExitMenu@OTWDriverClass@@QAEXK@Z ENDP			; OTWDriverClass::ExitMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 132  : {

	push	ebp
	mov	ebp, esp

; 133  :     return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__time64
	add	esp, 4

; 134  : }

	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC

; 113  : {

	push	ebp
	mov	ebp, esp

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__localtime64
	add	esp, 4

; 117  : #pragma warning( pop )
; 118  : }

	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
END
