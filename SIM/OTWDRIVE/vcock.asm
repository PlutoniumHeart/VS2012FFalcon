; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\OTWDRIVE\vcock.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?HudScale@@3MA					; HudScale
PUBLIC	?CXX@@3MA					; CXX
PUBLIC	?CXY@@3MA					; CXY
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?resScale@@3MA					; resScale
PUBLIC	?DEDw@@3MA					; DEDw
PUBLIC	?DEDh@@3MA					; DEDh
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?BobbingRollRate@@3MA				; BobbingRollRate
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?BobbingTilt@@3MA				; BobbingTilt
PUBLIC	?BobbingPan@@3MA				; BobbingPan
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?bRTTTarget@@3_NA				; bRTTTarget
PUBLIC	?hasPFL@@3_NA					; hasPFL
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?txRes@@3HA					; txRes
PUBLIC	?tyRes@@3HA					; tyRes
PUBLIC	?tBpp@@3HA					; tBpp
PUBLIC	?vHUDul@@3UTpoint@@A				; vHUDul
PUBLIC	?vHUDur@@3UTpoint@@A				; vHUDur
PUBLIC	?vHUDll@@3UTpoint@@A				; vHUDll
PUBLIC	?tHUDleft@@3HA					; tHUDleft
PUBLIC	?tHUDtop@@3HA					; tHUDtop
PUBLIC	?tHUDright@@3HA					; tHUDright
PUBLIC	?tHUDbottom@@3HA				; tHUDbottom
PUBLIC	?vRWRul@@3UTpoint@@A				; vRWRul
PUBLIC	?vRWRur@@3UTpoint@@A				; vRWRur
PUBLIC	?vRWRll@@3UTpoint@@A				; vRWRll
PUBLIC	?tRWRleft@@3HA					; tRWRleft
PUBLIC	?tRWRtop@@3HA					; tRWRtop
PUBLIC	?tRWRright@@3HA					; tRWRright
PUBLIC	?tRWRbottom@@3HA				; tRWRbottom
PUBLIC	?vMACHul@@3UTpoint@@A				; vMACHul
PUBLIC	?vMACHur@@3UTpoint@@A				; vMACHur
PUBLIC	?vMACHll@@3UTpoint@@A				; vMACHll
PUBLIC	?vDEDul@@3UTpoint@@A				; vDEDul
PUBLIC	?vDEDur@@3UTpoint@@A				; vDEDur
PUBLIC	?vDEDll@@3UTpoint@@A				; vDEDll
PUBLIC	?tDEDleft@@3HA					; tDEDleft
PUBLIC	?tDEDtop@@3HA					; tDEDtop
PUBLIC	?tDEDright@@3HA					; tDEDright
PUBLIC	?tDEDbottom@@3HA				; tDEDbottom
PUBLIC	?vPFLul@@3UTpoint@@A				; vPFLul
PUBLIC	?vPFLur@@3UTpoint@@A				; vPFLur
PUBLIC	?vPFLll@@3UTpoint@@A				; vPFLll
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?tPFLleft@@3HA					; tPFLleft
PUBLIC	?tPFLtop@@3HA					; tPFLtop
PUBLIC	?tPFLright@@3HA					; tPFLright
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?tPFLbottom@@3HA				; tPFLbottom
PUBLIC	?trMFDleft@@3HA					; trMFDleft
PUBLIC	?trMFDtop@@3HA					; trMFDtop
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?trMFDright@@3HA				; trMFDright
PUBLIC	?trMFDbottom@@3HA				; trMFDbottom
PUBLIC	?tlMFDleft@@3HA					; tlMFDleft
PUBLIC	?tlMFDtop@@3HA					; tlMFDtop
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?tlMFDright@@3HA				; tlMFDright
PUBLIC	?tlMFDbottom@@3HA				; tlMFDbottom
PUBLIC	?dedStr1@@3PADA					; dedStr1
PUBLIC	?dedStr2@@3PADA					; dedStr2
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?dedStr3@@3PADA					; dedStr3
PUBLIC	?string1@@3PADA					; string1
PUBLIC	?string2@@3PADA					; string2
PUBLIC	?string3@@3PADA					; string3
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?string4@@3PADA					; string4
PUBLIC	?string5@@3PADA					; string5
PUBLIC	?string6@@3PADA					; string6
PUBLIC	?string7@@3PADA					; string7
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?string8@@3PADA					; string8
PUBLIC	?string9@@3PADA					; string9
PUBLIC	?string10@@3PADA				; string10
PUBLIC	?string11@@3PADA				; string11
PUBLIC	?string12@@3PADA				; string12
PUBLIC	?string13@@3PADA				; string13
PUBLIC	?string14@@3PADA				; string14
PUBLIC	?string15@@3PADA				; string15
PUBLIC	?string16@@3PADA				; string16
PUBLIC	?vOILul@@3UTpoint@@A				; vOILul
PUBLIC	?vOILur@@3UTpoint@@A				; vOILur
PUBLIC	?vOILll@@3UTpoint@@A				; vOILll
PUBLIC	?vOILepts@@3HA					; vOILepts
PUBLIC	?vOILvals@@3PAMA				; vOILvals
PUBLIC	?vOILpts@@3PAMA					; vOILpts
PUBLIC	?vNOZul@@3UTpoint@@A				; vNOZul
PUBLIC	?vNOZur@@3UTpoint@@A				; vNOZur
PUBLIC	?vNOZll@@3UTpoint@@A				; vNOZll
PUBLIC	?vNOZepts@@3HA					; vNOZepts
PUBLIC	?vNOZvals@@3PAMA				; vNOZvals
PUBLIC	?vNOZpts@@3PAMA					; vNOZpts
PUBLIC	?vRPMul@@3UTpoint@@A				; vRPMul
PUBLIC	?vRPMur@@3UTpoint@@A				; vRPMur
PUBLIC	?vRPMll@@3UTpoint@@A				; vRPMll
PUBLIC	?vRPMepts@@3HA					; vRPMepts
PUBLIC	?vRPMvals@@3PAMA				; vRPMvals
PUBLIC	?vRPMpts@@3PAMA					; vRPMpts
PUBLIC	?vFTITul@@3UTpoint@@A				; vFTITul
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?vFTITur@@3UTpoint@@A				; vFTITur
PUBLIC	?vFTITll@@3UTpoint@@A				; vFTITll
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?vFTITepts@@3HA					; vFTITepts
PUBLIC	?vFTITvals@@3PAMA				; vFTITvals
PUBLIC	?vFTITpts@@3PAMA				; vFTITpts
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?vALTul@@3UTpoint@@A				; vALTul
PUBLIC	?vALTur@@3UTpoint@@A				; vALTur
PUBLIC	?vALTll@@3UTpoint@@A				; vALTll
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?vALTepts@@3HA					; vALTepts
PUBLIC	?vALTvals@@3PAMA				; vALTvals
PUBLIC	?vALTpts@@3PAMA					; vALTpts
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
_BSS	SEGMENT
?DEDw@@3MA DD	01H DUP (?)				; DEDw
?DEDh@@3MA DD	01H DUP (?)				; DEDh
_LastMainADIPitch3d DD 01H DUP (?)
_LastMainADIRoll3d DD 01H DUP (?)
_LastBUPPitch3d DD 01H DUP (?)
_LastBUPRoll3d DD 01H DUP (?)
_ADIPitch3d DD	01H DUP (?)
_ADIRoll3d DD	01H DUP (?)
_BUPADIRoll3d DD 01H DUP (?)
_BUPADIPitch3d DD 01H DUP (?)
_HYDA3d	DD	01H DUP (?)
_HYDB3d	DD	01H DUP (?)
_MAGCOMPASS3d DD 01H DUP (?)
_BobbingPreviousRoll DD 01H DUP (?)
_BobbingPreviousPan DD 01H DUP (?)
?BobbingRollRate@@3MA DD 01H DUP (?)			; BobbingRollRate
?BobbingTilt@@3MA DD 01H DUP (?)			; BobbingTilt
?BobbingPan@@3MA DD 01H DUP (?)				; BobbingPan
?bRTTTarget@@3_NA DB 01H DUP (?)			; bRTTTarget
	ALIGN	4

?hasPFL@@3_NA DB 01H DUP (?)				; hasPFL
	ALIGN	4

?dedStr1@@3PADA DB 03cH DUP (?)				; dedStr1
?dedStr2@@3PADA DB 03cH DUP (?)				; dedStr2
?dedStr3@@3PADA DB 03cH DUP (?)				; dedStr3
?string1@@3PADA DB 03cH DUP (?)				; string1
?string2@@3PADA DB 03cH DUP (?)				; string2
?string3@@3PADA DB 03cH DUP (?)				; string3
?string4@@3PADA DB 03cH DUP (?)				; string4
?string5@@3PADA DB 03cH DUP (?)				; string5
?string6@@3PADA DB 03cH DUP (?)				; string6
?string7@@3PADA DB 03cH DUP (?)				; string7
?string8@@3PADA DB 03cH DUP (?)				; string8
?string9@@3PADA DB 03cH DUP (?)				; string9
?string10@@3PADA DB 03cH DUP (?)			; string10
?string11@@3PADA DB 03cH DUP (?)			; string11
?string12@@3PADA DB 03cH DUP (?)			; string12
?string13@@3PADA DB 03cH DUP (?)			; string13
?string14@@3PADA DB 03cH DUP (?)			; string14
?string15@@3PADA DB 03cH DUP (?)			; string15
?string16@@3PADA DB 03cH DUP (?)			; string16
_BSS	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
_DATA	SEGMENT
?HudScale@@3MA DD 040800000r			; 4	; HudScale
?CXX@@3MA DD	03f800000r			; 1	; CXX
?CXY@@3MA DD	03f800000r			; 1	; CXY
?resScale@@3MA DD 03f2aaae3r			; 0.66667 ; resScale
_hILS	DD	0bf8ccccdr			; -1.1
_vILS	DD	0bf8ccccdr			; -1.1
_hILSneedle DD	0bf800000r			; -1
_vILSneedle DD	0bf800000r			; -1
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?txRes@@3HA DD	0300H					; txRes
?tyRes@@3HA DD	0300H					; tyRes
?tBpp@@3HA DD	020H					; tBpp
?vHUDul@@3UTpoint@@A DD 041a08106r		; 20.063 ; vHUDul
	DD	0c0300000r			; -2.75
	DD	0bee978d5r			; -0.456
?vHUDur@@3UTpoint@@A DD 041a08106r		; 20.063 ; vHUDur
	DD	040300000r			; 2.75
	DD	0bee978d5r			; -0.456
?vHUDll@@3UTpoint@@A DD 041a08106r		; 20.063 ; vHUDll
	DD	0c0300000r			; -2.75
	DD	040944189r			; 4.633
?tHUDleft@@3HA DD 01H					; tHUDleft
?tHUDtop@@3HA DD 01H					; tHUDtop
?tHUDright@@3HA DD 01aeH				; tHUDright
?tHUDbottom@@3HA DD 01aeH				; tHUDbottom
?vRWRul@@3UTpoint@@A DD 041963d71r		; 18.78	; vRWRul
	DD	0c08bc6a8r			; -4.368
	DD	040a4b439r			; 5.147
?vRWRur@@3UTpoint@@A DD 041963b64r		; 18.779 ; vRWRur
	DD	0c01f1aa0r			; -2.486
	DD	040a4b439r			; 5.147
?vRWRll@@3UTpoint@@A DD 041956873r		; 18.676 ; vRWRll
	DD	0c08bc6a8r			; -4.368
	DD	040e09375r			; 7.018
?tRWRleft@@3HA DD 0faH					; tRWRleft
?tRWRtop@@3HA DD 01f4H					; tRWRtop
?tRWRright@@3HA DD 01aeH				; tRWRright
?tRWRbottom@@3HA DD 02a8H				; tRWRbottom
?vMACHul@@3UTpoint@@A DD 041a96c8br		; 21.178 ; vMACHul
	DD	0bfed2f1br			; -1.853
	DD	0410ef1aar			; 8.934
?vMACHur@@3UTpoint@@A DD 041a96c8br		; 21.178 ; vMACHur
	DD	0bd591687r			; -0.053
	DD	0410ef1aar			; 8.934
?vMACHll@@3UTpoint@@A DD 041a8ae14r		; 21.085 ; vMACHll
	DD	0bfed2f1br			; -1.853
	DD	0412bb646r			; 10.732
?vDEDul@@3UTpoint@@A DD 041951893r		; 18.637 ; vDEDul
	DD	04024ed91r			; 2.577
	DD	040a5c28fr			; 5.18
?vDEDur@@3UTpoint@@A DD 041951893r		; 18.637 ; vDEDur
	DD	040d8dd2fr			; 6.777
	DD	040a5c28fr			; 5.18
?vDEDll@@3UTpoint@@A DD 04193cac1r		; 18.474 ; vDEDll
	DD	04024ed91r			; 2.577
	DD	040c547aer			; 6.165
?tDEDleft@@3HA DD 01H					; tDEDleft
?tDEDtop@@3HA DD 01f4H					; tDEDtop
?tDEDright@@3HA DD 0c8H					; tDEDright
?tDEDbottom@@3HA DD 0244H				; tDEDbottom
?vPFLul@@3UTpoint@@A DD 041951893r		; 18.637 ; vPFLul
	DD	040d276c9r			; 6.577
	DD	040a5c28fr			; 5.18
?vPFLur@@3UTpoint@@A DD 041951893r		; 18.637 ; vPFLur
	DD	0412c6e98r			; 10.777
	DD	040a5c28fr			; 5.18
?vPFLll@@3UTpoint@@A DD 04193cac1r		; 18.474 ; vPFLll
	DD	040d276c9r			; 6.577
	DD	040c547aer			; 6.165
?tPFLleft@@3HA DD 01H					; tPFLleft
?tPFLtop@@3HA DD 0258H					; tPFLtop
?tPFLright@@3HA DD 0c8H					; tPFLright
?tPFLbottom@@3HA DD 02a8H				; tPFLbottom
?trMFDleft@@3HA DD 0226H				; trMFDleft
?trMFDtop@@3HA DD 0faH					; trMFDtop
?trMFDright@@3HA DD 02eeH				; trMFDright
?trMFDbottom@@3HA DD 01c2H				; trMFDbottom
?tlMFDleft@@3HA DD 0226H				; tlMFDleft
?tlMFDtop@@3HA DD 01H					; tlMFDtop
?tlMFDright@@3HA DD 02eeH				; tlMFDright
?tlMFDbottom@@3HA DD 0c8H				; tlMFDbottom
?vOILul@@3UTpoint@@A DD 0418feb85r		; 17.99	; vOILul
	DD	040ff3b64r			; 7.976
	DD	0410d2b02r			; 8.823
?vOILur@@3UTpoint@@A DD 0418feb85r		; 17.99	; vOILur
	DD	0410ad0e5r			; 8.676
	DD	0410d2b02r			; 8.823
?vOILll@@3UTpoint@@A DD 0418ef5c3r		; 17.87	; vOILll
	DD	040ff3b64r			; 7.976
	DD	041183127r			; 9.512
?vOILepts@@3HA DD 03H					; vOILepts
?vOILvals@@3PAMA DD 000000000r			; 0	; vOILvals
	DD	042c80000r			; 100
	DD	042ce999ar			; 103.3
?vOILpts@@3PAMA DD 0bf256042r			; -0.646 ; vOILpts
	DD	03f391687r			; 0.723
	DD	03f0353f8r			; 0.513
?vNOZul@@3UTpoint@@A DD 0418e6666r		; 17.8	; vNOZul
	DD	04101374cr			; 8.076
	DD	0411e7efar			; 9.906
?vNOZur@@3UTpoint@@A DD 0418e6666r		; 17.8	; vNOZur
	DD	04111374cr			; 9.076
	DD	0411e7efar			; 9.906
?vNOZll@@3UTpoint@@A DD 0418d0419r		; 17.627 ; vNOZll
	DD	04101374cr			; 8.076
	DD	0412e4189r			; 10.891
?vNOZepts@@3HA DD 02H					; vNOZepts
?vNOZvals@@3PAMA DD 000000000r			; 0	; vNOZvals
	DD	042c80000r			; 100
?vNOZpts@@3PAMA DD 03f71a9fcr			; 0.944	; vNOZpts
	DD	04011374cr			; 2.269
?vRPMul@@3UTpoint@@A DD 0418c999ar		; 17.575 ; vRPMul
	DD	04101374cr			; 8.076
	DD	04132f9dbr			; 11.186
?vRPMur@@3UTpoint@@A DD 0418c999ar		; 17.575 ; vRPMur
	DD	041160419r			; 9.376
	DD	04132f9dbr			; 11.186
?vRPMll@@3UTpoint@@A DD 0418acac1r		; 17.349 ; vRPMll
	DD	04101374cr			; 8.076
	DD	0414778d5r			; 12.467
?vRPMepts@@3HA DD 04H					; vRPMepts
?vRPMvals@@3PAMA DD 000000000r			; 0	; vRPMvals
	DD	042700000r			; 60
	DD	042c80000r			; 100
	DD	042dc0000r			; 110
?vRPMpts@@3PAMA DD 03fc91687r			; 1.571	; vRPMpts
	DD	000000000r			; 0
	DD	040491687r			; 3.142
	DD	04013a5e3r			; 2.307
?vFTITul@@3UTpoint@@A DD 04189ced9r		; 17.226 ; vFTITul
	DD	0410acccdr			; 8.675
	DD	041527efar			; 13.156
?vFTITur@@3UTpoint@@A DD 04189ced9r		; 17.226 ; vFTITur
	DD	0411e0000r			; 9.875
	DD	041527efar			; 13.156
?vFTITll@@3UTpoint@@A DD 0418822d1r		; 17.017 ; vFTITll
	DD	0410acccdr			; 8.675
	DD	041656873r			; 14.338
?vFTITepts@@3HA DD 06H					; vFTITepts
?vFTITvals@@3PAMA DD 040000000r			; 2	; vFTITvals
	DD	040c00000r			; 6
	DD	041000000r			; 8
	DD	041100000r			; 9
	DD	041200000r			; 10
	DD	041400000r			; 12
?vFTITpts@@3PAMA DD 0bea353f8r			; -0.319 ; vFTITpts
	DD	0bfb8f5c3r			; -1.445
	DD	0c033b646r			; -2.808
	DD	0401a5e35r			; 2.412
	DD	03f9a9fber			; 1.208
	DD	03f1ef9dbr			; 0.621
?vALTul@@3UTpoint@@A DD 041a96c8br		; 21.178 ; vALTul
	DD	03e7ced91r			; 0.247
	DD	0410ef1aar			; 8.934
?vALTur@@3UTpoint@@A DD 041a96c8br		; 21.178 ; vALTur
	DD	04003020cr			; 2.047
	DD	0410ef1aar			; 8.934
?vALTll@@3UTpoint@@A DD 041a8ae14r		; 21.085 ; vALTll
	DD	03e74bc6ar			; 0.239
	DD	0412bb646r			; 10.732
?vALTepts@@3HA DD 02H					; vALTepts
?vALTvals@@3PAMA DD 000000000r			; 0	; vALTvals
	DD	0447a0000r			; 1000
?vALTpts@@3PAMA DD 03fc8f5c3r			; 1.57	; vALTpts
	DD	03fc91687r			; 1.571
	ORG $+4
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_atanf
PUBLIC	_fmodf
PUBLIC	_log10f
PUBLIC	_tanf
PUBLIC	?abs@@YAMM@Z					; abs
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?fmod@@YAMMM@Z					; fmod
PUBLIC	?log10@@YAMM@Z					; log10
PUBLIC	?tan@@YAMM@Z					; tan
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?CurrentForegroundColor@ContextMPR@@QAEHXZ	; ContextMPR::CurrentForegroundColor
PUBLIC	??0VirtualDisplay@@QAE@XZ			; VirtualDisplay::VirtualDisplay
PUBLIC	??1VirtualDisplay@@UAE@XZ			; VirtualDisplay::~VirtualDisplay
PUBLIC	?Circle@VirtualDisplay@@UAEXMMM@Z		; VirtualDisplay::Circle
PUBLIC	?Arc@VirtualDisplay@@UAEXMMMMM@Z		; VirtualDisplay::Arc
PUBLIC	?TextWidth@VirtualDisplay@@UAEMPAD@Z		; VirtualDisplay::TextWidth
PUBLIC	?TextHeight@VirtualDisplay@@UAEMXZ		; VirtualDisplay::TextHeight
PUBLIC	?CurFont@VirtualDisplay@@SAHXZ			; VirtualDisplay::CurFont
PUBLIC	?SetLineStyle@VirtualDisplay@@UAEXH@Z		; VirtualDisplay::SetLineStyle
PUBLIC	?Color@VirtualDisplay@@UAEKXZ			; VirtualDisplay::Color
PUBLIC	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ	; VirtualDisplay::CenterOriginInViewport
PUBLIC	?HasRttTarget@VirtualDisplay@@QAEHXZ		; VirtualDisplay::HasRttTarget
PUBLIC	?GetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@@Z	; VirtualDisplay::GetRttCanvas
PUBLIC	??_GVirtualDisplay@@UAEPAXI@Z			; VirtualDisplay::`scalar deleting destructor'
PUBLIC	??0Render2D@@QAE@XZ				; Render2D::Render2D
PUBLIC	??1Render2D@@UAE@XZ				; Render2D::~Render2D
PUBLIC	?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ	; Render2D::GetImageBuffer
PUBLIC	?ClearDraw@Render2D@@UAEXXZ			; Render2D::ClearDraw
PUBLIC	?ClearZBuffer@Render2D@@UAEXXZ			; Render2D::ClearZBuffer
PUBLIC	?Color@Render2D@@UAEKXZ				; Render2D::Color
PUBLIC	?SetColor@Render2D@@UAEXK@Z			; Render2D::SetColor
PUBLIC	?SetBackground@Render2D@@UAEXK@Z		; Render2D::SetBackground
PUBLIC	?SetLineStyle@Render2D@@UAEXH@Z			; Render2D::SetLineStyle
PUBLIC	??_GRender2D@@UAEPAXI@Z				; Render2D::`scalar deleting destructor'
PUBLIC	?GetObjectTextureState@Render3D@@QAEHXZ		; Render3D::GetObjectTextureState
PUBLIC	??0Canvas3D@@QAE@XZ				; Canvas3D::Canvas3D
PUBLIC	??1Canvas3D@@UAE@XZ				; Canvas3D::~Canvas3D
PUBLIC	?StartDraw@Canvas3D@@UAEXXZ			; Canvas3D::StartDraw
PUBLIC	?ClearDraw@Canvas3D@@UAEXXZ			; Canvas3D::ClearDraw
PUBLIC	?EndDraw@Canvas3D@@UAEXXZ			; Canvas3D::EndDraw
PUBLIC	?Render2DTri@Canvas3D@@UAEXMMMMMM@Z		; Canvas3D::Render2DTri
PUBLIC	?SetLineStyle@Canvas3D@@UAEXH@Z			; Canvas3D::SetLineStyle
PUBLIC	?Color@Canvas3D@@UAEKXZ				; Canvas3D::Color
PUBLIC	?SetColor@Canvas3D@@UAEXK@Z			; Canvas3D::SetColor
PUBLIC	?SetBackground@Canvas3D@@UAEXK@Z		; Canvas3D::SetBackground
PUBLIC	?ScreenText@Canvas3D@@UAEXMMPBDH@Z		; Canvas3D::ScreenText
PUBLIC	??_GCanvas3D@@UAEPAXI@Z				; Canvas3D::`scalar deleting destructor'
PUBLIC	?GetNTextureSet@ObjectInstance@@QAEHXZ		; ObjectInstance::GetNTextureSet
PUBLIC	?SetTextureSet@DrawableBSP@@QAEXK@Z		; DrawableBSP::SetTextureSet
PUBLIC	?GetNTextureSet@DrawableBSP@@QAEHXZ		; DrawableBSP::GetNTextureSet
PUBLIC	?GetTextureSet@DrawableBSP@@QAEKXZ		; DrawableBSP::GetTextureSet
PUBLIC	?GetGreenMode@RenderOTW@@QAE_NXZ		; RenderOTW::GetGreenMode
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ	; MFDClass::GetDrawable
PUBLIC	?SetGridVisible@PlayerRwrClass@@QAEXH@Z		; PlayerRwrClass::SetGridVisible
PUBLIC	?LaunchIndication@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::LaunchIndication
PUBLIC	?IsPriority@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::IsPriority
PUBLIC	?TargetSep@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::TargetSep
PUBLIC	?ShowUnknowns@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::ShowUnknowns
PUBLIC	?ShowNaval@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::ShowNaval
PUBLIC	?ShowSearch@PlayerRwrClass@@QAEHXZ		; PlayerRwrClass::ShowSearch
PUBLIC	?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowLowAltPriority
PUBLIC	?GetDOFValue@SimMoverClass@@QAEMH@Z		; SimMoverClass::GetDOFValue
PUBLIC	?SetSwitch@SimMoverClass@@QAEXHH@Z		; SimMoverClass::SetSwitch
PUBLIC	?NumHardpoints@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumHardpoints
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
PUBLIC	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
PUBLIC	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
PUBLIC	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z	; AircraftClass::IsAcStatusBitsSet
PUBLIC	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
PUBLIC	?IsComplex@AircraftClass@@QAEHXZ		; AircraftClass::IsComplex
PUBLIC	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z		; AircraftClass::IsOn
PUBLIC	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ	; AircraftClass::EWSPGM
PUBLIC	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
PUBLIC	?AVTROn@SimulationDriver@@QAEHXZ		; SimulationDriver::AVTROn
PUBLIC	?InExitMenu@OTWDriverClass@@QAEHXZ		; OTWDriverClass::InExitMenu
PUBLIC	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
PUBLIC	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
PUBLIC	??0?$allocator@PAVVDial@@@std@@QAE@XZ		; std::allocator<VDial *>::allocator<VDial *>
PUBLIC	?deallocate@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@I@Z ; std::allocator<VDial *>::deallocate
PUBLIC	?allocate@?$allocator@PAVVDial@@@std@@QAEPAPAVVDial@@I@Z ; std::allocator<VDial *>::allocate
PUBLIC	?construct@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@ABQAV3@@Z ; std::allocator<VDial *>::construct
PUBLIC	?max_size@?$allocator@PAVVDial@@@std@@QBEIXZ	; std::allocator<VDial *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAIABV?$allocator@PAVVDial@@@2@@Z ; std::allocator_traits<std::allocator<VDial *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<VDial *> >::_Wrap_alloc<std::allocator<VDial *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEPAPAVVDial@@I@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@I@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<VDial *> >::max_size
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
PUBLIC	?capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::_Unused_capacity
PUBLIC	?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::size
PUBLIC	?max_size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::max_size
PUBLIC	??A?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEAAPAVVDial@@I@Z ; std::vector<VDial *,std::allocator<VDial *> >::operator[]
PUBLIC	?push_back@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXABQAVVDial@@@Z ; std::vector<VDial *,std::allocator<VDial *> >::push_back
PUBLIC	?clear@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXXZ ; std::vector<VDial *,std::allocator<VDial *> >::clear
PUBLIC	?_Destroy@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXPAPAVVDial@@0@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEII@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBE_NPBQAVVDial@@@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Reserve
PUBLIC	?_Xlen@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXXZ ; std::vector<VDial *,std::allocator<VDial *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXPAPAVVDial@@0@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Orphan_range
PUBLIC	?VCock_Glance@OTWDriverClass@@AAEXM@Z		; OTWDriverClass::VCock_Glance
PUBLIC	?VCock_GiveGilmanHead@OTWDriverClass@@AAEXM@Z	; OTWDriverClass::VCock_GiveGilmanHead
PUBLIC	?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z	; OTWDriverClass::VCock_RunNormalMotion
PUBLIC	?VCock_CheckStopStates@OTWDriverClass@@AAEXM@Z	; OTWDriverClass::VCock_CheckStopStates
PUBLIC	?VCock_DrawThePit@OTWDriverClass@@AAEXXZ	; OTWDriverClass::VCock_DrawThePit
PUBLIC	?VCock_HeadCalc@OTWDriverClass@@AAEXXZ		; OTWDriverClass::VCock_HeadCalc
PUBLIC	?VCock_Exec@OTWDriverClass@@AAEXXZ		; OTWDriverClass::VCock_Exec
PUBLIC	?VCock_Cleanup@OTWDriverClass@@AAEXXZ		; OTWDriverClass::VCock_Cleanup
PUBLIC	?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z ; OTWDriverClass::VCock_ParseVDial
PUBLIC	?VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z	; OTWDriverClass::VCock_Init
PUBLIC	?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z ; OTWDriverClass::VCock_SetCanvas
PUBLIC	?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ; OTWDriverClass::VCock_SetRttCanvas
PUBLIC	?MoveByRate@OTWDriverClass@@AAEMMMM@Z		; OTWDriverClass::MoveByRate
PUBLIC	?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z	; OTWDriverClass::Button3D_Init
PUBLIC	?CockAttachWeapons@OTWDriverClass@@QAEXXZ	; OTWDriverClass::CockAttachWeapons
PUBLIC	?CockDetachWeapons@OTWDriverClass@@QAEXXZ	; OTWDriverClass::CockDetachWeapons
PUBLIC	?IsSet@FlightData@@QAEHH@Z			; FlightData::IsSet
PUBLIC	?IsSetHsi@FlightData@@QAEHH@Z			; FlightData::IsSetHsi
PUBLIC	?Ownship@HudClass@@QAEPAVAircraftClass@@XZ	; HudClass::Ownship
PUBLIC	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
PUBLIC	?HydraulicA@AirframeClass@@QAEHXZ		; AirframeClass::HydraulicA
PUBLIC	?HydraulicB@AirframeClass@@QAEHXZ		; AirframeClass::HydraulicB
PUBLIC	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
PUBLIC	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
PUBLIC	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
PUBLIC	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
PUBLIC	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?GetNVGmode@CTimeOfDay@@QAEHXZ			; CTimeOfDay::GetNVGmode
PUBLIC	??_GVDial@@QAEPAXI@Z				; VDial::`scalar deleting destructor'
PUBLIC	?getX@TrackIR@@QAEMXZ				; TrackIR::getX
PUBLIC	?getY@TrackIR@@QAEMXZ				; TrackIR::getY
PUBLIC	?getZ@TrackIR@@QAEMXZ				; TrackIR::getZ
PUBLIC	?ExtractDigit@@YAHMH@Z				; ExtractDigit
PUBLIC	??$pow@HH@@YANHH@Z				; pow<int,int>
PUBLIC	??$addressof@QAVVDial@@@std@@YAPBQAVVDial@@ABQAV1@@Z ; std::addressof<VDial * const>
PUBLIC	??$construct@PAVVDial@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * &>
PUBLIC	??$construct@PAVVDial@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * const &>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >
PUBLIC	??$_Umove@PAPAVVDial@@@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEPAPAVVDial@@PAPAV2@00@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Umove<VDial * *>
PUBLIC	??$_Allocate@PAVVDial@@@std@@YAPAPAVVDial@@IPAPAV1@@Z ; std::_Allocate<VDial *>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z ; std::forward<VDial * &>
PUBLIC	??$construct@PAVVDial@@AAPAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@AAPAV3@@Z ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * &>
PUBLIC	??$forward@ABQAVVDial@@@std@@YAABQAVVDial@@ABQAV1@@Z ; std::forward<VDial * const &>
PUBLIC	??$construct@PAVVDial@@ABQAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@ABQAV3@@Z ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * const &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Ptr_cat@PAVVDial@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVVDial@@0@Z ; std::_Ptr_cat<VDial *,VDial *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >
PUBLIC	??$_Uninitialized_move@PAPAVVDial@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z ; std::_Uninitialized_move<VDial * *,VDial * *,std::_Wrap_alloc<std::allocator<VDial *> > >
PUBLIC	??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z ; std::allocator<VDial *>::construct<VDial *,VDial * &>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$_Val_type@PAPAVVDial@@@std@@YAPAPAVVDial@@PAPAV1@@Z ; std::_Val_type<VDial * *>
PUBLIC	??$_Uninit_move@PAVVDial@@PAV1@PAV1@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<VDial *,VDial *,VDial *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_7VirtualDisplay@@6B@				; VirtualDisplay::`vftable'
PUBLIC	??_7Render2D@@6B@				; Render2D::`vftable'
PUBLIC	??_7Canvas3D@@6B@				; Canvas3D::`vftable'
PUBLIC	??_C@_03OCLOCGE@?$DN?$DL?6?$AA@			; `string'
PUBLIC	??_C@_0CN@HGJLILKD@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_0BL@PNBJJOIP@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@ ; `string'
PUBLIC	??_C@_04PAJMBCIO@?$CDend?$AA@			; `string'
PUBLIC	??_C@_0N@NJACGLBK@numendpoints?$AA@		; `string'
PUBLIC	??_C@_06GPGIDCJA@points?$AA@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_06GEKOPAHD@values?$AA@			; `string'
PUBLIC	??_C@_07ILDOBJAO@radius0?$AA@			; `string'
PUBLIC	??_C@_06JGNLDMKC@color0?$AA@			; `string'
PUBLIC	??_C@_03OPHMLOFF@?$CFlx?$AA@			; `string'
PUBLIC	??_C@_0N@BALDINCG@callbackslot?$AA@		; `string'
PUBLIC	??_C@_07OKLNCIDH@destloc?$AA@			; `string'
PUBLIC	??_C@_0M@JEIKDHB@3dckpit?4dat?$AA@		; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_09JALPCOHE@rtttarget?$AA@			; `string'
PUBLIC	??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_03HDICPLBH@hud?$AA@			; `string'
PUBLIC	??_C@_03FDDKCNFF@rwr?$AA@			; `string'
PUBLIC	??_C@_03CIIJCKKD@DED?$AA@			; `string'
PUBLIC	??_C@_03DAJGBDEG@pfl?$AA@			; `string'
PUBLIC	??_C@_07EHJPLJNA@MACHASI?$AA@			; `string'
PUBLIC	??_C@_07PNADDHHC@mfdleft?$AA@			; `string'
PUBLIC	??_C@_08KEAJBMEO@mfdright?$AA@			; `string'
PUBLIC	??_C@_04FPCGAGCC@DIAL?$AA@			; `string'
PUBLIC	??_C@_09BDGLCNBI@padlockbg?$AA@			; `string'
PUBLIC	??_C@_0BA@MBCBKCMN@padlockliftline?$AA@		; `string'
PUBLIC	??_C@_0O@IFMFANAH@padlockvpside?$AA@		; `string'
PUBLIC	??_C@_0N@CKBBNJNL@padlockvptop?$AA@		; `string'
PUBLIC	??_C@_0M@ECDAFED@padlocktick?$AA@		; `string'
PUBLIC	??_C@_0N@JLPECKLH@needlecolor0?$AA@		; `string'
PUBLIC	??_C@_0N@ICOPBLPG@needlecolor1?$AA@		; `string'
PUBLIC	??_C@_08EFPLLPGK@dedcolor?$AA@			; `string'
PUBLIC	??_C@_08KALBBLDD@rwrcolor?$AA@			; `string'
PUBLIC	??_C@_09MIAHMBP@highlight?$AA@			; `string'
PUBLIC	??_C@_08MDNHPGJO@lowlight?$AA@			; `string'
PUBLIC	??_C@_0N@ECHNMOHL@cockpitmodel?$AA@		; `string'
PUBLIC	??_C@_0P@BFJPBPOJ@cockpitdfmodel?$AA@		; `string'
PUBLIC	??_C@_09PLEBLAKK@mainmodel?$AA@			; `string'
PUBLIC	??_C@_0N@GLLLAGML@damagedmodel?$AA@		; `string'
PUBLIC	??_C@_0L@OMMBEINF@zbuffering?$AA@		; `string'
PUBLIC	??_C@_0O@BFBKOAGD@liftlinecolor?$AA@		; `string'
PUBLIC	??_C@_0L@HAIMJJDN@boresighty?$AA@		; `string'
PUBLIC	??_C@_0M@MEJOGGLB@usenew3dpit?$AA@		; `string'
PUBLIC	??_C@_0O@LJEPPKJG@3dbuttons?4dat?$AA@		; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_08JHKGGCCB@?$CFs?2?$CFd?2?$CFs?$AA@	; `string'
PUBLIC	??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@	; `string'
PUBLIC	??_C@_0N@LCGKJIDE@art?2ckptart?2?$AA@		; `string'
PUBLIC	??_C@_0BF@CGIJNBCN@?$CFs?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Render2D@@8			; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRender2D@@@8				; Render2D `RTTI Type Descriptor'
PUBLIC	??_R3Render2D@@8				; Render2D::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Render2D@@8				; Render2D::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VirtualDisplay@@8			; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVirtualDisplay@@@8			; VirtualDisplay `RTTI Type Descriptor'
PUBLIC	??_R3VirtualDisplay@@8				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VirtualDisplay@@8				; VirtualDisplay::`RTTI Base Class Array'
PUBLIC	??_R4VirtualDisplay@@6B@			; VirtualDisplay::`RTTI Complete Object Locator'
PUBLIC	??_R4Render2D@@6B@				; Render2D::`RTTI Complete Object Locator'
PUBLIC	??_R4Canvas3D@@6B@				; Canvas3D::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCanvas3D@@@8				; Canvas3D `RTTI Type Descriptor'
PUBLIC	??_R3Canvas3D@@8				; Canvas3D::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Canvas3D@@8				; Canvas3D::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Canvas3D@@8			; Canvas3D::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c3bc2b9
PUBLIC	__real@3c75c28f
PUBLIC	__real@3c888f86
PUBLIC	__real@3c8efa34
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d07c84b
PUBLIC	__real@3d2c0831
PUBLIC	__real@3d2db61c
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3d5d97f6
PUBLIC	__real@3d6978d5
PUBLIC	__real@3d75c28f
PUBLIC	__real@3d8ef88c
PUBLIC	__real@3d9a36e3
PUBLIC	__real@3da1cac1
PUBLIC	__real@3da3d70a
PUBLIC	__real@3da949a5
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e051eb8
PUBLIC	__real@3e19999a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3ea66666
PUBLIC	__real@3ea8f5c3
PUBLIC	__real@3ea9c91e
PUBLIC	__real@3eb0a3d7
PUBLIC	__real@3ec00000
PUBLIC	__real@3ec147ae
PUBLIC	__real@3eca3d71
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ed851ec
PUBLIC	__real@3edf66f1
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f07ae14
PUBLIC	__real@3f19999a
PUBLIC	__real@3f1c61a9
PUBLIC	__real@3f1f5c29
PUBLIC	__real@3f20d845
PUBLIC	__real@3f32b8c1
PUBLIC	__real@3f400000
PUBLIC	__real@3f59999a
PUBLIC	__real@3f666666
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f7eb852
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae1
PUBLIC	__real@3f860a91
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fdd0e56
PUBLIC	__real@3ffe978d
PUBLIC	__real@40000000
PUBLIC	__real@4021eb85
PUBLIC	__real@40278d35
PUBLIC	__real@40490fd9
PUBLIC	__real@40490fdb
PUBLIC	__real@4068f5c3
PUBLIC	__real@40700000
PUBLIC	__real@40800000
PUBLIC	__real@409ab021
PUBLIC	__real@409ccccd
PUBLIC	__real@40a00000
PUBLIC	__real@40a33333
PUBLIC	__real@40b9999a
PUBLIC	__real@40c00000
PUBLIC	__real@40c33333
PUBLIC	__real@40c90fd9
PUBLIC	__real@40c90fdb
PUBLIC	__real@40e00000
PUBLIC	__real@40f33333
PUBLIC	__real@41200000
PUBLIC	__real@4125999a
PUBLIC	__real@41400000
PUBLIC	__real@41980000
PUBLIC	__real@41a00000
PUBLIC	__real@41f00000
PUBLIC	__real@420c0000
PUBLIC	__real@42100000
PUBLIC	__real@42480000
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@428c0000
PUBLIC	__real@42a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@43a00000
PUBLIC	__real@44000000
PUBLIC	__real@440e4000
PUBLIC	__real@44548000
PUBLIC	__real@447a0000
PUBLIC	__real@44c80000
PUBLIC	__real@44fa0000
PUBLIC	__real@461c3c00
PUBLIC	__real@461c4000
PUBLIC	__real@467ffc00
PUBLIC	__real@bda3d70a
PUBLIC	__real@bdcccccd
PUBLIC	__real@bdd6774e
PUBLIC	__real@be051eb8
PUBLIC	__real@bea8f5c3
PUBLIC	__real@bf000000
PUBLIC	__real@bf30a3d7
PUBLIC	__real@bf400000
PUBLIC	__real@bf666666
PUBLIC	__real@bf7ae148
PUBLIC	__real@bf7eb852
PUBLIC	__real@bf800000
PUBLIC	__real@bf8ccccd
PUBLIC	__real@bfa00000
PUBLIC	__real@bfc90fd9
PUBLIC	__real@bfcd87ab
PUBLIC	__real@bff5be09
PUBLIC	__real@c01c61a9
PUBLIC	__real@c0278d35
PUBLIC	__real@c0490fd9
PUBLIC	__real@c0490fdb
PUBLIC	__real@c0700000
PUBLIC	__real@c0c00000
PUBLIC	__real@c0c90fd9
PUBLIC	__real@c20c0000
PUBLIC	__real@c2b40000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_atan:PROC
EXTRN	_fabs:PROC
EXTRN	_fmod:PROC
EXTRN	_log10:PROC
EXTRN	_pow:PROC
EXTRN	_tan:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strcmpi:PROC
EXTRN	_feof:PROC
EXTRN	_fgets:PROC
EXTRN	_sscanf:PROC
EXTRN	_sprintf:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??0ContextMPR@@QAE@XZ:PROC			; ContextMPR::ContextMPR
EXTRN	??1ContextMPR@@UAE@XZ:PROC			; ContextMPR::~ContextMPR
EXTRN	?SetState@ContextMPR@@QAEXGK@Z:PROC		; ContextMPR::SetState
EXTRN	?ClearBuffers@ContextMPR@@QAEXG@Z:PROC		; ContextMPR::ClearBuffers
EXTRN	?SelectForegroundColor@ContextMPR@@QAEXH@Z:PROC	; ContextMPR::SelectForegroundColor
EXTRN	?RestoreState@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::RestoreState
EXTRN	?MatrixMult@@YAXPBUTrotation@@0PAU1@@Z:PROC	; MatrixMult
EXTRN	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z:PROC ; MatrixMult
EXTRN	?Setup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Setup
EXTRN	?Cleanup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Cleanup
EXTRN	?Point@VirtualDisplay@@UAEXMM@Z:PROC		; VirtualDisplay::Point
EXTRN	?Line@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Line@VirtualDisplay@@UAEXMMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Tri@VirtualDisplay@@UAEXMMMMMM@Z:PROC		; VirtualDisplay::Tri
EXTRN	?Oval@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Oval
EXTRN	?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z:PROC	; VirtualDisplay::OvalArc
EXTRN	?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextLeft
EXTRN	?TextRight@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextRight
EXTRN	?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextLeftVertical
EXTRN	?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextRightVertical
EXTRN	?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextCenter
EXTRN	?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextCenterVertical
EXTRN	?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z:PROC	; VirtualDisplay::TextWrap
EXTRN	?ScreenTextHeight@VirtualDisplay@@SAHXZ:PROC	; VirtualDisplay::ScreenTextHeight
EXTRN	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z:PROC	; VirtualDisplay::ScreenTextWidth
EXTRN	?SetFont@VirtualDisplay@@SAXH@Z:PROC		; VirtualDisplay::SetFont
EXTRN	?SetViewport@VirtualDisplay@@UAEXMMMM@Z:PROC	; VirtualDisplay::SetViewport
EXTRN	?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z:PROC ; VirtualDisplay::SetViewportRelative
EXTRN	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z:PROC ; VirtualDisplay::AdjustOriginInViewport
EXTRN	?GetViewport@VirtualDisplay@@QAEXPAM000@Z:PROC	; VirtualDisplay::GetViewport
EXTRN	?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z:PROC	; VirtualDisplay::Render2DTri
EXTRN	?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z:PROC	; VirtualDisplay::SetupRttTarget
EXTRN	?CleanupRttTarget@VirtualDisplay@@SA_NXZ:PROC	; VirtualDisplay::CleanupRttTarget
EXTRN	?StartRtt@VirtualDisplay@@QAEXPAVRender3D@@@Z:PROC ; VirtualDisplay::StartRtt
EXTRN	?FinishRtt@VirtualDisplay@@QAEXXZ:PROC		; VirtualDisplay::FinishRtt
EXTRN	?SetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@00DM@Z:PROC ; VirtualDisplay::SetRttCanvas
EXTRN	?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z:PROC	; VirtualDisplay::SetRttRect
EXTRN	?AdjustRttViewport@VirtualDisplay@@QAEXXZ:PROC	; VirtualDisplay::AdjustRttViewport
EXTRN	?DrawRttQuad@VirtualDisplay@@QAEXXZ:PROC	; VirtualDisplay::DrawRttQuad
EXTRN	??_EVirtualDisplay@@UAEPAXI@Z:PROC		; VirtualDisplay::`vector deleting destructor'
EXTRN	?Setup@Render2D@@UAEXPAVImageBuffer@@@Z:PROC	; Render2D::Setup
EXTRN	?Cleanup@Render2D@@UAEXXZ:PROC			; Render2D::Cleanup
EXTRN	?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z:PROC ; Render2D::SetImageBuffer
EXTRN	?StartDraw@Render2D@@UAEXXZ:PROC		; Render2D::StartDraw
EXTRN	?EndDraw@Render2D@@UAEXXZ:PROC			; Render2D::EndDraw
EXTRN	?SetViewport@Render2D@@UAEXMMMM@Z:PROC		; Render2D::SetViewport
EXTRN	?Render2DPoint@Render2D@@UAEXMM@Z:PROC		; Render2D::Render2DPoint
EXTRN	?Render2DLine@Render2D@@UAEXMMMM@Z:PROC		; Render2D::Render2DLine
EXTRN	?Render2DTri@Render2D@@UAEXMMMMMM@Z:PROC	; Render2D::Render2DTri
EXTRN	?ScreenText@Render2D@@UAEXMMPBDH@Z:PROC		; Render2D::ScreenText
EXTRN	?ChangeFontSet@Render2D@@SAXPAUFontSet@@@Z:PROC	; Render2D::ChangeFontSet
EXTRN	??_ERender2D@@UAEPAXI@Z:PROC			; Render2D::`vector deleting destructor'
EXTRN	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; Render3D::SetCamera
EXTRN	?SetObjectTextureState@Render3D@@QAEXH@Z:PROC	; Render3D::SetObjectTextureState
EXTRN	?TransformCameraCentricPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z:PROC ; Render3D::TransformCameraCentricPoint
EXTRN	?Setup@Canvas3D@@UAEXPAVRender3D@@@Z:PROC	; Canvas3D::Setup
EXTRN	?Cleanup@Canvas3D@@UAEXXZ:PROC			; Canvas3D::Cleanup
EXTRN	?Render2DPoint@Canvas3D@@UAEXMM@Z:PROC		; Canvas3D::Render2DPoint
EXTRN	?Render2DLine@Canvas3D@@UAEXMMMM@Z:PROC		; Canvas3D::Render2DLine
EXTRN	?TextWidth@Canvas3D@@UAEMPAD@Z:PROC		; Canvas3D::TextWidth
EXTRN	?TextHeight@Canvas3D@@UAEMXZ:PROC		; Canvas3D::TextHeight
EXTRN	?SetCanvas@Canvas3D@@QAEXPAUTpoint@@00@Z:PROC	; Canvas3D::SetCanvas
EXTRN	?Update@Canvas3D@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; Canvas3D::Update
EXTRN	?Point@Canvas3D@@UAEXMM@Z:PROC			; Canvas3D::Point
EXTRN	?Line@Canvas3D@@UAEXMMMM@Z:PROC			; Canvas3D::Line
EXTRN	?Tri@Canvas3D@@UAEXMMMMMM@Z:PROC		; Canvas3D::Tri
EXTRN	?TextLeft@Canvas3D@@UAEXMMPBDH@Z:PROC		; Canvas3D::TextLeft
EXTRN	?TextRight@Canvas3D@@UAEXMMPBDH@Z:PROC		; Canvas3D::TextRight
EXTRN	?TextCenter@Canvas3D@@UAEXMMPBDH@Z:PROC		; Canvas3D::TextCenter
EXTRN	?TextLeftVertical@Canvas3D@@UAEXMMPBDH@Z:PROC	; Canvas3D::TextLeftVertical
EXTRN	?TextRightVertical@Canvas3D@@UAEXMMPBDH@Z:PROC	; Canvas3D::TextRightVertical
EXTRN	?TextCenterVertical@Canvas3D@@UAEXMMPBDH@Z:PROC	; Canvas3D::TextCenterVertical
EXTRN	?Circle@Canvas3D@@UAEXMMM@Z:PROC		; Canvas3D::Circle
EXTRN	?Arc@Canvas3D@@UAEXMMMMM@Z:PROC			; Canvas3D::Arc
EXTRN	?NormalizedLineHeight@Canvas3D@@UAEMXZ:PROC	; Canvas3D::NormalizedLineHeight
EXTRN	??_ECanvas3D@@UAEPAXI@Z:PROC			; Canvas3D::`vector deleting destructor'
EXTRN	?SetTextureSet@ObjectInstance@@QAEXH@Z:PROC	; ObjectInstance::SetTextureSet
EXTRN	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::AttachChild
EXTRN	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z:PROC	; DrawableBSP::DetachChild
EXTRN	?SetDOFangle@DrawableBSP@@QAEXHM@Z:PROC		; DrawableBSP::SetDOFangle
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	_F4SoundFXSetDist:PROC
EXTRN	?Exec@MFDClass@@QAEXHH@Z:PROC			; MFDClass::Exec
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?SetAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::SetAcStatusBits
EXTRN	?ClearAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::ClearAcStatusBits
EXTRN	?CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z:PROC ; AircraftClass::CopyAnimationsToPit
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?GetTurbulence@AircraftClass@@QAE?AUTpoint@@XZ:PROC ; AircraftClass::GetTurbulence
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?GetButtonId@InputFunctionHashTable@@QAEHP6AXKHPAX@Z@Z:PROC ; InputFunctionHashTable::GetButtonId
EXTRN	?FindFunctionFromString@@YAP6AXKHPAX@ZPAD@Z:PROC ; FindFunctionFromString
EXTRN	?SetFOV@OTWDriverClass@@QAEXM@Z:PROC		; OTWDriverClass::SetFOV
EXTRN	?GetFOV@OTWDriverClass@@QAEMXZ:PROC		; OTWDriverClass::GetFOV
EXTRN	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z:PROC ; OTWDriverClass::BuildHeadMatrix
EXTRN	?PadlockF3_SlewCamera@OTWDriverClass@@AAEHMMMMMMM@Z:PROC ; OTWDriverClass::PadlockF3_SlewCamera
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z:PROC ; FackClass::GetFault
EXTRN	?ExecPfl@ICPClass@@QAEXXZ:PROC			; ICPClass::ExecPfl
EXTRN	?Exec@ICPClass@@QAEXXZ:PROC			; ICPClass::Exec
EXTRN	?GetDEDStrings@ICPClass@@QAEXPAD00@Z:PROC	; ICPClass::GetDEDStrings
EXTRN	?FindToken@@YAPADPAPADPBD@Z:PROC		; FindToken
EXTRN	?CalculateNVGColor@@YAKK@Z:PROC			; CalculateNVGColor
EXTRN	?FileExists@@YAHPAD@Z:PROC			; FileExists
EXTRN	?FindCockpit@@YAHPBDW4Vis_Types@@00PADH@Z:PROC	; FindCockpit
EXTRN	?GetButtonPointer@CockpitManager@@QAEPAVCPButtonObject@@H@Z:PROC ; CockpitManager::GetButtonPointer
EXTRN	?HudFont@CockpitManager@@QAEHXZ:PROC		; CockpitManager::HudFont
EXTRN	?MFDFont@CockpitManager@@QAEHXZ:PROC		; CockpitManager::MFDFont
EXTRN	?DEDFont@CockpitManager@@QAEHXZ:PROC		; CockpitManager::DEDFont
EXTRN	?SetTarget@HudClass@@QAEXPAVSimObjectType@@@Z:PROC ; HudClass::SetTarget
EXTRN	?SetHalfAngle@HudClass@@QAEXMMM@Z:PROC		; HudClass::SetHalfAngle
EXTRN	?Display@HudClass@@QAEXPAVVirtualDisplay@@_N@Z:PROC ; HudClass::Display
EXTRN	?GetHudColor@HudClass@@QAEKXZ:PROC		; HudClass::GetHudColor
EXTRN	?GetScalesSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetScalesSwitch
EXTRN	?GetFPMSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetFPMSwitch
EXTRN	?GetDriftCOSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDriftCOSwitch
EXTRN	?GetDEDSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetDEDSwitch
EXTRN	?GetVelocitySwitch@HudClass@@QAEHXZ:PROC	; HudClass::GetVelocitySwitch
EXTRN	?GetRadarSwitch@HudClass@@QAEHXZ:PROC		; HudClass::GetRadarSwitch
EXTRN	?GetBrightnessSwitch@HudClass@@QAEHXZ:PROC	; HudClass::GetBrightnessSwitch
EXTRN	?Exec@VDial@@QAEXPAVSimBaseClass@@@Z:PROC	; VDial::Exec
EXTRN	??0VDial@@QAE@PAUVDialInitStr@@@Z:PROC		; VDial::VDial
EXTRN	??1VDial@@QAE@XZ:PROC				; VDial::~VDial
EXTRN	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z:PROC ; NavigationSystem::GetILSAttribute
EXTRN	?GetDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::GetDomain
EXTRN	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ:PROC ; NavigationSystem::GetControlSrc
EXTRN	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ:PROC ; NavigationSystem::GetInstrumentMode
EXTRN	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z:PROC ; NavigationSystem::GetTacanChannel
EXTRN	?GetTacanBand@NavigationSystem@@QAE?AW4StationSet@TacanList@@W4Tacan_Channel_Src@1@@Z:PROC ; NavigationSystem::GetTacanBand
EXTRN	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z:PROC	; CPHsi::GetValue
EXTRN	?RunSeeker@MissileClass@@QAEXXZ:PROC		; MissileClass::RunSeeker
EXTRN	?FindBestResolution@@YAHXZ:PROC			; FindBestResolution
EXTRN	?CallFunc@@YAXP6AXKHPAX@ZKH0@Z:PROC		; CallFunc
EXTRN	?RemoveInvalidChars@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z:PROC ; RemoveInvalidChars
EXTRN	_ResFOpen:PROC
EXTRN	_ResFClose:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?Origin@@3UTpoint@@B:BYTE			; Origin
EXTRN	?IMatrix@@3UTrotation@@B:BYTE			; IMatrix
EXTRN	?Font3D@VirtualDisplay@@2UFontSet@@A:BYTE	; VirtualDisplay::Font3D
EXTRN	?pFontSet@VirtualDisplay@@2PAUFontSet@@A:DWORD	; VirtualDisplay::pFontSet
EXTRN	?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A:DWORD ; VirtualDisplay::renderTexture
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?UserFunctionTable@@3VInputFunctionHashTable@@A:BYTE ; UserFunctionTable
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?DisplayOptions@@3VDisplayOptionsClass@@A:BYTE	; DisplayOptions
EXTRN	?cockpitFlightData@@3VFlightData@@A:BYTE	; cockpitFlightData
EXTRN	?hudWinY@@3PAMA:BYTE				; hudWinY
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?TheTimeOfDay@@3VCTimeOfDay@@A:BYTE		; TheTimeOfDay
EXTRN	?gxPos@@3HA:DWORD				; gxPos
EXTRN	?gyPos@@3HA:DWORD				; gyPos
EXTRN	?gSelectedCursor@@3HA:DWORD			; gSelectedCursor
EXTRN	?gTimeLastMouseMove@@3KA:DWORD			; gTimeLastMouseMove
EXTRN	?gNavigationSys@@3PAVNavigationSystem@@A:DWORD	; gNavigationSys
EXTRN	?g_bUse_DX_Engine@@3_NA:BYTE			; g_bUse_DX_Engine
EXTRN	?theTrackIRObject@@3VTrackIR@@A:BYTE		; theTrackIRObject
EXTRN	?g_fTIRMinimumFOV@@3MA:DWORD			; g_fTIRMinimumFOV
EXTRN	?g_fTIRMaximumFOV@@3MA:DWORD			; g_fTIRMaximumFOV
EXTRN	?g_n6DOFTIR@@3HA:DWORD				; g_n6DOFTIR
EXTRN	?g_fDefaultFOV@@3MA:DWORD			; g_fDefaultFOV
EXTRN	?narrowFOV@@3HA:DWORD				; narrowFOV
EXTRN	?p3DpitHilite@@3KA:DWORD			; p3DpitHilite
EXTRN	?p3DpitLolite@@3KA:DWORD			; p3DpitLolite
EXTRN	?curColorIdx@@3HA:DWORD				; curColorIdx
EXTRN	?g_b3DClickableCockpitDebug@@3_NA:BYTE		; g_b3DClickableCockpitDebug
EXTRN	?g_b3DRTTCockpitDebug@@3_NA:BYTE		; g_b3DRTTCockpitDebug
EXTRN	?FalconCockpitThrDirectory@@3PADA:BYTE		; FalconCockpitThrDirectory
EXTRN	?g_fDyn_Head_TiltMul@@3MA:DWORD			; g_fDyn_Head_TiltMul
EXTRN	?g_fDyn_Head_TiltRndGMul@@3MA:DWORD		; g_fDyn_Head_TiltRndGMul
EXTRN	?g_fDyn_Head_RollMul@@3MA:DWORD			; g_fDyn_Head_RollMul
EXTRN	?g_fDyn_Head_PanMul@@3MA:DWORD			; g_fDyn_Head_PanMul
EXTRN	?g_fDyn_Head_TiltRateMul@@3MA:DWORD		; g_fDyn_Head_TiltRateMul
EXTRN	?g_fDyn_Head_TiltGRateMul@@3MA:DWORD		; g_fDyn_Head_TiltGRateMul
EXTRN	?g_fDyn_Head_RollRate@@3MA:DWORD		; g_fDyn_Head_RollRate
EXTRN	?g_fDyn_Head_PanRate@@3MA:DWORD			; g_fDyn_Head_PanRate
EXTRN	?gameCompressionRatio@@3HA:DWORD		; gameCompressionRatio
EXTRN	?g_bUseNew3dpit@@3_NA:BYTE			; g_bUseNew3dpit
EXTRN	?g_bINS@@3_NA:BYTE				; g_bINS
EXTRN	?HSITOFROM3d@@3HA:DWORD				; HSITOFROM3d
EXTRN	?g_b3dMFDLeft@@3_NA:BYTE			; g_b3dMFDLeft
EXTRN	?g_b3dMFDRight@@3_NA:BYTE			; g_b3dMFDRight
EXTRN	?g_b3dDynamicPilotHead@@3_NA:BYTE		; g_b3dDynamicPilotHead
EXTRN	?g_b3DClickableCursorChange@@3_NA:BYTE		; g_b3DClickableCursorChange
EXTRN	?g_n3DHeadPanRange@@3HA:DWORD			; g_n3DHeadPanRange
EXTRN	?g_n3DHeadTiltRange@@3HA:DWORD			; g_n3DHeadTiltRange
EXTRN	?lMFDul@@3UTpoint@@A:BYTE			; lMFDul
EXTRN	?lMFDur@@3UTpoint@@A:BYTE			; lMFDur
EXTRN	?lMFDll@@3UTpoint@@A:BYTE			; lMFDll
EXTRN	?ltMFDleft@@3HA:DWORD				; ltMFDleft
EXTRN	?ltMFDtop@@3HA:DWORD				; ltMFDtop
EXTRN	?ltMFDright@@3HA:DWORD				; ltMFDright
EXTRN	?ltMFDbottom@@3HA:DWORD				; ltMFDbottom
EXTRN	?lcMFDblend@@3DA:BYTE				; lcMFDblend
EXTRN	?lcMFDalpha@@3MA:DWORD				; lcMFDalpha
EXTRN	?rMFDul@@3UTpoint@@A:BYTE			; rMFDul
EXTRN	?rMFDur@@3UTpoint@@A:BYTE			; rMFDur
EXTRN	?rMFDll@@3UTpoint@@A:BYTE			; rMFDll
EXTRN	?rtMFDleft@@3HA:DWORD				; rtMFDleft
EXTRN	?rtMFDtop@@3HA:DWORD				; rtMFDtop
EXTRN	?rtMFDright@@3HA:DWORD				; rtMFDright
EXTRN	?rtMFDbottom@@3HA:DWORD				; rtMFDbottom
EXTRN	?rcMFDblend@@3DA:BYTE				; rcMFDblend
EXTRN	?rcMFDalpha@@3MA:DWORD				; rcMFDalpha
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_prevILStime DD	01H DUP (?)
_BobbingPreviousTime DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c2b40000
CONST	SEGMENT
__real@c2b40000 DD 0c2b40000r			; -90
CONST	ENDS
;	COMDAT __real@c20c0000
CONST	SEGMENT
__real@c20c0000 DD 0c20c0000r			; -35
CONST	ENDS
;	COMDAT __real@c0c90fd9
CONST	SEGMENT
__real@c0c90fd9 DD 0c0c90fd9r			; -6.28318
CONST	ENDS
;	COMDAT __real@c0c00000
CONST	SEGMENT
__real@c0c00000 DD 0c0c00000r			; -6
CONST	ENDS
;	COMDAT __real@c0700000
CONST	SEGMENT
__real@c0700000 DD 0c0700000r			; -3.75
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@c0490fd9
CONST	SEGMENT
__real@c0490fd9 DD 0c0490fd9r			; -3.14159
CONST	ENDS
;	COMDAT __real@c0278d35
CONST	SEGMENT
__real@c0278d35 DD 0c0278d35r			; -2.61799
CONST	ENDS
;	COMDAT __real@c01c61a9
CONST	SEGMENT
__real@c01c61a9 DD 0c01c61a9r			; -2.44346
CONST	ENDS
;	COMDAT __real@bff5be09
CONST	SEGMENT
__real@bff5be09 DD 0bff5be09r			; -1.91986
CONST	ENDS
;	COMDAT __real@bfcd87ab
CONST	SEGMENT
__real@bfcd87ab DD 0bfcd87abr			; -1.6057
CONST	ENDS
;	COMDAT __real@bfc90fd9
CONST	SEGMENT
__real@bfc90fd9 DD 0bfc90fd9r			; -1.5708
CONST	ENDS
;	COMDAT __real@bfa00000
CONST	SEGMENT
__real@bfa00000 DD 0bfa00000r			; -1.25
CONST	ENDS
;	COMDAT __real@bf8ccccd
CONST	SEGMENT
__real@bf8ccccd DD 0bf8ccccdr			; -1.1
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf7eb852
CONST	SEGMENT
__real@bf7eb852 DD 0bf7eb852r			; -0.995
CONST	ENDS
;	COMDAT __real@bf7ae148
CONST	SEGMENT
__real@bf7ae148 DD 0bf7ae148r			; -0.98
CONST	ENDS
;	COMDAT __real@bf666666
CONST	SEGMENT
__real@bf666666 DD 0bf666666r			; -0.9
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@bf30a3d7
CONST	SEGMENT
__real@bf30a3d7 DD 0bf30a3d7r			; -0.69
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@bea8f5c3
CONST	SEGMENT
__real@bea8f5c3 DD 0bea8f5c3r			; -0.33
CONST	ENDS
;	COMDAT __real@be051eb8
CONST	SEGMENT
__real@be051eb8 DD 0be051eb8r			; -0.13
CONST	ENDS
;	COMDAT __real@bdd6774e
CONST	SEGMENT
__real@bdd6774e DD 0bdd6774er			; -0.10472
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@bda3d70a
CONST	SEGMENT
__real@bda3d70a DD 0bda3d70ar			; -0.08
CONST	ENDS
;	COMDAT __real@467ffc00
CONST	SEGMENT
__real@467ffc00 DD 0467ffc00r			; 16383
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44c80000
CONST	SEGMENT
__real@44c80000 DD 044c80000r			; 1600
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44548000
CONST	SEGMENT
__real@44548000 DD 044548000r			; 850
CONST	ENDS
;	COMDAT __real@440e4000
CONST	SEGMENT
__real@440e4000 DD 0440e4000r			; 569
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@428c0000
CONST	SEGMENT
__real@428c0000 DD 0428c0000r			; 70
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42100000
CONST	SEGMENT
__real@42100000 DD 042100000r			; 36
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41980000
CONST	SEGMENT
__real@41980000 DD 041980000r			; 19
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@4125999a
CONST	SEGMENT
__real@4125999a DD 04125999ar			; 10.35
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40f33333
CONST	SEGMENT
__real@40f33333 DD 040f33333r			; 7.6
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40c33333
CONST	SEGMENT
__real@40c33333 DD 040c33333r			; 6.1
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40b9999a
CONST	SEGMENT
__real@40b9999a DD 040b9999ar			; 5.8
CONST	ENDS
;	COMDAT __real@40a33333
CONST	SEGMENT
__real@40a33333 DD 040a33333r			; 5.1
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@409ccccd
CONST	SEGMENT
__real@409ccccd DD 0409ccccdr			; 4.9
CONST	ENDS
;	COMDAT __real@409ab021
CONST	SEGMENT
__real@409ab021 DD 0409ab021r			; 4.834
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40700000
CONST	SEGMENT
__real@40700000 DD 040700000r			; 3.75
CONST	ENDS
;	COMDAT __real@4068f5c3
CONST	SEGMENT
__real@4068f5c3 DD 04068f5c3r			; 3.64
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@40278d35
CONST	SEGMENT
__real@40278d35 DD 040278d35r			; 2.61799
CONST	ENDS
;	COMDAT __real@4021eb85
CONST	SEGMENT
__real@4021eb85 DD 04021eb85r			; 2.53
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ffe978d
CONST	SEGMENT
__real@3ffe978d DD 03ffe978dr			; 1.989
CONST	ENDS
;	COMDAT __real@3fdd0e56
CONST	SEGMENT
__real@3fdd0e56 DD 03fdd0e56r			; 1.727
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f847ae1
CONST	SEGMENT
__real@3f847ae1 DD 03f847ae1r			; 1.035
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7eb852
CONST	SEGMENT
__real@3f7eb852 DD 03f7eb852r			; 0.995
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f32b8c1
CONST	SEGMENT
__real@3f32b8c1 DD 03f32b8c1r			; 0.698132
CONST	ENDS
;	COMDAT __real@3f20d845
CONST	SEGMENT
__real@3f20d845 DD 03f20d845r			; 0.6283
CONST	ENDS
;	COMDAT __real@3f1f5c29
CONST	SEGMENT
__real@3f1f5c29 DD 03f1f5c29r			; 0.6225
CONST	ENDS
;	COMDAT __real@3f1c61a9
CONST	SEGMENT
__real@3f1c61a9 DD 03f1c61a9r			; 0.610865
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f07ae14
CONST	SEGMENT
__real@3f07ae14 DD 03f07ae14r			; 0.53
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3edf66f1
CONST	SEGMENT
__real@3edf66f1 DD 03edf66f1r			; 0.436332
CONST	ENDS
;	COMDAT __real@3ed851ec
CONST	SEGMENT
__real@3ed851ec DD 03ed851ecr			; 0.4225
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3eca3d71
CONST	SEGMENT
__real@3eca3d71 DD 03eca3d71r			; 0.395
CONST	ENDS
;	COMDAT __real@3ec147ae
CONST	SEGMENT
__real@3ec147ae DD 03ec147aer			; 0.3775
CONST	ENDS
;	COMDAT __real@3ec00000
CONST	SEGMENT
__real@3ec00000 DD 03ec00000r			; 0.375
CONST	ENDS
;	COMDAT __real@3eb0a3d7
CONST	SEGMENT
__real@3eb0a3d7 DD 03eb0a3d7r			; 0.345
CONST	ENDS
;	COMDAT __real@3ea9c91e
CONST	SEGMENT
__real@3ea9c91e DD 03ea9c91er			; 0.331613
CONST	ENDS
;	COMDAT __real@3ea8f5c3
CONST	SEGMENT
__real@3ea8f5c3 DD 03ea8f5c3r			; 0.33
CONST	ENDS
;	COMDAT __real@3ea66666
CONST	SEGMENT
__real@3ea66666 DD 03ea66666r			; 0.325
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e051eb8
CONST	SEGMENT
__real@3e051eb8 DD 03e051eb8r			; 0.13
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da949a5
CONST	SEGMENT
__real@3da949a5 DD 03da949a5r			; 0.08266
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3da1cac1
CONST	SEGMENT
__real@3da1cac1 DD 03da1cac1r			; 0.079
CONST	ENDS
;	COMDAT __real@3d9a36e3
CONST	SEGMENT
__real@3d9a36e3 DD 03d9a36e3r			; 0.0753
CONST	ENDS
;	COMDAT __real@3d8ef88c
CONST	SEGMENT
__real@3d8ef88c DD 03d8ef88cr			; 0.06981
CONST	ENDS
;	COMDAT __real@3d75c28f
CONST	SEGMENT
__real@3d75c28f DD 03d75c28fr			; 0.06
CONST	ENDS
;	COMDAT __real@3d6978d5
CONST	SEGMENT
__real@3d6978d5 DD 03d6978d5r			; 0.057
CONST	ENDS
;	COMDAT __real@3d5d97f6
CONST	SEGMENT
__real@3d5d97f6 DD 03d5d97f6r			; 0.0541
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d2db61c
CONST	SEGMENT
__real@3d2db61c DD 03d2db61cr			; 0.04241
CONST	ENDS
;	COMDAT __real@3d2c0831
CONST	SEGMENT
__real@3d2c0831 DD 03d2c0831r			; 0.042
CONST	ENDS
;	COMDAT __real@3d07c84b
CONST	SEGMENT
__real@3d07c84b DD 03d07c84br			; 0.03315
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c888f86
CONST	SEGMENT
__real@3c888f86 DD 03c888f86r			; 0.01667
CONST	ENDS
;	COMDAT __real@3c75c28f
CONST	SEGMENT
__real@3c75c28f DD 03c75c28fr			; 0.015
CONST	ENDS
;	COMDAT __real@3c3bc2b9
CONST	SEGMENT
__real@3c3bc2b9 DD 03c3bc2b9r			; 0.01146
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@Canvas3D@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Canvas3D@@8 DD FLAT:??_R0?AVCanvas3D@@@8	; Canvas3D::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Canvas3D@@8
rdata$r	ENDS
;	COMDAT ??_R2Canvas3D@@8
rdata$r	SEGMENT
??_R2Canvas3D@@8 DD FLAT:??_R1A@?0A@EA@Canvas3D@@8	; Canvas3D::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R3Canvas3D@@8
rdata$r	SEGMENT
??_R3Canvas3D@@8 DD 00H					; Canvas3D::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Canvas3D@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCanvas3D@@@8
_DATA	SEGMENT
??_R0?AVCanvas3D@@@8 DD FLAT:??_7type_info@@6B@		; Canvas3D `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCanvas3D@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Canvas3D@@6B@
rdata$r	SEGMENT
??_R4Canvas3D@@6B@ DD 00H				; Canvas3D::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCanvas3D@@@8
	DD	FLAT:??_R3Canvas3D@@8
rdata$r	ENDS
;	COMDAT ??_R4Render2D@@6B@
rdata$r	SEGMENT
??_R4Render2D@@6B@ DD 00H				; Render2D::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRender2D@@@8
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R4VirtualDisplay@@6B@
rdata$r	SEGMENT
??_R4VirtualDisplay@@6B@ DD 00H				; VirtualDisplay::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVirtualDisplay@@@8
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2VirtualDisplay@@8
rdata$r	SEGMENT
??_R2VirtualDisplay@@8 DD FLAT:??_R1A@?0A@EA@VirtualDisplay@@8 ; VirtualDisplay::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VirtualDisplay@@8
rdata$r	SEGMENT
??_R3VirtualDisplay@@8 DD 00H				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVirtualDisplay@@@8
_DATA	SEGMENT
??_R0?AVVirtualDisplay@@@8 DD FLAT:??_7type_info@@6B@	; VirtualDisplay `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVirtualDisplay@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VirtualDisplay@@8 DD FLAT:??_R0?AVVirtualDisplay@@@8 ; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2Render2D@@8
rdata$r	SEGMENT
??_R2Render2D@@8 DD FLAT:??_R1A@?0A@EA@Render2D@@8	; Render2D::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R3Render2D@@8
rdata$r	SEGMENT
??_R3Render2D@@8 DD 00H					; Render2D::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRender2D@@@8
_DATA	SEGMENT
??_R0?AVRender2D@@@8 DD FLAT:??_7type_info@@6B@		; Render2D `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRender2D@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Render2D@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Render2D@@8 DD FLAT:??_R0?AVRender2D@@@8	; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGIJNBCN@?$CFs?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@CGIJNBCN@?$CFs?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd?$AA@ DB '%'
	DB	's %f %f %f %f %d %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCGKJIDE@art?2ckptart?2?$AA@
CONST	SEGMENT
??_C@_0N@LCGKJIDE@art?2ckptart?2?$AA@ DB 'art\ckptart\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@ DB '%s\%s\%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHKGGCCB@?$CFs?2?$CFd?2?$CFs?$AA@
CONST	SEGMENT
??_C@_08JHKGGCCB@?$CFs?2?$CFd?2?$CFs?$AA@ DB '%s\%d\%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ?vcockfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
_DATA	SEGMENT
?vcockfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB DD FLAT:??_C@_0M@JEIKDHB@3dckpit?4dat?$AA@ ; `OTWDriverClass::Button3D_Init'::`2'::vcockfile
_DATA	ENDS
;	COMDAT ??_C@_0O@LJEPPKJG@3dbuttons?4dat?$AA@
CONST	SEGMENT
??_C@_0O@LJEPPKJG@3dbuttons?4dat?$AA@ DB '3dbuttons.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
_DATA	SEGMENT
?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB DD FLAT:??_C@_0O@LJEPPKJG@3dbuttons?4dat?$AA@ ; `OTWDriverClass::Button3D_Init'::`2'::buttonfile
_DATA	ENDS
;	COMDAT ??_C@_0M@MEJOGGLB@usenew3dpit?$AA@
CONST	SEGMENT
??_C@_0M@MEJOGGLB@usenew3dpit?$AA@ DB 'usenew3dpit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HAIMJJDN@boresighty?$AA@
CONST	SEGMENT
??_C@_0L@HAIMJJDN@boresighty?$AA@ DB 'boresighty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFBKOAGD@liftlinecolor?$AA@
CONST	SEGMENT
??_C@_0O@BFBKOAGD@liftlinecolor?$AA@ DB 'liftlinecolor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMMBEINF@zbuffering?$AA@
CONST	SEGMENT
??_C@_0L@OMMBEINF@zbuffering?$AA@ DB 'zbuffering', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GLLLAGML@damagedmodel?$AA@
CONST	SEGMENT
??_C@_0N@GLLLAGML@damagedmodel?$AA@ DB 'damagedmodel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLEBLAKK@mainmodel?$AA@
CONST	SEGMENT
??_C@_09PLEBLAKK@mainmodel?$AA@ DB 'mainmodel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFJPBPOJ@cockpitdfmodel?$AA@
CONST	SEGMENT
??_C@_0P@BFJPBPOJ@cockpitdfmodel?$AA@ DB 'cockpitdfmodel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECHNMOHL@cockpitmodel?$AA@
CONST	SEGMENT
??_C@_0N@ECHNMOHL@cockpitmodel?$AA@ DB 'cockpitmodel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MDNHPGJO@lowlight?$AA@
CONST	SEGMENT
??_C@_08MDNHPGJO@lowlight?$AA@ DB 'lowlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MIAHMBP@highlight?$AA@
CONST	SEGMENT
??_C@_09MIAHMBP@highlight?$AA@ DB 'highlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KALBBLDD@rwrcolor?$AA@
CONST	SEGMENT
??_C@_08KALBBLDD@rwrcolor?$AA@ DB 'rwrcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFPLLPGK@dedcolor?$AA@
CONST	SEGMENT
??_C@_08EFPLLPGK@dedcolor?$AA@ DB 'dedcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ICOPBLPG@needlecolor1?$AA@
CONST	SEGMENT
??_C@_0N@ICOPBLPG@needlecolor1?$AA@ DB 'needlecolor1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JLPECKLH@needlecolor0?$AA@
CONST	SEGMENT
??_C@_0N@JLPECKLH@needlecolor0?$AA@ DB 'needlecolor0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECDAFED@padlocktick?$AA@
CONST	SEGMENT
??_C@_0M@ECDAFED@padlocktick?$AA@ DB 'padlocktick', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKBBNJNL@padlockvptop?$AA@
CONST	SEGMENT
??_C@_0N@CKBBNJNL@padlockvptop?$AA@ DB 'padlockvptop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFMFANAH@padlockvpside?$AA@
CONST	SEGMENT
??_C@_0O@IFMFANAH@padlockvpside?$AA@ DB 'padlockvpside', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBCBKCMN@padlockliftline?$AA@
CONST	SEGMENT
??_C@_0BA@MBCBKCMN@padlockliftline?$AA@ DB 'padlockliftline', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDGLCNBI@padlockbg?$AA@
CONST	SEGMENT
??_C@_09BDGLCNBI@padlockbg?$AA@ DB 'padlockbg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPCGAGCC@DIAL?$AA@
CONST	SEGMENT
??_C@_04FPCGAGCC@DIAL?$AA@ DB 'DIAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEAJBMEO@mfdright?$AA@
CONST	SEGMENT
??_C@_08KEAJBMEO@mfdright?$AA@ DB 'mfdright', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PNADDHHC@mfdleft?$AA@
CONST	SEGMENT
??_C@_07PNADDHHC@mfdleft?$AA@ DB 'mfdleft', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EHJPLJNA@MACHASI?$AA@
CONST	SEGMENT
??_C@_07EHJPLJNA@MACHASI?$AA@ DB 'MACHASI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAJGBDEG@pfl?$AA@
CONST	SEGMENT
??_C@_03DAJGBDEG@pfl?$AA@ DB 'pfl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CIIJCKKD@DED?$AA@
CONST	SEGMENT
??_C@_03CIIJCKKD@DED?$AA@ DB 'DED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FDDKCNFF@rwr?$AA@
CONST	SEGMENT
??_C@_03FDDKCNFF@rwr?$AA@ DB 'rwr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDICPLBH@hud?$AA@
CONST	SEGMENT
??_C@_03HDICPLBH@hud?$AA@ DB 'hud', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@ DB '%d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JALPCOHE@rtttarget?$AA@
CONST	SEGMENT
??_C@_09JALPCOHE@rtttarget?$AA@ DB 'rtttarget', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
CONST	SEGMENT
?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB DB 020H ; `OTWDriverClass::VCock_Init'::`2'::pseparators
	DB	02cH
	DB	03dH
	DB	03bH
	DB	0dH
	DB	0aH
	DB	09H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_0M@JEIKDHB@3dckpit?4dat?$AA@
CONST	SEGMENT
??_C@_0M@JEIKDHB@3dckpit?4dat?$AA@ DB '3dckpit.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ?pCPFile@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4PBDB
_DATA	SEGMENT
?pCPFile@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4PBDB DD FLAT:??_C@_0M@JEIKDHB@3dckpit?4dat?$AA@ ; `OTWDriverClass::VCock_Init'::`2'::pCPFile
_DATA	ENDS
;	COMDAT ??_C@_07OKLNCIDH@destloc?$AA@
CONST	SEGMENT
??_C@_07OKLNCIDH@destloc?$AA@ DB 'destloc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BALDINCG@callbackslot?$AA@
CONST	SEGMENT
??_C@_0N@BALDINCG@callbackslot?$AA@ DB 'callbackslot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPHMLOFF@?$CFlx?$AA@
CONST	SEGMENT
??_C@_03OPHMLOFF@?$CFlx?$AA@ DB '%lx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGNLDMKC@color0?$AA@
CONST	SEGMENT
??_C@_06JGNLDMKC@color0?$AA@ DB 'color0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ILDOBJAO@radius0?$AA@
CONST	SEGMENT
??_C@_07ILDOBJAO@radius0?$AA@ DB 'radius0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GEKOPAHD@values?$AA@
CONST	SEGMENT
??_C@_06GEKOPAHD@values?$AA@ DB 'values', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GPGIDCJA@points?$AA@
CONST	SEGMENT
??_C@_06GPGIDCJA@points?$AA@ DB 'points', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NJACGLBK@numendpoints?$AA@
CONST	SEGMENT
??_C@_0N@NJACGLBK@numendpoints?$AA@ DB 'numendpoints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PAJMBCIO@?$CDend?$AA@
CONST	SEGMENT
??_C@_04PAJMBCIO@?$CDend?$AA@ DB '#end', 00H		; `string'
CONST	ENDS
;	COMDAT ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
CONST	SEGMENT
?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB DB 020H ; `OTWDriverClass::VCock_ParseVDial'::`2'::pseparators
	DB	02cH
	DB	03dH
	DB	03bH
	DB	0dH
	DB	0aH
	DB	09H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_0BL@PNBJJOIP@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@
CONST	SEGMENT
??_C@_0BL@PNBJJOIP@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@ DB '%'
	DB	'f %f %f %f %f %f %f %f %f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HGJLILKD@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0CN@HGJLILKD@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd@ DB '%'
	DB	'f %f %f %f %f %f %f %f %f %d %d %d %d %c %f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
CONST	SEGMENT
??_C@_03OCLOCGE@?$DN?$DL?6?$AA@ DB '=;', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_7Canvas3D@@6B@
CONST	SEGMENT
??_7Canvas3D@@6B@ DD FLAT:??_R4Canvas3D@@6B@		; Canvas3D::`vftable'
	DD	FLAT:??_ECanvas3D@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@Canvas3D@@UAEXXZ
	DD	FLAT:?StartDraw@Canvas3D@@UAEXXZ
	DD	FLAT:?ClearDraw@Canvas3D@@UAEXXZ
	DD	FLAT:?EndDraw@Canvas3D@@UAEXXZ
	DD	FLAT:?Point@Canvas3D@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@Canvas3D@@UAEXMMMM@Z
	DD	FLAT:?Tri@Canvas3D@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@Canvas3D@@UAEXMMM@Z
	DD	FLAT:?Arc@Canvas3D@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@Canvas3D@@UAEMPAD@Z
	DD	FLAT:?TextHeight@Canvas3D@@UAEMXZ
	DD	FLAT:?SetColor@Canvas3D@@UAEXK@Z
	DD	FLAT:?SetBackground@Canvas3D@@UAEXK@Z
	DD	FLAT:?ScreenText@Canvas3D@@UAEXMMPBDH@Z
	DD	FLAT:?SetLineStyle@Canvas3D@@UAEXH@Z
	DD	FLAT:?Color@Canvas3D@@UAEKXZ
	DD	FLAT:?SetViewport@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Render2DPoint@Canvas3D@@UAEXMM@Z
	DD	FLAT:?Render2DLine@Canvas3D@@UAEXMMMM@Z
	DD	FLAT:?Render2DTri@Canvas3D@@UAEXMMMMMM@Z
	DD	FLAT:?Setup@Canvas3D@@UAEXPAVRender3D@@@Z
	DD	FLAT:?NormalizedLineHeight@Canvas3D@@UAEMXZ
CONST	ENDS
;	COMDAT ??_7Render2D@@6B@
CONST	SEGMENT
??_7Render2D@@6B@ DD FLAT:??_R4Render2D@@6B@		; Render2D::`vftable'
	DD	FLAT:??_ERender2D@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@Render2D@@UAEXXZ
	DD	FLAT:?StartDraw@Render2D@@UAEXXZ
	DD	FLAT:?ClearDraw@Render2D@@UAEXXZ
	DD	FLAT:?EndDraw@Render2D@@UAEXXZ
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:?SetColor@Render2D@@UAEXK@Z
	DD	FLAT:?SetBackground@Render2D@@UAEXK@Z
	DD	FLAT:?ScreenText@Render2D@@UAEXMMPBDH@Z
	DD	FLAT:?SetLineStyle@Render2D@@UAEXH@Z
	DD	FLAT:?Color@Render2D@@UAEKXZ
	DD	FLAT:?SetViewport@Render2D@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Render2DPoint@Render2D@@UAEXMM@Z
	DD	FLAT:?Render2DLine@Render2D@@UAEXMMMM@Z
	DD	FLAT:?Render2DTri@Render2D@@UAEXMMMMMM@Z
	DD	FLAT:?Setup@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?ClearZBuffer@Render2D@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7VirtualDisplay@@6B@
CONST	SEGMENT
??_7VirtualDisplay@@6B@ DD FLAT:??_R4VirtualDisplay@@6B@ ; VirtualDisplay::`vftable'
	DD	FLAT:??_EVirtualDisplay@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@VirtualDisplay@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?SetLineStyle@VirtualDisplay@@UAEXH@Z
	DD	FLAT:?Color@VirtualDisplay@@UAEKXZ
	DD	FLAT:?SetViewport@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z$0
__ehfuncinfo$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z$0
__unwindtable$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z$0
__unwindtable$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z$0
__ehfuncinfo$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_prevILStime$initializer$ DD FLAT:??__EprevILStime@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_BobbingPreviousTime$initializer$ DD FLAT:??__EBobbingPreviousTime@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVVDial@@PAV1@PAV1@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVVDial@@PAV1@PAV1@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<VDial *,VDial *,VDial *>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 459  : 	_DEBUG_RANGE(_First, _Last);
; 460  : 	_DEBUG_POINTER(_Dest);
; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAVVDial@@PAV1@PAV1@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<VDial *,VDial *,VDial *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVVDial@@@std@@YAPAPAVVDial@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVVDial@@@std@@YAPAPAVVDial@@PAPAV1@@Z PROC ; std::_Val_type<VDial * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAPAVVDial@@@std@@YAPAPAVVDial@@PAPAV1@@Z ENDP ; std::_Val_type<VDial * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z PROC ; std::allocator<VDial *>::construct<VDial *,VDial * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z ; std::forward<VDial * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z ENDP ; std::allocator<VDial *>::construct<VDial *,VDial * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVVDial@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVVDial@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z PROC ; std::_Uninitialized_move<VDial * *,VDial * *,std::_Wrap_alloc<std::allocator<VDial *> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVVDial@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVVDial@@0@Z ; std::_Ptr_cat<VDial *,VDial *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVVDial@@@std@@YAPAPAVVDial@@PAPAV1@@Z ; std::_Val_type<VDial * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAVVDial@@PAV1@PAV1@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<VDial *,VDial *,VDial *>
	add	esp, 24					; 00000018H

; 474  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAVVDial@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<VDial * *,VDial * *,std::_Wrap_alloc<std::allocator<VDial *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 97   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVVDial@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVVDial@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVVDial@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVVDial@@0@Z PROC ; std::_Ptr_cat<VDial *,VDial *>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAVVDial@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVVDial@@0@Z ENDP ; std::_Ptr_cat<VDial *,VDial *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVVDial@@ABQAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVVDial@@ABQAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVVDial@@@std@@YAABQAVVDial@@ABQAV1@@Z ; std::forward<VDial * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@ABQAV3@@Z ; std::allocator<VDial *>::construct
	pop	ebp
	ret	0
??$construct@PAVVDial@@ABQAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVVDial@@@std@@YAABQAVVDial@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVVDial@@@std@@YAABQAVVDial@@ABQAV1@@Z PROC ; std::forward<VDial * const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@ABQAVVDial@@@std@@YAABQAVVDial@@ABQAV1@@Z ENDP ; std::forward<VDial * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVVDial@@AAPAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVVDial@@AAPAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z ; std::forward<VDial * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVVDial@@AAPAV1@@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z ; std::allocator<VDial *>::construct<VDial *,VDial * &>
	pop	ebp
	ret	0
??$construct@PAVVDial@@AAPAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z PROC ; std::forward<VDial * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z ENDP ; std::forward<VDial * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVVDial@@@std@@YAPAPAVVDial@@IPAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVVDial@@@std@@YAPAPAVVDial@@IPAPAV1@@Z PROC ; std::_Allocate<VDial *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVVDial@@@std@@YAPAPAVVDial@@IPAPAV1@@Z ENDP ; std::_Allocate<VDial *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVVDial@@@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEPAPAVVDial@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVVDial@@@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEPAPAVVDial@@PAPAV2@00@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Umove<VDial * *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAPAVVDial@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAPAPAVVDial@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z ; std::_Uninitialized_move<VDial * *,VDial * *,std::_Wrap_alloc<std::allocator<VDial *> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVVDial@@@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEPAPAVVDial@@PAPAV2@00@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Umove<VDial * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVVDial@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVVDial@@0@Z ; std::_Ptr_cat<VDial *,VDial *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVVDial@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVVDial@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVVDial@@@std@@YAABQAVVDial@@ABQAV1@@Z ; std::forward<VDial * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVVDial@@ABQAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@ABQAV3@@Z ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * const &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVVDial@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVVDial@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVVDial@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVVDial@@@std@@YAAAPAVVDial@@AAPAV1@@Z ; std::forward<VDial * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVVDial@@AAPAV1@@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAXAAV?$allocator@PAVVDial@@@1@PAPAVVDial@@AAPAV3@@Z ; std::allocator_traits<std::allocator<VDial *> >::construct<VDial *,VDial * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVVDial@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVVDial@@@std@@YAPBQAVVDial@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVVDial@@@std@@YAPBQAVVDial@@ABQAV1@@Z PROC ; std::addressof<VDial * const>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@QAVVDial@@@std@@YAPBQAVVDial@@ABQAV1@@Z ENDP ; std::addressof<VDial * const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtgmath.h
;	COMDAT ??$pow@HH@@YANHH@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$pow@HH@@YANHH@Z PROC					; pow<int,int>, COMDAT

; 80   : 	{	// bring mixed types to a common type

	push	ebp
	mov	ebp, esp

; 81   : 	typedef typename _STD _Common_float_type<_Ty1, _Ty2>::type type;
; 82   : 	return (_CSTD pow(type(_Left), type(_Right)));

	cvtsi2sd xmm0, DWORD PTR __Right$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtsi2sd xmm0, DWORD PTR __Left$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H

; 83   : 	}

	pop	ebp
	ret	0
??$pow@HH@@YANHH@Z ENDP					; pow<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
;	COMDAT ?ExtractDigit@@YAHMH@Z
_TEXT	SEGMENT
tv76 = -16						; size = 8
tv84 = -8						; size = 8
_number$ = 8						; size = 4
_digit$ = 12						; size = 4
?ExtractDigit@@YAHMH@Z PROC				; ExtractDigit, COMDAT

; 1211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1212 : 	return (int)( number / pow( 10, digit ) ) % 10;

	cvtss2sd xmm0, DWORD PTR _number$[ebp]
	mov	eax, DWORD PTR _digit$[ebp]
	push	eax
	push	10					; 0000000aH
	movsd	QWORD PTR tv84[ebp], xmm0
	call	??$pow@HH@@YANHH@Z			; pow<int,int>
	add	esp, 8
	fstp	QWORD PTR tv76[ebp]
	movsd	xmm0, QWORD PTR tv84[ebp]
	divsd	xmm0, QWORD PTR tv76[ebp]
	cvttsd2si eax, xmm0
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	eax, edx

; 1213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ExtractDigit@@YAHMH@Z ENDP				; ExtractDigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
;	COMDAT ??__EBobbingPreviousTime@@YAXXZ
text$yc	SEGMENT
??__EBobbingPreviousTime@@YAXXZ PROC			; `dynamic initializer for 'BobbingPreviousTime'', COMDAT

; 113  : static long  BobbingPreviousTime = vuxGameTime;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _BobbingPreviousTime, eax
	pop	ebp
	ret	0
??__EBobbingPreviousTime@@YAXXZ ENDP			; `dynamic initializer for 'BobbingPreviousTime''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
;	COMDAT ??__EprevILStime@@YAXXZ
text$yc	SEGMENT
??__EprevILStime@@YAXXZ PROC				; `dynamic initializer for 'prevILStime'', COMDAT

; 100  : static long  prevILStime = vuxGameTime;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _prevILStime, eax
	pop	ebp
	ret	0
??__EprevILStime@@YAXXZ ENDP				; `dynamic initializer for 'prevILStime''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\trackir.h
;	COMDAT ?getZ@TrackIR@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getZ@TrackIR@@QAEMXZ PROC				; TrackIR::getZ, COMDAT
; _this$ = ecx

; 28   : 	float getZ() { return z;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getZ@TrackIR@@QAEMXZ ENDP				; TrackIR::getZ
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\trackir.h
;	COMDAT ?getY@TrackIR@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getY@TrackIR@@QAEMXZ PROC				; TrackIR::getY, COMDAT
; _this$ = ecx

; 27   : 	float getY() { return y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getY@TrackIR@@QAEMXZ ENDP				; TrackIR::getY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\trackir.h
;	COMDAT ?getX@TrackIR@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getX@TrackIR@@QAEMXZ PROC				; TrackIR::getX, COMDAT
; _this$ = ecx

; 26   : 	float getX() { return x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?getX@TrackIR@@QAEMXZ ENDP				; TrackIR::getX
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVDial@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVDial@@QAEPAXI@Z PROC				; VDial::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VDial@@QAE@XZ			; VDial::~VDial
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVDial@@QAEPAXI@Z ENDP				; VDial::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetNVGmode@CTimeOfDay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNVGmode@CTimeOfDay@@QAEHXZ PROC			; CTimeOfDay::GetNVGmode, COMDAT
; _this$ = ecx

; 69   : 	BOOL GetNVGmode()							{ return NVGmode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+348]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNVGmode@CTimeOfDay@@QAEHXZ ENDP			; CTimeOfDay::GetNVGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_gen$ = 8						; size = 4
?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z PROC ; AirframeClass::GeneratorRunning, COMDAT
; _this$ = ecx

; 1130 : 	BOOL GeneratorRunning(Generator gen) { return (generators & gen) ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1804]
	and	ecx, DWORD PTR _gen$[ebp]
	je	SHORT $LN3@GeneratorR
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@GeneratorR
$LN3@GeneratorR:
	mov	DWORD PTR tv67[ebp], 0
$LN4@GeneratorR:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ENDP ; AirframeClass::GeneratorRunning
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ PROC	; AirframeClass::GetAirSource, COMDAT
; _this$ = ecx

; 1112 : 	AirSource GetAirSource() { return airSource; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1800]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ENDP	; AirframeClass::GetAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ PROC	; AirframeClass::GetFuelPump, COMDAT
; _this$ = ecx

; 1091 : 	FuelPump GetFuelPump() { return fuelPump; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1684]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ENDP	; AirframeClass::GetFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ PROC ; AirframeClass::GetFuelSwitch, COMDAT
; _this$ = ecx

; 1082 : 	FuelSwitch GetFuelSwitch() { return fuelSwitch; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1680]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ENDP ; AirframeClass::GetFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_ef$ = 8						; size = 4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z PROC ; AirframeClass::IsEngineFlag, COMDAT
; _this$ = ecx

; 1070 : 	int IsEngineFlag(EngineFlags ef) { return (engineFlags & ef) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	and	ecx, DWORD PTR _ef$[ebp]
	je	SHORT $LN3@IsEngineFl
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEngineFl
$LN3@IsEngineFl:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEngineFl:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ENDP ; AirframeClass::IsEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HydraulicB@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HydraulicB@AirframeClass@@QAEHXZ PROC			; AirframeClass::HydraulicB, COMDAT
; _this$ = ecx

; 1040 : 	int HydraulicB() { return (hydrAB & HYDR_B_SYSTEM); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1601]
	and	eax, 2
	mov	esp, ebp
	pop	ebp
	ret	0
?HydraulicB@AirframeClass@@QAEHXZ ENDP			; AirframeClass::HydraulicB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HydraulicA@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HydraulicA@AirframeClass@@QAEHXZ PROC			; AirframeClass::HydraulicA, COMDAT
; _this$ = ecx

; 1039 : 	int HydraulicA() { return (hydrAB & HYDR_A_SYSTEM); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1601]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?HydraulicA@AirframeClass@@QAEHXZ ENDP			; AirframeClass::HydraulicA
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ PROC	; AirframeClass::GetEpuSwitch, COMDAT
; _this$ = ecx

; 1021 : 	EpuState GetEpuSwitch () { return epuState; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1596]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ENDP	; AirframeClass::GetEpuSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?Ownship@HudClass@@QAEPAVAircraftClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Ownship@HudClass@@QAEPAVAircraftClass@@XZ PROC		; HudClass::Ownship, COMDAT
; _this$ = ecx

; 253  : 	AircraftClass*	Ownship(void) {return ownship;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?Ownship@HudClass@@QAEPAVAircraftClass@@XZ ENDP		; HudClass::Ownship
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\flightdata.h
;	COMDAT ?IsSetHsi@FlightData@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newBit$ = 8						; size = 4
?IsSetHsi@FlightData@@QAEHH@Z PROC			; FlightData::IsSetHsi, COMDAT
; _this$ = ecx

; 288  :     int  IsSetHsi (int newBit) {return ((hsiBits & newBit) ? TRUE : FALSE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	and	ecx, DWORD PTR _newBit$[ebp]
	je	SHORT $LN3@IsSetHsi
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSetHsi
$LN3@IsSetHsi:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSetHsi:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetHsi@FlightData@@QAEHH@Z ENDP			; FlightData::IsSetHsi
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\flightdata.h
;	COMDAT ?IsSet@FlightData@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newBit$ = 8						; size = 4
?IsSet@FlightData@@QAEHH@Z PROC				; FlightData::IsSet, COMDAT
; _this$ = ecx

; 276  :     int  IsSet (int newBit) {return ((lightBits & newBit) ? TRUE : FALSE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	and	ecx, DWORD PTR _newBit$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@FlightData@@QAEHH@Z ENDP				; FlightData::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_child$ = -12						; size = 4
_sms$ = -8						; size = 4
_stationNum$ = -4					; size = 4
?CockDetachWeapons@OTWDriverClass@@QAEXXZ PROC		; OTWDriverClass::CockDetachWeapons
; _this$ = ecx

; 1413 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1414 :     int				stationNum;
; 1415 :     SMSClass		*sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	DWORD PTR _sms$[ebp], eax

; 1416 :     DrawableBSP*	child;
; 1417 : 	for (stationNum=1; stationNum < sms->NumHardpoints(); stationNum++)

	mov	DWORD PTR _stationNum$[ebp], 1
	jmp	SHORT $LN4@CockDetach
$LN3@CockDetach:
	mov	ecx, DWORD PTR _stationNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stationNum$[ebp], ecx
$LN4@CockDetach:
	mov	ecx, DWORD PTR _sms$[ebp]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _stationNum$[ebp], eax
	jge	SHORT $LN5@CockDetach

; 1418 : 	{
; 1419 : 		// MLR 2/20/2004 - new rack code, compatible with SP3 still
; 1420 : 		child = sms->hardPoint[stationNum]->GetTopDrawable();

	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _child$[ebp], eax

; 1421 : 		if (child) vrCockpit->DetachChild( child, stationNum-1 );

	cmp	DWORD PTR _child$[ebp], 0
	je	SHORT $LN1@CockDetach
	mov	ecx, DWORD PTR _stationNum$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _child$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?DetachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::DetachChild
$LN1@CockDetach:

; 1422 : 	}

	jmp	SHORT $LN3@CockDetach
$LN5@CockDetach:

; 1423 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CockDetachWeapons@OTWDriverClass@@QAEXXZ ENDP		; OTWDriverClass::CockDetachWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_child$ = -12						; size = 4
_sms$ = -8						; size = 4
_stationNum$ = -4					; size = 4
?CockAttachWeapons@OTWDriverClass@@QAEXXZ PROC		; OTWDriverClass::CockAttachWeapons
; _this$ = ecx

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1400 :     int				stationNum;
; 1401 :     SMSClass		*sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	DWORD PTR _sms$[ebp], eax

; 1402 :     DrawableBSP*	child;
; 1403 : 	for (stationNum=1; stationNum < sms->NumHardpoints(); stationNum++)

	mov	DWORD PTR _stationNum$[ebp], 1
	jmp	SHORT $LN4@CockAttach
$LN3@CockAttach:
	mov	ecx, DWORD PTR _stationNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stationNum$[ebp], ecx
$LN4@CockAttach:
	mov	ecx, DWORD PTR _sms$[ebp]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _stationNum$[ebp], eax
	jge	SHORT $LN5@CockAttach

; 1404 : 	{
; 1405 : 		// MLR 2/20/2004 - new rack code, compatible with SP3 still
; 1406 : 		child = sms->hardPoint[stationNum]->GetTopDrawable();

	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _stationNum$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+108]
	call	eax
	mov	DWORD PTR _child$[ebp], eax

; 1407 : 		if (child) vrCockpit->AttachChild( child, stationNum-1 );

	cmp	DWORD PTR _child$[ebp], 0
	je	SHORT $LN1@CockAttach
	mov	ecx, DWORD PTR _stationNum$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _child$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?AttachChild@DrawableBSP@@QAEXPAV1@H@Z	; DrawableBSP::AttachChild
$LN1@CockAttach:

; 1408 : 	}

	jmp	SHORT $LN3@CockAttach
$LN5@CockAttach:

; 1409 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CockAttachWeapons@OTWDriverClass@@QAEXXZ ENDP		; OTWDriverClass::CockAttachWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv302 = -916						; size = 4
tv81 = -912						; size = 4
tv307 = -908						; size = 4
tv305 = -904						; size = 4
_matchedfields$2 = -900					; size = 4
_tempfunc$3 = -896					; size = 4
_Button3DDataFile$ = -892				; size = 4
_this$ = -888						; size = 4
$T4 = -884						; size = 24
$T5 = -860						; size = 24
_name$6 = -836						; size = 24
_nameNCTR$7 = -812					; size = 24
_tempfunction$ = -788					; size = 256
_templine$ = -532					; size = 256
_strCPFile$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eCPVisType$ = 8					; size = 4
_eCPName$ = 12						; size = 4
_eCPNameNCTR$ = 16					; size = 4
?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z PROC	; OTWDriverClass::Button3D_Init
; _this$ = ecx

; 3314 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 904				; 00000388H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3315 :     char strCPFile[MAX_PATH];
; 3316 :     static const TCHAR *buttonfile = "3dbuttons.dat";
; 3317 : 	static const TCHAR *vcockfile = "3dckpit.dat";			//Wombat778 10-15-2003
; 3318 :     FILE*			Button3DDataFile;
; 3319 : 	char templine[256];
; 3320 : 	char tempfunction[256];
; 3321 :     
; 3322 : //    FindCockpit(pCPFile, (Vis_Types)eCPVisType, eCPName, eCPNameNCTR, strCPFile);
; 3323 : 
; 3324 : 	//Wombat778 10-15-2003 Replaced the findcockpit call with a sequence that should mean that a button file only loads if it is in
; 3325 : 	//the same folder as the 3d cockpit file.  This should solve the problem of an f-16 button file with another planes 3d pit.
; 3326 : 
; 3327 : 	if(eCPVisType == MapVisId(VIS_F16C))

	push	1052					; 0000041cH
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	cmp	DWORD PTR _eCPVisType$[ebp], eax
	jne	SHORT $LN15@Button3D_I

; 3328 : 		// RV - Biker
; 3329 : 		//sprintf(strCPFile, "%s%s", FalconCockpitThrDirectory, buttonfile);
; 3330 : 		sprintf(strCPFile, "%s\\%s", FalconCockpitThrDirectory, buttonfile);

	mov	eax, DWORD PTR ?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	ecx, DWORD PTR _strCPFile$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3331 : 	else

	jmp	$LN14@Button3D_I
$LN15@Button3D_I:

; 3332 : 	{
; 3333 : 		// RV - Biker
; 3334 : 		//sprintf(strCPFile, "%s%d\\%s", FalconCockpitThrDirectory, MapVisId(eCPVisType), vcockfile);
; 3335 : 		sprintf(strCPFile, "%s\\%d\\%s", FalconCockpitThrDirectory, MapVisId(eCPVisType), vcockfile);

	mov	edx, DWORD PTR ?vcockfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	edx
	mov	eax, DWORD PTR _eCPVisType$[ebp]
	push	eax
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_08JHKGGCCB@?$CFs?2?$CFd?2?$CFs?$AA@
	lea	ecx, DWORD PTR _strCPFile$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3336 : 		
; 3337 : 		// RV - Biker - No more res manager
; 3338 : 		//if(ResExistFile(strCPFile))
; 3339 : 		if(FileExists(strCPFile))

	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	?FileExists@@YAHPAD@Z			; FileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Button3D_I

; 3340 : 			// RV - Biker
; 3341 : 			//sprintf(strCPFile, "%s%d\\%s", FalconCockpitThrDirectory, MapVisId(eCPVisType), buttonfile);
; 3342 : 			sprintf(strCPFile, "%s\\%d\\%s", FalconCockpitThrDirectory, MapVisId(eCPVisType), buttonfile);

	mov	eax, DWORD PTR ?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	eax
	mov	ecx, DWORD PTR _eCPVisType$[ebp]
	push	ecx
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_08JHKGGCCB@?$CFs?2?$CFd?2?$CFs?$AA@
	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3343 : 		else

	jmp	$LN14@Button3D_I
$LN13@Button3D_I:

; 3344 : 		{
; 3345 : 			std::string name = RemoveInvalidChars(string(eCPName, 15));

	push	15					; 0000000fH
	mov	eax, DWORD PTR _eCPName$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv307[ebp], eax
	mov	ecx, DWORD PTR tv307[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv302[ebp]
	push	edx
	lea	eax, DWORD PTR _name$6[ebp]
	push	eax
	call	?RemoveInvalidChars@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; RemoveInvalidChars
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 3346 : 			
; 3347 : 			// RV - Biker
; 3348 : 			//sprintf(strCPFile, "%s%s\\%s", FalconCockpitThrDirectory, name.c_str(), vcockfile);			
; 3349 : 			sprintf(strCPFile, "%s\\%s\\%s", FalconCockpitThrDirectory, name.c_str(), vcockfile);

	mov	ecx, DWORD PTR ?vcockfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	ecx
	lea	ecx, DWORD PTR _name$6[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@
	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3350 : 			
; 3351 : 			// RV - Biker - No more res manager
; 3352 : 			//if(ResExistFile(strCPFile))
; 3353 : 			if(FileExists(strCPFile))

	lea	eax, DWORD PTR _strCPFile$[ebp]
	push	eax
	call	?FileExists@@YAHPAD@Z			; FileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@Button3D_I

; 3354 : 				// RV - Biker
; 3355 : 				//sprintf(strCPFile, "%s%s\\%s", FalconCockpitThrDirectory, name.c_str(), buttonfile);
; 3356 : 				sprintf(strCPFile, "%s\\%s\\%s", FalconCockpitThrDirectory, name.c_str(), buttonfile);

	mov	ecx, DWORD PTR ?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	ecx
	lea	ecx, DWORD PTR _name$6[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@
	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3357 : 			else

	jmp	$LN10@Button3D_I
$LN11@Button3D_I:

; 3358 : 			{
; 3359 : 				std::string nameNCTR = RemoveInvalidChars(string(eCPNameNCTR, 5));

	push	5
	mov	eax, DWORD PTR _eCPNameNCTR$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv81[ebp], eax
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv305[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR tv305[ebp]
	push	edx
	lea	eax, DWORD PTR _nameNCTR$7[ebp]
	push	eax
	call	?RemoveInvalidChars@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; RemoveInvalidChars
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 3360 : 				// RV - Biker
; 3361 : 				//sprintf(strCPFile, "%s%s\\%s", FalconCockpitThrDirectory, nameNCTR.c_str(), vcockfile);
; 3362 : 				sprintf(strCPFile, "%s\\%s\\%s", FalconCockpitThrDirectory, nameNCTR.c_str(), vcockfile);

	mov	ecx, DWORD PTR ?vcockfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	ecx
	lea	ecx, DWORD PTR _nameNCTR$7[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@
	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3363 : 				
; 3364 : 				// RV - Biker - No more res manager
; 3365 : 				//if(ResExistFile(strCPFile))
; 3366 : 				if(FileExists(strCPFile))

	lea	eax, DWORD PTR _strCPFile$[ebp]
	push	eax
	call	?FileExists@@YAHPAD@Z			; FileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@Button3D_I

; 3367 : 					// RV - Biker
; 3368 : 					//sprintf(strCPFile, "%s%s\\%s", FalconCockpitThrDirectory, nameNCTR.c_str(), buttonfile);
; 3369 : 					sprintf(strCPFile, "%s\\%s\\%s", FalconCockpitThrDirectory, nameNCTR.c_str(), buttonfile);

	mov	ecx, DWORD PTR ?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	ecx
	lea	ecx, DWORD PTR _nameNCTR$7[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	push	OFFSET ?FalconCockpitThrDirectory@@3PADA ; FalconCockpitThrDirectory
	push	OFFSET ??_C@_08EFGGCJLD@?$CFs?2?$CFs?2?$CFs?$AA@
	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3370 : 				else

	jmp	SHORT $LN8@Button3D_I
$LN9@Button3D_I:

; 3371 : 				{
; 3372 : 					// F16C fallback
; 3373 : 					// RV - Biker - Here read from default cockpit dir
; 3374 : 					//sprintf(strCPFile, "%s%s", FalconCockpitThrDirectory, buttonfile);
; 3375 : 					sprintf(strCPFile, "%s\\%s", COCKPIT_DIR, buttonfile);

	mov	eax, DWORD PTR ?buttonfile@?1??Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z@4PBDB
	push	eax
	push	OFFSET ??_C@_0N@LCGKJIDE@art?2ckptart?2?$AA@
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
	lea	ecx, DWORD PTR _strCPFile$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN8@Button3D_I:

; 3376 : 				}
; 3377 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _nameNCTR$7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@Button3D_I:

; 3378 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@Button3D_I:

; 3379 : 	}
; 3380 : 
; 3381 :     Button3DDataFile = fopen(strCPFile, "r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	edx, DWORD PTR _strCPFile$[ebp]
	push	edx
	call	_ResFOpen
	add	esp, 8
	mov	DWORD PTR _Button3DDataFile$[ebp], eax

; 3382 :   
; 3383 : 
; 3384 : 	Button3DList.numbuttons=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32000], 0

; 3385 : 	Button3DList.debugbutton=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32004], 0

; 3386 : 	Button3DList.clicked=0;  //Wombat778 10-15-2003 removed clickx and clicky

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32008], 0

; 3387 : 
; 3388 : 	if (Button3DDataFile) {

	cmp	DWORD PTR _Button3DDataFile$[ebp], 0
	je	$LN7@Button3D_I

; 3389 : 		if (!feof(Button3DDataFile)) 

	mov	eax, DWORD PTR _Button3DDataFile$[ebp]
	push	eax
	call	_feof
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Button3D_I

; 3390 : 			fgets(templine, 256, Button3DDataFile);				//Just read a dummy line for comments etc..

	mov	ecx, DWORD PTR _Button3DDataFile$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _templine$[ebp]
	push	edx
	call	_fgets
	add	esp, 12					; 0000000cH
$LN5@Button3D_I:

; 3391 : 
; 3392 : 		while (!feof(Button3DDataFile)) {

	mov	eax, DWORD PTR _Button3DDataFile$[ebp]
	push	eax
	call	_feof
	add	esp, 4
	test	eax, eax
	jne	$LN4@Button3D_I

; 3393 : 			fgets(templine, 256, Button3DDataFile);

	mov	ecx, DWORD PTR _Button3DDataFile$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _templine$[ebp]
	push	edx
	call	_fgets
	add	esp, 12					; 0000000cH

; 3394 : 			int matchedfields = sscanf(templine, "%s %f %f %f %f %d %d", tempfunction,				//Wombat778 11-08-2003
; 3395 : 										   &Button3DList.buttons[Button3DList.numbuttons].loc.x,
; 3396 : 										   &Button3DList.buttons[Button3DList.numbuttons].loc.y,
; 3397 : 										   &Button3DList.buttons[Button3DList.numbuttons].loc.z,
; 3398 : 										   &Button3DList.buttons[Button3DList.numbuttons].dist,
; 3399 : 										   &Button3DList.buttons[Button3DList.numbuttons].sound,
; 3400 : 										   &Button3DList.buttons[Button3DList.numbuttons].mousebutton);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32000]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32000]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32000]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32000]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32000]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32000]
	shl	eax, 5
	add	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempfunction$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@CGIJNBCN@?$CFs?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd?$AA@
	lea	edx, DWORD PTR _templine$[ebp]
	push	edx
	call	_sscanf
	add	esp, 36					; 00000024H
	mov	DWORD PTR _matchedfields$2[ebp], eax

; 3401 : 
; 3402 : 
; 3403 : 			if (matchedfields == 6) 

	cmp	DWORD PTR _matchedfields$2[ebp], 6
	jne	SHORT $LN3@Button3D_I

; 3404 : 				Button3DList.buttons[Button3DList.numbuttons].mousebutton=1;			//Wombat778 11-08-2003 Added so there will still be compatibility with old files. Default to left mouse button.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32000]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+24], 1
$LN3@Button3D_I:

; 3405 : 
; 3406 : 			if (matchedfields >= 6)		//Wombat778 11-08-2003 changed to allow compatibility with old files 11-7-2003 added mousebutton field to allow LMB/RMB usage.

	cmp	DWORD PTR _matchedfields$2[ebp], 6
	jl	$LN2@Button3D_I

; 3407 : 			{			
; 3408 : 				InputFunctionType tempfunc;
; 3409 : 				tempfunc = FindFunctionFromString (tempfunction);

	lea	eax, DWORD PTR _tempfunction$[ebp]
	push	eax
	call	?FindFunctionFromString@@YAP6AXKHPAX@ZPAD@Z ; FindFunctionFromString
	add	esp, 4
	mov	DWORD PTR _tempfunc$3[ebp], eax

; 3410 : 				//Wombat778 03-06-04 Find and store the buttonid of the function, which should stop a ctd in not-realistic avionics.				
; 3411 : 				Button3DList.buttons[Button3DList.numbuttons].function = tempfunc;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32000]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tempfunc$3[ebp]
	mov	DWORD PTR [eax+edx+16], ecx

; 3412 : 				if (tempfunc) 

	cmp	DWORD PTR _tempfunc$3[ebp], 0
	je	SHORT $LN1@Button3D_I

; 3413 : 					Button3DList.buttons[Button3DList.numbuttons].buttonId=UserFunctionTable.GetButtonId(tempfunc);		//GetButtonId is a terribly slow function because it has to traverse a hash table.

	mov	edx, DWORD PTR _tempfunc$3[ebp]
	push	edx
	mov	ecx, OFFSET ?UserFunctionTable@@3VInputFunctionHashTable@@A ; UserFunctionTable
	call	?GetButtonId@InputFunctionHashTable@@QAEHP6AXKHPAX@Z@Z ; InputFunctionHashTable::GetButtonId
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32000]
	shl	edx, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+28], eax
$LN1@Button3D_I:

; 3414 : 
; 3415 : 				Button3DList.numbuttons++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32000]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32000], eax
$LN2@Button3D_I:

; 3416 : 			}
; 3417 : 		}

	jmp	$LN5@Button3D_I
$LN4@Button3D_I:

; 3418 : 		fclose(Button3DDataFile);

	mov	edx, DWORD PTR _Button3DDataFile$[ebp]
	push	edx
	call	_ResFClose
	add	esp, 4

; 3419 : 		return true;

	mov	al, 1
	jmp	SHORT $LN16@Button3D_I
$LN7@Button3D_I:

; 3420 : 	}
; 3421 : 	return false;

	xor	al, al
$LN16@Button3D_I:

; 3422 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$0:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$1:
	lea	ecx, DWORD PTR _name$6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z$3:
	lea	ecx, DWORD PTR _nameNCTR$7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-908]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Button3D_Init@OTWDriverClass@@QAE_NHPAD0@Z ENDP	; OTWDriverClass::Button3D_Init
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_changeval$ = -8					; size = 4
_value$ = -4						; size = 4
_oldval$ = 8						; size = 4
_newval$ = 12						; size = 4
_rate$ = 16						; size = 4
?MoveByRate@OTWDriverClass@@AAEMMMM@Z PROC		; OTWDriverClass::MoveByRate
; _this$ = ecx

; 1217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1218 : 	float changeval;
; 1219 : 	float value = oldval;

	movss	xmm0, DWORD PTR _oldval$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 1220 : 	if (value == newval || !gameCompressionRatio) return value; // all done

	movss	xmm0, DWORD PTR _value$[ebp]
	ucomiss	xmm0, DWORD PTR _newval$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@MoveByRate
	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 0	; gameCompressionRatio
	jne	SHORT $LN7@MoveByRate
$LN6@MoveByRate:
	fld	DWORD PTR _value$[ebp]
	jmp	SHORT $LN8@MoveByRate
$LN7@MoveByRate:

; 1221 : 	
; 1222 : 	changeval = rate * DTR * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _rate$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _changeval$[ebp], xmm0

; 1223 : 	
; 1224 : 	if (value > newval)

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR _newval$[ebp]
	jbe	SHORT $LN5@MoveByRate

; 1225 : 	{
; 1226 : 		value -= changeval;

	movss	xmm0, DWORD PTR _value$[ebp]
	subss	xmm0, DWORD PTR _changeval$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 1227 : 		if (value <= newval) {

	movss	xmm0, DWORD PTR _newval$[ebp]
	comiss	xmm0, DWORD PTR _value$[ebp]
	jb	SHORT $LN4@MoveByRate

; 1228 : 			value = newval;

	movss	xmm0, DWORD PTR _newval$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0
$LN4@MoveByRate:

; 1229 : 		}
; 1230 : 	}

	jmp	SHORT $LN1@MoveByRate
$LN5@MoveByRate:

; 1231 : 	else if (value < newval)

	movss	xmm0, DWORD PTR _newval$[ebp]
	comiss	xmm0, DWORD PTR _value$[ebp]
	jbe	SHORT $LN1@MoveByRate

; 1232 : 	{
; 1233 : 		value += changeval;

	movss	xmm0, DWORD PTR _value$[ebp]
	addss	xmm0, DWORD PTR _changeval$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 1234 : 		if (value >= newval) {

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR _newval$[ebp]
	jb	SHORT $LN1@MoveByRate

; 1235 : 			value = newval;

	movss	xmm0, DWORD PTR _newval$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0
$LN1@MoveByRate:

; 1236 : 		}
; 1237 : 	}
; 1238 : 	return value;

	fld	DWORD PTR _value$[ebp]
$LN8@MoveByRate:

; 1239 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MoveByRate@OTWDriverClass@@AAEMMMM@Z ENDP		; OTWDriverClass::MoveByRate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_ptoken$2 = -104					; size = 4
_this$ = -100						; size = 4
$T3 = -96						; size = 4
_cAlpha$ = -92						; size = 4
tv225 = -88						; size = 4
$T4 = -84						; size = 4
tv128 = -80						; size = 4
_canvas$ = -76						; size = 4
_tTop$ = -72						; size = 4
_tBottom$ = -68						; size = 4
_tRight$ = -64						; size = 4
_tLeft$ = -60						; size = 4
_cBlend$ = -53						; size = 1
_ur$ = -52						; size = 12
_ll$ = -40						; size = 12
_ul$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_plinePtr$ = 8						; size = 4
_canvaspp$ = 12						; size = 4
_dev$ = 16						; size = 4
?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z PROC ; OTWDriverClass::VCock_SetRttCanvas
; _this$ = ecx

; 590  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 	Tpoint ul, ur, ll;
; 592  : 	int tLeft, tTop, tRight, tBottom;
; 593  : 	char cBlend = 'c';

	mov	BYTE PTR _cBlend$[ebp], 99		; 00000063H

; 594  : 	float cAlpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cAlpha$[ebp], xmm0

; 595  : //	extern int txRes, tyRes, tBpp;
; 596  : 	extern bool bRTTTarget;
; 597  : 
; 598  : 	// Missing rttTarget line in 3dckpit.dat?
; 599  : 	if (!bRTTTarget)

	movzx	eax, BYTE PTR ?bRTTTarget@@3_NA		; bRTTTarget
	test	eax, eax
	jne	SHORT $LN18@VCock_SetR

; 600  : 	{
; 601  : 		// Cobra - Lower screen resolutions need a smaller canvas (font is too small)
; 602  : 		if(FindBestResolution() < 1280)

	call	?FindBestResolution@@YAHXZ		; FindBestResolution
	cmp	eax, 1280				; 00000500H
	jge	SHORT $LN17@VCock_SetR

; 603  : 		{
; 604  : 			resScale = 512.0f/(float)txRes;

	cvtsi2ss xmm0, DWORD PTR ?txRes@@3HA		; txRes
	movss	xmm1, DWORD PTR __real@44000000
	divss	xmm1, xmm0
	movss	DWORD PTR ?resScale@@3MA, xmm1

; 605  : 			txRes = 512;

	mov	DWORD PTR ?txRes@@3HA, 512		; txRes, 00000200H

; 606  : 			tyRes = 512;

	mov	DWORD PTR ?tyRes@@3HA, 512		; tyRes, 00000200H
$LN17@VCock_SetR:

; 607  : 		}
; 608  : 		VirtualDisplay::SetupRttTarget( txRes, tyRes, tBpp );

	mov	ecx, DWORD PTR ?tBpp@@3HA		; tBpp
	push	ecx
	mov	edx, DWORD PTR ?tyRes@@3HA		; tyRes
	push	edx
	mov	eax, DWORD PTR ?txRes@@3HA		; txRes
	push	eax
	call	?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z ; VirtualDisplay::SetupRttTarget
	add	esp, 12					; 0000000cH
$LN18@VCock_SetR:

; 609  : 	}
; 610  : 
; 611  : 	// Canvas3D *canvas;
; 612  : 	Render2D* canvas;
; 613  : 	// no PFL data
; 614  : 	if (dev == 6)

	cmp	DWORD PTR _dev$[ebp], 6
	jne	$LN16@VCock_SetR

; 615  : 	{
; 616  : 		ul.x = vPFLul.x;

	movss	xmm0, DWORD PTR ?vPFLul@@3UTpoint@@A
	movss	DWORD PTR _ul$[ebp], xmm0

; 617  : 		ul.y = vPFLul.y;

	movss	xmm0, DWORD PTR ?vPFLul@@3UTpoint@@A+4
	movss	DWORD PTR _ul$[ebp+4], xmm0

; 618  : 		ul.z = vPFLul.z;

	movss	xmm0, DWORD PTR ?vPFLul@@3UTpoint@@A+8
	movss	DWORD PTR _ul$[ebp+8], xmm0

; 619  : 		ur.x = vPFLur.x;

	movss	xmm0, DWORD PTR ?vPFLur@@3UTpoint@@A
	movss	DWORD PTR _ur$[ebp], xmm0

; 620  : 		ur.y = vPFLur.y;

	movss	xmm0, DWORD PTR ?vPFLur@@3UTpoint@@A+4
	movss	DWORD PTR _ur$[ebp+4], xmm0

; 621  : 		ur.z = vPFLur.z;

	movss	xmm0, DWORD PTR ?vPFLur@@3UTpoint@@A+8
	movss	DWORD PTR _ur$[ebp+8], xmm0

; 622  : 		ll.x = vPFLll.x;

	movss	xmm0, DWORD PTR ?vPFLll@@3UTpoint@@A
	movss	DWORD PTR _ll$[ebp], xmm0

; 623  : 		ll.y = vPFLll.y;

	movss	xmm0, DWORD PTR ?vPFLll@@3UTpoint@@A+4
	movss	DWORD PTR _ll$[ebp+4], xmm0

; 624  : 		ll.z = vPFLll.z;

	movss	xmm0, DWORD PTR ?vPFLll@@3UTpoint@@A+8
	movss	DWORD PTR _ll$[ebp+8], xmm0

; 625  : 		tLeft = tPFLleft;

	mov	ecx, DWORD PTR ?tPFLleft@@3HA		; tPFLleft
	mov	DWORD PTR _tLeft$[ebp], ecx

; 626  : 		tTop = tPFLtop; 

	mov	edx, DWORD PTR ?tPFLtop@@3HA		; tPFLtop
	mov	DWORD PTR _tTop$[ebp], edx

; 627  : 		tRight = tPFLright; 

	mov	eax, DWORD PTR ?tPFLright@@3HA		; tPFLright
	mov	DWORD PTR _tRight$[ebp], eax

; 628  : 		tBottom = tPFLbottom;

	mov	ecx, DWORD PTR ?tPFLbottom@@3HA		; tPFLbottom
	mov	DWORD PTR _tBottom$[ebp], ecx

; 629  : 		hasPFL = false;

	mov	BYTE PTR ?hasPFL@@3_NA, 0		; hasPFL

; 630  : 	}
; 631  : 	else

	jmp	$LN6@VCock_SetR
$LN16@VCock_SetR:

; 632  : 	{
; 633  : 		char *ptoken = FindToken(plinePtr, "=;\n");	

	push	OFFSET ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
	mov	edx, DWORD PTR _plinePtr$[ebp]
	push	edx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$2[ebp], eax

; 634  : 		if (sscanf(ptoken, "%f %f %f %f %f %f %f %f %f %d %d %d %d %c %f", 
; 635  : 			&ul.x, &ul.y, &ul.z,
; 636  : 			&ur.x, &ur.y, &ur.z,
; 637  : 			&ll.x, &ll.y, &ll.z,
; 638  : 			&tLeft, &tTop, &tRight, &tBottom, 
; 639  : 			&cBlend, &cAlpha ) == 9) 

	lea	eax, DWORD PTR _cAlpha$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cBlend$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tBottom$[ebp]
	push	edx
	lea	eax, DWORD PTR _tRight$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tTop$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tLeft$[ebp]
	push	edx
	lea	eax, DWORD PTR _ll$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _ll$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _ll$[ebp]
	push	edx
	lea	eax, DWORD PTR _ur$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _ur$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _ur$[ebp]
	push	edx
	lea	eax, DWORD PTR _ul$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _ul$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _ul$[ebp]
	push	edx
	push	OFFSET ??_C@_0CN@HGJLILKD@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd@
	mov	eax, DWORD PTR _ptoken$2[ebp]
	push	eax
	call	_sscanf
	add	esp, 68					; 00000044H
	cmp	eax, 9
	jne	$LN14@VCock_SetR

; 640  : 		{ // no RTT canvas data. Use default.
; 641  : 			switch (dev)

	mov	ecx, DWORD PTR _dev$[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	mov	edx, DWORD PTR tv128[ebp]
	sub	edx, 1
	mov	DWORD PTR tv128[ebp], edx
	cmp	DWORD PTR tv128[ebp], 3
	ja	$LN12@VCock_SetR
	mov	eax, DWORD PTR tv128[ebp]
	jmp	DWORD PTR $LN25@VCock_SetR[eax*4]
$LN11@VCock_SetR:

; 642  : 			{
; 643  : 				case 1: // hud
; 644  : 					tLeft = tHUDleft;

	mov	ecx, DWORD PTR ?tHUDleft@@3HA		; tHUDleft
	mov	DWORD PTR _tLeft$[ebp], ecx

; 645  : 					tTop = tHUDtop; 

	mov	edx, DWORD PTR ?tHUDtop@@3HA		; tHUDtop
	mov	DWORD PTR _tTop$[ebp], edx

; 646  : 					tRight = tHUDright; 

	mov	eax, DWORD PTR ?tHUDright@@3HA		; tHUDright
	mov	DWORD PTR _tRight$[ebp], eax

; 647  : 					tBottom = tHUDbottom;

	mov	ecx, DWORD PTR ?tHUDbottom@@3HA		; tHUDbottom
	mov	DWORD PTR _tBottom$[ebp], ecx

; 648  : 				break;

	jmp	SHORT $LN12@VCock_SetR
$LN10@VCock_SetR:

; 649  : 				case 2: // rwr
; 650  : 					tLeft = tRWRleft;

	mov	edx, DWORD PTR ?tRWRleft@@3HA		; tRWRleft
	mov	DWORD PTR _tLeft$[ebp], edx

; 651  : 					tTop = tRWRtop; 

	mov	eax, DWORD PTR ?tRWRtop@@3HA		; tRWRtop
	mov	DWORD PTR _tTop$[ebp], eax

; 652  : 					tRight = tRWRright; 

	mov	ecx, DWORD PTR ?tRWRright@@3HA		; tRWRright
	mov	DWORD PTR _tRight$[ebp], ecx

; 653  : 					tBottom = tRWRbottom;

	mov	edx, DWORD PTR ?tRWRbottom@@3HA		; tRWRbottom
	mov	DWORD PTR _tBottom$[ebp], edx

; 654  : 				break;

	jmp	SHORT $LN12@VCock_SetR
$LN9@VCock_SetR:

; 655  : 				case 3: // ded
; 656  : 					tLeft = tDEDleft;

	mov	eax, DWORD PTR ?tDEDleft@@3HA		; tDEDleft
	mov	DWORD PTR _tLeft$[ebp], eax

; 657  : 					tTop = tDEDtop; 

	mov	ecx, DWORD PTR ?tDEDtop@@3HA		; tDEDtop
	mov	DWORD PTR _tTop$[ebp], ecx

; 658  : 					tRight = tDEDright; 

	mov	edx, DWORD PTR ?tDEDright@@3HA		; tDEDright
	mov	DWORD PTR _tRight$[ebp], edx

; 659  : 					tBottom = tDEDbottom;

	mov	eax, DWORD PTR ?tDEDbottom@@3HA		; tDEDbottom
	mov	DWORD PTR _tBottom$[ebp], eax

; 660  : 				break;

	jmp	SHORT $LN12@VCock_SetR
$LN8@VCock_SetR:

; 661  : 				case 4: // pfl
; 662  : 					tLeft = tPFLleft;

	mov	ecx, DWORD PTR ?tPFLleft@@3HA		; tPFLleft
	mov	DWORD PTR _tLeft$[ebp], ecx

; 663  : 					tTop = tPFLtop; 

	mov	edx, DWORD PTR ?tPFLtop@@3HA		; tPFLtop
	mov	DWORD PTR _tTop$[ebp], edx

; 664  : 					tRight = tPFLright; 

	mov	eax, DWORD PTR ?tPFLright@@3HA		; tPFLright
	mov	DWORD PTR _tRight$[ebp], eax

; 665  : 					tBottom = tPFLbottom;

	mov	ecx, DWORD PTR ?tPFLbottom@@3HA		; tPFLbottom
	mov	DWORD PTR _tBottom$[ebp], ecx

; 666  : 					hasPFL = false;

	mov	BYTE PTR ?hasPFL@@3_NA, 0		; hasPFL
$LN12@VCock_SetR:

; 667  : 				break;
; 668  : 			}
; 669  : 		}
; 670  : 		else

	jmp	SHORT $LN6@VCock_SetR
$LN14@VCock_SetR:

; 671  : 		{
; 672  : 			if (dev == 4)

	cmp	DWORD PTR _dev$[ebp], 4
	jne	SHORT $LN6@VCock_SetR

; 673  : 				hasPFL = true;

	mov	BYTE PTR ?hasPFL@@3_NA, 1		; hasPFL
$LN6@VCock_SetR:

; 674  : 		}
; 675  : 	}
; 676  : 
; 677  : 	// Cobra - Lower screen resolutions need a smaller canvas (font is too small)
; 678  : 	if(FindBestResolution() < 1280)

	call	?FindBestResolution@@YAHXZ		; FindBestResolution
	cmp	eax, 1280				; 00000500H
	jge	SHORT $LN1@VCock_SetR

; 679  : 	{
; 680  : 		if (tLeft > 1)

	cmp	DWORD PTR _tLeft$[ebp], 1
	jle	SHORT $LN4@VCock_SetR

; 681  : 			tLeft = (int)(resScale * (float)tLeft);

	cvtsi2ss xmm0, DWORD PTR _tLeft$[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si edx, xmm0
	mov	DWORD PTR _tLeft$[ebp], edx
$LN4@VCock_SetR:

; 682  : 		if (tRight > 1)

	cmp	DWORD PTR _tRight$[ebp], 1
	jle	SHORT $LN3@VCock_SetR

; 683  : 			tRight = (int)(resScale * (float)tRight);

	cvtsi2ss xmm0, DWORD PTR _tRight$[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si eax, xmm0
	mov	DWORD PTR _tRight$[ebp], eax
$LN3@VCock_SetR:

; 684  : 		if (tTop > 1)

	cmp	DWORD PTR _tTop$[ebp], 1
	jle	SHORT $LN2@VCock_SetR

; 685  : 			tTop = (int)(resScale * (float)tTop);

	cvtsi2ss xmm0, DWORD PTR _tTop$[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si ecx, xmm0
	mov	DWORD PTR _tTop$[ebp], ecx
$LN2@VCock_SetR:

; 686  : 		if (tBottom > 1)

	cmp	DWORD PTR _tBottom$[ebp], 1
	jle	SHORT $LN1@VCock_SetR

; 687  : 			tBottom = (int)(resScale * (float)tBottom);

	cvtsi2ss xmm0, DWORD PTR _tBottom$[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si edx, xmm0
	mov	DWORD PTR _tBottom$[ebp], edx
$LN1@VCock_SetR:

; 688  : 	}
; 689  : 	*canvaspp = canvas = new Render2D;

	push	262840					; 000402b8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN21@VCock_SetR
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0Render2D@@QAE@XZ			; Render2D::Render2D
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN22@VCock_SetR
$LN21@VCock_SetR:
	mov	DWORD PTR tv225[ebp], 0
$LN22@VCock_SetR:
	mov	eax, DWORD PTR tv225[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _canvas$[ebp], ecx
	mov	edx, DWORD PTR _canvaspp$[ebp]
	mov	eax, DWORD PTR _canvas$[ebp]
	mov	DWORD PTR [edx], eax

; 690  : 	canvas->Setup( renderer->GetImageBuffer() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ ; Render2D::GetImageBuffer
	push	eax
	mov	edx, DWORD PTR _canvas$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _canvas$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx

; 691  : 	canvas->SetRttCanvas( &ul, &ur, &ll, cBlend, cAlpha );

	push	ecx
	movss	xmm0, DWORD PTR _cAlpha$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, BYTE PTR _cBlend$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ll$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ur$[ebp]
	push	edx
	lea	eax, DWORD PTR _ul$[ebp]
	push	eax
	mov	ecx, DWORD PTR _canvas$[ebp]
	call	?SetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@00DM@Z ; VirtualDisplay::SetRttCanvas

; 692  : 	canvas->SetRttRect( tLeft, tTop, tRight, tBottom );

	push	1
	mov	ecx, DWORD PTR _tBottom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tRight$[ebp]
	push	edx
	mov	eax, DWORD PTR _tTop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tLeft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _canvas$[ebp]
	call	?SetRttRect@VirtualDisplay@@QAEXHHHH_N@Z ; VirtualDisplay::SetRttRect

; 693  : 	return true;

	mov	al, 1

; 694  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN25@VCock_SetR:
	DD	$LN11@VCock_SetR
	DD	$LN10@VCock_SetR
	DD	$LN9@VCock_SetR
	DD	$LN8@VCock_SetR
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ENDP ; OTWDriverClass::VCock_SetRttCanvas
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_ptoken$ = -76						; size = 4
_this$ = -72						; size = 4
$T2 = -68						; size = 4
$T3 = -64						; size = 4
tv87 = -60						; size = 4
_canvas$ = -56						; size = 4
_ur$ = -52						; size = 12
_ll$ = -40						; size = 12
_ul$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_plinePtr$ = 8						; size = 4
_canvaspp$ = 12						; size = 4
?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z PROC ; OTWDriverClass::VCock_SetCanvas
; _this$ = ecx

; 699  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 700  :     Tpoint ul, ur, ll;
; 701  :     Canvas3D *canvas;
; 702  :     char *ptoken = FindToken(plinePtr, "=;\n");	

	push	OFFSET ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
	mov	eax, DWORD PTR _plinePtr$[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 703  :     if (sscanf(ptoken, "%f %f %f %f %f %f %f %f %f", 
; 704  : 	&ul.x, &ul.y, &ul.z,
; 705  : 	&ur.x, &ur.y, &ur.z,
; 706  : 	&ll.x, &ll.y, &ll.z) != 9) {

	lea	ecx, DWORD PTR _ll$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ll$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ll$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ur$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ur$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ur$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ul$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ul$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ul$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@PNBJJOIP@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@
	mov	ecx, DWORD PTR _ptoken$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 44					; 0000002cH
	cmp	eax, 9
	je	SHORT $LN1@VCock_SetC

; 707  : 	ShiAssert(!"Failed to parse canvas");
; 708  : 	*canvaspp = NULL;

	mov	edx, DWORD PTR _canvaspp$[ebp]
	mov	DWORD PTR [edx], 0

; 709  : 	return false;

	xor	al, al
	jmp	$LN2@VCock_SetC
$LN1@VCock_SetC:

; 710  :     }
; 711  :     *canvaspp = canvas = new Canvas3D;

	push	262916					; 00040304H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@VCock_SetC
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Canvas3D@@QAE@XZ			; Canvas3D::Canvas3D
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN5@VCock_SetC
$LN4@VCock_SetC:
	mov	DWORD PTR tv87[ebp], 0
$LN5@VCock_SetC:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _canvas$[ebp], ecx
	mov	edx, DWORD PTR _canvaspp$[ebp]
	mov	eax, DWORD PTR _canvas$[ebp]
	mov	DWORD PTR [edx], eax

; 712  :     canvas->Setup(renderer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	push	edx
	mov	eax, DWORD PTR _canvas$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _canvas$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 713  :     canvas->SetCanvas(&ul, &ur, &ll);

	lea	ecx, DWORD PTR _ll$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ur$[ebp]
	push	edx
	lea	eax, DWORD PTR _ul$[ebp]
	push	eax
	mov	ecx, DWORD PTR _canvas$[ebp]
	call	?SetCanvas@Canvas3D@@QAEXPAUTpoint@@00@Z ; Canvas3D::SetCanvas

; 714  :     canvas->Update( &Origin, (struct Trotation *)&IMatrix );

	push	OFFSET ?IMatrix@@3UTrotation@@B		; IMatrix
	push	OFFSET ?Origin@@3UTpoint@@B		; Origin
	mov	ecx, DWORD PTR _canvas$[ebp]
	call	?Update@Canvas3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Canvas3D::Update

; 715  :     
; 716  :     return true;

	mov	al, 1
$LN2@VCock_SetC:

; 717  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z ENDP ; OTWDriverClass::VCock_SetCanvas
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_presult$1 = -924					; size = 4
tv82 = -920						; size = 4
_cAlpha$2 = -916					; size = 4
_pcockpitDataFile$ = -912				; size = 4
_cAlpha$3 = -908					; size = 4
_bset$4 = -904						; size = 4
_DebugLineNum$ = -900					; size = 4
_tTop$5 = -896						; size = 4
_tBottom$6 = -892					; size = 4
_tBottom$7 = -888					; size = 4
_tLeft$8 = -884						; size = 4
_tRight$9 = -880					; size = 4
_tRight$10 = -876					; size = 4
_tTop$11 = -872						; size = 4
_tLeft$12 = -868					; size = 4
_cBlend$13 = -863					; size = 1
_cBlend$14 = -862					; size = 1
_quitFlag$ = -861					; size = 1
_plinePtr$15 = -860					; size = 4
_this$ = -856						; size = 4
_ptoken$16 = -852					; size = 4
_ul$17 = -848						; size = 12
_ll$18 = -836						; size = 12
_ll$19 = -824						; size = 12
_ur$20 = -812						; size = 12
_ur$21 = -800						; size = 12
_ul$22 = -788						; size = 12
_strCPFile$ = -776					; size = 260
_plineBuffer$23 = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_eCPVisType$ = 8					; size = 4
_eCPName$ = 12						; size = 4
_eCPNameNCTR$ = 16					; size = 4
?VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z PROC		; OTWDriverClass::VCock_Init
; _this$ = ecx

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 924				; 0000039cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 806  :     char strCPFile[MAX_PATH];
; 807  :     static const TCHAR *pCPFile = "3dckpit.dat";
; 808  :     CP_HANDLE*			pcockpitDataFile;
; 809  :     static const char		pseparators[] = {0x20, 0x2c, 0x3d, 0x3b, 0x0d, 0x0a, 0x09, 0x00};
; 810  :     extern Tpoint lMFDul, lMFDur, lMFDll;
; 811  : 		extern int ltMFDleft, ltMFDtop, ltMFDright, ltMFDbottom;	// ASSO:
; 812  : 		extern char lcMFDblend;
; 813  : 		extern float lcMFDalpha;
; 814  : 		extern Tpoint rMFDul, rMFDur, rMFDll;
; 815  : 		extern int rtMFDleft, rtMFDtop, rtMFDright, rtMFDbottom; //, txRes, tyRes, tBpp;	// ASSO:
; 816  : 		extern char rcMFDblend;
; 817  : 		extern float rcMFDalpha;
; 818  : 		extern bool bRTTTarget;
; 819  : 		int DebugLineNum;
; 820  : 		bool quitFlag = false;

	mov	BYTE PTR _quitFlag$[ebp], 0

; 821  : 		g_bUseNew3dpit = false; //Use new 3dpit code - needs new 3d pit model - assume not

	mov	BYTE PTR ?g_bUseNew3dpit@@3_NA, 0	; g_bUseNew3dpit

; 822  : 		bRTTTarget = false; // RTT needs RTT dimensions in 3dckpit.dat

	mov	BYTE PTR ?bRTTTarget@@3_NA, 0		; bRTTTarget

; 823  : 
; 824  : 		// RV - RED - Init to default value
; 825  : 		vBoresightY = 0.75f;	

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [eax+33956], xmm0

; 826  : 
; 827  : 	// COBRA - RED - Default Hud Color if not assigned by DAT FILE
; 828  : //	TheHud->SetHudColor(DEFAULT_HUD_COLOR);
; 829  : 
; 830  : 	// RV - Biker - Use fallback for cockpit path
; 831  : 	//FindCockpit(pCPFile, (Vis_Types)eCPVisType, eCPName, eCPNameNCTR, strCPFile);
; 832  :     FindCockpit(pCPFile, (Vis_Types)eCPVisType, eCPName, eCPNameNCTR, strCPFile, TRUE);

	push	1
	lea	ecx, DWORD PTR _strCPFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eCPNameNCTR$[ebp]
	push	edx
	mov	eax, DWORD PTR _eCPName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eCPVisType$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?pCPFile@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4PBDB
	push	edx
	call	?FindCockpit@@YAHPBDW4Vis_Types@@00PADH@Z ; FindCockpit
	add	esp, 24					; 00000018H

; 833  : 
; 834  :     pcockpitDataFile = CP_OPEN(strCPFile, "r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	lea	eax, DWORD PTR _strCPFile$[ebp]
	push	eax
	call	_ResFOpen
	add	esp, 8
	mov	DWORD PTR _pcockpitDataFile$[ebp], eax

; 835  :   
; 836  :     F4Assert(pcockpitDataFile);			//Error: Couldn't open file
; 837  :     DebugLineNum = 0;

	mov	DWORD PTR _DebugLineNum$[ebp], 0
$LN88@VCock_Init:

; 838  : 
; 839  :     while(!quitFlag) {

	movzx	ecx, BYTE PTR _quitFlag$[ebp]
	test	ecx, ecx
	jne	$LN82@VCock_Init

; 840  : 	char			plineBuffer[MAX_LINE_BUFFER];
; 841  : 	char *plinePtr, *ptoken;
; 842  : 	char *presult	= fgets(plineBuffer, sizeof plineBuffer, pcockpitDataFile);

	mov	edx, DWORD PTR _pcockpitDataFile$[ebp]
	push	edx
	push	512					; 00000200H
	lea	eax, DWORD PTR _plineBuffer$23[ebp]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _presult$1[ebp], eax

; 843  : 	DebugLineNum ++;

	mov	ecx, DWORD PTR _DebugLineNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DebugLineNum$[ebp], ecx

; 844  : 	quitFlag	= (presult == NULL);

	cmp	DWORD PTR _presult$1[ebp], 0
	jne	SHORT $LN86@VCock_Init
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN87@VCock_Init
$LN86@VCock_Init:
	mov	DWORD PTR tv82[ebp], 0
$LN87@VCock_Init:
	mov	dl, BYTE PTR tv82[ebp]
	mov	BYTE PTR _quitFlag$[ebp], dl

; 845  : 	
; 846  : 	if (quitFlag || *plineBuffer == '/' || *plineBuffer == '\n')

	movzx	eax, BYTE PTR _quitFlag$[ebp]
	test	eax, eax
	jne	SHORT $LN80@VCock_Init
	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR _plineBuffer$23[ebp+ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN80@VCock_Init
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _plineBuffer$23[ebp+eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN81@VCock_Init
$LN80@VCock_Init:

; 847  : 	    continue;

	jmp	$LN88@VCock_Init
$LN81@VCock_Init:

; 848  : 	plinePtr = plineBuffer;

	lea	edx, DWORD PTR _plineBuffer$23[ebp]
	mov	DWORD PTR _plinePtr$15[ebp], edx

; 849  : 	ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	eax, DWORD PTR _plinePtr$15[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 850  : 
; 851  : 		// ASSO:
; 852  : 		if (!strcmpi(ptoken, PROP_3D_RTTTARGET)) {  // the rttTarget :

	push	OFFSET ??_C@_09JALPCOHE@rtttarget?$AA@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN79@VCock_Init

; 853  : 			ptoken = FindToken(&plinePtr, "=;\n");	

	push	OFFSET ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
	lea	edx, DWORD PTR _plinePtr$15[ebp]
	push	edx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 854  : 			if (sscanf(ptoken, "%d %d %d", 
; 855  : 				&txRes, &tyRes, &tBpp) >= 2) 

	push	OFFSET ?tBpp@@3HA			; tBpp
	push	OFFSET ?tyRes@@3HA			; tyRes
	push	OFFSET ?txRes@@3HA			; txRes
	push	OFFSET ??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jl	SHORT $LN78@VCock_Init

; 856  : 			{
; 857  : 				// Cobra - Lower screen resolutions need a smaller canvas (font is too small)
; 858  : 				if(FindBestResolution() < 1280)

	call	?FindBestResolution@@YAHXZ		; FindBestResolution
	cmp	eax, 1280				; 00000500H
	jge	SHORT $LN77@VCock_Init

; 859  : 				{
; 860  : 					resScale = 512.0f/(float)txRes;

	cvtsi2ss xmm0, DWORD PTR ?txRes@@3HA		; txRes
	movss	xmm1, DWORD PTR __real@44000000
	divss	xmm1, xmm0
	movss	DWORD PTR ?resScale@@3MA, xmm1

; 861  : 					txRes = 512;

	mov	DWORD PTR ?txRes@@3HA, 512		; txRes, 00000200H

; 862  : 					tyRes = 512;

	mov	DWORD PTR ?tyRes@@3HA, 512		; tyRes, 00000200H
$LN77@VCock_Init:

; 863  : 				}
; 864  : 				VirtualDisplay::SetupRttTarget( txRes, tyRes, tBpp );

	mov	ecx, DWORD PTR ?tBpp@@3HA		; tBpp
	push	ecx
	mov	edx, DWORD PTR ?tyRes@@3HA		; tyRes
	push	edx
	mov	eax, DWORD PTR ?txRes@@3HA		; txRes
	push	eax
	call	?SetupRttTarget@VirtualDisplay@@SA_NHHH@Z ; VirtualDisplay::SetupRttTarget
	add	esp, 12					; 0000000cH

; 865  : 				bRTTTarget = true;

	mov	BYTE PTR ?bRTTTarget@@3_NA, 1		; bRTTTarget
$LN78@VCock_Init:

; 866  : 			}
; 867  : 		}

	jmp	$LN6@VCock_Init
$LN79@VCock_Init:

; 868  : 		else if (!strcmpi(ptoken, PROP_HUD_STR)) { // the hud

	push	OFFSET ??_C@_03HDICPLBH@hud?$AA@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN75@VCock_Init

; 869  : 			if (!VCock_SetRttCanvas(&plinePtr, &vHUDrenderer, 1 )) { // ASSO:

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33980				; 000084bcH
	push	edx
	lea	eax, DWORD PTR _plinePtr$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ; OTWDriverClass::VCock_SetRttCanvas
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN74@VCock_Init

; 870  : 
; 871  : 				plinePtr = plinePtr; // Release mode compile warning

	mov	edx, DWORD PTR _plinePtr$15[ebp]
	mov	DWORD PTR _plinePtr$15[ebp], edx
$LN74@VCock_Init:

; 872  : 				F4Assert("Bad HUD description");
; 873  : 			}
; 874  : 		}

	jmp	$LN6@VCock_Init
$LN75@VCock_Init:

; 875  : 		else if (!strcmpi(ptoken, PROP_RWR_STR)) { //  the rwr

	push	OFFSET ??_C@_03FDDKCNFF@rwr?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN72@VCock_Init

; 876  : 			if (!VCock_SetRttCanvas(&plinePtr, &vRWRrenderer, 2)) { // ASSO:

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33984				; 000084c0H
	push	ecx
	lea	edx, DWORD PTR _plinePtr$15[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ; OTWDriverClass::VCock_SetRttCanvas
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN71@VCock_Init

; 877  : 				plinePtr = plinePtr; // Release mode compile warning

	mov	ecx, DWORD PTR _plinePtr$15[ebp]
	mov	DWORD PTR _plinePtr$15[ebp], ecx
$LN71@VCock_Init:

; 878  : 				F4Assert("Bad RWR description");
; 879  : 			}
; 880  : 		}

	jmp	$LN6@VCock_Init
$LN72@VCock_Init:

; 881  : 		else if (!strcmpi(ptoken, TYPE_DED_STR)) { //  the ded

	push	OFFSET ??_C@_03CIIJCKKD@DED?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN69@VCock_Init

; 882  : 			if (!VCock_SetRttCanvas(&plinePtr, &vDEDrenderer, 3)) { // ASSO:

	push	3
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33988				; 000084c4H
	push	eax
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ; OTWDriverClass::VCock_SetRttCanvas
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN68@VCock_Init

; 883  : 				plinePtr = plinePtr; // Release mode compile warning

	mov	eax, DWORD PTR _plinePtr$15[ebp]
	mov	DWORD PTR _plinePtr$15[ebp], eax
$LN68@VCock_Init:

; 884  : 				F4Assert("Bad DED description");
; 885  : 			}
; 886  : 		}

	jmp	$LN6@VCock_Init
$LN69@VCock_Init:

; 887  : 		else if (!strcmpi(ptoken, PROP_DED_PFL)) { //  the pfl

	push	OFFSET ??_C@_03DAJGBDEG@pfl?$AA@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@VCock_Init

; 888  : 			if (!VCock_SetRttCanvas(&plinePtr, &vPFLrenderer, 4)) { // ASSO:

	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33992				; 000084c8H
	push	edx
	lea	eax, DWORD PTR _plinePtr$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ; OTWDriverClass::VCock_SetRttCanvas
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN65@VCock_Init

; 889  : 				plinePtr = plinePtr; // Release mode compile warning

	mov	edx, DWORD PTR _plinePtr$15[ebp]
	mov	DWORD PTR _plinePtr$15[ebp], edx
$LN65@VCock_Init:

; 890  : 				F4Assert("Bad PFL description");
; 891  : 			}
; 892  : 		}

	jmp	$LN6@VCock_Init
$LN66@VCock_Init:

; 893  : 		else if (!strcmpi(ptoken, TYPE_MACHASI_STR)) { //  the rwr

	push	OFFSET ??_C@_07EHJPLJNA@MACHASI?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN63@VCock_Init

; 894  : 			if (!VCock_SetCanvas(&plinePtr, &vcInfo.vMACHrenderer)) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33968				; 000084b0H
	push	ecx
	lea	edx, DWORD PTR _plinePtr$15[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_SetCanvas@OTWDriverClass@@AAE_NPAPADPAPAVCanvas3D@@@Z ; OTWDriverClass::VCock_SetCanvas
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN62@VCock_Init

; 895  : 				plinePtr = plinePtr; // Release mode compile warning

	mov	ecx, DWORD PTR _plinePtr$15[ebp]
	mov	DWORD PTR _plinePtr$15[ebp], ecx
$LN62@VCock_Init:

; 896  : 				F4Assert("Bad MACH description");
; 897  : 			}
; 898  : 		}

	jmp	$LN6@VCock_Init
$LN63@VCock_Init:

; 899  : 		else if (!strcmpi(ptoken, PROP_MFDLEFT_STR)) {// left MFD

	push	OFFSET ??_C@_07PNADDHHC@mfdleft?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN60@VCock_Init

; 900  : 			Tpoint ul, ur, ll;
; 901  : 			int tLeft, tTop, tRight, tBottom;	// ASSO:
; 902  : 			char cBlend = 'c';

	mov	BYTE PTR _cBlend$13[ebp], 99		; 00000063H

; 903  : 			float cAlpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cAlpha$2[ebp], xmm0

; 904  : 			ptoken = FindToken(&plinePtr, "=;\n");		

	push	OFFSET ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
	lea	eax, DWORD PTR _plinePtr$15[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 905  : 			if (sscanf(ptoken, "%f %f %f %f %f %f %f %f %f %d %d %d %d %c %f",	
; 906  : 				&ul.x, &ul.y, &ul.z,
; 907  : 				&ur.x, &ur.y, &ur.z,
; 908  : 				&ll.x, &ll.y, &ll.z,
; 909  : 				&tLeft, &tTop, &tRight, &tBottom,
; 910  : 				&cBlend, &cAlpha ) == 9) 

	lea	ecx, DWORD PTR _cAlpha$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _cBlend$13[ebp]
	push	edx
	lea	eax, DWORD PTR _tBottom$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _tRight$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _tTop$5[ebp]
	push	edx
	lea	eax, DWORD PTR _tLeft$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _ll$19[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ll$19[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ll$19[ebp]
	push	eax
	lea	ecx, DWORD PTR _ur$21[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ur$21[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ur$21[ebp]
	push	eax
	lea	ecx, DWORD PTR _ul$22[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ul$22[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ul$22[ebp]
	push	eax
	push	OFFSET ??_C@_0CN@HGJLILKD@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_sscanf
	add	esp, 68					; 00000044H
	cmp	eax, 9
	jne	SHORT $LN59@VCock_Init

; 911  : 			{
; 912  : 				tLeft = tlMFDleft;

	mov	edx, DWORD PTR ?tlMFDleft@@3HA		; tlMFDleft
	mov	DWORD PTR _tLeft$8[ebp], edx

; 913  : 				tTop = tlMFDtop; 

	mov	eax, DWORD PTR ?tlMFDtop@@3HA		; tlMFDtop
	mov	DWORD PTR _tTop$5[ebp], eax

; 914  : 				tRight = tlMFDright; 

	mov	ecx, DWORD PTR ?tlMFDright@@3HA		; tlMFDright
	mov	DWORD PTR _tRight$10[ebp], ecx

; 915  : 				tBottom = tlMFDbottom;

	mov	edx, DWORD PTR ?tlMFDbottom@@3HA	; tlMFDbottom
	mov	DWORD PTR _tBottom$6[ebp], edx
$LN59@VCock_Init:

; 916  : 			}
; 917  : 			// Cobra - Lower screen resolutions need a smaller canvas (font is too small)
; 918  : 			if(FindBestResolution() < 1280)

	call	?FindBestResolution@@YAHXZ		; FindBestResolution
	cmp	eax, 1280				; 00000500H
	jge	$LN54@VCock_Init

; 919  : 			{
; 920  : 				if (tLeft > 1)

	cmp	DWORD PTR _tLeft$8[ebp], 1
	jle	SHORT $LN57@VCock_Init

; 921  : 					tLeft = (int)(resScale * (float)tLeft);

	cvtsi2ss xmm0, DWORD PTR _tLeft$8[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si eax, xmm0
	mov	DWORD PTR _tLeft$8[ebp], eax
$LN57@VCock_Init:

; 922  : 				if (tRight > 1)

	cmp	DWORD PTR _tRight$10[ebp], 1
	jle	SHORT $LN56@VCock_Init

; 923  : 					tRight = (int)(resScale * (float)tRight);

	cvtsi2ss xmm0, DWORD PTR _tRight$10[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si ecx, xmm0
	mov	DWORD PTR _tRight$10[ebp], ecx
$LN56@VCock_Init:

; 924  : 				if (tTop > 1)

	cmp	DWORD PTR _tTop$5[ebp], 1
	jle	SHORT $LN55@VCock_Init

; 925  : 					tTop = (int)(resScale * (float)tTop);

	cvtsi2ss xmm0, DWORD PTR _tTop$5[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si edx, xmm0
	mov	DWORD PTR _tTop$5[ebp], edx
$LN55@VCock_Init:

; 926  : 				if (tBottom > 1)

	cmp	DWORD PTR _tBottom$6[ebp], 1
	jle	SHORT $LN54@VCock_Init

; 927  : 					tBottom = (int)(resScale * (float)tBottom);

	cvtsi2ss xmm0, DWORD PTR _tBottom$6[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si eax, xmm0
	mov	DWORD PTR _tBottom$6[ebp], eax
$LN54@VCock_Init:

; 928  : 			}
; 929  : 			lMFDul = ul;

	mov	ecx, DWORD PTR _ul$22[ebp]
	mov	DWORD PTR ?lMFDul@@3UTpoint@@A, ecx
	mov	edx, DWORD PTR _ul$22[ebp+4]
	mov	DWORD PTR ?lMFDul@@3UTpoint@@A+4, edx
	mov	eax, DWORD PTR _ul$22[ebp+8]
	mov	DWORD PTR ?lMFDul@@3UTpoint@@A+8, eax

; 930  : 			lMFDur = ur;

	mov	ecx, DWORD PTR _ur$21[ebp]
	mov	DWORD PTR ?lMFDur@@3UTpoint@@A, ecx
	mov	edx, DWORD PTR _ur$21[ebp+4]
	mov	DWORD PTR ?lMFDur@@3UTpoint@@A+4, edx
	mov	eax, DWORD PTR _ur$21[ebp+8]
	mov	DWORD PTR ?lMFDur@@3UTpoint@@A+8, eax

; 931  : 			lMFDll = ll;

	mov	ecx, DWORD PTR _ll$19[ebp]
	mov	DWORD PTR ?lMFDll@@3UTpoint@@A, ecx
	mov	edx, DWORD PTR _ll$19[ebp+4]
	mov	DWORD PTR ?lMFDll@@3UTpoint@@A+4, edx
	mov	eax, DWORD PTR _ll$19[ebp+8]
	mov	DWORD PTR ?lMFDll@@3UTpoint@@A+8, eax

; 932  : 			ltMFDleft = tLeft;

	mov	ecx, DWORD PTR _tLeft$8[ebp]
	mov	DWORD PTR ?ltMFDleft@@3HA, ecx		; ltMFDleft

; 933  : 			ltMFDtop = tTop;

	mov	edx, DWORD PTR _tTop$5[ebp]
	mov	DWORD PTR ?ltMFDtop@@3HA, edx		; ltMFDtop

; 934  : 			ltMFDright = tRight;

	mov	eax, DWORD PTR _tRight$10[ebp]
	mov	DWORD PTR ?ltMFDright@@3HA, eax		; ltMFDright

; 935  : 			ltMFDbottom = tBottom;

	mov	ecx, DWORD PTR _tBottom$6[ebp]
	mov	DWORD PTR ?ltMFDbottom@@3HA, ecx	; ltMFDbottom

; 936  : 			lcMFDblend = cBlend;

	mov	dl, BYTE PTR _cBlend$13[ebp]
	mov	BYTE PTR ?lcMFDblend@@3DA, dl		; lcMFDblend

; 937  : 			lcMFDalpha = cAlpha;

	movss	xmm0, DWORD PTR _cAlpha$2[ebp]
	movss	DWORD PTR ?lcMFDalpha@@3MA, xmm0
	jmp	$LN6@VCock_Init
$LN60@VCock_Init:

; 938  : 		}
; 939  : 		else if (!strcmpi(ptoken, PROP_MFDRIGHT_STR)) {// right MFD

	push	OFFSET ??_C@_08KEAJBMEO@mfdright?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN52@VCock_Init

; 940  : 			Tpoint ul, ur, ll;
; 941  : 			int tLeft, tTop, tRight, tBottom;	// ASSO:
; 942  : 			char cBlend = 'c';

	mov	BYTE PTR _cBlend$14[ebp], 99		; 00000063H

; 943  : 			float cAlpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cAlpha$3[ebp], xmm0

; 944  : 			ptoken = FindToken(&plinePtr, "=;\n");	

	push	OFFSET ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 945  : 			if (sscanf(ptoken, "%f %f %f %f %f %f %f %f %f %d %d %d %d %c %f",
; 946  : 				&ul.x, &ul.y, &ul.z,
; 947  : 				&ur.x, &ur.y, &ur.z,
; 948  : 				&ll.x, &ll.y, &ll.z,
; 949  : 				&tLeft, &tTop, &tRight, &tBottom, 
; 950  : 				&cBlend, &cAlpha ) == 9) 

	lea	edx, DWORD PTR _cAlpha$3[ebp]
	push	edx
	lea	eax, DWORD PTR _cBlend$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _tBottom$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _tRight$9[ebp]
	push	edx
	lea	eax, DWORD PTR _tTop$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _tLeft$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _ll$18[ebp+8]
	push	edx
	lea	eax, DWORD PTR _ll$18[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _ll$18[ebp]
	push	ecx
	lea	edx, DWORD PTR _ur$20[ebp+8]
	push	edx
	lea	eax, DWORD PTR _ur$20[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _ur$20[ebp]
	push	ecx
	lea	edx, DWORD PTR _ul$17[ebp+8]
	push	edx
	lea	eax, DWORD PTR _ul$17[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _ul$17[ebp]
	push	ecx
	push	OFFSET ??_C@_0CN@HGJLILKD@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFd?5?$CFd@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 68					; 00000044H
	cmp	eax, 9
	jne	SHORT $LN51@VCock_Init

; 951  : 			{
; 952  : 				tLeft = trMFDleft;

	mov	eax, DWORD PTR ?trMFDleft@@3HA		; trMFDleft
	mov	DWORD PTR _tLeft$12[ebp], eax

; 953  : 				tTop = trMFDtop; 

	mov	ecx, DWORD PTR ?trMFDtop@@3HA		; trMFDtop
	mov	DWORD PTR _tTop$11[ebp], ecx

; 954  : 				tRight = trMFDright; 

	mov	edx, DWORD PTR ?trMFDright@@3HA		; trMFDright
	mov	DWORD PTR _tRight$9[ebp], edx

; 955  : 				tBottom = trMFDbottom;

	mov	eax, DWORD PTR ?trMFDbottom@@3HA	; trMFDbottom
	mov	DWORD PTR _tBottom$7[ebp], eax
$LN51@VCock_Init:

; 956  : 			}
; 957  : 			// Cobra - Lower screen resolutions need a smaller canvas (font is too small)
; 958  : 			if(FindBestResolution() < 1280)

	call	?FindBestResolution@@YAHXZ		; FindBestResolution
	cmp	eax, 1280				; 00000500H
	jge	$LN46@VCock_Init

; 959  : 			{
; 960  : 				if (tLeft > 1)

	cmp	DWORD PTR _tLeft$12[ebp], 1
	jle	SHORT $LN49@VCock_Init

; 961  : 					tLeft = (int)(resScale * (float)tLeft);

	cvtsi2ss xmm0, DWORD PTR _tLeft$12[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si ecx, xmm0
	mov	DWORD PTR _tLeft$12[ebp], ecx
$LN49@VCock_Init:

; 962  : 				if (tRight > 1)

	cmp	DWORD PTR _tRight$9[ebp], 1
	jle	SHORT $LN48@VCock_Init

; 963  : 					tRight = (int)(resScale * (float)tRight);

	cvtsi2ss xmm0, DWORD PTR _tRight$9[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si edx, xmm0
	mov	DWORD PTR _tRight$9[ebp], edx
$LN48@VCock_Init:

; 964  : 				if (tTop > 1)

	cmp	DWORD PTR _tTop$11[ebp], 1
	jle	SHORT $LN47@VCock_Init

; 965  : 					tTop = (int)(resScale * (float)tTop);

	cvtsi2ss xmm0, DWORD PTR _tTop$11[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si eax, xmm0
	mov	DWORD PTR _tTop$11[ebp], eax
$LN47@VCock_Init:

; 966  : 				if (tBottom > 1)

	cmp	DWORD PTR _tBottom$7[ebp], 1
	jle	SHORT $LN46@VCock_Init

; 967  : 					tBottom = (int)(resScale * (float)tBottom);

	cvtsi2ss xmm0, DWORD PTR _tBottom$7[ebp]
	mulss	xmm0, DWORD PTR ?resScale@@3MA
	cvttss2si ecx, xmm0
	mov	DWORD PTR _tBottom$7[ebp], ecx
$LN46@VCock_Init:

; 968  : 			}
; 969  : 			rMFDul = ul;

	mov	edx, DWORD PTR _ul$17[ebp]
	mov	DWORD PTR ?rMFDul@@3UTpoint@@A, edx
	mov	eax, DWORD PTR _ul$17[ebp+4]
	mov	DWORD PTR ?rMFDul@@3UTpoint@@A+4, eax
	mov	ecx, DWORD PTR _ul$17[ebp+8]
	mov	DWORD PTR ?rMFDul@@3UTpoint@@A+8, ecx

; 970  : 			rMFDur = ur;

	mov	edx, DWORD PTR _ur$20[ebp]
	mov	DWORD PTR ?rMFDur@@3UTpoint@@A, edx
	mov	eax, DWORD PTR _ur$20[ebp+4]
	mov	DWORD PTR ?rMFDur@@3UTpoint@@A+4, eax
	mov	ecx, DWORD PTR _ur$20[ebp+8]
	mov	DWORD PTR ?rMFDur@@3UTpoint@@A+8, ecx

; 971  : 			rMFDll = ll;

	mov	edx, DWORD PTR _ll$18[ebp]
	mov	DWORD PTR ?rMFDll@@3UTpoint@@A, edx
	mov	eax, DWORD PTR _ll$18[ebp+4]
	mov	DWORD PTR ?rMFDll@@3UTpoint@@A+4, eax
	mov	ecx, DWORD PTR _ll$18[ebp+8]
	mov	DWORD PTR ?rMFDll@@3UTpoint@@A+8, ecx

; 972  : 			rtMFDleft = tLeft;

	mov	edx, DWORD PTR _tLeft$12[ebp]
	mov	DWORD PTR ?rtMFDleft@@3HA, edx		; rtMFDleft

; 973  : 			rtMFDtop = tTop;

	mov	eax, DWORD PTR _tTop$11[ebp]
	mov	DWORD PTR ?rtMFDtop@@3HA, eax		; rtMFDtop

; 974  : 			rtMFDright = tRight;

	mov	ecx, DWORD PTR _tRight$9[ebp]
	mov	DWORD PTR ?rtMFDright@@3HA, ecx		; rtMFDright

; 975  : 			rtMFDbottom = tBottom;

	mov	edx, DWORD PTR _tBottom$7[ebp]
	mov	DWORD PTR ?rtMFDbottom@@3HA, edx	; rtMFDbottom

; 976  : 			rcMFDblend = cBlend;

	mov	al, BYTE PTR _cBlend$14[ebp]
	mov	BYTE PTR ?rcMFDblend@@3DA, al		; rcMFDblend

; 977  : 			rcMFDalpha = cAlpha;

	movss	xmm0, DWORD PTR _cAlpha$3[ebp]
	movss	DWORD PTR ?rcMFDalpha@@3MA, xmm0
	jmp	$LN6@VCock_Init
$LN52@VCock_Init:

; 978  : 		}
; 979  : 		else if(!strcmpi(ptoken, TYPE_DIAL_STR)) {

	push	OFFSET ??_C@_04FPCGAGCC@DIAL?$AA@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@VCock_Init

; 980  : 			VCock_ParseVDial(pcockpitDataFile);

	mov	edx, DWORD PTR _pcockpitDataFile$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z ; OTWDriverClass::VCock_ParseVDial
	jmp	$LN6@VCock_Init
$LN44@VCock_Init:

; 981  : 		}
; 982  : 		else if (!strcmpi(ptoken, PROP_3D_PADBACKGROUND)) {

	push	OFFSET ??_C@_09BDGLCNBI@padlockbg?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN42@VCock_Init

; 983  : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 984  : 			sscanf(ptoken, "%lx", &pVColors[0][0]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 0
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 985  : 			pVColors[1][0] = CalculateNVGColor(pVColors[0][0]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	imul	edx, 0
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN42@VCock_Init:

; 986  : 		}
; 987  : 		else if (!strcmpi(ptoken, PROP_3D_PADLIFTLINE)) {

	push	OFFSET ??_C@_0BA@MBCBKCMN@padlockliftline?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN40@VCock_Init

; 988  : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 989  : 			sscanf(ptoken, "%lx", &pVColors[0][1]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	shl	edx, 0
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 990  : 			pVColors[1][1] = CalculateNVGColor(pVColors[0][1]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN40@VCock_Init:

; 991  : 		}
; 992  : 		else if (!strcmpi(ptoken, PROP_3D_PADBOXSIDE)) {

	push	OFFSET ??_C@_0O@IFMFANAH@padlockvpside?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN38@VCock_Init

; 993  : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 994  : 			sscanf(ptoken, "%lx", &pVColors[0][2]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	shl	edx, 1
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 995  : 			pVColors[1][2] = CalculateNVGColor(pVColors[0][2]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN38@VCock_Init:

; 996  : 		}
; 997  : 		else if (!strcmpi(ptoken, PROP_3D_PADBOXTOP)) {

	push	OFFSET ??_C@_0N@CKBBNJNL@padlockvptop?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN36@VCock_Init

; 998  : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 999  : 			sscanf(ptoken, "%lx", &pVColors[0][3]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 3
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1000 : 			pVColors[1][3] = CalculateNVGColor(pVColors[0][3]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	imul	edx, 3
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN36@VCock_Init:

; 1001 : 		}
; 1002 : 		else if (!strcmpi(ptoken, PROP_3D_PADTICK)) {

	push	OFFSET ??_C@_0M@ECDAFED@padlocktick?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN34@VCock_Init

; 1003 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1004 : 			sscanf(ptoken, "%lx", &pVColors[0][4]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	shl	edx, 2
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1005 : 			pVColors[1][4] = CalculateNVGColor(pVColors[0][4]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	shl	edx, 2
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN34@VCock_Init:

; 1006 : 		}
; 1007 : 		else if (!strcmpi(ptoken, PROP_3D_NEEDLE0)) {

	push	OFFSET ??_C@_0N@JLPECKLH@needlecolor0?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN32@VCock_Init

; 1008 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1009 : 			sscanf(ptoken, "%lx", &pVColors[0][5]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 5
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1010 : 			pVColors[1][5] = CalculateNVGColor(pVColors[0][5]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 5
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	imul	edx, 5
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN32@VCock_Init:

; 1011 : 		}
; 1012 : 		else if (!strcmpi(ptoken, PROP_3D_NEEDLE1)) {

	push	OFFSET ??_C@_0N@ICOPBLPG@needlecolor1?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN30@VCock_Init

; 1013 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1014 : 			sscanf(ptoken, "%lx", &pVColors[0][6]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 6
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1015 : 			pVColors[1][6] = CalculateNVGColor(pVColors[0][6]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 6
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	imul	edx, 6
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN30@VCock_Init:

; 1016 : 		}
; 1017 : 		else if (!strcmpi(ptoken, PROP_3D_DED)) {

	push	OFFSET ??_C@_08EFPLLPGK@dedcolor?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN28@VCock_Init

; 1018 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1019 : 			sscanf(ptoken, "%lx", &pVColors[0][7]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 7
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1020 : 			pVColors[1][7] = CalculateNVGColor(pVColors[0][7]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 7
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	imul	edx, 7
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN28@VCock_Init:

; 1021 : 		}
; 1022 : 		else if (!strcmpi(ptoken, PROP_3D_RWR)) {

	push	OFFSET ??_C@_08KALBBLDD@rwrcolor?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN26@VCock_Init

; 1023 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1024 : 			sscanf(ptoken, "%lx", &pVColors[0][8]);

	mov	edx, 44					; 0000002cH
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	shl	edx, 3
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1025 : 			pVColors[1][8] = CalculateNVGColor(pVColors[0][8]);

	mov	ecx, 44					; 0000002cH
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	?CalculateNVGColor@@YAKK@Z		; CalculateNVGColor
	add	esp, 4
	mov	ecx, 44					; 0000002cH
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+33696]
	mov	edx, 4
	shl	edx, 3
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN6@VCock_Init
$LN26@VCock_Init:

; 1026 : 		}
; 1027 : 		else if (!strcmpi(ptoken, PROP_3D_HILIGHT)) {

	push	OFFSET ??_C@_09MIAHMBP@highlight?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@VCock_Init

; 1028 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1029 : 			sscanf(ptoken, "%lx", &p3DpitHilite);

	push	OFFSET ?p3DpitHilite@@3KA		; p3DpitHilite
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN24@VCock_Init:

; 1030 : 		}
; 1031 : 		else if (!strcmpi(ptoken, PROP_3D_LOLIGHT)) {

	push	OFFSET ??_C@_08MDNHPGJO@lowlight?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@VCock_Init

; 1032 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1033 : 			sscanf(ptoken, "%lx", &p3DpitLolite);

	push	OFFSET ?p3DpitLolite@@3KA		; p3DpitLolite
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN22@VCock_Init:

; 1034 : 		}
; 1035 : 		else if (!strcmpi(ptoken, PROP_3D_COCKPIT)) {

	push	OFFSET ??_C@_0N@ECHNMOHL@cockpitmodel?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@VCock_Init

; 1036 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1037 : 			sscanf(ptoken, "%d", &vrCockpitModel[0]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+34000]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN20@VCock_Init:

; 1038 : 		}
; 1039 : 		else if (!strcmpi(ptoken, PROP_3D_COCKPITDF)) {

	push	OFFSET ??_C@_0P@BFJPBPOJ@cockpitdfmodel?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@VCock_Init

; 1040 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1041 : 			sscanf(ptoken, "%d", &vrCockpitModel[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+34000]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN18@VCock_Init:

; 1042 : 		}
; 1043 : 		else if (!strcmpi(ptoken, PROP_3D_MAINMODEL)) {

	push	OFFSET ??_C@_09PLEBLAKK@mainmodel?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@VCock_Init

; 1044 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1045 : 			sscanf(ptoken, "%d", &vrCockpitModel[2]);

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+34000]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN16@VCock_Init:

; 1046 : 		}
; 1047 : 		else if (!strcmpi(ptoken, PROP_3D_DAMAGEDMODEL)) {

	push	OFFSET ??_C@_0N@GLLLAGML@damagedmodel?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@VCock_Init

; 1048 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1049 : 			sscanf(ptoken, "%d", &vrCockpitModel[3]);

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+34000]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN14@VCock_Init:

; 1050 : 		}
; 1051 : 		//JAM 10May04
; 1052 : 		else if(!strcmpi(ptoken,PROP_3D_ZBUFFERING))

	push	OFFSET ??_C@_0L@OMMBEINF@zbuffering?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@VCock_Init

; 1053 : 		{
; 1054 : 			ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1055 : 			sscanf(ptoken,"%d",&bVCockZBuffering);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33692				; 0000839cH
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN12@VCock_Init:

; 1056 : 		}
; 1057 : 		else if (!strcmpi(ptoken, PROP_LIFT_LINE_COLOR)) {

	push	OFFSET ??_C@_0O@BFBKOAGD@liftlinecolor?$AA@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@VCock_Init

; 1058 : 			ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	edx, DWORD PTR _plinePtr$15[ebp]
	push	edx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1059 : 			sscanf(ptoken, "%lx", &liftlinecolor);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 34032				; 000084f0H
	push	eax
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	ecx, DWORD PTR _ptoken$16[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN6@VCock_Init
$LN10@VCock_Init:

; 1060 : 		}
; 1061 : 		else if (!strcmpi(ptoken, PROP_3D_BORESIGHT_Y)) {

	push	OFFSET ??_C@_0L@HAIMJJDN@boresighty?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@VCock_Init

; 1062 : 			ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	eax, DWORD PTR _plinePtr$15[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1063 : 			sscanf(ptoken, "%f", &vBoresightY);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33956				; 000084a4H
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _ptoken$16[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@VCock_Init
$LN8@VCock_Init:

; 1064 : 		}
; 1065 : 		else if (!strcmpi(ptoken, PROP_3D_USE_NEW_3DPIT)) {

	push	OFFSET ??_C@_0M@MEJOGGLB@usenew3dpit?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@VCock_Init

; 1066 : 			int	bset = 0;

	mov	DWORD PTR _bset$4[ebp], 0

; 1067 : 			ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$15[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$16[ebp], eax

; 1068 : 			sscanf(ptoken, "%d", &bset);

	lea	edx, DWORD PTR _bset$4[ebp]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, DWORD PTR _ptoken$16[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 1069 : 			if (bset)

	cmp	DWORD PTR _bset$4[ebp], 0
	je	SHORT $LN5@VCock_Init

; 1070 : 				g_bUseNew3dpit = true;

	mov	BYTE PTR ?g_bUseNew3dpit@@3_NA, 1	; g_bUseNew3dpit

; 1071 : 			else

	jmp	SHORT $LN4@VCock_Init
$LN5@VCock_Init:

; 1072 : 				g_bUseNew3dpit = false;

	mov	BYTE PTR ?g_bUseNew3dpit@@3_NA, 0	; g_bUseNew3dpit
$LN4@VCock_Init:
$LN6@VCock_Init:

; 1073 : 
; 1074 : 		}
; 1075 : 		else {
; 1076 : 			F4Assert(!"Unknown Line in 3dfile");
; 1077 : 		}
; 1078 : 	}

	jmp	$LN88@VCock_Init
$LN82@VCock_Init:

; 1079 : 	// Check for missing PFL RTT data
; 1080 : 	if (!vPFLrenderer) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33992], 0
	jne	SHORT $LN1@VCock_Init

; 1081 : 	{
; 1082 : 		if (!VCock_SetRttCanvas(NULL, &vPFLrenderer, 6)) 

	push	6
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33992				; 000084c8H
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_SetRttCanvas@OTWDriverClass@@AAE_NPAPADPAPAVRender2D@@H@Z ; OTWDriverClass::VCock_SetRttCanvas
$LN1@VCock_Init:

; 1083 : 		{ // ASSO:
; 1084 : 			F4Assert("Bad PFL description");
; 1085 : 		}
; 1086 : 	}
; 1087 : 
; 1088 : 	return true;

	mov	al, 1

; 1089 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?VCock_Init@OTWDriverClass@@AAE_NHPAD0@Z ENDP		; OTWDriverClass::VCock_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
$T2 = -656						; size = 4
$T3 = -652						; size = 4
$T4 = -648						; size = 4
$T5 = -644						; size = 4
_vdial$ = -640						; size = 4
$T6 = -636						; size = 4
_vdialInitStr$ = -632					; size = 40
$T7 = -592						; size = 4
_this$ = -588						; size = 4
tv264 = -584						; size = 4
_pointsIndex$ = -580					; size = 4
_valuesIndex$ = -576					; size = 4
_plinePtr$ = -572					; size = 4
_ptoken$ = -568						; size = 4
_ul$ = -564						; size = 12
_ur$ = -552						; size = 12
_ll$ = -540						; size = 12
_plineBuffer$ = -528					; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fp$ = 8						; size = 4
?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z PROC ; OTWDriverClass::VCock_ParseVDial
; _this$ = ecx

; 721  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 644				; 00000284H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 722  :     VDialInitStr vdialInitStr;
; 723  :     static const char		pseparators[] = {0x20, 0x2c, 0x3d, 0x3b, 0x0d, 0x0a, 0x09, 0x00};
; 724  :     int				valuesIndex = 0;

	mov	DWORD PTR _valuesIndex$[ebp], 0

; 725  :     int				pointsIndex = 0;

	mov	DWORD PTR _pointsIndex$[ebp], 0

; 726  :     char			plineBuffer[MAX_LINE_BUFFER];
; 727  :     char *plinePtr, *ptoken;
; 728  :     Tpoint ur, ul, ll;
; 729  :     
; 730  :     ZeroMemory(&vdialInitStr, sizeof vdialInitStr);

	push	40					; 00000028H
	push	0
	lea	eax, DWORD PTR _vdialInitStr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 731  :     vdialInitStr.callback = -1;

	mov	DWORD PTR _vdialInitStr$[ebp], -1

; 732  : 
; 733  :     fgets(plineBuffer, sizeof plineBuffer, fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	512					; 00000200H
	lea	edx, DWORD PTR _plineBuffer$[ebp]
	push	edx
	call	_fgets
	add	esp, 12					; 0000000cH

; 734  :     plinePtr = plineBuffer;

	lea	eax, DWORD PTR _plineBuffer$[ebp]
	mov	DWORD PTR _plinePtr$[ebp], eax

; 735  :     ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 736  :     vdialInitStr.ppoints = NULL;

	mov	DWORD PTR _vdialInitStr$[ebp+36], 0

; 737  :     vdialInitStr.pvalues = NULL;

	mov	DWORD PTR _vdialInitStr$[ebp+32], 0
$LN21@VCock_Pars:

; 738  :     
; 739  :     while(strcmpi(ptoken, END_MARKER)){

	push	OFFSET ??_C@_04PAJMBCIO@?$CDend?$AA@
	mov	edx, DWORD PTR _ptoken$[ebp]
	push	edx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	je	$LN20@VCock_Pars

; 740  : 	
; 741  : 	if(!strcmpi(ptoken, PROP_NUMENDPOINTS_STR)) {

	push	OFFSET ??_C@_0N@NJACGLBK@numendpoints?$AA@
	mov	eax, DWORD PTR _ptoken$[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN19@VCock_Pars

; 742  : 	    ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 743  : 	    sscanf(ptoken, "%d", &vdialInitStr.endPoints);

	lea	edx, DWORD PTR _vdialInitStr$[ebp+28]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, DWORD PTR _ptoken$[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 744  : 	    vdialInitStr.ppoints = new float[vdialInitStr.endPoints];

	xor	ecx, ecx
	mov	eax, DWORD PTR _vdialInitStr$[ebp+28]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _vdialInitStr$[ebp+36], eax

; 745  : 	    vdialInitStr.pvalues = new float[vdialInitStr.endPoints];

	xor	ecx, ecx
	mov	eax, DWORD PTR _vdialInitStr$[ebp+28]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _vdialInitStr$[ebp+32], eax
	jmp	$LN18@VCock_Pars
$LN19@VCock_Pars:

; 746  : 	}
; 747  : 	else if(!strcmpi(ptoken, PROP_POINTS_STR)) {

	push	OFFSET ??_C@_06GPGIDCJA@points?$AA@
	mov	ecx, DWORD PTR _ptoken$[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@VCock_Pars

; 748  : 	    ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	edx, DWORD PTR _plinePtr$[ebp]
	push	edx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax
$LN16@VCock_Pars:

; 749  : 	    while(ptoken) {

	cmp	DWORD PTR _ptoken$[ebp], 0
	je	SHORT $LN15@VCock_Pars

; 750  : 		F4Assert(pointsIndex < vdialInitStr.endPoints);
; 751  : 		sscanf(ptoken, "%f", &vdialInitStr.ppoints[pointsIndex]);

	mov	eax, DWORD PTR _pointsIndex$[ebp]
	mov	ecx, DWORD PTR _vdialInitStr$[ebp+36]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	eax, DWORD PTR _ptoken$[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 752  : 		ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 753  : 		pointsIndex++;

	mov	edx, DWORD PTR _pointsIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _pointsIndex$[ebp], edx

; 754  : 	    }

	jmp	SHORT $LN16@VCock_Pars
$LN15@VCock_Pars:

; 755  : 	}
; 756  : 	else if(!strcmpi(ptoken, PROP_VALUES_STR)) {

	jmp	$LN18@VCock_Pars
$LN17@VCock_Pars:
	push	OFFSET ??_C@_06GEKOPAHD@values?$AA@
	mov	eax, DWORD PTR _ptoken$[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@VCock_Pars

; 757  : 	    ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax
$LN12@VCock_Pars:

; 758  : 	    while(ptoken) {

	cmp	DWORD PTR _ptoken$[ebp], 0
	je	SHORT $LN11@VCock_Pars

; 759  : 		F4Assert(valuesIndex < vdialInitStr.endPoints);
; 760  : 		sscanf(ptoken, "%f", &vdialInitStr.pvalues[valuesIndex]);

	mov	edx, DWORD PTR _valuesIndex$[ebp]
	mov	eax, DWORD PTR _vdialInitStr$[ebp+32]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _ptoken$[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH

; 761  : 		ptoken = FindToken(&plinePtr, pseparators);

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	eax, DWORD PTR _plinePtr$[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 762  : 		valuesIndex++;

	mov	ecx, DWORD PTR _valuesIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _valuesIndex$[ebp], ecx

; 763  : 	    }

	jmp	SHORT $LN12@VCock_Pars
$LN11@VCock_Pars:

; 764  : 	}
; 765  : 	else if(!strcmpi(ptoken, PROP_RADIUS0_STR)) {

	jmp	$LN18@VCock_Pars
$LN13@VCock_Pars:
	push	OFFSET ??_C@_07ILDOBJAO@radius0?$AA@
	mov	edx, DWORD PTR _ptoken$[ebp]
	push	edx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@VCock_Pars

; 766  : 	    ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	eax, DWORD PTR _plinePtr$[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 767  : 	    sscanf(ptoken, "%f", &vdialInitStr.radius);

	lea	ecx, DWORD PTR _vdialInitStr$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	mov	edx, DWORD PTR _ptoken$[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN18@VCock_Pars
$LN9@VCock_Pars:

; 768  : 	}
; 769  : 	else if(!strcmpi(ptoken, PROP_COLOR0_STR)) {

	push	OFFSET ??_C@_06JGNLDMKC@color0?$AA@
	mov	eax, DWORD PTR _ptoken$[ebp]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@VCock_Pars

; 770  : 	    ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	ecx, DWORD PTR _plinePtr$[ebp]
	push	ecx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 771  : 	    sscanf(ptoken, "%lx", &vdialInitStr.color);

	lea	edx, DWORD PTR _vdialInitStr$[ebp+24]
	push	edx
	push	OFFSET ??_C@_03OPHMLOFF@?$CFlx?$AA@
	mov	eax, DWORD PTR _ptoken$[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN18@VCock_Pars
$LN7@VCock_Pars:

; 772  : 	}
; 773  : 	else if(!strcmpi(ptoken, PROP_CALLBACKSLOT_STR)) {

	push	OFFSET ??_C@_0N@BALDINCG@callbackslot?$AA@
	mov	ecx, DWORD PTR _ptoken$[ebp]
	push	ecx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@VCock_Pars

; 774  : 	    ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	edx, DWORD PTR _plinePtr$[ebp]
	push	edx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 775  : 	    sscanf(ptoken, "%d", &vdialInitStr.callback);

	lea	eax, DWORD PTR _vdialInitStr$[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	ecx, DWORD PTR _ptoken$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	jmp	$LN18@VCock_Pars
$LN5@VCock_Pars:

; 776  : 	}
; 777  : 	else if (!strcmpi(ptoken, PROP_DESTLOC_STR)) {

	push	OFFSET ??_C@_07OKLNCIDH@destloc?$AA@
	mov	edx, DWORD PTR _ptoken$[ebp]
	push	edx
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	$LN18@VCock_Pars

; 778  : 	    ptoken = FindToken(&plinePtr, "=;\n");	

	push	OFFSET ??_C@_03OCLOCGE@?$DN?$DL?6?$AA@
	lea	eax, DWORD PTR _plinePtr$[ebp]
	push	eax
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 779  : 	    if (sscanf(ptoken, "%f %f %f %f %f %f %f %f %f", 
; 780  : 		&ul.x, &ul.y, &ul.z,
; 781  : 		&ur.x, &ur.y, &ur.z,
; 782  : 		&ll.x, &ll.y, &ll.z) == 9) {

	lea	ecx, DWORD PTR _ll$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ll$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ll$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ur$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ur$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ur$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ul$[ebp+8]
	push	ecx
	lea	edx, DWORD PTR _ul$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ul$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@PNBJJOIP@?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?5?$CFf?$AA@
	mov	ecx, DWORD PTR _ptoken$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 44					; 0000002cH
	cmp	eax, 9
	jne	SHORT $LN18@VCock_Pars

; 783  : 		vdialInitStr.pUL = &ul;

	lea	edx, DWORD PTR _ul$[ebp]
	mov	DWORD PTR _vdialInitStr$[ebp+4], edx

; 784  : 		vdialInitStr.pUR = &ur;

	lea	eax, DWORD PTR _ur$[ebp]
	mov	DWORD PTR _vdialInitStr$[ebp+8], eax

; 785  : 		vdialInitStr.pLL = &ll;

	lea	ecx, DWORD PTR _ll$[ebp]
	mov	DWORD PTR _vdialInitStr$[ebp+12], ecx
$LN18@VCock_Pars:

; 786  : 	    }
; 787  : 	}
; 788  : 	else {
; 789  : 	    F4Assert(!"Unknown Line in dial defn");
; 790  : 	}
; 791  : 	
; 792  : 	fgets(plineBuffer, sizeof plineBuffer, fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	512					; 00000200H
	lea	eax, DWORD PTR _plineBuffer$[ebp]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH

; 793  : 	plinePtr = plineBuffer;

	lea	ecx, DWORD PTR _plineBuffer$[ebp]
	mov	DWORD PTR _plinePtr$[ebp], ecx

; 794  : 	ptoken = FindToken(&plinePtr, pseparators);	

	push	OFFSET ?pseparators@?1??VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z@4QBDB
	lea	edx, DWORD PTR _plinePtr$[ebp]
	push	edx
	call	?FindToken@@YAPADPAPADPBD@Z		; FindToken
	add	esp, 8
	mov	DWORD PTR _ptoken$[ebp], eax

; 795  :     }

	jmp	$LN21@VCock_Pars
$LN20@VCock_Pars:

; 796  :     vdialInitStr.pRender		= renderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	DWORD PTR _vdialInitStr$[ebp+16], ecx

; 797  :     VDial *vdial = new VDial(&vdialInitStr);

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN24@VCock_Pars
	lea	edx, DWORD PTR _vdialInitStr$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0VDial@@QAE@PAUVDialInitStr@@@Z	; VDial::VDial
	mov	DWORD PTR tv264[ebp], eax
	jmp	SHORT $LN25@VCock_Pars
$LN24@VCock_Pars:
	mov	DWORD PTR tv264[ebp], 0
$LN25@VCock_Pars:
	mov	eax, DWORD PTR tv264[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _vdial$[ebp], ecx

; 798  :     mpVDials.push_back(vdial);

	lea	edx, DWORD PTR _vdial$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34020				; 000084e4H
	call	?push_back@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXABQAVVDial@@@Z ; std::vector<VDial *,std::allocator<VDial *> >::push_back

; 799  :     delete [] vdialInitStr.ppoints;

	mov	eax, DWORD PTR _vdialInitStr$[ebp+36]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 800  :     delete [] vdialInitStr.pvalues;

	mov	edx, DWORD PTR _vdialInitStr$[ebp+32]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 801  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-648]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?VCock_ParseVDial@OTWDriverClass@@AAEXPAU_iobuf@@@Z ENDP ; OTWDriverClass::VCock_ParseVDial
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv369 = -128						; size = 4
$T1 = -124						; size = 4
tv343 = -120						; size = 4
$T2 = -116						; size = 4
tv317 = -112						; size = 4
$T3 = -108						; size = 4
tv291 = -104						; size = 4
$T4 = -100						; size = 4
tv264 = -96						; size = 4
$T5 = -92						; size = 4
tv233 = -88						; size = 4
$T6 = -84						; size = 4
tv202 = -80						; size = 4
$T7 = -76						; size = 4
tv171 = -72						; size = 4
$T8 = -68						; size = 4
tv140 = -64						; size = 4
$T9 = -60						; size = 4
tv77 = -56						; size = 4
$T10 = -52						; size = 4
$T11 = -48						; size = 4
$T12 = -44						; size = 4
$T13 = -40						; size = 4
$T14 = -36						; size = 4
$T15 = -32						; size = 4
$T16 = -28						; size = 4
$T17 = -24						; size = 4
$T18 = -20						; size = 4
$T19 = -16						; size = 4
$T20 = -12						; size = 4
_i$21 = -8						; size = 4
_this$ = -4						; size = 4
?VCock_Cleanup@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::VCock_Cleanup
; _this$ = ecx

; 3244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 3245 : //		int i;
; 3246 : 
; 3247 : 		for(unsigned int i = 0; i < mpVDials.size(); i++) {

	mov	DWORD PTR _i$21[ebp], 0
	jmp	SHORT $LN12@VCock_Clea
$LN11@VCock_Clea:
	mov	eax, DWORD PTR _i$21[ebp]
	add	eax, 1
	mov	DWORD PTR _i$21[ebp], eax
$LN12@VCock_Clea:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34020				; 000084e4H
	call	?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::size
	cmp	DWORD PTR _i$21[ebp], eax
	jae	SHORT $LN10@VCock_Clea

; 3248 : 			delete mpVDials[i];

	mov	ecx, DWORD PTR _i$21[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34020				; 000084e4H
	call	??A?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEAAPAVVDial@@I@Z ; std::vector<VDial *,std::allocator<VDial *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T10[ebp], edx
	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T11[ebp], eax
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN15@VCock_Clea
	push	1
	mov	ecx, DWORD PTR $T11[ebp]
	call	??_GVDial@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN16@VCock_Clea
$LN15@VCock_Clea:
	mov	DWORD PTR tv77[ebp], 0
$LN16@VCock_Clea:

; 3249 : 		}

	jmp	SHORT $LN11@VCock_Clea
$LN10@VCock_Clea:

; 3250 : 		mpVDials.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34020				; 000084e4H
	call	?clear@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXXZ ; std::vector<VDial *,std::allocator<VDial *> >::clear

; 3251 : 
; 3252 :    	if (vcInfo.vHUDrenderer)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33960], 0
	je	SHORT $LN9@VCock_Clea

; 3253 :    	{
; 3254 :       	vcInfo.vHUDrenderer->Cleanup();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33960]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33960]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 3255 :       	delete vcInfo.vHUDrenderer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33960]
	mov	DWORD PTR $T9[ebp], edx
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T20[ebp], eax
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN17@VCock_Clea
	push	1
	mov	ecx, DWORD PTR $T20[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T20[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN18@VCock_Clea
$LN17@VCock_Clea:
	mov	DWORD PTR tv140[ebp], 0
$LN18@VCock_Clea:

; 3256 :       	vcInfo.vHUDrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33960], 0
$LN9@VCock_Clea:

; 3257 :    	}
; 3258 :    	if (vcInfo.vRWRrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33964], 0
	je	SHORT $LN8@VCock_Clea

; 3259 :    	{
; 3260 :       	vcInfo.vRWRrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33964]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33964]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3261 :       	delete vcInfo.vRWRrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33964]
	mov	DWORD PTR $T8[ebp], ecx
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T19[ebp], edx
	cmp	DWORD PTR $T19[ebp], 0
	je	SHORT $LN19@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T19[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T19[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN20@VCock_Clea
$LN19@VCock_Clea:
	mov	DWORD PTR tv171[ebp], 0
$LN20@VCock_Clea:

; 3262 :       	vcInfo.vRWRrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33964], 0
$LN8@VCock_Clea:

; 3263 :    	}
; 3264 :    	if (vcInfo.vMACHrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33968], 0
	je	SHORT $LN7@VCock_Clea

; 3265 :    	{
; 3266 :       	vcInfo.vMACHrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33968]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33968]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3267 :       	delete vcInfo.vMACHrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33968]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T18[ebp], edx
	cmp	DWORD PTR $T18[ebp], 0
	je	SHORT $LN21@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T18[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T18[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv202[ebp], eax
	jmp	SHORT $LN22@VCock_Clea
$LN21@VCock_Clea:
	mov	DWORD PTR tv202[ebp], 0
$LN22@VCock_Clea:

; 3268 :       	vcInfo.vMACHrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33968], 0
$LN7@VCock_Clea:

; 3269 :    	}
; 3270 :    	if (vcInfo.vDEDrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33972], 0
	je	SHORT $LN6@VCock_Clea

; 3271 :    	{
; 3272 :       	vcInfo.vDEDrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33972]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33972]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3273 :       	delete vcInfo.vDEDrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33972]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T17[ebp], edx
	cmp	DWORD PTR $T17[ebp], 0
	je	SHORT $LN23@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T17[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T17[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv233[ebp], eax
	jmp	SHORT $LN24@VCock_Clea
$LN23@VCock_Clea:
	mov	DWORD PTR tv233[ebp], 0
$LN24@VCock_Clea:

; 3274 :       	vcInfo.vDEDrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33972], 0
$LN6@VCock_Clea:

; 3275 :    	}
; 3276 :    	if (vcInfo.vPFLrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33976], 0
	je	SHORT $LN5@VCock_Clea

; 3277 :    	{
; 3278 :       	vcInfo.vPFLrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33976]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33976]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3279 :       	delete vcInfo.vPFLrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33976]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T16[ebp], edx
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN25@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T16[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T16[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv264[ebp], eax
	jmp	SHORT $LN26@VCock_Clea
$LN25@VCock_Clea:
	mov	DWORD PTR tv264[ebp], 0
$LN26@VCock_Clea:

; 3280 :       	vcInfo.vPFLrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33976], 0
$LN5@VCock_Clea:

; 3281 :    	}
; 3282 : 	// ASSO
; 3283 : 	if (vHUDrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33980], 0
	je	SHORT $LN4@VCock_Clea

; 3284 : 	{
; 3285 : 		vHUDrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33980]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3286 : 		delete vHUDrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33980]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T15[ebp], edx
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN27@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T15[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T15[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv291[ebp], eax
	jmp	SHORT $LN28@VCock_Clea
$LN27@VCock_Clea:
	mov	DWORD PTR tv291[ebp], 0
$LN28@VCock_Clea:

; 3287 : 		vHUDrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33980], 0
$LN4@VCock_Clea:

; 3288 : 	}
; 3289 : 	if (vRWRrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33984], 0
	je	SHORT $LN3@VCock_Clea

; 3290 : 	{
; 3291 : 		vRWRrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33984]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33984]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3292 : 		delete vRWRrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33984]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T14[ebp], edx
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN29@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T14[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T14[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv317[ebp], eax
	jmp	SHORT $LN30@VCock_Clea
$LN29@VCock_Clea:
	mov	DWORD PTR tv317[ebp], 0
$LN30@VCock_Clea:

; 3293 : 		vRWRrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33984], 0
$LN3@VCock_Clea:

; 3294 : 	}
; 3295 : 	if (vDEDrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33988], 0
	je	SHORT $LN2@VCock_Clea

; 3296 : 	{
; 3297 : 		vDEDrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33988]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3298 : 		delete vDEDrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33988]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T13[ebp], edx
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN31@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T13[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T13[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv343[ebp], eax
	jmp	SHORT $LN32@VCock_Clea
$LN31@VCock_Clea:
	mov	DWORD PTR tv343[ebp], 0
$LN32@VCock_Clea:

; 3299 : 		vDEDrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33988], 0
$LN2@VCock_Clea:

; 3300 : 	}
; 3301 : 	if (vPFLrenderer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33992], 0
	je	SHORT $LN1@VCock_Clea

; 3302 : 	{
; 3303 : 		vPFLrenderer->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3304 : 		delete vPFLrenderer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T12[ebp], edx
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN33@VCock_Clea
	push	1
	mov	eax, DWORD PTR $T12[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv369[ebp], eax
	jmp	SHORT $LN34@VCock_Clea
$LN33@VCock_Clea:
	mov	DWORD PTR tv369[ebp], 0
$LN34@VCock_Clea:

; 3305 : 		vPFLrenderer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+33992], 0
$LN1@VCock_Clea:

; 3306 : 	}
; 3307 : 	VirtualDisplay::CleanupRttTarget();

	call	?CleanupRttTarget@VirtualDisplay@@SA_NXZ ; VirtualDisplay::CleanupRttTarget

; 3308 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VCock_Cleanup@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::VCock_Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv6619 = -920						; size = 8
_top$1 = -912						; size = 4
tv6610 = -908						; size = 8
_bottom$2 = -900					; size = 4
tv6601 = -896						; size = 8
tv7310 = -888						; size = 8
tv6166 = -880						; size = 8
_sms$ = -872						; size = 4
_trig$ = -868						; size = 8
_dtILS$3 = -860						; size = 4
_fuelflowdigit3$4 = -856				; size = 4
tv5918 = -852						; size = 4
tv6707 = -848						; size = 4
tv5912 = -844						; size = 4
_VRatio$5 = -840					; size = 4
_t$6 = -836						; size = 4
_machsecondDigit$7 = -832				; size = 4
_y1$ = -828						; size = 4
tv7276 = -824						; size = 4
tv7253 = -820						; size = 4
_x2$ = -816						; size = 4
_hudangy$8 = -812					; size = 4
_y2$ = -808						; size = 4
_currentTime$9 = -804					; size = 4
_stepx$10 = -800					; size = 4
_x1$ = -796						; size = 4
_XOffset$11 = -792					; size = 4
tv6370 = -788						; size = 4
tv7287 = -784						; size = 4
_stepx$12 = -780					; size = 4
_left$13 = -776						; size = 4
tv7304 = -772						; size = 4
_right$14 = -768					; size = 4
_YOffset$15 = -764					; size = 4
tv8083 = -760						; size = 4
tv8075 = -756						; size = 4
tv7967 = -752						; size = 4
tv8073 = -748						; size = 4
_td$16 = -744						; size = 4
_ratio$17 = -740					; size = 4
tv8081 = -736						; size = 4
_hudangx$18 = -732					; size = 4
tv7838 = -728						; size = 4
tv6717 = -724						; size = 4
tv8077 = -720						; size = 4
_seconds$19 = -716					; size = 4
tv8079 = -712						; size = 4
_altsecondDigit$20 = -708				; size = 4
tv7796 = -704						; size = 4
tv7791 = -700						; size = 4
_bsp$21 = -696						; size = 4
tv228 = -692						; size = 4
_machNumber$22 = -688					; size = 4
tv210 = -684						; size = 4
tv1084 = -680						; size = 4
tv192 = -676						; size = 4
tv1188 = -672						; size = 4
tv174 = -668						; size = 4
tv977 = -664						; size = 4
tv156 = -660						; size = 4
tv1371 = -656						; size = 4
tv913 = -652						; size = 4
tv1136 = -648						; size = 4
tv897 = -644						; size = 4
tv1032 = -640						; size = 4
tv865 = -636						; size = 4
tv246 = -632						; size = 4
tv833 = -628						; size = 4
tv1377 = -624						; size = 4
tv801 = -620						; size = 4
tv1367 = -616						; size = 4
tv769 = -612						; size = 4
tv1162 = -608						; size = 4
tv737 = -604						; size = 4
tv1110 = -600						; size = 4
tv705 = -596						; size = 4
tv1058 = -592						; size = 4
tv673 = -588						; size = 4
tv1006 = -584						; size = 4
tv641 = -580						; size = 4
tv945 = -576						; size = 4
tv612 = -572						; size = 4
_machfirstDigit$23 = -568				; size = 4
tv580 = -564						; size = 4
tv1378 = -560						; size = 4
tv548 = -556						; size = 4
tv1374 = -552						; size = 4
tv516 = -548						; size = 4
tv1370 = -544						; size = 4
tv484 = -540						; size = 4
tv6163 = -536						; size = 4
tv412 = -532						; size = 4
tv1175 = -528						; size = 4
_canopyopen$24 = -524					; size = 4
tv1149 = -520						; size = 4
tv369 = -516						; size = 4
tv136 = -512						; size = 4
tv326 = -508						; size = 4
tv1097 = -504						; size = 4
tv282 = -500						; size = 4
tv1071 = -496						; size = 4
tv6615 = -492						; size = 4
tv1045 = -488						; size = 4
tv6606 = -484						; size = 4
tv1019 = -480						; size = 4
_minutes$25 = -476					; size = 4
tv993 = -472						; size = 4
tv6597 = -468						; size = 4
tv961 = -464						; size = 4
_altneedle$26 = -460					; size = 4
tv929 = -456						; size = 4
_altfirstDigit$27 = -452				; size = 4
_alt$28 = -448						; size = 4
tv881 = -444						; size = 4
tv5478 = -440						; size = 4
tv849 = -436						; size = 4
_vc$ = -432						; size = 4
tv817 = -428						; size = 4
tv5441 = -424						; size = 4
tv785 = -420						; size = 4
_closestdistance$29 = -416				; size = 4
tv753 = -412						; size = 4
tv4710 = -408						; size = 4
tv721 = -404						; size = 4
tv4647 = -400						; size = 4
tv689 = -396						; size = 4
tv4637 = -392						; size = 4
tv657 = -388						; size = 4
tv4620 = -384						; size = 4
tv625 = -380						; size = 4
tv4610 = -376						; size = 4
tv596 = -372						; size = 4
tv4536 = -368						; size = 4
tv564 = -364						; size = 4
$T30 = -360						; size = 4
tv532 = -356						; size = 4
tv4396 = -352						; size = 4
tv500 = -348						; size = 4
tv4320 = -344						; size = 4
tv470 = -340						; size = 4
tv4195 = -336						; size = 4
tv394 = -332						; size = 4
$T31 = -328						; size = 4
tv380 = -324						; size = 4
tv4088 = -320						; size = 4
tv344 = -316						; size = 4
tv3998 = -312						; size = 4
tv304 = -308						; size = 4
tv3856 = -304						; size = 4
tv264 = -300						; size = 4
_Seconds$32 = -296					; size = 4
tv1123 = -292						; size = 4
_crsToTrueFlag$33 = -288				; size = 4
_fuelflow$34 = -284					; size = 4
_hsidist$35 = -280					; size = 4
_Hours$36 = -276					; size = 4
_hsicrs$37 = -272					; size = 4
_Minutes$38 = -268					; size = 4
_x$39 = -264						; size = 4
_td$40 = -260						; size = 4
_y$41 = -256						; size = 4
_y$42 = -252						; size = 4
_rwr$ = -248						; size = 4
_x$43 = -244						; size = 4
_theMissile$44 = -240					; size = 4
_tempdistance$45 = -236					; size = 4
_xDiff$46 = -232					; size = 4
_remainder$47 = -228					; size = 4
_hours$48 = -224					; size = 4
_GetKias$49 = -220					; size = 4
_vvi$50 = -216						; size = 4
_oldFont$ = -212					; size = 4
_hsidev$51 = -208					; size = 4
_value$52 = -204					; size = 4
_i$53 = -200						; size = 4
_closestbutton$54 = -196				; size = 4
_aoa$55 = -192						; size = 4
_j$56 = -188						; size = 4
_i$57 = -184						; size = 4
_j$58 = -180						; size = 4
_buf$59 = -176						; size = 2
_buf$60 = -172						; size = 2
_needle$61 = -168					; size = 4
_ftit$62 = -164						; size = 4
_theRwr$63 = -160					; size = 4
_rpm$64 = -156						; size = 4
_i$ = -152						; size = 4
_val$65 = -148						; size = 4
_this$ = -144						; size = 4
_t1$ = -140						; size = 52
_Pan$ = -88						; size = 12
_Pos$66 = -76						; size = 12
_Pos$67 = -64						; size = 12
_Pos$68 = -52						; size = 12
_pt$69 = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
?VCock_Exec@OTWDriverClass@@AAEXXZ PROC			; OTWDriverClass::VCock_Exec
; _this$ = ecx

; 1455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 920				; 00000398H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1456 : #if 1
; 1457 : 	renderer->ChangeFontSet( &VirtualDisplay::Font3D ); // ASFO:

	push	OFFSET ?Font3D@VirtualDisplay@@2UFontSet@@A ; VirtualDisplay::Font3D
	call	?ChangeFontSet@Render2D@@SAXPAUFontSet@@@Z ; Render2D::ChangeFontSet
	add	esp, 4

; 1458 : 
; 1459 :     int				i;
; 1460 :     PlayerRwrClass	*rwr;
; 1461 :     float			x1, y1, x2, y2;
; 1462 :     mlTrig			trig;
; 1463 :     SMSClass		*sms = SimDriver.GetPlayerAircraft()->Sms;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+940]
	mov	DWORD PTR _sms$[ebp], eax

; 1464 :     int oldFont = VirtualDisplay::CurFont();

	call	?CurFont@VirtualDisplay@@SAHXZ		; VirtualDisplay::CurFont
	mov	DWORD PTR _oldFont$[ebp], eax

; 1465 : 
; 1466 :     // Make sure we don't get in here when we shouldn't
; 1467 :     ShiAssert( otwPlatform );
; 1468 :     ShiAssert( otwPlatform->IsSetFlag(MOTION_OWNSHIP) );
; 1469 :     //ShiAssert( otwPlatform == SimDriver.GetPlayerAircraft() );
; 1470 :     ShiAssert( sms );	// If we legally might not have one, then we'd have to skip the ordinance...
; 1471 :     
; 1472 : 	/*
; 1473 : 	** Render the 3d cockpit object
; 1474 : 	*/
; 1475 : 
; 1476 : 	ShiAssert(vrCockpit);
; 1477 : 	if (!vrCockpit) // CTD fix

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33996], 0
	jne	SHORT $LN373@VCock_Exec

; 1478 : 		return;

	jmp	$LN374@VCock_Exec
$LN373@VCock_Exec:

; 1479 : 
; 1480 : 
; 1481 : 	// MLR 2003-10-12
; 1482 : 	// I moved all my previous animation code to the AircraftClass, 
; 1483 : 	// it's more readily (more likely) to get updated there as new 
; 1484 : 	// DOFs and Switches are added.
; 1485 : 	//
; 1486 : 	// Also both 2d and 3d pit had the exact same duplicate code.
; 1487 : 	SimDriver.GetPlayerAircraft()->CopyAnimationsToPit(vrCockpit);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33996]
	push	eax
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?CopyAnimationsToPit@AircraftClass@@QAEXPAVDrawableBSP@@@Z ; AircraftClass::CopyAnimationsToPit

; 1488 : 
; 1489 : 
; 1490 : 	{   // MLR 2003-10-05 This needs to be moved so it only runs once
; 1491 : 		DrawableBSP *bsp=(DrawableBSP*)SimDriver.GetPlayerAircraft()->drawPointer;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+332]
	mov	DWORD PTR _bsp$21[ebp], ecx

; 1492 : 		int t = bsp->GetTextureSet();

	mov	ecx, DWORD PTR _bsp$21[ebp]
	call	?GetTextureSet@DrawableBSP@@QAEKXZ	; DrawableBSP::GetTextureSet
	mov	DWORD PTR _t$6[ebp], eax

; 1493 : 		vrCockpit->SetTextureSet(t % vrCockpit->GetNTextureSet());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?GetNTextureSet@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNTextureSet
	mov	ecx, eax
	mov	eax, DWORD PTR _t$6[ebp]
	cdq
	idiv	ecx
	push	edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetTextureSet@DrawableBSP@@QAEXK@Z	; DrawableBSP::SetTextureSet

; 1494 : 	}
; 1495 : 
; 1496 : 
; 1497 : 
; 1498 :     // master caution light
; 1499 : 	/*ATARIBABY Master Caution Light fix - not updated in virtual cockpit 
; 1500 : 	Use cockpitFlightData.IsSet(FlightData::MasterCaution) instead of pCockpitManager->mMiscStates.GetMasterCautionLight()
; 1501 : 	Looks like pCockpitManager->mMiscStates.GetMasterCautionLight() is updated only if 2d caution light is in view
; 1502 : 	Added Main Power check to all caution lights to copy 2d pit functionality*/
; 1503 : 	// sfr: will test this using callbacks
; 1504 : #if 1
; 1505 : 	if ( cockpitFlightData.IsSet(FlightData::MasterCaution) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	1
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN372@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN376@VCock_Exec
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN377@VCock_Exec
$LN376@VCock_Exec:
	mov	DWORD PTR tv136[ebp], 0
$LN377@VCock_Exec:
	cmp	DWORD PTR tv136[ebp], 0
	jne	SHORT $LN372@VCock_Exec

; 1506 : 		vrCockpit->SetSwitchMask( 2, 1);

	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1507 : 	else

	jmp	SHORT $LN371@VCock_Exec
$LN372@VCock_Exec:

; 1508 : 		vrCockpit->SetSwitchMask( 2, 0);

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN371@VCock_Exec:

; 1509 : #endif
; 1510 : 
; 1511 : 
; 1512 : 	//ATARIBABY but big thanx to ASSOCIATOR, new 3dpit start
; 1513 : 	if (g_bUseNew3dpit)

	movzx	edx, BYTE PTR ?g_bUseNew3dpit@@3_NA	; g_bUseNew3dpit
	test	edx, edx
	je	$LN370@VCock_Exec

; 1514 : 	{
; 1515 : 		//******************************************
; 1516 : 		// LIGHTS
; 1517 : 		//******************************************
; 1518 : 
; 1519 : 		// AR/RDY light 
; 1520 : 		if (cockpitFlightData.IsSet(FlightData::RefuelRDY) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	32768					; 00008000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN369@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN378@VCock_Exec
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN379@VCock_Exec
$LN378@VCock_Exec:
	mov	DWORD PTR tv156[ebp], 0
$LN379@VCock_Exec:
	cmp	DWORD PTR tv156[ebp], 0
	jne	SHORT $LN369@VCock_Exec

; 1521 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ARRDY_LIGHT, 1);

	push	1
	push	102					; 00000066H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1522 : 		else

	jmp	SHORT $LN368@VCock_Exec
$LN369@VCock_Exec:

; 1523 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ARRDY_LIGHT, 0);

	push	0
	push	102					; 00000066H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN368@VCock_Exec:

; 1524 : 
; 1525 : 		// AR/NWS light
; 1526 : 		if ( cockpitFlightData.IsSet(FlightData::RefuelAR) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	65536					; 00010000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN367@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN380@VCock_Exec
	mov	DWORD PTR tv174[ebp], 1
	jmp	SHORT $LN381@VCock_Exec
$LN380@VCock_Exec:
	mov	DWORD PTR tv174[ebp], 0
$LN381@VCock_Exec:
	cmp	DWORD PTR tv174[ebp], 0
	jne	SHORT $LN367@VCock_Exec

; 1527 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ARNWS_LIGHT, 1);

	push	1
	push	101					; 00000065H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1528 : 		else

	jmp	SHORT $LN366@VCock_Exec
$LN367@VCock_Exec:

; 1529 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ARNWS_LIGHT, 0);

	push	0
	push	101					; 00000065H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN366@VCock_Exec:

; 1530 : 
; 1531 : 		// AR/DISC light
; 1532 : 		if ( cockpitFlightData.IsSet(FlightData::RefuelDSC) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	131072					; 00020000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN365@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN382@VCock_Exec
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN383@VCock_Exec
$LN382@VCock_Exec:
	mov	DWORD PTR tv192[ebp], 0
$LN383@VCock_Exec:
	cmp	DWORD PTR tv192[ebp], 0
	jne	SHORT $LN365@VCock_Exec

; 1533 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ARDISC_LIGHT, 1);

	push	1
	push	103					; 00000067H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1534 : 		else

	jmp	SHORT $LN364@VCock_Exec
$LN365@VCock_Exec:

; 1535 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ARDISC_LIGHT, 0);

	push	0
	push	103					; 00000067H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN364@VCock_Exec:

; 1536 : 
; 1537 : 		// AOA BELOW light
; 1538 : 		if ( cockpitFlightData.IsSet(FlightData::AOABelow) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	16384					; 00004000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN363@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN384@VCock_Exec
	mov	DWORD PTR tv210[ebp], 1
	jmp	SHORT $LN385@VCock_Exec
$LN384@VCock_Exec:
	mov	DWORD PTR tv210[ebp], 0
$LN385@VCock_Exec:
	cmp	DWORD PTR tv210[ebp], 0
	jne	SHORT $LN363@VCock_Exec

; 1539 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOABELOW_LIGHT, 1);

	push	1
	push	105					; 00000069H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1540 : 		else

	jmp	SHORT $LN362@VCock_Exec
$LN363@VCock_Exec:

; 1541 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOABELOW_LIGHT, 0);

	push	0
	push	105					; 00000069H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN362@VCock_Exec:

; 1542 : 
; 1543 : 		// AOA ON light
; 1544 : 		if ( cockpitFlightData.IsSet(FlightData::AOAOn) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	8192					; 00002000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN361@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN386@VCock_Exec
	mov	DWORD PTR tv228[ebp], 1
	jmp	SHORT $LN387@VCock_Exec
$LN386@VCock_Exec:
	mov	DWORD PTR tv228[ebp], 0
$LN387@VCock_Exec:
	cmp	DWORD PTR tv228[ebp], 0
	jne	SHORT $LN361@VCock_Exec

; 1545 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOAON_LIGHT, 1);

	push	1
	push	104					; 00000068H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1546 : 		else

	jmp	SHORT $LN360@VCock_Exec
$LN361@VCock_Exec:

; 1547 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOAON_LIGHT, 0);

	push	0
	push	104					; 00000068H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN360@VCock_Exec:

; 1548 : 
; 1549 : 		// AOA ABOVE light
; 1550 : 		if ( cockpitFlightData.IsSet(FlightData::AOAAbove) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	4096					; 00001000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN359@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN388@VCock_Exec
	mov	DWORD PTR tv246[ebp], 1
	jmp	SHORT $LN389@VCock_Exec
$LN388@VCock_Exec:
	mov	DWORD PTR tv246[ebp], 0
$LN389@VCock_Exec:
	cmp	DWORD PTR tv246[ebp], 0
	jne	SHORT $LN359@VCock_Exec

; 1551 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOAABOVE_LIGHT, 1);

	push	1
	push	106					; 0000006aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1552 : 		else

	jmp	SHORT $LN358@VCock_Exec
$LN359@VCock_Exec:

; 1553 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOAABOVE_LIGHT, 0);

	push	0
	push	106					; 0000006aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN358@VCock_Exec:

; 1554 : 
; 1555 : 		//EYEBROW CAUTION lights
; 1556 : 		//ENG FIRE
; 1557 : 		if ( cockpitFlightData.IsSet(FlightData::ENG_FIRE) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	32					; 00000020H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN357@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN390@VCock_Exec
	mov	DWORD PTR tv264[ebp], 1
	jmp	SHORT $LN391@VCock_Exec
$LN390@VCock_Exec:
	mov	DWORD PTR tv264[ebp], 0
$LN391@VCock_Exec:
	cmp	DWORD PTR tv264[ebp], 0
	jne	SHORT $LN357@VCock_Exec

; 1558 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_ENGFIRE, 1);

	push	1
	push	109					; 0000006dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1559 : 		else

	jmp	SHORT $LN356@VCock_Exec
$LN357@VCock_Exec:

; 1560 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_ENGFIRE, 0);

	push	0
	push	109					; 0000006dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN356@VCock_Exec:

; 1561 : 		//ENGINE
; 1562 : 		if ( cockpitFlightData.IsSet(FlightData::EngineFault) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN355@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN392@VCock_Exec
	mov	DWORD PTR tv282[ebp], 1
	jmp	SHORT $LN393@VCock_Exec
$LN392@VCock_Exec:
	mov	DWORD PTR tv282[ebp], 0
$LN393@VCock_Exec:
	cmp	DWORD PTR tv282[ebp], 0
	jne	SHORT $LN355@VCock_Exec

; 1563 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_ENGINE, 1);

	push	1
	push	110					; 0000006eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1564 : 		else

	jmp	SHORT $LN354@VCock_Exec
$LN355@VCock_Exec:

; 1565 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_ENGINE, 0);

	push	0
	push	110					; 0000006eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN354@VCock_Exec:

; 1566 : 		//HYD/OIL
; 1567 : 		if ( (cockpitFlightData.IsSet(FlightData::HYD) || cockpitFlightData.IsSet(FlightData::OIL)) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	128					; 00000080H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	jne	SHORT $LN352@VCock_Exec
	push	256					; 00000100H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN353@VCock_Exec
$LN352@VCock_Exec:
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN394@VCock_Exec
	mov	DWORD PTR tv304[ebp], 1
	jmp	SHORT $LN395@VCock_Exec
$LN394@VCock_Exec:
	mov	DWORD PTR tv304[ebp], 0
$LN395@VCock_Exec:
	cmp	DWORD PTR tv304[ebp], 0
	jne	SHORT $LN353@VCock_Exec

; 1568 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_HYDOIL, 1);

	push	1
	push	111					; 0000006fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1569 : 		else

	jmp	SHORT $LN351@VCock_Exec
$LN353@VCock_Exec:

; 1570 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_HYDOIL, 0);

	push	0
	push	111					; 0000006fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN351@VCock_Exec:

; 1571 : 		//FLCS
; 1572 : 		if ( (cockpitFlightData.IsSet(FlightData::FltControlSys) || cockpitFlightData.IsSet(FlightData::DUAL)) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	262144					; 00040000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	jne	SHORT $LN349@VCock_Exec
	push	512					; 00000200H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN350@VCock_Exec
$LN349@VCock_Exec:
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN396@VCock_Exec
	mov	DWORD PTR tv326[ebp], 1
	jmp	SHORT $LN397@VCock_Exec
$LN396@VCock_Exec:
	mov	DWORD PTR tv326[ebp], 0
$LN397@VCock_Exec:
	cmp	DWORD PTR tv326[ebp], 0
	jne	SHORT $LN350@VCock_Exec

; 1573 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_FLCS, 1);

	push	1
	push	112					; 00000070H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1574 : 		else

	jmp	SHORT $LN348@VCock_Exec
$LN350@VCock_Exec:

; 1575 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_FLCS, 0);

	push	0
	push	112					; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN348@VCock_Exec:

; 1576 : 		//TO/LDG config
; 1577 : 		if ( cockpitFlightData.IsSet(FlightData::T_L_CFG) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	2048					; 00000800H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN347@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN398@VCock_Exec
	mov	DWORD PTR tv344[ebp], 1
	jmp	SHORT $LN399@VCock_Exec
$LN398@VCock_Exec:
	mov	DWORD PTR tv344[ebp], 0
$LN399@VCock_Exec:
	cmp	DWORD PTR tv344[ebp], 0
	jne	SHORT $LN347@VCock_Exec

; 1578 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_TOLDG, 1);

	push	1
	push	113					; 00000071H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1579 : 		else

	jmp	SHORT $LN346@VCock_Exec
$LN347@VCock_Exec:

; 1580 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_TOLDG, 0);

	push	0
	push	113					; 00000071H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN346@VCock_Exec:

; 1581 : 		//CANOPY
; 1582 : 		int canopyopen;
; 1583 : 		if (SimDriver.GetPlayerAircraft()->IsComplex())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsComplex@AircraftClass@@QAEHXZ	; AircraftClass::IsComplex
	test	eax, eax
	je	SHORT $LN345@VCock_Exec

; 1584 : 			canopyopen = SimDriver.GetPlayerAircraft()->GetDOFValue(COMP_CANOPY_DOF) > 0;

	push	30					; 0000001eH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv5912[ebp]
	movss	xmm0, DWORD PTR tv5912[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN400@VCock_Exec
	mov	DWORD PTR tv369[ebp], 1
	jmp	SHORT $LN401@VCock_Exec
$LN400@VCock_Exec:
	mov	DWORD PTR tv369[ebp], 0
$LN401@VCock_Exec:
	mov	ecx, DWORD PTR tv369[ebp]
	mov	DWORD PTR _canopyopen$24[ebp], ecx

; 1585 : 		else

	jmp	SHORT $LN344@VCock_Exec
$LN345@VCock_Exec:

; 1586 : 			canopyopen = SimDriver.GetPlayerAircraft()->GetDOFValue(SIMP_CANOPY_DOF) > 0;

	push	23					; 00000017H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetDOFValue@SimMoverClass@@QAEMH@Z	; SimMoverClass::GetDOFValue
	fstp	DWORD PTR tv5918[ebp]
	movss	xmm0, DWORD PTR tv5918[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN402@VCock_Exec
	mov	DWORD PTR tv380[ebp], 1
	jmp	SHORT $LN403@VCock_Exec
$LN402@VCock_Exec:
	mov	DWORD PTR tv380[ebp], 0
$LN403@VCock_Exec:
	mov	edx, DWORD PTR tv380[ebp]
	mov	DWORD PTR _canopyopen$24[ebp], edx
$LN344@VCock_Exec:

; 1587 : 		if ( (cockpitFlightData.IsSet(FlightData::CAN) || cockpitFlightData.IsSet(FlightData::OXY_LOW) || canopyopen) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	1024					; 00000400H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	jne	SHORT $LN342@VCock_Exec
	push	8388608					; 00800000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	jne	SHORT $LN342@VCock_Exec
	cmp	DWORD PTR _canopyopen$24[ebp], 0
	je	SHORT $LN343@VCock_Exec
$LN342@VCock_Exec:
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN404@VCock_Exec
	mov	DWORD PTR tv394[ebp], 1
	jmp	SHORT $LN405@VCock_Exec
$LN404@VCock_Exec:
	mov	DWORD PTR tv394[ebp], 0
$LN405@VCock_Exec:
	cmp	DWORD PTR tv394[ebp], 0
	jne	SHORT $LN343@VCock_Exec

; 1588 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_CANOPY, 1);

	push	1
	push	114					; 00000072H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1589 : 		else

	jmp	SHORT $LN341@VCock_Exec
$LN343@VCock_Exec:

; 1590 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_CANOPY, 0);

	push	0
	push	114					; 00000072H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN341@VCock_Exec:

; 1591 : 		//TF-FAIL
; 1592 : 		if ( cockpitFlightData.IsSet(FlightData::TF) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	push	2
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	test	eax, eax
	je	SHORT $LN340@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN406@VCock_Exec
	mov	DWORD PTR tv412[ebp], 1
	jmp	SHORT $LN407@VCock_Exec
$LN406@VCock_Exec:
	mov	DWORD PTR tv412[ebp], 0
$LN407@VCock_Exec:
	cmp	DWORD PTR tv412[ebp], 0
	jne	SHORT $LN340@VCock_Exec

; 1593 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_TFFAIL, 1);

	push	1
	push	115					; 00000073H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1594 : 		else

	jmp	SHORT $LN339@VCock_Exec
$LN340@VCock_Exec:

; 1595 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EYEBROW_TFFAIL, 0);

	push	0
	push	115					; 00000073H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN339@VCock_Exec:

; 1596 : 
; 1597 : 		//Interior lights
; 1598 : 		// COBRA - RED - Canopy does not forces interior light... and needs no power up...
; 1599 : 		if (SimDriver.GetPlayerAircraft()->GetInteriorLight() )

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
	test	eax, eax
	je	SHORT $LN338@VCock_Exec

; 1600 : 		{
; 1601 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INTERIOR_LIGHTS, 1);

	push	1
	push	127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1602 : 			SimDriver.GetPlayerAircraft()->SetSwitch( COMP_3DPIT_INTERIOR_LIGHTS, 1);

	push	1
	push	127					; 0000007fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1603 : 			SimDriver.GetPlayerAircraft()->SetAcStatusBits(AircraftClass::ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 1604 : 		}
; 1605 : 		else

	jmp	SHORT $LN337@VCock_Exec
$LN338@VCock_Exec:

; 1606 : 		{
; 1607 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INTERIOR_LIGHTS, 0);

	push	0
	push	127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1608 : 			SimDriver.GetPlayerAircraft()->SetSwitch( COMP_3DPIT_INTERIOR_LIGHTS, 0);

	push	0
	push	127					; 0000007fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1609 : 			SimDriver.GetPlayerAircraft()->ClearAcStatusBits(AircraftClass::ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN337@VCock_Exec:

; 1610 : 		}
; 1611 : 		//Instrument lights
; 1612 : 		if ((SimDriver.GetPlayerAircraft()->GetInstrumentLight()) && !SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff )

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
	test	eax, eax
	je	SHORT $LN336@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN408@VCock_Exec
	mov	DWORD PTR tv470[ebp], 1
	jmp	SHORT $LN409@VCock_Exec
$LN408@VCock_Exec:
	mov	DWORD PTR tv470[ebp], 0
$LN409@VCock_Exec:
	cmp	DWORD PTR tv470[ebp], 0
	jne	SHORT $LN336@VCock_Exec

; 1613 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INSTRUMENT_LIGHTS, 1);

	push	1
	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1614 : 		else

	jmp	SHORT $LN335@VCock_Exec
$LN336@VCock_Exec:

; 1615 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INSTRUMENT_LIGHTS, 0);

	push	0
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN335@VCock_Exec:

; 1616 : 
; 1617 : 		//******************************************
; 1618 : 		// New 3D cockpit Lights
; 1619 : 		//******************************************
; 1620 : 		// Caution Panel lights
; 1621 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN410@VCock_Exec
	mov	DWORD PTR tv484[ebp], 1
	jmp	SHORT $LN411@VCock_Exec
$LN410@VCock_Exec:
	mov	DWORD PTR tv484[ebp], 0
$LN411@VCock_Exec:
	cmp	DWORD PTR tv484[ebp], 0
	jne	SHORT $LN334@VCock_Exec

; 1622 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_1, SimDriver.GetPlayerAircraft()->mFaults->GetFault(flt_cont_fault));

	push	10					; 0000000aH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN334@VCock_Exec:

; 1623 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN412@VCock_Exec
	mov	DWORD PTR tv500[ebp], 1
	jmp	SHORT $LN413@VCock_Exec
$LN412@VCock_Exec:
	mov	DWORD PTR tv500[ebp], 0
$LN413@VCock_Exec:
	cmp	DWORD PTR tv500[ebp], 0
	jne	SHORT $LN333@VCock_Exec

; 1624 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_2, SimDriver.GetPlayerAircraft()->mFaults->GetFault(elec_fault));

	push	34					; 00000022H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	224					; 000000e0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN333@VCock_Exec:

; 1625 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN414@VCock_Exec
	mov	DWORD PTR tv516[ebp], 1
	jmp	SHORT $LN415@VCock_Exec
$LN414@VCock_Exec:
	mov	DWORD PTR tv516[ebp], 0
$LN415@VCock_Exec:
	cmp	DWORD PTR tv516[ebp], 0
	jne	SHORT $LN332@VCock_Exec

; 1626 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_3, SimDriver.GetPlayerAircraft()->mFaults->GetFault(probeheat_fault));

	push	27					; 0000001bH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	225					; 000000e1H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN332@VCock_Exec:

; 1627 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN416@VCock_Exec
	mov	DWORD PTR tv532[ebp], 1
	jmp	SHORT $LN417@VCock_Exec
$LN416@VCock_Exec:
	mov	DWORD PTR tv532[ebp], 0
$LN417@VCock_Exec:
	cmp	DWORD PTR tv532[ebp], 0
	jne	SHORT $LN331@VCock_Exec

; 1628 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_4, SimDriver.GetPlayerAircraft()->mFaults->GetFault(lef_fault)); // LEF sub'ed for C ADC ????

	push	35					; 00000023H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	226					; 000000e2H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN331@VCock_Exec:

; 1629 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN418@VCock_Exec
	mov	DWORD PTR tv548[ebp], 1
	jmp	SHORT $LN419@VCock_Exec
$LN418@VCock_Exec:
	mov	DWORD PTR tv548[ebp], 0
$LN419@VCock_Exec:
	cmp	DWORD PTR tv548[ebp], 0
	jne	SHORT $LN330@VCock_Exec

; 1630 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_5, SimDriver.GetPlayerAircraft()->mFaults->GetFault(stores_config_fault));

	push	28					; 0000001cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	227					; 000000e3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN330@VCock_Exec:

; 1631 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN420@VCock_Exec
	mov	DWORD PTR tv564[ebp], 1
	jmp	SHORT $LN421@VCock_Exec
$LN420@VCock_Exec:
	mov	DWORD PTR tv564[ebp], 0
$LN421@VCock_Exec:
	cmp	DWORD PTR tv564[ebp], 0
	jne	SHORT $LN329@VCock_Exec

; 1632 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_6, SimDriver.GetPlayerAircraft()->mFaults->GetFault(lastFault)); // no act sub'ed for AFT NOT ENGAGED ???

	push	37					; 00000025H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	228					; 000000e4H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN329@VCock_Exec:

; 1633 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN422@VCock_Exec
	mov	DWORD PTR tv580[ebp], 1
	jmp	SHORT $LN423@VCock_Exec
$LN422@VCock_Exec:
	mov	DWORD PTR tv580[ebp], 0
$LN423@VCock_Exec:
	cmp	DWORD PTR tv580[ebp], 0
	jne	SHORT $LN328@VCock_Exec

; 1634 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_7, SimDriver.GetPlayerAircraft()->mFaults->GetFault(fwd_fuel_low_fault));

	push	22					; 00000016H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	229					; 000000e5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN328@VCock_Exec:

; 1635 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN424@VCock_Exec
	mov	DWORD PTR tv596[ebp], 1
	jmp	SHORT $LN425@VCock_Exec
$LN424@VCock_Exec:
	mov	DWORD PTR tv596[ebp], 0
$LN425@VCock_Exec:
	cmp	DWORD PTR tv596[ebp], 0
	jne	SHORT $LN327@VCock_Exec

; 1636 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL1_8, SimDriver.GetPlayerAircraft()->mFaults->GetFault(aft_fuel_low_fault));

	push	23					; 00000017H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	230					; 000000e6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN327@VCock_Exec:

; 1637 : 
; 1638 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN426@VCock_Exec
	mov	DWORD PTR tv612[ebp], 1
	jmp	SHORT $LN427@VCock_Exec
$LN426@VCock_Exec:
	mov	DWORD PTR tv612[ebp], 0
$LN427@VCock_Exec:
	cmp	DWORD PTR tv612[ebp], 0
	jne	SHORT $LN326@VCock_Exec

; 1639 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_1, cockpitFlightData.IsSet(FlightData::EngineFault));

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	231					; 000000e7H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN326@VCock_Exec:

; 1640 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN428@VCock_Exec
	mov	DWORD PTR tv625[ebp], 1
	jmp	SHORT $LN429@VCock_Exec
$LN428@VCock_Exec:
	mov	DWORD PTR tv625[ebp], 0
$LN429@VCock_Exec:
	cmp	DWORD PTR tv625[ebp], 0
	jne	SHORT $LN325@VCock_Exec

; 1641 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_2, SimDriver.GetPlayerAircraft()->mFaults->GetFault(sec_fault));

	push	26					; 0000001aH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	232					; 000000e8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN325@VCock_Exec:

; 1642 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN430@VCock_Exec
	mov	DWORD PTR tv641[ebp], 1
	jmp	SHORT $LN431@VCock_Exec
$LN430@VCock_Exec:
	mov	DWORD PTR tv641[ebp], 0
$LN431@VCock_Exec:
	cmp	DWORD PTR tv641[ebp], 0
	jne	SHORT $LN324@VCock_Exec

; 1643 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_3, SimDriver.GetPlayerAircraft()->mFaults->GetFault(fueloil_hot_fault));

	push	30					; 0000001eH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	233					; 000000e9H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN324@VCock_Exec:

; 1644 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN432@VCock_Exec
	mov	DWORD PTR tv657[ebp], 1
	jmp	SHORT $LN433@VCock_Exec
$LN432@VCock_Exec:
	mov	DWORD PTR tv657[ebp], 0
$LN433@VCock_Exec:
	cmp	DWORD PTR tv657[ebp], 0
	jne	SHORT $LN323@VCock_Exec

; 1645 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_4, SimDriver.GetPlayerAircraft()->mFaults->GetFault(le_flaps_fault)); // Flaps fault sub'ed for INLET ICING ???

	push	11					; 0000000bH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	234					; 000000eaH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN323@VCock_Exec:

; 1646 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN434@VCock_Exec
	mov	DWORD PTR tv673[ebp], 1
	jmp	SHORT $LN435@VCock_Exec
$LN434@VCock_Exec:
	mov	DWORD PTR tv673[ebp], 0
$LN435@VCock_Exec:
	cmp	DWORD PTR tv673[ebp], 0
	jne	SHORT $LN322@VCock_Exec

; 1647 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_5, SimDriver.GetPlayerAircraft()->mFaults->GetFault(overheat_fault));

	push	12					; 0000000cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	235					; 000000ebH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN322@VCock_Exec:

; 1648 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN436@VCock_Exec
	mov	DWORD PTR tv689[ebp], 1
	jmp	SHORT $LN437@VCock_Exec
$LN436@VCock_Exec:
	mov	DWORD PTR tv689[ebp], 0
$LN437@VCock_Exec:
	cmp	DWORD PTR tv689[ebp], 0
	jne	SHORT $LN321@VCock_Exec

; 1649 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_6, SimDriver.GetPlayerAircraft()->mFaults->GetFault(ecm_fault)); // ecm fault sub'ed for ECC ???

	push	17					; 00000011H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	236					; 000000ecH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN321@VCock_Exec:

; 1650 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN438@VCock_Exec
	mov	DWORD PTR tv705[ebp], 1
	jmp	SHORT $LN439@VCock_Exec
$LN438@VCock_Exec:
	mov	DWORD PTR tv705[ebp], 0
$LN439@VCock_Exec:
	cmp	DWORD PTR tv705[ebp], 0
	jne	SHORT $LN320@VCock_Exec

; 1651 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_7, SimDriver.GetPlayerAircraft()->mFaults->GetFault(buc_fault));

	push	29					; 0000001dH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	237					; 000000edH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN320@VCock_Exec:

; 1652 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN440@VCock_Exec
	mov	DWORD PTR tv721[ebp], 1
	jmp	SHORT $LN441@VCock_Exec
$LN440@VCock_Exec:
	mov	DWORD PTR tv721[ebp], 0
$LN441@VCock_Exec:
	cmp	DWORD PTR tv721[ebp], 0
	jne	SHORT $LN319@VCock_Exec

; 1653 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL2_8, SimDriver.GetPlayerAircraft()->mFaults->GetFault(fuel_low_fault)); // Fuel Low fault sub'ed for blank

	push	13					; 0000000dH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	238					; 000000eeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN319@VCock_Exec:

; 1654 : 
; 1655 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN442@VCock_Exec
	mov	DWORD PTR tv737[ebp], 1
	jmp	SHORT $LN443@VCock_Exec
$LN442@VCock_Exec:
	mov	DWORD PTR tv737[ebp], 0
$LN443@VCock_Exec:
	cmp	DWORD PTR tv737[ebp], 0
	jne	SHORT $LN318@VCock_Exec

; 1656 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_1, SimDriver.GetPlayerAircraft()->mFaults->GetFault(avionics_fault));

	push	14					; 0000000eH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	239					; 000000efH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN318@VCock_Exec:

; 1657 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN444@VCock_Exec
	mov	DWORD PTR tv753[ebp], 1
	jmp	SHORT $LN445@VCock_Exec
$LN444@VCock_Exec:
	mov	DWORD PTR tv753[ebp], 0
$LN445@VCock_Exec:
	cmp	DWORD PTR tv753[ebp], 0
	jne	SHORT $LN317@VCock_Exec

; 1658 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_2, SimDriver.GetPlayerAircraft()->mFaults->GetFault(equip_host_fault));

	push	33					; 00000021H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	240					; 000000f0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN317@VCock_Exec:

; 1659 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN446@VCock_Exec
	mov	DWORD PTR tv769[ebp], 1
	jmp	SHORT $LN447@VCock_Exec
$LN446@VCock_Exec:
	mov	DWORD PTR tv769[ebp], 0
$LN447@VCock_Exec:
	cmp	DWORD PTR tv769[ebp], 0
	jne	SHORT $LN316@VCock_Exec

; 1660 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_3, SimDriver.GetPlayerAircraft()->mFaults->GetFault(radar_alt_fault));

	push	15					; 0000000fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	241					; 000000f1H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN316@VCock_Exec:

; 1661 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN448@VCock_Exec
	mov	DWORD PTR tv785[ebp], 1
	jmp	SHORT $LN449@VCock_Exec
$LN448@VCock_Exec:
	mov	DWORD PTR tv785[ebp], 0
$LN449@VCock_Exec:
	cmp	DWORD PTR tv785[ebp], 0
	jne	SHORT $LN315@VCock_Exec

; 1662 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_4, SimDriver.GetPlayerAircraft()->mFaults->GetFault(iff_fault));

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	242					; 000000f2H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN315@VCock_Exec:

; 1663 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN450@VCock_Exec
	mov	DWORD PTR tv801[ebp], 1
	jmp	SHORT $LN451@VCock_Exec
$LN450@VCock_Exec:
	mov	DWORD PTR tv801[ebp], 0
$LN451@VCock_Exec:
	cmp	DWORD PTR tv801[ebp], 0
	jne	SHORT $LN314@VCock_Exec

; 1664 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_5, SimDriver.GetPlayerAircraft()->mFaults->GetFault(lastFault)); // no act sub'ed for NUCLEAR ???

	push	37					; 00000025H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	243					; 000000f3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN314@VCock_Exec:

; 1665 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN452@VCock_Exec
	mov	DWORD PTR tv817[ebp], 1
	jmp	SHORT $LN453@VCock_Exec
$LN452@VCock_Exec:
	mov	DWORD PTR tv817[ebp], 0
$LN453@VCock_Exec:
	cmp	DWORD PTR tv817[ebp], 0
	jne	SHORT $LN313@VCock_Exec

; 1666 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_6, SimDriver.GetPlayerAircraft()->mFaults->GetFault(fuel_trapped)); // Fuel trapped fault sub'ed for ECC ???

	push	24					; 00000018H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	244					; 000000f4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN313@VCock_Exec:

; 1667 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN454@VCock_Exec
	mov	DWORD PTR tv833[ebp], 1
	jmp	SHORT $LN455@VCock_Exec
$LN454@VCock_Exec:
	mov	DWORD PTR tv833[ebp], 0
$LN455@VCock_Exec:
	cmp	DWORD PTR tv833[ebp], 0
	jne	SHORT $LN312@VCock_Exec

; 1668 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_7, SimDriver.GetPlayerAircraft()->mFaults->GetFault(fuel_home)); // Fuel "Bingo" fault sub'ed for blank

	push	25					; 00000019H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	245					; 000000f5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN312@VCock_Exec:

; 1669 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN456@VCock_Exec
	mov	DWORD PTR tv849[ebp], 1
	jmp	SHORT $LN457@VCock_Exec
$LN456@VCock_Exec:
	mov	DWORD PTR tv849[ebp], 0
$LN457@VCock_Exec:
	cmp	DWORD PTR tv849[ebp], 0
	jne	SHORT $LN311@VCock_Exec

; 1670 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL3_8, SimDriver.GetPlayerAircraft()->mFaults->GetFault(lastFault)); // blank

	push	37					; 00000025H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	246					; 000000f6H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN311@VCock_Exec:

; 1671 : 
; 1672 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN458@VCock_Exec
	mov	DWORD PTR tv865[ebp], 1
	jmp	SHORT $LN459@VCock_Exec
$LN458@VCock_Exec:
	mov	DWORD PTR tv865[ebp], 0
$LN459@VCock_Exec:
	cmp	DWORD PTR tv865[ebp], 0
	jne	SHORT $LN310@VCock_Exec

; 1673 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_1, SimDriver.GetPlayerAircraft()->mFaults->GetFault(seat_notarmed_fault));

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	247					; 000000f7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN310@VCock_Exec:

; 1674 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN460@VCock_Exec
	mov	DWORD PTR tv881[ebp], 1
	jmp	SHORT $LN461@VCock_Exec
$LN460@VCock_Exec:
	mov	DWORD PTR tv881[ebp], 0
$LN461@VCock_Exec:
	cmp	DWORD PTR tv881[ebp], 0
	jne	SHORT $LN309@VCock_Exec

; 1675 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_2, SimDriver.GetPlayerAircraft()->mFaults->GetFault(nws_fault));

	push	19					; 00000013H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	248					; 000000f8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN309@VCock_Exec:

; 1676 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN462@VCock_Exec
	mov	DWORD PTR tv897[ebp], 1
	jmp	SHORT $LN463@VCock_Exec
$LN462@VCock_Exec:
	mov	DWORD PTR tv897[ebp], 0
$LN463@VCock_Exec:
	cmp	DWORD PTR tv897[ebp], 0
	jne	SHORT $LN308@VCock_Exec

; 1677 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_3, SimDriver.GetPlayerAircraft()->mFaults->GetFault(anti_skid_fault));

	push	31					; 0000001fH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	249					; 000000f9H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN308@VCock_Exec:

; 1678 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN464@VCock_Exec
	mov	DWORD PTR tv913[ebp], 1
	jmp	SHORT $LN465@VCock_Exec
$LN464@VCock_Exec:
	mov	DWORD PTR tv913[ebp], 0
$LN465@VCock_Exec:
	cmp	DWORD PTR tv913[ebp], 0
	jne	SHORT $LN307@VCock_Exec

; 1679 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_4, SimDriver.GetPlayerAircraft()->mFaults->GetFault(hook_fault));

	push	18					; 00000012H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	250					; 000000faH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN307@VCock_Exec:

; 1680 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN466@VCock_Exec
	mov	DWORD PTR tv929[ebp], 1
	jmp	SHORT $LN467@VCock_Exec
$LN466@VCock_Exec:
	mov	DWORD PTR tv929[ebp], 0
$LN467@VCock_Exec:
	cmp	DWORD PTR tv929[ebp], 0
	jne	SHORT $LN306@VCock_Exec

; 1681 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_5, SimDriver.GetPlayerAircraft()->mFaults->GetFault(oxy_low_fault));

	push	21					; 00000015H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	251					; 000000fbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN306@VCock_Exec:

; 1682 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN468@VCock_Exec
	mov	DWORD PTR tv945[ebp], 1
	jmp	SHORT $LN469@VCock_Exec
$LN468@VCock_Exec:
	mov	DWORD PTR tv945[ebp], 0
$LN469@VCock_Exec:
	cmp	DWORD PTR tv945[ebp], 0
	jne	SHORT $LN305@VCock_Exec

; 1683 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_6, SimDriver.GetPlayerAircraft()->mFaults->GetFault(cabin_press_fault));

	push	20					; 00000014H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	252					; 000000fcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN305@VCock_Exec:

; 1684 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN470@VCock_Exec
	mov	DWORD PTR tv961[ebp], 1
	jmp	SHORT $LN471@VCock_Exec
$LN470@VCock_Exec:
	mov	DWORD PTR tv961[ebp], 0
$LN471@VCock_Exec:
	cmp	DWORD PTR tv961[ebp], 0
	jne	SHORT $LN304@VCock_Exec

; 1685 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_7, SimDriver.GetPlayerAircraft()->mFaults->GetFault(lastFault)); // blank

	push	37					; 00000025H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	253					; 000000fdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN304@VCock_Exec:

; 1686 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN472@VCock_Exec
	mov	DWORD PTR tv977[ebp], 1
	jmp	SHORT $LN473@VCock_Exec
$LN472@VCock_Exec:
	mov	DWORD PTR tv977[ebp], 0
$LN473@VCock_Exec:
	cmp	DWORD PTR tv977[ebp], 0
	jne	SHORT $LN303@VCock_Exec

; 1687 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_FAULT_COL4_8, SimDriver.GetPlayerAircraft()->mFaults->GetFault(lastFault)); // blank

	push	37					; 00000025H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	push	eax
	push	254					; 000000feH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN303@VCock_Exec:

; 1688 : 
; 1689 : 		// Indicator lights
; 1690 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN474@VCock_Exec
	mov	DWORD PTR tv993[ebp], 1
	jmp	SHORT $LN475@VCock_Exec
$LN474@VCock_Exec:
	mov	DWORD PTR tv993[ebp], 0
$LN475@VCock_Exec:
	cmp	DWORD PTR tv993[ebp], 0
	jne	SHORT $LN302@VCock_Exec

; 1691 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_TFR_STBY, cockpitFlightData.IsSet(FlightData::TFR_STBY));

	push	-2147483648				; 80000000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	84					; 00000054H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN302@VCock_Exec:

; 1692 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN476@VCock_Exec
	mov	DWORD PTR tv1006[ebp], 1
	jmp	SHORT $LN477@VCock_Exec
$LN476@VCock_Exec:
	mov	DWORD PTR tv1006[ebp], 0
$LN477@VCock_Exec:
	cmp	DWORD PTR tv1006[ebp], 0
	jne	SHORT $LN301@VCock_Exec

; 1693 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ECM_PWR, cockpitFlightData.IsSet(FlightData::EcmPwr));

	push	65536					; 00010000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	85					; 00000055H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN301@VCock_Exec:

; 1694 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN478@VCock_Exec
	mov	DWORD PTR tv1019[ebp], 1
	jmp	SHORT $LN479@VCock_Exec
$LN478@VCock_Exec:
	mov	DWORD PTR tv1019[ebp], 0
$LN479@VCock_Exec:
	cmp	DWORD PTR tv1019[ebp], 0
	jne	SHORT $LN300@VCock_Exec

; 1695 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ECM_FAIL, cockpitFlightData.IsSet(FlightData::EcmFail));

	push	131072					; 00020000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	86					; 00000056H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN300@VCock_Exec:

; 1696 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN480@VCock_Exec
	mov	DWORD PTR tv1032[ebp], 1
	jmp	SHORT $LN481@VCock_Exec
$LN480@VCock_Exec:
	mov	DWORD PTR tv1032[ebp], 0
$LN481@VCock_Exec:
	cmp	DWORD PTR tv1032[ebp], 0
	jne	SHORT $LN299@VCock_Exec

; 1697 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EPU_ON, cockpitFlightData.IsSet(FlightData::EPUOn));

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	87					; 00000057H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN299@VCock_Exec:

; 1698 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN482@VCock_Exec
	mov	DWORD PTR tv1045[ebp], 1
	jmp	SHORT $LN483@VCock_Exec
$LN482@VCock_Exec:
	mov	DWORD PTR tv1045[ebp], 0
$LN483@VCock_Exec:
	cmp	DWORD PTR tv1045[ebp], 0
	jne	SHORT $LN298@VCock_Exec

; 1699 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_JFS_ON, cockpitFlightData.IsSet(FlightData::JFSOn));

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN298@VCock_Exec:

; 1700 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN484@VCock_Exec
	mov	DWORD PTR tv1058[ebp], 1
	jmp	SHORT $LN485@VCock_Exec
$LN484@VCock_Exec:
	mov	DWORD PTR tv1058[ebp], 0
$LN485@VCock_Exec:
	cmp	DWORD PTR tv1058[ebp], 0
	jne	SHORT $LN297@VCock_Exec

; 1701 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EPU_HYD, cockpitFlightData.IsSet(FlightData::Hydrazine));

	push	256					; 00000100H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	89					; 00000059H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN297@VCock_Exec:

; 1702 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN486@VCock_Exec
	mov	DWORD PTR tv1071[ebp], 1
	jmp	SHORT $LN487@VCock_Exec
$LN486@VCock_Exec:
	mov	DWORD PTR tv1071[ebp], 0
$LN487@VCock_Exec:
	cmp	DWORD PTR tv1071[ebp], 0
	jne	SHORT $LN296@VCock_Exec

; 1703 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EPU_AIR, cockpitFlightData.IsSet(FlightData::Air));

	push	512					; 00000200H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	90					; 0000005aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN296@VCock_Exec:

; 1704 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN488@VCock_Exec
	mov	DWORD PTR tv1084[ebp], 1
	jmp	SHORT $LN489@VCock_Exec
$LN488@VCock_Exec:
	mov	DWORD PTR tv1084[ebp], 0
$LN489@VCock_Exec:
	cmp	DWORD PTR tv1084[ebp], 0
	jne	SHORT $LN295@VCock_Exec

; 1705 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_FLCSPGM, cockpitFlightData.IsSet(FlightData::FlcsPmg));

	push	1
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	91					; 0000005bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN295@VCock_Exec:

; 1706 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN490@VCock_Exec
	mov	DWORD PTR tv1097[ebp], 1
	jmp	SHORT $LN491@VCock_Exec
$LN490@VCock_Exec:
	mov	DWORD PTR tv1097[ebp], 0
$LN491@VCock_Exec:
	cmp	DWORD PTR tv1097[ebp], 0
	jne	SHORT $LN294@VCock_Exec

; 1707 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_MAINGEN, cockpitFlightData.IsSet(FlightData::MainGen));

	push	2
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	92					; 0000005cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN294@VCock_Exec:

; 1708 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN492@VCock_Exec
	mov	DWORD PTR tv1110[ebp], 1
	jmp	SHORT $LN493@VCock_Exec
$LN492@VCock_Exec:
	mov	DWORD PTR tv1110[ebp], 0
$LN493@VCock_Exec:
	cmp	DWORD PTR tv1110[ebp], 0
	jne	SHORT $LN293@VCock_Exec

; 1709 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_STBYGEN, cockpitFlightData.IsSet(FlightData::StbyGen));

	push	4
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	93					; 0000005dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN293@VCock_Exec:

; 1710 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN494@VCock_Exec
	mov	DWORD PTR tv1123[ebp], 1
	jmp	SHORT $LN495@VCock_Exec
$LN494@VCock_Exec:
	mov	DWORD PTR tv1123[ebp], 0
$LN495@VCock_Exec:
	cmp	DWORD PTR tv1123[ebp], 0
	jne	SHORT $LN292@VCock_Exec

; 1711 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_EPUGEN, cockpitFlightData.IsSet(FlightData::EpuGen));

	push	8
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	94					; 0000005eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN292@VCock_Exec:

; 1712 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN496@VCock_Exec
	mov	DWORD PTR tv1136[ebp], 1
	jmp	SHORT $LN497@VCock_Exec
$LN496@VCock_Exec:
	mov	DWORD PTR tv1136[ebp], 0
$LN497@VCock_Exec:
	cmp	DWORD PTR tv1136[ebp], 0
	jne	SHORT $LN291@VCock_Exec

; 1713 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_EPUPMG, cockpitFlightData.IsSet(FlightData::EpuPmg));

	push	16					; 00000010H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	95					; 0000005fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN291@VCock_Exec:

; 1714 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN498@VCock_Exec
	mov	DWORD PTR tv1149[ebp], 1
	jmp	SHORT $LN499@VCock_Exec
$LN498@VCock_Exec:
	mov	DWORD PTR tv1149[ebp], 0
$LN499@VCock_Exec:
	cmp	DWORD PTR tv1149[ebp], 0
	jne	SHORT $LN290@VCock_Exec

; 1715 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_TOFLCS, cockpitFlightData.IsSet(FlightData::ToFlcs));

	push	32					; 00000020H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	96					; 00000060H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN290@VCock_Exec:

; 1716 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN500@VCock_Exec
	mov	DWORD PTR tv1162[ebp], 1
	jmp	SHORT $LN501@VCock_Exec
$LN500@VCock_Exec:
	mov	DWORD PTR tv1162[ebp], 0
$LN501@VCock_Exec:
	cmp	DWORD PTR tv1162[ebp], 0
	jne	SHORT $LN289@VCock_Exec

; 1717 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_FLCSRLY, cockpitFlightData.IsSet(FlightData::FlcsRly));

	push	64					; 00000040H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	97					; 00000061H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN289@VCock_Exec:

; 1718 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN502@VCock_Exec
	mov	DWORD PTR tv1175[ebp], 1
	jmp	SHORT $LN503@VCock_Exec
$LN502@VCock_Exec:
	mov	DWORD PTR tv1175[ebp], 0
$LN503@VCock_Exec:
	cmp	DWORD PTR tv1175[ebp], 0
	jne	SHORT $LN288@VCock_Exec

; 1719 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PWR_BATFAIL, cockpitFlightData.IsSet(FlightData::BatFail));

	push	128					; 00000080H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSet@FlightData@@QAEHH@Z		; FlightData::IsSet
	push	eax
	push	98					; 00000062H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN288@VCock_Exec:

; 1720 : 		if (!SimDriver.GetPlayerAircraft()->mainPower == AircraftClass::MainPowerOff)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1484], 0
	jne	SHORT $LN504@VCock_Exec
	mov	DWORD PTR tv1188[ebp], 1
	jmp	SHORT $LN505@VCock_Exec
$LN504@VCock_Exec:
	mov	DWORD PTR tv1188[ebp], 0
$LN505@VCock_Exec:
	cmp	DWORD PTR tv1188[ebp], 0
	jne	SHORT $LN287@VCock_Exec

; 1721 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AVTR_ON, SimDriver.AVTROn());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?AVTROn@SimulationDriver@@QAEHXZ	; SimulationDriver::AVTROn
	push	eax
	push	99					; 00000063H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN287@VCock_Exec:

; 1722 : 
; 1723 : 		//******************************************
; 1724 : 		// INSTRUMNETS
; 1725 : 		//******************************************
; 1726 : 
; 1727 : 		//ADI and BACKUP ADI stuff
; 1728 : 		if(g_bRealisticAvionics && g_bINS)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN286@VCock_Exec
	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	$LN286@VCock_Exec

; 1729 : 		{
; 1730 : 			if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::BUP_ADI_OFF_IN))

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN285@VCock_Exec

; 1731 : 			{
; 1732 : 				//make a check for the BUP ADI energy here when ready
; 1733 : 				BUPADIPitch3d = cockpitFlightData.pitch;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	movss	DWORD PTR _BUPADIPitch3d, xmm0

; 1734 : 				BUPADIRoll3d	= cockpitFlightData.roll;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR _BUPADIRoll3d, xmm0

; 1735 : 				LastBUPPitch3d = BUPADIPitch3d;

	movss	xmm0, DWORD PTR _BUPADIPitch3d
	movss	DWORD PTR _LastBUPPitch3d, xmm0

; 1736 : 				LastBUPRoll3d = BUPADIRoll3d;

	movss	xmm0, DWORD PTR _BUPADIRoll3d
	movss	DWORD PTR _LastBUPRoll3d, xmm0

; 1737 : 
; 1738 : 				//set BUP ADI OFF mark off
; 1739 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_BACKUP_ADI_OFFMARK, 0);

	push	0
	push	100					; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1740 : 			}
; 1741 : 			else

	jmp	SHORT $LN284@VCock_Exec
$LN285@VCock_Exec:

; 1742 : 			{
; 1743 : 				BUPADIPitch3d = LastBUPPitch3d;

	movss	xmm0, DWORD PTR _LastBUPPitch3d
	movss	DWORD PTR _BUPADIPitch3d, xmm0

; 1744 : 				BUPADIRoll3d = LastBUPRoll3d;

	movss	xmm0, DWORD PTR _LastBUPRoll3d
	movss	DWORD PTR _BUPADIRoll3d, xmm0

; 1745 : 
; 1746 : 				//set BUP ADI OFF mark on
; 1747 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_BACKUP_ADI_OFFMARK, 1);

	push	1
	push	100					; 00000064H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN284@VCock_Exec:

; 1748 : 			}	
; 1749 : 
; 1750 : 			if(!SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_ADI_OFF_IN))

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN283@VCock_Exec

; 1751 : 			{
; 1752 : 				//stay where you currently are
; 1753 : 				ADIPitch3d = LastMainADIPitch3d;

	movss	xmm0, DWORD PTR _LastMainADIPitch3d
	movss	DWORD PTR _ADIPitch3d, xmm0

; 1754 : 				ADIRoll3d = LastMainADIRoll3d;

	movss	xmm0, DWORD PTR _LastMainADIRoll3d
	movss	DWORD PTR _ADIRoll3d, xmm0

; 1755 : 			}
; 1756 : 			else

	jmp	SHORT $LN282@VCock_Exec
$LN283@VCock_Exec:

; 1757 : 			{
; 1758 : 				ADIPitch3d	= cockpitFlightData.pitch;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	movss	DWORD PTR _ADIPitch3d, xmm0

; 1759 : 				ADIRoll3d	= cockpitFlightData.roll;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR _ADIRoll3d, xmm0

; 1760 : 				LastMainADIPitch3d = ADIPitch3d;

	movss	xmm0, DWORD PTR _ADIPitch3d
	movss	DWORD PTR _LastMainADIPitch3d, xmm0

; 1761 : 				LastMainADIRoll3d = ADIRoll3d;

	movss	xmm0, DWORD PTR _ADIRoll3d
	movss	DWORD PTR _LastMainADIRoll3d, xmm0
$LN282@VCock_Exec:

; 1762 : 			}
; 1763 : 
; 1764 : 		}
; 1765 : 		else

	jmp	SHORT $LN281@VCock_Exec
$LN286@VCock_Exec:

; 1766 : 		{
; 1767 : 			ADIPitch3d = cockpitFlightData.pitch;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	movss	DWORD PTR _ADIPitch3d, xmm0

; 1768 : 			ADIRoll3d = cockpitFlightData.roll;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR _ADIRoll3d, xmm0

; 1769 : 			BUPADIPitch3d = ADIPitch3d;

	movss	xmm0, DWORD PTR _ADIPitch3d
	movss	DWORD PTR _BUPADIPitch3d, xmm0

; 1770 : 			BUPADIRoll3d = ADIRoll3d;

	movss	xmm0, DWORD PTR _ADIRoll3d
	movss	DWORD PTR _BUPADIRoll3d, xmm0
$LN281@VCock_Exec:

; 1771 : 		}
; 1772 : 
; 1773 : 		//MAIN ADI ball
; 1774 : 		//Roll
; 1775 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ADI_ROLL, -ADIRoll3d );

	movss	xmm0, DWORD PTR _ADIRoll3d
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	100					; 00000064H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1776 : 		//Pitch
; 1777 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ADI_PITCH, -ADIPitch3d );

	movss	xmm0, DWORD PTR _ADIPitch3d
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	101					; 00000065H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1778 : 
; 1779 : 		//MAIN ADI OFF flag
; 1780 : 		if(!SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_ADI_OFF_IN))

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN280@VCock_Exec

; 1781 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_OFF_FLAG, 1);

	push	1
	push	118					; 00000076H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1782 : 		else

	jmp	SHORT $LN279@VCock_Exec
$LN280@VCock_Exec:

; 1783 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_OFF_FLAG, 0);

	push	0
	push	118					; 00000076H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN279@VCock_Exec:

; 1784 : 
; 1785 : 		//MAIN ADI AUX flag
; 1786 : 		if (!SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_ADI_AUX_IN))

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN278@VCock_Exec

; 1787 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_AUX_FLAG, 1);

	push	1
	push	119					; 00000077H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1788 : 		else

	jmp	SHORT $LN277@VCock_Exec
$LN278@VCock_Exec:

; 1789 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_AUX_FLAG, 0);

	push	0
	push	119					; 00000077H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN277@VCock_Exec:

; 1790 : 
; 1791 : 		//MAIN ADI LOC flag
; 1792 : 		if (SimDriver.GetPlayerAircraft()->LOCValid == FALSE || SimDriver.GetPlayerAircraft()->currentPower == AircraftClass::PowerNone)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	eax, BYTE PTR [eax+837]
	test	eax, eax
	je	SHORT $LN275@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1488], 0
	jne	SHORT $LN276@VCock_Exec
$LN275@VCock_Exec:

; 1793 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_LOC_FLAG, 1);

	push	1
	push	116					; 00000074H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1794 : 		else

	jmp	SHORT $LN274@VCock_Exec
$LN276@VCock_Exec:

; 1795 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_LOC_FLAG, 0);

	push	0
	push	116					; 00000074H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN274@VCock_Exec:

; 1796 : 
; 1797 : 		//MAIN ADI GS flag
; 1798 : 		if (SimDriver.GetPlayerAircraft()->GSValid == FALSE || SimDriver.GetPlayerAircraft()->currentPower == AircraftClass::PowerNone)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	eax, BYTE PTR [eax+836]
	test	eax, eax
	je	SHORT $LN272@VCock_Exec
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1488], 0
	jne	SHORT $LN273@VCock_Exec
$LN272@VCock_Exec:

; 1799 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_GS_FLAG, 1);

	push	1
	push	117					; 00000075H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1800 : 		else

	jmp	SHORT $LN271@VCock_Exec
$LN273@VCock_Exec:

; 1801 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ADI_GS_FLAG, 0);

	push	0
	push	117					; 00000075H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN271@VCock_Exec:

; 1802 : 
; 1803 : 		//MAIN ADI ILS
; 1804 : 		float dtILS = (float)(vuxGameTime - prevILStime);

	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	sub	eax, DWORD PTR _prevILStime
	mov	DWORD PTR tv6163[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv6163[ebp]
	mov	ecx, DWORD PTR tv6163[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv6166[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv6166[ebp]
	movss	DWORD PTR _dtILS$3[ebp], xmm0

; 1805 : 		if (dtILS)

	movss	xmm0, DWORD PTR _dtILS$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN270@VCock_Exec

; 1806 : 		{
; 1807 : 			if (hILSneedle<hILS) 

	movss	xmm0, DWORD PTR _hILS
	comiss	xmm0, DWORD PTR _hILSneedle
	jbe	SHORT $LN269@VCock_Exec

; 1808 : 				hILSneedle=hILSneedle + 0.05F; 

	movss	xmm0, DWORD PTR _hILSneedle
	addss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _hILSneedle, xmm0
$LN269@VCock_Exec:

; 1809 : 			if (hILSneedle>hILS) 

	movss	xmm0, DWORD PTR _hILSneedle
	comiss	xmm0, DWORD PTR _hILS
	jbe	SHORT $LN268@VCock_Exec

; 1810 : 				hILSneedle=hILSneedle - 0.05F; 

	movss	xmm0, DWORD PTR _hILSneedle
	subss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _hILSneedle, xmm0
$LN268@VCock_Exec:

; 1811 : 
; 1812 : 			if (vILSneedle<vILS) 

	movss	xmm0, DWORD PTR _vILS
	comiss	xmm0, DWORD PTR _vILSneedle
	jbe	SHORT $LN267@VCock_Exec

; 1813 : 				vILSneedle=vILSneedle + 0.05F; 

	movss	xmm0, DWORD PTR _vILSneedle
	addss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _vILSneedle, xmm0
$LN267@VCock_Exec:

; 1814 : 			if (vILSneedle>vILS) 

	movss	xmm0, DWORD PTR _vILSneedle
	comiss	xmm0, DWORD PTR _vILS
	jbe	SHORT $LN266@VCock_Exec

; 1815 : 				vILSneedle=vILSneedle - 0.05F; 

	movss	xmm0, DWORD PTR _vILSneedle
	subss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _vILSneedle, xmm0
$LN266@VCock_Exec:

; 1816 : 			
; 1817 : 			vrCockpit->SetDOFangle( COMP_3DPIT_ILSV_NEEDLE, vILSneedle / 10.0F );

	movss	xmm0, DWORD PTR _vILSneedle
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	106					; 0000006aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1818 : 			vrCockpit->SetDOFangle( COMP_3DPIT_ILSH_NEEDLE, -hILSneedle / 10.0F);

	movss	xmm0, DWORD PTR _hILSneedle
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	107					; 0000006bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1819 : 			
; 1820 : 			//i use this timer for other needles as well
; 1821 : 			if (SimDriver.GetPlayerAircraft()->af->HydraulicA() && HYDA3d<3.64F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	je	SHORT $LN265@VCock_Exec
	movss	xmm0, DWORD PTR __real@4068f5c3
	comiss	xmm0, DWORD PTR _HYDA3d
	jbe	SHORT $LN265@VCock_Exec

; 1822 : 				{
; 1823 : 					HYDA3d=HYDA3d + 0.1F;

	movss	xmm0, DWORD PTR _HYDA3d
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _HYDA3d, xmm0
	jmp	SHORT $LN263@VCock_Exec
$LN265@VCock_Exec:

; 1824 : 				}
; 1825 : 			else if (!SimDriver.GetPlayerAircraft()->af->HydraulicA() && HYDA3d>0.0F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	jne	SHORT $LN263@VCock_Exec
	movss	xmm0, DWORD PTR _HYDA3d
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN263@VCock_Exec

; 1826 : 				{
; 1827 : 					HYDA3d=HYDA3d - 0.1F;

	movss	xmm0, DWORD PTR _HYDA3d
	subss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _HYDA3d, xmm0
$LN263@VCock_Exec:

; 1828 : 				}
; 1829 : 
; 1830 : 			if (SimDriver.GetPlayerAircraft()->af->HydraulicB() &&  HYDB3d<3.64F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	je	SHORT $LN262@VCock_Exec
	movss	xmm0, DWORD PTR __real@4068f5c3
	comiss	xmm0, DWORD PTR _HYDB3d
	jbe	SHORT $LN262@VCock_Exec

; 1831 : 				{
; 1832 : 					HYDB3d=HYDB3d + 0.1F;

	movss	xmm0, DWORD PTR _HYDB3d
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _HYDB3d, xmm0
	jmp	SHORT $LN260@VCock_Exec
$LN262@VCock_Exec:

; 1833 : 				}
; 1834 : 			else if (!SimDriver.GetPlayerAircraft()->af->HydraulicB() &&  HYDB3d>0.0F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	jne	SHORT $LN260@VCock_Exec
	movss	xmm0, DWORD PTR _HYDB3d
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN260@VCock_Exec

; 1835 : 				{
; 1836 : 					HYDB3d=HYDB3d - 0.1F;

	movss	xmm0, DWORD PTR _HYDB3d
	subss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _HYDB3d, xmm0
$LN260@VCock_Exec:

; 1837 : 				}
; 1838 : 
; 1839 : 			prevILStime = vuxGameTime;

	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _prevILStime, ecx
$LN270@VCock_Exec:

; 1840 : 		}
; 1841 : 
; 1842 : 		if(gNavigationSys)

	cmp	DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A, 0 ; gNavigationSys
	je	$LN253@VCock_Exec

; 1843 : 		{
; 1844 : 			if ((gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_TACAN ||
; 1845 : 				gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_NAV) &&
; 1846 : 				gNavigationSys->GetILSAttribute(NavigationSystem::GP_DEV, &hILS))

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 2
	je	SHORT $LN257@VCock_Exec
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 1
	jne	$LN258@VCock_Exec
$LN257@VCock_Exec:
	push	OFFSET _hILS
	push	4
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z ; NavigationSystem::GetILSAttribute
	test	eax, eax
	je	$LN258@VCock_Exec

; 1847 : 			{
; 1848 : 
; 1849 : 				gNavigationSys->GetILSAttribute(NavigationSystem::GP_DEV, &hILS);

	push	OFFSET _hILS
	push	4
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z ; NavigationSystem::GetILSAttribute

; 1850 : 				gNavigationSys->GetILSAttribute(NavigationSystem::GS_DEV, &vILS);

	push	OFFSET _vILS
	push	5
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetILSAttribute@NavigationSystem@@QAEHW4Attribute@1@PAM@Z ; NavigationSystem::GetILSAttribute

; 1851 : 				hILS *= RTD;

	movss	xmm0, DWORD PTR _hILS
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _hILS, xmm0

; 1852 : 				vILS *= RTD;

	movss	xmm0, DWORD PTR _vILS
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _vILS, xmm0

; 1853 : 				hILS = min ( max (hILS, -3.75F), 3.75F) / 3.75F;

	movss	xmm0, DWORD PTR _hILS
	comiss	xmm0, DWORD PTR __real@c0700000
	jbe	SHORT $LN506@VCock_Exec
	movss	xmm0, DWORD PTR _hILS
	movss	DWORD PTR tv1367[ebp], xmm0
	jmp	SHORT $LN507@VCock_Exec
$LN506@VCock_Exec:
	movss	xmm0, DWORD PTR __real@c0700000
	movss	DWORD PTR tv1367[ebp], xmm0
$LN507@VCock_Exec:
	movss	xmm0, DWORD PTR __real@40700000
	comiss	xmm0, DWORD PTR tv1367[ebp]
	jbe	SHORT $LN510@VCock_Exec
	movss	xmm0, DWORD PTR _hILS
	comiss	xmm0, DWORD PTR __real@c0700000
	jbe	SHORT $LN508@VCock_Exec
	movss	xmm0, DWORD PTR _hILS
	movss	DWORD PTR tv1370[ebp], xmm0
	jmp	SHORT $LN509@VCock_Exec
$LN508@VCock_Exec:
	movss	xmm0, DWORD PTR __real@c0700000
	movss	DWORD PTR tv1370[ebp], xmm0
$LN509@VCock_Exec:
	movss	xmm0, DWORD PTR tv1370[ebp]
	movss	DWORD PTR tv1371[ebp], xmm0
	jmp	SHORT $LN511@VCock_Exec
$LN510@VCock_Exec:
	movss	xmm0, DWORD PTR __real@40700000
	movss	DWORD PTR tv1371[ebp], xmm0
$LN511@VCock_Exec:
	movss	xmm0, DWORD PTR tv1371[ebp]
	divss	xmm0, DWORD PTR __real@40700000
	movss	DWORD PTR _hILS, xmm0

; 1854 : 				vILS = min ( max (vILS, -0.75F), 0.75F) / 0.75F;

	movss	xmm0, DWORD PTR _vILS
	comiss	xmm0, DWORD PTR __real@bf400000
	jbe	SHORT $LN512@VCock_Exec
	movss	xmm0, DWORD PTR _vILS
	movss	DWORD PTR tv1374[ebp], xmm0
	jmp	SHORT $LN513@VCock_Exec
$LN512@VCock_Exec:
	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR tv1374[ebp], xmm0
$LN513@VCock_Exec:
	movss	xmm0, DWORD PTR __real@3f400000
	comiss	xmm0, DWORD PTR tv1374[ebp]
	jbe	SHORT $LN516@VCock_Exec
	movss	xmm0, DWORD PTR _vILS
	comiss	xmm0, DWORD PTR __real@bf400000
	jbe	SHORT $LN514@VCock_Exec
	movss	xmm0, DWORD PTR _vILS
	movss	DWORD PTR tv1377[ebp], xmm0
	jmp	SHORT $LN515@VCock_Exec
$LN514@VCock_Exec:
	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR tv1377[ebp], xmm0
$LN515@VCock_Exec:
	movss	xmm0, DWORD PTR tv1377[ebp]
	movss	DWORD PTR tv1378[ebp], xmm0
	jmp	SHORT $LN517@VCock_Exec
$LN516@VCock_Exec:
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR tv1378[ebp], xmm0
$LN517@VCock_Exec:
	movss	xmm0, DWORD PTR tv1378[ebp]
	divss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _vILS, xmm0

; 1855 : 			}
; 1856 : 			else

	jmp	SHORT $LN256@VCock_Exec
$LN258@VCock_Exec:

; 1857 : 			{
; 1858 : 				hILS = -1.1F;   

	movss	xmm0, DWORD PTR __real@bf8ccccd
	movss	DWORD PTR _hILS, xmm0

; 1859 : 				vILS = -1.1F;   

	movss	xmm0, DWORD PTR __real@bf8ccccd
	movss	DWORD PTR _vILS, xmm0
$LN256@VCock_Exec:

; 1860 : 			}
; 1861 : 			if (hILSneedle > -1.1F || vILSneedle > -1.1F )

	movss	xmm0, DWORD PTR _hILSneedle
	comiss	xmm0, DWORD PTR __real@bf8ccccd
	ja	SHORT $LN254@VCock_Exec
	movss	xmm0, DWORD PTR _vILSneedle
	comiss	xmm0, DWORD PTR __real@bf8ccccd
	jbe	SHORT $LN255@VCock_Exec
$LN254@VCock_Exec:

; 1862 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_ILS_VISIBLE, 1);

	push	1
	push	108					; 0000006cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1863 : 			else

	jmp	SHORT $LN253@VCock_Exec
$LN255@VCock_Exec:

; 1864 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_ILS_VISIBLE, 0);

	push	0
	push	108					; 0000006cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN253@VCock_Exec:

; 1865 : 		}
; 1866 : 
; 1867 : 		hILSneedle = MoveByRate(hILSneedle,hILS,320.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@43a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _hILS
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _hILSneedle
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR _hILSneedle

; 1868 : 		vILSneedle = MoveByRate(vILSneedle,vILS,320.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@43a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vILS
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vILSneedle
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR _vILSneedle

; 1869 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ILSV_NEEDLE, vILSneedle / 10.0F );

	movss	xmm0, DWORD PTR _vILSneedle
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	106					; 0000006aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1870 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ILSH_NEEDLE, -hILSneedle / 10.0F);

	movss	xmm0, DWORD PTR _hILSneedle
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	107					; 0000006bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1871 : 
; 1872 : 		//ADI backup ball
; 1873 : 		//Roll
; 1874 : 		vrCockpit->SetDOFangle( COMP_3DPIT_BACKUP_ADI_ROLL, -BUPADIRoll3d );

	movss	xmm0, DWORD PTR _BUPADIRoll3d
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	103					; 00000067H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1875 : 		//Pitch
; 1876 : 		vrCockpit->SetDOFangle( COMP_3DPIT_BACKUP_ADI_PITCH, -BUPADIPitch3d );

	movss	xmm0, DWORD PTR _BUPADIPitch3d
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	104					; 00000068H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1877 : 
; 1878 : 		//backup magnetic compass
; 1879 : 		MAGCOMPASS3d=cockpitFlightData.yaw;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	movss	DWORD PTR _MAGCOMPASS3d, xmm0

; 1880 : 		vrCockpit->SetDOFangle( COMP_3DPIT_MAG_COMPASS, MAGCOMPASS3d );

	push	ecx
	movss	xmm0, DWORD PTR _MAGCOMPASS3d
	movss	DWORD PTR [esp], xmm0
	push	108					; 0000006cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1881 : 
; 1882 : 		//HSI
; 1883 : 		//current heading
; 1884 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_HDG, -cockpitFlightData.currentHeading * 0.017453292F );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+204
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	114					; 00000072H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1885 : 		//desired course
; 1886 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_CRS, cockpitFlightData.desiredCourse * 0.017453292F );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+192
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	115					; 00000073H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1887 : 		//desired heading
; 1888 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_DHDG, cockpitFlightData.desiredHeading * 0.017453292F );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+208
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	116					; 00000074H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1889 : 		//beacon course
; 1890 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_BCN, cockpitFlightData.bearingToBeacon * 0.017453292F );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+200
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	117					; 00000075H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1891 : 
; 1892 : 		//HSI TO/FROM flags
; 1893 : 		BOOL crsToTrueFlag = HSITOFROM3d;

	mov	ecx, DWORD PTR ?HSITOFROM3d@@3HA	; HSITOFROM3d
	mov	DWORD PTR _crsToTrueFlag$33[ebp], ecx

; 1894 : 
; 1895 : 		if(g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN250@VCock_Exec

; 1896 : 		{
; 1897 : 			if(gNavigationSys)

	cmp	DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A, 0 ; gNavigationSys
	je	SHORT $LN250@VCock_Exec

; 1898 : 			{
; 1899 : 				if(gNavigationSys->GetInstrumentMode() == NavigationSystem::NAV)

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	test	eax, eax
	jne	SHORT $LN250@VCock_Exec

; 1900 : 					crsToTrueFlag = FALSE;

	mov	DWORD PTR _crsToTrueFlag$33[ebp], 0
$LN250@VCock_Exec:

; 1901 : 			}
; 1902 : 		}
; 1903 : 
; 1904 : 		if(crsToTrueFlag == TRUE) {	// to

	cmp	DWORD PTR _crsToTrueFlag$33[ebp], 1
	jne	SHORT $LN249@VCock_Exec

; 1905 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_TO_FLAG, 1);

	push	1
	push	121					; 00000079H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1906 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_FROM_FLAG, 0);

	push	0
	push	122					; 0000007aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN246@VCock_Exec
$LN249@VCock_Exec:

; 1907 : 		}
; 1908 : 		else if (crsToTrueFlag == 2) { // from

	cmp	DWORD PTR _crsToTrueFlag$33[ebp], 2
	jne	SHORT $LN247@VCock_Exec

; 1909 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_TO_FLAG, 0);

	push	0
	push	121					; 00000079H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1910 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_FROM_FLAG, 1);

	push	1
	push	122					; 0000007aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1911 : 		}
; 1912 : 		else { // to/from both off

	jmp	SHORT $LN246@VCock_Exec
$LN247@VCock_Exec:

; 1913 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_TO_FLAG, 0);

	push	0
	push	121					; 00000079H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1914 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_FROM_FLAG, 0);

	push	0
	push	122					; 0000007aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN246@VCock_Exec:

; 1915 : 		}
; 1916 : 
; 1917 : 		//HSI course deviation needle
; 1918 : 		float hsidev = cockpitFlightData.courseDeviation;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+188
	movss	DWORD PTR _hsidev$51[ebp], xmm0

; 1919 : 		if (hsidev > 90) hsidev = 180 - hsidev;

	movss	xmm0, DWORD PTR _hsidev$51[ebp]
	comiss	xmm0, DWORD PTR __real@42b40000
	jbe	SHORT $LN245@VCock_Exec
	movss	xmm0, DWORD PTR __real@43340000
	subss	xmm0, DWORD PTR _hsidev$51[ebp]
	movss	DWORD PTR _hsidev$51[ebp], xmm0
$LN245@VCock_Exec:

; 1920 : 		if (hsidev < -90) hsidev = - (180 + hsidev);

	movss	xmm0, DWORD PTR __real@c2b40000
	comiss	xmm0, DWORD PTR _hsidev$51[ebp]
	jbe	SHORT $LN244@VCock_Exec
	movss	xmm0, DWORD PTR __real@43340000
	addss	xmm0, DWORD PTR _hsidev$51[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _hsidev$51[ebp], xmm0
$LN244@VCock_Exec:

; 1921 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_CRSDEV, hsidev);

	push	ecx
	movss	xmm0, DWORD PTR _hsidev$51[ebp]
	movss	DWORD PTR [esp], xmm0
	push	118					; 00000076H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1922 : 
; 1923 : 		//HSI OFF flag
; 1924 : 		if (!SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_HSI_OFF_IN))

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN243@VCock_Exec

; 1925 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_OFF_FLAG, 1);

	push	1
	push	120					; 00000078H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1926 : 		else

	jmp	SHORT $LN242@VCock_Exec
$LN243@VCock_Exec:

; 1927 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_OFF_FLAG, 0);

	push	0
	push	120					; 00000078H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN242@VCock_Exec:

; 1928 : 
; 1929 : 		//HSI ILSWARN flag
; 1930 : 		if (cockpitFlightData.IsSetHsi(FlightData::IlsWarning))

	push	2
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSetHsi@FlightData@@QAEHH@Z		; FlightData::IsSetHsi
	test	eax, eax
	je	SHORT $LN241@VCock_Exec

; 1931 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_ILSWARN_FLAG, 1);

	push	1
	push	123					; 0000007bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1932 : 		else

	jmp	SHORT $LN240@VCock_Exec
$LN241@VCock_Exec:

; 1933 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_ILSWARN_FLAG, 0);

	push	0
	push	123					; 0000007bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN240@VCock_Exec:

; 1934 : 
; 1935 : 		//HSI CRSWARN flag
; 1936 : 		if (cockpitFlightData.IsSetHsi(FlightData::CourseWarning))

	push	4
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSetHsi@FlightData@@QAEHH@Z		; FlightData::IsSetHsi
	test	eax, eax
	je	SHORT $LN239@VCock_Exec

; 1937 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_CRSWARN_FLAG, 1);

	push	1
	push	124					; 0000007cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 1938 : 		else

	jmp	SHORT $LN238@VCock_Exec
$LN239@VCock_Exec:

; 1939 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_CRSWARN_FLAG, 0);

	push	0
	push	124					; 0000007cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN238@VCock_Exec:

; 1940 : 
; 1941 : 		//HSI distance to beacon digital readout
; 1942 : 		float hsidist = cockpitFlightData.distanceToBeacon;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+196
	movss	DWORD PTR _hsidist$35[ebp], xmm0

; 1943 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_DIST_DIGIT3, ExtractDigit( hsidist, 0 ) * 0.6283F);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _hsidist$35[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	121					; 00000079H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1944 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_DIST_DIGIT2, ExtractDigit( hsidist, 1 ) * 0.6283F);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR _hsidist$35[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	120					; 00000078H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1945 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_DIST_DIGIT1, ExtractDigit( hsidist, 2 ) * 0.6283F);

	push	2
	push	ecx
	movss	xmm0, DWORD PTR _hsidist$35[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	119					; 00000077H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1946 : 
; 1947 : 		//HSI course digital readout
; 1948 : 		float hsicrs = cockpitFlightData.desiredCourse;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+192
	movss	DWORD PTR _hsicrs$37[ebp], xmm0

; 1949 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_CRS_DIGIT3, ExtractDigit( hsicrs, 0 ) * 0.6283F);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _hsicrs$37[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	124					; 0000007cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1950 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_CRS_DIGIT2, ExtractDigit( hsicrs, 1 ) * 0.6283F);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR _hsicrs$37[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	123					; 0000007bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1951 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HSI_CRS_DIGIT1, ExtractDigit( hsicrs, 2 ) * 0.6283F);

	push	2
	push	ecx
	movss	xmm0, DWORD PTR _hsicrs$37[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	122					; 0000007aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1952 : 
; 1953 : 		//fuel flow digital readout
; 1954 : 		float fuelflow = cockpitFlightData.fuelFlow;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+84
	movss	DWORD PTR _fuelflow$34[ebp], xmm0

; 1955 : 		float fuelflowdigit3 = (((long) fuelflow) % 1000) / 1000.0F;

	cvttss2si eax, DWORD PTR _fuelflow$34[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fuelflowdigit3$4[ebp], xmm0

; 1956 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUELFLOW_DIGIT3, fuelflowdigit3 * (2 * PI));

	movss	xmm0, DWORD PTR _fuelflowdigit3$4[ebp]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1957 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUELFLOW_DIGIT2, ExtractDigit( fuelflow, 3 ) * 0.6283F);

	push	3
	push	ecx
	movss	xmm0, DWORD PTR _fuelflow$34[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	126					; 0000007eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1958 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUELFLOW_DIGIT1, ExtractDigit( fuelflow, 4 ) * 0.6283F);

	push	4
	push	ecx
	movss	xmm0, DWORD PTR _fuelflow$34[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	125					; 0000007dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1959 : 
; 1960 : 
; 1961 : 		//******************************************
; 1962 : 		// NEEDLES
; 1963 : 		//******************************************
; 1964 : 
; 1965 : 		//G-Meter needle
; 1966 : 		vrCockpit->SetDOFangle( COMP_3DPIT_G_NEEDLE, (float) cockpitFlightData.gs );

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [esp], xmm0
	push	144					; 00000090H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1967 : 
; 1968 : 		//ASI needle
; 1969 : 		float value = cockpitFlightData.kias;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	movss	DWORD PTR _value$52[ebp], xmm0

; 1970 : 		if(value < 80.0F )

	movss	xmm0, DWORD PTR __real@42a00000
	comiss	xmm0, DWORD PTR _value$52[ebp]
	jbe	SHORT $LN237@VCock_Exec

; 1971 : 			value = 80.0F;

	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR _value$52[ebp], xmm0
	jmp	SHORT $LN235@VCock_Exec
$LN237@VCock_Exec:

; 1972 : 		else if(value > 850.0F )

	movss	xmm0, DWORD PTR _value$52[ebp]
	comiss	xmm0, DWORD PTR __real@44548000
	jbe	SHORT $LN235@VCock_Exec

; 1973 : 			value = 850.0F;

	movss	xmm0, DWORD PTR __real@44548000
	movss	DWORD PTR _value$52[ebp], xmm0
$LN235@VCock_Exec:

; 1974 : 		value = value / 100.0F;

	movss	xmm0, DWORD PTR _value$52[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _value$52[ebp], xmm0

; 1975 : 		//ASI Instrument has a Log10 scale.  
; 1976 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ASI_NEEDLE, (float)((log10(value) * 5.8F) + 0.6F ));

	push	ecx
	movss	xmm0, DWORD PTR _value$52[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?log10@@YAMM@Z				; log10
	add	esp, 4
	fstp	DWORD PTR tv6370[ebp]
	movss	xmm0, DWORD PTR tv6370[ebp]
	mulss	xmm0, DWORD PTR __real@40b9999a
	addss	xmm0, DWORD PTR __real@3f19999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	102					; 00000066H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1977 : 
; 1978 : 		//ASI mach digital readout
; 1979 : 		float	machNumber;
; 1980 : 		int		machfirstDigit;
; 1981 : 		int		machsecondDigit;
; 1982 : 		machNumber = cockpitFlightData.mach;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+48
	movss	DWORD PTR _machNumber$22[ebp], xmm0

; 1983 : 		machfirstDigit = (int) machNumber;

	cvttss2si ecx, DWORD PTR _machNumber$22[ebp]
	mov	DWORD PTR _machfirstDigit$23[ebp], ecx

; 1984 : 		machsecondDigit = (int) (10.0F * (machNumber - ((float) machfirstDigit)));

	cvtsi2ss xmm0, DWORD PTR _machfirstDigit$23[ebp]
	movss	xmm1, DWORD PTR _machNumber$22[ebp]
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@41200000
	cvttss2si edx, xmm1
	mov	DWORD PTR _machsecondDigit$7[ebp], edx

; 1985 : 
; 1986 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ASIMACH_DIGIT1, (float) machfirstDigit * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _machfirstDigit$23[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	109					; 0000006dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1987 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ASIMACH_DIGIT2, (float) machsecondDigit * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _machsecondDigit$7[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	110					; 0000006eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1988 : 
; 1989 : 		//ALTIMETER needle
; 1990 : 		float altneedle = (((long) -cockpitFlightData.z) % 1000) / 1000.0F;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvttss2si eax, xmm0
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _altneedle$26[ebp], xmm0

; 1991 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ALT_NEEDLE, (float) altneedle * (2 * PI));

	movss	xmm0, DWORD PTR _altneedle$26[ebp]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	105					; 00000069H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 1992 : 
; 1993 : 		//ALTIMETER digital readout
; 1994 : 		float	alt;
; 1995 : 		int		altfirstDigit;
; 1996 : 		int		altsecondDigit;
; 1997 : 		alt = -cockpitFlightData.z;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _alt$28[ebp], xmm0

; 1998 : 		altfirstDigit = (int) alt / 10000;

	cvttss2si eax, DWORD PTR _alt$28[ebp]
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	mov	DWORD PTR _altfirstDigit$27[ebp], eax

; 1999 : 		altsecondDigit = (int) (((alt / 10000) - altfirstDigit) * 10.0F) ;

	movss	xmm0, DWORD PTR _alt$28[ebp]
	divss	xmm0, DWORD PTR __real@461c4000
	cvtsi2ss xmm1, DWORD PTR _altfirstDigit$27[ebp]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si edx, xmm0
	mov	DWORD PTR _altsecondDigit$20[ebp], edx

; 2000 : 
; 2001 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ALT_DIGIT1, (float) altfirstDigit * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _altfirstDigit$27[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	111					; 0000006fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2002 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ALT_DIGIT2, (float) altsecondDigit * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _altsecondDigit$20[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	112					; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2003 : 		vrCockpit->SetDOFangle( COMP_3DPIT_ALT_DIGIT3, (float) altneedle * (2 * PI));

	movss	xmm0, DWORD PTR _altneedle$26[ebp]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	113					; 00000071H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2004 : 
; 2005 : 		//ALTIMETER PNEU flag - if main generator not running then PNEU flag apears
; 2006 : 		if (!SimDriver.GetPlayerAircraft()->af->GeneratorRunning(AirframeClass::GenMain)){

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GeneratorRunning@AirframeClass@@QAEHW4Generator@1@@Z ; AirframeClass::GeneratorRunning
	test	eax, eax
	jne	SHORT $LN234@VCock_Exec

; 2007 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ALTPNEU_FLAG, 1);

	push	1
	push	107					; 0000006bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2008 : 		}
; 2009 : 		else{

	jmp	SHORT $LN233@VCock_Exec
$LN234@VCock_Exec:

; 2010 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ALTPNEU_FLAG, 0);

	push	0
	push	107					; 0000006bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN233@VCock_Exec:

; 2011 : 		}
; 2012 : 
; 2013 : 		//total fuel digital readout
; 2014 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUEL_DIGIT5, 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	141					; 0000008dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2015 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUEL_DIGIT4, 0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	140					; 0000008cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2016 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUEL_DIGIT3, ExtractDigit( cockpitFlightData.total, 2 ) * 0.6283F);

	push	2
	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+1272
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	139					; 0000008bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2017 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUEL_DIGIT2, ExtractDigit( cockpitFlightData.total, 3 ) * 0.6283F);

	push	3
	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+1272
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	138					; 0000008aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2018 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUEL_DIGIT1, ExtractDigit( cockpitFlightData.total, 4 ) * 0.6283F);

	push	4
	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+1272
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	137					; 00000089H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2019 : 
; 2020 : 		//FUEL FWD needle
; 2021 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUELFWD_NEEDLE, (float) cockpitFlightData.fwd * 0.00010F);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+1264
	mulss	xmm0, DWORD PTR __real@38d1b717
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	143					; 0000008fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2022 : 		//FUEL AFT needle
; 2023 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FUELAFT_NEEDLE, (float) cockpitFlightData.aft * 0.00010F);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+1268
	mulss	xmm0, DWORD PTR __real@38d1b717
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	142					; 0000008eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2024 : 
; 2025 : 		//OIL press
; 2026 : 		vrCockpit->SetDOFangle( COMP_3DPIT_OIL_NEEDLE, (float) cockpitFlightData.oilPressure * 0.057F);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+116
	mulss	xmm0, DWORD PTR __real@3d6978d5
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2027 : 
; 2028 : 		//NOZZLE pos
; 2029 : 		vrCockpit->SetDOFangle( COMP_3DPIT_NOZ_NEEDLE, (float) cockpitFlightData.nozzlePos * 0.042F);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+68
	mulss	xmm0, DWORD PTR __real@3d2c0831
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	129					; 00000081H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2030 : 
; 2031 : 		float rpm = cockpitFlightData.rpm;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+88
	movss	DWORD PTR _rpm$64[ebp], xmm0

; 2032 : 		float needle;
; 2033 : 
; 2034 : 		//RPM
; 2035 : 		//match F16 RPM scale
; 2036 : 		if (rpm<60) 

	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _rpm$64[ebp]
	jbe	SHORT $LN232@VCock_Exec

; 2037 : 		{
; 2038 : 			needle = rpm * 0.03315F;

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	mulss	xmm0, DWORD PTR __real@3d07c84b
	movss	DWORD PTR _needle$61[ebp], xmm0
	jmp	$LN227@VCock_Exec
$LN232@VCock_Exec:

; 2039 : 		}
; 2040 : 		else if (rpm<70)

	movss	xmm0, DWORD PTR __real@428c0000
	comiss	xmm0, DWORD PTR _rpm$64[ebp]
	jbe	SHORT $LN230@VCock_Exec

; 2041 : 		{
; 2042 : 			needle = 1.989F + ((rpm-60.0F) * 0.0541F);

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	mulss	xmm0, DWORD PTR __real@3d5d97f6
	addss	xmm0, DWORD PTR __real@3ffe978d
	movss	DWORD PTR _needle$61[ebp], xmm0
	jmp	SHORT $LN227@VCock_Exec
$LN230@VCock_Exec:

; 2043 : 		}
; 2044 : 		else if (rpm<100)

	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _rpm$64[ebp]
	jbe	SHORT $LN228@VCock_Exec

; 2045 : 		{
; 2046 : 			needle = 2.53F + ((rpm-70.0F) * 0.079F);

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	subss	xmm0, DWORD PTR __real@428c0000
	mulss	xmm0, DWORD PTR __real@3da1cac1
	addss	xmm0, DWORD PTR __real@4021eb85
	movss	DWORD PTR _needle$61[ebp], xmm0

; 2047 : 		}
; 2048 : 		else

	jmp	SHORT $LN227@VCock_Exec
$LN228@VCock_Exec:

; 2049 : 		{
; 2050 : 			needle = 4.9F + ((rpm-100.0F) * 0.08266F);

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	subss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR __real@3da949a5
	addss	xmm0, DWORD PTR __real@409ccccd
	movss	DWORD PTR _needle$61[ebp], xmm0
$LN227@VCock_Exec:

; 2051 : 		}
; 2052 : 
; 2053 : 		vrCockpit->SetDOFangle( COMP_3DPIT_RPM_NEEDLE, needle);

	push	ecx
	movss	xmm0, DWORD PTR _needle$61[ebp]
	movss	DWORD PTR [esp], xmm0
	push	130					; 00000082H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2054 : 
; 2055 : 		//FTIT
; 2056 : 		float ftit;
; 2057 : 		rpm = SimDriver.GetPlayerAircraft()->af->oldp01[0];

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx+284]
	movss	DWORD PTR _rpm$64[ebp], xmm0

; 2058 : 
; 2059 : 		// FTIT values from Sylvain :-)
; 2060 : 		if (rpm < 0.2F)

	movss	xmm0, DWORD PTR __real@3e4ccccd
	comiss	xmm0, DWORD PTR _rpm$64[ebp]
	jbe	SHORT $LN226@VCock_Exec

; 2061 : 		{
; 2062 : 			ftit = 5.1F * rpm/0.2f; // JPO adapt for < idle speeds.

	movss	xmm0, DWORD PTR __real@40a33333
	mulss	xmm0, DWORD PTR _rpm$64[ebp]
	divss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _ftit$62[ebp], xmm0
	jmp	$LN221@VCock_Exec
$LN226@VCock_Exec:

; 2063 : 		}
; 2064 : 		else if (rpm < 0.6225F) // 0.9^4.5

	movss	xmm0, DWORD PTR __real@3f1f5c29
	comiss	xmm0, DWORD PTR _rpm$64[ebp]
	jbe	SHORT $LN224@VCock_Exec

; 2065 : 		{
; 2066 : 			ftit = 5.1F + (rpm - 0.2F) / 0.4225F * 1.0F;

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	subss	xmm0, DWORD PTR __real@3e4ccccd
	divss	xmm0, DWORD PTR __real@3ed851ec
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@40a33333
	movss	DWORD PTR _ftit$62[ebp], xmm0
	jmp	SHORT $LN221@VCock_Exec
$LN224@VCock_Exec:

; 2067 : 		}
; 2068 : 		else if (rpm < 1.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rpm$64[ebp]
	jbe	SHORT $LN222@VCock_Exec

; 2069 : 		{
; 2070 : 			ftit = 6.1F + (rpm - 0.6225F) / 0.3775F * 1.5F;

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	subss	xmm0, DWORD PTR __real@3f1f5c29
	divss	xmm0, DWORD PTR __real@3ec147ae
	mulss	xmm0, DWORD PTR __real@3fc00000
	addss	xmm0, DWORD PTR __real@40c33333
	movss	DWORD PTR _ftit$62[ebp], xmm0

; 2071 : 		}
; 2072 : 		else

	jmp	SHORT $LN221@VCock_Exec
$LN222@VCock_Exec:

; 2073 : 		{
; 2074 : 			ftit = 7.6F + (rpm - 1.0F) / 0.53F * 0.4F; // 0.53 is full afterburner

	movss	xmm0, DWORD PTR _rpm$64[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR __real@3f07ae14
	mulss	xmm0, DWORD PTR __real@3ecccccd
	addss	xmm0, DWORD PTR __real@40f33333
	movss	DWORD PTR _ftit$62[ebp], xmm0
$LN221@VCock_Exec:

; 2075 : 		}
; 2076 : 
; 2077 : 		if (ftit>12.0F){

	movss	xmm0, DWORD PTR _ftit$62[ebp]
	comiss	xmm0, DWORD PTR __real@41400000
	jbe	SHORT $LN220@VCock_Exec

; 2078 : 			ftit=12.0F;

	movss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR _ftit$62[ebp], xmm0
$LN220@VCock_Exec:

; 2079 : 		}
; 2080 : 
; 2081 : 		//match F16 FTIT scale
; 2082 : 		if (ftit<2.0F) 

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _ftit$62[ebp]
	jbe	SHORT $LN219@VCock_Exec

; 2083 : 		{
; 2084 : 			needle = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _needle$61[ebp], xmm0
	jmp	$LN214@VCock_Exec
$LN219@VCock_Exec:

; 2085 : 		}
; 2086 : 		else if (ftit<7.0F)

	movss	xmm0, DWORD PTR __real@40e00000
	comiss	xmm0, DWORD PTR _ftit$62[ebp]
	jbe	SHORT $LN217@VCock_Exec

; 2087 : 		{
; 2088 : 			needle = (ftit-2.0F) * 0.345F;

	movss	xmm0, DWORD PTR _ftit$62[ebp]
	subss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@3eb0a3d7
	movss	DWORD PTR _needle$61[ebp], xmm0
	jmp	SHORT $LN214@VCock_Exec
$LN217@VCock_Exec:

; 2089 : 		}
; 2090 : 		else if (ftit<10.0F)

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _ftit$62[ebp]
	jbe	SHORT $LN215@VCock_Exec

; 2091 : 		{
; 2092 : 			needle = 1.727F + ((ftit-7.0F) * 1.035F);

	movss	xmm0, DWORD PTR _ftit$62[ebp]
	subss	xmm0, DWORD PTR __real@40e00000
	mulss	xmm0, DWORD PTR __real@3f847ae1
	addss	xmm0, DWORD PTR __real@3fdd0e56
	movss	DWORD PTR _needle$61[ebp], xmm0

; 2093 : 		}
; 2094 : 		else

	jmp	SHORT $LN214@VCock_Exec
$LN215@VCock_Exec:

; 2095 : 		{
; 2096 : 			needle = 4.834F + ((ftit-10.0F) * 0.375F);

	movss	xmm0, DWORD PTR _ftit$62[ebp]
	subss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR __real@3ec00000
	addss	xmm0, DWORD PTR __real@409ab021
	movss	DWORD PTR _needle$61[ebp], xmm0
$LN214@VCock_Exec:

; 2097 : 		}
; 2098 : 
; 2099 : 		vrCockpit->SetDOFangle( COMP_3DPIT_FTIT_NEEDLE, needle );

	push	ecx
	movss	xmm0, DWORD PTR _needle$61[ebp]
	movss	DWORD PTR [esp], xmm0
	push	131					; 00000083H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2100 : 		
; 2101 : 		//HYD A/B
; 2102 : 		if (SimDriver.GetPlayerAircraft()->af->HydraulicA() && HYDA3d<3.64F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	je	SHORT $LN213@VCock_Exec
	movss	xmm0, DWORD PTR __real@4068f5c3
	comiss	xmm0, DWORD PTR _HYDA3d
	jbe	SHORT $LN213@VCock_Exec

; 2103 : 		{
; 2104 : 			HYDA3d = MoveByRate(HYDA3d,3.64F,200);

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@4068f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _HYDA3d
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR _HYDA3d
	jmp	SHORT $LN211@VCock_Exec
$LN213@VCock_Exec:

; 2105 : 		}
; 2106 : 		else if (!SimDriver.GetPlayerAircraft()->af->HydraulicA() && HYDA3d>0.0F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicA@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicA
	test	eax, eax
	jne	SHORT $LN211@VCock_Exec
	movss	xmm0, DWORD PTR _HYDA3d
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN211@VCock_Exec

; 2107 : 		{
; 2108 : 			HYDA3d = MoveByRate(HYDA3d,0.0F,200);

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _HYDA3d
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR _HYDA3d
$LN211@VCock_Exec:

; 2109 : 		}
; 2110 : 
; 2111 : 		if (SimDriver.GetPlayerAircraft()->af->HydraulicB() &&  HYDB3d<3.64F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	je	SHORT $LN210@VCock_Exec
	movss	xmm0, DWORD PTR __real@4068f5c3
	comiss	xmm0, DWORD PTR _HYDB3d
	jbe	SHORT $LN210@VCock_Exec

; 2112 : 		{
; 2113 : 			HYDB3d = MoveByRate(HYDB3d,3.64F,200);

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@4068f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _HYDB3d
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR _HYDB3d
	jmp	SHORT $LN208@VCock_Exec
$LN210@VCock_Exec:

; 2114 : 		}
; 2115 : 		else if (!SimDriver.GetPlayerAircraft()->af->HydraulicB() &&  HYDB3d>0.0F)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?HydraulicB@AirframeClass@@QAEHXZ	; AirframeClass::HydraulicB
	test	eax, eax
	jne	SHORT $LN208@VCock_Exec
	movss	xmm0, DWORD PTR _HYDB3d
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN208@VCock_Exec

; 2116 : 		{
; 2117 : 			HYDB3d = MoveByRate(HYDB3d,0.0F,200);

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _HYDB3d
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR _HYDB3d
$LN208@VCock_Exec:

; 2118 : 		}
; 2119 : 
; 2120 : 		//HYD A 
; 2121 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HYDA_NEEDLE, HYDA3d );

	push	ecx
	movss	xmm0, DWORD PTR _HYDA3d
	movss	DWORD PTR [esp], xmm0
	push	134					; 00000086H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2122 : 
; 2123 : 		//HYD B
; 2124 : 		vrCockpit->SetDOFangle( COMP_3DPIT_HYDB_NEEDLE, HYDB3d );

	push	ecx
	movss	xmm0, DWORD PTR _HYDB3d
	movss	DWORD PTR [esp], xmm0
	push	135					; 00000087H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2125 : 
; 2126 : 		//EPU fuel
; 2127 : 		vrCockpit->SetDOFangle( COMP_3DPIT_EPU_NEEDLE, cockpitFlightData.epuFuel * 0.04241F);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+112
	mulss	xmm0, DWORD PTR __real@3d2db61c
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	136					; 00000088H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2128 : 
; 2129 : 		//AOA tape
; 2130 : 		if (cockpitFlightData.IsSetHsi(FlightData::AOA))

	push	4096					; 00001000H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSetHsi@FlightData@@QAEHH@Z		; FlightData::IsSetHsi
	test	eax, eax
	je	SHORT $LN207@VCock_Exec

; 2131 : 		{
; 2132 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOA_OFF_FLAG, 1);

	push	1
	push	125					; 0000007dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2133 : 			vrCockpit->SetDOFangle( COMP_3DPIT_AOA, -0.69F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf30a3d7
	movss	DWORD PTR [esp], xmm0
	push	132					; 00000084H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2134 : 			vrCockpit->SetDOFangle( COMP_3DPIT_AOA_DIAL, 19.0f * DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@3ea9c91e
	movss	DWORD PTR [esp], xmm0
	push	161					; 000000a1H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2135 : 		}
; 2136 : 		else

	jmp	$LN206@VCock_Exec
$LN207@VCock_Exec:

; 2137 : 		{
; 2138 : 			float aoa=-cockpitFlightData.alpha;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+24
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _aoa$55[ebp], xmm0

; 2139 : 			if (aoa>35.0F)

	movss	xmm0, DWORD PTR _aoa$55[ebp]
	comiss	xmm0, DWORD PTR __real@420c0000
	jbe	SHORT $LN205@VCock_Exec

; 2140 : 				aoa = 35.0F;

	movss	xmm0, DWORD PTR __real@420c0000
	movss	DWORD PTR _aoa$55[ebp], xmm0
$LN205@VCock_Exec:

; 2141 : 			if (aoa<-35.0F)

	movss	xmm0, DWORD PTR __real@c20c0000
	comiss	xmm0, DWORD PTR _aoa$55[ebp]
	jbe	SHORT $LN204@VCock_Exec

; 2142 : 				aoa = -35.0F;

	movss	xmm0, DWORD PTR __real@c20c0000
	movss	DWORD PTR _aoa$55[ebp], xmm0
$LN204@VCock_Exec:

; 2143 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AOA_OFF_FLAG, 0);

	push	0
	push	125					; 0000007dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2144 : 			vrCockpit->SetDOFangle( COMP_3DPIT_AOA, aoa * 0.01146F);

	movss	xmm0, DWORD PTR _aoa$55[ebp]
	mulss	xmm0, DWORD PTR __real@3c3bc2b9
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	132					; 00000084H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2145 : 			// AOA Dial
; 2146 : 			aoa += 19.0f;

	movss	xmm0, DWORD PTR _aoa$55[ebp]
	addss	xmm0, DWORD PTR __real@41980000
	movss	DWORD PTR _aoa$55[ebp], xmm0

; 2147 : 			vrCockpit->SetDOFangle( COMP_3DPIT_AOA_DIAL, aoa * DTR);

	movss	xmm0, DWORD PTR _aoa$55[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	161					; 000000a1H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN206@VCock_Exec:

; 2148 : 		}
; 2149 : 
; 2150 : 		//VVI tape
; 2151 : 		if (cockpitFlightData.IsSetHsi(FlightData::VVI))

	push	2048					; 00000800H
	mov	ecx, OFFSET ?cockpitFlightData@@3VFlightData@@A ; cockpitFlightData
	call	?IsSetHsi@FlightData@@QAEHH@Z		; FlightData::IsSetHsi
	test	eax, eax
	je	SHORT $LN203@VCock_Exec

; 2152 : 		{
; 2153 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_VVI_OFF_FLAG, 1);

	push	1
	push	126					; 0000007eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2154 : 			vrCockpit->SetDOFangle( COMP_3DPIT_VVI, -0.69F);		

	push	ecx
	movss	xmm0, DWORD PTR __real@bf30a3d7
	movss	DWORD PTR [esp], xmm0
	push	133					; 00000085H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2155 : 			vrCockpit->SetDOFangle( COMP_3DPIT_VVI_DIAL, -6.0F * DTR);		

	push	ecx
	movss	xmm0, DWORD PTR __real@bdd6774e
	movss	DWORD PTR [esp], xmm0
	push	162					; 000000a2H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2156 : 		}
; 2157 : 		else

	jmp	$LN202@VCock_Exec
$LN203@VCock_Exec:

; 2158 : 		{
; 2159 : 			float vvi=cockpitFlightData.zDot * 0.06F;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	mulss	xmm0, DWORD PTR __real@3d75c28f
	movss	DWORD PTR _vvi$50[ebp], xmm0

; 2160 : 			if (vvi>6.0F)

	movss	xmm0, DWORD PTR _vvi$50[ebp]
	comiss	xmm0, DWORD PTR __real@40c00000
	jbe	SHORT $LN201@VCock_Exec

; 2161 : 				vvi=6.0F;

	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR _vvi$50[ebp], xmm0
$LN201@VCock_Exec:

; 2162 : 			if (vvi<-6.0F)

	movss	xmm0, DWORD PTR __real@c0c00000
	comiss	xmm0, DWORD PTR _vvi$50[ebp]
	jbe	SHORT $LN200@VCock_Exec

; 2163 : 				vvi=-6.0F;

	movss	xmm0, DWORD PTR __real@c0c00000
	movss	DWORD PTR _vvi$50[ebp], xmm0
$LN200@VCock_Exec:

; 2164 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_VVI_OFF_FLAG, 0);

	push	0
	push	126					; 0000007eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2165 : 			vrCockpit->SetDOFangle( COMP_3DPIT_VVI, vvi * 0.06981F);

	movss	xmm0, DWORD PTR _vvi$50[ebp]
	mulss	xmm0, DWORD PTR __real@3d8ef88c
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	133					; 00000085H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2166 : 			vrCockpit->SetDOFangle( COMP_3DPIT_VVI_DIAL, vvi * DTR);

	movss	xmm0, DWORD PTR _vvi$50[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	162					; 000000a2H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN202@VCock_Exec:

; 2167 : 		}
; 2168 : 
; 2169 : 		//=======================================================
; 2170 : 		// New 3D pit switch/knob animation - FRB
; 2171 : 		// What time is it?
; 2172 : 		VU_TIME	currentTime;
; 2173 : 		VU_TIME	remainder;
; 2174 : 		VU_TIME	hours;
; 2175 : 		VU_TIME	minutes;
; 2176 : 		VU_TIME	seconds;
; 2177 : 		// Get current time convert from ms to secs
; 2178 : 		currentTime	= vuxGameTime / 1000;

	mov	eax, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR _currentTime$9[ebp], eax

; 2179 : 		remainder	= currentTime % 86400;		//86400 secs in a day

	mov	eax, DWORD PTR _currentTime$9[ebp]
	xor	edx, edx
	mov	ecx, 86400				; 00015180H
	div	ecx
	mov	DWORD PTR _remainder$47[ebp], edx

; 2180 : 		hours			= remainder / 3600;			// 3600 secs in an hour

	mov	eax, DWORD PTR _remainder$47[ebp]
	xor	edx, edx
	mov	ecx, 3600				; 00000e10H
	div	ecx
	mov	DWORD PTR _hours$48[ebp], eax

; 2181 : 		remainder	= remainder - hours * 3600;

	mov	edx, DWORD PTR _hours$48[ebp]
	imul	edx, 3600				; 00000e10H
	mov	eax, DWORD PTR _remainder$47[ebp]
	sub	eax, edx
	mov	DWORD PTR _remainder$47[ebp], eax

; 2182 : 		if(hours > 12) {

	cmp	DWORD PTR _hours$48[ebp], 12		; 0000000cH
	jbe	SHORT $LN199@VCock_Exec

; 2183 : 			hours -= 12;

	mov	ecx, DWORD PTR _hours$48[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR _hours$48[ebp], ecx
$LN199@VCock_Exec:

; 2184 : 		}
; 2185 : 		minutes	= remainder / 60;

	mov	eax, DWORD PTR _remainder$47[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _minutes$25[ebp], eax

; 2186 : 		seconds	= remainder - minutes * 60;

	mov	edx, DWORD PTR _minutes$25[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR _remainder$47[ebp]
	sub	eax, edx
	mov	DWORD PTR _seconds$19[ebp], eax

; 2187 : 		// add back fraction of hour and fraction of minutes so that hour and min hand doesn't pop
; 2188 : 		float Hours			= (float)hours;

	mov	ecx, DWORD PTR _hours$48[ebp]
	mov	DWORD PTR tv6597[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv6597[ebp]
	mov	edx, DWORD PTR tv6597[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv6601[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv6601[ebp]
	movss	DWORD PTR _Hours$36[ebp], xmm0

; 2189 : 		float Minutes		= (float)minutes;

	mov	eax, DWORD PTR _minutes$25[ebp]
	mov	DWORD PTR tv6606[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv6606[ebp]
	mov	ecx, DWORD PTR tv6606[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv6610[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv6610[ebp]
	movss	DWORD PTR _Minutes$38[ebp], xmm0

; 2190 : 		float Seconds		= (float)seconds;

	mov	edx, DWORD PTR _seconds$19[ebp]
	mov	DWORD PTR tv6615[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv6615[ebp]
	mov	eax, DWORD PTR tv6615[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv6619[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv6619[ebp]
	movss	DWORD PTR _Seconds$32[ebp], xmm0

; 2191 : 		Hours += (Minutes * 0.01667F); // minutes * 1/60

	movss	xmm0, DWORD PTR _Minutes$38[ebp]
	mulss	xmm0, DWORD PTR __real@3c888f86
	addss	xmm0, DWORD PTR _Hours$36[ebp]
	movss	DWORD PTR _Hours$36[ebp], xmm0

; 2192 : 		Minutes += (Seconds * 0.01667F);

	movss	xmm0, DWORD PTR _Seconds$32[ebp]
	mulss	xmm0, DWORD PTR __real@3c888f86
	addss	xmm0, DWORD PTR _Minutes$38[ebp]
	movss	DWORD PTR _Minutes$38[ebp], xmm0

; 2193 : 		vrCockpit->SetDOFangle( COMP_3DPIT_CLOCK_HRS, Hours * 30.0F*DTR);  // degrees per hour 

	movss	xmm0, DWORD PTR _Hours$36[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	151					; 00000097H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2194 : 		vrCockpit->SetDOFangle( COMP_3DPIT_CLOCK_MINS, Minutes * 6.0F*DTR); // degrees per minute

	movss	xmm0, DWORD PTR _Minutes$38[ebp]
	mulss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	152					; 00000098H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2195 : 		vrCockpit->SetDOFangle( COMP_3DPIT_CLOCK_SECS, Seconds * 6.0F*DTR); // degrees per second

	movss	xmm0, DWORD PTR _Seconds$32[ebp]
	mulss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	153					; 00000099H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2196 : 
; 2197 :     PlayerRwrClass* theRwr = (PlayerRwrClass*)FindSensor(SimDriver.GetPlayerAircraft(), SensorClass::RWR);

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRwr$63[ebp], eax

; 2198 : 		// RWR Launch warning light
; 2199 : 		if (theRwr)

	cmp	DWORD PTR _theRwr$63[ebp], 0
	je	$LN198@VCock_Exec

; 2200 : 		{
; 2201 : 			if (theRwr->LaunchIndication() && (vuxRealTime & 0x200))

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?LaunchIndication@PlayerRwrClass@@QAEHXZ ; PlayerRwrClass::LaunchIndication
	test	eax, eax
	je	SHORT $LN197@VCock_Exec
	mov	ecx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	ecx, 512				; 00000200H
	je	SHORT $LN197@VCock_Exec

; 2202 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_LAUNCH, 1);

	push	1
	push	222					; 000000deH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2203 : 			else

	jmp	SHORT $LN196@VCock_Exec
$LN197@VCock_Exec:

; 2204 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_LAUNCH, 0);

	push	0
	push	222					; 000000deH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN196@VCock_Exec:

; 2205 : 
; 2206 : 			// RWR switches
; 2207 : 			if (theRwr->IsPriority() != FALSE)

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?IsPriority@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::IsPriority
	test	eax, eax
	je	SHORT $LN195@VCock_Exec

; 2208 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_PRIORITY, 2);

	push	2
	push	153					; 00000099H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2209 : 			else

	jmp	SHORT $LN194@VCock_Exec
$LN195@VCock_Exec:

; 2210 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_PRIORITY, 1);

	push	1
	push	153					; 00000099H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN194@VCock_Exec:

; 2211 : 
; 2212 : 			if (theRwr->TargetSep() != FALSE)

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?TargetSep@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::TargetSep
	test	eax, eax
	je	SHORT $LN193@VCock_Exec

; 2213 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_TGT_SEP, 2);

	push	2
	push	152					; 00000098H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2214 : 			else

	jmp	SHORT $LN192@VCock_Exec
$LN193@VCock_Exec:

; 2215 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_TGT_SEP, 1);

	push	1
	push	152					; 00000098H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN192@VCock_Exec:

; 2216 : 
; 2217 : 			if (theRwr->ShowUnknowns() != FALSE)

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?ShowUnknowns@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowUnknowns
	test	eax, eax
	je	SHORT $LN191@VCock_Exec

; 2218 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_UNKS, 2);

	push	2
	push	151					; 00000097H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2219 : 			else

	jmp	SHORT $LN190@VCock_Exec
$LN191@VCock_Exec:

; 2220 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_UNKS, 1);

	push	1
	push	151					; 00000097H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN190@VCock_Exec:

; 2221 : 
; 2222 : 			if (theRwr->ShowNaval() != FALSE)

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?ShowNaval@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowNaval
	test	eax, eax
	je	SHORT $LN189@VCock_Exec

; 2223 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_NAVAL, 2);

	push	2
	push	155					; 0000009bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2224 : 			else

	jmp	SHORT $LN188@VCock_Exec
$LN189@VCock_Exec:

; 2225 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_NAVAL, 1);

	push	1
	push	155					; 0000009bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN188@VCock_Exec:

; 2226 : 
; 2227 : 			if (theRwr->ShowLowAltPriority() != FALSE)

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ ; PlayerRwrClass::ShowLowAltPriority
	test	eax, eax
	je	SHORT $LN187@VCock_Exec

; 2228 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_GND_PRI, 2);

	push	2
	push	150					; 00000096H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2229 : 			else

	jmp	SHORT $LN186@VCock_Exec
$LN187@VCock_Exec:

; 2230 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_GND_PRI, 1);

	push	1
	push	150					; 00000096H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN186@VCock_Exec:

; 2231 : 
; 2232 : 			if (theRwr->ShowSearch() != FALSE)

	mov	ecx, DWORD PTR _theRwr$63[ebp]
	call	?ShowSearch@PlayerRwrClass@@QAEHXZ	; PlayerRwrClass::ShowSearch
	test	eax, eax
	je	SHORT $LN185@VCock_Exec

; 2233 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_SEARCH, 2);

	push	2
	push	149					; 00000095H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2234 : 			else

	jmp	SHORT $LN184@VCock_Exec
$LN185@VCock_Exec:

; 2235 : 				vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_SEARCH, 1);

	push	1
	push	149					; 00000095H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN184@VCock_Exec:

; 2236 : 
; 2237 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_HNDOFF, 1); // Momentary Sw

	push	1
	push	154					; 0000009aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN198@VCock_Exec:

; 2238 : 		}
; 2239 : 
; 2240 : 		// Master Arm switch
; 2241 : 		if (SimDriver.GetPlayerAircraft()->Sms->MasterArm() == SMSBaseClass::Arm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 2
	jne	SHORT $LN183@VCock_Exec

; 2242 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 2);

	push	2
	push	135					; 00000087H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN180@VCock_Exec
$LN183@VCock_Exec:

; 2243 : 		else if (SimDriver.GetPlayerAircraft()->Sms->MasterArm() ==  SMSBaseClass::Sim)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	cmp	eax, 1
	jne	SHORT $LN181@VCock_Exec

; 2244 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 4);

	push	4
	push	135					; 00000087H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2245 : 		else // safe

	jmp	SHORT $LN180@VCock_Exec
$LN181@VCock_Exec:

; 2246 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_MASTER_ARM, 1);

	push	1
	push	135					; 00000087H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN180@VCock_Exec:

; 2247 : 
; 2248 : 		// HUD Scale switch
; 2249 : 		if (TheHud->GetScalesSwitch() < 3)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetScalesSwitch@HudClass@@QAEHXZ	; HudClass::GetScalesSwitch
	cmp	eax, 3
	jge	SHORT $LN179@VCock_Exec

; 2250 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_VAH, 1<<(2 - TheHud->GetScalesSwitch()));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetScalesSwitch@HudClass@@QAEHXZ	; HudClass::GetScalesSwitch
	mov	ecx, 2
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	push	edx
	push	198					; 000000c6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2251 : 		else

	jmp	SHORT $LN178@VCock_Exec
$LN179@VCock_Exec:

; 2252 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_VAH, 1);

	push	1
	push	198					; 000000c6H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN178@VCock_Exec:

; 2253 : 		// HUD Pitch ladder switch
; 2254 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_FPM_LADD, 1<<TheHud->GetFPMSwitch());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetFPMSwitch@HudClass@@QAEHXZ		; HudClass::GetFPMSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	199					; 000000c7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2255 : 		// HUD Color wheel
; 2256 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_ICP_BRT_WHEEL, 1<<curColorIdx);

	mov	edx, 1
	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	shl	edx, cl
	push	edx
	push	146					; 00000092H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2257 : 		// HUD Contrast wheel
; 2258 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_ICP_BRT_WHEEL, 1<<((int)(TheHud->ContWheelPos*10)));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+5140]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	edx, 1
	shl	edx, cl
	push	edx
	push	146					; 00000092H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2259 : 		// ICP DriftCo switch
; 2260 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_ICP_DRIFTCO, 1<<TheHud->GetDriftCOSwitch());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDriftCOSwitch@HudClass@@QAEHXZ	; HudClass::GetDriftCOSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	129					; 00000081H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2261 : 		// Cat I/III switch
; 2262 : 		if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::CATLimiterIII))

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN177@VCock_Exec

; 2263 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_STORES_CAT, 2);

	push	2
	push	138					; 0000008aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2264 : 		else

	jmp	SHORT $LN176@VCock_Exec
$LN177@VCock_Exec:

; 2265 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_STORES_CAT, 1);

	push	1
	push	138					; 0000008aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN176@VCock_Exec:

; 2266 : 		// Thrust reverser switch
; 2267 : 		if (SimDriver.GetPlayerAircraft()->af->thrustReverse == 0)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	cmp	DWORD PTR [eax+1592], 0
	jne	SHORT $LN175@VCock_Exec

; 2268 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_REV_THRUSTER, 1);

	push	1
	push	218					; 000000daH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2269 : 		else

	jmp	SHORT $LN174@VCock_Exec
$LN175@VCock_Exec:

; 2270 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_REV_THRUSTER, 2);

	push	2
	push	218					; 000000daH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN174@VCock_Exec:

; 2271 : 		// HSI Course knob
; 2272 : 		int val = 1<<((int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_CRS)/36.0f));

	push	1
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv6707[ebp]
	movss	xmm0, DWORD PTR tv6707[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _val$65[ebp], edx

; 2273 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_COURSE, val);

	mov	eax, DWORD PTR _val$65[ebp]
	push	eax
	push	158					; 0000009eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2274 : 		// HSI Heading knob
; 2275 : 		val = 1<<((int)(OTWDriver.pCockpitManager->mpHsi->GetValue(CPHsi::HSI_VAL_DESIRED_HEADING)/36.0f));

	push	5
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+692]
	call	?GetValue@CPHsi@@QAEMW4HSIValues@1@@Z	; CPHsi::GetValue
	fstp	DWORD PTR tv6717[ebp]
	movss	xmm0, DWORD PTR tv6717[ebp]
	divss	xmm0, DWORD PTR __real@42100000
	cvttss2si ecx, xmm0
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _val$65[ebp], eax

; 2276 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_HEADING, val);

	mov	ecx, DWORD PTR _val$65[ebp]
	push	ecx
	push	157					; 0000009dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2277 : 		//
; 2278 : 		// MPO switch
; 2279 : 		if(SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::MPOverride))

	push	262144					; 00040000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN173@VCock_Exec

; 2280 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_MPO, 1);

	push	1
	push	174					; 000000aeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2281 : 		else

	jmp	SHORT $LN172@VCock_Exec
$LN173@VCock_Exec:

; 2282 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_MPO, 2);

	push	2
	push	174					; 000000aeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN172@VCock_Exec:

; 2283 : 		// Silence the horn
; 2284 : 		if (SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::HornSilenced))

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN171@VCock_Exec

; 2285 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_SILENCE_HORN, 2);

	push	2
	push	134					; 00000086H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2286 : 		else

	jmp	SHORT $LN170@VCock_Exec
$LN171@VCock_Exec:

; 2287 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_SILENCE_HORN, 1);

	push	1
	push	134					; 00000086H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN170@VCock_Exec:

; 2288 : 		// HSI Mode switch
; 2289 : 		if (gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_TACAN) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 2
	jne	SHORT $LN169@VCock_Exec

; 2290 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_MODE, 1);

	push	1
	push	156					; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2291 : 		else

	jmp	$LN162@VCock_Exec
$LN169@VCock_Exec:

; 2292 : 		if (gNavigationSys->GetInstrumentMode() == NavigationSystem::TACAN) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 3
	jne	SHORT $LN167@VCock_Exec

; 2293 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_MODE, 2);

	push	2
	push	156					; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2294 : 		else

	jmp	SHORT $LN162@VCock_Exec
$LN167@VCock_Exec:

; 2295 : 		if (gNavigationSys->GetInstrumentMode() == NavigationSystem::NAV) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	test	eax, eax
	jne	SHORT $LN165@VCock_Exec

; 2296 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_MODE, 4);

	push	4
	push	156					; 0000009cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2297 : 		else

	jmp	SHORT $LN162@VCock_Exec
$LN165@VCock_Exec:

; 2298 : 		if (gNavigationSys->GetInstrumentMode() == NavigationSystem::ILS_NAV) 

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetInstrumentMode@NavigationSystem@@QAE?AW4Instrument_Mode@1@XZ ; NavigationSystem::GetInstrumentMode
	cmp	eax, 1
	jne	SHORT $LN163@VCock_Exec

; 2299 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_MODE, 8);

	push	8
	push	156					; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2300 : 		else

	jmp	SHORT $LN162@VCock_Exec
$LN163@VCock_Exec:

; 2301 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HSI_MODE, 1);

	push	1
	push	156					; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN162@VCock_Exec:

; 2302 : 		// HUD DED/PFL switch
; 2303 : 		if (TheHud->GetDEDSwitch() == HudClass::PFL_DATA)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDEDSwitch@HudClass@@QAEHXZ		; HudClass::GetDEDSwitch
	cmp	eax, 2
	jne	SHORT $LN161@VCock_Exec

; 2304 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 2);

	push	2
	push	200					; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2305 : 		else

	jmp	SHORT $LN158@VCock_Exec
$LN161@VCock_Exec:

; 2306 : 		if (TheHud->GetDEDSwitch() == HudClass::DED_DATA)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetDEDSwitch@HudClass@@QAEHXZ		; HudClass::GetDEDSwitch
	test	eax, eax
	jne	SHORT $LN159@VCock_Exec

; 2307 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 4);

	push	4
	push	200					; 000000c8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2308 : 		else

	jmp	SHORT $LN158@VCock_Exec
$LN159@VCock_Exec:

; 2309 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_DED_PFL, 1);

	push	1
	push	200					; 000000c8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN158@VCock_Exec:

; 2310 : 		// HUD velocity switch
; 2311 : 		if (TheHud->GetVelocitySwitch() == HudClass::CAS)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetVelocitySwitch@HudClass@@QAEHXZ	; HudClass::GetVelocitySwitch
	test	eax, eax
	jne	SHORT $LN157@VCock_Exec

; 2312 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 4);

	push	4
	push	202					; 000000caH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2313 : 		else

	jmp	SHORT $LN154@VCock_Exec
$LN157@VCock_Exec:

; 2314 : 		if (TheHud->GetVelocitySwitch() == HudClass::TAS)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetVelocitySwitch@HudClass@@QAEHXZ	; HudClass::GetVelocitySwitch
	cmp	eax, 1
	jne	SHORT $LN155@VCock_Exec

; 2315 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 2);

	push	2
	push	202					; 000000caH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2316 : 		else

	jmp	SHORT $LN154@VCock_Exec
$LN155@VCock_Exec:

; 2317 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_VELOCITY, 1);

	push	1
	push	202					; 000000caH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN154@VCock_Exec:

; 2318 : 		// HUD radar altitude switch (RAL/BARO)
; 2319 : 		if (TheHud->GetRadarSwitch() == HudClass::ALT_RADAR)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetRadarSwitch@HudClass@@QAEHXZ	; HudClass::GetRadarSwitch
	test	eax, eax
	jne	SHORT $LN153@VCock_Exec

; 2320 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 4);

	push	4
	push	203					; 000000cbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2321 : 		else

	jmp	SHORT $LN150@VCock_Exec
$LN153@VCock_Exec:

; 2322 : 		if (TheHud->GetRadarSwitch() == HudClass::BARO)

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetRadarSwitch@HudClass@@QAEHXZ	; HudClass::GetRadarSwitch
	cmp	eax, 1
	jne	SHORT $LN151@VCock_Exec

; 2323 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 2);

	push	2
	push	203					; 000000cbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2324 : 		else

	jmp	SHORT $LN150@VCock_Exec
$LN151@VCock_Exec:

; 2325 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_RAL_BARO, 1);

	push	1
	push	203					; 000000cbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN150@VCock_Exec:

; 2326 : 		// HUD brightness switch
; 2327 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_DAY_NITE, 1<<TheHud->GetBrightnessSwitch());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetBrightnessSwitch@HudClass@@QAEHXZ	; HudClass::GetBrightnessSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	204					; 000000ccH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2328 : 		// Chaff Remaining units digit
; 2329 : 		if(((AircraftClass*)(SimDriver.GetPlayerEntity()))->HasPower(AircraftClass::ChaffFlareCount))

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	$LN149@VCock_Exec

; 2330 : 		{
; 2331 : 			val = ((AircraftClass*)(SimDriver.GetPlayerEntity()))->counterMeasureStation[CHAFF_STATION].weaponCount;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, 20					; 00000014H
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx+1110]
	mov	DWORD PTR _val$65[ebp], edx

; 2332 : 			vrCockpit->SetDOFangle( COMP_3DPIT_CHAFF_DIGIT1, ExtractDigit((float)val, 0) * 0.6283F);

	push	0
	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	155					; 0000009bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2333 : 			vrCockpit->SetDOFangle( COMP_3DPIT_CHAFF_DIGIT2, ExtractDigit((float)val, 1) * 0.6283F);

	push	1
	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	156					; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2334 : 			vrCockpit->SetDOFangle( COMP_3DPIT_CHAFF_DIGIT3, ExtractDigit((float)val, 2) * 0.6283F);

	push	2
	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	157					; 0000009dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN149@VCock_Exec:

; 2335 : 		}
; 2336 : 		// Flare Remaining units digit
; 2337 : 		if(((AircraftClass*)(SimDriver.GetPlayerEntity()))->HasPower(AircraftClass::ChaffFlareCount))

	push	1048576					; 00100000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	$LN148@VCock_Exec

; 2338 : 		{
; 2339 : 			val = ((AircraftClass*)(SimDriver.GetPlayerEntity()))->counterMeasureStation[FLARE_STATION].weaponCount;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, 20					; 00000014H
	imul	ecx, 0
	movsx	edx, WORD PTR [eax+ecx+1110]
	mov	DWORD PTR _val$65[ebp], edx

; 2340 : 			vrCockpit->SetDOFangle( COMP_3DPIT_FLARE_DIGIT1, ExtractDigit((float)val, 0) * 0.6283F);

	push	0
	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	158					; 0000009eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2341 : 			vrCockpit->SetDOFangle( COMP_3DPIT_FLARE_DIGIT2, ExtractDigit((float)val, 1) * 0.6283F);

	push	1
	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	159					; 0000009fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2342 : 			vrCockpit->SetDOFangle( COMP_3DPIT_FLARE_DIGIT3, ExtractDigit((float)val, 2) * 0.6283F);

	push	2
	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?ExtractDigit@@YAHMH@Z			; ExtractDigit
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	160					; 000000a0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle
$LN148@VCock_Exec:

; 2343 : 		}
; 2344 : 		// Aux Comm Tacan channel left digit
; 2345 : 		val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 2);

	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$65[ebp], eax

; 2346 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TACAN_LEFT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	145					; 00000091H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2347 : 		// Aux Comm Tacan channel middle digit
; 2348 : 		val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 1);

	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$65[ebp], eax

; 2349 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TACAN_CENTER, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	146					; 00000092H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2350 : 		// Aux Comm Tacan channel right digit
; 2351 : 		val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 0);

	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$65[ebp], eax

; 2352 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TACAN_RIGHT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	147					; 00000093H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2353 : 		// Aux Comm Tacan channel band (X/Y)
; 2354 : 		if(gNavigationSys->GetTacanBand(NavigationSystem::AUXCOMM) == TacanList::X)

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanBand@NavigationSystem@@QAE?AW4StationSet@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::GetTacanBand
	test	eax, eax
	jne	SHORT $LN147@VCock_Exec

; 2355 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_TACAN_BAND, 1);

	push	1
	push	182					; 000000b6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2356 : 		else

	jmp	SHORT $LN146@VCock_Exec
$LN147@VCock_Exec:

; 2357 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_TACAN_BAND, 2);

	push	2
	push	182					; 000000b6H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN146@VCock_Exec:

; 2358 : 		// Aux Comm source switch
; 2359 : 		if(gNavigationSys->GetControlSrc() == NavigationSystem::AUXCOMM)

	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetControlSrc@NavigationSystem@@QAE?AW4Tacan_Channel_Src@1@XZ ; NavigationSystem::GetControlSrc
	cmp	eax, 1
	jne	SHORT $LN145@VCock_Exec

; 2360 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AUX_COMM_SRC, 1);

	push	1
	push	181					; 000000b5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2361 : 		else

	jmp	SHORT $LN144@VCock_Exec
$LN145@VCock_Exec:

; 2362 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AUX_COMM_SRC, 2);

	push	2
	push	181					; 000000b5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN144@VCock_Exec:

; 2363 : 		// Aux Comm Master switch
; 2364 : 		val = gNavigationSys->GetDomain(NavigationSystem::AUXCOMM)+1;

	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetDomain@NavigationSystem@@QAE?AW4Domain@TacanList@@W4Tacan_Channel_Src@1@@Z ; NavigationSystem::GetDomain
	add	eax, 1
	mov	DWORD PTR _val$65[ebp], eax

; 2365 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_AUX_COMM_MSTR, val);

	mov	ecx, DWORD PTR _val$65[ebp]
	push	ecx
	push	180					; 000000b4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2366 : 		// EPU switch
; 2367 : 		val = 1<<SimDriver.GetPlayerAircraft()->af->GetEpuSwitch();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetEpuSwitch@AirframeClass@@QAE?AW4EpuState@1@XZ ; AirframeClass::GetEpuSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _val$65[ebp], edx

; 2368 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EPU, val);

	mov	eax, DWORD PTR _val$65[ebp]
	push	eax
	push	178					; 000000b2H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2369 : 		// Alt gear switch/lever
; 2370 : 		if (SimDriver.GetPlayerAircraft()->af->altGearDeployed == true)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	movzx	eax, BYTE PTR [edx+1572]
	cmp	eax, 1
	jne	SHORT $LN143@VCock_Exec

; 2371 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ALT_GEAR, 2);

	push	2
	push	140					; 0000008cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2372 : 		else

	jmp	SHORT $LN142@VCock_Exec
$LN143@VCock_Exec:

; 2373 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ALT_GEAR, 1);

	push	1
	push	140					; 0000008cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN142@VCock_Exec:

; 2374 : 		// HUD Radar altitude switch
; 2375 : 		if(SimDriver.GetPlayerAircraft()->af->platform->RALTStatus == AircraftClass::RaltStatus::ROFF)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [eax+1088]
	cmp	DWORD PTR [ecx+1004], 0
	jne	SHORT $LN141@VCock_Exec

; 2376 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RALT_PWR, 1);

	push	1
	push	197					; 000000c5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2377 : 		else

	jmp	$LN136@VCock_Exec
$LN141@VCock_Exec:

; 2378 : 		if(SimDriver.GetPlayerAircraft()->af->platform->RALTStatus == AircraftClass::RaltStatus::RON)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [eax+1088]
	cmp	DWORD PTR [ecx+1004], 2
	jne	SHORT $LN139@VCock_Exec

; 2379 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RALT_PWR, 4);

	push	4
	push	197					; 000000c5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2380 : 		else

	jmp	SHORT $LN136@VCock_Exec
$LN139@VCock_Exec:

; 2381 : 		if(SimDriver.GetPlayerAircraft()->af->platform->RALTStatus == AircraftClass::RaltStatus::RSTANDBY)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+932]
	mov	ecx, DWORD PTR [eax+1088]
	cmp	DWORD PTR [ecx+1004], 1
	jne	SHORT $LN137@VCock_Exec

; 2382 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RALT_PWR, 2);

	push	2
	push	197					; 000000c5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2383 : 		else

	jmp	SHORT $LN136@VCock_Exec
$LN137@VCock_Exec:

; 2384 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RALT_PWR, 1);

	push	1
	push	197					; 000000c5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN136@VCock_Exec:

; 2385 : 		// JSF start switch
; 2386 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_JSF_START, SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::JfsStart+1));

	push	268435457				; 10000001H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	push	eax
	push	176					; 000000b0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2387 : 		// SMS power switch
; 2388 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_SMS_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::SMSPower));

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	210					; 000000d2H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2389 : 		// FCC power switch
; 2390 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_FCC_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::FCCPower));

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	209					; 000000d1H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2391 : 		// MFD power switch
; 2392 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_MFD_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::MFDPower));

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	211					; 000000d3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2393 : 		// UFC power switch
; 2394 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_UFC_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::UFCPower));

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	212					; 000000d4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2395 : 		// GPS power switch
; 2396 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_GPS_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::GPSPower));

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	213					; 000000d5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2397 : 		// DL power switch
; 2398 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_DL_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::DLPower));

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	214					; 000000d6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2399 : 		// MAP power switch
; 2400 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_MAP_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::MAPPower));

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	215					; 000000d7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2401 : 		// Right hardpoints power switch
; 2402 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_RIGHT_HPT_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::RightHptPower));

	push	256					; 00000100H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	195					; 000000c3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2403 : 		// Left hardpoints power switch
; 2404 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_LEFT_HPT_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::LeftHptPower));

	push	128					; 00000080H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	194					; 000000c2H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2405 : 		// HUD power switch
; 2406 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::HUDPower));

	push	2048					; 00000800H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	147					; 00000093H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2407 : 		// FCR power switch
; 2408 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_FCR_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::FCRPower));

	push	1024					; 00000400H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	196					; 000000c4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2409 : 		// Fuel Control switch
; 2410 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_FUEL_QTY, 1<<(SimDriver.GetPlayerAircraft()->af->GetFuelSwitch()));

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetFuelSwitch@AirframeClass@@QAE?AW4FuelSwitch@1@XZ ; AirframeClass::GetFuelSwitch
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	159					; 0000009fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2411 : 		// Fuel pump switch
; 2412 : 		val = SimDriver.GetPlayerAircraft()->af->GetFuelPump()+1;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetFuelPump@AirframeClass@@QAE?AW4FuelPump@1@XZ ; AirframeClass::GetFuelPump
	add	eax, 1
	mov	DWORD PTR _val$65[ebp], eax

; 2413 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_REFUEL_PUMP, val);

	mov	ecx, DWORD PTR _val$65[ebp]
	push	ecx
	push	184					; 000000b8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2414 : 		// Refuel master switch
; 2415 : 		if (SimDriver.GetPlayerAircraft()->af->IsEngineFlag(AirframeClass::MasterFuelOff))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN135@VCock_Exec

; 2416 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_REFUEL_MSTR, 1);

	push	1
	push	185					; 000000b9H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2417 : 		else

	jmp	SHORT $LN134@VCock_Exec
$LN135@VCock_Exec:

; 2418 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_REFUEL_MSTR, 2);

	push	2
	push	185					; 000000b9H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN134@VCock_Exec:

; 2419 : 		// Air source switch
; 2420 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_AIR_SOURCE, 1<<SimDriver.GetPlayerAircraft()->af->GetAirSource());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?GetAirSource@AirframeClass@@QAE?AW4AirSource@1@XZ ; AirframeClass::GetAirSource
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	207					; 000000cfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2421 : 		// Landing lights switch
; 2422 : 		if (SimDriver.GetPlayerAircraft()->IsAcStatusBitsSet(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT))

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN133@VCock_Exec

; 2423 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LAND_LIGHT, 2);

	push	2
	push	219					; 000000dbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2424 : 		else

	jmp	SHORT $LN132@VCock_Exec
$LN133@VCock_Exec:

; 2425 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LAND_LIGHT, 1);

	push	1
	push	219					; 000000dbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN132@VCock_Exec:

; 2426 : 		// Parking brake switch
; 2427 : 		if (SimDriver.GetPlayerAircraft()->af->PBON == TRUE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movzx	edx, BYTE PTR [ecx+1616]
	cmp	edx, 1
	jne	SHORT $LN131@VCock_Exec

; 2428 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 2);

	push	2
	push	141					; 0000008dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2429 : 		else

	jmp	SHORT $LN130@VCock_Exec
$LN131@VCock_Exec:

; 2430 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_PARK_BRAKE, 1);

	push	1
	push	141					; 0000008dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN130@VCock_Exec:

; 2431 : 		// Hook switch
; 2432 : 		if (SimDriver.GetPlayerAircraft()->af->IsSet(AirframeClass::Hook))

	push	-2147483648				; 80000000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN129@VCock_Exec

; 2433 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HOOK, 2);

	push	2
	push	139					; 0000008bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2434 : 		else

	jmp	SHORT $LN128@VCock_Exec
$LN129@VCock_Exec:

; 2435 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HOOK, 1);

	push	1
	push	139					; 0000008bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN128@VCock_Exec:

; 2436 : 		// Laser switch
; 2437 : 		if (SimDriver.GetPlayerAircraft()->FCC->LaserArm)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	movzx	edx, BYTE PTR [ecx+420]
	test	edx, edx
	je	SHORT $LN127@VCock_Exec

; 2438 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LASER_ARM, 2);

	push	2
	push	144					; 00000090H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2439 : 		else

	jmp	SHORT $LN126@VCock_Exec
$LN127@VCock_Exec:

; 2440 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LASER_ARM, 1);

	push	1
	push	144					; 00000090H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN126@VCock_Exec:

; 2441 : 		// Refuel door switch
; 2442 : 		if (SimDriver.GetPlayerAircraft()->af->IsEngineFlag(AirframeClass::FuelDoorOpen))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN125@VCock_Exec

; 2443 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_REFUEL_DOOR, 2);

	push	2
	push	183					; 000000b7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2444 : 		else

	jmp	SHORT $LN124@VCock_Exec
$LN125@VCock_Exec:

; 2445 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_REFUEL_DOOR, 1);

	push	1
	push	183					; 000000b7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN124@VCock_Exec:

; 2446 : 		// Autopilot left switch
; 2447 : 			// Left switch Middle position
; 2448 : 		if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::RollHold))

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN123@VCock_Exec

; 2449 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 4);

	push	4
	push	137					; 00000089H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN120@VCock_Exec
$LN123@VCock_Exec:

; 2450 : 			// Left switch down position
; 2451 : 		else if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::StrgSel))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN121@VCock_Exec

; 2452 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 1);

	push	1
	push	137					; 00000089H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2453 : 			// Left switch up position
; 2454 : 		else

	jmp	SHORT $LN120@VCock_Exec
$LN121@VCock_Exec:

; 2455 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LT_AP_SW, 2);

	push	2
	push	137					; 00000089H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN120@VCock_Exec:

; 2456 : 		// Autopilot left switch
; 2457 : 			// Right switch up position
; 2458 : 		if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AltHold))

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN119@VCock_Exec

; 2459 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 4);

	push	4
	push	136					; 00000088H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN116@VCock_Exec
$LN119@VCock_Exec:

; 2460 : 			// Right switch down position
; 2461 : 		else if(SimDriver.GetPlayerAircraft()->IsOn(AircraftClass::AttHold))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z	; AircraftClass::IsOn
	test	eax, eax
	je	SHORT $LN117@VCock_Exec

; 2462 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 1);

	push	1
	push	136					; 00000088H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2463 : 			// Right switch middle position (off)
; 2464 : 		else

	jmp	SHORT $LN116@VCock_Exec
$LN117@VCock_Exec:

; 2465 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RT_AP_SW, 1);

	push	1
	push	136					; 00000088H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN116@VCock_Exec:

; 2466 : 		// HUD reticle switch
; 2467 : 		if (TheHud->WhichMode == 1)	// PRI

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [ecx+5016], 1
	jne	SHORT $LN115@VCock_Exec

; 2468 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 2);

	push	2
	push	201					; 000000c9H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN115@VCock_Exec:

; 2469 : 		if (TheHud->WhichMode == 2)	// STBY

	mov	eax, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [eax+5016], 2
	jne	SHORT $LN114@VCock_Exec

; 2470 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 4);

	push	4
	push	201					; 000000c9H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN114@VCock_Exec:

; 2471 : 		if (TheHud->WhichMode == 0)	// Off

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	cmp	DWORD PTR [edx+5016], 0
	jne	SHORT $LN113@VCock_Exec

; 2472 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_HUD_RETICLE, 1);

	push	1
	push	201					; 000000c9H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN113@VCock_Exec:

; 2473 : 		// Interior light switch
; 2474 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_INTERIOR_LITE, 1<<SimDriver.GetPlayerAircraft()->GetInteriorLight());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInteriorLight
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	205					; 000000cdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2475 : 		// Instrument light switch
; 2476 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_INSTR_LITE, 1<<SimDriver.GetPlayerAircraft()->GetInstrumentLight());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetInstrumentLight
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	206					; 000000ceH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2477 : 		// Spot light switch
; 2478 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_SPOT_LITE, 1<<SimDriver.GetPlayerAircraft()->GetSpotLight());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ; AircraftClass::GetSpotLight
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	217					; 000000d9H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2479 : 		// EWS RWR power switch
; 2480 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EWS_RWR_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSRWRPower));

	push	4096					; 00001000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	161					; 000000a1H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2481 : 		// EWS jammer power
; 2482 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EWS_JMR_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSJammerPower));

	push	8192					; 00002000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	162					; 000000a2H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2483 : 		// EWS chaff power
; 2484 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EWS_CHAFF_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSChaffPower));

	push	16384					; 00004000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	163					; 000000a3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2485 : 		// EWS flares
; 2486 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EWS_FLARE_PWR, 1<<SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::EWSFlarePower));

	push	32768					; 00008000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	164					; 000000a4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2487 : 		// EWS PGM switch
; 2488 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EWS_MODE, 1<<SimDriver.GetPlayerAircraft()->EWSPGM());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ; AircraftClass::EWSPGM
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	165					; 000000a5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2489 : 		// EWS Program switch
; 2490 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_EWS_PROG, 1<<SimDriver.GetPlayerAircraft()->EWSProgNum);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+1500]
	shl	edx, cl
	push	edx
	push	166					; 000000a6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2491 : 		// Main power switch
; 2492 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_MAIN_PWR, 1<<SimDriver.GetPlayerAircraft()->mainPower);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+1484]
	shl	edx, cl
	push	edx
	push	177					; 000000b1H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2493 : 		// Silence Betty (VMS)
; 2494 : 		if (SimDriver.GetPlayerAircraft()->playBetty)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+1516]
	test	ecx, ecx
	je	SHORT $LN112@VCock_Exec

; 2495 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_VMS_PWR, 1);

	push	1
	push	208					; 000000d0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2496 : 		else

	jmp	SHORT $LN111@VCock_Exec
$LN112@VCock_Exec:

; 2497 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_VMS_PWR, 2);

	push	2
	push	208					; 000000d0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN111@VCock_Exec:

; 2498 : 		// RF emissions switch
; 2499 : 		if(SimDriver.GetPlayerAircraft()->RFState == 0)				//NORM	

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 0
	jne	SHORT $LN110@VCock_Exec

; 2500 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RF_QUIET, 2);

	push	2
	push	142					; 0000008eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN107@VCock_Exec
$LN110@VCock_Exec:

; 2501 : 		else if(SimDriver.GetPlayerAircraft()->RFState == 2) 	//SILENT --> No CARA, no TFR, no Radar

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 2
	jne	SHORT $LN108@VCock_Exec

; 2502 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RF_QUIET, 4);

	push	4
	push	142					; 0000008eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2503 : 		else 

	jmp	SHORT $LN107@VCock_Exec
$LN108@VCock_Exec:

; 2504 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RF_QUIET, 1);	//QUIET --> no Radar	

	push	1
	push	142					; 0000008eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN107@VCock_Exec:

; 2505 : 		// RWR power switch
; 2506 : 		if (theRwr && theRwr->IsOn())

	cmp	DWORD PTR _theRwr$63[ebp], 0
	je	SHORT $LN106@VCock_Exec
	mov	ecx, DWORD PTR _theRwr$63[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theRwr$63[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	test	eax, eax
	je	SHORT $LN106@VCock_Exec

; 2507 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_PWR, 2);

	push	2
	push	148					; 00000094H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2508 : 		else

	jmp	SHORT $LN105@VCock_Exec
$LN106@VCock_Exec:

; 2509 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_RWR_PWR, 1);

	push	1
	push	148					; 00000094H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN105@VCock_Exec:

; 2510 : 		// External light power switch
; 2511 : 		if(SimDriver.GetPlayerAircraft()->ExtlState(AircraftClass::ExtlLightFlags::Extl_Main_Power))

	push	4
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN104@VCock_Exec

; 2512 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 2);

	push	2
	push	186					; 000000baH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2513 : 		else

	jmp	SHORT $LN103@VCock_Exec
$LN104@VCock_Exec:

; 2514 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EXT_LITE_MSTR, 1);

	push	1
	push	186					; 000000baH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN103@VCock_Exec:

; 2515 : 
; 2516 : 		//int LightPwr = 0;
; 2517 : 		//if(SimDriver.GetPlayerAircraft()->ExtlState(AircraftClass::ExtlLightFlags::Extl_Main_Power))
; 2518 : 		//	LightPwr = 1;
; 2519 : 		//else
; 2520 : 		//	LightPwr = 0;
; 2521 : 		// External collision light switch
; 2522 : 		if(SimDriver.GetPlayerAircraft()->ExtlState(AircraftClass::ExtlLightFlags::Extl_Anti_Coll))

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN102@VCock_Exec

; 2523 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 2);

	push	2
	push	187					; 000000bbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2524 : 		else

	jmp	SHORT $LN101@VCock_Exec
$LN102@VCock_Exec:

; 2525 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ANTI_COLL, 1);

	push	1
	push	187					; 000000bbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN101@VCock_Exec:

; 2526 : 		// External light flash switch
; 2527 : 		if(SimDriver.GetPlayerAircraft()->ExtlState(AircraftClass::ExtlLightFlags::Extl_Flash))

	push	64					; 00000040H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN100@VCock_Exec

; 2528 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EXT_FLASH, 2);

	push	2
	push	188					; 000000bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2529 : 		else

	jmp	SHORT $LN99@VCock_Exec
$LN100@VCock_Exec:

; 2530 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EXT_FLASH, 1);

	push	1
	push	188					; 000000bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN99@VCock_Exec:

; 2531 : 		// External collision wing/tail switch
; 2532 : 		if(SimDriver.GetPlayerAircraft()->ExtlState(AircraftClass::ExtlLightFlags::Extl_Wing_Tail))

	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	je	SHORT $LN98@VCock_Exec

; 2533 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EXT_WING, 2);

	push	2
	push	189					; 000000bdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2534 : 		else

	jmp	SHORT $LN97@VCock_Exec
$LN98@VCock_Exec:

; 2535 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_EXT_WING, 1);

	push	1
	push	189					; 000000bdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN97@VCock_Exec:

; 2536 : 		// AVTR SWITCH
; 2537 : 		if(SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_AUTO))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN96@VCock_Exec

; 2538 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AVTR_SW, 2);

	push	2
	push	173					; 000000adH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN93@VCock_Exec
$LN96@VCock_Exec:

; 2539 : 		else if(SimDriver.GetPlayerAircraft()->AVTRState(AircraftClass::AVTRStateFlags::AVTR_ON))

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ; AircraftClass::AVTRState
	test	eax, eax
	je	SHORT $LN94@VCock_Exec

; 2540 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AVTR_SW, 4);

	push	4
	push	173					; 000000adH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2541 : 		else

	jmp	SHORT $LN93@VCock_Exec
$LN94@VCock_Exec:

; 2542 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_AVTR_SW, 1);

	push	1
	push	173					; 000000adH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN93@VCock_Exec:

; 2543 : 		// IFF power switch
; 2544 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_IFF_PWR, SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::IFFPower)+1);

	push	2097152					; 00200000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	add	eax, 1
	push	eax
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2545 : 		// IFF query switch
; 2546 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_IFF_QUERY, 1);

	push	1
	push	143					; 0000008fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2547 : 		// INS switch							COMP_3DPIT_IFF_PWR
; 2548 : 		if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_AlignNorm))

	push	2
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN92@VCock_Exec

; 2549 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INS_MODE, 2);

	push	2
	push	216					; 000000d8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN87@VCock_Exec
$LN92@VCock_Exec:

; 2550 : 		else if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_Nav))

	push	32					; 00000020H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN90@VCock_Exec

; 2551 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INS_MODE, 4);

	push	4
	push	216					; 000000d8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
	jmp	SHORT $LN87@VCock_Exec
$LN90@VCock_Exec:

; 2552 : 		else if(SimDriver.GetPlayerAircraft()->INSState(AircraftClass::INS_AlignFlight))

	push	16					; 00000010H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN88@VCock_Exec

; 2553 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INS_MODE, 8);

	push	8
	push	216					; 000000d8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2554 : 		else

	jmp	SHORT $LN87@VCock_Exec
$LN88@VCock_Exec:

; 2555 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_INS_MODE, 1);

	push	1
	push	216					; 000000d8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN87@VCock_Exec:

; 2556 : 		// LEF lock switch 
; 2557 : 		if(SimDriver.GetPlayerAircraft()->LEFLocked)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+853]
	test	edx, edx
	je	SHORT $LN86@VCock_Exec

; 2558 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LEF_FLAPS, 2);

	push	2
	push	192					; 000000c0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2559 : 		else

	jmp	SHORT $LN85@VCock_Exec
$LN86@VCock_Exec:

; 2560 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_LEF_FLAPS, 1);

	push	1
	push	192					; 000000c0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN85@VCock_Exec:

; 2561 : 		// Alt flaps switch
; 2562 : 		if (SimDriver.GetPlayerAircraft()->TEFExtend == TRUE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+851]
	cmp	edx, 1
	jne	SHORT $LN84@VCock_Exec

; 2563 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ALT_FLAPS, 2);

	push	2
	push	193					; 000000c1H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2564 : 		else

	jmp	SHORT $LN83@VCock_Exec
$LN84@VCock_Exec:

; 2565 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_ALT_FLAPS, 1);

	push	1
	push	193					; 000000c1H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN83@VCock_Exec:

; 2566 : 		// AP Trim switch
; 2567 : 		if(SimDriver.GetPlayerAircraft()->TrimAPDisc == TRUE)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	edx, BYTE PTR [eax+850]
	cmp	edx, 1
	jne	SHORT $LN82@VCock_Exec

; 2568 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_TRIM_AP, 2);

	push	2
	push	191					; 000000bfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2569 : 		else 

	jmp	SHORT $LN81@VCock_Exec
$LN82@VCock_Exec:

; 2570 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_TRIM_AP, 1);

	push	1
	push	191					; 000000bfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN81@VCock_Exec:

; 2571 : 		// Pitch trim
; 2572 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TRIM_PITCH, cockpitFlightData.TrimPitch );

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+236
	movss	DWORD PTR [esp], xmm0
	push	148					; 00000094H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2573 : 		val = (int)(5.0f + (cockpitFlightData.TrimPitch*10.0f)); // 5 + (+/-5)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+236
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@40a00000
	cvttss2si eax, xmm0
	mov	DWORD PTR _val$65[ebp], eax

; 2574 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_TRIM_PITCH_SW, val);

	mov	ecx, DWORD PTR _val$65[ebp]
	push	ecx
	push	81					; 00000051H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2575 : 		// Yaw trim
; 2576 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TRIM_YAW, cockpitFlightData.TrimYaw );

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+244
	movss	DWORD PTR [esp], xmm0
	push	149					; 00000095H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2577 : 		val = (int)(5.0f + (cockpitFlightData.TrimYaw*10.0f)); // 5 + (+/-5)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+244
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@40a00000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _val$65[ebp], ecx

; 2578 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_TRIM_YAW_SW, (int)(cockpitFlightData.TrimYaw));

	cvttss2si edx, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+244
	push	edx
	push	82					; 00000052H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2579 : 		// Roll trim
; 2580 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TRIM_ROLL, cockpitFlightData.TrimRoll );

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+240
	movss	DWORD PTR [esp], xmm0
	push	150					; 00000096H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2581 : 		val = (int)(5.0f + (cockpitFlightData.TrimRoll*10.0f)); // 5 + (+/-5)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+240
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@40a00000
	cvttss2si edx, xmm0
	mov	DWORD PTR _val$65[ebp], edx

; 2582 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_TRIM_ROLL_SW, (int)(cockpitFlightData.TrimRoll));

	cvttss2si eax, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+240
	push	eax
	push	83					; 00000053H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2583 : 		// Comm - Missile volume
; 2584 : 		val = 1<<(8 - SimDriver.GetPlayerAircraft()->MissileVolume);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+876]
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _val$65[ebp], edx

; 2585 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_MISSILE_VOL, val);

	mov	eax, DWORD PTR _val$65[ebp]
	push	eax
	push	171					; 000000abH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2586 : 		// Comm - Threat volume
; 2587 : 		val = 1<<(8 - SimDriver.GetPlayerAircraft()->ThreatVolume);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+880]
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _val$65[ebp], edx

; 2588 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_THREAT_VOL, val);

	mov	eax, DWORD PTR _val$65[ebp]
	push	eax
	push	172					; 000000acH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2589 : 		// Comm1 volume switch
; 2590 : 		val = 1<<(8 - OTWDriver.pCockpitManager->mpIcp->Comm1Volume);

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+1668]
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _val$65[ebp], edx

; 2591 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_COMM1_VOL, val);

	mov	eax, DWORD PTR _val$65[ebp]
	push	eax
	push	169					; 000000a9H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2592 : 		// Comm2 volume switch
; 2593 : 		val = 1<<(8 - OTWDriver.pCockpitManager->mpIcp->Comm2Volume);

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, 8
	sub	ecx, DWORD PTR [eax+1672]
	mov	edx, 1
	shl	edx, cl
	mov	DWORD PTR _val$65[ebp], edx

; 2594 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_COMM2_VOL, val);

	mov	eax, DWORD PTR _val$65[ebp]
	push	eax
	push	170					; 000000aaH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2595 : 		// Fuel transfer switch
; 2596 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_FUEL_EXT_TRANS, 1<<SimDriver.GetPlayerAircraft()->af->IsEngineFlag(AirframeClass::WingFirst));

	push	1
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2597 : 		// Sym wheel switch
; 2598 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_ICP_SYM_WHEEL, 1<<((int)(TheHud->SymWheelPos*10.0f)));

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR [ecx+5136]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	edx, 1
	shl	edx, cl
	push	edx
	push	145					; 00000091H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2599 : 		// Canopy switch
; 2600 : 		if (SimDriver.GetPlayerAircraft()->af->canopyState == true)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+932]
	movzx	edx, BYTE PTR [ecx+1588]
	cmp	edx, 1
	jne	SHORT $LN80@VCock_Exec

; 2601 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_CANOPY, 2);

	push	2
	push	175					; 000000afH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2602 : 		else

	jmp	SHORT $LN79@VCock_Exec
$LN80@VCock_Exec:

; 2603 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_CANOPY, 1);

	push	1
	push	175					; 000000afH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN79@VCock_Exec:

; 2604 : 		// Drag chute switch
; 2605 : 		if (SimDriver.GetPlayerAircraft()->af->dragChute == AirframeClass::DRAGC_STOWED)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+932]
	cmp	DWORD PTR [edx+1584], 0
	jne	SHORT $LN78@VCock_Exec

; 2606 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_DRAGCHUTE, 1);

	push	1
	push	220					; 000000dcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2607 : 		else

	jmp	SHORT $LN77@VCock_Exec
$LN78@VCock_Exec:

; 2608 : 			vrCockpit->SetSwitchMask( COMP_3DPIT_DRAGCHUTE, 2);

	push	2
	push	220					; 000000dcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN77@VCock_Exec:

; 2609 : 		// ICP Previous/Next rocker OFF
; 2610 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_ICP_NEXT, 1);

	push	1
	push	132					; 00000084H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2611 : 		// ICP DED rocker OFF
; 2612 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_ICP_DED, 1);

	push	1
	push	131					; 00000083H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 2613 : 		// TACAN channel
; 2614 : 		val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 2);

	push	2
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$65[ebp], eax

; 2615 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TACAN_LEFT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	145					; 00000091H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2616 : 		val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 1);

	push	1
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$65[ebp], eax

; 2617 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TACAN_CENTER, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	146					; 00000092H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2618 : 		val = gNavigationSys->GetTacanChannel(NavigationSystem::AUXCOMM, 0);

	push	0
	push	1
	mov	ecx, DWORD PTR ?gNavigationSys@@3PAVNavigationSystem@@A ; gNavigationSys
	call	?GetTacanChannel@NavigationSystem@@QAEHW4Tacan_Channel_Src@1@H@Z ; NavigationSystem::GetTacanChannel
	mov	DWORD PTR _val$65[ebp], eax

; 2619 : 		vrCockpit->SetDOFangle( COMP_3DPIT_TACAN_RIGHT, val * 0.6283F);

	cvtsi2ss xmm0, DWORD PTR _val$65[ebp]
	mulss	xmm0, DWORD PTR __real@3f20d845
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	147					; 00000093H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33996]
	call	?SetDOFangle@DrawableBSP@@QAEXHM@Z	; DrawableBSP::SetDOFangle

; 2620 : 		// Ejection Seat Arm switch
; 2621 : 		vrCockpit->SetSwitchMask( COMP_3DPIT_SEAT_ARM, SimDriver.GetPlayerAircraft()->SeatArmed+1);

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	movzx	ecx, BYTE PTR [eax+1052]
	add	ecx, 1
	push	ecx
	push	221					; 000000ddH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33996]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN370@VCock_Exec:

; 2622 : 
; 2623 : 		// end New 3D pit switch/knob animation
; 2624 : 	} //ATARIBABY new 3dpit end
; 2625 : 
; 2626 : 
; 2627 : 	// Scale to 3D world coords the rtt positions
; 2628 : 	Tpoint	Pan=headPan;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33664				; 00008380H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Pan$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _Pan$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _Pan$[ebp+8], eax

; 2629 : 	Pan.z*=RTT_POSITION_SCALING;

	movss	xmm0, DWORD PTR _Pan$[ebp+8]
	mulss	xmm0, DWORD PTR __real@4125999a
	movss	DWORD PTR _Pan$[ebp+8], xmm0

; 2630 : 	Pan.y*=RTT_POSITION_SCALING;

	movss	xmm0, DWORD PTR _Pan$[ebp+4]
	mulss	xmm0, DWORD PTR __real@4125999a
	movss	DWORD PTR _Pan$[ebp+4], xmm0

; 2631 : 	Pan.x*=RTT_POSITION_SCALING;

	movss	xmm0, DWORD PTR _Pan$[ebp]
	mulss	xmm0, DWORD PTR __real@4125999a
	movss	DWORD PTR _Pan$[ebp], xmm0

; 2632 : 	renderer->SetCamera( &Pan, &headMatrix );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33616				; 00008350H
	push	ecx
	lea	edx, DWORD PTR _Pan$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera

; 2633 : 
; 2634 : 
; 2635 : // ASSO: BEGIN
; 2636 : 	if( renderer->HasRttTarget() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?HasRttTarget@VirtualDisplay@@QAEHXZ	; VirtualDisplay::HasRttTarget
	test	eax, eax
	je	$LN33@VCock_Exec

; 2637 : 	{
; 2638 : 
; 2639 : 		renderer->EndDraw(); //588

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 2640 : 		renderer->StartRtt( renderer );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	call	?StartRtt@VirtualDisplay@@QAEXPAVRender3D@@@Z ; VirtualDisplay::StartRtt

; 2641 : 
; 2642 : 
; 2643 : // DX - COBRA - RED - The AA texture corruption Problem?		
; 2644 : 		renderer->StartDraw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 2645 : 		renderer->SetBackground( 0x00000000 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 2646 : 		renderer->ClearDraw(); //588

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 2647 : //		renderer->ClearZBuffer();
; 2648 : 
; 2649 : 		//
; 2650 : 		// Do HUD
; 2651 : 		//
; 2652 : 		if (vHUDrenderer) // JPO - use basic info

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33980], 0
	je	$LN75@VCock_Exec

; 2653 : 		{
; 2654 : 			vHUDrenderer->AdjustRttViewport();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33980]
	call	?AdjustRttViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::AdjustRttViewport

; 2655 : 
; 2656 : 			if (g_b3DRTTCockpitDebug)

	movzx	eax, BYTE PTR ?g_b3DRTTCockpitDebug@@3_NA ; g_b3DRTTCockpitDebug
	test	eax, eax
	je	$LN74@VCock_Exec

; 2657 : 			{			
; 2658 : 				//ATARIBABY debug frame around surface
; 2659 : 				vHUDrenderer->SetColor (0x0000ffff);

	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33980]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2660 : 				vHUDrenderer->Line (-0.995F, -0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33980]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2661 : 				vHUDrenderer->Line (-0.995F, 0.995F, 0.995F, 0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33980]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2662 : 				vHUDrenderer->Line (-0.995F, 0.995F, -0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33980]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2663 : 				vHUDrenderer->Line (0.995F, 0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33980]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN74@VCock_Exec:

; 2664 : 			}
; 2665 : 
; 2666 : 			vHUDrenderer->SetColor( TheHud->GetHudColor() );	

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetHudColor@HudClass@@QAEKXZ		; HudClass::GetHudColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33980]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2667 :     
; 2668 : 			// Get the RTT Canvas coords, UL / UR / LL
; 2669 : 			Tpoint	pt[3];
; 2670 : 			vHUDrenderer->GetRttCanvas(pt);

	lea	ecx, DWORD PTR _pt$69[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33980]
	call	?GetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@@Z ; VirtualDisplay::GetRttCanvas

; 2671 : 
; 2672 : 			// set the HUD half angle
; 2673 : 			float hudangy, hudangx, ratio, VRatio;
; 2674 : 			hudangy = ( pt[1].y - pt[0].y ) * 0.50f;

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	movss	xmm0, DWORD PTR _pt$69[ebp+eax+4]
	subss	xmm0, DWORD PTR _pt$69[ebp+ecx+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _hudangy$8[ebp], xmm0

; 2675 : 			hudangx = pt[1].x;

	mov	edx, 12					; 0000000cH
	shl	edx, 0
	movss	xmm0, DWORD PTR _pt$69[ebp+edx]
	movss	DWORD PTR _hudangx$18[ebp], xmm0

; 2676 : 
; 2677 : 			// the hud half angle -- ratio of tangents (?)
; 2678 : 			ratio = ( hudangy/hudangx );

	movss	xmm0, DWORD PTR _hudangy$8[ebp]
	divss	xmm0, DWORD PTR _hudangx$18[ebp]
	movss	DWORD PTR _ratio$17[ebp], xmm0

; 2679 : 
; 2680 : 			// RV - RED - the Hud texture is supposed to be square
; 2681 : 			// may be it's drawn not square... to keep Hud symbology aligned with OTW
; 2682 : 			// calculate the verticale ratio and assign it as Hud Vertical aspect ratio
; 2683 : 			VRatio = ( pt[1].y - pt[0].y ) / ( pt[2].z - pt[0].z );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	movss	xmm0, DWORD PTR _pt$69[ebp+eax+4]
	subss	xmm0, DWORD PTR _pt$69[ebp+ecx+4]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	movss	xmm1, DWORD PTR _pt$69[ebp+edx+8]
	subss	xmm1, DWORD PTR _pt$69[ebp+eax+8]
	divss	xmm0, xmm1
	movss	DWORD PTR _VRatio$5[ebp], xmm0

; 2684 : 			
; 2685 : 			TheHud->SetHalfAngle((float)atan (ratio) * RTD, 1.0f, VRatio);

	push	ecx
	movss	xmm0, DWORD PTR _VRatio$5[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ratio$17[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR tv7253[ebp]
	movss	xmm0, DWORD PTR tv7253[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetHalfAngle@HudClass@@QAEXMMM@Z	; HudClass::SetHalfAngle

; 2686 : 			// TheHud->SetHalfAngle(atan (hudangy/hudangx) * RTD);
; 2687 : 
; 2688 : 			// hack!  move borsight height to boresighty from 3dckpit.dat. default 0.75f
; 2689 : 			hudWinY[BORESIGHT_CROSS_WINDOW] = vBoresightY;	// ASSO: 

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33956]
	mov	DWORD PTR ?hudWinY@@3PAMA[ecx], eax

; 2690 : 
; 2691 : 			TheHud->SetTarget( TheHud->Ownship()->targetPtr );

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?Ownship@HudClass@@QAEPAVAircraftClass@@XZ ; HudClass::Ownship
	mov	ecx, DWORD PTR [eax+656]
	push	ecx
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetTarget@HudClass@@QAEXPAVSimObjectType@@@Z ; HudClass::SetTarget

; 2692 : 			//vcInfo.vHUDrenderer->SetFont(pCockpitManager->HudFont());
; 2693 : 			vHUDrenderer->SetFont( pCockpitManager->HudFont() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33684]
	call	?HudFont@CockpitManager@@QAEHXZ		; CockpitManager::HudFont
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2694 : 
; 2695 : 			// infinite projection - Hud Offset - Hud is offsetted same value as Head
; 2696 : 			// This makes Hud to be always aligned with observer center
; 2697 : 			float	XOffset=12.0f * headPan.y / (pt[1].y - pt[0].y) * tanf(DTR * 60.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41400000
	mulss	xmm0, DWORD PTR [eax+33668]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	movss	xmm1, DWORD PTR _pt$69[ebp+ecx+4]
	subss	xmm1, DWORD PTR _pt$69[ebp+edx+4]
	divss	xmm0, xmm1
	push	ecx
	movss	xmm1, DWORD PTR __real@3f860a91
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv8073[ebp], xmm0
	call	_tanf
	add	esp, 4
	fstp	DWORD PTR tv7276[ebp]
	movss	xmm0, DWORD PTR tv8073[ebp]
	mulss	xmm0, DWORD PTR tv7276[ebp]
	movss	DWORD PTR _XOffset$11[ebp], xmm0

; 2698 : 			float	YOffset=12.0f * headPan.z / (pt[0].z - pt[2].z) * tanf(DTR * 60.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41400000
	mulss	xmm0, DWORD PTR [eax+33672]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	movss	xmm1, DWORD PTR _pt$69[ebp+ecx+8]
	subss	xmm1, DWORD PTR _pt$69[ebp+edx+8]
	divss	xmm0, xmm1
	push	ecx
	movss	xmm1, DWORD PTR __real@3f860a91
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv8075[ebp], xmm0
	call	_tanf
	add	esp, 4
	fstp	DWORD PTR tv7287[ebp]
	movss	xmm0, DWORD PTR tv8075[ebp]
	mulss	xmm0, DWORD PTR tv7287[ebp]
	movss	DWORD PTR _YOffset$15[ebp], xmm0

; 2699 : 
; 2700 : 			vHUDrenderer->AdjustOriginInViewport(XOffset, YOffset);

	push	ecx
	movss	xmm0, DWORD PTR _YOffset$15[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _XOffset$11[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33980]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2701 : 
; 2702 : 			TheHud->Display( vHUDrenderer, true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33980]
	push	edx
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?Display@HudClass@@QAEXPAVVirtualDisplay@@_N@Z ; HudClass::Display

; 2703 : 
; 2704 : 			VirtualDisplay::SetFont(oldFont);

	mov	eax, DWORD PTR _oldFont$[ebp]
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2705 : 			renderer->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2706 : 			// restore hud half angle
; 2707 : 			TheHud->SetHalfAngle((float)atan (0.25 * (float)tan(30.0F * DTR)) * RTD);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f060a91
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv7304[ebp]
	movss	xmm0, DWORD PTR tv7304[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fd0000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv7310[ebp]
	movsd	xmm0, QWORD PTR tv7310[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?SetHalfAngle@HudClass@@QAEXMMM@Z	; HudClass::SetHalfAngle

; 2708 : 			// hack!  restore borsight height to 0.60.  sigh.
; 2709 : 			hudWinY[BORESIGHT_CROSS_WINDOW] = 0.60f;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR ?hudWinY@@3PAMA[ecx], xmm0
$LN75@VCock_Exec:

; 2710 : 
; 2711 : 		}
; 2712 : 
; 2713 : 
; 2714 : 		//
; 2715 : 		// Do RWR
; 2716 : 		//
; 2717 : 		rwr = (PlayerRwrClass*)FindSensor( (SimMoverClass *)otwPlatform.get(), SensorClass::RWR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _rwr$[ebp], eax

; 2718 : 		if (vRWRrenderer && rwr)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33984], 0
	je	$LN73@VCock_Exec
	cmp	DWORD PTR _rwr$[ebp], 0
	je	$LN73@VCock_Exec

; 2719 : 		{
; 2720 : 			vRWRrenderer->AdjustRttViewport();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33984]
	call	?AdjustRttViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::AdjustRttViewport

; 2721 : 			
; 2722 : 			if (g_b3DRTTCockpitDebug)			

	movzx	ecx, BYTE PTR ?g_b3DRTTCockpitDebug@@3_NA ; g_b3DRTTCockpitDebug
	test	ecx, ecx
	je	$LN72@VCock_Exec

; 2723 : 			{
; 2724 : 				//ATARIBABY debug frame around surface
; 2725 : 				vRWRrenderer->SetColor (0x0000ffff);

	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33984]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33984]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2726 : 				vRWRrenderer->Line (-0.995F, -0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33984]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33984]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2727 : 				vRWRrenderer->Line (-0.995F, 0.995F, 0.995F, 0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33984]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33984]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2728 : 				vRWRrenderer->Line (-0.995F, 0.995F, -0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33984]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33984]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2729 : 				vRWRrenderer->Line (0.995F, 0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33984]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33984]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN72@VCock_Exec:

; 2730 : 			}
; 2731 : 
; 2732 : 			vRWRrenderer->SetColor(pVColors[OTWDriver.renderer->GetGreenMode() != 0][8]);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN518@VCock_Exec
	mov	DWORD PTR tv3856[ebp], 1
	jmp	SHORT $LN519@VCock_Exec
$LN518@VCock_Exec:
	mov	DWORD PTR tv3856[ebp], 0
$LN519@VCock_Exec:
	mov	edx, DWORD PTR tv3856[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33984]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33984]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2733 : 			rwr->SetGridVisible(FALSE);

	push	0
	mov	ecx, DWORD PTR _rwr$[ebp]
	call	?SetGridVisible@PlayerRwrClass@@QAEXH@Z	; PlayerRwrClass::SetGridVisible

; 2734 : 			vHUDrenderer->SetFont( pCockpitManager->MFDFont() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33684]
	call	?MFDFont@CockpitManager@@QAEHXZ		; CockpitManager::MFDFont
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2735 : 			rwr->Display(vRWRrenderer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33984]
	push	eax
	mov	ecx, DWORD PTR _rwr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rwr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 2736 : 			VirtualDisplay::SetFont(oldFont);

	mov	ecx, DWORD PTR _oldFont$[ebp]
	push	ecx
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4
$LN73@VCock_Exec:

; 2737 : 		}
; 2738 : 		
; 2739 : 		//
; 2740 : 		// Do DED
; 2741 : 		//
; 2742 : 		//I aligned DED and PFL column readouts for 3Dpit RTT they looks exactly as 2d DED . 
; 2743 : 		//If fonts get too big for 3d RTT, not change anything and wait for
; 2744 : 		//configurable fonts for RTT, please. Thanx 
; 2745 : 		//PLF and DED can be fitted into each "character boxes" (26x5 matrix) by changing 
; 2746 : 		//PLF and DED RTT surface resolution to match pixel size of fonts.
; 2747 : 
; 2748 : 		if(pCockpitManager->mpIcp && vDEDrenderer) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	cmp	DWORD PTR [eax+688], 0
	je	$LN71@VCock_Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33988], 0
	je	$LN71@VCock_Exec

; 2749 : 		{
; 2750 : 			vDEDrenderer->AdjustRttViewport();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33988]
	call	?AdjustRttViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::AdjustRttViewport

; 2751 : 			vHUDrenderer->SetFont( pCockpitManager->DEDFont() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33684]
	call	?DEDFont@CockpitManager@@QAEHXZ		; CockpitManager::DEDFont
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2752 : 			
; 2753 : 			if (g_b3DRTTCockpitDebug)

	movzx	ecx, BYTE PTR ?g_b3DRTTCockpitDebug@@3_NA ; g_b3DRTTCockpitDebug
	test	ecx, ecx
	je	$LN70@VCock_Exec

; 2754 : 			{
; 2755 : 				//ATARIBABY debug frame around surface
; 2756 : 				vDEDrenderer->SetColor (0x0000ffff);

	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2757 : 				vDEDrenderer->Line (-0.995F, -0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33988]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2758 : 				vDEDrenderer->Line (-0.995F, 0.995F, 0.995F, 0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33988]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2759 : 				vDEDrenderer->Line (-0.995F, 0.995F, -0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33988]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2760 : 				vDEDrenderer->Line (0.995F, 0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33988]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN70@VCock_Exec:

; 2761 : 			}
; 2762 : 
; 2763 : 			if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN69@VCock_Exec

; 2764 : 			{ 
; 2765 : 				pCockpitManager->mpIcp->Exec();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	mov	ecx, DWORD PTR [eax+688]
	call	?Exec@ICPClass@@QAEXXZ			; ICPClass::Exec

; 2766 : 				//MI changed for ICP Stuff
; 2767 : 				pCockpitManager->mpIcp->GetDEDStrings( dedStr1,	dedStr2, dedStr3 );

	push	OFFSET ?dedStr3@@3PADA			; dedStr3
	push	OFFSET ?dedStr2@@3PADA			; dedStr2
	push	OFFSET ?dedStr1@@3PADA			; dedStr1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33684]
	mov	ecx, DWORD PTR [edx+688]
	call	?GetDEDStrings@ICPClass@@QAEXPAD00@Z	; ICPClass::GetDEDStrings

; 2768 : 
; 2769 : 				// Check for DED/Avionics failure
; 2770 : 				F4Assert (SimDriver.GetPlayerAircraft());
; 2771 : 				F4Assert (SimDriver.GetPlayerAircraft()->mFaults);
; 2772 : 
; 2773 : 				// DED is orange :)
; 2774 : 				vDEDrenderer->SetColor(pVColors[OTWDriver.renderer->GetGreenMode() != 0][7]);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN520@VCock_Exec
	mov	DWORD PTR tv3998[ebp], 1
	jmp	SHORT $LN521@VCock_Exec
$LN520@VCock_Exec:
	mov	DWORD PTR tv3998[ebp], 0
$LN521@VCock_Exec:
	mov	ecx, DWORD PTR tv3998[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 7
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33988]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 2775 : 
; 2776 : 				if (!SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::ufc_fault))

	push	28					; 0000001cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	$LN68@VCock_Exec

; 2777 : 				{
; 2778 : 					vDEDrenderer->TextLeft(	-0.90F,	0.99F, dedStr1,	FALSE);

	push	0
	push	OFFSET ?dedStr1@@3PADA			; dedStr1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33988]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2779 : 					vDEDrenderer->TextLeft(	-0.90F,	0.33F, dedStr2,	FALSE);

	push	0
	push	OFFSET ?dedStr2@@3PADA			; dedStr2
	push	ecx
	movss	xmm0, DWORD PTR __real@3ea8f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33988]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2780 : 					vDEDrenderer->TextLeft(	-0.90F,	-0.33F,	dedStr3, FALSE);

	push	0
	push	OFFSET ?dedStr3@@3PADA			; dedStr3
	push	ecx
	movss	xmm0, DWORD PTR __real@bea8f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33988]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33988]
	mov	edx, DWORD PTR [eax+56]
	call	edx
$LN68@VCock_Exec:

; 2781 : 				} 
; 2782 : 			}
; 2783 : 			else

	jmp	$LN63@VCock_Exec
$LN69@VCock_Exec:

; 2784 : 			{
; 2785 : 				//MI modified for ICP Stuff
; 2786 : 				if(	!SimDriver.GetPlayerAircraft()->mFaults->GetFault(FaultClass::ufc_fault) && 
; 2787 : 					SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::UFCPower) )

	push	28					; 0000001cH
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	$LN63@VCock_Exec
	push	8
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	$LN63@VCock_Exec

; 2788 : 				{
; 2789 : 					pCockpitManager->mpIcp->Exec();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33684]
	mov	ecx, DWORD PTR [ecx+688]
	call	?Exec@ICPClass@@QAEXXZ			; ICPClass::Exec

; 2790 : 
; 2791 : 					// Check for DED/Avionics failure
; 2792 : 					F4Assert (SimDriver.GetPlayerAircraft());
; 2793 : 					F4Assert (SimDriver.GetPlayerAircraft()->mFaults);
; 2794 : 
; 2795 : 					// DED is orange :)
; 2796 : 					vDEDrenderer->SetColor(pVColors[OTWDriver.renderer->GetGreenMode() != 0][7]);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN522@VCock_Exec
	mov	DWORD PTR tv4088[ebp], 1
	jmp	SHORT $LN523@VCock_Exec
$LN522@VCock_Exec:
	mov	DWORD PTR tv4088[ebp], 0
$LN523@VCock_Exec:
	mov	eax, DWORD PTR tv4088[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+33696]
	mov	eax, 4
	imul	eax, 7
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2797 : 					
; 2798 : 					//ATARIBABY
; 2799 : 					float stepx;
; 2800 : 					stepx = 0.0753F;

	movss	xmm0, DWORD PTR __real@3d9a36e3
	movss	DWORD PTR _stepx$10[ebp], xmm0

; 2801 : 					
; 2802 : 					float x;
; 2803 : 					float y = 0.90F;

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR _y$41[ebp], xmm0

; 2804 : 
; 2805 : 					char buf[2];
; 2806 : 					for(int j = 0; j < 5; j++)

	mov	DWORD PTR _j$56[ebp], 0
	jmp	SHORT $LN65@VCock_Exec
$LN64@VCock_Exec:
	mov	ecx, DWORD PTR _j$56[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$56[ebp], ecx
$LN65@VCock_Exec:
	cmp	DWORD PTR _j$56[ebp], 5
	jge	$LN63@VCock_Exec

; 2807 : 					{
; 2808 : 						x = -0.98F;

	movss	xmm0, DWORD PTR __real@bf7ae148
	movss	DWORD PTR _x$39[ebp], xmm0

; 2809 : 						for(int i = 0; i < 26; i++)

	mov	DWORD PTR _i$57[ebp], 0
	jmp	SHORT $LN62@VCock_Exec
$LN61@VCock_Exec:
	mov	edx, DWORD PTR _i$57[ebp]
	add	edx, 1
	mov	DWORD PTR _i$57[ebp], edx
$LN62@VCock_Exec:
	cmp	DWORD PTR _i$57[ebp], 26		; 0000001aH
	jge	$LN60@VCock_Exec

; 2810 : 						{
; 2811 : 							buf[0] = pCockpitManager->mpIcp->DEDLines[j][i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33684]
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _j$56[ebp]
	imul	eax, 26					; 0000001aH
	lea	ecx, DWORD PTR [edx+eax+764]
	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _i$57[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _buf$60[ebp+edx], cl

; 2812 : 							buf[1] = '\0';

	mov	DWORD PTR $T31[ebp], 1
	cmp	DWORD PTR $T31[ebp], 2
	jae	SHORT $LN524@VCock_Exec
	jmp	SHORT $LN525@VCock_Exec
$LN524@VCock_Exec:
	call	___report_rangecheckfailure
$LN525@VCock_Exec:
	mov	edx, DWORD PTR $T31[ebp]
	mov	BYTE PTR _buf$60[ebp+edx], 0

; 2813 : 							
; 2814 : 							if(buf[0] != ' ' && pCockpitManager->mpIcp->Invert[j][i] == 0)

	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buf$60[ebp+eax]
	cmp	ecx, 32					; 00000020H
	je	$LN59@VCock_Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$56[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+894]
	mov	ecx, DWORD PTR _i$57[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	jne	SHORT $LN59@VCock_Exec

; 2815 : 								vDEDrenderer->TextLeft(x, y, buf,pCockpitManager->mpIcp->Invert[j][i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33684]
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _j$56[ebp]
	imul	eax, 26					; 0000001aH
	lea	ecx, DWORD PTR [edx+eax+894]
	mov	edx, DWORD PTR _i$57[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	push	eax
	lea	ecx, DWORD PTR _buf$60[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _y$41[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$39[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33988]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	jmp	$LN57@VCock_Exec
$LN59@VCock_Exec:

; 2816 : 							else if(pCockpitManager->mpIcp->Invert[j][i] == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33684]
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR _j$56[ebp]
	imul	ecx, 26					; 0000001aH
	lea	edx, DWORD PTR [eax+ecx+894]
	mov	eax, DWORD PTR _i$57[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	cmp	ecx, 2
	jne	SHORT $LN57@VCock_Exec

; 2817 : 								vDEDrenderer->TextLeft(x, y, buf,pCockpitManager->mpIcp->Invert[j][i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$56[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+894]
	mov	ecx, DWORD PTR _i$57[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	push	edx
	lea	eax, DWORD PTR _buf$60[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$41[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$39[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33988]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33988]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN57@VCock_Exec:

; 2818 : 							x += stepx;

	movss	xmm0, DWORD PTR _x$39[ebp]
	addss	xmm0, DWORD PTR _stepx$10[ebp]
	movss	DWORD PTR _x$39[ebp], xmm0

; 2819 : 						}

	jmp	$LN61@VCock_Exec
$LN60@VCock_Exec:

; 2820 : 						y -=0.325F;

	movss	xmm0, DWORD PTR _y$41[ebp]
	subss	xmm0, DWORD PTR __real@3ea66666
	movss	DWORD PTR _y$41[ebp], xmm0

; 2821 : 					}

	jmp	$LN64@VCock_Exec
$LN63@VCock_Exec:

; 2822 : 					//ATARIBABY end
; 2823 : 				}	
; 2824 : 			}
; 2825 : 			renderer->SetColor ( pVColors[OTWDriver.renderer->GetGreenMode() !=	0][6] );

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN526@VCock_Exec
	mov	DWORD PTR tv4195[ebp], 1
	jmp	SHORT $LN527@VCock_Exec
$LN526@VCock_Exec:
	mov	DWORD PTR tv4195[ebp], 0
$LN527@VCock_Exec:
	mov	edx, DWORD PTR tv4195[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 6
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2826 : 			VirtualDisplay::SetFont(oldFont);	// ASSO:

	mov	ecx, DWORD PTR _oldFont$[ebp]
	push	ecx
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4
$LN71@VCock_Exec:

; 2827 : 		}
; 2828 : 
; 2829 : 		//
; 2830 : 		// Do PFL
; 2831 : 		//
; 2832 : 
; 2833 : 		if(hasPFL && pCockpitManager->mpIcp && vPFLrenderer) 

	movzx	edx, BYTE PTR ?hasPFL@@3_NA		; hasPFL
	test	edx, edx
	je	$LN56@VCock_Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33684]
	cmp	DWORD PTR [ecx+688], 0
	je	$LN56@VCock_Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33992], 0
	je	$LN56@VCock_Exec

; 2834 : 		{
; 2835 : 			vPFLrenderer->AdjustRttViewport();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	call	?AdjustRttViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::AdjustRttViewport

; 2836 : 			vHUDrenderer->SetFont( pCockpitManager->DEDFont() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33684]
	call	?DEDFont@CockpitManager@@QAEHXZ		; CockpitManager::DEDFont
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2837 : 
; 2838 : 			if (g_b3DRTTCockpitDebug)

	movzx	edx, BYTE PTR ?g_b3DRTTCockpitDebug@@3_NA ; g_b3DRTTCockpitDebug
	test	edx, edx
	je	$LN55@VCock_Exec

; 2839 : 			{
; 2840 : 				//ATARIBABY debug frame around surface
; 2841 : 				vPFLrenderer->SetColor (0x0000ffff);

	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 2842 : 				vPFLrenderer->Line (-0.995F, -0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2843 : 				vPFLrenderer->Line (-0.995F, 0.995F, 0.995F, 0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2844 : 				vPFLrenderer->Line (-0.995F, 0.995F, -0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2845 : 				vPFLrenderer->Line (0.995F, 0.995F, 0.995F, -0.995F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7eb852
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN55@VCock_Exec:

; 2846 : 			}
; 2847 : 
; 2848 : 			if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN54@VCock_Exec

; 2849 : 			{ 
; 2850 : 				pCockpitManager->mpIcp->Exec();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33684]
	mov	ecx, DWORD PTR [edx+688]
	call	?Exec@ICPClass@@QAEXXZ			; ICPClass::Exec

; 2851 : 				//MI changed for ICP Stuff
; 2852 : 				pCockpitManager->mpIcp->GetDEDStrings( dedStr1,	dedStr2, dedStr3 );

	push	OFFSET ?dedStr3@@3PADA			; dedStr3
	push	OFFSET ?dedStr2@@3PADA			; dedStr2
	push	OFFSET ?dedStr1@@3PADA			; dedStr1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33684]
	mov	ecx, DWORD PTR [ecx+688]
	call	?GetDEDStrings@ICPClass@@QAEXPAD00@Z	; ICPClass::GetDEDStrings

; 2853 : 
; 2854 : 				// Check for DED/Avionics failure
; 2855 : 				F4Assert (SimDriver.GetPlayerAircraft());
; 2856 : 				F4Assert (SimDriver.GetPlayerAircraft()->mFaults);
; 2857 : 
; 2858 : 				// DED is orange :)
; 2859 : 				vPFLrenderer->SetColor(pVColors[OTWDriver.renderer->GetGreenMode() != 0][7]);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN528@VCock_Exec
	mov	DWORD PTR tv4320[ebp], 1
	jmp	SHORT $LN529@VCock_Exec
$LN528@VCock_Exec:
	mov	DWORD PTR tv4320[ebp], 0
$LN529@VCock_Exec:
	mov	eax, DWORD PTR tv4320[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+33696]
	mov	eax, 4
	imul	eax, 7
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33992]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33992]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2860 : 
; 2861 : 				{
; 2862 : 					vPFLrenderer->TextLeft(	-0.90F,	0.99F, dedStr1,	FALSE);

	push	0
	push	OFFSET ?dedStr1@@3PADA			; dedStr1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33992]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2863 : 					vPFLrenderer->TextLeft(	-0.90F,	0.33F, dedStr2,	FALSE);

	push	0
	push	OFFSET ?dedStr2@@3PADA			; dedStr2
	push	ecx
	movss	xmm0, DWORD PTR __real@3ea8f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33992]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2864 : 					vPFLrenderer->TextLeft(	-0.90F,	-0.33F,	dedStr3, FALSE);

	push	0
	push	OFFSET ?dedStr3@@3PADA			; dedStr3
	push	ecx
	movss	xmm0, DWORD PTR __real@bea8f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33992]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2865 : 				} 
; 2866 : 			}
; 2867 : 			else

	jmp	$LN52@VCock_Exec
$LN54@VCock_Exec:

; 2868 : 			{
; 2869 : 				if(	SimDriver.GetPlayerAircraft()->HasPower(AircraftClass::PFDPower) )

	push	524288					; 00080000H
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	$LN52@VCock_Exec

; 2870 : 				{
; 2871 : 					pCockpitManager->mpIcp->ExecPfl(); //ATARIBABY ExecPfl() instead Exec() is needed

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33684]
	mov	ecx, DWORD PTR [edx+688]
	call	?ExecPfl@ICPClass@@QAEXXZ		; ICPClass::ExecPfl

; 2872 : 
; 2873 : 					// Check for DED/Avionics failure
; 2874 : 					F4Assert (SimDriver.GetPlayerAircraft());
; 2875 : 					F4Assert (SimDriver.GetPlayerAircraft()->mFaults);
; 2876 : 
; 2877 : 					// PFL is orange :)
; 2878 : 					vPFLrenderer->SetColor(pVColors[OTWDriver.renderer->GetGreenMode() != 0][7]);

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN530@VCock_Exec
	mov	DWORD PTR tv4396[ebp], 1
	jmp	SHORT $LN531@VCock_Exec
$LN530@VCock_Exec:
	mov	DWORD PTR tv4396[ebp], 0
$LN531@VCock_Exec:
	mov	ecx, DWORD PTR tv4396[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 7
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33992]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 2879 : 					
; 2880 : 					//ATARIBABY
; 2881 : 					float stepx;
; 2882 : 					stepx = 0.0753F;

	movss	xmm0, DWORD PTR __real@3d9a36e3
	movss	DWORD PTR _stepx$12[ebp], xmm0

; 2883 : 					
; 2884 : 					float x;
; 2885 : 					float y = 0.90F;

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR _y$42[ebp], xmm0

; 2886 : 
; 2887 : 					char buf[2];
; 2888 : 					for(int j = 0; j < 5; j++)

	mov	DWORD PTR _j$58[ebp], 0
	jmp	SHORT $LN51@VCock_Exec
$LN50@VCock_Exec:
	mov	eax, DWORD PTR _j$58[ebp]
	add	eax, 1
	mov	DWORD PTR _j$58[ebp], eax
$LN51@VCock_Exec:
	cmp	DWORD PTR _j$58[ebp], 5
	jge	$LN49@VCock_Exec

; 2889 : 					{
; 2890 : 						x = -0.98F;

	movss	xmm0, DWORD PTR __real@bf7ae148
	movss	DWORD PTR _x$43[ebp], xmm0

; 2891 : 						for(int i = 0; i < 26; i++)

	mov	DWORD PTR _i$53[ebp], 0
	jmp	SHORT $LN48@VCock_Exec
$LN47@VCock_Exec:
	mov	ecx, DWORD PTR _i$53[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$53[ebp], ecx
$LN48@VCock_Exec:
	cmp	DWORD PTR _i$53[ebp], 26		; 0000001aH
	jge	$LN46@VCock_Exec

; 2892 : 						{
; 2893 : 							buf[0] = pCockpitManager->mpIcp->PFLLines[j][i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$58[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+1084]
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _i$53[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR _buf$59[ebp+ecx], al

; 2894 : 							buf[1] = '\0';

	mov	DWORD PTR $T30[ebp], 1
	cmp	DWORD PTR $T30[ebp], 2
	jae	SHORT $LN532@VCock_Exec
	jmp	SHORT $LN533@VCock_Exec
$LN532@VCock_Exec:
	call	___report_rangecheckfailure
$LN533@VCock_Exec:
	mov	ecx, DWORD PTR $T30[ebp]
	mov	BYTE PTR _buf$59[ebp+ecx], 0

; 2895 : 							
; 2896 : 							if(buf[0] != ' ' && pCockpitManager->mpIcp->PFLInvert[j][i] == 0)

	mov	edx, 1
	imul	edx, 0
	movsx	eax, BYTE PTR _buf$59[ebp+edx]
	cmp	eax, 32					; 00000020H
	je	$LN45@VCock_Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33684]
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR _j$58[ebp]
	imul	ecx, 26					; 0000001aH
	lea	edx, DWORD PTR [eax+ecx+1214]
	mov	eax, DWORD PTR _i$53[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	test	ecx, ecx
	jne	SHORT $LN45@VCock_Exec

; 2897 : 								vPFLrenderer->TextLeft(x, y, buf,pCockpitManager->mpIcp->PFLInvert[j][i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$58[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+1214]
	mov	ecx, DWORD PTR _i$53[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	push	edx
	lea	eax, DWORD PTR _buf$59[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$42[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$43[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33992]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	jmp	$LN43@VCock_Exec
$LN45@VCock_Exec:

; 2898 : 							else if(pCockpitManager->mpIcp->PFLInvert[j][i] == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33684]
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR _j$58[ebp]
	imul	ecx, 26					; 0000001aH
	lea	edx, DWORD PTR [eax+ecx+1214]
	mov	eax, DWORD PTR _i$53[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	cmp	ecx, 2
	jne	SHORT $LN43@VCock_Exec

; 2899 : 								vPFLrenderer->TextLeft(x, y, buf,pCockpitManager->mpIcp->PFLInvert[j][i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33684]
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$58[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+1214]
	mov	ecx, DWORD PTR _i$53[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	push	edx
	lea	eax, DWORD PTR _buf$59[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$42[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$43[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33992]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33992]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN43@VCock_Exec:

; 2900 : 							x += stepx;

	movss	xmm0, DWORD PTR _x$43[ebp]
	addss	xmm0, DWORD PTR _stepx$12[ebp]
	movss	DWORD PTR _x$43[ebp], xmm0

; 2901 : 						}

	jmp	$LN47@VCock_Exec
$LN46@VCock_Exec:

; 2902 : 						y -=0.325F;

	movss	xmm0, DWORD PTR _y$42[ebp]
	subss	xmm0, DWORD PTR __real@3ea66666
	movss	DWORD PTR _y$42[ebp], xmm0

; 2903 : 					}

	jmp	$LN50@VCock_Exec
$LN49@VCock_Exec:

; 2904 : 					//ATARIBABY end
; 2905 : 
; 2906 : 					VirtualDisplay::SetFont(oldFont);	// ASSO:

	mov	ecx, DWORD PTR _oldFont$[ebp]
	push	ecx
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4
$LN52@VCock_Exec:

; 2907 : 				}	
; 2908 : 			}
; 2909 : 			renderer->SetColor ( pVColors[OTWDriver.renderer->GetGreenMode() !=	0][6] );

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN534@VCock_Exec
	mov	DWORD PTR tv4536[ebp], 1
	jmp	SHORT $LN535@VCock_Exec
$LN534@VCock_Exec:
	mov	DWORD PTR tv4536[ebp], 0
$LN535@VCock_Exec:
	mov	eax, DWORD PTR tv4536[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+33696]
	mov	eax, 4
	imul	eax, 6
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax
$LN56@VCock_Exec:

; 2910 : 		}
; 2911 : 
; 2912 : 
; 2913 : // DX - COBRA - RED - The AA texture corruption Problem?		
; 2914 : //		renderer->FinishFrame();
; 2915 : 
; 2916 : 		//
; 2917 : 		// Do MFDs
; 2918 : 		//
; 2919 : 		// don't need to update pos here since it's always relative
; 2920 : 		// to origin and identity matrix
; 2921 : 		// MfdDisplay[i]->UpdateVirtualPosition(&Origin, &IMatrix);    
; 2922 : 
; 2923 : 		if (g_b3dMFDLeft)

	movzx	ecx, BYTE PTR ?g_b3dMFDLeft@@3_NA	; g_b3dMFDLeft
	test	ecx, ecx
	je	SHORT $LN42@VCock_Exec

; 2924 : 		{
; 2925 : 			//MfdDisplay[0]->SetImageBuffer(OTWImage, viewportBounds.left, viewportBounds.top, viewportBounds.right, viewportBounds.bottom);			
; 2926 : 			VirtualDisplay::SetFont(0);//pCockpitManager->MFDFont());	

	push	0
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2927 : 			MfdDisplay[0]->Exec(FALSE, TRUE); // ASSO:

	push	1
	push	0
	mov	edx, 4
	imul	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?Exec@MFDClass@@QAEXHH@Z		; MFDClass::Exec

; 2928 : 			VirtualDisplay::SetFont(oldFont);	

	mov	eax, DWORD PTR _oldFont$[ebp]
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4
$LN42@VCock_Exec:

; 2929 : 		}
; 2930 : 		if (g_b3dMFDRight)

	movzx	ecx, BYTE PTR ?g_b3dMFDRight@@3_NA	; g_b3dMFDRight
	test	ecx, ecx
	je	SHORT $LN41@VCock_Exec

; 2931 : 		{
; 2932 : 			//MfdDisplay[1]->SetImageBuffer(OTWImage, viewportBounds.left, viewportBounds.top, viewportBounds.right, viewportBounds.bottom);			
; 2933 : 			VirtualDisplay::SetFont(0);//pCockpitManager->MFDFont());	

	push	0
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 2934 : 			MfdDisplay[1]->Exec(FALSE, TRUE); // ASSO:

	push	1
	push	0
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?Exec@MFDClass@@QAEXHH@Z		; MFDClass::Exec

; 2935 : 			VirtualDisplay::SetFont(oldFont);	

	mov	eax, DWORD PTR _oldFont$[ebp]
	push	eax
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4
$LN41@VCock_Exec:

; 2936 : 		}
; 2937 : 
; 2938 : 
; 2939 : //		renderer->FinishFrame();
; 2940 : 		renderer->FinishRtt();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?FinishRtt@VirtualDisplay@@QAEXXZ	; VirtualDisplay::FinishRtt

; 2941 : 
; 2942 : //		renderer->StartDraw();
; 2943 : 		
; 2944 : 		if( vHUDrenderer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33980], 0
	je	SHORT $LN40@VCock_Exec

; 2945 : 			vHUDrenderer->DrawRttQuad();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33980]
	call	?DrawRttQuad@VirtualDisplay@@QAEXXZ	; VirtualDisplay::DrawRttQuad
$LN40@VCock_Exec:

; 2946 : 
; 2947 : 		if( vRWRrenderer )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33984], 0
	je	SHORT $LN39@VCock_Exec

; 2948 : 			vRWRrenderer->DrawRttQuad();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33984]
	call	?DrawRttQuad@VirtualDisplay@@QAEXXZ	; VirtualDisplay::DrawRttQuad
$LN39@VCock_Exec:

; 2949 : 		
; 2950 : 		if( vDEDrenderer )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+33988], 0
	je	SHORT $LN38@VCock_Exec

; 2951 : 			vDEDrenderer->DrawRttQuad();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33988]
	call	?DrawRttQuad@VirtualDisplay@@QAEXXZ	; VirtualDisplay::DrawRttQuad
$LN38@VCock_Exec:

; 2952 : 
; 2953 : 		if( vPFLrenderer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33992], 0
	je	SHORT $LN37@VCock_Exec

; 2954 : 			vPFLrenderer->DrawRttQuad();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33992]
	call	?DrawRttQuad@VirtualDisplay@@QAEXXZ	; VirtualDisplay::DrawRttQuad
$LN37@VCock_Exec:

; 2955 : 
; 2956 : 		if( g_b3dMFDLeft ){

	movzx	ecx, BYTE PTR ?g_b3dMFDLeft@@3_NA	; g_b3dMFDLeft
	test	ecx, ecx
	je	SHORT $LN35@VCock_Exec

; 2957 : 			if( MfdDisplay[0]->GetDrawable() && MfdDisplay[0]->GetDrawable()->GetDisplay() )

	mov	edx, 4
	imul	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ; MFDClass::GetDrawable
	test	eax, eax
	je	SHORT $LN35@VCock_Exec
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[eax]
	call	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ; MFDClass::GetDrawable
	mov	DWORD PTR tv4610[ebp], eax
	mov	ecx, DWORD PTR tv4610[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv4610[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	test	eax, eax
	je	SHORT $LN35@VCock_Exec

; 2958 : 			{
; 2959 : 				MfdDisplay[0]->GetDrawable()->GetDisplay()->DrawRttQuad();

	mov	ecx, 4
	imul	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ; MFDClass::GetDrawable
	mov	DWORD PTR tv4620[ebp], eax
	mov	edx, DWORD PTR tv4620[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv4620[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	ecx, eax
	call	?DrawRttQuad@VirtualDisplay@@QAEXXZ	; VirtualDisplay::DrawRttQuad
$LN35@VCock_Exec:

; 2960 : 			}
; 2961 : 		}
; 2962 : 		if( g_b3dMFDRight){

	movzx	eax, BYTE PTR ?g_b3dMFDRight@@3_NA	; g_b3dMFDRight
	test	eax, eax
	je	SHORT $LN33@VCock_Exec

; 2963 : 			if( MfdDisplay[1]->GetDrawable() &&  MfdDisplay[1]->GetDrawable()->GetDisplay() )

	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ; MFDClass::GetDrawable
	test	eax, eax
	je	SHORT $LN33@VCock_Exec
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx]
	call	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ; MFDClass::GetDrawable
	mov	DWORD PTR tv4637[ebp], eax
	mov	eax, DWORD PTR tv4637[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv4637[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	test	eax, eax
	je	SHORT $LN33@VCock_Exec

; 2964 : 			{
; 2965 : 				MfdDisplay[1]->GetDrawable()->GetDisplay()->DrawRttQuad();

	mov	ecx, 4
	shl	ecx, 0
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx]
	call	?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ; MFDClass::GetDrawable
	mov	DWORD PTR tv4647[ebp], eax
	mov	edx, DWORD PTR tv4647[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv4647[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	ecx, eax
	call	?DrawRttQuad@VirtualDisplay@@QAEXXZ	; VirtualDisplay::DrawRttQuad
$LN33@VCock_Exec:

; 2966 : 			}
; 2967 : 		}
; 2968 : 	}
; 2969 : // ASSO: END
; 2970 : 
; 2971 : 
; 2972 : 	if (!g_bUseNew3dpit) //ATARIBABY start Disabled if using new 3dpit code	

	movzx	eax, BYTE PTR ?g_bUseNew3dpit@@3_NA	; g_bUseNew3dpit
	test	eax, eax
	jne	$LN28@VCock_Exec

; 2973 : 	{
; 2974 : 		if (vcInfo.vMACHrenderer) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33968], 0
	je	$LN31@VCock_Exec

; 2975 : 		{
; 2976 : 			/* Do MACH indictator */
; 2977 : 			float GetKias = ((AircraftClass *)otwPlatform.get())->af->vcas;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	edx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1124]
	movss	DWORD PTR _GetKias$49[ebp], xmm0

; 2978 : 
; 2979 : 			GetKias = (float)fmod( GetKias, 1000.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _GetKias$49[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fmod@@YAMMM@Z				; fmod
	add	esp, 8
	fstp	DWORD PTR _GetKias$49[ebp]

; 2980 : 			GetKias = GetKias * 0.001f * 2.0F * PI;

	movss	xmm0, DWORD PTR _GetKias$49[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR _GetKias$49[ebp], xmm0

; 2981 : 
; 2982 : 			x1 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x1$[ebp], xmm0

; 2983 : 			y1 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y1$[ebp], xmm0

; 2984 : 			mlSinCos (&trig, GetKias);

	push	ecx
	movss	xmm0, DWORD PTR _GetKias$49[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2985 : 			x2 = 0.85f * trig.cos;

	movss	xmm0, DWORD PTR __real@3f59999a
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2986 : 			y2 = 0.85f * -trig.sin;

	movss	xmm0, DWORD PTR _trig$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR _y2$[ebp], xmm0

; 2987 : 
; 2988 : 			vcInfo.vMACHrenderer->Line( x1, y1, x2, y2 );

	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33968]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33968]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN31@VCock_Exec:

; 2989 : 		}
; 2990 : 
; 2991 : 		renderer->SetColor ( pVColors[OTWDriver.renderer->GetGreenMode() != 0][5] );

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33576
	call	?GetGreenMode@RenderOTW@@QAE_NXZ	; RenderOTW::GetGreenMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN536@VCock_Exec
	mov	DWORD PTR tv4710[ebp], 1
	jmp	SHORT $LN537@VCock_Exec
$LN536@VCock_Exec:
	mov	DWORD PTR tv4710[ebp], 0
$LN537@VCock_Exec:
	mov	edx, DWORD PTR tv4710[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+33696]
	mov	edx, 4
	imul	edx, 5
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 2992 : 
; 2993 : 		for(i = 0; static_cast<unsigned int>(i) < mpVDials.size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN30@VCock_Exec
$LN29@VCock_Exec:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN30@VCock_Exec:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34020				; 000084e4H
	call	?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN28@VCock_Exec

; 2994 : 			mpVDials[i]->Exec(SimDriver.GetPlayerAircraft());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34020				; 000084e4H
	call	??A?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEAAPAVVDial@@I@Z ; std::vector<VDial *,std::allocator<VDial *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Exec@VDial@@QAEXPAVSimBaseClass@@@Z	; VDial::Exec
	jmp	SHORT $LN29@VCock_Exec
$LN28@VCock_Exec:

; 2995 : 	}
; 2996 : 	//ATARIBABY end
; 2997 : 
; 2998 : 	//Wombat778 10-11-2003 The meat of the clickable cockpit.  Looks for the closest button and executes it.  Also displays button locations in debug mode.
; 2999 : 	//Why execute the commands here, you may ask.  Well, because I spent all night trying to get it to run from simouse.cpp and couldnt (strange memory corruption)
; 3000 : 	//So, here it is.  It is a hack, but it works.  If you don't like, then YOU fix it;-)
; 3001 : 
; 3002 : 		ThreeDVertex t1;
; 3003 : 		gSelectedCursor = 9;				//Wombat778 10-11-2003 set the cursor to the default green cursor

	mov	DWORD PTR ?gSelectedCursor@@3HA, 9	; gSelectedCursor

; 3004 : 
; 3005 : 		if ((vuxRealTime - gTimeLastMouseMove < SI_MOUSE_TIME_DELTA) && !InExitMenu()) //Wombat778 10-15-2003 added so mouse cursor would disappear after a few seconds standing still. Also dont want two cursors when exit menu is up

	mov	eax, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	sub	eax, DWORD PTR ?gTimeLastMouseMove@@3KA	; gTimeLastMouseMove
	cmp	eax, 1500				; 000005dcH
	jae	$LN23@VCock_Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InExitMenu@OTWDriverClass@@QAEHXZ	; OTWDriverClass::InExitMenu
	test	eax, eax
	jne	$LN23@VCock_Exec

; 3006 : 		{
; 3007 : 			//Wombat778 10-15-2003 Added the following so that mouse cursor could be drawn in green if over a button, red otherwise
; 3008 : 			if (g_b3DClickableCursorChange) 

	movzx	ecx, BYTE PTR ?g_b3DClickableCursorChange@@3_NA ; g_b3DClickableCursorChange
	test	ecx, ecx
	je	$LN23@VCock_Exec

; 3009 : 			{
; 3010 : 				gSelectedCursor = 0;

	mov	DWORD PTR ?gSelectedCursor@@3HA, 0	; gSelectedCursor

; 3011 : 				for ( i = 0 ; i < Button3DList.numbuttons ; i++ )  

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@VCock_Exec
$LN24@VCock_Exec:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN25@VCock_Exec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32000]
	jge	$LN23@VCock_Exec

; 3012 : 				{
; 3013 : 					Tpoint	Pos=Button3DList.buttons[i].loc;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Pos$66[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _Pos$66[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _Pos$66[ebp+8], edx

; 3014 : 					Pos.x+=headPan.x*B3D_POSITION_SCALING;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+33664]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$66[ebp]
	movss	DWORD PTR _Pos$66[ebp], xmm0

; 3015 : 					Pos.y+=headPan.y*B3D_POSITION_SCALING;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33668]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$66[ebp+4]
	movss	DWORD PTR _Pos$66[ebp+4], xmm0

; 3016 : 					Pos.z+=headPan.z*B3D_POSITION_SCALING;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+33672]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$66[ebp+8]
	movss	DWORD PTR _Pos$66[ebp+8], xmm0

; 3017 : 
; 3018 : 					renderer->TransformCameraCentricPoint(&Pos,&t1);			

	lea	eax, DWORD PTR _t1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Pos$66[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33576]
	call	?TransformCameraCentricPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformCameraCentricPoint

; 3019 : 					if (sqrt(((gxPos-t1.x)*(gxPos-t1.x))+((gyPos-t1.y)*(gyPos-t1.y)))  <  (float)(DisplayOptions.DispWidth/ 1600.0f) * (Button3DList.buttons[i].dist/(1.5f*(float)GetFOV())))  //Wombat778 10-15-2003 changes changex with gxPos

	cvtsi2ss xmm0, DWORD PTR ?gxPos@@3HA		; gxPos
	subss	xmm0, DWORD PTR _t1$[ebp]
	cvtsi2ss xmm1, DWORD PTR ?gxPos@@3HA		; gxPos
	subss	xmm1, DWORD PTR _t1$[ebp]
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR ?gyPos@@3HA		; gyPos
	subss	xmm1, DWORD PTR _t1$[ebp+4]
	cvtsi2ss xmm2, DWORD PTR ?gyPos@@3HA		; gyPos
	subss	xmm2, DWORD PTR _t1$[ebp+4]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv7791[ebp]
	movss	xmm0, DWORD PTR tv7791[ebp]
	movzx	eax, WORD PTR ?DisplayOptions@@3VDisplayOptionsClass@@A
	cvtsi2ss xmm1, eax
	divss	xmm1, DWORD PTR __real@44c80000
	mov	esi, DWORD PTR _i$[ebp]
	shl	esi, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv8077[ebp], xmm0
	movss	DWORD PTR tv8079[ebp], xmm1
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv7796[ebp]
	movss	xmm0, DWORD PTR tv7796[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+esi+12]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv8079[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR tv8077[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN22@VCock_Exec

; 3020 : 					{
; 3021 : 						gSelectedCursor = 9;

	mov	DWORD PTR ?gSelectedCursor@@3HA, 9	; gSelectedCursor

; 3022 : 						break;

	jmp	SHORT $LN23@VCock_Exec
$LN22@VCock_Exec:

; 3023 : 					}
; 3024 : 				}

	jmp	$LN24@VCock_Exec
$LN23@VCock_Exec:

; 3025 : 			}		
; 3026 : 		//Wombat778 12-16-2003 moved to vcock.cpp
; 3027 : 		//ClipAndDrawCursor(OTWDriver.pCockpitManager->GetCockpitWidth(), OTWDriver.pCockpitManager->GetCockpitHeight());//Wombat778 10-10-2003  Draw the Mouse cursor if 3d clickable cockpit enabled
; 3028 : 
; 3029 : 		}
; 3030 : 
; 3031 : 		
; 3032 : 		if (Button3DList.clicked)			//Wombat778 10-11-2003 check if the mouse button has been clicked while in the 3d cockpit

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32008], 0
	je	$LN21@VCock_Exec

; 3033 : 		{
; 3034 : 			float closestdistance=9999;	//set these variables to a high value so that we know when it is uninitialized (there is a button 0)

	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR _closestdistance$29[ebp], xmm0

; 3035 : 			float tempdistance=9999;

	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR _tempdistance$45[ebp], xmm0

; 3036 : 			int closestbutton=9999;

	mov	DWORD PTR _closestbutton$54[ebp], 9999	; 0000270fH

; 3037 : 
; 3038 : 			for ( i = 0 ; i < Button3DList.numbuttons ; i++ )  

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@VCock_Exec
$LN19@VCock_Exec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@VCock_Exec:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+32000]
	jge	$LN18@VCock_Exec

; 3039 : 			{
; 3040 : 				
; 3041 : 				if (Button3DList.buttons[i].mousebutton==Button3DList.clicked)		//Wombat778 11-07-2003 Added so that the left and right mouse button can be differentiated

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+24]
	cmp	eax, DWORD PTR [edx+32008]
	jne	$LN15@VCock_Exec

; 3042 : 				{
; 3043 : 					Tpoint	Pos=Button3DList.buttons[i].loc;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _Pos$68[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _Pos$68[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _Pos$68[ebp+8], ecx

; 3044 : 					Pos.x+=headPan.x*B3D_POSITION_SCALING;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+33664]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$68[ebp]
	movss	DWORD PTR _Pos$68[ebp], xmm0

; 3045 : 					Pos.y+=headPan.y*B3D_POSITION_SCALING;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+33668]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$68[ebp+4]
	movss	DWORD PTR _Pos$68[ebp+4], xmm0

; 3046 : 					Pos.z+=headPan.z*B3D_POSITION_SCALING;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33672]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$68[ebp+8]
	movss	DWORD PTR _Pos$68[ebp+8], xmm0

; 3047 : 	
; 3048 : 					renderer->TransformCameraCentricPoint(&Pos,&t1);

	lea	edx, DWORD PTR _t1$[ebp]
	push	edx
	lea	eax, DWORD PTR _Pos$68[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?TransformCameraCentricPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformCameraCentricPoint

; 3049 : 					tempdistance=sqrt(((gxPos-t1.x)*(gxPos-t1.x))+((gyPos-t1.y)*(gyPos-t1.y)));

	cvtsi2ss xmm0, DWORD PTR ?gxPos@@3HA		; gxPos
	subss	xmm0, DWORD PTR _t1$[ebp]
	cvtsi2ss xmm1, DWORD PTR ?gxPos@@3HA		; gxPos
	subss	xmm1, DWORD PTR _t1$[ebp]
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR ?gyPos@@3HA		; gyPos
	subss	xmm1, DWORD PTR _t1$[ebp+4]
	cvtsi2ss xmm2, DWORD PTR ?gyPos@@3HA		; gyPos
	subss	xmm2, DWORD PTR _t1$[ebp+4]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _tempdistance$45[ebp]

; 3050 : 			
; 3051 : 					//Normalize the distance so it is affected by the FOV and by the resolution
; 3052 : 					//Todo: add something about the SA bar.  Currently, the dist increases too much when it is active
; 3053 : 					float td = ((float) DisplayOptions.DispWidth/ 1600.0f) * (Button3DList.buttons[i].dist/(1.5f*(float)GetFOV()));	

	movzx	edx, WORD PTR ?DisplayOptions@@3VDisplayOptionsClass@@A
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@44c80000
	mov	esi, DWORD PTR _i$[ebp]
	shl	esi, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv8081[ebp], xmm0
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv7838[ebp]
	movss	xmm0, DWORD PTR tv7838[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+esi+12]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv8081[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _td$16[ebp], xmm0

; 3054 : 
; 3055 : 					if (tempdistance < td)

	movss	xmm0, DWORD PTR _td$16[ebp]
	comiss	xmm0, DWORD PTR _tempdistance$45[ebp]
	jbe	SHORT $LN15@VCock_Exec

; 3056 : 						if (tempdistance < closestdistance)			//if the cursor is near more than 1 button, find the closest one

	movss	xmm0, DWORD PTR _closestdistance$29[ebp]
	comiss	xmm0, DWORD PTR _tempdistance$45[ebp]
	jbe	SHORT $LN15@VCock_Exec

; 3057 : 						{
; 3058 : 							closestdistance=tempdistance;

	movss	xmm0, DWORD PTR _tempdistance$45[ebp]
	movss	DWORD PTR _closestdistance$29[ebp], xmm0

; 3059 : 							closestbutton=i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _closestbutton$54[ebp], ecx

; 3060 : 							tempdistance = 9999;

	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR _tempdistance$45[ebp], xmm0
$LN15@VCock_Exec:

; 3061 : 
; 3062 : 						}
; 3063 : 				}
; 3064 : 			}

	jmp	$LN19@VCock_Exec
$LN18@VCock_Exec:

; 3065 : 
; 3066 : 			if (closestbutton != 9999) 

	cmp	DWORD PTR _closestbutton$54[ebp], 9999	; 0000270fH
	je	$LN13@VCock_Exec

; 3067 : 				if (Button3DList.buttons[closestbutton].function)

	mov	edx, DWORD PTR _closestbutton$54[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+16], 0
	je	$LN13@VCock_Exec

; 3068 : 				{
; 3069 : 				//Wombat778 03-06-04 Send the buttonid of the function, which should stop a ctd in not-realistic avionics
; 3070 : 				if(Button3DList.buttons[closestbutton].buttonId < 0) 

	mov	ecx, DWORD PTR _closestbutton$54[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+28], 0
	jge	SHORT $LN12@VCock_Exec

; 3071 : 					//Wombat778 03-06-04 Use callfunc instead of directly calling funcs, so they can be captured
; 3072 : 					CallFunc(Button3DList.buttons[closestbutton].function,1, KEY_DOWN, NULL);		

	push	0
	push	8
	push	1
	mov	eax, DWORD PTR _closestbutton$54[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	?CallFunc@@YAXP6AXKHPAX@ZKH0@Z		; CallFunc
	add	esp, 16					; 00000010H

; 3073 : 				else

	jmp	SHORT $LN11@VCock_Exec
$LN12@VCock_Exec:

; 3074 : 					//Wombat778 03-06-04 Use callfunc instead of directly calling funcs, so they can be captured
; 3075 : 					CallFunc(Button3DList.buttons[closestbutton].function,1, KEY_DOWN, OTWDriver.pCockpitManager->GetButtonPointer(Button3DList.buttons[closestbutton].buttonId));	

	mov	eax, DWORD PTR _closestbutton$54[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+28]
	push	edx
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?GetButtonPointer@CockpitManager@@QAEPAVCPButtonObject@@H@Z ; CockpitManager::GetButtonPointer
	push	eax
	push	8
	push	1
	mov	eax, DWORD PTR _closestbutton$54[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	?CallFunc@@YAXP6AXKHPAX@ZKH0@Z		; CallFunc
	add	esp, 16					; 00000010H
$LN11@VCock_Exec:

; 3076 : 				F4SoundFXSetDist(Button3DList.buttons[closestbutton].sound, FALSE, 0.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _closestbutton$54[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN13@VCock_Exec:

; 3077 : 				}
; 3078 : 			Button3DList.clicked=0;		

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32008], 0
$LN21@VCock_Exec:

; 3079 : 		}
; 3080 : 		
; 3081 : 		if (g_b3DClickableCockpitDebug) 

	movzx	ecx, BYTE PTR ?g_b3DClickableCockpitDebug@@3_NA ; g_b3DClickableCockpitDebug
	test	ecx, ecx
	je	$LN10@VCock_Exec

; 3082 : 		{		//Wombat778 10-10-2003 Draw Locations of the 3d buttons when Debug mode is enabled
; 3083 : 
; 3084 : 		
; 3085 : 			for ( i = 0 ; i < Button3DList.numbuttons ; i++ )  {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@VCock_Exec
$LN8@VCock_Exec:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@VCock_Exec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32000]
	jge	$LN7@VCock_Exec

; 3086 : 
; 3087 : 		//		if (i==Button3DList.debugbutton) 
; 3088 : 		//			renderer->SetColor(pVColors[TheTimeOfDay.GetNVGmode() != 0][7]);
; 3089 : 		//		else
; 3090 : 		//			renderer->SetColor (0x000000FF);		//RED
; 3091 : 					Tpoint	Pos=Button3DList.buttons[i].loc;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Pos$67[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _Pos$67[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _Pos$67[ebp+8], edx

; 3092 : 					Pos.x+=headPan.x*B3D_POSITION_SCALING;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+33664]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$67[ebp]
	movss	DWORD PTR _Pos$67[ebp], xmm0

; 3093 : 					Pos.y+=headPan.y*B3D_POSITION_SCALING;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33668]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$67[ebp+4]
	movss	DWORD PTR _Pos$67[ebp+4], xmm0

; 3094 : 					Pos.z+=headPan.z*B3D_POSITION_SCALING;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+33672]
	mulss	xmm0, DWORD PTR __real@440e4000
	addss	xmm0, DWORD PTR _Pos$67[ebp+8]
	movss	DWORD PTR _Pos$67[ebp+8], xmm0

; 3095 : 
; 3096 : 				renderer->TransformCameraCentricPoint(&Pos,&t1);

	lea	eax, DWORD PTR _t1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Pos$67[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33576]
	call	?TransformCameraCentricPoint@Render3D@@QAEXPAUTpoint@@PAUThreeDVertex@@@Z ; Render3D::TransformCameraCentricPoint

; 3097 : 
; 3098 : 				if (t1.csZ<0) {			//Wombat778 10-11-2003 Only show those points in front of us. Why it does this is beyond me.

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _t1$[ebp+48]
	jbe	$LN6@VCock_Exec

; 3099 : 
; 3100 : 					renderer->SetColor (0x000000FF);		//RED

	push	255					; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 3101 : 
; 3102 : 				
; 3103 : 
; 3104 : 					renderer->Render2DPoint(t1.x,t1.y);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3105 : 					renderer->Render2DPoint(t1.x,t1.y-1);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3106 : 					renderer->Render2DPoint(t1.x,t1.y+1);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3107 : 					renderer->Render2DPoint(t1.x-1,t1.y);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3108 : 					renderer->Render2DPoint(t1.x-1,t1.y-1);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3109 : 					renderer->Render2DPoint(t1.x-1,t1.y+1);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3110 : 					renderer->Render2DPoint(t1.x+1,t1.y);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3111 : 					renderer->Render2DPoint(t1.x+1,t1.y-1);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3112 : 					renderer->Render2DPoint(t1.x+1,t1.y+1);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+120]
	call	edx

; 3113 : 
; 3114 : 
; 3115 : 					renderer->SetColor (0x0000ffff);		//Yellow

	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 3116 : 							
; 3117 : 					//Normalize the distance so it is affected by the FOV and by the resolution
; 3118 : 					//Todo: add something about the SA bar.  Currently, the dist increases too much when it is active
; 3119 : 					float td = ((float) DisplayOptions.DispWidth/ 1600.0f) * (Button3DList.buttons[i].dist/(1.5f*(float)GetFOV()));	

	movzx	eax, WORD PTR ?DisplayOptions@@3VDisplayOptionsClass@@A
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@44c80000
	mov	esi, DWORD PTR _i$[ebp]
	shl	esi, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv8083[ebp], xmm0
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv7967[ebp]
	movss	xmm0, DWORD PTR tv7967[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+esi+12]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv8083[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _td$40[ebp], xmm0

; 3120 : 
; 3121 : 					renderer->Render2DPoint(t1.x-td,t1.y);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR _td$40[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+120]
	call	eax

; 3122 : 					renderer->Render2DPoint(t1.x+td,t1.y);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR _td$40[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+120]
	call	eax

; 3123 : 					renderer->Render2DPoint(t1.x,t1.y+td);

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	addss	xmm0, DWORD PTR _td$40[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+120]
	call	eax

; 3124 : 					renderer->Render2DPoint(t1.x,t1.y-td);	

	movss	xmm0, DWORD PTR _t1$[ebp+4]
	subss	xmm0, DWORD PTR _td$40[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+120]
	call	eax
$LN6@VCock_Exec:

; 3125 : 				
; 3126 : 				}
; 3127 : 
; 3128 : 				 //Button3DList.buttons[i].dist);
; 3129 : 				
; 3130 : 			
; 3131 : 			}

	jmp	$LN8@VCock_Exec
$LN7@VCock_Exec:

; 3132 : 		renderer->SetColor ( pVColors[TheTimeOfDay.GetNVGmode() != 0][5] );

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetNVGmode@CTimeOfDay@@QAEHXZ		; CTimeOfDay::GetNVGmode
	test	eax, eax
	je	SHORT $LN538@VCock_Exec
	mov	DWORD PTR tv5441[ebp], 1
	jmp	SHORT $LN539@VCock_Exec
$LN538@VCock_Exec:
	mov	DWORD PTR tv5441[ebp], 0
$LN539@VCock_Exec:
	mov	ecx, DWORD PTR tv5441[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+33696]
	mov	ecx, 4
	imul	ecx, 5
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+33576]
	mov	edx, DWORD PTR [eax+92]
	call	edx
$LN10@VCock_Exec:

; 3133 : 		}
; 3134 : 
; 3135 : #if 0
; 3136 : 	/*
; 3137 : 	** Do ALT indictator
; 3138 : 	*/
; 3139 : 	float alt = -((AircraftClass *)otwPlatform)->af->z;
; 3140 : 	alt = fmod( alt, 1000.0f );
; 3141 : 	alt = alt * 0.001f * 2.0 * PI;
; 3142 : 
; 3143 : 	x1 = 0.0f;
; 3144 : 	y1 = 0.0f;
; 3145 :    mlSinCos (&trig, alt);
; 3146 : 	x2 = 0.85f * trig.cos;
; 3147 : 	y2 = 0.85f * -trig.sin;
; 3148 :     vcInfo.vALTrenderer->Line( x1, y1, x2, y2 );
; 3149 : 
; 3150 : 	/*
; 3151 : 	** Do OIL indictator
; 3152 : 	*/
; 3153 : 	float oil = ((AircraftClass *)otwPlatform)->af->rpm;
; 3154 : 	oil = oil  * 2.0 * PI;
; 3155 : 
; 3156 : 	x1 = 0.0f;
; 3157 : 	y1 = 0.0f;
; 3158 :    mlSinCos (&trig, oil);
; 3159 : 	x2 = 0.85f * trig.cos;
; 3160 : 	y2 = 0.85f * -trig.sin;
; 3161 :     vcInfo.vOILrenderer->Line( x1, y1, x2, y2 );
; 3162 : 
; 3163 : 	/*
; 3164 : 	** Do NOZ indictator
; 3165 : 	*/
; 3166 : 	float noz = ((AircraftClass *)otwPlatform)->af->rpm;
; 3167 : 	noz = noz  * 2.0 * PI;
; 3168 : 
; 3169 : 	x1 = 0.0f;
; 3170 : 	y1 = 0.0f;
; 3171 :    mlSinCos (&trig, noz);
; 3172 : 	x2 = 0.85f * trig.cos;
; 3173 : 	y2 = 0.85f * -trig.sin;
; 3174 :     vcInfo.vNOZrenderer->Line( x1, y1, x2, y2 );
; 3175 : 
; 3176 : 	/*
; 3177 : 	** Do RPM indictator
; 3178 : 	*/
; 3179 : 	float rpm = ((AircraftClass *)otwPlatform)->af->rpm;
; 3180 : 	rpm = rpm  * 2.0 * PI;
; 3181 : 
; 3182 : 	x1 = 0.0f;
; 3183 : 	y1 = 0.0f;
; 3184 :    mlSinCos (&trig, rpm);
; 3185 : 	x2 = 0.85f * trig.cos;
; 3186 : 	y2 = 0.85f * -trig.sin;
; 3187 :     vcInfo.vRPMrenderer->Line( x1, y1, x2, y2 );
; 3188 : 
; 3189 : 	/*
; 3190 : 	** Do FTIT indictator
; 3191 : 	*/
; 3192 : 	x1 = 0.0f;
; 3193 : 	y1 = 0.0f;
; 3194 : 	x2 = 0.0f;
; 3195 : 	y2 = 0.85f;
; 3196 :     vcInfo.vFTITrenderer->Line( x1, y1, x2, y2 );
; 3197 : #endif
; 3198 : 
; 3199 : // 2001-01-31 ADDED BY S.G. SO HMS EQUIPPED PLANE HAS TWO GREEN CONCENTRIC CIRCLE IN PADLOCK VIEW
; 3200 : 	VehicleClassDataType	*vc	= (VehicleClassDataType *)Falcon4ClassTable[otwPlatform->Type() - VU_LAST_ENTITY_TYPE].dataPtr;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	sub	eax, 100				; 00000064H
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	mov	DWORD PTR _vc$[ebp], edx

; 3201 : 	if (vc && vc->Flags & 0x20000000)

	cmp	DWORD PTR _vc$[ebp], 0
	je	$LN2@VCock_Exec
	mov	eax, DWORD PTR _vc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 536870912				; 20000000H
	je	$LN2@VCock_Exec

; 3202 : 	{
; 3203 : 		MissileClass* theMissile;
; 3204 : 		theMissile = (MissileClass*)(SimDriver.GetPlayerAircraft()->Sms->GetCurrentWeapon());

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+940]
	mov	DWORD PTR tv5478[ebp], edx
	mov	eax, DWORD PTR tv5478[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv5478[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _theMissile$44[ebp], eax

; 3205 : 
; 3206 : 		// First, make sure we have a Aim9 in uncage mode selected...
; 3207 : 		if (SimDriver.GetPlayerAircraft()->Sms->curWeaponType == wtAim9)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+148], 1
	jne	$LN2@VCock_Exec

; 3208 : 		{
; 3209 : 			if (theMissile && theMissile->isCaged == 0)

	cmp	DWORD PTR _theMissile$44[ebp], 0
	je	$LN2@VCock_Exec
	mov	edx, DWORD PTR _theMissile$44[ebp]
	cmp	DWORD PTR [edx+728], 0
	jne	$LN2@VCock_Exec

; 3210 : 			{
; 3211 : 				theMissile->RunSeeker();

	mov	ecx, DWORD PTR _theMissile$44[ebp]
	call	?RunSeeker@MissileClass@@QAEXXZ		; MissileClass::RunSeeker

; 3212 : 
; 3213 : 				if (!theMissile->targetPtr || vuxRealTime & 0x100 ) // JB 010712 Flash when we have a target locked up

	mov	eax, DWORD PTR _theMissile$44[ebp]
	cmp	DWORD PTR [eax+656], 0
	je	SHORT $LN1@VCock_Exec
	mov	ecx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	ecx, 256				; 00000100H
	je	$LN2@VCock_Exec
$LN1@VCock_Exec:

; 3214 : 				{
; 3215 : 					float xDiff, left, right, top, bottom;
; 3216 : 
; 3217 : 					renderer->GetViewport(&left, &top, &right, &bottom);

	lea	edx, DWORD PTR _bottom$2[ebp]
	push	edx
	lea	eax, DWORD PTR _right$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _top$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _left$13[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	call	?GetViewport@VirtualDisplay@@QAEXPAM000@Z ; VirtualDisplay::GetViewport

; 3218 : 					renderer->SetColor (TheHud->GetHudColor());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetHudColor@HudClass@@QAEKXZ		; HudClass::GetHudColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 3219 : 
; 3220 : 					xDiff = right - left;

	movss	xmm0, DWORD PTR _right$14[ebp]
	subss	xmm0, DWORD PTR _left$13[ebp]
	movss	DWORD PTR _xDiff$46[ebp], xmm0

; 3221 : 					renderer->CenterOriginInViewport();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport

; 3222 : 					//renderer->Circle(0.0f, 0.0f, xDiff / 30.0F);
; 3223 : 					renderer->Circle(0.0f, 0.0f, xDiff / 20.0F);

	movss	xmm0, DWORD PTR _xDiff$46[ebp]
	divss	xmm0, DWORD PTR __real@41a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33576]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 3224 : 					renderer->Line(-xDiff / 50.0f, 0.0f, xDiff / 50.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xDiff$46[ebp]
	divss	xmm0, DWORD PTR __real@42480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xDiff$46[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@42480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 3225 : 					renderer->Line(0.0f, -xDiff / 50.0f, 0.0f, xDiff / 50.0f);

	movss	xmm0, DWORD PTR _xDiff$46[ebp]
	divss	xmm0, DWORD PTR __real@42480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xDiff$46[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR __real@42480000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN2@VCock_Exec:

; 3226 : 				}
; 3227 : 			}
; 3228 : 		}
; 3229 : 	}
; 3230 : // END OF ADDED SECTION
; 3231 : 
; 3232 : 	renderer->SetColor (TheHud->GetHudColor());

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	call	?GetHudColor@HudClass@@QAEKXZ		; HudClass::GetHudColor
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+33576]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+33576]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 3233 : 	renderer->SetCamera( &cameraPos, &cameraRot );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33452				; 000082acH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33440				; 000082a0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera
$LN374@VCock_Exec:

; 3234 : #endif
; 3235 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?VCock_Exec@OTWDriverClass@@AAEXXZ ENDP			; OTWDriverClass::VCock_Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv455 = -144						; size = 8
tv391 = -136						; size = 4
tv491 = -132						; size = 4
tv351 = -128						; size = 4
tv432 = -124						; size = 4
_dt$1 = -120						; size = 4
tv387 = -116						; size = 4
tv222 = -112						; size = 4
tv223 = -108						; size = 4
tv219 = -104						; size = 4
tv452 = -100						; size = 4
tv230 = -96						; size = 4
tv241 = -92						; size = 4
_playerAC$ = -88					; size = 4
tv233 = -84						; size = 4
tv245 = -80						; size = 4
tv244 = -76						; size = 4
tv234 = -72						; size = 4
_gs$2 = -68						; size = 4
_x$3 = -64						; size = 4
_actualtilt$4 = -60					; size = 4
_fov$5 = -56						; size = 4
_actualrollrate$6 = -52					; size = 4
_actualpan$7 = -48					; size = 4
_this$ = -44						; size = 4
$T8 = -40						; size = 12
_Pan$9 = -28						; size = 12
_Ho$10 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?VCock_HeadCalc@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::VCock_HeadCalc
; _this$ = ecx

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1246 : 	if ((mUseHeadTracking) && (g_n6DOFTIR))	// Retro 24Dez2004

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+34016], 0
	je	$LN24@VCock_Head
	cmp	DWORD PTR ?g_n6DOFTIR@@3HA, 0		; g_n6DOFTIR
	je	$LN24@VCock_Head

; 1247 : 	{
; 1248 : 
; 1249 : 		// Use TIR 6 DOF - Cobra
; 1250 : 		if (g_n6DOFTIR == 1)

	cmp	DWORD PTR ?g_n6DOFTIR@@3HA, 1		; g_n6DOFTIR
	jne	$LN23@VCock_Head

; 1251 : 		{	
; 1252 : 			Tpoint Pan;
; 1253 : 			Pan.x = theTrackIRObject.getZ() / 16383.0f * -1.25f; // Cobra - changed from +/-4' to +/-1.75'

	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getZ@TrackIR@@QAEMXZ			; TrackIR::getZ
	fstp	DWORD PTR tv351[ebp]
	movss	xmm0, DWORD PTR tv351[ebp]
	divss	xmm0, DWORD PTR __real@467ffc00
	mulss	xmm0, DWORD PTR __real@bfa00000
	movss	DWORD PTR _Pan$9[ebp], xmm0

; 1254 : 			Pan.y = theTrackIRObject.getX() / 16383.0f * -0.50f;

	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getX@TrackIR@@QAEMXZ			; TrackIR::getX
	fstp	DWORD PTR tv387[ebp]
	movss	xmm0, DWORD PTR tv387[ebp]
	divss	xmm0, DWORD PTR __real@467ffc00
	mulss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR _Pan$9[ebp+4], xmm0

; 1255 : 			Pan.z = theTrackIRObject.getY() / 16383.0f * -0.75f;

	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getY@TrackIR@@QAEMXZ			; TrackIR::getY
	fstp	DWORD PTR tv391[ebp]
	movss	xmm0, DWORD PTR tv391[ebp]
	divss	xmm0, DWORD PTR __real@467ffc00
	mulss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR _Pan$9[ebp+8], xmm0

; 1256 : 
; 1257 : 			// If using DX Engine, orient head with the cockpit/platform, head movements oriented with head rotation
; 1258 : 			if(g_bUse_DX_Engine){

	movzx	ecx, BYTE PTR ?g_bUse_DX_Engine@@3_NA	; g_bUse_DX_Engine
	test	ecx, ecx
	je	SHORT $LN22@VCock_Head

; 1259 : 				MatrixMult(&headMatrix, &Pan, &headPan);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33664				; 00008380H
	push	edx
	lea	eax, DWORD PTR _Pan$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33616				; 00008350H
	push	ecx
	call	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z ; MatrixMult
	add	esp, 12					; 0000000cH

; 1260 : 				MatrixMult(&OTWDriver.ownshipRot, &headPan, &headOrigin);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33652				; 00008374H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33664				; 00008380H
	push	eax
	push	OFFSET ?OTWDriver@@3VOTWDriverClass@@A+33580
	call	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z ; MatrixMult
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN21@VCock_Head
$LN22@VCock_Head:

; 1261 : 			} else headOrigin=headPan;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33664				; 00008380H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33652				; 00008374H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
$LN21@VCock_Head:

; 1262 : 		}
; 1263 : 		else // g_n6DOFTIR = 2 - Hold Viewpoint at 0,0,0 and use FOV zoom for forward/back movement - Cobra

	jmp	$LN14@VCock_Head
$LN23@VCock_Head:

; 1264 : 		{
; 1265 : 			float	x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x$3[ebp], xmm0

; 1266 : 			float	fov = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fov$5[ebp], xmm0

; 1267 : 			headOrigin.x=headOrigin.y=headOrigin.z=0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+33660], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+33656], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+33652], xmm0

; 1268 : 			headPan=headOrigin;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33652				; 00008374H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33664				; 00008380H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1269 : 
; 1270 : 			x = -(theTrackIRObject.getZ() / 16383.0f); // +/-1.0

	mov	ecx, OFFSET ?theTrackIRObject@@3VTrackIR@@A ; theTrackIRObject
	call	?getZ@TrackIR@@QAEMXZ			; TrackIR::getZ
	fstp	DWORD PTR tv432[ebp]
	movss	xmm0, DWORD PTR tv432[ebp]
	divss	xmm0, DWORD PTR __real@467ffc00
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _x$3[ebp], xmm0

; 1271 : 			if (x > 0.0f)

	movss	xmm0, DWORD PTR _x$3[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@VCock_Head

; 1272 : 				fov = g_fDefaultFOV - (x * (g_fDefaultFOV - g_fTIRMinimumFOV));

	movss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	subss	xmm0, DWORD PTR ?g_fTIRMinimumFOV@@3MA
	mulss	xmm0, DWORD PTR _x$3[ebp]
	movss	xmm1, DWORD PTR ?g_fDefaultFOV@@3MA
	subss	xmm1, xmm0
	movss	DWORD PTR _fov$5[ebp], xmm1
	jmp	SHORT $LN16@VCock_Head
$LN19@VCock_Head:

; 1273 : 			else if (x < 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _x$3[ebp]
	jbe	SHORT $LN17@VCock_Head

; 1274 : 				fov = g_fDefaultFOV + (-x * (g_fTIRMaximumFOV - g_fDefaultFOV));

	movss	xmm0, DWORD PTR _x$3[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR ?g_fTIRMaximumFOV@@3MA
	subss	xmm1, DWORD PTR ?g_fDefaultFOV@@3MA
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	movss	DWORD PTR _fov$5[ebp], xmm0

; 1275 : 			else

	jmp	SHORT $LN16@VCock_Head
$LN17@VCock_Head:

; 1276 : 				fov = g_fDefaultFOV;

	movss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	movss	DWORD PTR _fov$5[ebp], xmm0
$LN16@VCock_Head:

; 1277 : 
; 1278 : 			OTWDriver.SetFOV(fov * DTR);

	movss	xmm0, DWORD PTR _fov$5[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetFOV@OTWDriverClass@@QAEXM@Z		; OTWDriverClass::SetFOV

; 1279 : 
; 1280 : 			if (fov == g_fDefaultFOV)

	movss	xmm0, DWORD PTR _fov$5[ebp]
	ucomiss	xmm0, DWORD PTR ?g_fDefaultFOV@@3MA
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@VCock_Head

; 1281 : 				narrowFOV = FALSE;

	mov	DWORD PTR ?narrowFOV@@3HA, 0		; narrowFOV

; 1282 : 			else

	jmp	SHORT $LN14@VCock_Head
$LN15@VCock_Head:

; 1283 : 				narrowFOV = TRUE;

	mov	DWORD PTR ?narrowFOV@@3HA, 1		; narrowFOV
$LN14@VCock_Head:

; 1284 : 		}
; 1285 : 	}
; 1286 : 	else	// Retro 24Dez2004

	jmp	$LN2@VCock_Head
$LN24@VCock_Head:

; 1287 : 	{
; 1288 : 		//ATARIBABY start new dynamic head movement more like old DID EF2000 days :-)
; 1289 : 		if (g_b3dDynamicPilotHead) 

	movzx	eax, BYTE PTR ?g_b3dDynamicPilotHead@@3_NA ; g_b3dDynamicPilotHead
	test	eax, eax
	je	$LN12@VCock_Head

; 1290 : 		{
; 1291 :             // Pu239 initilize those before use!
; 1292 : 			float actualtilt = 0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _actualtilt$4[ebp], xmm0

; 1293 : 			float actualrollrate = 0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _actualrollrate$6[ebp], xmm0

; 1294 : 			float actualpan = 0.0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _actualpan$7[ebp], xmm0

; 1295 : 			//ATARIBABY disabled now - fwd/back lean cause normals problems and i not know solution yet
; 1296 : 			//float actualaccel; 
; 1297 : 			
; 1298 : 			//ATARIBABY disabled now - fwd/back lean cause normals problems and i not know solution yet
; 1299 : 			//Tpoint origin = {0.0, 0.0, 0.0}; 
; 1300 : 
; 1301 : 			float dt = (vuxGameTime - BobbingPreviousTime) / 2000.0f;

	mov	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	sub	ecx, DWORD PTR _BobbingPreviousTime
	mov	DWORD PTR tv452[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv452[ebp]
	mov	edx, DWORD PTR tv452[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv455[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv455[ebp]
	divss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR _dt$1[ebp], xmm0

; 1302 : 			if (dt)

	movss	xmm0, DWORD PTR _dt$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN11@VCock_Head

; 1303 : 			{
; 1304 : 				//ATARIBABY disabled now - fwd/back lean cause normals problems and i not know solution yet
; 1305 : 				//get accel in X axis (forward/backward accel)
; 1306 : 				//actualaccel = -SimDriver.GetPlayerAircraft()->af->nxcgb;
; 1307 : 				
; 1308 : 				//compute actual tilt change
; 1309 : 				actualtilt=((cockpitFlightData.gs - 1.0F) * 0.015F) * g_fDyn_Head_TiltMul;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3c75c28f
	mulss	xmm0, DWORD PTR ?g_fDyn_Head_TiltMul@@3MA
	movss	DWORD PTR _actualtilt$4[ebp], xmm0

; 1310 : 				// with higher Gs add more random shaking
; 1311 : 				int gs = (int)cockpitFlightData.gs;

	cvttss2si eax, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	mov	DWORD PTR _gs$2[ebp], eax

; 1312 : 				gs = gs - 1;

	mov	ecx, DWORD PTR _gs$2[ebp]
	sub	ecx, 1
	mov	DWORD PTR _gs$2[ebp], ecx

; 1313 : 				if (gs != 0) 

	je	SHORT $LN10@VCock_Head

; 1314 : 					actualtilt=actualtilt + (((rand() % gs) / 2000.0F) * g_fDyn_Head_TiltRndGMul);

	call	_rand
	cdq
	idiv	DWORD PTR _gs$2[ebp]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR ?g_fDyn_Head_TiltRndGMul@@3MA
	addss	xmm0, DWORD PTR _actualtilt$4[ebp]
	movss	DWORD PTR _actualtilt$4[ebp], xmm0

; 1315 : 				else

	jmp	SHORT $LN9@VCock_Head
$LN10@VCock_Head:

; 1316 : 					actualtilt=0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _actualtilt$4[ebp], xmm0
$LN9@VCock_Head:

; 1317 : 				//compute actual roll change
; 1318 : 				actualrollrate = cockpitFlightData.roll - BobbingPreviousRoll;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	subss	xmm0, DWORD PTR _BobbingPreviousRoll
	movss	DWORD PTR _actualrollrate$6[ebp], xmm0

; 1319 : 				if (actualrollrate > PI)

	movss	xmm0, DWORD PTR _actualrollrate$6[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN8@VCock_Head

; 1320 : 					actualrollrate = -(PI - cockpitFlightData.roll + PI + BobbingPreviousRoll);

	movss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	addss	xmm0, DWORD PTR __real@40490fdb
	addss	xmm0, DWORD PTR _BobbingPreviousRoll
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _actualrollrate$6[ebp], xmm0
	jmp	SHORT $LN6@VCock_Head
$LN8@VCock_Head:

; 1321 : 				else if (actualrollrate < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _actualrollrate$6[ebp]
	jbe	SHORT $LN6@VCock_Head

; 1322 : 					actualrollrate = PI + cockpitFlightData.roll + PI - BobbingPreviousRoll;

	movss	xmm0, DWORD PTR __real@40490fdb
	addss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	addss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR _BobbingPreviousRoll
	movss	DWORD PTR _actualrollrate$6[ebp], xmm0
$LN6@VCock_Head:

; 1323 : 				actualrollrate = (actualrollrate * 0.15F) * g_fDyn_Head_RollMul;

	movss	xmm0, DWORD PTR _actualrollrate$6[ebp]
	mulss	xmm0, DWORD PTR __real@3e19999a
	mulss	xmm0, DWORD PTR ?g_fDyn_Head_RollMul@@3MA
	movss	DWORD PTR _actualrollrate$6[ebp], xmm0

; 1324 : 				//compute actual pan
; 1325 : 				actualpan = cockpitFlightData.yaw - BobbingPreviousPan;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	subss	xmm0, DWORD PTR _BobbingPreviousPan
	movss	DWORD PTR _actualpan$7[ebp], xmm0

; 1326 : 				if (actualpan > PI)

	movss	xmm0, DWORD PTR _actualpan$7[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN5@VCock_Head

; 1327 : 					actualpan = -(PI - cockpitFlightData.yaw + PI + BobbingPreviousPan);

	movss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	addss	xmm0, DWORD PTR __real@40490fdb
	addss	xmm0, DWORD PTR _BobbingPreviousPan
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _actualpan$7[ebp], xmm0
	jmp	SHORT $LN3@VCock_Head
$LN5@VCock_Head:

; 1328 : 				else if (actualpan < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _actualpan$7[ebp]
	jbe	SHORT $LN3@VCock_Head

; 1329 : 					actualpan = PI + cockpitFlightData.yaw + PI - BobbingPreviousPan;

	movss	xmm0, DWORD PTR __real@40490fdb
	addss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	addss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR _BobbingPreviousPan
	movss	DWORD PTR _actualpan$7[ebp], xmm0
$LN3@VCock_Head:

; 1330 : 				actualpan = actualpan * g_fDyn_Head_PanMul;

	movss	xmm0, DWORD PTR _actualpan$7[ebp]
	mulss	xmm0, DWORD PTR ?g_fDyn_Head_PanMul@@3MA
	movss	DWORD PTR _actualpan$7[ebp], xmm0

; 1331 : 
; 1332 : 				// my old crappy execution
; 1333 : 				//Head roll move damping
; 1334 : 	//			if (actualrollrate < BobbingRollRate && BobbingRollRate > -0.5F ) 
; 1335 : 	//				BobbingRollRate = BobbingRollRate - 0.001F;
; 1336 : 	//			if (actualrollrate > BobbingRollRate && BobbingRollRate < 0.5F)  
; 1337 : 	//				BobbingRollRate = BobbingRollRate + 0.001F;
; 1338 : 				//Head tilt move damping
; 1339 : 	//			if (actualtilt < BobbingTilt && BobbingTilt > -0.5F) 
; 1340 : 	//				BobbingTilt = BobbingTilt - 0.001F;
; 1341 : 	//			if (actualtilt > BobbingTilt && BobbingTilt < 0.5F) 
; 1342 : 	//				BobbingTilt = BobbingTilt + 0.001F;
; 1343 : 				//Head pan move damping
; 1344 : 	//			if (actualpan < BobbingPan && BobbingPan > -0.5F) 
; 1345 : 	//				BobbingPan = BobbingPan - 0.001F;
; 1346 : 	//			if (actualpan > BobbingPan && BobbingPan < 0.5F) 
; 1347 : 	//				BobbingPan = BobbingPan + 0.001F;
; 1348 : 
; 1349 : 				BobbingPreviousTime = vuxGameTime;

	mov	edx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	mov	DWORD PTR _BobbingPreviousTime, edx
$LN11@VCock_Head:

; 1350 : 			}
; 1351 : 			BobbingPreviousRoll = cockpitFlightData.roll;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR _BobbingPreviousRoll, xmm0

; 1352 : 			BobbingPreviousPan = cockpitFlightData.yaw;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+44
	movss	DWORD PTR _BobbingPreviousPan, xmm0

; 1353 : 
; 1354 : 			//better execution
; 1355 : 			BobbingTilt = MoveByRate(BobbingTilt,actualtilt, ((abs(cockpitFlightData.gs)+1.0F) * g_fDyn_Head_TiltGRateMul) * g_fDyn_Head_TiltRateMul); //tilt rate is G's sensitive

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [esp], xmm0
	call	?abs@@YAMM@Z				; abs
	add	esp, 4
	fstp	DWORD PTR tv491[ebp]
	movss	xmm0, DWORD PTR tv491[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR ?g_fDyn_Head_TiltGRateMul@@3MA
	mulss	xmm0, DWORD PTR ?g_fDyn_Head_TiltRateMul@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _actualtilt$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR ?BobbingTilt@@3MA		; BobbingTilt

; 1356 : 			BobbingTilt = max(-0.13F,min(0.13f,BobbingTilt));

	movss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	comiss	xmm0, DWORD PTR __real@3e051eb8
	jbe	SHORT $LN27@VCock_Head
	movss	xmm0, DWORD PTR __real@3e051eb8
	movss	DWORD PTR tv219[ebp], xmm0
	jmp	SHORT $LN28@VCock_Head
$LN27@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	movss	DWORD PTR tv219[ebp], xmm0
$LN28@VCock_Head:
	movss	xmm0, DWORD PTR __real@be051eb8
	comiss	xmm0, DWORD PTR tv219[ebp]
	jbe	SHORT $LN31@VCock_Head
	movss	xmm0, DWORD PTR __real@be051eb8
	movss	DWORD PTR tv223[ebp], xmm0
	jmp	SHORT $LN32@VCock_Head
$LN31@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	comiss	xmm0, DWORD PTR __real@3e051eb8
	jbe	SHORT $LN29@VCock_Head
	movss	xmm0, DWORD PTR __real@3e051eb8
	movss	DWORD PTR tv222[ebp], xmm0
	jmp	SHORT $LN30@VCock_Head
$LN29@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	movss	DWORD PTR tv222[ebp], xmm0
$LN30@VCock_Head:
	movss	xmm0, DWORD PTR tv222[ebp]
	movss	DWORD PTR tv223[ebp], xmm0
$LN32@VCock_Head:
	movss	xmm0, DWORD PTR tv223[ebp]
	movss	DWORD PTR ?BobbingTilt@@3MA, xmm0

; 1357 : 			BobbingRollRate = MoveByRate(BobbingRollRate,actualrollrate, g_fDyn_Head_RollRate); //change this to alter roll speed

	push	ecx
	movss	xmm0, DWORD PTR ?g_fDyn_Head_RollRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _actualrollrate$6[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR ?BobbingRollRate@@3MA		; BobbingRollRate

; 1358 : 			BobbingRollRate = max(-0.08F,min(0.08f,BobbingRollRate));

	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	comiss	xmm0, DWORD PTR __real@3da3d70a
	jbe	SHORT $LN33@VCock_Head
	movss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR tv230[ebp], xmm0
	jmp	SHORT $LN34@VCock_Head
$LN33@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	movss	DWORD PTR tv230[ebp], xmm0
$LN34@VCock_Head:
	movss	xmm0, DWORD PTR __real@bda3d70a
	comiss	xmm0, DWORD PTR tv230[ebp]
	jbe	SHORT $LN37@VCock_Head
	movss	xmm0, DWORD PTR __real@bda3d70a
	movss	DWORD PTR tv234[ebp], xmm0
	jmp	SHORT $LN38@VCock_Head
$LN37@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	comiss	xmm0, DWORD PTR __real@3da3d70a
	jbe	SHORT $LN35@VCock_Head
	movss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR tv233[ebp], xmm0
	jmp	SHORT $LN36@VCock_Head
$LN35@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	movss	DWORD PTR tv233[ebp], xmm0
$LN36@VCock_Head:
	movss	xmm0, DWORD PTR tv233[ebp]
	movss	DWORD PTR tv234[ebp], xmm0
$LN38@VCock_Head:
	movss	xmm0, DWORD PTR tv234[ebp]
	movss	DWORD PTR ?BobbingRollRate@@3MA, xmm0

; 1359 : 			BobbingPan = MoveByRate(BobbingPan,actualpan, g_fDyn_Head_PanRate); //change this to alter pan speed

	push	ecx
	movss	xmm0, DWORD PTR ?g_fDyn_Head_PanRate@@3MA
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _actualpan$7[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?BobbingPan@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveByRate@OTWDriverClass@@AAEMMMM@Z	; OTWDriverClass::MoveByRate
	fstp	DWORD PTR ?BobbingPan@@3MA		; BobbingPan

; 1360 : 			BobbingPan = max(-0.10F,min(0.10f,BobbingPan));

	movss	xmm0, DWORD PTR ?BobbingPan@@3MA
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN39@VCock_Head
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv241[ebp], xmm0
	jmp	SHORT $LN40@VCock_Head
$LN39@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingPan@@3MA
	movss	DWORD PTR tv241[ebp], xmm0
$LN40@VCock_Head:
	movss	xmm0, DWORD PTR __real@bdcccccd
	comiss	xmm0, DWORD PTR tv241[ebp]
	jbe	SHORT $LN43@VCock_Head
	movss	xmm0, DWORD PTR __real@bdcccccd
	movss	DWORD PTR tv245[ebp], xmm0
	jmp	SHORT $LN44@VCock_Head
$LN43@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingPan@@3MA
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN41@VCock_Head
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv244[ebp], xmm0
	jmp	SHORT $LN42@VCock_Head
$LN41@VCock_Head:
	movss	xmm0, DWORD PTR ?BobbingPan@@3MA
	movss	DWORD PTR tv244[ebp], xmm0
$LN42@VCock_Head:
	movss	xmm0, DWORD PTR tv244[ebp]
	movss	DWORD PTR tv245[ebp], xmm0
$LN44@VCock_Head:
	movss	xmm0, DWORD PTR tv245[ebp]
	movss	DWORD PTR ?BobbingPan@@3MA, xmm0

; 1361 : 			//ATARIBABY disabled now - fwd/back lean cause normals problems and i not know solution yet
; 1362 : 			//BobbingAccel = MoveByRate(BobbingAccel,actualaccel, 30.0f); //change this to alter accel speed
; 1363 : 
; 1364 : 			//ATARIBABY disabled now - fwd/back lean cause normals pro	blems and i not know solution yet
; 1365 : 			//origin.x = max(-0.9F,min(0.9f,BobbingAccel * 2.0f));
; 1366 : 			//origin.y = 0.0;
; 1367 : 			//origin.z = 0.0;
; 1368 : 
; 1369 : 			//ATARIBABY disabled now - fwd/back lean cause normals problems and i not know solution yet
; 1370 : 			//renderer->SetCamera( &origin, &headMatrix );
; 1371 : 
; 1372 : 			headOrigin=headPan=Origin;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33664				; 00008380H
	mov	ecx, DWORD PTR ?Origin@@3UTpoint@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?Origin@@3UTpoint@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?Origin@@3UTpoint@@B+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33664				; 00008380H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33652				; 00008374H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1373 : 		}
; 1374 : 		else

	jmp	SHORT $LN2@VCock_Head
$LN12@VCock_Head:

; 1375 : 			headOrigin=headPan=Origin;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33664				; 00008380H
	mov	ecx, DWORD PTR ?Origin@@3UTpoint@@B
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ?Origin@@3UTpoint@@B+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ?Origin@@3UTpoint@@B+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33664				; 00008380H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33652				; 00008374H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
$LN2@VCock_Head:

; 1376 : 
; 1377 : 		//ATARIBABY end
; 1378 : 	}	// Retro 24Dez2004
; 1379 : 
; 1380 : 
; 1381 : 	// COBRA - RED - Introduced Airframe Vibrations
; 1382 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 1383 : 	if (playerAC){

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN1@VCock_Head

; 1384 : 		PitTurbulence = playerAC->GetTurbulence();

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?GetTurbulence@AircraftClass@@QAE?AUTpoint@@XZ ; AircraftClass::GetTurbulence
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 34036				; 000084f4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1385 : 		Tpoint	Ho;
; 1386 : 		headPan.x+=PitTurbulence.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33664]
	addss	xmm0, DWORD PTR [edx+34036]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+33664], xmm0

; 1387 : 		headPan.y+=PitTurbulence.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33668]
	addss	xmm0, DWORD PTR [edx+34040]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+33668], xmm0

; 1388 : 		headPan.z+=PitTurbulence.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33672]
	addss	xmm0, DWORD PTR [edx+34044]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+33672], xmm0

; 1389 : 		MatrixMult(&OTWDriver.ownshipRot, &PitTurbulence, &Ho);

	lea	ecx, DWORD PTR _Ho$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 34036				; 000084f4H
	push	edx
	push	OFFSET ?OTWDriver@@3VOTWDriverClass@@A+33580
	call	?MatrixMult@@YAXPBUTrotation@@PBUTpoint@@PAU2@@Z ; MatrixMult
	add	esp, 12					; 0000000cH

; 1390 : 		headOrigin.x+=Ho.x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+33652]
	addss	xmm0, DWORD PTR _Ho$10[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+33652], xmm0

; 1391 : 		headOrigin.y+=Ho.y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+33656]
	addss	xmm0, DWORD PTR _Ho$10[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+33656], xmm0

; 1392 : 		headOrigin.z+=Ho.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+33660]
	addss	xmm0, DWORD PTR _Ho$10[ebp+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+33660], xmm0
$LN1@VCock_Head:

; 1393 : 	}
; 1394 : 
; 1395 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?VCock_HeadCalc@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::VCock_HeadCalc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_oldState$ = -8						; size = 4
_this$ = -4						; size = 4
?VCock_DrawThePit@OTWDriverClass@@AAEXXZ PROC		; OTWDriverClass::VCock_DrawThePit
; _this$ = ecx

; 1427 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1428 :     int				oldState;
; 1429 : 
; 1430 : 	// COBRA - DX - if using DX Engine, PIT has to be Oriented as in 3D WORLD SPACE
; 1431 : 	vrCockpit->orientation=OTWDriver.ownshipRot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [eax+33996]
	add	edi, 48					; 00000030H
	mov	ecx, 9
	mov	esi, OFFSET ?OTWDriver@@3VOTWDriverClass@@A+33580
	rep movsd

; 1432 : 	renderer->SetCamera( &headOrigin, &headMatrix );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33616				; 00008350H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33652				; 00008374H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	call	?SetCamera@Render3D@@QAEXPBUTpoint@@PBUTrotation@@@Z ; Render3D::SetCamera

; 1433 : 	oldState = renderer->GetObjectTextureState();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+33576]
	call	?GetObjectTextureState@Render3D@@QAEHXZ	; Render3D::GetObjectTextureState
	mov	DWORD PTR _oldState$[ebp], eax

; 1434 : 	renderer->SetObjectTextureState( TRUE );

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33576]
	call	?SetObjectTextureState@Render3D@@QAEXH@Z ; Render3D::SetObjectTextureState

; 1435 : 	vrCockpit->Draw( renderer );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+33576]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+33996]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+33996]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 1436 : 	renderer->SetObjectTextureState( oldState );

	mov	ecx, DWORD PTR _oldState$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+33576]
	call	?SetObjectTextureState@Render3D@@QAEXH@Z ; Render3D::SetObjectTextureState

; 1437 : 
; 1438 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?VCock_DrawThePit@OTWDriverClass@@AAEXXZ ENDP		; OTWDriverClass::VCock_DrawThePit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv170 = -28						; size = 4
tv169 = -24						; size = 4
tv162 = -20						; size = 4
tv89 = -16						; size = 4
tv88 = -12						; size = 4
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_dT$ = 8						; size = 4
?VCock_CheckStopStates@OTWDriverClass@@AAEXM@Z PROC	; OTWDriverClass::VCock_CheckStopStates
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 	if(stopState == STOP_STATE0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32084], 0
	jne	$LN26@VCock_Chec

; 139  : 		if((azDir > 0.0F && eyePan <= PAN_LIMIT * DTR) || (azDir < 0.0F && eyePan >= PAN_LIMIT * DTR)){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32296]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN23@VCock_Chec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40278d35
	comiss	xmm0, DWORD PTR [edx+32272]
	jae	SHORT $LN24@VCock_Chec
$LN23@VCock_Chec:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+32296]
	jbe	$LN25@VCock_Chec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	comiss	xmm0, DWORD PTR __real@40278d35
	jb	$LN25@VCock_Chec
$LN24@VCock_Chec:

; 140  : 
; 141  : 			stopState = STOP_STATE1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32084], 1

; 142  : 			eyePan	= min(max(eyePan, -PAN_LIMIT * DTR), PAN_LIMIT * DTR);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN29@VCock_Chec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR tv81[ebp], xmm0
	jmp	SHORT $LN30@VCock_Chec
$LN29@VCock_Chec:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv81[ebp], xmm0
$LN30@VCock_Chec:
	movss	xmm0, DWORD PTR __real@40278d35
	comiss	xmm0, DWORD PTR tv81[ebp]
	jbe	SHORT $LN33@VCock_Chec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN31@VCock_Chec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN32@VCock_Chec
$LN31@VCock_Chec:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv88[ebp], xmm0
$LN32@VCock_Chec:
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN34@VCock_Chec
$LN33@VCock_Chec:
	movss	xmm0, DWORD PTR __real@40278d35
	movss	DWORD PTR tv89[ebp], xmm0
$LN34@VCock_Chec:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR [ecx+32272], xmm0

; 143  : 			F4SoundFXSetDist(SFX_CP_UGH, TRUE, 0.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	1
	push	151					; 00000097H
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H

; 144  : 		}
; 145  : 		else {

	jmp	SHORT $LN22@VCock_Chec
$LN25@VCock_Chec:

; 146  : 			VCock_RunNormalMotion(dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z ; OTWDriverClass::VCock_RunNormalMotion
$LN22@VCock_Chec:

; 147  : 		}

	jmp	$LN1@VCock_Chec
$LN26@VCock_Chec:

; 148  : 	}
; 149  : 	else if(stopState == STOP_STATE1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32084], 1
	jne	$LN20@VCock_Chec

; 150  : 		if((azDir > 0.0F && eyePan <= -PAN_LIMIT * DTR) || (azDir < 0.0F && eyePan >= PAN_LIMIT * DTR)){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32296]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN17@VCock_Chec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [ecx+32272]
	jae	SHORT $LN18@VCock_Chec
$LN17@VCock_Chec:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+32296]
	jbe	SHORT $LN19@VCock_Chec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@40278d35
	jb	SHORT $LN19@VCock_Chec
$LN18@VCock_Chec:

; 151  : 			stopState = STOP_STATE1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32084], 1
	jmp	SHORT $LN14@VCock_Chec
$LN19@VCock_Chec:

; 152  : 		}
; 153  : 		else if(azDir == 0.0F) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32296]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@VCock_Chec

; 154  : 			stopState = STOP_STATE2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32084], 2

; 155  : 		}
; 156  : 		else {

	jmp	SHORT $LN14@VCock_Chec
$LN15@VCock_Chec:

; 157  : 			stopState = STOP_STATE0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32084], 0
$LN14@VCock_Chec:

; 158  : 		}

	jmp	$LN1@VCock_Chec
$LN20@VCock_Chec:

; 159  : 	}
; 160  : 	else if(stopState == STOP_STATE2) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32084], 2
	jne	$LN12@VCock_Chec

; 161  : 		if((azDir > 0.0F && eyePan <= -PAN_LIMIT * DTR) || (azDir < 0.0F && eyePan >= PAN_LIMIT * DTR)){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32296]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@VCock_Chec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [ecx+32272]
	jae	SHORT $LN10@VCock_Chec
$LN9@VCock_Chec:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+32296]
	jbe	$LN11@VCock_Chec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@40278d35
	jb	$LN11@VCock_Chec
$LN10@VCock_Chec:

; 162  : 			headMotion	= HEAD_TRANSISTION1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32048], 2

; 163  : 			initialTilt	= eyeTilt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32276]
	mov	DWORD PTR [edx+32076], ecx

; 164  : 			eyePan		= min(max(eyePan, -PAN_LIMIT * DTR), PAN_LIMIT * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN35@VCock_Chec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN36@VCock_Chec
$LN35@VCock_Chec:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv162[ebp], xmm0
$LN36@VCock_Chec:
	movss	xmm0, DWORD PTR __real@40278d35
	comiss	xmm0, DWORD PTR tv162[ebp]
	jbe	SHORT $LN39@VCock_Chec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN37@VCock_Chec
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN38@VCock_Chec
$LN37@VCock_Chec:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv169[ebp], xmm0
$LN38@VCock_Chec:
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN40@VCock_Chec
$LN39@VCock_Chec:
	movss	xmm0, DWORD PTR __real@40278d35
	movss	DWORD PTR tv170[ebp], xmm0
$LN40@VCock_Chec:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR [eax+32272], xmm0

; 165  : 			if(eyePan <= -PAN_LIMIT * DTR) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [ecx+32272]
	jb	SHORT $LN8@VCock_Chec

; 166  : 				snapDir	= LTOR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+32080], xmm0

; 167  : 			}
; 168  : 			else {

	jmp	SHORT $LN7@VCock_Chec
$LN8@VCock_Chec:

; 169  : 				snapDir = RTOL;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+32080], xmm0
$LN7@VCock_Chec:

; 170  : 			}

	jmp	SHORT $LN4@VCock_Chec
$LN11@VCock_Chec:

; 171  : 		}
; 172  : 		else if(azDir == 0.0F) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32296]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@VCock_Chec

; 173  : 			VCock_RunNormalMotion(dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z ; OTWDriverClass::VCock_RunNormalMotion

; 174  : 			stopState = STOP_STATE2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32084], 2

; 175  : 		}
; 176  : 		else {

	jmp	SHORT $LN4@VCock_Chec
$LN5@VCock_Chec:

; 177  : 			stopState = STOP_STATE0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32084], 0

; 178  : 			VCock_RunNormalMotion(dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z ; OTWDriverClass::VCock_RunNormalMotion
$LN4@VCock_Chec:

; 179  : 		}

	jmp	SHORT $LN1@VCock_Chec
$LN12@VCock_Chec:

; 180  : 	}
; 181  : 	else if(stopState == STOP_STATE3) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32084], 3
	jne	SHORT $LN1@VCock_Chec

; 182  : 		if(azDir == 0.0F) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32296]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@VCock_Chec

; 183  : 			stopState = STOP_STATE2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32084], 2
$LN1@VCock_Chec:

; 184  : 		}
; 185  : 	}
; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?VCock_CheckStopStates@OTWDriverClass@@AAEXM@Z ENDP	; OTWDriverClass::VCock_CheckStopStates
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv641 = -160						; size = 4
tv529 = -156						; size = 4
tv608 = -152						; size = 4
tv539 = -148						; size = 4
tv598 = -144						; size = 4
tv590 = -140						; size = 4
tv521 = -136						; size = 4
tv189 = -132						; size = 4
tv218 = -128						; size = 4
tv170 = -124						; size = 4
tv238 = -120						; size = 4
tv144 = -116						; size = 4
tv246 = -112						; size = 4
tv181 = -108						; size = 4
tv343 = -104						; size = 4
tv162 = -100						; size = 4
tv342 = -96						; size = 4
tv130 = -92						; size = 4
tv335 = -88						; size = 4
tv90 = -84						; size = 4
tv328 = -80						; size = 4
tv231 = -76						; size = 4
tv315 = -72						; size = 4
tv199 = -68						; size = 4
tv296 = -64						; size = 4
tv188 = -60						; size = 4
tv276 = -56						; size = 4
tv174 = -52						; size = 4
tv275 = -48						; size = 4
tv169 = -44						; size = 4
tv268 = -40						; size = 4
tv145 = -36						; size = 4
tv261 = -32						; size = 4
tv137 = -28						; size = 4
tv260 = -24						; size = 4
tv129 = -20						; size = 4
tv253 = -16						; size = 4
tv245 = -12						; size = 4
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_dT$ = 8						; size = 4
?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z PROC	; OTWDriverClass::VCock_RunNormalMotion
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 	stopState	= STOP_STATE0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32084], 0

; 191  : 
; 192  : 	if (!mUseHeadTracking)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+34016], 0
	jne	$LN32@VCock_RunN

; 193  : 	{
; 194  : 		eyePan		-= azDir * slewRate * 4.0F * dT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32296]
	mulss	xmm0, DWORD PTR [eax+32304]
	mulss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+32272]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+32272], xmm1

; 195  : 		eyeTilt		+= elDir * slewRate * 4.0F * dT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32300]
	mulss	xmm0, DWORD PTR [ecx+32304]
	mulss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+32276]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+32276], xmm0

; 196  : 
; 197  : 		//Wombat778 2-21-04 Removed this as it doesnt seem pointful
; 198  : 
; 199  : 		/*	   if(eyeTilt <= -90.0F * DTR) {
; 200  : 		eyePan		= min(max(eyePan, -PAN_LIMIT * DTR), PAN_LIMIT * DTR);
; 201  : 		eyeTilt		= min(max(eyeTilt, -140.0F * DTR), 25.0F * DTR);
; 202  : 		//		eyeTilt		= min(max(eyeTilt, -150.0F * DTR), 25.0F * DTR);
; 203  : 		// BuildHeadMatrix(TRUE, YAW_PITCH, eyePan + 180.0F * DTR, -(eyeTilt + 180.0F * DTR), 0.0F);
; 204  : 		BuildHeadMatrix(TRUE, YAW_PITCH, (eyePan + 180.0F * DTR) + BobbingPan, -(eyeTilt + 180.0F * DTR) + BobbingTilt, BobbingRollRate);  //ATARIBABY dynamic head added
; 205  : 		}
; 206  : 		else 
; 207  : 		{		   
; 208  : 		*/
; 209  : 		//Wombat778 2-21-2004  Changed the expandedheadrange variable to the following independant adjustments.  This should allow a suitable head range
; 210  : 		// to be selected as more complete 3d pits get built in the future
; 211  : 		switch (g_n3DHeadPanRange)

	mov	ecx, DWORD PTR ?g_n3DHeadPanRange@@3HA	; g_n3DHeadPanRange
	mov	DWORD PTR tv83[ebp], ecx
	cmp	DWORD PTR tv83[ebp], 0
	je	SHORT $LN29@VCock_RunN
	cmp	DWORD PTR tv83[ebp], 1
	je	$LN28@VCock_RunN
	cmp	DWORD PTR tv83[ebp], 2
	je	$LN27@VCock_RunN
	jmp	$LN23@VCock_RunN
$LN29@VCock_RunN:

; 212  : 		{
; 213  : 		case 0:																	//MPS default pan stops
; 214  : 			eyePan		= min(max(eyePan, -PAN_LIMIT * DTR), PAN_LIMIT * DTR);			   

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN35@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN36@VCock_RunN
$LN35@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv90[ebp], xmm0
$LN36@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40278d35
	comiss	xmm0, DWORD PTR tv90[ebp]
	jbe	SHORT $LN39@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN37@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR tv129[ebp], xmm0
	jmp	SHORT $LN38@VCock_RunN
$LN37@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv129[ebp], xmm0
$LN38@VCock_RunN:
	movss	xmm0, DWORD PTR tv129[ebp]
	movss	DWORD PTR tv130[ebp], xmm0
	jmp	SHORT $LN40@VCock_RunN
$LN39@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40278d35
	movss	DWORD PTR tv130[ebp], xmm0
$LN40@VCock_RunN:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv130[ebp]
	movss	DWORD PTR [eax+32272], xmm0

; 215  : 			break;		   

	jmp	$LN30@VCock_RunN
$LN28@VCock_RunN:

; 216  : 		case 1:																	//Stops removed.  +-180degrees
; 217  : 			eyePan		= min(max(eyePan, -180.0f * DTR), 180.0f * DTR);			

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	comiss	xmm0, DWORD PTR __real@c0490fd9
	jbe	SHORT $LN41@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR tv137[ebp], xmm0
	jmp	SHORT $LN42@VCock_RunN
$LN41@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0490fd9
	movss	DWORD PTR tv137[ebp], xmm0
$LN42@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40490fd9
	comiss	xmm0, DWORD PTR tv137[ebp]
	jbe	SHORT $LN45@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@c0490fd9
	jbe	SHORT $LN43@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR tv144[ebp], xmm0
	jmp	SHORT $LN44@VCock_RunN
$LN43@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0490fd9
	movss	DWORD PTR tv144[ebp], xmm0
$LN44@VCock_RunN:
	movss	xmm0, DWORD PTR tv144[ebp]
	movss	DWORD PTR tv145[ebp], xmm0
	jmp	SHORT $LN46@VCock_RunN
$LN45@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR tv145[ebp], xmm0
$LN46@VCock_RunN:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR [edx+32272], xmm0

; 218  : 			break;

	jmp	$LN30@VCock_RunN
$LN27@VCock_RunN:

; 219  : 		case 2:																	//Wraparound left/right
; 220  : 			if (eyePan > 180.0f * DTR) eyePan-=360.0f *DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN26@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+32272], xmm0
	jmp	SHORT $LN24@VCock_RunN
$LN26@VCock_RunN:

; 221  : 			else if (eyePan < -180.0f * DTR) eyePan+=360.0f *DTR;			   

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [eax+32272]
	jbe	SHORT $LN24@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+32272], xmm0
$LN24@VCock_RunN:

; 222  : 			break;

	jmp	$LN30@VCock_RunN
$LN23@VCock_RunN:

; 223  : 		default:
; 224  : 			eyePan		= min(max(eyePan, -PAN_LIMIT * DTR), PAN_LIMIT * DTR);			   

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN47@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN48@VCock_RunN
$LN47@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv162[ebp], xmm0
$LN48@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40278d35
	comiss	xmm0, DWORD PTR tv162[ebp]
	jbe	SHORT $LN51@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@c0278d35
	jbe	SHORT $LN49@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN50@VCock_RunN
$LN49@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv169[ebp], xmm0
$LN50@VCock_RunN:
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN52@VCock_RunN
$LN51@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40278d35
	movss	DWORD PTR tv170[ebp], xmm0
$LN52@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR [ecx+32272], xmm0
$LN30@VCock_RunN:

; 225  : 			break;
; 226  : 		}			   
; 227  : 
; 228  : 		switch (g_n3DHeadTiltRange)

	mov	edx, DWORD PTR ?g_n3DHeadTiltRange@@3HA	; g_n3DHeadTiltRange
	mov	DWORD PTR tv174[ebp], edx
	cmp	DWORD PTR tv174[ebp], 4
	ja	$LN10@VCock_RunN
	mov	eax, DWORD PTR tv174[ebp]
	jmp	DWORD PTR $LN95@VCock_RunN[eax*4]
$LN20@VCock_RunN:

; 229  : 		{
; 230  : 
; 231  : 		case 0:																	//MPS default tilt
; 232  : 			eyeTilt		= min(max(eyeTilt, -140.0F * DTR), 25.0F * DTR);			  

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN53@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR tv181[ebp], xmm0
	jmp	SHORT $LN54@VCock_RunN
$LN53@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv181[ebp], xmm0
$LN54@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3edf66f1
	comiss	xmm0, DWORD PTR tv181[ebp]
	jbe	SHORT $LN57@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN55@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR tv188[ebp], xmm0
	jmp	SHORT $LN56@VCock_RunN
$LN55@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv188[ebp], xmm0
$LN56@VCock_RunN:
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR tv189[ebp], xmm0
	jmp	SHORT $LN58@VCock_RunN
$LN57@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3edf66f1
	movss	DWORD PTR tv189[ebp], xmm0
$LN58@VCock_RunN:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv189[ebp]
	movss	DWORD PTR [edx+32276], xmm0

; 233  : 			break;

	jmp	$LN21@VCock_RunN
$LN19@VCock_RunN:

; 234  : 		case 1:																	//BMS default tilt.  Takes FOV into account
; 235  : 			if (GetFOV() < 60.0F * DTR)											//Wombat778 10-23-2003  Dont do anything with FOV if it is greater than 60

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv521[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv521[ebp]
	jbe	$LN18@VCock_RunN

; 236  : 				eyeTilt		= min(max(eyeTilt, -140.0F * DTR), (35.0F + ((60.0F - (GetFOV()* RTD)))*
; 237  : 								0.395F) * DTR); 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN59@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR tv199[ebp], xmm0
	jmp	SHORT $LN60@VCock_RunN
$LN59@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv199[ebp], xmm0
$LN60@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv529[ebp]
	movss	xmm0, DWORD PTR tv529[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR __real@42700000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3eca3d71
	addss	xmm1, DWORD PTR __real@420c0000
	mulss	xmm1, DWORD PTR __real@3c8efa34
	comiss	xmm1, DWORD PTR tv199[ebp]
	jbe	SHORT $LN63@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN61@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR tv218[ebp], xmm0
	jmp	SHORT $LN62@VCock_RunN
$LN61@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv218[ebp], xmm0
$LN62@VCock_RunN:
	movss	xmm0, DWORD PTR tv218[ebp]
	movss	DWORD PTR tv231[ebp], xmm0
	jmp	SHORT $LN64@VCock_RunN
$LN63@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv539[ebp]
	movss	xmm0, DWORD PTR tv539[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR __real@42700000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3eca3d71
	addss	xmm1, DWORD PTR __real@420c0000
	mulss	xmm1, DWORD PTR __real@3c8efa34
	movss	DWORD PTR tv231[ebp], xmm1
$LN64@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv231[ebp]
	movss	DWORD PTR [ecx+32276], xmm0

; 238  : 			else

	jmp	$LN17@VCock_RunN
$LN18@VCock_RunN:

; 239  : 				eyeTilt		= min(max(eyeTilt, -140.0F * DTR), 40.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN65@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR tv238[ebp], xmm0
	jmp	SHORT $LN66@VCock_RunN
$LN65@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv238[ebp], xmm0
$LN66@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3f32b8c1
	comiss	xmm0, DWORD PTR tv238[ebp]
	jbe	SHORT $LN69@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN67@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR tv245[ebp], xmm0
	jmp	SHORT $LN68@VCock_RunN
$LN67@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv245[ebp], xmm0
$LN68@VCock_RunN:
	movss	xmm0, DWORD PTR tv245[ebp]
	movss	DWORD PTR tv246[ebp], xmm0
	jmp	SHORT $LN70@VCock_RunN
$LN69@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3f32b8c1
	movss	DWORD PTR tv246[ebp], xmm0
$LN70@VCock_RunN:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR [eax+32276], xmm0
$LN17@VCock_RunN:

; 240  : 			break;

	jmp	$LN21@VCock_RunN
$LN16@VCock_RunN:

; 241  : 		case 2:																	//Significantly expanded tilt range.  Can look 90 degrees down		
; 242  : 			eyeTilt		= min(max(eyeTilt, -140.0F * DTR), 90.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN71@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR tv253[ebp], xmm0
	jmp	SHORT $LN72@VCock_RunN
$LN71@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv253[ebp], xmm0
$LN72@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv253[ebp]
	jbe	SHORT $LN75@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	comiss	xmm0, DWORD PTR __real@c01c61a9
	jbe	SHORT $LN73@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR tv260[ebp], xmm0
	jmp	SHORT $LN74@VCock_RunN
$LN73@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c01c61a9
	movss	DWORD PTR tv260[ebp], xmm0
$LN74@VCock_RunN:
	movss	xmm0, DWORD PTR tv260[ebp]
	movss	DWORD PTR tv261[ebp], xmm0
	jmp	SHORT $LN76@VCock_RunN
$LN75@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv261[ebp], xmm0
$LN76@VCock_RunN:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv261[ebp]
	movss	DWORD PTR [edx+32276], xmm0

; 243  : 			break;

	jmp	$LN21@VCock_RunN
$LN15@VCock_RunN:

; 244  : 		case 3:																	//Full vertical range +- 180 degrees
; 245  : 			eyeTilt		= min(max(eyeTilt, -180.0F * DTR), 180.0F * DTR);			   

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	comiss	xmm0, DWORD PTR __real@c0490fd9
	jbe	SHORT $LN77@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN78@VCock_RunN
$LN77@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0490fd9
	movss	DWORD PTR tv268[ebp], xmm0
$LN78@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40490fd9
	comiss	xmm0, DWORD PTR tv268[ebp]
	jbe	SHORT $LN81@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	comiss	xmm0, DWORD PTR __real@c0490fd9
	jbe	SHORT $LN79@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR tv275[ebp], xmm0
	jmp	SHORT $LN80@VCock_RunN
$LN79@VCock_RunN:
	movss	xmm0, DWORD PTR __real@c0490fd9
	movss	DWORD PTR tv275[ebp], xmm0
$LN80@VCock_RunN:
	movss	xmm0, DWORD PTR tv275[ebp]
	movss	DWORD PTR tv276[ebp], xmm0
	jmp	SHORT $LN82@VCock_RunN
$LN81@VCock_RunN:
	movss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR tv276[ebp], xmm0
$LN82@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv276[ebp]
	movss	DWORD PTR [ecx+32276], xmm0

; 246  : 			break;

	jmp	$LN21@VCock_RunN
$LN14@VCock_RunN:

; 247  : 		case 4:																	//Wraparound tilt
; 248  : 			if (eyeTilt > 180.0f * DTR) eyeTilt-=360.0f *DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN13@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32276], xmm0
	jmp	SHORT $LN11@VCock_RunN
$LN13@VCock_RunN:

; 249  : 			else if (eyeTilt < -180.0f * DTR) eyeTilt+=360.0f *DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [edx+32276]
	jbe	SHORT $LN11@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32276], xmm0
$LN11@VCock_RunN:

; 250  : 			break;

	jmp	$LN21@VCock_RunN
$LN10@VCock_RunN:

; 251  : 		default:
; 252  : 			if (GetFOV() < 60.0F * DTR)										

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv590[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv590[ebp]
	jbe	$LN9@VCock_RunN

; 253  : 				eyeTilt		= min(max(eyeTilt, -110.0F * DTR), 
; 254  : 				(35.0F + ((60.0F - (GetFOV()* RTD)))* 0.395F) * DTR); 

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	comiss	xmm0, DWORD PTR __real@bff5be09
	jbe	SHORT $LN83@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR tv296[ebp], xmm0
	jmp	SHORT $LN84@VCock_RunN
$LN83@VCock_RunN:
	movss	xmm0, DWORD PTR __real@bff5be09
	movss	DWORD PTR tv296[ebp], xmm0
$LN84@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv598[ebp]
	movss	xmm0, DWORD PTR tv598[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR __real@42700000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3eca3d71
	addss	xmm1, DWORD PTR __real@420c0000
	mulss	xmm1, DWORD PTR __real@3c8efa34
	comiss	xmm1, DWORD PTR tv296[ebp]
	jbe	SHORT $LN87@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@bff5be09
	jbe	SHORT $LN85@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR tv315[ebp], xmm0
	jmp	SHORT $LN86@VCock_RunN
$LN85@VCock_RunN:
	movss	xmm0, DWORD PTR __real@bff5be09
	movss	DWORD PTR tv315[ebp], xmm0
$LN86@VCock_RunN:
	movss	xmm0, DWORD PTR tv315[ebp]
	movss	DWORD PTR tv328[ebp], xmm0
	jmp	SHORT $LN88@VCock_RunN
$LN87@VCock_RunN:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFOV@OTWDriverClass@@QAEMXZ		; OTWDriverClass::GetFOV
	fstp	DWORD PTR tv608[ebp]
	movss	xmm0, DWORD PTR tv608[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR __real@42700000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3eca3d71
	addss	xmm1, DWORD PTR __real@420c0000
	mulss	xmm1, DWORD PTR __real@3c8efa34
	movss	DWORD PTR tv328[ebp], xmm1
$LN88@VCock_RunN:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv328[ebp]
	movss	DWORD PTR [eax+32276], xmm0

; 255  : 			else

	jmp	$LN8@VCock_RunN
$LN9@VCock_RunN:

; 256  : 				eyeTilt		= min(max(eyeTilt, -110.0F * DTR), 35.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@bff5be09
	jbe	SHORT $LN89@VCock_RunN
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR tv335[ebp], xmm0
	jmp	SHORT $LN90@VCock_RunN
$LN89@VCock_RunN:
	movss	xmm0, DWORD PTR __real@bff5be09
	movss	DWORD PTR tv335[ebp], xmm0
$LN90@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3f1c61a9
	comiss	xmm0, DWORD PTR tv335[ebp]
	jbe	SHORT $LN93@VCock_RunN
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	comiss	xmm0, DWORD PTR __real@bff5be09
	jbe	SHORT $LN91@VCock_RunN
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR tv342[ebp], xmm0
	jmp	SHORT $LN92@VCock_RunN
$LN91@VCock_RunN:
	movss	xmm0, DWORD PTR __real@bff5be09
	movss	DWORD PTR tv342[ebp], xmm0
$LN92@VCock_RunN:
	movss	xmm0, DWORD PTR tv342[ebp]
	movss	DWORD PTR tv343[ebp], xmm0
	jmp	SHORT $LN94@VCock_RunN
$LN93@VCock_RunN:
	movss	xmm0, DWORD PTR __real@3f1c61a9
	movss	DWORD PTR tv343[ebp], xmm0
$LN94@VCock_RunN:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv343[ebp]
	movss	DWORD PTR [edx+32276], xmm0
$LN8@VCock_RunN:
$LN21@VCock_RunN:

; 257  : 			break;
; 258  : 		}			   
; 259  : 
; 260  : 
; 261  : 		// BuildHeadMatrix(FALSE, YAW_PITCH, eyePan, eyeTilt, 0.0F);
; 262  : 
; 263  : 		//Wombat778 2-24-2004 Added this to stop the head from flipping when looking above 90 degrees up
; 264  : 		//Wombat778 3-12-2003 changes >= 90.0 to > 90.0 which prevents a flip when looking directly down.
; 265  : 		//ATARIBABY added BobbingTilt change to tilt angle checks and branched for look up/down
; 266  : 
; 267  : 		if(eyeTilt + BobbingTilt < -90.0F * DTR) 		   

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	addss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	movss	xmm1, DWORD PTR __real@bfc90fd9
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@VCock_RunN

; 268  : 			BuildHeadMatrix(TRUE, YAW_PITCH, (eyePan + 180.0F * DTR) + BobbingPan, -(eyeTilt + 180.0F * DTR) + BobbingTilt, BobbingRollRate);  //ATARIBABY dynamic head added

	push	ecx
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	addss	xmm0, DWORD PTR __real@40490fd9
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	addss	xmm0, DWORD PTR __real@40490fd9
	addss	xmm0, DWORD PTR ?BobbingPan@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix
	jmp	$LN4@VCock_RunN
$LN7@VCock_RunN:

; 269  : 		else if(fabs(eyeTilt + BobbingTilt) > 90.0F * DTR) 		   

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	addss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv641[ebp]
	movss	xmm0, DWORD PTR tv641[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fd9
	jbe	SHORT $LN5@VCock_RunN

; 270  : 			BuildHeadMatrix(TRUE, YAW_PITCH, eyePan + BobbingPan, eyeTilt + BobbingTilt, BobbingRollRate); //ATARIBABY dynamic head added

	push	ecx
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	addss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	addss	xmm0, DWORD PTR ?BobbingPan@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 271  : 		else 

	jmp	SHORT $LN4@VCock_RunN
$LN5@VCock_RunN:

; 272  : 			BuildHeadMatrix(FALSE, YAW_PITCH, eyePan + BobbingPan, eyeTilt + BobbingTilt, BobbingRollRate); //ATARIBABY dynamic head added

	push	ecx
	movss	xmm0, DWORD PTR ?BobbingRollRate@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	addss	xmm0, DWORD PTR ?BobbingTilt@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	addss	xmm0, DWORD PTR ?BobbingPan@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix
$LN4@VCock_RunN:

; 273  : 		//	   }
; 274  : 	}
; 275  : 	else

	jmp	$LN1@VCock_RunN
$LN32@VCock_RunN:

; 276  : 	{
; 277  : 
; 278  : 		eyePan = cockpitFlightData.headYaw;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+136
	movss	DWORD PTR [edx+32272], xmm0

; 279  : 		eyeTilt = cockpitFlightData.headPitch;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+128
	movss	DWORD PTR [eax+32276], xmm0

; 280  : 		eyeHeadRoll = cockpitFlightData.headRoll;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+132
	movss	DWORD PTR [ecx+32280], xmm0

; 281  : 		if(eyeTilt <= -90.0F * DTR)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfc90fd9
	comiss	xmm0, DWORD PTR [edx+32276]
	jb	SHORT $LN2@VCock_RunN

; 282  : 			BuildHeadMatrix(TRUE, YAW_PITCH, eyePan, eyeTilt, eyeHeadRoll);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32280]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 283  : 		else

	jmp	SHORT $LN1@VCock_RunN
$LN2@VCock_RunN:

; 284  : 			BuildHeadMatrix(FALSE, YAW_PITCH, eyePan, eyeTilt, eyeHeadRoll);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32280]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix
$LN1@VCock_RunN:

; 285  : 	}
; 286  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN95@VCock_RunN:
	DD	$LN20@VCock_RunN
	DD	$LN19@VCock_RunN
	DD	$LN16@VCock_RunN
	DD	$LN15@VCock_RunN
	DD	$LN14@VCock_RunN
?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z ENDP	; OTWDriverClass::VCock_RunNormalMotion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
tv265 = -32						; size = 4
tv240 = -28						; size = 4
tv239 = -24						; size = 4
tv232 = -20						; size = 4
tv214 = -16						; size = 4
tv204 = -12						; size = 4
tv147 = -8						; size = 4
_this$ = -4						; size = 4
_dT$ = 8						; size = 4
?VCock_GiveGilmanHead@OTWDriverClass@@AAEXM@Z PROC	; OTWDriverClass::VCock_GiveGilmanHead
; _this$ = ecx

; 339  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 340  :    // No limits when using a head tracker
; 341  : 	if(padlockGlance != GlanceNone) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+33856], 0
	je	SHORT $LN32@VCock_Give

; 342  : 		VCock_Glance(dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_Glance@OTWDriverClass@@AAEXM@Z	; OTWDriverClass::VCock_Glance

; 343  : 		BuildHeadMatrix(FALSE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 344  : 	}
; 345  : 	else {

	jmp	$LN1@VCock_Give
$LN32@VCock_Give:

; 346  : 		if(headMotion == YAW_PITCH) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32048], 1
	jne	SHORT $LN27@VCock_Give

; 347  : 			if(eyePan <= -PAN_LIMIT * DTR ||  eyePan >= PAN_LIMIT * DTR) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [ecx+32272]
	jae	SHORT $LN28@VCock_Give
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@40278d35
	jb	SHORT $LN29@VCock_Give
$LN28@VCock_Give:

; 348  : 				VCock_CheckStopStates(dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_CheckStopStates@OTWDriverClass@@AAEXM@Z ; OTWDriverClass::VCock_CheckStopStates

; 349  : 			}
; 350  : 			else {

	jmp	SHORT $LN27@VCock_Give
$LN29@VCock_Give:

; 351  : 				VCock_RunNormalMotion(dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VCock_RunNormalMotion@OTWDriverClass@@AAEXM@Z ; OTWDriverClass::VCock_RunNormalMotion
$LN27@VCock_Give:

; 352  : 			}
; 353  : 		}
; 354  : 
; 355  : 		if(headMotion == HEAD_TRANSISTION1) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32048], 2
	jne	$LN20@VCock_Give

; 356  : 
; 357  : 			if(initialTilt <= -90.0F * DTR) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfc90fd9
	comiss	xmm0, DWORD PTR [ecx+32076]
	jb	SHORT $LN25@VCock_Give

; 358  : 				BuildHeadMatrix(TRUE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 359  : 				headMotion	= HEAD_TRANSISTION2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32048], 3
	jmp	$LN20@VCock_Give
$LN25@VCock_Give:

; 360  : 			}
; 361  : 			else if(initialTilt > -90.0F * DTR && eyeTilt > -92.0F * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32076]
	comiss	xmm0, DWORD PTR __real@bfc90fd9
	jbe	$LN23@VCock_Give
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	comiss	xmm0, DWORD PTR __real@bfcd87ab
	jbe	$LN23@VCock_Give

; 362  : 
; 363  : 				eyeTilt -= slewRate * 10.0F * dT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32304]
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+32276]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+32276], xmm1

; 364  : 
; 365  : 				eyeTilt = max(eyeTilt, -92.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@bfcd87ab
	jbe	SHORT $LN35@VCock_Give
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN36@VCock_Give
$LN35@VCock_Give:
	movss	xmm0, DWORD PTR __real@bfcd87ab
	movss	DWORD PTR tv147[ebp], xmm0
$LN36@VCock_Give:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR [eax+32276], xmm0

; 366  : 				if(eyeTilt >= -90.0F * DTR) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32276]
	comiss	xmm0, DWORD PTR __real@bfc90fd9
	jb	SHORT $LN22@VCock_Give

; 367  : 					BuildHeadMatrix(FALSE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 368  : 				}
; 369  : 				else {

	jmp	SHORT $LN21@VCock_Give
$LN22@VCock_Give:

; 370  : 					BuildHeadMatrix(TRUE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix
$LN21@VCock_Give:

; 371  : 				}
; 372  : 			}
; 373  : 			else {

	jmp	SHORT $LN20@VCock_Give
$LN23@VCock_Give:

; 374  : 				eyeTilt		= -92.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bfcd87ab
	movss	DWORD PTR [eax+32276], xmm0

; 375  : 				headMotion	= HEAD_TRANSISTION2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32048], 3
$LN20@VCock_Give:

; 376  : 			}
; 377  : 		}
; 378  : 
; 379  : 		if(headMotion == HEAD_TRANSISTION2) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32048], 3
	jne	$LN8@VCock_Give

; 380  : 
; 381  : 
; 382  : 			if((snapDir == RTOL || snapDir == LTOR) && ((eyePan >= PAN_LIMIT * DTR) || (eyePan <= -PAN_LIMIT * DTR))) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32080]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@VCock_Give
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32080]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN18@VCock_Give
$LN17@VCock_Give:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@40278d35
	jae	SHORT $LN16@VCock_Give
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [eax+32272]
	jb	$LN18@VCock_Give
$LN16@VCock_Give:

; 383  : 				eyePan		-= snapDir * slewRate * 10.0F * dT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32080]
	mulss	xmm0, DWORD PTR [edx+32304]
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+32272]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32272], xmm1

; 384  : 				if(eyePan > 180.0F * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN15@VCock_Give

; 385  : 					eyePan = -360.0F * DTR + eyePan;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0c90fd9
	addss	xmm0, DWORD PTR [eax+32272]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32272], xmm0
	jmp	SHORT $LN13@VCock_Give
$LN15@VCock_Give:

; 386  : 				}
; 387  : 				else if(eyePan < -180.0F * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [edx+32272]
	jbe	SHORT $LN13@VCock_Give

; 388  : 					eyePan = 360.0F * DTR + eyePan;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40c90fd9
	addss	xmm0, DWORD PTR [eax+32272]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32272], xmm0
$LN13@VCock_Give:

; 389  : 				}
; 390  : 
; 391  : 				if(eyePan < 0.0F) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+32272]
	jbe	SHORT $LN12@VCock_Give

; 392  : 					eyePan = min(eyePan, -PAN_LIMIT * DTR);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [eax+32272]
	jbe	SHORT $LN37@VCock_Give
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR tv204[ebp], xmm0
	jmp	SHORT $LN38@VCock_Give
$LN37@VCock_Give:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv204[ebp], xmm0
$LN38@VCock_Give:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR [edx+32272], xmm0

; 393  : 					if(eyePan == -PAN_LIMIT * DTR) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	ucomiss	xmm0, DWORD PTR __real@c0278d35
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@VCock_Give

; 394  : 						headMotion = HEAD_TRANSISTION3;			

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32048], 4
$LN11@VCock_Give:

; 395  : 					}
; 396  : 				}
; 397  : 				else {

	jmp	SHORT $LN9@VCock_Give
$LN12@VCock_Give:

; 398  : 
; 399  : 					eyePan = max(eyePan, PAN_LIMIT * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	comiss	xmm0, DWORD PTR __real@40278d35
	jbe	SHORT $LN39@VCock_Give
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR tv214[ebp], xmm0
	jmp	SHORT $LN40@VCock_Give
$LN39@VCock_Give:
	movss	xmm0, DWORD PTR __real@40278d35
	movss	DWORD PTR tv214[ebp], xmm0
$LN40@VCock_Give:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv214[ebp]
	movss	DWORD PTR [ecx+32272], xmm0

; 400  : 					if(eyePan == PAN_LIMIT * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32272]
	ucomiss	xmm0, DWORD PTR __real@40278d35
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@VCock_Give

; 401  : 						headMotion = HEAD_TRANSISTION3;			

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32048], 4
$LN9@VCock_Give:

; 402  : 					}
; 403  : 				}
; 404  : 				BuildHeadMatrix(TRUE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 405  : 			}
; 406  : 			else {

	jmp	$LN8@VCock_Give
$LN18@VCock_Give:

; 407  : 				eyePan	= max(min(eyePan, -PAN_LIMIT * DTR), PAN_LIMIT * DTR);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [eax+32272]
	jbe	SHORT $LN41@VCock_Give
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR tv232[ebp], xmm0
	jmp	SHORT $LN42@VCock_Give
$LN41@VCock_Give:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv232[ebp], xmm0
$LN42@VCock_Give:
	movss	xmm0, DWORD PTR tv232[ebp]
	comiss	xmm0, DWORD PTR __real@40278d35
	jbe	SHORT $LN45@VCock_Give
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR [edx+32272]
	jbe	SHORT $LN43@VCock_Give
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR tv239[ebp], xmm0
	jmp	SHORT $LN44@VCock_Give
$LN43@VCock_Give:
	movss	xmm0, DWORD PTR __real@c0278d35
	movss	DWORD PTR tv239[ebp], xmm0
$LN44@VCock_Give:
	movss	xmm0, DWORD PTR tv239[ebp]
	movss	DWORD PTR tv240[ebp], xmm0
	jmp	SHORT $LN46@VCock_Give
$LN45@VCock_Give:
	movss	xmm0, DWORD PTR __real@40278d35
	movss	DWORD PTR tv240[ebp], xmm0
$LN46@VCock_Give:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv240[ebp]
	movss	DWORD PTR [ecx+32272], xmm0

; 408  : 				headMotion = HEAD_TRANSISTION3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32048], 4
$LN8@VCock_Give:

; 409  : 			}
; 410  : 		}
; 411  : 
; 412  : 		if(headMotion == HEAD_TRANSISTION3) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32048], 4
	jne	$LN1@VCock_Give

; 413  : 
; 414  : 			if(/*azDir &&*/ initialTilt >= -92.0F * DTR){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32076]
	comiss	xmm0, DWORD PTR __real@bfcd87ab
	jb	$LN6@VCock_Give

; 415  : 
; 416  : 				if(eyeTilt < initialTilt) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32076]
	comiss	xmm0, DWORD PTR [eax+32276]
	jbe	SHORT $LN5@VCock_Give

; 417  : 					eyeTilt += slewRate * 10.0F * dT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32304]
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+32276]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+32276], xmm0

; 418  : 					eyeTilt = min(eyeTilt, initialTilt);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32076]
	comiss	xmm0, DWORD PTR [ecx+32276]
	jbe	SHORT $LN47@VCock_Give
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR tv265[ebp], xmm0
	jmp	SHORT $LN48@VCock_Give
$LN47@VCock_Give:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32076]
	movss	DWORD PTR tv265[ebp], xmm0
$LN48@VCock_Give:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv265[ebp]
	movss	DWORD PTR [edx+32276], xmm0

; 419  : 				}
; 420  : 				else {

	jmp	SHORT $LN4@VCock_Give
$LN5@VCock_Give:

; 421  : 					stopState = STOP_STATE3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32084], 3

; 422  : 
; 423  : 					eyeTilt = initialTilt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32076]
	mov	DWORD PTR [ecx+32276], eax

; 424  : 					headMotion	= YAW_PITCH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32048], 1
$LN4@VCock_Give:

; 425  : 				}
; 426  : 
; 427  : 				if(eyeTilt >= -90.0F * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32276]
	comiss	xmm0, DWORD PTR __real@bfc90fd9
	jb	SHORT $LN3@VCock_Give

; 428  : 					BuildHeadMatrix(FALSE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix

; 429  : 				}
; 430  : 				else {

	jmp	SHORT $LN2@VCock_Give
$LN3@VCock_Give:

; 431  : 					BuildHeadMatrix(TRUE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+32276]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix
$LN2@VCock_Give:

; 432  : 				}
; 433  : 			}
; 434  : 			else {

	jmp	SHORT $LN1@VCock_Give
$LN6@VCock_Give:

; 435  : 				stopState = STOP_STATE3;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32084], 3

; 436  : 
; 437  : 				eyeTilt = initialTilt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32076]
	mov	DWORD PTR [edx+32276], ecx

; 438  : 				headMotion	= YAW_PITCH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32048], 1

; 439  : 				BuildHeadMatrix(TRUE, YAW_PITCH, eyePan, eyeTilt, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32276]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32272]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildHeadMatrix@OTWDriverClass@@AAEXHHMMM@Z ; OTWDriverClass::BuildHeadMatrix
$LN1@VCock_Give:

; 440  : 			}
; 441  : 		}
; 442  : 	}
; 443  : 	// Combine the head and airplane matrices
; 444  : 	MatrixMult (&ownshipRot, &headMatrix, &cameraRot);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 33452				; 000082acH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 33616				; 00008350H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 33580				; 0000832cH
	push	ecx
	call	?MatrixMult@@YAXPBUTrotation@@0PAU1@@Z	; MatrixMult
	add	esp, 12					; 0000000cH

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?VCock_GiveGilmanHead@OTWDriverClass@@AAEXM@Z ENDP	; OTWDriverClass::VCock_GiveGilmanHead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\vcock.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dT$ = 8						; size = 4
?VCock_Glance@OTWDriverClass@@AAEXM@Z PROC		; OTWDriverClass::VCock_Glance
; _this$ = ecx

; 291  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 	// No glances when using a head tracker
; 293  : 	if (mUseHeadTracking)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+34016], 0
	je	SHORT $LN12@VCock_Glan

; 294  : 		return;

	jmp	$LN13@VCock_Glan
$LN12@VCock_Glan:

; 295  : 
; 296  : 	if(padlockGlance == GlanceNose) {					// if player glances forward

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33856], 1
	jne	$LN11@VCock_Glan

; 297  : 
; 298  : 		if(!mIsSlewInit) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33836], 0
	jne	SHORT $LN10@VCock_Glan

; 299  : 			mIsSlewInit = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33836], 1

; 300  : 			mSlewPStart				= eyePan;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32272]
	mov	DWORD PTR [ecx+33840], eax

; 301  : 			mSlewTStart				= eyeTilt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32276]
	mov	DWORD PTR [ecx+33844], eax
$LN10@VCock_Glan:

; 302  : 		}
; 303  : 		PadlockF3_SlewCamera(mSlewPStart, mSlewTStart, 0.0F, 0.0F, 5.0F, 0.001F, dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+33844]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+33840]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PadlockF3_SlewCamera@OTWDriverClass@@AAEHMMMMMMM@Z ; OTWDriverClass::PadlockF3_SlewCamera
	jmp	$LN1@VCock_Glan
$LN11@VCock_Glan:

; 304  : 	}
; 305  : 	else if (padlockGlance == GlanceTail) {			// if player glances back

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+33856], 2
	jne	$LN8@VCock_Glan

; 306  : 
; 307  : 		if(eyePan < 0.0F) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+32272]
	jbe	$LN7@VCock_Glan

; 308  : 
; 309  : 			if(!mIsSlewInit) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+33836], 0
	jne	SHORT $LN6@VCock_Glan

; 310  : 				mIsSlewInit = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33836], 1

; 311  : 				mSlewPStart				= eyePan;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32272]
	mov	DWORD PTR [ecx+33840], eax

; 312  : 				mSlewTStart				= eyeTilt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32276]
	mov	DWORD PTR [ecx+33844], eax
$LN6@VCock_Glan:

; 313  : 			}
; 314  : 
; 315  : 			PadlockF3_SlewCamera(mSlewPStart, mSlewTStart, -180.0F * DTR,  0.0F, 5.0F, 0.001F, dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c0490fd9
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+33844]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+33840]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PadlockF3_SlewCamera@OTWDriverClass@@AAEHMMMMMMM@Z ; OTWDriverClass::PadlockF3_SlewCamera
	jmp	$LN2@VCock_Glan
$LN7@VCock_Glan:

; 316  : 		}
; 317  : 		else if(eyePan > 0.0F) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32272]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN4@VCock_Glan

; 318  : 
; 319  : 			if(!mIsSlewInit) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+33836], 0
	jne	SHORT $LN3@VCock_Glan

; 320  : 				mIsSlewInit = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+33836], 1

; 321  : 				mSlewPStart				= eyePan;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32272]
	mov	DWORD PTR [eax+33840], edx

; 322  : 				mSlewTStart				= eyeTilt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32276]
	mov	DWORD PTR [eax+33844], edx
$LN3@VCock_Glan:

; 323  : 			}
; 324  : 
; 325  : 			PadlockF3_SlewCamera(mSlewPStart, mSlewTStart, 180.0F * DTR, 0.0F, 5.0F, 0.001F, dT);

	push	ecx
	movss	xmm0, DWORD PTR _dT$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+33844]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+33840]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PadlockF3_SlewCamera@OTWDriverClass@@AAEHMMMMMMM@Z ; OTWDriverClass::PadlockF3_SlewCamera

; 326  : 		}
; 327  : 		else {

	jmp	SHORT $LN2@VCock_Glan
$LN4@VCock_Glan:

; 328  : 			eyePan	= 0.001F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR [edx+32272], xmm0
$LN2@VCock_Glan:

; 329  : 		}
; 330  : 	}
; 331  : 	else {

	jmp	SHORT $LN1@VCock_Glan
$LN8@VCock_Glan:

; 332  : 		padlockGlance = GlanceNone;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33856], 0
$LN1@VCock_Glan:
$LN13@VCock_Glan:

; 333  : 	}
; 334  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?VCock_Glance@OTWDriverClass@@AAEXM@Z ENDP		; OTWDriverClass::VCock_Glance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXPAPAVVDial@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXPAPAVVDial@@0@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1693 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1694 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXPAPAVVDial@@0@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXXZ PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1668 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXXZ ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXXZ ; std::vector<VDial *,std::allocator<VDial *> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEII@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEPAPAVVDial@@I@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVVDial@@@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEPAPAVVDial@@PAPAV2@00@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Umove<VDial * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@I@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXPAPAVVDial@@0@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@I@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1521 : 		this->_Myfirst = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBE_NPBQAVVDial@@@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBE_NPBQAVVDial@@@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBE_NPBQAVVDial@@@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEII@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::vector<VDial *,std::allocator<VDial *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEII@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXPAPAVVDial@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXPAPAVVDial@@0@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@@std@@YAXPAPAVVDial@@0AAU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<VDial *> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXPAPAVVDial@@0@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXXZ PROC ; std::vector<VDial *,std::allocator<VDial *> >::clear, COMDAT
; _this$ = ecx

; 1413 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1414 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXPAPAVVDial@@0@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Destroy

; 1416 : 		this->_Mylast = this->_Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 1417 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXXZ ENDP ; std::vector<VDial *,std::allocator<VDial *> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXABQAVVDial@@@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXABQAVVDial@@@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVVDial@@@std@@YAPBQAVVDial@@ABQAV1@@Z ; std::addressof<VDial * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBE_NPBQAVVDial@@@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@QAVVDial@@@std@@YAPBQAVVDial@@ABQAV1@@Z ; std::addressof<VDial * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR __Idx$1[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXPAPAVVDial@@0@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Idx$1[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVVDial@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * &>

; 1193 : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IAEXI@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@IBEXPAPAVVDial@@0@Z ; std::vector<VDial *,std::allocator<VDial *> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVVDial@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<VDial *> >::construct<VDial *,VDial * const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEXABQAVVDial@@@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEAAPAVVDial@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEAAPAVVDial@@I@Z PROC ; std::vector<VDial *,std::allocator<VDial *> >::operator[], COMDAT
; _this$ = ecx

; 1136 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QAEAAPAVVDial@@I@Z ENDP ; std::vector<VDial *,std::allocator<VDial *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ PROC ; std::vector<VDial *,std::allocator<VDial *> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<VDial *> >::max_size

; 1093 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ENDP ; std::vector<VDial *,std::allocator<VDial *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ PROC ; std::vector<VDial *,std::allocator<VDial *> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1088 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ENDP ; std::vector<VDial *,std::allocator<VDial *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ PROC ; std::vector<VDial *,std::allocator<VDial *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 973  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ENDP ; std::vector<VDial *,std::allocator<VDial *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ PROC ; std::vector<VDial *,std::allocator<VDial *> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 968  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ENDP ; std::vector<VDial *,std::allocator<VDial *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<VDial *> >::_Wrap_alloc<std::allocator<VDial *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVVDial@@V?$allocator@PAVVDial@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<VDial *,std::allocator<VDial *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<VDial *> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAIABV?$allocator@PAVVDial@@@2@@Z ; std::allocator_traits<std::allocator<VDial *> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<VDial *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@I@Z PROC ; std::_Wrap_alloc<std::allocator<VDial *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@I@Z ; std::allocator<VDial *>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEXPAPAVVDial@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<VDial *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEPAPAVVDial@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEPAPAVVDial@@I@Z PROC ; std::_Wrap_alloc<std::allocator<VDial *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVVDial@@@std@@QAEPAPAVVDial@@I@Z ; std::allocator<VDial *>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAEPAPAVVDial@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<VDial *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<VDial *> >::_Wrap_alloc<std::allocator<VDial *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVVDial@@@std@@QAE@XZ	; std::allocator<VDial *>::allocator<VDial *>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVVDial@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<VDial *> >::_Wrap_alloc<std::allocator<VDial *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAIABV?$allocator@PAVVDial@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAIABV?$allocator@PAVVDial@@@2@@Z PROC ; std::allocator_traits<std::allocator<VDial *> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAVVDial@@@std@@QBEIXZ ; std::allocator<VDial *>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVVDial@@@std@@@std@@SAIABV?$allocator@PAVVDial@@@2@@Z ENDP ; std::allocator_traits<std::allocator<VDial *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVVDial@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PAVVDial@@@std@@QBEIXZ PROC	; std::allocator<VDial *>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVVDial@@@std@@QBEIXZ ENDP	; std::allocator<VDial *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@ABQAV3@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv68 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@ABQAV3@@Z PROC ; std::allocator<VDial *>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@ABQAV3@@Z ENDP ; std::allocator<VDial *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVVDial@@@std@@QAEPAPAVVDial@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVVDial@@@std@@QAEPAPAVVDial@@I@Z PROC ; std::allocator<VDial *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVVDial@@@std@@YAPAPAVVDial@@IPAPAV1@@Z ; std::_Allocate<VDial *>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVVDial@@@std@@QAEPAPAVVDial@@I@Z ENDP ; std::allocator<VDial *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@I@Z PROC ; std::allocator<VDial *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVVDial@@@std@@QAEXPAPAVVDial@@I@Z ENDP ; std::allocator<VDial *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVVDial@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVVDial@@@std@@QAE@XZ PROC		; std::allocator<VDial *>::allocator<VDial *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVVDial@@@std@@QAE@XZ ENDP		; std::allocator<VDial *>::allocator<VDial *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ PROC ; VuBin<SimBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ENDP ; VuBin<SimBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ PROC	; VuBin<SimBaseClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ENDP	; VuBin<SimBaseClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?InExitMenu@OTWDriverClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InExitMenu@OTWDriverClass@@QAEHXZ PROC			; OTWDriverClass::InExitMenu, COMDAT
; _this$ = ecx

; 448  :       int InExitMenu (void) {return exitMenuOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32208]
	mov	esp, ebp
	pop	ebp
	ret	0
?InExitMenu@OTWDriverClass@@QAEHXZ ENDP			; OTWDriverClass::InExitMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?AVTROn@SimulationDriver@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AVTROn@SimulationDriver@@QAEHXZ PROC			; SimulationDriver::AVTROn, COMDAT
; _this$ = ecx

; 100  : 	int AVTROn (void) {return avtrOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]
	mov	esp, ebp
	pop	ebp
	ret	0
?AVTROn@SimulationDriver@@QAEHXZ ENDP			; SimulationDriver::AVTROn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ PROC ; SimulationDriver::GetPlayerEntity, COMDAT
; _this$ = ecx

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ENDP ; SimulationDriver::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ PROC	; AircraftClass::EWSPGM, COMDAT
; _this$ = ecx

; 543  : 	EWSPGMSwitch EWSPGM() { return EWSPgm; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1496]
	mov	esp, ebp
	pop	ebp
	ret	0
?EWSPGM@AircraftClass@@QAE?AW4EWSPGMSwitch@1@XZ ENDP	; AircraftClass::EWSPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_flag$ = 8						; size = 4
?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z PROC		; AircraftClass::IsOn, COMDAT
; _this$ = ecx

; 438  : 	int IsOn (APFlags flag) {return APFlag & flag ? 1 : 0;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1048]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsOn
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsOn
$LN3@IsOn:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsOn:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsOn@AircraftClass@@QAEHW4APFlags@1@@Z ENDP		; AircraftClass::IsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsComplex@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsComplex@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsComplex, COMDAT
; _this$ = ecx

; 336  : 	int            IsComplex (void) {return ((acFlags & isComplex) ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 4
	je	SHORT $LN3@IsComplex
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsComplex
$LN3@IsComplex:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsComplex:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsComplex@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsComplex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z PROC ; AircraftClass::AVTRState, COMDAT
; _this$ = ecx

; 251  : 	int AVTRState(AVTRStateFlags fl) { return (AVTRFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@AVTRState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@AVTRState
$LN3@AVTRState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@AVTRState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?AVTRState@AircraftClass@@QAEHW4AVTRStateFlags@1@@Z ENDP ; AircraftClass::AVTRState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z PROC ; AircraftClass::ExtlState, COMDAT
; _this$ = ecx

; 188  : 	int ExtlState(ExtlLightFlags fl) const { return (IsAcStatusBitsSet(fl) ? 1 : 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExtlState
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@ExtlState
$LN3@ExtlState:
	mov	DWORD PTR tv69[ebp], 0
$LN4@ExtlState:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ENDP ; AircraftClass::ExtlState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_bits$ = 8						; size = 4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z PROC		; AircraftClass::IsAcStatusBitsSet, COMDAT
; _this$ = ecx

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN3@IsAcStatus
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAcStatus
$LN3@IsAcStatus:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAcStatus:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ENDP		; AircraftClass::IsAcStatusBitsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetSpotLight, COMDAT
; _this$ = ecx

; 113  : 	LightSwitch GetSpotLight() const { return spotLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+752]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpotLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetSpotLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetInstrumentLight, COMDAT
; _this$ = ecx

; 112  : 	LightSwitch GetInstrumentLight() const { return instrumentLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+748]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstrumentLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetInstrumentLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ PROC ; AircraftClass::GetInteriorLight, COMDAT
; _this$ = ecx

; 111  : 	LightSwitch GetInteriorLight() const { return interiorLight; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+744]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInteriorLight@AircraftClass@@QBE?AW4LightSwitch@1@XZ ENDP ; AircraftClass::GetInteriorLight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumHardpoints@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumHardpoints@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumHardpoints, COMDAT
; _this$ = ecx

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumHardpoints@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumHardpoints
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?SetSwitch@SimMoverClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_val$ = 12						; size = 4
?SetSwitch@SimMoverClass@@QAEXHH@Z PROC			; SimMoverClass::SetSwitch, COMDAT
; _this$ = ecx

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN2@SetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR [ecx+edx*4], 1
$LN2@SetSwitch:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSwitch@SimMoverClass@@QAEXHH@Z ENDP			; SimMoverClass::SetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?GetDOFValue@SimMoverClass@@QAEMH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_dof$ = 8						; size = 4
?GetDOFValue@SimMoverClass@@QAEMH@Z PROC		; SimMoverClass::GetDOFValue, COMDAT
; _this$ = ecx

; 132  : 	float GetDOFValue (int dof) { ShiAssert(dof < numDofs); return dof < numDofs ? DOFData[dof] : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dof$[ebp]
	cmp	ecx, DWORD PTR [eax+600]
	jge	SHORT $LN3@GetDOFValu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+612]
	mov	ecx, DWORD PTR _dof$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN4@GetDOFValu
$LN3@GetDOFValu:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv69[ebp], xmm0
$LN4@GetDOFValu:
	fld	DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetDOFValue@SimMoverClass@@QAEMH@Z ENDP		; SimMoverClass::GetDOFValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ PROC		; PlayerRwrClass::ShowLowAltPriority, COMDAT
; _this$ = ecx

; 44   : 	int ShowLowAltPriority (void)		{return lowAltPriority;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+592]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowLowAltPriority@PlayerRwrClass@@QAEHXZ ENDP		; PlayerRwrClass::ShowLowAltPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowSearch@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowSearch@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::ShowSearch, COMDAT
; _this$ = ecx

; 43   : 	int ShowSearch (void)		{return showSearch;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+636]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowSearch@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::ShowSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowNaval@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowNaval@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::ShowNaval, COMDAT
; _this$ = ecx

; 42   : 	int ShowNaval (void)		{return showNaval;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+632]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowNaval@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::ShowNaval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?ShowUnknowns@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowUnknowns@PlayerRwrClass@@QAEHXZ PROC		; PlayerRwrClass::ShowUnknowns, COMDAT
; _this$ = ecx

; 41   : 	int ShowUnknowns (void)		{return showUnknowns;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+628]
	mov	esp, ebp
	pop	ebp
	ret	0
?ShowUnknowns@PlayerRwrClass@@QAEHXZ ENDP		; PlayerRwrClass::ShowUnknowns
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?TargetSep@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TargetSep@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::TargetSep, COMDAT
; _this$ = ecx

; 40   : 	int TargetSep (void)		{return targetSep;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+624]
	mov	esp, ebp
	pop	ebp
	ret	0
?TargetSep@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::TargetSep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?IsPriority@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPriority@PlayerRwrClass@@QAEHXZ PROC			; PlayerRwrClass::IsPriority, COMDAT
; _this$ = ecx

; 39   : 	int IsPriority (void)		{return priorityMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+620]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPriority@PlayerRwrClass@@QAEHXZ ENDP			; PlayerRwrClass::IsPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?LaunchIndication@PlayerRwrClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LaunchIndication@PlayerRwrClass@@QAEHXZ PROC		; PlayerRwrClass::LaunchIndication, COMDAT
; _this$ = ecx

; 28   : 	int LaunchIndication (void) {return missileActivity;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+640]
	mov	esp, ebp
	pop	ebp
	ret	0
?LaunchIndication@PlayerRwrClass@@QAEHXZ ENDP		; PlayerRwrClass::LaunchIndication
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\playerrwr.h
;	COMDAT ?SetGridVisible@PlayerRwrClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetGridVisible@PlayerRwrClass@@QAEXH@Z PROC		; PlayerRwrClass::SetGridVisible, COMDAT
; _this$ = ecx

; 24   : 	void SetGridVisible(BOOL flag)				{mGridVisible = flag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flag$[ebp]
	mov	DWORD PTR [eax+616], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetGridVisible@PlayerRwrClass@@QAEXH@Z ENDP		; PlayerRwrClass::SetGridVisible
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ PROC	; MFDClass::GetDrawable, COMDAT
; _this$ = ecx

; 90   : 	DrawableClass *GetDrawable() const { return const_cast<DrawableClass*>(drawable); } 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDrawable@MFDClass@@QBEPAVDrawableClass@@XZ ENDP	; MFDClass::GetDrawable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\renderow.h
;	COMDAT ?GetGreenMode@RenderOTW@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreenMode@RenderOTW@@QAE_NXZ PROC			; RenderOTW::GetGreenMode, COMDAT
; _this$ = ecx

; 167  : 	inline bool GetGreenMode() { return GreenMode; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+263368]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreenMode@RenderOTW@@QAE_NXZ ENDP			; RenderOTW::GetGreenMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetTextureSet@DrawableBSP@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTextureSet@DrawableBSP@@QAEKXZ PROC			; DrawableBSP::GetTextureSet, COMDAT
; _this$ = ecx

; 60   : 	UInt32	GetTextureSet( void)	{ return instance.TextureSet; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTextureSet@DrawableBSP@@QAEKXZ ENDP			; DrawableBSP::GetTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetNTextureSet@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNTextureSet@DrawableBSP@@QAEHXZ PROC		; DrawableBSP::GetNTextureSet, COMDAT
; _this$ = ecx

; 50   : 	int GetNTextureSet() { return instance.GetNTextureSet(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?GetNTextureSet@ObjectInstance@@QAEHXZ	; ObjectInstance::GetNTextureSet
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNTextureSet@DrawableBSP@@QAEHXZ ENDP		; DrawableBSP::GetNTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?SetTextureSet@DrawableBSP@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_set$ = 8						; size = 4
?SetTextureSet@DrawableBSP@@QAEXK@Z PROC		; DrawableBSP::SetTextureSet, COMDAT
; _this$ = ecx

; 49   : 	void SetTextureSet( UInt32 set )	{ instance.SetTextureSet( set ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?SetTextureSet@ObjectInstance@@QAEXH@Z	; ObjectInstance::SetTextureSet
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTextureSet@DrawableBSP@@QAEXK@Z ENDP		; DrawableBSP::SetTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\objectinstance.h
;	COMDAT ?GetNTextureSet@ObjectInstance@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNTextureSet@ObjectInstance@@QAEHXZ PROC		; ObjectInstance::GetNTextureSet, COMDAT
; _this$ = ecx

; 39   : 	int	GetNTextureSet() { return ParentObject->nTextureSets; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movsx	eax, WORD PTR [ecx+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNTextureSet@ObjectInstance@@QAEHXZ ENDP		; ObjectInstance::GetNTextureSet
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCanvas3D@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCanvas3D@@UAEPAXI@Z PROC				; Canvas3D::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Canvas3D@@UAE@XZ			; Canvas3D::~Canvas3D
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCanvas3D@@UAEPAXI@Z ENDP				; Canvas3D::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?ScreenText@Canvas3D@@UAEXMMPBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_xLeft$ = 8						; size = 4
_yTop$ = 12						; size = 4
_string$ = 16						; size = 4
_boxed$ = 20						; size = 4
?ScreenText@Canvas3D@@UAEXMMPBDH@Z PROC			; Canvas3D::ScreenText, COMDAT
; _this$ = ecx

; 79   : 	virtual void ScreenText( float xLeft, float yTop, const char *string, int boxed ){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ScreenText@Canvas3D@@UAEXMMPBDH@Z ENDP			; Canvas3D::ScreenText
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?SetBackground@Canvas3D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetBackground@Canvas3D@@UAEXK@Z PROC			; Canvas3D::SetBackground, COMDAT
; _this$ = ecx

; 59   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		r3d->SetBackground( packedRGBA );

	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262912]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+262912]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 61   : 	};	

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBackground@Canvas3D@@UAEXK@Z ENDP			; Canvas3D::SetBackground
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?SetColor@Canvas3D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetColor@Canvas3D@@UAEXK@Z PROC			; Canvas3D::SetColor, COMDAT
; _this$ = ecx

; 55   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		r3d->SetColor( packedRGBA );

	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262912]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+262912]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 57   : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetColor@Canvas3D@@UAEXK@Z ENDP			; Canvas3D::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?Color@Canvas3D@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@Canvas3D@@UAEKXZ PROC				; Canvas3D::Color, COMDAT
; _this$ = ecx

; 52   : 	virtual DWORD Color( void )	{return r3d->context.CurrentForegroundColor(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+262912]
	add	ecx, 100				; 00000064H
	call	?CurrentForegroundColor@ContextMPR@@QAEHXZ ; ContextMPR::CurrentForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@Canvas3D@@UAEKXZ ENDP				; Canvas3D::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?SetLineStyle@Canvas3D@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_style$ = 8						; size = 4
?SetLineStyle@Canvas3D@@UAEXH@Z PROC			; Canvas3D::SetLineStyle, COMDAT
; _this$ = ecx

; 47   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 		r3d->SetLineStyle( style );

	mov	eax, DWORD PTR _style$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+262912]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+262912]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 49   : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@Canvas3D@@UAEXH@Z ENDP			; Canvas3D::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?Render2DTri@Canvas3D@@UAEXMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Render2DTri@Canvas3D@@UAEXMMMMMM@Z PROC		; Canvas3D::Render2DTri, COMDAT
; _this$ = ecx

; 43   :     virtual void Render2DTri( float, float, float, float, float, float) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Render2DTri@Canvas3D@@UAEXMMMMMM@Z ENDP		; Canvas3D::Render2DTri
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?EndDraw@Canvas3D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EndDraw@Canvas3D@@UAEXXZ PROC				; Canvas3D::EndDraw, COMDAT
; _this$ = ecx

; 40   :     virtual void EndDraw( void )	{} ;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?EndDraw@Canvas3D@@UAEXXZ ENDP				; Canvas3D::EndDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?ClearDraw@Canvas3D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDraw@Canvas3D@@UAEXXZ PROC			; Canvas3D::ClearDraw, COMDAT
; _this$ = ecx

; 39   :     virtual void ClearDraw( void ) 	{} ;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDraw@Canvas3D@@UAEXXZ ENDP			; Canvas3D::ClearDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ?StartDraw@Canvas3D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartDraw@Canvas3D@@UAEXXZ PROC			; Canvas3D::StartDraw, COMDAT
; _this$ = ecx

; 38   :     virtual void StartDraw ( void ) 	{} ;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartDraw@Canvas3D@@UAEXXZ ENDP			; Canvas3D::StartDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ??1Canvas3D@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Canvas3D@@UAE@XZ PROC				; Canvas3D::~Canvas3D, COMDAT
; _this$ = ecx

; 28   : 	virtual ~Canvas3D()	{ ready = FALSE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Canvas3D@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	esp, ebp
	pop	ebp
	ret	0
??1Canvas3D@@UAE@XZ ENDP				; Canvas3D::~Canvas3D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\canvas3d.h
;	COMDAT ??0Canvas3D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Canvas3D@@QAE@XZ PROC				; Canvas3D::Canvas3D, COMDAT
; _this$ = ecx

; 27   : 	Canvas3D()	{ r3d = NULL; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VirtualDisplay@@QAE@XZ		; VirtualDisplay::VirtualDisplay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Canvas3D@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262912], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Canvas3D@@QAE@XZ ENDP				; Canvas3D::Canvas3D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render3d.h
;	COMDAT ?GetObjectTextureState@Render3D@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectTextureState@Render3D@@QAEHXZ PROC		; Render3D::GetObjectTextureState, COMDAT
; _this$ = ecx

; 75   : 	BOOL GetObjectTextureState( void )			{ return objTextureState; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+262888]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectTextureState@Render3D@@QAEHXZ ENDP		; Render3D::GetObjectTextureState
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRender2D@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRender2D@@UAEPAXI@Z PROC				; Render2D::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Render2D@@UAE@XZ			; Render2D::~Render2D
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRender2D@@UAEPAXI@Z ENDP				; Render2D::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetLineStyle@Render2D@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@Render2D@@UAEXH@Z PROC			; Render2D::SetLineStyle, COMDAT
; _this$ = ecx

; 60   : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@Render2D@@UAEXH@Z ENDP			; Render2D::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetBackground@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetBackground@Render2D@@UAEXK@Z PROC			; Render2D::SetBackground, COMDAT
; _this$ = ecx

; 50   : 	virtual void SetBackground(DWORD packedRGBA){ context.SetState(MPR_STA_BG_COLOR,packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBackground@Render2D@@UAEXK@Z ENDP			; Render2D::SetBackground
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetColor@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetColor@Render2D@@UAEXK@Z PROC			; Render2D::SetColor, COMDAT
; _this$ = ecx

; 49   : 	virtual void SetColor(DWORD packedRGBA)	{ context.RestoreState(STATE_SOLID); context.SelectForegroundColor(packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SelectForegroundColor@ContextMPR@@QAEXH@Z ; ContextMPR::SelectForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	4
?SetColor@Render2D@@UAEXK@Z ENDP			; Render2D::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?Color@Render2D@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@Render2D@@UAEKXZ PROC				; Render2D::Color, COMDAT
; _this$ = ecx

; 48   : 	virtual DWORD Color(void) { return context.CurrentForegroundColor(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?CurrentForegroundColor@ContextMPR@@QAEHXZ ; ContextMPR::CurrentForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@Render2D@@UAEKXZ ENDP				; Render2D::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearZBuffer@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearZBuffer@Render2D@@UAEXXZ PROC			; Render2D::ClearZBuffer, COMDAT
; _this$ = ecx

; 42   : 	virtual void ClearZBuffer( void )	{ context.ClearBuffers( MPR_CI_ZBUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearZBuffer@Render2D@@UAEXXZ ENDP			; Render2D::ClearZBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearDraw@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDraw@Render2D@@UAEXXZ PROC			; Render2D::ClearDraw, COMDAT
; _this$ = ecx

; 41   : 	virtual void ClearDraw( void )		{ context.ClearBuffers( MPR_CI_DRAW_BUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDraw@Render2D@@UAEXXZ ENDP			; Render2D::ClearDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ PROC	; Render2D::GetImageBuffer, COMDAT
; _this$ = ecx

; 38   : 	ImageBuffer* GetImageBuffer(void) {return image;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetImageBuffer@Render2D@@QAEPAVImageBuffer@@XZ ENDP	; Render2D::GetImageBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??1Render2D@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Render2D@@UAE@XZ PROC				; Render2D::~Render2D, COMDAT
; _this$ = ecx

; 32   : 	virtual ~Render2D()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	esp, ebp
	pop	ebp
	ret	0
??1Render2D@@UAE@XZ ENDP				; Render2D::~Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??0Render2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Render2D@@QAE@XZ PROC				; Render2D::Render2D, COMDAT
; _this$ = ecx

; 31   : 	Render2D()			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VirtualDisplay@@QAE@XZ		; VirtualDisplay::VirtualDisplay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Render2D@@QAE@XZ ENDP				; Render2D::Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVirtualDisplay@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVirtualDisplay@@UAEPAXI@Z PROC			; VirtualDisplay::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVirtualDisplay@@UAEPAXI@Z ENDP			; VirtualDisplay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?GetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Canvas$ = 8						; size = 4
?GetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@@Z PROC	; VirtualDisplay::GetRttCanvas, COMDAT
; _this$ = ecx

; 240  : 	void GetRttCanvas( Tpoint* Canvas ) { Canvas[0]=canUL; Canvas[1]=canUR; Canvas[2]=canLL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 262780				; 0004027cH
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _Canvas$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 262792				; 00040288H
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _Canvas$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 262804				; 00040294H
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _Canvas$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRttCanvas@VirtualDisplay@@QAEXPAUTpoint@@@Z ENDP	; VirtualDisplay::GetRttCanvas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?HasRttTarget@VirtualDisplay@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasRttTarget@VirtualDisplay@@QAEHXZ PROC		; VirtualDisplay::HasRttTarget, COMDAT
; _this$ = ecx

; 239  : 	int HasRttTarget() { return (int)renderTexture; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?renderTexture@VirtualDisplay@@1PAVTextureHandle@@A ; VirtualDisplay::renderTexture
	mov	esp, ebp
	pop	ebp
	ret	0
?HasRttTarget@VirtualDisplay@@QAEHXZ ENDP		; VirtualDisplay::HasRttTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CenterOriginInViewport@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::CenterOriginInViewport, COMDAT
; _this$ = ecx

; 143  : 	void CenterOriginInViewport( void )  { dmatrix.translationX = 0.0f; dmatrix.translationY = 0.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+68], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+72], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::CenterOriginInViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Color@VirtualDisplay@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@VirtualDisplay@@UAEKXZ PROC			; VirtualDisplay::Color, COMDAT
; _this$ = ecx

; 136  : 	virtual DWORD Color( void )	{return 0x0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@VirtualDisplay@@UAEKXZ ENDP			; VirtualDisplay::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?SetLineStyle@VirtualDisplay@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@VirtualDisplay@@UAEXH@Z PROC		; VirtualDisplay::SetLineStyle, COMDAT
; _this$ = ecx

; 135  : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@VirtualDisplay@@UAEXH@Z ENDP		; VirtualDisplay::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CurFont@VirtualDisplay@@SAHXZ
_TEXT	SEGMENT
?CurFont@VirtualDisplay@@SAHXZ PROC			; VirtualDisplay::CurFont, COMDAT

; 132  : 	static int CurFont(void) { return pFontSet->fontNum; };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	eax, DWORD PTR [eax+24672]
	pop	ebp
	ret	0
?CurFont@VirtualDisplay@@SAHXZ ENDP			; VirtualDisplay::CurFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextHeight@VirtualDisplay@@UAEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?TextHeight@VirtualDisplay@@UAEMXZ PROC			; VirtualDisplay::TextHeight, COMDAT
; _this$ = ecx

; 121  : 	virtual float TextHeight(void)			{ return ScreenTextHeight()/scaleY; };		// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR tv71[ebp], xmm0
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TextHeight@VirtualDisplay@@UAEMXZ ENDP			; VirtualDisplay::TextHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextWidth@VirtualDisplay@@UAEMPAD@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_string$ = 8						; size = 4
?TextWidth@VirtualDisplay@@UAEMPAD@Z PROC		; VirtualDisplay::TextWidth, COMDAT
; _this$ = ecx

; 120  : 	virtual float TextWidth(char *string)	{ return ScreenTextWidth(string)/scaleX; };	// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?TextWidth@VirtualDisplay@@UAEMPAD@Z ENDP		; VirtualDisplay::TextWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Arc@VirtualDisplay@@UAEXMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
_start$ = 20						; size = 4
_stop$ = 24						; size = 4
?Arc@VirtualDisplay@@UAEXMMMMM@Z PROC			; VirtualDisplay::Arc, COMDAT
; _this$ = ecx

; 109  : 		{ OvalArc(x, y, xRadius, xRadius*scaleX/scaleY, start, stop); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _stop$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Arc@VirtualDisplay@@UAEXMMMMM@Z ENDP			; VirtualDisplay::Arc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Circle@VirtualDisplay@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
?Circle@VirtualDisplay@@UAEXMMM@Z PROC			; VirtualDisplay::Circle, COMDAT
; _this$ = ecx

; 107  : 		{ Oval(x, y, xRadius, xRadius*scaleX/scaleY); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Circle@VirtualDisplay@@UAEXMMM@Z ENDP			; VirtualDisplay::Circle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??1VirtualDisplay@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VirtualDisplay@@UAE@XZ PROC				; VirtualDisplay::~VirtualDisplay, COMDAT
; _this$ = ecx

; 86   :     virtual ~VirtualDisplay()	{ ShiAssert( ready == FALSE ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??1ContextMPR@@UAE@XZ			; ContextMPR::~ContextMPR
	mov	esp, ebp
	pop	ebp
	ret	0
??1VirtualDisplay@@UAE@XZ ENDP				; VirtualDisplay::~VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??0VirtualDisplay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VirtualDisplay@@QAE@XZ PROC				; VirtualDisplay::VirtualDisplay, COMDAT
; _this$ = ecx

; 85   :     VirtualDisplay()			{ ready = FALSE; tLeft = tTop = tRight = tBottom = txRes = tyRes = 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0ContextMPR@@QAE@XZ			; ContextMPR::ContextMPR
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262776], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262772], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262768], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262764], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262760], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262756], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VirtualDisplay@@QAE@XZ ENDP				; VirtualDisplay::VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\context.h
;	COMDAT ?CurrentForegroundColor@ContextMPR@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentForegroundColor@ContextMPR@@QAEHXZ PROC		; ContextMPR::CurrentForegroundColor, COMDAT
; _this$ = ecx

; 708  : 	int CurrentForegroundColor(void) {return m_colFG_Raw;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentForegroundColor@ContextMPR@@QAEHXZ ENDP		; ContextMPR::CurrentForegroundColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1717 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1718 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1719 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 778  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 779  : 		assign(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 780  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 39   : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?tan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?tan@@YAMM@Z PROC					; tan, COMDAT

; 543  :         {return (tanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_tanf
	add	esp, 4
	pop	ebp
	ret	0
?tan@@YAMM@Z ENDP					; tan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?log10@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?log10@@YAMM@Z PROC					; log10, COMDAT

; 529  :         {return (log10f(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_log10f
	add	esp, 4
	pop	ebp
	ret	0
?log10@@YAMM@Z ENDP					; log10
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 521  :         {return (fmodf(_X, _Y)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __Y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fmodf
	add	esp, 8
	pop	ebp
	ret	0
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?abs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?abs@@YAMM@Z PROC					; abs, COMDAT

; 499  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?abs@@YAMM@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _log10f
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_log10f	PROC						; COMDAT

; 422  :         {return ((float)log10((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log10
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_log10f	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv77 = -12						; size = 8
tv79 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 418  :         {return ((float)fmod((double)_X, (double)_Y)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv77[ebp]
	movsd	xmm0, QWORD PTR tv77[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
