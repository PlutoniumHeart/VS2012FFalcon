; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\OTWDRIVE\Sfx.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?acmiStatSfx@@3UACMIStationarySfxRecord@@A	; acmiStatSfx
PUBLIC	?acmiMoveSfx@@3UACMIMovingSfxRecord@@A		; acmiMoveSfx
PUBLIC	?gWindVect@@3UTpoint@@A				; gWindVect
PUBLIC	?gWindTimer@@3KA				; gWindTimer
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?gFireVerts@@3PAUTpoint@@A			; gFireVerts
PUBLIC	?gGroundVerts@@3PAUTpoint@@A			; gGroundVerts
PUBLIC	?gWaterVerts@@3PAUTpoint@@A			; gWaterVerts
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?gFireUvs@@3PAUTpoint@@A			; gFireUvs
PUBLIC	?gShockVerts@@3PAUTpoint@@A			; gShockVerts
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?lastViewTime@@3KA				; lastViewTime
PUBLIC	?sfxFrameTime@@3MA				; sfxFrameTime
PUBLIC	?gSfxLOD@@3MA					; gSfxLOD
PUBLIC	?gTotSfx@@3HA					; gTotSfx
PUBLIC	?gTotHighWaterSfx@@3HA				; gTotHighWaterSfx
PUBLIC	?gSfxCount@@3PAHA				; gSfxCount
PUBLIC	?gSfxHighWater@@3PAHA				; gSfxHighWater
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
_BSS	SEGMENT
?acmiStatSfx@@3UACMIStationarySfxRecord@@A DB 01dH DUP (?) ; acmiStatSfx
	ALIGN	4

?acmiMoveSfx@@3UACMIMovingSfxRecord@@A DB 031H DUP (?)	; acmiMoveSfx
	ALIGN	4

?gWindVect@@3UTpoint@@A DB 0cH DUP (?)			; gWindVect
?gWindTimer@@3KA DD 01H DUP (?)				; gWindTimer
?lastViewTime@@3KA DD 01H DUP (?)			; lastViewTime
?sfxFrameTime@@3MA DD 01H DUP (?)			; sfxFrameTime
?gTotSfx@@3HA DD 01H DUP (?)				; gTotSfx
?gTotHighWaterSfx@@3HA DD 01H DUP (?)			; gTotHighWaterSfx
?gSfxCount@@3PAHA DD 08bH DUP (?)			; gSfxCount
?gSfxHighWater@@3PAHA DD 08bH DUP (?)			; gSfxHighWater
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
_DATA	SEGMENT
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
?gFireVerts@@3PAUTpoint@@A DD 0bf000000r	; -0.5	; gFireVerts
	DD	0bf000000r			; -0.5
	DD	0bf400000r			; -0.75
	DD	0bf000000r			; -0.5
	DD	03f000000r			; 0.5
	DD	0bf400000r			; -0.75
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f400000r			; 0.75
	DD	03f000000r			; 0.5
	DD	0bf000000r			; -0.5
	DD	03f400000r			; 0.75
?gGroundVerts@@3PAUTpoint@@A DD 0bf000000r	; -0.5	; gGroundVerts
	DD	0bf000000r			; -0.5
	DD	0bf800000r			; -1
	DD	0bf000000r			; -0.5
	DD	03f000000r			; 0.5
	DD	0bf800000r			; -1
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	0bf000000r			; -0.5
	DD	03f800000r			; 1
?gWaterVerts@@3PAUTpoint@@A DD 0be99999ar	; -0.3	; gWaterVerts
	DD	0be99999ar			; -0.3
	DD	0bfc00000r			; -1.5
	DD	0be99999ar			; -0.3
	DD	03e99999ar			; 0.3
	DD	0bfc00000r			; -1.5
	DD	03e99999ar			; 0.3
	DD	03e99999ar			; 0.3
	DD	03fc00000r			; 1.5
	DD	03e99999ar			; 0.3
	DD	0be99999ar			; -0.3
	DD	03fc00000r			; 1.5
?gFireUvs@@3PAUTpoint@@A DD 000000000r		; 0	; gFireUvs
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
?gShockVerts@@3PAUTpoint@@A DD 03f800000r	; 1	; gShockVerts
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	0bf800000r			; -1
	DD	000000000r			; 0
?gSfxLOD@@3MA DD 03f800000r			; 1	; gSfxLOD
_DATA	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_asinf
PUBLIC	?asin@@YAMM@Z					; asin
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z		; TViewPoint::GetPos
PUBLIC	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z	; DrawableObject::GetPosition
PUBLIC	?SetScale@DrawableObject@@QAEXM@Z		; DrawableObject::SetScale
PUBLIC	?InDisplayList@DrawableObject@@QAEHXZ		; DrawableObject::InDisplayList
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?KeepStaleSegs@DrawableTrail@@QAEXH@Z		; DrawableTrail::KeepStaleSegs
PUBLIC	?GetID@DrawableBSP@@QAEHXZ			; DrawableBSP::GetID
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDInt5@@YAHXZ				; PRANDInt5
PUBLIC	?PRANDInt3@@YAHXZ				; PRANDInt3
PUBLIC	?PRANDFloat@@YAMXZ				; PRANDFloat
PUBLIC	?PRANDFloatPos@@YAMXZ				; PRANDFloatPos
PUBLIC	?PRANDInt6@@YAHXZ				; PRANDInt6
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?SetScale2D@Drawable2D@@QAEXM@Z			; Drawable2D::SetScale2D
PUBLIC	?SetYPR@VuEntity@@QAEXMMM@Z			; VuEntity::SetYPR
PUBLIC	?SetYPRDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPRDelta
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	?YawDelta@VuEntity@@QBEMXZ			; VuEntity::YawDelta
PUBLIC	?PitchDelta@VuEntity@@QBEMXZ			; VuEntity::PitchDelta
PUBLIC	?RollDelta@VuEntity@@QBEMXZ			; VuEntity::RollDelta
PUBLIC	?IsAwake@SimBaseClass@@QBEHXZ			; SimBaseClass::IsAwake
PUBLIC	?Status@SimBaseClass@@QBEHXZ			; SimBaseClass::Status
PUBLIC	?GraphicsOwnship@OTWDriverClass@@QBEPAVSimBaseClass@@XZ ; OTWDriverClass::GraphicsOwnship
PUBLIC	?Scale@OTWDriverClass@@QAEMXZ			; OTWDriverClass::Scale
PUBLIC	?SetOwnshipPosition@OTWDriverClass@@QAEXMMM@Z	; OTWDriverClass::SetOwnshipPosition
PUBLIC	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z	; OTWDriverClass::SetEndFlightPoint
PUBLIC	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z	; OTWDriverClass::SetEndFlightVec
PUBLIC	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
PUBLIC	??1?$VuBin@VSimBaseClass@@@@QAE@XZ		; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
PUBLIC	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ		; VuBin<SimBaseClass>::operator bool
PUBLIC	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
PUBLIC	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
PUBLIC	?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::reset
PUBLIC	?CalculateRestingObjectMatrix@SfxClass@@KAXMMQAY02M@Z ; SfxClass::CalculateRestingObjectMatrix
PUBLIC	?CalculateGroundMatrix@SfxClass@@KAXPAUTpoint@@MQAY02M@Z ; SfxClass::CalculateGroundMatrix
PUBLIC	?MultiplyMatrix@SfxClass@@KAXQAY02M00@Z		; SfxClass::MultiplyMatrix
PUBLIC	?TransformPoint@SfxClass@@KAXPAUTpoint@@0QAY02M@Z ; SfxClass::TransformPoint
PUBLIC	?CopyMatrix@SfxClass@@KAXQAY02M0@Z		; SfxClass::CopyMatrix
PUBLIC	?GetOrientation@SfxClass@@KAXQAY02MPAM11@Z	; SfxClass::GetOrientation
PUBLIC	?AdjustAngle180@SfxClass@@KAMM@Z		; SfxClass::AdjustAngle180
PUBLIC	?RestPiece@SfxClass@@KAHPAMMMM@Z		; SfxClass::RestPiece
PUBLIC	?TryParticleEffect@SfxClass@@QAEHXZ		; SfxClass::TryParticleEffect
PUBLIC	??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z ; SfxClass::SfxClass
PUBLIC	?GetApproxViewDist@SfxClass@@IAEXM@Z		; SfxClass::GetApproxViewDist
PUBLIC	?RunSecondarySfx@SfxClass@@IAEXXZ		; SfxClass::RunSecondarySfx
PUBLIC	?RunSfxCompletion@SfxClass@@IAEXHMH@Z		; SfxClass::RunSfxCompletion
PUBLIC	?GroundReflection@SfxClass@@IAEXXZ		; SfxClass::GroundReflection
PUBLIC	?StartRandomDebris@SfxClass@@IAEXXZ		; SfxClass::StartRandomDebris
PUBLIC	??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z ; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HPAUTpoint@@MM@Z		; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HPAUTpoint@@HM@Z		; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HPAUTpoint@@0HM@Z		; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z		; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z ; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z	; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@MPAVDrawableTrail@@@Z		; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z ; SfxClass::SfxClass
PUBLIC	??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z	; SfxClass::SfxClass
PUBLIC	??1SfxClass@@QAE@XZ				; SfxClass::~SfxClass
PUBLIC	?Start@SfxClass@@QAEXXZ				; SfxClass::Start
PUBLIC	?Exec@SfxClass@@QAEHXZ				; SfxClass::Exec
PUBLIC	?Draw@SfxClass@@QAEHXZ				; SfxClass::Draw
PUBLIC	?ACMIStart@SfxClass@@QAEXPAVRViewPoint@@MM@Z	; SfxClass::ACMIStart
PUBLIC	?ACMIExec@SfxClass@@QAEHM@Z			; SfxClass::ACMIExec
PUBLIC	?SetLOD@SfxClass@@SAXM@Z			; SfxClass::SetLOD
PUBLIC	?AddParticleEffect@@YAHHPAUTpoint@@0@Z		; AddParticleEffect
PUBLIC	?AddParticleEffect@@YAHPADPAUTpoint@@1@Z	; AddParticleEffect
PUBLIC	?GetLightLevel@CTimeOfDay@@QAEMXZ		; CTimeOfDay::GetLightLevel
PUBLIC	?IsRecording@ACMIRecorder@@QAEHXZ		; ACMIRecorder::IsRecording
PUBLIC	?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z		; PlayCrashSound
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	?gSfxLODCutoff@@3HA				; gSfxLODCutoff
PUBLIC	?gSfxLODDistCutoff@@3HA				; gSfxLODDistCutoff
PUBLIC	?gSfxLODTotCutoff@@3HA				; gSfxLODTotCutoff
PUBLIC	??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3d56774e
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3de147ae
PUBLIC	__real@3e000000
PUBLIC	__real@3e19999a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e570a3d
PUBLIC	__real@3e800000
PUBLIC	__real@3e860a91
PUBLIC	__real@3e99999a
PUBLIC	__real@3eb2b8c1
PUBLIC	__real@3ec00000
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f59999a
PUBLIC	__real@3f666666
PUBLIC	__real@3f733333
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f7fbe77
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40e00000
PUBLIC	__real@411fd70a
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41700000
PUBLIC	__real@41800000
PUBLIC	__real@4180b53f
PUBLIC	__real@41a00000
PUBLIC	__real@41ac0000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@4200b53f
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@425c0000
PUBLIC	__real@42700000
PUBLIC	__real@428c0000
PUBLIC	__real@42a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42fa0000
PUBLIC	__real@4346e65c
PUBLIC	__real@43480000
PUBLIC	__real@43c80000
PUBLIC	__real@43fa0000
PUBLIC	__real@44160000
PUBLIC	__real@44480000
PUBLIC	__real@447a0000
PUBLIC	__real@44bb8000
PUBLIC	__real@44fa0000
PUBLIC	__real@453b8000
PUBLIC	__real@457a0000
PUBLIC	__real@45bb8000
PUBLIC	__real@45fa0000
PUBLIC	__real@461c4000
PUBLIC	__real@463b8000
PUBLIC	__real@466a6000
PUBLIC	__real@46ea6000
PUBLIC	__real@477fff00
PUBLIC	__real@47c35000
PUBLIC	__real@48435000
PUBLIC	__real@4b189680
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@bfc90fdb
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0490fdb
PUBLIC	__real@c0a00000
PUBLIC	__real@c0c90fdb
PUBLIC	__real@c1000000
PUBLIC	__real@c1200000
PUBLIC	__real@c1900000
PUBLIC	__real@c1a00000
PUBLIC	__real@c1c80000
PUBLIC	__real@c1f00000
PUBLIC	__real@c2180000
PUBLIC	__real@c2200000
PUBLIC	__real@c2480000
PUBLIC	__real@c2a00000
PUBLIC	__real@c2c80000
PUBLIC	__real@c61c4000
PUBLIC	__real@c8127c00
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_asin:PROC
EXTRN	_atan:PROC
EXTRN	_fabs:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?MatrixTranspose@@YAXPBUTrotation@@PAU1@@Z:PROC	; MatrixTranspose
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?InsertObject@RViewPoint@@QAEXPAVDrawableObject@@@Z:PROC ; RViewPoint::InsertObject
EXTRN	?RemoveObject@RViewPoint@@QAEXPAVDrawableObject@@@Z:PROC ; RViewPoint::RemoveObject
EXTRN	?AddPointAtHead@DrawableTrail@@QAEXPAUTpoint@@K@Z:PROC ; DrawableTrail::AddPointAtHead
EXTRN	?RewindTrail@DrawableTrail@@QAEHK@Z:PROC	; DrawableTrail::RewindTrail
EXTRN	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z:PROC ; DrawableBSP::DrawableBSP
EXTRN	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z:PROC ; DrawableBSP::Update
EXTRN	?GetChildOffset@DrawableBSP@@QAEXHPAUTpoint@@@Z:PROC ; DrawableBSP::GetChildOffset
EXTRN	_F4SoundFXSetPos:PROC
EXTRN	??0DrawableParticleSys@@QAE@HM@Z:PROC		; DrawableParticleSys::DrawableParticleSys
EXTRN	?AddParticle@DrawableParticleSys@@QAEXHPAUTpoint@@0@Z:PROC ; DrawableParticleSys::AddParticle
EXTRN	?Exec@DrawableParticleSys@@QAEXXZ:PROC		; DrawableParticleSys::Exec
EXTRN	?HasParticles@DrawableParticleSys@@QAEHXZ:PROC	; DrawableParticleSys::HasParticles
EXTRN	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z:PROC ; DrawableParticleSys::PS_AddParticleEx
EXTRN	?IsValidPSId@DrawableParticleSys@@SAHH@Z:PROC	; DrawableParticleSys::IsValidPSId
EXTRN	?GetNameId@DrawableParticleSys@@SAHPAD@Z:PROC	; DrawableParticleSys::GetNameId
EXTRN	??0Drawable2D@@QAE@HMPAUTpoint@@@Z:PROC		; Drawable2D::Drawable2D
EXTRN	??0Drawable2D@@QAE@HMPAUTpoint@@PAUTrotation@@@Z:PROC ; Drawable2D::Drawable2D
EXTRN	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z:PROC	; Drawable2D::Drawable2D
EXTRN	?SetPosition@Drawable2D@@QAEXPAUTpoint@@@Z:PROC	; Drawable2D::SetPosition
EXTRN	?SetStartTime@Drawable2D@@QAEXKK@Z:PROC		; Drawable2D::SetStartTime
EXTRN	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ:PROC	; Drawable2D::GetAlphaTimeToLive
EXTRN	?SetLOD@Drawable2D@@SAXM@Z:PROC			; Drawable2D::SetLOD
EXTRN	??0DrawableTracer@@QAE@M@Z:PROC			; DrawableTracer::DrawableTracer
EXTRN	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z:PROC ; DrawableGroundVehicle::DrawableGroundVehicle
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetDelta@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetDelta
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	_MonoPrint:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?WindSpeedInFeetPerSecond@WeatherClass@@QAEMPBUTpoint@@@Z:PROC ; WeatherClass::WindSpeedInFeetPerSecond
EXTRN	?WindHeadingAt@WeatherClass@@QAEMPBUTpoint@@@Z:PROC ; WeatherClass::WindHeadingAt
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z:PROC ; OTWDriverClass::GetApproxGroundLevel
EXTRN	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z:PROC ; OTWDriverClass::InsertObject
EXTRN	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z:PROC ; OTWDriverClass::RemoveObject
EXTRN	?AddTrailHead@OTWDriverClass@@QAEXPAVDrawableTrail@@MMM@Z:PROC ; OTWDriverClass::AddTrailHead
EXTRN	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z:PROC ; OTWDriverClass::AddSfxRequest
EXTRN	?ObjectSetData@OTWDriverClass@@QAEXPAVSimBaseClass@@PAUTpoint@@PAUTrotation@@@Z:PROC ; OTWDriverClass::ObjectSetData
EXTRN	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ:PROC ; OTWDriverClass::GetViewpoint
EXTRN	?GetGroundType@OTWDriverClass@@QAEHMM@Z:PROC	; OTWDriverClass::GetGroundType
EXTRN	?ApplyChainReaction@SimFeatureClass@@SAHPAUTpoint@@M@Z:PROC ; SimFeatureClass::ApplyChainReaction
EXTRN	?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z:PROC ; ACMIRecorder::StationarySfxRecord
EXTRN	?MovingSfxRecord@ACMIRecorder@@QAEXPAUACMIMovingSfxRecord@@@Z:PROC ; ACMIRecorder::MovingSfxRecord
EXTRN	?MapVisId@@YAKK@Z:PROC				; MapVisId
EXTRN	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z:PROC ; CalcTransformMatrix
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?IMatrix@@3UTrotation@@B:BYTE			; IMatrix
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?SimLibElapsedSeconds@@3MA:DWORD		; SimLibElapsedSeconds
EXTRN	?realWeather@@3PAVRealWeather@@A:DWORD		; realWeather
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?TheTimeOfDay@@3VCTimeOfDay@@A:BYTE		; TheTimeOfDay
EXTRN	?gACMIRec@@3VACMIRecorder@@A:BYTE		; gACMIRec
EXTRN	?g_nSfxLODCutoff@@3HA:DWORD			; g_nSfxLODCutoff
EXTRN	?g_nSfxLODDistCutoff@@3HA:DWORD			; g_nSfxLODDistCutoff
EXTRN	?g_nSfxLODTotCutoff@@3HA:DWORD			; g_nSfxLODTotCutoff
EXTRN	?g_bOldDustTrail@@3_NA:BYTE			; g_bOldDustTrail
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?gSfxLODCutoff@@3HA DD 01H DUP (?)			; gSfxLODCutoff
?gSfxLODDistCutoff@@3HA DD 01H DUP (?)			; gSfxLODDistCutoff
?gSfxLODTotCutoff@@3HA DD 01H DUP (?)			; gSfxLODTotCutoff
_BSS	ENDS
;	COMDAT ?timePlaying@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA
_BSS	SEGMENT
?timePlaying@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA DD 05H DUP (?) ; `PlayCrashSound'::`2'::timePlaying
_BSS	ENDS
;	COMDAT ?SoundIndex@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA
_BSS	SEGMENT
?SoundIndex@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA DD 05H DUP (?) ; `PlayCrashSound'::`2'::SoundIndex
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c8127c00
CONST	SEGMENT
__real@c8127c00 DD 0c8127c00r			; -150000
CONST	ENDS
;	COMDAT __real@c61c4000
CONST	SEGMENT
__real@c61c4000 DD 0c61c4000r			; -10000
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2a00000
CONST	SEGMENT
__real@c2a00000 DD 0c2a00000r			; -80
CONST	ENDS
;	COMDAT __real@c2480000
CONST	SEGMENT
__real@c2480000 DD 0c2480000r			; -50
CONST	ENDS
;	COMDAT __real@c2200000
CONST	SEGMENT
__real@c2200000 DD 0c2200000r			; -40
CONST	ENDS
;	COMDAT __real@c2180000
CONST	SEGMENT
__real@c2180000 DD 0c2180000r			; -38
CONST	ENDS
;	COMDAT __real@c1f00000
CONST	SEGMENT
__real@c1f00000 DD 0c1f00000r			; -30
CONST	ENDS
;	COMDAT __real@c1c80000
CONST	SEGMENT
__real@c1c80000 DD 0c1c80000r			; -25
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c1900000
CONST	SEGMENT
__real@c1900000 DD 0c1900000r			; -18
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c1000000
CONST	SEGMENT
__real@c1000000 DD 0c1000000r			; -8
CONST	ENDS
;	COMDAT __real@c0c90fdb
CONST	SEGMENT
__real@c0c90fdb DD 0c0c90fdbr			; -6.28319
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bfc90fdb
CONST	SEGMENT
__real@bfc90fdb DD 0bfc90fdbr			; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@4b189680
CONST	SEGMENT
__real@4b189680 DD 04b189680r			; 1e+007
CONST	ENDS
;	COMDAT __real@48435000
CONST	SEGMENT
__real@48435000 DD 048435000r			; 200000
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@46ea6000
CONST	SEGMENT
__real@46ea6000 DD 046ea6000r			; 30000
CONST	ENDS
;	COMDAT __real@466a6000
CONST	SEGMENT
__real@466a6000 DD 0466a6000r			; 15000
CONST	ENDS
;	COMDAT __real@463b8000
CONST	SEGMENT
__real@463b8000 DD 0463b8000r			; 12000
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@45fa0000
CONST	SEGMENT
__real@45fa0000 DD 045fa0000r			; 8000
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@457a0000
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44bb8000
CONST	SEGMENT
__real@44bb8000 DD 044bb8000r			; 1500
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@4346e65c
CONST	SEGMENT
__real@4346e65c DD 04346e65cr			; 198.9
CONST	ENDS
;	COMDAT __real@42fa0000
CONST	SEGMENT
__real@42fa0000 DD 042fa0000r			; 125
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@428c0000
CONST	SEGMENT
__real@428c0000 DD 0428c0000r			; 70
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@4200b53f
CONST	SEGMENT
__real@4200b53f DD 04200b53fr			; 32.177
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41ac0000
CONST	SEGMENT
__real@41ac0000 DD 041ac0000r			; 21.5
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@4180b53f
CONST	SEGMENT
__real@4180b53f DD 04180b53fr			; 16.0885
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@411fd70a
CONST	SEGMENT
__real@411fd70a DD 0411fd70ar			; 9.99
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7fbe77
CONST	SEGMENT
__real@3f7fbe77 DD 03f7fbe77r			; 0.999
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ec00000
CONST	SEGMENT
__real@3ec00000 DD 03ec00000r			; 0.375
CONST	ENDS
;	COMDAT __real@3eb2b8c1
CONST	SEGMENT
__real@3eb2b8c1 DD 03eb2b8c1r			; 0.349066
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e860a91
CONST	SEGMENT
__real@3e860a91 DD 03e860a91r			; 0.261799
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e570a3d
CONST	SEGMENT
__real@3e570a3d DD 03e570a3dr			; 0.21
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3de147ae
CONST	SEGMENT
__real@3de147ae DD 03de147aer			; 0.11
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3d56774e
CONST	SEGMENT
__real@3d56774e DD 03d56774er			; 0.0523599
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ?DelayTime@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA
_DATA	SEGMENT
?DelayTime@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA DD 064H ; `PlayCrashSound'::`2'::DelayTime
	DD	03e8H
	DD	01f4H
	DD	032H
	DD	032H
_DATA	ENDS
;	COMDAT ??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@ DB 'Bad SFX Po'
	DB	'sition Passed in!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?AddParticleEffect@@YAHHPAUTpoint@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddParticleEffect@@YAHHPAUTpoint@@0@Z$0
__unwindtable$??1SfxClass@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SfxClass@@QAE@XZ$0
__unwindtable$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z$0
__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z$0
__unwindtable$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z$0
__unwindtable$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z$0
__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z$0
__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@HM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@HM@Z$0
__unwindtable$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z$0
__unwindtable$?RunSfxCompletion@SfxClass@@IAEXHMH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RunSfxCompletion@SfxClass@@IAEXHMH@Z$0
__unwindtable$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z$0
__unwindtable$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z$1
__unwindtable$?RunSecondarySfx@SfxClass@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RunSecondarySfx@SfxClass@@IAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunSecondarySfx@SfxClass@@IAEXXZ$1
__ehfuncinfo$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddParticleEffect@@YAHHPAUTpoint@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddParticleEffect@@YAHHPAUTpoint@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1SfxClass@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1SfxClass@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z DD 019930522H
	DD	034H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@HM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@HM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@MM@Z DD 019930522H
	DD	046H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RunSfxCompletion@SfxClass@@IAEXHMH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RunSfxCompletion@SfxClass@@IAEXHMH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RunSecondarySfx@SfxClass@@IAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RunSecondarySfx@SfxClass@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$20
__unwindtable$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$20
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$22
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$23
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$25
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$26
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$27
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$28
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$29
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$30
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$31
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$32
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$33
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$34
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$35
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$36
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$37
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$38
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$39
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$40
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$41
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$42
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$43
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$44
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$45
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$46
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$47
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$48
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$49
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$50
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$51
__unwindtable$??0SfxClass@@QAE@HPAUTpoint@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$20
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$22
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$23
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$25
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$26
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$27
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$28
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$29
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$30
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$31
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$32
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$33
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$34
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$35
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$36
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$37
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$38
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$39
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$40
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$41
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$42
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$43
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$44
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$45
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$46
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$47
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$48
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$49
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$50
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$51
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$52
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$53
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$54
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$55
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$56
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$57
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$58
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$59
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$60
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$61
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$62
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$63
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$64
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$65
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$66
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$67
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$68
	DD	00H
	DD	FLAT:__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$69
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gSfxLODCutoff$initializer$ DD FLAT:??__EgSfxLODCutoff@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gSfxLODDistCutoff$initializer$ DD FLAT:??__EgSfxLODDistCutoff@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_gSfxLODTotCutoff$initializer$ DD FLAT:??__EgSfxLODTotCutoff@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_index$ = -4						; size = 4
_mask$ = 8						; size = 4
_soundindex$ = 12					; size = 4
_flag$ = 16						; size = 4
_time$ = 20						; size = 4
_pos$ = 24						; size = 4
?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z PROC		; PlayCrashSound

; 2294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2295 : 	static int timePlaying[F16CRASH_MAXSOUND];
; 2296 : 	static int SoundIndex[F16CRASH_MAXSOUND];
; 2297 : 	static int DelayTime[F16CRASH_MAXSOUND] = { 100, 1000, 500, 50, 50 };
; 2298 : 	int	i, index;
; 2299 : 
; 2300 : 	if (flag) {	

	cmp	DWORD PTR _flag$[ebp], 0
	je	SHORT $LN12@PlayCrashS

; 2301 : 		index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 2302 : 		for (i=0; i < F16CRASH_MAXSOUND; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@PlayCrashS
$LN10@PlayCrashS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@PlayCrashS:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN9@PlayCrashS

; 2303 : 			if (mask & 1) {

	mov	ecx, DWORD PTR _mask$[ebp]
	and	ecx, 1
	je	SHORT $LN8@PlayCrashS

; 2304 : 				SoundIndex[index] = soundindex;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _soundindex$[ebp]
	mov	DWORD PTR ?SoundIndex@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[edx*4], eax

; 2305 : 				break;

	jmp	SHORT $LN9@PlayCrashS
$LN8@PlayCrashS:

; 2306 : 			}
; 2307 : 			mask >>= 1;

	mov	ecx, DWORD PTR _mask$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx

; 2308 : 			index++;

	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx

; 2309 : 		}

	jmp	SHORT $LN10@PlayCrashS
$LN9@PlayCrashS:

; 2310 : 	}
; 2311 : 	else {		// play sound

	jmp	$LN4@PlayCrashS
$LN12@PlayCrashS:

; 2312 : 		index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 2313 : 		for (i=0; i < F16CRASH_MAXSOUND; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@PlayCrashS
$LN5@PlayCrashS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@PlayCrashS:
	cmp	DWORD PTR _i$[ebp], 5
	jge	$LN4@PlayCrashS

; 2314 : 			if (mask & 1) {

	mov	ecx, DWORD PTR _mask$[ebp]
	and	ecx, 1
	je	$LN1@PlayCrashS

; 2315 : 				if (timePlaying[index] > time + DelayTime[index]) timePlaying[index] = 0;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	add	eax, DWORD PTR ?DelayTime@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[edx*4]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	DWORD PTR ?timePlaying@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[ecx*4], eax
	jle	SHORT $LN2@PlayCrashS
	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR ?timePlaying@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[edx*4], 0
$LN2@PlayCrashS:

; 2316 : 				if (timePlaying[index] < time) {

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR ?timePlaying@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[eax*4]
	cmp	ecx, DWORD PTR _time$[ebp]
	jge	SHORT $LN1@PlayCrashS

; 2317 : 					timePlaying[index] = time + DelayTime[index];

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	add	eax, DWORD PTR ?DelayTime@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[edx*4]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR ?timePlaying@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[ecx*4], eax

; 2318 : 					F4SoundFXSetPos(SoundIndex[index], TRUE, pos -> x, pos -> y, pos -> z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _pos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR ?SoundIndex@?1??PlayCrashSound@@YAXHHHHPAUTpoint@@@Z@4PAHA[edx*4]
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H
$LN1@PlayCrashS:

; 2319 : 				}
; 2320 : 			}
; 2321 : 			mask >>= 1;

	mov	ecx, DWORD PTR _mask$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _mask$[ebp], ecx

; 2322 : 			index++;

	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx

; 2323 : 		}

	jmp	$LN5@PlayCrashS
$LN4@PlayCrashS:

; 2324 : 	}
; 2325 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z ENDP		; PlayCrashSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
;	COMDAT ??__EgSfxLODTotCutoff@@YAXXZ
text$yc	SEGMENT
??__EgSfxLODTotCutoff@@YAXXZ PROC			; `dynamic initializer for 'gSfxLODTotCutoff'', COMDAT

; 79   : int gSfxLODTotCutoff = g_nSfxLODTotCutoff;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?g_nSfxLODTotCutoff@@3HA	; g_nSfxLODTotCutoff
	mov	DWORD PTR ?gSfxLODTotCutoff@@3HA, eax	; gSfxLODTotCutoff
	pop	ebp
	ret	0
??__EgSfxLODTotCutoff@@YAXXZ ENDP			; `dynamic initializer for 'gSfxLODTotCutoff''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
;	COMDAT ??__EgSfxLODDistCutoff@@YAXXZ
text$yc	SEGMENT
??__EgSfxLODDistCutoff@@YAXXZ PROC			; `dynamic initializer for 'gSfxLODDistCutoff'', COMDAT

; 78   : int gSfxLODDistCutoff = g_nSfxLODDistCutoff;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?g_nSfxLODDistCutoff@@3HA ; g_nSfxLODDistCutoff
	mov	DWORD PTR ?gSfxLODDistCutoff@@3HA, eax	; gSfxLODDistCutoff
	pop	ebp
	ret	0
??__EgSfxLODDistCutoff@@YAXXZ ENDP			; `dynamic initializer for 'gSfxLODDistCutoff''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
;	COMDAT ??__EgSfxLODCutoff@@YAXXZ
text$yc	SEGMENT
??__EgSfxLODCutoff@@YAXXZ PROC				; `dynamic initializer for 'gSfxLODCutoff'', COMDAT

; 77   : int gSfxLODCutoff = g_nSfxLODCutoff;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?g_nSfxLODCutoff@@3HA	; g_nSfxLODCutoff
	mov	DWORD PTR ?gSfxLODCutoff@@3HA, eax	; gSfxLODCutoff
	pop	ebp
	ret	0
??__EgSfxLODCutoff@@YAXXZ ENDP				; `dynamic initializer for 'gSfxLODCutoff''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
;	COMDAT ?IsRecording@ACMIRecorder@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRecording@ACMIRecorder@@QAEHXZ PROC			; ACMIRecorder::IsRecording, COMDAT
; _this$ = ecx

; 319  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return _recording;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 321  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRecording@ACMIRecorder@@QAEHXZ ENDP			; ACMIRecorder::IsRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetLightLevel@CTimeOfDay@@QAEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?GetLightLevel@CTimeOfDay@@QAEMXZ PROC			; CTimeOfDay::GetLightLevel, COMDAT
; _this$ = ecx

; 108  : 	float GetLightLevel()						{ return Ambient + Diffuse; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	addss	xmm0, DWORD PTR [ecx+224]
	movss	DWORD PTR tv71[ebp], xmm0
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLightLevel@CTimeOfDay@@QAEMXZ ENDP			; CTimeOfDay::GetLightLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
tv79 = -48						; size = 4
_ps$5 = -44						; size = 4
tv92 = -40						; size = 4
$T6 = -36						; size = 4
_id$ = -32						; size = 4
_zero$7 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_pos$ = 12						; size = 4
_vec$ = 16						; size = 4
?AddParticleEffect@@YAHPADPAUTpoint@@1@Z PROC		; AddParticleEffect

; 168  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 169  : 	int id = DrawableParticleSys::GetNameId(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	?GetNameId@DrawableParticleSys@@SAHPAD@Z ; DrawableParticleSys::GetNameId
	add	esp, 4
	mov	DWORD PTR _id$[ebp], eax

; 170  : 
; 171  : 	if(DrawableParticleSys::IsValidPSId(id))

	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	?IsValidPSId@DrawableParticleSys@@SAHH@Z ; DrawableParticleSys::IsValidPSId
	add	esp, 4
	test	eax, eax
	je	$LN2@AddParticl

; 172  : 	{
; 173  : 		Tpoint zero = {0,0,0};

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _zero$7[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _zero$7[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _zero$7[ebp+8], xmm0

; 174  : 		if(!vec)

	cmp	DWORD PTR _vec$[ebp], 0
	jne	SHORT $LN1@AddParticl

; 175  : 		{
; 176  : 			vec = &zero;

	lea	edx, DWORD PTR _zero$7[ebp]
	mov	DWORD PTR _vec$[ebp], edx
$LN1@AddParticl:

; 177  : 		}
; 178  : 
; 179  : 
; 180  : 		DrawableParticleSys *ps;
; 181  : 		ps = new DrawableParticleSys(id,1);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN5@AddParticl
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0DrawableParticleSys@@QAE@HM@Z	; DrawableParticleSys::DrawableParticleSys
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN6@AddParticl
$LN5@AddParticl:
	mov	DWORD PTR tv79[ebp], 0
$LN6@AddParticl:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _ps$5[ebp], edx

; 182  : 		ps->AddParticle(id, pos, vec);// Cobra - the SFX.cpp type is used in AddParticle(), so give the ID thru function

	mov	eax, DWORD PTR _vec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	ecx, DWORD PTR _ps$5[ebp]
	call	?AddParticle@DrawableParticleSys@@QAEXHPAUTpoint@@0@Z ; DrawableParticleSys::AddParticle

; 183  : 
; 184  : 		OTWDriver.AddSfxRequest( new SfxClass ( ps ) );	

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN7@AddParticl
	mov	eax, DWORD PTR _ps$5[ebp]
	push	eax
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z ; SfxClass::SfxClass
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN8@AddParticl
$LN7@AddParticl:
	mov	DWORD PTR tv92[ebp], 0
$LN8@AddParticl:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest

; 185  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@AddParticl
$LN2@AddParticl:

; 186  : 	}
; 187  : 	return 0;

	xor	eax, eax
$LN3@AddParticl:

; 188  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddParticleEffect@@YAHPADPAUTpoint@@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddParticleEffect@@YAHPADPAUTpoint@@1@Z ENDP		; AddParticleEffect
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
$T2 = -40						; size = 4
$T3 = -36						; size = 4
tv82 = -32						; size = 4
_z$4 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_SfxId$ = 8						; size = 4
_pos$ = 12						; size = 4
_vec$ = 16						; size = 4
?AddParticleEffect@@YAHHPAUTpoint@@0@Z PROC		; AddParticleEffect

; 153  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddParticleEffect@@YAHHPAUTpoint@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 154  : 	if(DrawableParticleSys::IsValidPSId(SfxId+1))

	mov	eax, DWORD PTR _SfxId$[ebp]
	add	eax, 1
	push	eax
	call	?IsValidPSId@DrawableParticleSys@@SAHH@Z ; DrawableParticleSys::IsValidPSId
	add	esp, 4
	test	eax, eax
	je	$LN2@AddParticl

; 155  : 	{
; 156  : 		Tpoint z = {0,0,0};

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _z$4[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _z$4[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _z$4[ebp+8], xmm0

; 157  : 		if(!vec)

	cmp	DWORD PTR _vec$[ebp], 0
	jne	SHORT $LN1@AddParticl

; 158  : 		{
; 159  : 			vec = &z;

	lea	ecx, DWORD PTR _z$4[ebp]
	mov	DWORD PTR _vec$[ebp], ecx
$LN1@AddParticl:

; 160  : 		}
; 161  : 		OTWDriver.AddSfxRequest( new SfxClass (SfxId, pos,	vec,	1,	1 ) );	

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@AddParticl
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	edx, DWORD PTR _vec$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SfxId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0SfxClass@@QAE@HPAUTpoint@@0HM@Z	; SfxClass::SfxClass
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN6@AddParticl
$LN5@AddParticl:
	mov	DWORD PTR tv82[ebp], 0
$LN6@AddParticl:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest

; 162  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@AddParticl
$LN2@AddParticl:

; 163  : 	}
; 164  : 	return 0;

	xor	eax, eax
$LN3@AddParticl:

; 165  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddParticleEffect@@YAHHPAUTpoint@@0@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddParticleEffect@@YAHHPAUTpoint@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddParticleEffect@@YAHHPAUTpoint@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddParticleEffect@@YAHHPAUTpoint@@0@Z ENDP		; AddParticleEffect
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv71 = -8						; size = 4
tv69 = -4						; size = 4
_objDetail$ = 8						; size = 4
?SetLOD@SfxClass@@SAXM@Z PROC				; SfxClass::SetLOD

; 5970 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5971 : 	// objDetail is based on PlayerOptions.SfxLevel
; 5972 : 	// and has a value of 0.0 to 5.0.  We want to normalize this to
; 5973 : 	// be in thee 0 - 1 range.
; 5974 : 	gSfxLOD = max( objDetail/5.0f, 0.1f );

	movss	xmm0, DWORD PTR _objDetail$[ebp]
	divss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN3@SetLOD
	movss	xmm0, DWORD PTR _objDetail$[ebp]
	divss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN4@SetLOD
$LN3@SetLOD:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv69[ebp], xmm0
$LN4@SetLOD:
	movss	xmm0, DWORD PTR tv69[ebp]
	movss	DWORD PTR ?gSfxLOD@@3MA, xmm0

; 5975 : 
; 5976 : 	// set the cutoff level for some special effects
; 5977 : //	gSfxLODCutoff = 40 + (int)( 160.0f * gSfxLOD );
; 5978 : 
; 5979 : 	// set the cutoff level for some special effects
; 5980 : 	// this is the total number currently running
; 5981 : //	gSfxLODTotCutoff = 200 + (int)( 600.0f * gSfxLOD );
; 5982 : 
; 5983 : 	// distant effects are compared against total running
; 5984 : 	// gSfxLODDistCutoff = 50 + (int)( 160.0f * gSfxLOD );
; 5985 : //	gSfxLODDistCutoff = (int)((float)gSfxLODTotCutoff * 0.75f);
; 5986 : 
; 5987 : 	// set the 2d detail level
; 5988 :  	Drawable2D::SetLOD( max( 0.8f, gSfxLOD ) );

	movss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	jbe	SHORT $LN5@SetLOD
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv71[ebp], xmm0
	jmp	SHORT $LN6@SetLOD
$LN5@SetLOD:
	movss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	movss	DWORD PTR tv71[ebp], xmm0
$LN6@SetLOD:
	push	ecx
	movss	xmm0, DWORD PTR tv71[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?SetLOD@Drawable2D@@SAXM@Z		; Drawable2D::SetLOD
	add	esp, 4

; 5989 : 
; 5990 : 	// MonoPrint( "New SFX LOD = %f, Obj Detail = %f\n", gSfxLOD, objDetail );
; 5991 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetLOD@SfxClass@@SAXM@Z ENDP				; SfxClass::SetLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv709 = -208						; size = 8
tv696 = -200						; size = 8
tv651 = -192						; size = 4
tv739 = -188						; size = 4
tv735 = -184						; size = 4
tv694 = -180						; size = 4
tv645 = -176						; size = 4
tv702 = -172						; size = 4
tv639 = -168						; size = 4
tv689 = -164						; size = 4
tv669 = -160						; size = 4
tv657 = -156						; size = 4
tv663 = -152						; size = 4
_groundType$ = -148					; size = 4
tv707 = -144						; size = 4
tv737 = -140						; size = 4
_hitGround$ = -136					; size = 4
_dTFrame$ = -132					; size = 4
tv704 = -128						; size = 2
tv691 = -126						; size = 2
_groundZ$ = -124					; size = 4
_dT$ = -120						; size = 4
_this$ = -116						; size = 4
_rot$ = -112						; size = 36
_rot$1 = -76						; size = 36
_mpos$ = -40						; size = 12
_newvec$ = -28						; size = 12
_newpos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_currTime$ = 8						; size = 4
?ACMIExec@SfxClass@@QAEHM@Z PROC			; SfxClass::ACMIExec
; _this$ = ecx

; 5764 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5765 : 	if(objParticleSys)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN31@ACMIExec

; 5766 : 	{
; 5767 : 		objParticleSys->Exec();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+168]
	call	?Exec@DrawableParticleSys@@QAEXXZ	; DrawableParticleSys::Exec

; 5768 : 		if(objParticleSys->HasParticles())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+168]
	call	?HasParticles@DrawableParticleSys@@QAEHXZ ; DrawableParticleSys::HasParticles
	test	eax, eax
	je	SHORT $LN30@ACMIExec

; 5769 : 			return TRUE;

	mov	eax, 1
	jmp	$LN32@ACMIExec
$LN30@ACMIExec:

; 5770 : 		return FALSE;

	xor	eax, eax
	jmp	$LN32@ACMIExec
$LN31@ACMIExec:

; 5771 : 	}
; 5772 : 
; 5773 : 	float groundZ=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _groundZ$[ebp], xmm0

; 5774 : 	BOOL hitGround = FALSE;

	mov	DWORD PTR _hitGround$[ebp], 0

; 5775 : 	Tpoint mpos, newpos, newvec;
; 5776 : 	Trotation rot = IMatrix;

	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	lea	edi, DWORD PTR _rot$[ebp]
	rep movsd

; 5777 : 	int groundType= COVERAGE_PLAINS;

	mov	DWORD PTR _groundType$[ebp], 4

; 5778 : 	float dTFrame=0.0F, dT=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dTFrame$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dT$[ebp], xmm0

; 5779 : 
; 5780 : 	// set delta time from last acmitime
; 5781 : 	dTFrame = (float)currTime - lastACMItime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currTime$[ebp]
	subss	xmm0, DWORD PTR [eax+136]
	movss	DWORD PTR _dTFrame$[ebp], xmm0

; 5782 : 	lastACMItime = (float)currTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currTime$[ebp]
	movss	DWORD PTR [ecx+136], xmm0

; 5783 : 
; 5784 : 	// set deltaT from the start of the effect
; 5785 : 	// position and movement is always determined relative to start time
; 5786 : 	dT = (float)currTime - startACMItime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currTime$[ebp]
	subss	xmm0, DWORD PTR [edx+140]
	movss	DWORD PTR _dT$[ebp], xmm0

; 5787 : 
; 5788 : 
; 5789 : 	// get approx distance to viewer based on timer
; 5790 : 	if ( currTime >= distTimer )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currTime$[ebp]
	comiss	xmm0, DWORD PTR [eax+128]
	jb	SHORT $LN29@ACMIExec

; 5791 : 		GetApproxViewDist(currTime);

	push	ecx
	movss	xmm0, DWORD PTR _currTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetApproxViewDist@SfxClass@@IAEXM@Z	; SfxClass::GetApproxViewDist
$LN29@ACMIExec:

; 5792 : 	
; 5793 : 
; 5794 : 	// if this effect is only drives other secondary effects, see if
; 5795 : 	// the count has reached 0, then kill it if so
; 5796 : 	// shouldn't have these in ACMI
; 5797 : 	if ( flags & SFX_SECONDARY_DRIVER )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 8
	je	SHORT $LN28@ACMIExec

; 5798 : 	{
; 5799 : 		return FALSE;

	xor	eax, eax
	jmp	$LN32@ACMIExec
$LN28@ACMIExec:

; 5800 : 	}
; 5801 : 
; 5802 : 	// check for hit with ground
; 5803 : 	if ( (flags & SFX_MOVES) && !(flags & SFX_NO_GROUND_CHECK) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	$LN25@ACMIExec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 16					; 00000010H
	jne	$LN25@ACMIExec

; 5804 : 	{
; 5805 : 		// 1st get approximation
; 5806 : 		groundZ = OTWDriver.GetApproxGroundLevel(pos.x, pos.y);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR _groundZ$[ebp]

; 5807 : 		if (  pos.z - groundZ  > -100.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR _groundZ$[ebp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jbe	SHORT $LN25@ACMIExec

; 5808 : 		{
; 5809 : 		 	groundZ = OTWDriver.GetGroundLevel( pos.x, pos.y );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$[ebp]

; 5810 : 			if ( pos.z >= groundZ )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	comiss	xmm0, DWORD PTR _groundZ$[ebp]
	jb	SHORT $LN25@ACMIExec

; 5811 : 			{
; 5812 : 				hitGround = TRUE;

	mov	DWORD PTR _hitGround$[ebp], 1

; 5813 : 				groundType = OTWDriver.GetGroundType (pos.x, pos.y);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundType@OTWDriverClass@@QAEHMM@Z	; OTWDriverClass::GetGroundType
	mov	DWORD PTR _groundType$[ebp], eax
$LN25@ACMIExec:

; 5814 : 			}
; 5815 : 		}
; 5816 : 	}
; 5817 : 
; 5818 : 	// does this object bounce?
; 5819 : 	/*
; 5820 : 	if ( hitGround && (flags & SFX_BOUNCES) && groundType > 2 )
; 5821 : 	{
; 5822 : 		// calcuate the new movement vector
; 5823 : 		GroundReflection();
; 5824 : 		pos.z = groundZ - 4.0f;
; 5825 : 		// momentum loss
; 5826 : 		vec.x *= 0.50f;
; 5827 : 		vec.y *= 0.50f;
; 5828 : 		vec.z *= 0.50f;
; 5829 : 		hitGround = FALSE;
; 5830 : 	}
; 5831 : 	*/
; 5832 : 
; 5833 : 	// lived long enough?
; 5834 : 	if ( currTime > timeToLive || hitGround )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currTime$[ebp]
	comiss	xmm0, DWORD PTR [eax+100]
	ja	SHORT $LN23@ACMIExec
	cmp	DWORD PTR _hitGround$[ebp], 0
	je	SHORT $LN24@ACMIExec
$LN23@ACMIExec:

; 5835 : 	{
; 5836 : 		// probably will need to remove from draw list here ...
; 5837 : 		// done with this effect
; 5838 : 		return FALSE;

	xor	eax, eax
	jmp	$LN32@ACMIExec
$LN24@ACMIExec:

; 5839 : 
; 5840 : 	}
; 5841 : 
; 5842 : 	// do we need to move it?
; 5843 : 	if ( !(flags & SFX_MOVES) || (flags & SFX_TIMER_FLAG) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	je	SHORT $LN21@ACMIExec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 256				; 00000100H
	je	SHORT $LN22@ACMIExec
$LN21@ACMIExec:

; 5844 : 	    return TRUE;

	mov	eax, 1
	jmp	$LN32@ACMIExec
$LN22@ACMIExec:

; 5845 : 
; 5846 : 	newvec = vec;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _newvec$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _newvec$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _newvec$[ebp+8], edx

; 5847 : 	if ( flags & (SFX_USES_GRAVITY | SFX_TRAJECTORY) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 514				; 00000202H
	je	SHORT $LN20@ACMIExec

; 5848 : 	{
; 5849 : 		// gravity = 32 ft/secSq
; 5850 : 		newvec.z += 32.0f * dT;

	movss	xmm0, DWORD PTR __real@42000000
	mulss	xmm0, DWORD PTR _dT$[ebp]
	addss	xmm0, DWORD PTR _newvec$[ebp+8]
	movss	DWORD PTR _newvec$[ebp+8], xmm0
$LN20@ACMIExec:

; 5851 : 	}
; 5852 : 
; 5853 : 	// update position based on vector
; 5854 : 	newpos.x = pos.x + vec.x * dT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _newpos$[ebp], xmm0

; 5855 : 	newpos.y = pos.y + vec.y * dT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _newpos$[ebp+4], xmm0

; 5856 : 	if ( flags & (SFX_USES_GRAVITY | SFX_TRAJECTORY) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 514				; 00000202H
	je	SHORT $LN19@ACMIExec

; 5857 : 	{
; 5858 : 		// pos(t) = p0 + v0(t) + 1/2a(t^2)
; 5859 : 		newpos.z = pos.z + vec.z * dT + 0.5f * 32.0f * dT * dT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+48]
	movss	xmm1, DWORD PTR __real@41800000
	mulss	xmm1, DWORD PTR _dT$[ebp]
	mulss	xmm1, DWORD PTR _dT$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _newpos$[ebp+8], xmm0

; 5860 : 	}
; 5861 : 	else

	jmp	SHORT $LN18@ACMIExec
$LN19@ACMIExec:

; 5862 : 	{
; 5863 : 		newpos.z = pos.z + vec.z * dT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR _newpos$[ebp+8], xmm0
$LN18@ACMIExec:

; 5864 : 	}
; 5865 : 
; 5866 : 	// hack, we've been noticing things still falling thru the ground
; 5867 : 	// double check position
; 5868 : 	if ( newpos.z > groundZ )

	movss	xmm0, DWORD PTR _newpos$[ebp+8]
	comiss	xmm0, DWORD PTR _groundZ$[ebp]
	jbe	SHORT $LN17@ACMIExec

; 5869 : 		newpos.z = groundZ;

	movss	xmm0, DWORD PTR _groundZ$[ebp]
	movss	DWORD PTR _newpos$[ebp+8], xmm0
$LN17@ACMIExec:

; 5870 : 
; 5871 : 	// for 2d objects set new position
; 5872 : 	if ( obj2d )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN16@ACMIExec

; 5873 : 	{
; 5874 : 		obj2d->SetPosition( &newpos );

	lea	ecx, DWORD PTR _newpos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?SetPosition@Drawable2D@@QAEXPAUTpoint@@@Z ; Drawable2D::SetPosition
$LN16@ACMIExec:

; 5875 : 	}
; 5876 : 
; 5877 : 	// for BSP objects set new position
; 5878 : 	if ( objBSP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+160], 0
	je	$LN15@ACMIExec

; 5879 : 	{
; 5880 : 		Trotation rot;
; 5881 : 
; 5882 : 		if ( type == SFX_EJECT1 )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 11			; 0000000bH
	jne	SHORT $LN14@ACMIExec

; 5883 : 		{
; 5884 : 			// hack! ejection is sideways
; 5885 : 			rot.M11 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rot$1[ebp], xmm0

; 5886 : 			rot.M12 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$1[ebp+4], xmm0

; 5887 : 			rot.M13 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$1[ebp+8], xmm0

; 5888 : 			rot.M21 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$1[ebp+12], xmm0

; 5889 : 			rot.M22 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$1[ebp+16], xmm0

; 5890 : 			rot.M23 = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _rot$1[ebp+20], xmm0

; 5891 : 			rot.M31 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$1[ebp+24], xmm0

; 5892 : 			rot.M32 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rot$1[ebp+28], xmm0

; 5893 : 			rot.M33 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$1[ebp+32], xmm0
	jmp	SHORT $LN11@ACMIExec
$LN14@ACMIExec:

; 5894 : 		}
; 5895 : 	  	else if (type == SFX_MOVING_BSP)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 33			; 00000021H
	jne	SHORT $LN12@ACMIExec

; 5896 :       	{
; 5897 :          	MatrixTranspose (&objBSP->orientation, &rot);

	lea	eax, DWORD PTR _rot$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	add	edx, 48					; 00000030H
	push	edx
	call	?MatrixTranspose@@YAXPBUTrotation@@PAU1@@Z ; MatrixTranspose
	add	esp, 8

; 5898 :       	}
; 5899 :       	else

	jmp	SHORT $LN11@ACMIExec
$LN12@ACMIExec:

; 5900 : 	  	{
; 5901 : 			// right now, no rotation
; 5902 : 			rot = IMatrix;

	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	lea	edi, DWORD PTR _rot$1[ebp]
	rep movsd
$LN11@ACMIExec:

; 5903 : 	  	}
; 5904 : 
; 5905 : 		objBSP->Update( &newpos, &rot );

	lea	eax, DWORD PTR _rot$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _newpos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update
$LN15@ACMIExec:

; 5906 : 	}
; 5907 : 
; 5908 : 	// for bsp objects
; 5909 : 	if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN10@ACMIExec

; 5910 : 	{
; 5911 : 		baseObj->SetPosition (newpos.x, newpos.y, newpos.z );

	push	ecx
	movss	xmm0, DWORD PTR _newpos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _newpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _newpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 5912 : 		baseObj->SetDelta (newvec.x, newvec.y, newvec.z );

	push	ecx
	movss	xmm0, DWORD PTR _newvec$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _newvec$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _newvec$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 5913 : 
; 5914 : 		if (newvec.x == 0.0f && newvec.y == 0.0f && newvec.z == 0.0f) {

	movss	xmm0, DWORD PTR _newvec$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@ACMIExec
	movss	xmm0, DWORD PTR _newvec$[ebp+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@ACMIExec
	movss	xmm0, DWORD PTR _newvec$[ebp+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@ACMIExec

; 5915 : 			baseObj->SetYPR(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 5916 : 		}
; 5917 : 		else {

	jmp	$LN8@ACMIExec
$LN9@ACMIExec:

; 5918 : 			baseObj->SetYPR(
; 5919 : 				baseObj->Yaw() + baseObj->YawDelta() * dT,
; 5920 : 				baseObj->Pitch() + baseObj->PitchDelta() * dT,
; 5921 : 				baseObj->Roll() + baseObj->RollDelta() * dT
; 5922 : 			);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv639[ebp]
	movss	xmm0, DWORD PTR tv639[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv735[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?RollDelta@VuEntity@@QBEMXZ		; VuEntity::RollDelta
	fstp	DWORD PTR tv645[ebp]
	movss	xmm0, DWORD PTR tv645[ebp]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	movss	xmm1, DWORD PTR tv735[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv651[ebp]
	movss	xmm0, DWORD PTR tv651[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv737[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?PitchDelta@VuEntity@@QBEMXZ		; VuEntity::PitchDelta
	fstp	DWORD PTR tv657[ebp]
	movss	xmm0, DWORD PTR tv657[ebp]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	movss	xmm1, DWORD PTR tv737[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv663[ebp]
	movss	xmm0, DWORD PTR tv663[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv739[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	fstp	DWORD PTR tv669[ebp]
	movss	xmm0, DWORD PTR tv669[ebp]
	mulss	xmm0, DWORD PTR _dT$[ebp]
	movss	xmm1, DWORD PTR tv739[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR
$LN8@ACMIExec:

; 5923 : 		}
; 5924 : 		CalcTransformMatrix(baseObj.get());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	call	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z ; CalcTransformMatrix
	add	esp, 4

; 5925 : 		OTWDriver.ObjectSetData (baseObj.get(), &newpos, &rot);

	lea	ecx, DWORD PTR _rot$[ebp]
	push	ecx
	lea	edx, DWORD PTR _newpos$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ObjectSetData@OTWDriverClass@@QAEXPAVSimBaseClass@@PAUTpoint@@PAUTrotation@@@Z ; OTWDriverClass::ObjectSetData

; 5926 : 		((DrawableBSP*)(baseObj->drawPointer))->Update(&newpos, &rot);

	lea	eax, DWORD PTR _rot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _newpos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update
$LN10@ACMIExec:

; 5927 : 	}
; 5928 : 
; 5929 : 	// for drawable trails 
; 5930 : 	if ( objTrail )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	$LN4@ACMIExec

; 5931 : 	{
; 5932 : 		if ( dTFrame < 0.0f )

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _dTFrame$[ebp]
	jbe	SHORT $LN6@ACMIExec

; 5933 : 			objTrail->RewindTrail ( (DWORD)(currTime * 1000) );

	movss	xmm0, DWORD PTR _currTime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv689[ebp], xmm0
	fld	DWORD PTR tv689[ebp]
	fnstcw	WORD PTR tv691[ebp]
	movzx	eax, WORD PTR tv691[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv694[ebp], eax
	fldcw	WORD PTR tv694[ebp]
	fistp	QWORD PTR tv696[ebp]
	fldcw	WORD PTR tv691[ebp]
	mov	eax, DWORD PTR tv696[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+156]
	call	?RewindTrail@DrawableTrail@@QAEHK@Z	; DrawableTrail::RewindTrail
	jmp	SHORT $LN4@ACMIExec
$LN6@ACMIExec:

; 5934 : 		else if ( dTFrame > 0.0f )

	movss	xmm0, DWORD PTR _dTFrame$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@ACMIExec

; 5935 : 			objTrail->AddPointAtHead (&newpos, (DWORD)(currTime * 1000) );

	movss	xmm0, DWORD PTR _currTime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv702[ebp], xmm0
	fld	DWORD PTR tv702[ebp]
	fnstcw	WORD PTR tv704[ebp]
	movzx	eax, WORD PTR tv704[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv707[ebp], eax
	fldcw	WORD PTR tv707[ebp]
	fistp	QWORD PTR tv709[ebp]
	fldcw	WORD PTR tv704[ebp]
	mov	edx, DWORD PTR tv709[ebp]
	push	edx
	lea	eax, DWORD PTR _newpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+156]
	call	?AddPointAtHead@DrawableTrail@@QAEXPAUTpoint@@K@Z ; DrawableTrail::AddPointAtHead
$LN4@ACMIExec:

; 5936 : 	}
; 5937 : 
; 5938 : 	// for drawable tracers
; 5939 : 	if ( objTracer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 0
	je	$LN3@ACMIExec

; 5940 : 	{
; 5941 : 		// tracers take a start and end position
; 5942 : 		// use a value that's about 1/4 their velocity vector
; 5943 : 		if ( type == SFX_GUN_TRACER )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 61			; 0000003dH
	jne	SHORT $LN2@ACMIExec

; 5944 : 		{
; 5945 : 			mpos.x = newpos.x - ( newvec.x * sfxFrameTime * 0.2f );

	movss	xmm0, DWORD PTR _newvec$[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR _newpos$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp], xmm1

; 5946 : 			mpos.y = newpos.y - ( newvec.y * sfxFrameTime * 0.2f ) ;

	movss	xmm0, DWORD PTR _newvec$[ebp+4]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR _newpos$[ebp+4]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+4], xmm1

; 5947 : 			mpos.z = newpos.z - ( newvec.z * sfxFrameTime * 0.2f );

	movss	xmm0, DWORD PTR _newvec$[ebp+8]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR _newpos$[ebp+8]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1

; 5948 : 		}
; 5949 : 		else 

	jmp	SHORT $LN1@ACMIExec
$LN2@ACMIExec:

; 5950 : 		{
; 5951 : 			mpos.x = newpos.x - ( newvec.x * 0.02f );

	movss	xmm0, DWORD PTR _newvec$[ebp]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR _newpos$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp], xmm1

; 5952 : 			mpos.y = newpos.y - ( newvec.y * 0.02f );

	movss	xmm0, DWORD PTR _newvec$[ebp+4]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR _newpos$[ebp+4]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+4], xmm1

; 5953 : 			mpos.z = newpos.z - ( newvec.z * 0.02f );

	movss	xmm0, DWORD PTR _newvec$[ebp+8]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	xmm1, DWORD PTR _newpos$[ebp+8]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1
$LN1@ACMIExec:

; 5954 : 		}
; 5955 : 		objTracer->Update( &newpos, &mpos );

	lea	ecx, DWORD PTR _mpos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _newpos$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+164]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN3@ACMIExec:

; 5956 : 	}
; 5957 : 
; 5958 : 	return TRUE;

	mov	eax, 1
$LN32@ACMIExec:

; 5959 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?ACMIExec@SfxClass@@QAEHM@Z ENDP			; SfxClass::ACMIExec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv227 = -48						; size = 8
tv216 = -40						; size = 8
_distScale$1 = -32					; size = 4
tv225 = -28						; size = 4
tv220 = -24						; size = 4
tv214 = -20						; size = 4
tv209 = -16						; size = 4
tv149 = -12						; size = 4
_this$ = -8						; size = 4
tv222 = -4						; size = 2
tv211 = -2						; size = 2
_acmiView$ = 8						; size = 4
_startTime$ = 12					; size = 4
_currTime$ = 16						; size = 4
?ACMIStart@SfxClass@@QAEXPAVRViewPoint@@MM@Z PROC	; SfxClass::ACMIStart
; _this$ = ecx

; 5705 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 5706 : 	inACMI = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 1

; 5707 : 	viewPoint = acmiView;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _acmiView$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 5708 : 
; 5709 : 	// set the time it will die
; 5710 : 	timeToLive += startTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	addss	xmm0, DWORD PTR _startTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 5711 : 
; 5712 : 	// last ACMI time set
; 5713 : 	lastACMItime = (float)currTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _currTime$[ebp]
	movss	DWORD PTR [edx+136], xmm0

; 5714 : 	startACMItime = startTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _startTime$[ebp]
	movss	DWORD PTR [eax+140], xmm0

; 5715 : 
; 5716 : 	// get the approximate distance to the viewer
; 5717 : 	GetApproxViewDist( currTime );

	push	ecx
	movss	xmm0, DWORD PTR _currTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetApproxViewDist@SfxClass@@IAEXM@Z	; SfxClass::GetApproxViewDist

; 5718 : 
; 5719 : 	// timers don't get added to draw list
; 5720 : 	if ( flags & SFX_TIMER_FLAG )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 256				; 00000100H
	je	SHORT $LN7@ACMIStart

; 5721 : 		return;

	jmp	$LN8@ACMIStart
$LN7@ACMIStart:

; 5722 : 
; 5723 : 	// insert the effect's object into the display list
; 5724 : 	if ( obj2d )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	$LN6@ACMIStart

; 5725 : 	{
; 5726 : 		obj2d->SetStartTime( (DWORD)( startTime * 1000 ), (DWORD)( currTime * 1000 ) );

	movss	xmm0, DWORD PTR _currTime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv209[ebp], xmm0
	fld	DWORD PTR tv209[ebp]
	fnstcw	WORD PTR tv211[ebp]
	movzx	eax, WORD PTR tv211[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv214[ebp], eax
	fldcw	WORD PTR tv214[ebp]
	fistp	QWORD PTR tv216[ebp]
	fldcw	WORD PTR tv211[ebp]
	mov	ecx, DWORD PTR tv216[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _startTime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv220[ebp], xmm0
	fld	DWORD PTR tv220[ebp]
	fnstcw	WORD PTR tv222[ebp]
	movzx	eax, WORD PTR tv222[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv225[ebp], eax
	fldcw	WORD PTR tv225[ebp]
	fistp	QWORD PTR tv227[ebp]
	fldcw	WORD PTR tv222[ebp]
	mov	edx, DWORD PTR tv227[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?SetStartTime@Drawable2D@@QAEXKK@Z	; Drawable2D::SetStartTime

; 5727 : 		viewPoint->InsertObject(obj2d);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	call	?InsertObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::InsertObject
$LN6@ACMIStart:

; 5728 : 	}
; 5729 : 	if ( objBSP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+160], 0
	je	SHORT $LN5@ACMIStart

; 5730 : 	{
; 5731 : 		viewPoint->InsertObject(objBSP);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+184]
	call	?InsertObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::InsertObject
$LN5@ACMIStart:

; 5732 : 	}
; 5733 : 	if ( objTrail )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	$LN4@ACMIStart

; 5734 : 	{
; 5735 : 		// a hack -- scale trail of missile launch based on dist
; 5736 : 		if ( type == SFX_MISSILE_LAUNCH )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 21			; 00000015H
	jne	SHORT $LN3@ACMIStart

; 5737 : 		{
; 5738 : 			float distScale = max( 0.1f, approxDist/10000.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@461c4000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN10@ACMIStart
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN11@ACMIStart
$LN10@ACMIStart:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+132]
	divss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR tv149[ebp], xmm0
$LN11@ACMIStart:
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR _distScale$1[ebp], xmm0

; 5739 : 			objTrail->SetScale( distScale );

	push	ecx
	movss	xmm0, DWORD PTR _distScale$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	call	?SetScale@DrawableObject@@QAEXM@Z	; DrawableObject::SetScale
$LN3@ACMIStart:

; 5740 : 		}
; 5741 : 		objTrail->KeepStaleSegs( TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+156]
	call	?KeepStaleSegs@DrawableTrail@@QAEXH@Z	; DrawableTrail::KeepStaleSegs

; 5742 : 		viewPoint->InsertObject(objTrail);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+184]
	call	?InsertObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::InsertObject
$LN4@ACMIStart:

; 5743 : 	}
; 5744 : 	if ( objTracer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 0
	je	SHORT $LN2@ACMIStart

; 5745 : 	{
; 5746 : 		viewPoint->InsertObject(objTracer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+184]
	call	?InsertObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::InsertObject
$LN2@ACMIStart:

; 5747 : 	}
; 5748 : 	if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@ACMIStart

; 5749 : 	{
; 5750 : 		viewPoint->InsertObject(baseObj->drawPointer);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+184]
	call	?InsertObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::InsertObject
$LN1@ACMIStart:
$LN8@ACMIStart:

; 5751 : 	}
; 5752 : 
; 5753 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ACMIStart@SfxClass@@QAEXPAVRViewPoint@@MM@Z ENDP	; SfxClass::ACMIStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_r$1 = -112						; size = 4
_g$2 = -108						; size = 4
_curra$3 = -104						; size = 4
_scaleOTW$ = -100					; size = 4
_b$4 = -96						; size = 4
_this$ = -92						; size = 4
_rot$ = -88						; size = 36
_rot$5 = -52						; size = 36
_mpos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?Draw@SfxClass@@QAEHXZ PROC				; SfxClass::Draw
; _this$ = ecx

; 2848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2849 : 	Tpoint mpos;
; 2850 : 	Trotation rot = IMatrix;

	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	lea	edi, DWORD PTR _rot$[ebp]
	rep movsd

; 2851 : 	float scaleOTW = OTWDriver.Scale();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Scale@OTWDriverClass@@QAEMXZ		; OTWDriverClass::Scale
	fstp	DWORD PTR _scaleOTW$[ebp]

; 2852 : 
; 2853 : 	// do we need to move it?
; 2854 : 	// this type has no drawing
; 2855 : 	if ( type == SFX_SMOKING_FEATURE || type == SFX_STEAMING_FEATURE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 100			; 00000064H
	je	SHORT $LN22@Draw
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 101			; 00000065H
	jne	SHORT $LN23@Draw
$LN22@Draw:

; 2856 : 		return TRUE;

	mov	eax, 1
	jmp	$LN24@Draw
$LN23@Draw:

; 2857 : 
; 2858 : 	// this type has no drawing
; 2859 : 	if ( (!(flags & SFX_F16CRASHLANDING) && !(flags & SFX_MOVES)) || (flags & SFX_TIMER_FLAG) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -2147483648			; 80000000H
	jne	SHORT $LN19@Draw
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	je	SHORT $LN20@Draw
$LN19@Draw:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 256				; 00000100H
	je	SHORT $LN21@Draw
$LN20@Draw:

; 2860 : 	{
; 2861 : 		if ( obj2d )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN18@Draw

; 2862 : 		{
; 2863 : 			obj2d->SetScale2D( scaleOTW );

	push	ecx
	movss	xmm0, DWORD PTR _scaleOTW$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?SetScale2D@Drawable2D@@QAEXM@Z		; Drawable2D::SetScale2D
$LN18@Draw:

; 2864 : 		}
; 2865 : 		if ( objBSP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+160], 0
	je	SHORT $LN17@Draw

; 2866 : 		{
; 2867 : 			objBSP->SetScale( scaleOTW );

	push	ecx
	movss	xmm0, DWORD PTR _scaleOTW$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?SetScale@DrawableObject@@QAEXM@Z	; DrawableObject::SetScale
$LN17@Draw:

; 2868 : 		}
; 2869 : 		if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool

; 2870 : 		{
; 2871 :             // Pu239 This shit is generating problems n the free flight TE, comment it out and everything works fine.
; 2872 : 			//baseObj->drawPointer->SetScale( scaleOTW );
; 2873 : 		}
; 2874 : 	    return TRUE;

	mov	eax, 1
	jmp	$LN24@Draw
$LN21@Draw:

; 2875 : 	}
; 2876 : 
; 2877 : 	// for 2d objects set new position
; 2878 : 	if ( obj2d )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+152], 0
	je	SHORT $LN15@Draw

; 2879 : 	{
; 2880 : 		obj2d->SetPosition( &pos );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?SetPosition@Drawable2D@@QAEXPAUTpoint@@@Z ; Drawable2D::SetPosition

; 2881 : 		obj2d->SetScale2D( scaleOTW );

	push	ecx
	movss	xmm0, DWORD PTR _scaleOTW$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?SetScale2D@Drawable2D@@QAEXM@Z		; Drawable2D::SetScale2D
$LN15@Draw:

; 2882 : 	}
; 2883 : 
; 2884 : 	// for BSP objects set new position
; 2885 : 	if ( objBSP )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+160], 0
	je	$LN14@Draw

; 2886 : 	{
; 2887 : 		Trotation rot;
; 2888 : 
; 2889 : 		objBSP->SetScale( scaleOTW );

	push	ecx
	movss	xmm0, DWORD PTR _scaleOTW$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	call	?SetScale@DrawableObject@@QAEXM@Z	; DrawableObject::SetScale

; 2890 :       if ( type == SFX_EJECT1 )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 11			; 0000000bH
	jne	SHORT $LN13@Draw

; 2891 :       {
; 2892 :          // hack! ejection is sideways
; 2893 :          rot.M11 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rot$5[ebp], xmm0

; 2894 :          rot.M12 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$5[ebp+4], xmm0

; 2895 :          rot.M13 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$5[ebp+8], xmm0

; 2896 :          rot.M21 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$5[ebp+12], xmm0

; 2897 :          rot.M22 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$5[ebp+16], xmm0

; 2898 :          rot.M23 = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _rot$5[ebp+20], xmm0

; 2899 :          rot.M31 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$5[ebp+24], xmm0

; 2900 :          rot.M32 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _rot$5[ebp+28], xmm0

; 2901 :          rot.M33 = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rot$5[ebp+32], xmm0
	jmp	$LN10@Draw
$LN13@Draw:

; 2902 :       }
; 2903 :       else if (type == SFX_MOVING_BSP)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 33			; 00000021H
	jne	$LN11@Draw

; 2904 :       {
; 2905 :          rot.M11 = objBSP->orientation.M11;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR _rot$5[ebp], xmm0

; 2906 :          rot.M12 = objBSP->orientation.M12;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR _rot$5[ebp+4], xmm0

; 2907 :          rot.M13 = objBSP->orientation.M13;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR _rot$5[ebp+8], xmm0

; 2908 :          rot.M21 = objBSP->orientation.M21;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	movss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR _rot$5[ebp+12], xmm0

; 2909 :          rot.M22 = objBSP->orientation.M22;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	movss	xmm0, DWORD PTR [eax+64]
	movss	DWORD PTR _rot$5[ebp+16], xmm0

; 2910 :          rot.M23 = objBSP->orientation.M23;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	movss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR _rot$5[ebp+20], xmm0

; 2911 :          rot.M31 = objBSP->orientation.M31;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	movss	xmm0, DWORD PTR [ecx+72]
	movss	DWORD PTR _rot$5[ebp+24], xmm0

; 2912 :          rot.M32 = objBSP->orientation.M32;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	movss	xmm0, DWORD PTR [eax+76]
	movss	DWORD PTR _rot$5[ebp+28], xmm0

; 2913 :          rot.M33 = objBSP->orientation.M33;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	movss	xmm0, DWORD PTR [edx+80]
	movss	DWORD PTR _rot$5[ebp+32], xmm0

; 2914 :       }
; 2915 :       else

	jmp	SHORT $LN10@Draw
$LN11@Draw:

; 2916 : 		{
; 2917 : 			// right now, no rotation
; 2918 : 			rot = IMatrix;

	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	lea	edi, DWORD PTR _rot$5[ebp]
	rep movsd
$LN10@Draw:

; 2919 : 		}
; 2920 : 
; 2921 : 		objBSP->Update( &pos, &rot );

	lea	eax, DWORD PTR _rot$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update
$LN14@Draw:

; 2922 : 	}
; 2923 : 
; 2924 : 	// for bsp objects
; 2925 : 	if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Draw

; 2926 : 	{
; 2927 : 		OTWDriver.ObjectSetData(baseObj.get(), &pos, &rot);

	lea	ecx, DWORD PTR _rot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ObjectSetData@OTWDriverClass@@QAEXPAVSimBaseClass@@PAUTpoint@@PAUTrotation@@@Z ; OTWDriverClass::ObjectSetData

; 2928 : 		((DrawableBSP*)(baseObj->drawPointer))->Update(&pos, &rot);

	lea	eax, DWORD PTR _rot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update

; 2929 : 		baseObj->drawPointer->SetScale( scaleOTW );

	push	ecx
	movss	xmm0, DWORD PTR _scaleOTW$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?SetScale@DrawableObject@@QAEXM@Z	; DrawableObject::SetScale
$LN9@Draw:

; 2930 : 	}
; 2931 : 
; 2932 : 	// for drawable trails 
; 2933 : 	if ( objTrail )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	SHORT $LN8@Draw

; 2934 : 	{
; 2935 : 		OTWDriver.AddTrailHead (objTrail, pos.x, pos.y, pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddTrailHead@OTWDriverClass@@QAEXPAVDrawableTrail@@MMM@Z ; OTWDriverClass::AddTrailHead
$LN8@Draw:

; 2936 : 	}
; 2937 : 
; 2938 : 	// for drawable tracers
; 2939 : 	if ( objTracer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 0
	je	$LN7@Draw

; 2940 : 	{
; 2941 : 		if ( type == SFX_SPARK_TRACER )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 117			; 00000075H
	jne	$LN6@Draw

; 2942 : 		{
; 2943 : 			float curra = objTracer->GetAlpha();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	fstp	DWORD PTR _curra$3[ebp]

; 2944 : 			float r,g,b;
; 2945 : 
; 2946 : 			objTracer->GetRGB( &r, &g, &b );

	lea	ecx, DWORD PTR _b$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _g$2[ebp]
	push	edx
	lea	eax, DWORD PTR _r$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+44]
	call	eax

; 2947 : 			curra -= sfxFrameTime * 0.8f;

	movss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR _curra$3[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _curra$3[ebp], xmm1

; 2948 : 			if ( curra < 0.0f )

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _curra$3[ebp]
	jbe	SHORT $LN5@Draw

; 2949 : 				curra = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _curra$3[ebp], xmm0
$LN5@Draw:

; 2950 : 			b -= sfxFrameTime * 1.5f;

	movss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	xmm1, DWORD PTR _b$4[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _b$4[ebp], xmm1

; 2951 : 			if ( b < 0.0f )

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _b$4[ebp]
	jbe	SHORT $LN4@Draw

; 2952 : 				b = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _b$4[ebp], xmm0
$LN4@Draw:

; 2953 : 			objTracer->SetAlpha( curra );

	push	ecx
	movss	xmm0, DWORD PTR _curra$3[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 2954 : 			objTracer->SetRGB( r, g, b );

	push	ecx
	movss	xmm0, DWORD PTR _b$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _g$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _r$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2955 : 			mpos.x = pos.x - ( vec.x * 0.25f );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR __real@3e800000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+40]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp], xmm1

; 2956 : 			mpos.y = pos.y - ( vec.y * 0.25f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR __real@3e800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+44]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+4], xmm1

; 2957 : 			mpos.z = pos.z - ( vec.z * 0.25f );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3e800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1
	jmp	$LN1@Draw
$LN6@Draw:

; 2958 : 		}
; 2959 : 
; 2960 : 		// tracers take a start and end position
; 2961 : 		// use a value that's about 1/4 their velocity vector
; 2962 : 		else if ( type == SFX_GUN_TRACER )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 61			; 0000003dH
	jne	SHORT $LN2@Draw

; 2963 : 		{
; 2964 : 			mpos.x = pos.x - ( vec.x * sfxFrameTime * 0.2f );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+40]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp], xmm1

; 2965 : 			mpos.y = pos.y - ( vec.y * sfxFrameTime * 0.2f ) ;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+44]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+4], xmm1

; 2966 : 			mpos.z = pos.z - ( vec.z * sfxFrameTime * 0.2f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1

; 2967 : 		}
; 2968 : 		else

	jmp	SHORT $LN1@Draw
$LN2@Draw:

; 2969 : 		{
; 2970 : 			mpos.x = pos.x - ( vec.x * 0.02f );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+40]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp], xmm1

; 2971 : 			mpos.y = pos.y - ( vec.y * 0.02f );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+44]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+4], xmm1

; 2972 : 			mpos.z = pos.z - ( vec.z * 0.02f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1
$LN1@Draw:

; 2973 : 		}
; 2974 : 		objTracer->Update( &pos, &mpos );

	lea	edx, DWORD PTR _mpos$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN7@Draw:

; 2975 : 	}
; 2976 : 
; 2977 : 	return TRUE;

	mov	eax, 1
$LN24@Draw:

; 2978 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?Draw@SfxClass@@QAEHXZ ENDP				; SfxClass::Draw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_trig$1 = -528						; size = 8
_curtime$2 = -520					; size = 4
tv2038 = -516						; size = 4
tv1937 = -512						; size = 4
tv2046 = -508						; size = 4
tv1930 = -504						; size = 4
tv2128 = -500						; size = 4
tv1923 = -496						; size = 4
tv2242 = -492						; size = 4
tv1904 = -488						; size = 4
tv2153 = -484						; size = 4
tv1881 = -480						; size = 4
tv2086 = -476						; size = 4
tv2820 = -472						; size = 4
tv2321 = -468						; size = 4
tv1835 = -464						; size = 4
tv2223 = -460						; size = 4
tv2199 = -456						; size = 4
tv2828 = -452						; size = 4
tv2159 = -448						; size = 4
tv2834 = -444						; size = 4
tv2824 = -440						; size = 4
tv2809 = -436						; size = 4
tv2822 = -432						; size = 4
tv2803 = -428						; size = 4
tv2059 = -424						; size = 4
tv2832 = -420						; size = 4
tv2326 = -416						; size = 4
tv2797 = -412						; size = 4
tv2316 = -408						; size = 4
tv2791 = -404						; size = 4
tv2234 = -400						; size = 4
tv2830 = -396						; size = 4
tv2212 = -392						; size = 4
tv2785 = -388						; size = 4
tv2191 = -384						; size = 4
tv2779 = -380						; size = 4
tv2165 = -376						; size = 4
tv2665 = -372						; size = 4
tv2826 = -368						; size = 4
tv2657 = -364						; size = 4
tv2147 = -360						; size = 4
tv2649 = -356						; size = 4
_hdg$3 = -352						; size = 4
_coverage$ = -348					; size = 4
tv2111 = -344						; size = 4
_yaw$4 = -340						; size = 4
tv2092 = -336						; size = 4
_pitch$5 = -332						; size = 4
tv2065 = -328						; size = 4
_roll$6 = -324						; size = 4
tv2053 = -320						; size = 4
tv2378 = -316						; size = 4
tv2370 = -312						; size = 4
tv2134 = -308						; size = 4
_roll$7 = -304						; size = 4
tv1387 = -300						; size = 4
_roll1$8 = -296						; size = 4
tv276 = -292						; size = 4
_pitch$9 = -288						; size = 4
_coverage$10 = -284					; size = 4
_roll$11 = -280						; size = 4
_vel$12 = -276						; size = 4
_scale$13 = -272					; size = 4
_pitch$14 = -268					; size = 4
tv141 = -264						; size = 4
_vecz$15 = -260						; size = 4
_stopit$16 = -256					; size = 4
_lastHit$17 = -252					; size = 4
_stopit$18 = -248					; size = 4
_gZ$19 = -244						; size = 4
_yaw$20 = -240						; size = 4
_i$21 = -236						; size = 4
_pitch1$22 = -232					; size = 4
_groundType$ = -228					; size = 4
_CrashSoundMask$23 = -224				; size = 4
_hitGround$ = -220					; size = 4
_groundZ$ = -216					; size = 4
_this$ = -212						; size = 4
_normal$24 = -208					; size = 12
_GroundNormal$25 = -196					; size = 12
_objrot$26 = -184					; size = 36
_objpos$27 = -148					; size = 12
_PSvec$ = -136						; size = 12
_point$28 = -124					; size = 12
_mat1$29 = -112						; size = 36
_mat$30 = -76						; size = 36
_mat$31 = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
?Exec@SfxClass@@QAEHXZ PROC				; SfxClass::Exec
; _this$ = ecx

; 2337 : BOOL SfxClass::Exec(){

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2338 : 	float groundZ=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _groundZ$[ebp], xmm0

; 2339 :     int groundType=COVERAGE_PLAINS;

	mov	DWORD PTR _groundType$[ebp], 4

; 2340 : 	BOOL hitGround = FALSE;

	mov	DWORD PTR _hitGround$[ebp], 0

; 2341 : 
; 2342 : 	//RV - I-Hawk - Added a 0 vector for RV new PS calls
; 2343 : 	Tpoint PSvec;
; 2344 : 	PSvec.x = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _PSvec$[ebp], xmm0

; 2345 : 	PSvec.y = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _PSvec$[ebp+4], xmm0

; 2346 : 	PSvec.z = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _PSvec$[ebp+8], xmm0

; 2347 : 
; 2348 : 	if (objParticleSys){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN80@Exec

; 2349 : 		objParticleSys->Exec();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+168]
	call	?Exec@DrawableParticleSys@@QAEXXZ	; DrawableParticleSys::Exec

; 2350 : 		if (objParticleSys->HasParticles()){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+168]
	call	?HasParticles@DrawableParticleSys@@QAEHXZ ; DrawableParticleSys::HasParticles
	test	eax, eax
	je	SHORT $LN79@Exec

; 2351 : 			return TRUE;

	mov	eax, 1
	jmp	$LN81@Exec
$LN79@Exec:

; 2352 : 		}
; 2353 : 		return FALSE;

	xor	eax, eax
	jmp	$LN81@Exec
$LN80@Exec:

; 2354 : 	}
; 2355 : 
; 2356 : 	// get approx distance to viewer based on timer
; 2357 : 	if ( SIM_ELAPSED_SEC >= distTimer ){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	comiss	xmm0, DWORD PTR [eax+128]
	jb	SHORT $LN78@Exec

; 2358 : 		GetApproxViewDist((float)SIM_ELAPSED_SEC );

	push	ecx
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetApproxViewDist@SfxClass@@IAEXM@Z	; SfxClass::GetApproxViewDist
$LN78@Exec:

; 2359 : 	}
; 2360 : 
; 2361 : 	// special case smoking feature -- they continue to run until the
; 2362 : 	// feature goes to sleep
; 2363 : 	if ( type == SFX_SMOKING_FEATURE || type == SFX_STEAMING_FEATURE ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 100			; 00000064H
	je	SHORT $LN76@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 101			; 00000065H
	jne	$LN77@Exec
$LN76@Exec:

; 2364 : 		// if we'vee got no base object return FALSE
; 2365 : 		if ( baseObj == NULL ){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN75@Exec

; 2366 : 			return FALSE;

	xor	eax, eax
	jmp	$LN81@Exec
$LN75@Exec:

; 2367 : 		}
; 2368 : 
; 2369 : 		// check to see if the object is awake or if its state
; 2370 : 		// is no longer OK
; 2371 : 		if ( !baseObj->IsAwake() ||
; 2372 : 		     (baseObj->Status() & VIS_TYPE_MASK) == VIS_DESTROYED ||
; 2373 : 		     (baseObj->Status() & VIS_TYPE_MASK) == VIS_DAMAGED ||
; 2374 : 			 baseObj->IsDead() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN73@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Status@SimBaseClass@@QBEHXZ		; SimBaseClass::Status
	and	eax, 7
	cmp	eax, 3
	je	SHORT $LN73@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Status@SimBaseClass@@QBEHXZ		; SimBaseClass::Status
	and	eax, 7
	cmp	eax, 2
	je	SHORT $LN73@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR tv141[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv141[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	je	SHORT $LN74@Exec
$LN73@Exec:

; 2375 : 		{
; 2376 : 			// deref the entity
; 2377 : 			//VuDeReferenceEntity( baseObj );
; 2378 : 
; 2379 : 			baseObj.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::reset

; 2380 : 
; 2381 : 			// we're done
; 2382 : 			return FALSE;

	xor	eax, eax
	jmp	$LN81@Exec
$LN74@Exec:

; 2383 : 		}
; 2384 : 
; 2385 : 		// run any secondary effects here
; 2386 : 		if ( SIM_ELAPSED_SEC >= secondaryTimer ){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	comiss	xmm0, DWORD PTR [ecx+124]
	jb	$LN72@Exec

; 2387 : 			// temporarily use the objBSP ptr
; 2388 : 			// se need to keep getting the base position since LOD may change
; 2389 : 			// on terrain
; 2390 : 			objBSP = (DrawableBSP *)baseObj->drawPointer;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]
	mov	DWORD PTR [edx+160], eax

; 2391 : 			objBSP->GetPosition( &pos );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 2392 : 
; 2393 : 			pos.x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+40], xmm0

; 2394 : 			pos.y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+44], xmm0

; 2395 : 			pos.z += vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	addss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0

; 2396 : 
; 2397 : 			// we're done borrowing this
; 2398 : 			objBSP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 2399 : 
; 2400 : 			groundZ = approxDist/30000.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@46ea6000
	movss	DWORD PTR _groundZ$[ebp], xmm0

; 2401 : 			secondaryTimer = SIM_ELAPSED_SEC + 0.50f + 2.5F * groundZ;

	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	addss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR __real@40200000
	mulss	xmm1, DWORD PTR _groundZ$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+124], xmm0

; 2402 : 
; 2403 : 			RunSecondarySfx();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunSecondarySfx@SfxClass@@IAEXXZ	; SfxClass::RunSecondarySfx
$LN72@Exec:

; 2404 : 		}
; 2405 : 
; 2406 : 		Draw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Draw@SfxClass@@QAEHXZ			; SfxClass::Draw

; 2407 : 		return TRUE;

	mov	eax, 1
	jmp	$LN81@Exec
$LN77@Exec:

; 2408 : 	}
; 2409 : 
; 2410 : 	if ( SimLibElapsedTime >= gWindTimer ){

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, DWORD PTR ?gWindTimer@@3KA		; gWindTimer
	jb	$LN71@Exec

; 2411 : 		mlTrig trig;
; 2412 : 		float hdg,vel;
; 2413 : 
; 2414 : 		gWindTimer = SimLibElapsedTime + 120000;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 120000				; 0001d4c0H
	mov	DWORD PTR ?gWindTimer@@3KA, ecx		; gWindTimer

; 2415 : 
; 2416 : 		hdg = ((WeatherClass*)realWeather)->WindHeadingAt(&pos);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?WindHeadingAt@WeatherClass@@QAEMPBUTpoint@@@Z ; WeatherClass::WindHeadingAt
	fstp	DWORD PTR _hdg$3[ebp]

; 2417 : 		vel = ((WeatherClass*)realWeather)->WindSpeedInFeetPerSecond(&pos);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?WindSpeedInFeetPerSecond@WeatherClass@@QAEMPBUTpoint@@@Z ; WeatherClass::WindSpeedInFeetPerSecond
	fstp	DWORD PTR _vel$12[ebp]

; 2418 :    		mlSinCos (&trig, hdg);

	push	ecx
	movss	xmm0, DWORD PTR _hdg$3[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$1[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2419 : 		gWindVect.x = trig.cos * vel;

	movss	xmm0, DWORD PTR _trig$1[ebp+4]
	mulss	xmm0, DWORD PTR _vel$12[ebp]
	movss	DWORD PTR ?gWindVect@@3UTpoint@@A, xmm0

; 2420 : 		gWindVect.y = trig.sin * vel;

	movss	xmm0, DWORD PTR _trig$1[ebp]
	mulss	xmm0, DWORD PTR _vel$12[ebp]
	movss	DWORD PTR ?gWindVect@@3UTpoint@@A+4, xmm0
$LN71@Exec:

; 2421 : 	}
; 2422 : 	
; 2423 : 
; 2424 : 	// run any secondary effects here
; 2425 : 	if ( secondaryCount > 0 && SIM_ELAPSED_SEC >= secondaryTimer ){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+112], 0
	jle	$LN70@Exec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	comiss	xmm0, DWORD PTR [eax+124]
	jb	$LN70@Exec

; 2426 : 		secondaryCount--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], edx

; 2427 : 		secondaryTimer = 
; 2428 : 			SIM_ELAPSED_SEC + secondaryInterval + secondaryInterval * (PRANDFloat() + 1.0f - gSfxLOD)
; 2429 : 		;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	addss	xmm0, DWORD PTR [ecx+120]
	movss	DWORD PTR tv2820[ebp], xmm0
	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1835[ebp]
	movss	xmm0, DWORD PTR tv1835[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+120]
	movss	xmm1, DWORD PTR tv2820[ebp]
	addss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+124], xmm1

; 2430 : 		RunSecondarySfx();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunSecondarySfx@SfxClass@@IAEXXZ	; SfxClass::RunSecondarySfx
$LN70@Exec:

; 2431 : 	}
; 2432 : 
; 2433 : 	// if this effect is only drives other secondary effects, see if
; 2434 : 	// the count has reached 0, then kill it if so
; 2435 : 	if ( flags & SFX_SECONDARY_DRIVER ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 8
	je	SHORT $LN67@Exec

; 2436 : 		if ( secondaryCount <= 0 ){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 0
	jg	SHORT $LN68@Exec

; 2437 : 			return FALSE;

	xor	eax, eax
	jmp	$LN81@Exec

; 2438 : 		}
; 2439 : 		else {

	jmp	SHORT $LN67@Exec
$LN68@Exec:

; 2440 : 			Draw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Draw@SfxClass@@QAEHXZ			; SfxClass::Draw

; 2441 : 			return TRUE;

	mov	eax, 1
	jmp	$LN81@Exec
$LN67@Exec:

; 2442 : 		}
; 2443 : 	}
; 2444 : 
; 2445 : ///////////////////////////////////////
; 2446 : 	if (baseObj && flags & SFX_F16CRASHLANDING) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN66@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -2147483648			; 80000000H
	je	$LN66@Exec

; 2447 : 
; 2448 : 		Tpoint GroundNormal;
; 2449 : 	 	groundZ = OTWDriver.GetGroundLevel( pos.x, pos.y, &GroundNormal );

	lea	ecx, DWORD PTR _GroundNormal$25[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$[ebp]

; 2450 : 		if ( pos.z - groundZ > -5.0f) {

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR _groundZ$[ebp]
	comiss	xmm0, DWORD PTR __real@c0a00000
	jbe	SHORT $LN65@Exec

; 2451 : 			hitGround = TRUE;

	mov	DWORD PTR _hitGround$[ebp], 1

; 2452 : 			groundType = OTWDriver.GetGroundType (pos.x, pos.y);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundType@OTWDriverClass@@QAEHMM@Z	; OTWDriverClass::GetGroundType
	mov	DWORD PTR _groundType$[ebp], eax
$LN65@Exec:

; 2453 : 		}
; 2454 : 		int coverage = (groundType == COVERAGE_WATER) || (groundType == COVERAGE_RIVER);

	cmp	DWORD PTR _groundType$[ebp], 1
	je	SHORT $LN83@Exec
	cmp	DWORD PTR _groundType$[ebp], 2
	je	SHORT $LN83@Exec
	mov	DWORD PTR tv276[ebp], 0
	jmp	SHORT $LN84@Exec
$LN83@Exec:
	mov	DWORD PTR tv276[ebp], 1
$LN84@Exec:
	mov	ecx, DWORD PTR tv276[ebp]
	mov	DWORD PTR _coverage$10[ebp], ecx

; 2455 : 
; 2456 : 		int curtime = static_cast<int>(SIM_ELAPSED_SEC);

	cvttss2si edx, DWORD PTR ?SimLibElapsedSeconds@@3MA
	mov	DWORD PTR _curtime$2[ebp], edx

; 2457 : 		int lastHit = hitGround;

	mov	eax, DWORD PTR _hitGround$[ebp]
	mov	DWORD PTR _lastHit$17[ebp], eax

; 2458 : 		int CrashSoundMask = 0;

	mov	DWORD PTR _CrashSoundMask$23[ebp], 0

; 2459 : 
; 2460 : 		if (hitGround && coverage) {

	cmp	DWORD PTR _hitGround$[ebp], 0
	je	SHORT $LN64@Exec
	cmp	DWORD PTR _coverage$10[ebp], 0
	je	SHORT $LN64@Exec

; 2461 : 			flags &= ~SFX_F16CRASHLANDING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 2147483647				; 7fffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2462 : 			flags &= ~SFX_MOVES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx
	jmp	$LN52@Exec
$LN64@Exec:

; 2463 : 		}
; 2464 : 		else if (hitGround && !coverage) {

	cmp	DWORD PTR _hitGround$[ebp], 0
	je	$LN52@Exec
	cmp	DWORD PTR _coverage$10[ebp], 0
	jne	$LN52@Exec

; 2465 : 			hitGround = FALSE;

	mov	DWORD PTR _hitGround$[ebp], 0

; 2466 : 			float scale = 15.0f;

	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _scale$13[ebp], xmm0

; 2467 : 			float vecz = (float)fabs(vec.z) * 0.01f;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1881[ebp]
	movss	xmm0, DWORD PTR tv1881[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _vecz$15[ebp], xmm0

; 2468 : 			if (vecz < 10.0f) scale -= (10.0f - vecz);

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _vecz$15[ebp]
	jbe	SHORT $LN61@Exec
	movss	xmm0, DWORD PTR __real@41200000
	subss	xmm0, DWORD PTR _vecz$15[ebp]
	movss	xmm1, DWORD PTR _scale$13[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _scale$13[ebp], xmm1
$LN61@Exec:

; 2469 : 
; 2470 : /*
; 2471 : 			baseObj->SetYPRDelta(baseObj->YawDelta(),
; 2472 : 								baseObj->PitchDelta(),// * 0.75f,
; 2473 : 								baseObj->RollDelta());// * 0.75f);
; 2474 : */
; 2475 : 			vec.x *= 0.75f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@3f400000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 2476 : 			vec.y *= 0.75f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR __real@3f400000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 2477 : 			vec.z *= 0.25f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR __real@3e800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm0

; 2478 : 			if ( vec.z > GRAVITY ) vec.z = -vec.z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	comiss	xmm0, DWORD PTR __real@4200b53f
	jbe	SHORT $LN60@Exec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm0
$LN60@Exec:

; 2479 : 
; 2480 : 			if (!(flags & SFX_F16CRASH_HITGROUND)) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 536870912				; 20000000H
	jne	$LN59@Exec

; 2481 : 				int i = FloatToInt32 (9.99f * PRANDFloatPos());

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv1904[ebp]
	movss	xmm0, DWORD PTR tv1904[ebp]
	mulss	xmm0, DWORD PTR __real@411fd70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _i$21[ebp], eax

; 2482 : 				if (i < 5) i = SFX_BOOMA1 + i;

	cmp	DWORD PTR _i$21[ebp], 5
	jge	SHORT $LN58@Exec
	mov	ecx, DWORD PTR _i$21[ebp]
	add	ecx, 43					; 0000002bH
	mov	DWORD PTR _i$21[ebp], ecx
	jmp	SHORT $LN57@Exec
$LN58@Exec:

; 2483 : 				else i = SFX_BOOMG1 + i - 5;

	mov	edx, DWORD PTR _i$21[ebp]
	add	edx, 23					; 00000017H
	mov	DWORD PTR _i$21[ebp], edx
$LN57@Exec:

; 2484 : 				CrashSoundMask |= F16CRASH_BOOMMASK;

	mov	eax, DWORD PTR _CrashSoundMask$23[ebp]
	or	eax, 4
	mov	DWORD PTR _CrashSoundMask$23[ebp], eax

; 2485 : 				PlayCrashSound (F16CRASH_BOOMMASK, i);

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _i$21[ebp]
	push	ecx
	push	4
	call	?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z	; PlayCrashSound
	add	esp, 20					; 00000014H

; 2486 : 
; 2487 : 				flags |= SFX_F16CRASH_HITGROUND;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 536870912				; 20000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2488 : 				/*
; 2489 : 				OTWDriver.AddSfxRequest(
; 2490 : 						new SfxClass(SFX_GROUND_STRIKE_NOFIRE,	// type
; 2491 : 								&pos,							// world pos
; 2492 : 								4.0f,			// time to live
; 2493 : 								scale) );		// scale
; 2494 : 								*/
; 2495 : 				DrawableParticleSys::PS_AddParticleEx((SFX_GROUND_STRIKE + 1),
; 2496 : 									&pos,
; 2497 : 									&PSvec);

	lea	edx, DWORD PTR _PSvec$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	39					; 00000027H
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 2498 : 			}
; 2499 : 			else {

	jmp	$LN53@Exec
$LN59@Exec:

; 2500 : 				if (fabs( vec.x ) > 1.0f && 
; 2501 : 					fabs( vec.y ) > 1.0f &&
; 2502 : 					fabs( vec.z ) > 5.0f  ) {

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1923[ebp]
	movss	xmm0, DWORD PTR tv1923[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN53@Exec
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1930[ebp]
	movss	xmm0, DWORD PTR tv1930[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN53@Exec
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1937[ebp]
	movss	xmm0, DWORD PTR tv1937[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	SHORT $LN53@Exec

; 2503 : 
; 2504 : 					if (flags & SFX_F16CRASH_OBJECT) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN54@Exec

; 2505 : 						CrashSoundMask |= F16CRASH_BUMPMASK;

	mov	eax, DWORD PTR _CrashSoundMask$23[ebp]
	or	eax, 1
	mov	DWORD PTR _CrashSoundMask$23[ebp], eax

; 2506 : 						PlayCrashSound (F16CRASH_BUMPMASK, SFX_GROUND_CRUNCH);

	push	0
	push	0
	push	1
	push	178					; 000000b2H
	push	1
	call	?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z	; PlayCrashSound
	add	esp, 20					; 00000014H
$LN54@Exec:

; 2507 : 					}
; 2508 : 					/*
; 2509 : 					OTWDriver.AddSfxRequest(
; 2510 : 							new SfxClass(SFX_AAA_EXPLOSION,				// type
; 2511 : 							&pos,							// world pos
; 2512 : 							2.5f,			// time to live
; 2513 : 							scale) );		// scale
; 2514 : 							*/
; 2515 : 					//RV - I-Hawk - Chnaged type for more appropriate F-16 crash effect
; 2516 : 					if ( PRANDInt6() == 0  )

	call	?PRANDInt6@@YAHXZ			; PRANDInt6
	test	eax, eax
	jne	SHORT $LN53@Exec

; 2517 : 					{
; 2518 :                         DrawableParticleSys::PS_AddParticleEx((SFX_FLAMING_PART + 1),
; 2519 : 										&pos,
; 2520 : 										&PSvec);

	lea	ecx, DWORD PTR _PSvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	push	5
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH
$LN53@Exec:

; 2521 : 					}
; 2522 : 				}
; 2523 : 			}
; 2524 : 
; 2525 : 			if ((flags & SFX_MOVES) && !(flags & SFX_F16CRASH_STOP)) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	SHORT $LN52@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 268435456				; 10000000H
	jne	SHORT $LN52@Exec

; 2526 : 				flags |= SFX_F16CRASH_ADJUSTANGLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 134217728				; 08000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN52@Exec:

; 2527 : 			}
; 2528 : 		}
; 2529 : 
; 2530 : 
; 2531 : 		// lived long enough?
; 2532 : 		if ( curtime > timeToLive || hitGround ) {

	cvtsi2ss xmm0, DWORD PTR _curtime$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+100]
	ja	SHORT $LN50@Exec
	cmp	DWORD PTR _hitGround$[ebp], 0
	je	SHORT $LN51@Exec
$LN50@Exec:

; 2533 : 			RunSfxCompletion( hitGround, groundZ, groundType );

	mov	edx, DWORD PTR _groundType$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _groundZ$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hitGround$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunSfxCompletion@SfxClass@@IAEXHMH@Z	; SfxClass::RunSfxCompletion

; 2534 : 		// done with this effect
; 2535 : 			return FALSE;

	xor	eax, eax
	jmp	$LN81@Exec
$LN51@Exec:

; 2536 : 		}	
; 2537 : 
; 2538 : 		if (flags & SFX_F16CRASH_ADJUSTANGLE) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 134217728				; 08000000H
	je	$LN42@Exec

; 2539 : 			if ( pos.z - groundZ > -30.0f) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR _groundZ$[ebp]
	comiss	xmm0, DWORD PTR __real@c1f00000
	jbe	$LN48@Exec

; 2540 : 				float mat[3][3];
; 2541 : 				CalculateGroundMatrix (&GroundNormal, baseObj->Yaw(), mat);

	lea	ecx, DWORD PTR _mat$31[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _GroundNormal$25[ebp]
	push	edx
	call	?CalculateGroundMatrix@SfxClass@@KAXPAUTpoint@@MQAY02M@Z ; SfxClass::CalculateGroundMatrix
	add	esp, 12					; 0000000cH

; 2542 : 				float yaw, pitch, roll;
; 2543 : 				GetOrientation (mat, &yaw, &pitch, &roll);

	lea	eax, DWORD PTR _roll$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _pitch$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _yaw$20[ebp]
	push	edx
	lea	eax, DWORD PTR _mat$31[ebp]
	push	eax
	call	?GetOrientation@SfxClass@@KAXQAY02MPAM11@Z ; SfxClass::GetOrientation
	add	esp, 16					; 00000010H

; 2544 : 				float pitch1 = AdjustAngle180 (baseObj->Pitch());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	call	?AdjustAngle180@SfxClass@@KAMM@Z	; SfxClass::AdjustAngle180
	add	esp, 4
	fstp	DWORD PTR _pitch1$22[ebp]

; 2545 : 				if (pitch1 > PI/2) {

	movss	xmm0, DWORD PTR _pitch1$22[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fdb
	jbe	SHORT $LN47@Exec

; 2546 : 					pitch1 = PI - pitch1;

	movss	xmm0, DWORD PTR __real@40490fdb
	subss	xmm0, DWORD PTR _pitch1$22[ebp]
	movss	DWORD PTR _pitch1$22[ebp], xmm0

; 2547 : 					yaw += PI;

	movss	xmm0, DWORD PTR _yaw$20[ebp]
	addss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR _yaw$20[ebp], xmm0
	jmp	SHORT $LN45@Exec
$LN47@Exec:

; 2548 : 				}
; 2549 : 				else if (pitch1 < -PI/2) {

	movss	xmm0, DWORD PTR __real@bfc90fdb
	comiss	xmm0, DWORD PTR _pitch1$22[ebp]
	jbe	SHORT $LN45@Exec

; 2550 : 					pitch1 = -PI - pitch1;

	movss	xmm0, DWORD PTR __real@c0490fdb
	subss	xmm0, DWORD PTR _pitch1$22[ebp]
	movss	DWORD PTR _pitch1$22[ebp], xmm0

; 2551 : 					yaw += PI;

	movss	xmm0, DWORD PTR _yaw$20[ebp]
	addss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR _yaw$20[ebp], xmm0
$LN45@Exec:

; 2552 : 				}
; 2553 : 				float roll1 = baseObj->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR _roll1$8[ebp]

; 2554 : 				int stopit = RestPiece (&pitch1, pitch, 0.5f, 3.0f*DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d56774e
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pitch$9[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pitch1$22[ebp]
	push	ecx
	call	?RestPiece@SfxClass@@KAHPAMMMM@Z	; SfxClass::RestPiece
	add	esp, 16					; 00000010H
	mov	DWORD PTR _stopit$16[ebp], eax

; 2555 : 				stopit += (RestPiece (&roll1, roll, 0.5f, 3.0f*DTR) << 1);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d56774e
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _roll$11[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _roll1$8[ebp]
	push	edx
	call	?RestPiece@SfxClass@@KAHPAMMMM@Z	; SfxClass::RestPiece
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _stopit$16[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _stopit$16[ebp], edx

; 2556 : 				if (stopit == 3) {

	cmp	DWORD PTR _stopit$16[ebp], 3
	jne	SHORT $LN44@Exec

; 2557 : 					flags &= ~SFX_F16CRASH_ADJUSTANGLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -134217729				; f7ffffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 2558 : 					baseObj->SetYPR(yaw, pitch, roll);

	push	ecx
	movss	xmm0, DWORD PTR _roll$11[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pitch$9[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yaw$20[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR
	jmp	SHORT $LN43@Exec
$LN44@Exec:

; 2559 : 				}
; 2560 : 				else baseObj->SetYPR(yaw, pitch1, roll1);

	push	ecx
	movss	xmm0, DWORD PTR _roll1$8[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pitch1$22[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yaw$20[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR
$LN43@Exec:
	jmp	SHORT $LN42@Exec
$LN48@Exec:

; 2561 : 			}
; 2562 : 			else flags &= ~SFX_F16CRASH_ADJUSTANGLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -134217729				; f7ffffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN42@Exec:

; 2563 : 		}
; 2564 : 
; 2565 : 		// update position based on vector
; 2566 : 		if (flags & SFX_MOVES) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	$LN41@Exec

; 2567 : 			if ( fabs( vec.x ) < 2.0f && fabs( vec.y ) < 2.0f) {

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2038[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR tv2038[ebp]
	jbe	$LN40@Exec
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2046[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR tv2046[ebp]
	jbe	$LN40@Exec

; 2568 : 				baseObj->SetYPRDelta(
; 2569 : 								baseObj->YawDelta() * 0.95f,
; 2570 : 								baseObj->PitchDelta() * 0.9f,
; 2571 : 								baseObj->RollDelta() * 0.9f);//75f);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?RollDelta@VuEntity@@QBEMXZ		; VuEntity::RollDelta
	fstp	DWORD PTR tv2053[ebp]
	movss	xmm0, DWORD PTR tv2053[ebp]
	mulss	xmm0, DWORD PTR __real@3f666666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?PitchDelta@VuEntity@@QBEMXZ		; VuEntity::PitchDelta
	fstp	DWORD PTR tv2059[ebp]
	movss	xmm0, DWORD PTR tv2059[ebp]
	mulss	xmm0, DWORD PTR __real@3f666666
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	fstp	DWORD PTR tv2065[ebp]
	movss	xmm0, DWORD PTR tv2065[ebp]
	mulss	xmm0, DWORD PTR __real@3f733333
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta
$LN40@Exec:

; 2572 : 			}
; 2573 : 
; 2574 : 			if (!(flags & SFX_F16CRASH_STOP)) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 268435456				; 10000000H
	jne	$LN34@Exec

; 2575 : 				if (lastHit) {

	cmp	DWORD PTR _lastHit$17[ebp], 0
	je	$LN38@Exec

; 2576 : 					baseObj->SetYPR( 
; 2577 : 						baseObj->Yaw() + baseObj->YawDelta() * sfxFrameTime,
; 2578 : 						baseObj->Pitch(),
; 2579 : 						baseObj->Roll());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv2086[ebp]
	movss	xmm0, DWORD PTR tv2086[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2822[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	fstp	DWORD PTR tv2092[ebp]
	movss	xmm0, DWORD PTR tv2092[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2822[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 2580 : 
; 2581 : 					if ((flags & SFX_F16CRASH_OBJECT) && (fabs(baseObj->YawDelta()) > 20.0f*DTR )) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN37@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2111[ebp]
	movss	xmm0, DWORD PTR tv2111[ebp]
	comiss	xmm0, DWORD PTR __real@3eb2b8c1
	jbe	SHORT $LN37@Exec

; 2582 : 						CrashSoundMask |= F16CRASH_DRAGMASK;

	mov	edx, DWORD PTR _CrashSoundMask$23[ebp]
	or	edx, 8
	mov	DWORD PTR _CrashSoundMask$23[ebp], edx

; 2583 : 						PlayCrashSound (F16CRASH_DRAGMASK, SFX_TAILSCRAPE);

	push	0
	push	0
	push	1
	push	168					; 000000a8H
	push	8
	call	?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z	; PlayCrashSound
	add	esp, 20					; 00000014H
$LN37@Exec:

; 2584 : 					}
; 2585 : 				}
; 2586 : 				else {

	jmp	$LN34@Exec
$LN38@Exec:

; 2587 : 					if (flags & SFX_F16CRASH_ADJUSTANGLE) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 134217728				; 08000000H
	je	$LN35@Exec

; 2588 : 						baseObj->SetYPR( 
; 2589 : 							baseObj->Yaw() + baseObj->YawDelta() * sfxFrameTime,
; 2590 : 							baseObj->Pitch(),
; 2591 : 							baseObj->Roll());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv2128[ebp]
	movss	xmm0, DWORD PTR tv2128[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2824[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	fstp	DWORD PTR tv2134[ebp]
	movss	xmm0, DWORD PTR tv2134[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2824[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 2592 : 					}
; 2593 : 					else {

	jmp	$LN34@Exec
$LN35@Exec:

; 2594 : 						baseObj->SetYPR( 
; 2595 : 							baseObj->Yaw(),
; 2596 : 							baseObj->Pitch() + baseObj->PitchDelta() * sfxFrameTime,
; 2597 : 							baseObj->Roll() + baseObj->RollDelta() * sfxFrameTime);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv2147[ebp]
	movss	xmm0, DWORD PTR tv2147[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2826[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?RollDelta@VuEntity@@QBEMXZ		; VuEntity::RollDelta
	fstp	DWORD PTR tv2153[ebp]
	movss	xmm0, DWORD PTR tv2153[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2826[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv2159[ebp]
	movss	xmm0, DWORD PTR tv2159[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2828[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?PitchDelta@VuEntity@@QBEMXZ		; VuEntity::PitchDelta
	fstp	DWORD PTR tv2165[ebp]
	movss	xmm0, DWORD PTR tv2165[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2828[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR
$LN34@Exec:

; 2598 : 					}
; 2599 : 				}
; 2600 : 			}
; 2601 : 
; 2602 : 			vec.x *= 0.99f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@3f7d70a4
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 2603 : 			vec.y *= 0.99f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR __real@3f7d70a4
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 2604 : 			vec.z *= 0.99f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR __real@3f7d70a4
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm0

; 2605 : 			if (fabs(vec.x) < 1.0f && 
; 2606 : 				fabs(vec.y) < 1.0f && 
; 2607 : 				lastHit && 
; 2608 : 				!(flags & SFX_F16CRASH_ADJUSTANGLE) &&
; 2609 : 				fabs(baseObj->YawDelta()) < 15.0f * DTR && 
; 2610 : 				fabs(baseObj->PitchDelta()) < 15.0f * DTR && 
; 2611 : 				fabs(baseObj->RollDelta()) < 15.0f * DTR && 
; 2612 : 				fabs(vec.z) < 5.0f  ) {

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2191[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv2191[ebp]
	jbe	$LN33@Exec
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2199[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv2199[ebp]
	jbe	$LN33@Exec
	cmp	DWORD PTR _lastHit$17[ebp], 0
	je	$LN33@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 134217728				; 08000000H
	jne	$LN33@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2212[ebp]
	movss	xmm0, DWORD PTR __real@3e860a91
	comiss	xmm0, DWORD PTR tv2212[ebp]
	jbe	$LN33@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?PitchDelta@VuEntity@@QBEMXZ		; VuEntity::PitchDelta
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2223[ebp]
	movss	xmm0, DWORD PTR __real@3e860a91
	comiss	xmm0, DWORD PTR tv2223[ebp]
	jbe	$LN33@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?RollDelta@VuEntity@@QBEMXZ		; VuEntity::RollDelta
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2234[ebp]
	movss	xmm0, DWORD PTR __real@3e860a91
	comiss	xmm0, DWORD PTR tv2234[ebp]
	jbe	$LN33@Exec
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2242[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR tv2242[ebp]
	jbe	$LN33@Exec

; 2613 : 
; 2614 : 				flags |= SFX_F16CRASH_STOP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 268435456				; 10000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2615 : 				float pitch = baseObj->Pitch();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR _pitch$14[ebp]

; 2616 : 				int stopit = RestPiece (&pitch, RestPitch);

	push	ecx
	movss	xmm0, DWORD PTR __real@3ca3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pitch$14[ebp]
	push	edx
	call	?RestPiece@SfxClass@@KAHPAMMMM@Z	; SfxClass::RestPiece
	add	esp, 16					; 00000010H
	mov	DWORD PTR _stopit$18[ebp], eax

; 2617 : 				float roll = baseObj->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR _roll$7[ebp]

; 2618 : 				stopit += (RestPiece (&roll, RestRoll, 0.375f) << 1);

	push	ecx
	movss	xmm0, DWORD PTR __real@3ca3d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ec00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _roll$7[ebp]
	push	ecx
	call	?RestPiece@SfxClass@@KAHPAMMMM@Z	; SfxClass::RestPiece
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _stopit$18[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _stopit$18[ebp], eax

; 2619 : 				if (stopit == 3) {

	cmp	DWORD PTR _stopit$18[ebp], 3
	jne	SHORT $LN32@Exec

; 2620 : 					flags &= ~SFX_MOVES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2621 : 					flags &= ~SFX_F16CRASH_STOP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -268435457				; efffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2622 : 					vec.x = vec.y = vec.z = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+60], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+56], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+52], xmm0
$LN32@Exec:

; 2623 : 				}
; 2624 : 				baseObj->SetYPR (baseObj->Yaw(), pitch, roll);

	push	ecx
	movss	xmm0, DWORD PTR _roll$7[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pitch$14[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 2625 : 
; 2626 : 				if (flags & SFX_F16CRASH_OBJECT) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN31@Exec

; 2627 : 					CrashSoundMask |= F16CRASH_FELLMASK;

	mov	eax, DWORD PTR _CrashSoundMask$23[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _CrashSoundMask$23[ebp], eax

; 2628 : 					PlayCrashSound (F16CRASH_FELLMASK, SFX_FLAPLOOP);

	push	0
	push	0
	push	1
	push	144					; 00000090H
	push	16					; 00000010H
	call	?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z	; PlayCrashSound
	add	esp, 20					; 00000014H
$LN31@Exec:

; 2629 : 				}
; 2630 : 			}

	jmp	SHORT $LN29@Exec
$LN33@Exec:

; 2631 : 			else if (!lastHit && !(flags & SFX_F16CRASH_SKIPGRAVITY)) vec.z += GRAVITY * sfxFrameTime;

	cmp	DWORD PTR _lastHit$17[ebp], 0
	jne	SHORT $LN29@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 67108864				; 04000000H
	jne	SHORT $LN29@Exec
	movss	xmm0, DWORD PTR __real@4200b53f
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm0
$LN29@Exec:

; 2632 : 
; 2633 : 			CalcTransformMatrix(baseObj.get());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	call	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z ; CalcTransformMatrix
	add	esp, 4

; 2634 : 			Tpoint point;
; 2635 : 			TransformPoint (&point, &CrashSlot, baseObj -> dmx);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	add	eax, 296				; 00000128H
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR _point$28[ebp]
	push	eax
	call	?TransformPoint@SfxClass@@KAXPAUTpoint@@0QAY02M@Z ; SfxClass::TransformPoint
	add	esp, 12					; 0000000cH

; 2636 : 			point.x *= OTWDriver.Scale();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Scale@OTWDriverClass@@QAEMXZ		; OTWDriverClass::Scale
	fstp	DWORD PTR tv2316[ebp]
	movss	xmm0, DWORD PTR tv2316[ebp]
	mulss	xmm0, DWORD PTR _point$28[ebp]
	movss	DWORD PTR _point$28[ebp], xmm0

; 2637 : 			point.y *= OTWDriver.Scale();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Scale@OTWDriverClass@@QAEMXZ		; OTWDriverClass::Scale
	fstp	DWORD PTR tv2321[ebp]
	movss	xmm0, DWORD PTR tv2321[ebp]
	mulss	xmm0, DWORD PTR _point$28[ebp+4]
	movss	DWORD PTR _point$28[ebp+4], xmm0

; 2638 : 			point.z *= OTWDriver.Scale();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Scale@OTWDriverClass@@QAEMXZ		; OTWDriverClass::Scale
	fstp	DWORD PTR tv2326[ebp]
	movss	xmm0, DWORD PTR tv2326[ebp]
	mulss	xmm0, DWORD PTR _point$28[ebp+8]
	movss	DWORD PTR _point$28[ebp+8], xmm0

; 2639 : 			CrashPos.x += vec.x * sfxFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2640 : 			CrashPos.y += vec.y * sfxFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+24], xmm0

; 2641 : 			CrashPos.z += vec.z * sfxFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+28]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+28], xmm0

; 2642 : 			pos.x = CrashPos.x + point.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	addss	xmm0, DWORD PTR _point$28[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+40], xmm0

; 2643 : 			pos.y = CrashPos.y + point.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	addss	xmm0, DWORD PTR _point$28[ebp+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 2644 : 			pos.z = CrashPos.z + point.z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	addss	xmm0, DWORD PTR _point$28[ebp+8]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 2645 : 
; 2646 : 			float gZ = OTWDriver.GetGroundLevel( pos.x, pos.y);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _gZ$19[ebp]

; 2647 : 			if (pos.z > gZ) {

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	comiss	xmm0, DWORD PTR _gZ$19[ebp]
	jbe	$LN25@Exec

; 2648 : 				pos.z = gZ;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _gZ$19[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 2649 : 				if ( fabs( vec.x ) < 1.0f && fabs( vec.y ) < 1.0f && vec.z < GRAVITY) {

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2370[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv2370[ebp]
	jbe	SHORT $LN27@Exec
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2378[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv2378[ebp]
	jbe	SHORT $LN27@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4200b53f
	comiss	xmm0, DWORD PTR [ecx+60]
	jbe	SHORT $LN27@Exec

; 2650 : 					flags |= SFX_F16CRASH_SKIPGRAVITY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 67108864				; 04000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2651 : 					vec.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0
	jmp	SHORT $LN25@Exec
$LN27@Exec:

; 2652 : 				}
; 2653 : 				else if (vec.z > GRAVITY) vec.z = -vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@4200b53f
	jbe	SHORT $LN25@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+60], xmm0
$LN25@Exec:

; 2654 : 			}
; 2655 : 			gZ = OTWDriver.GetGroundLevel (CrashPos.x, CrashPos.y);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _gZ$19[ebp]

; 2656 : 			if (CrashPos.z > gZ) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	comiss	xmm0, DWORD PTR _gZ$19[ebp]
	jbe	SHORT $LN24@Exec

; 2657 : 				CrashPos.z = gZ;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _gZ$19[ebp]
	movss	DWORD PTR [eax+28], xmm0
$LN24@Exec:

; 2658 : 			}
; 2659 : 
; 2660 : 			baseObj->SetPosition (pos.x, pos.y, pos.z);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 2661 : 			baseObj->SetDelta (vec.x, vec.y, vec.z );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 2662 : 
; 2663 : /*
; 2664 : 			if (fabs( vec.x ) > 10.0f && 
; 2665 : 				fabs( vec.y ) > 10.0f && 
; 2666 : 				fabs( vec.z ) > 10.0f &&
; 2667 : 				curtime & 8) {
; 2668 : 					OTWDriver.AddSfxRequest(
; 2669 : 						new SfxClass(SFX_AAA_EXPLOSION,				// type
; 2670 : 						&pos,							// world pos
; 2671 : 						1.0f,			// time to live
; 2672 : 						5.0f) );		// scale
; 2673 : 
; 2674 : 				CrashSoundMask |= F16CRASH_FLOATMASK;
; 2675 : 				PlayCrashSound (F16CRASH_FLOATMASK, SFX_IMPACTG6);
; 2676 : 			}
; 2677 : */
; 2678 : 		}
; 2679 : 		else {

	jmp	$LN22@Exec
$LN41@Exec:

; 2680 : 			if (!(flags & SFX_F16CRASH_STOP)) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 268435456				; 10000000H
	jne	$LN22@Exec

; 2681 : 				flags |= SFX_F16CRASH_STOP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 268435456				; 10000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 2682 : 				float mat[3][3], mat1[3][3];
; 2683 : 				Tpoint normal;
; 2684 : 				CalculateRestingObjectMatrix (RestPitch, RestRoll, mat1);

	lea	eax, DWORD PTR _mat1$29[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	call	?CalculateRestingObjectMatrix@SfxClass@@KAXMMQAY02M@Z ; SfxClass::CalculateRestingObjectMatrix
	add	esp, 12					; 0000000cH

; 2685 : 				CalculateGroundMatrix (&normal, baseObj->Yaw(), mat);

	lea	eax, DWORD PTR _mat$30[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _normal$24[ebp]
	push	ecx
	call	?CalculateGroundMatrix@SfxClass@@KAXPAUTpoint@@MQAY02M@Z ; SfxClass::CalculateGroundMatrix
	add	esp, 12					; 0000000cH

; 2686 : 				MultiplyMatrix (baseObj->dmx, mat, mat1);

	lea	edx, DWORD PTR _mat1$29[ebp]
	push	edx
	lea	eax, DWORD PTR _mat$30[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	add	eax, 296				; 00000128H
	push	eax
	call	?MultiplyMatrix@SfxClass@@KAXQAY02M00@Z	; SfxClass::MultiplyMatrix
	add	esp, 12					; 0000000cH

; 2687 : 				float yaw, pitch, roll;
; 2688 : 				GetOrientation (baseObj->dmx, &yaw, &pitch, &roll);

	lea	ecx, DWORD PTR _roll$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _pitch$5[ebp]
	push	edx
	lea	eax, DWORD PTR _yaw$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	add	eax, 296				; 00000128H
	push	eax
	call	?GetOrientation@SfxClass@@KAXQAY02MPAM11@Z ; SfxClass::GetOrientation

; 2689 : 				baseObj->SetYPR(yaw, pitch, roll);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _roll$6[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _pitch$5[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yaw$4[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR
$LN22@Exec:

; 2690 : 			}
; 2691 : 		}
; 2692 : 		PlayCrashSound (CrashSoundMask, 0, 0, SimLibElapsedTime, &pos);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _CrashSoundMask$23[ebp]
	push	eax
	call	?PlayCrashSound@@YAXHHHHPAUTpoint@@@Z	; PlayCrashSound
	add	esp, 20					; 00000014H

; 2693 : 
; 2694 : 		if (flags & SFX_F16CRASH_OBJECT) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1073741824				; 40000000H
	je	$LN21@Exec

; 2695 : 			OTWDriver.SetOwnshipPosition (CrashPos.x, CrashPos.y, CrashPos.z);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+24]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetOwnshipPosition@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetOwnshipPosition

; 2696 : 			OTWDriver.SetEndFlightPoint(
; 2697 : 					CrashPos.x - baseObj->dmx[0][0] * 100.0f,
; 2698 : 					CrashPos.y - baseObj->dmx[0][1] * 100.0f,
; 2699 : 					CrashPos.z - baseObj->dmx[0][2] * 100.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+28]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+24]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+20]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightPoint

; 2700 : 			OTWDriver.SetEndFlightVec(
; 2701 : 					-baseObj->dmx[0][0],
; 2702 : 					-baseObj->dmx[0][1],
; 2703 : 					-baseObj->dmx[0][2] );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ; OTWDriverClass::SetEndFlightVec
$LN21@Exec:

; 2704 : 		}
; 2705 : 
; 2706 : 		Trotation objrot;
; 2707 : 		objrot.M11 = baseObj->dmx[0][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp], xmm0

; 2708 : 		objrot.M21 = baseObj->dmx[0][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+12], xmm0

; 2709 : 		objrot.M31 = baseObj->dmx[0][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+24], xmm0

; 2710 : 		objrot.M12 = baseObj->dmx[1][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+4], xmm0

; 2711 : 		objrot.M22 = baseObj->dmx[1][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+16], xmm0

; 2712 : 		objrot.M32 = baseObj->dmx[1][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+28], xmm0

; 2713 : 		objrot.M13 = baseObj->dmx[2][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+8], xmm0

; 2714 : 		objrot.M23 = baseObj->dmx[2][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+20], xmm0

; 2715 : 		objrot.M33 = baseObj->dmx[2][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [eax+edx+296]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _objrot$26[ebp+32], xmm0

; 2716 : 		Tpoint objpos;
; 2717 : 		objpos.x = baseObj->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _objpos$27[ebp]

; 2718 : 		objpos.y = baseObj->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _objpos$27[ebp+4]

; 2719 : 		objpos.z = baseObj->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _objpos$27[ebp+8]

; 2720 : 		((DrawableBSP*)(baseObj->drawPointer))->Update(&objpos, &objrot);

	lea	edx, DWORD PTR _objrot$26[ebp]
	push	edx
	lea	eax, DWORD PTR _objpos$27[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?Update@DrawableBSP@@QAEXPBUTpoint@@PBUTrotation@@@Z ; DrawableBSP::Update

; 2721 : 		baseObj->drawPointer->SetScale(OTWDriver.Scale());

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?Scale@OTWDriverClass@@QAEMXZ		; OTWDriverClass::Scale
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?SetScale@DrawableObject@@QAEXM@Z	; DrawableObject::SetScale

; 2722 : 		return TRUE;

	mov	eax, 1
	jmp	$LN81@Exec
$LN66@Exec:

; 2723 : 	}
; 2724 : ///////////////////////////////////////
; 2725 : 
; 2726 : 
; 2727 : 	// check for hit with ground
; 2728 : 	if ( (flags & SFX_MOVES) && !(flags & SFX_NO_GROUND_CHECK) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	je	$LN18@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 16					; 00000010H
	jne	$LN18@Exec

; 2729 : 	{
; 2730 : 		// 1st get approximation
; 2731 : 		groundZ = OTWDriver.GetApproxGroundLevel (pos.x, pos.y);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR _groundZ$[ebp]

; 2732 : 		if (  pos.z - groundZ  > -100.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR _groundZ$[ebp]
	comiss	xmm0, DWORD PTR __real@c2c80000
	jbe	$LN18@Exec

; 2733 : 		{
; 2734 : 		 	groundZ = OTWDriver.GetGroundLevel( pos.x, pos.y);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$[ebp]

; 2735 : 			if ( pos.z >= groundZ )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	comiss	xmm0, DWORD PTR _groundZ$[ebp]
	jb	SHORT $LN18@Exec

; 2736 : 			{
; 2737 : 				hitGround = TRUE;

	mov	DWORD PTR _hitGround$[ebp], 1

; 2738 : 				groundType = OTWDriver.GetGroundType (pos.x, pos.y);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundType@OTWDriverClass@@QAEHMM@Z	; OTWDriverClass::GetGroundType
	mov	DWORD PTR _groundType$[ebp], eax
$LN18@Exec:

; 2739 : 			}
; 2740 : 		}
; 2741 : 	}
; 2742 : 
; 2743 : 	int coverage = (groundType == COVERAGE_WATER) || (groundType == COVERAGE_RIVER);

	cmp	DWORD PTR _groundType$[ebp], 1
	je	SHORT $LN85@Exec
	cmp	DWORD PTR _groundType$[ebp], 2
	je	SHORT $LN85@Exec
	mov	DWORD PTR tv1387[ebp], 0
	jmp	SHORT $LN86@Exec
$LN85@Exec:
	mov	DWORD PTR tv1387[ebp], 1
$LN86@Exec:
	mov	ecx, DWORD PTR tv1387[ebp]
	mov	DWORD PTR _coverage$[ebp], ecx

; 2744 : 
; 2745 : 	// does this object bounce?
; 2746 : 	if ( hitGround && (flags & (SFX_BOUNCES | SFX_BOUNCES_HARD) ) && !coverage)

	cmp	DWORD PTR _hitGround$[ebp], 0
	je	$LN13@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 96					; 00000060H
	je	$LN13@Exec
	cmp	DWORD PTR _coverage$[ebp], 0
	jne	$LN13@Exec

; 2747 : 	{
; 2748 : 		// calcuate the new movement vector
; 2749 : 		GroundReflection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GroundReflection@SfxClass@@IAEXXZ	; SfxClass::GroundReflection

; 2750 : 		pos.z = groundZ - 4.0f;

	movss	xmm0, DWORD PTR _groundZ$[ebp]
	subss	xmm0, DWORD PTR __real@40800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 2751 : 		// momentum loss
; 2752 : 		if ( flags & SFX_BOUNCES )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 32					; 00000020H
	je	SHORT $LN16@Exec

; 2753 : 		{
; 2754 : 			vec.x *= 0.30f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 2755 : 			vec.y *= 0.30f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 2756 : 			vec.z *= 0.30f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 2757 : 		}
; 2758 : 		else

	jmp	SHORT $LN15@Exec
$LN16@Exec:

; 2759 : 		{
; 2760 : 			vec.x *= 0.80f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 2761 : 			vec.y *= 0.80f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 2762 : 			vec.z *= 0.80f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+60], xmm0
$LN15@Exec:

; 2763 : 		}
; 2764 : 		if ( fabs( vec.x ) < 10.0f && fabs( vec.y ) < 10.0f && fabs( vec.z ) < 10.0f  )

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2649[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR tv2649[ebp]
	jbe	SHORT $LN14@Exec
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2657[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR tv2657[ebp]
	jbe	SHORT $LN14@Exec
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2665[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR tv2665[ebp]
	jbe	SHORT $LN14@Exec

; 2765 : 		{
; 2766 : 			flags &= ~SFX_MOVES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN14@Exec:

; 2767 : 		}
; 2768 : 
; 2769 : 		hitGround = FALSE;

	mov	DWORD PTR _hitGround$[ebp], 0

; 2770 : 		if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@Exec

; 2771 : 			baseObj->SetYPRDelta( 0.0f, 0.0f, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta
$LN13@Exec:

; 2772 : 	}
; 2773 : 
; 2774 : 
; 2775 : 	// lived long enough?
; 2776 : 	if ( SIM_ELAPSED_SEC > timeToLive || hitGround )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	comiss	xmm0, DWORD PTR [edx+100]
	ja	SHORT $LN11@Exec
	cmp	DWORD PTR _hitGround$[ebp], 0
	je	SHORT $LN12@Exec
$LN11@Exec:

; 2777 : 	{
; 2778 : 		RunSfxCompletion( hitGround, groundZ, groundType );

	mov	eax, DWORD PTR _groundType$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _groundZ$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _hitGround$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunSfxCompletion@SfxClass@@IAEXHMH@Z	; SfxClass::RunSfxCompletion

; 2779 : 
; 2780 : 		// done with this effect
; 2781 : 		return FALSE;

	xor	eax, eax
	jmp	$LN81@Exec
$LN12@Exec:

; 2782 : 
; 2783 : 	}
; 2784 : 
; 2785 : 	// if it's fire, play sound
; 2786 : 	if ( type == SFX_FIRE )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 37			; 00000025H
	jne	SHORT $LN10@Exec

; 2787 : 	{
; 2788 : 		F4SoundFXSetPos( SFX_FIRELOOP, TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	105					; 00000069H
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H
$LN10@Exec:

; 2789 : 	}
; 2790 : 
; 2791 : 	// do we need to move it?
; 2792 : 	if ( !(flags & SFX_MOVES) || (flags & SFX_TIMER_FLAG) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	SHORT $LN8@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 256				; 00000100H
	je	SHORT $LN9@Exec
$LN8@Exec:

; 2793 : 	{
; 2794 : 		Draw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Draw@SfxClass@@QAEHXZ			; SfxClass::Draw

; 2795 : 	    return TRUE;

	mov	eax, 1
	jmp	$LN81@Exec
$LN9@Exec:

; 2796 : 	}
; 2797 : 
; 2798 : 	if ( flags & SFX_USES_GRAVITY )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 2
	je	$LN7@Exec

; 2799 : 	{
; 2800 : 		// gravity also assumes air friction
; 2801 : 		vec.x *= 0.999F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR __real@3f7fbe77
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 2802 : 		vec.y *= 0.999F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR __real@3f7fbe77
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 2803 : 		if (vec.z > 500.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	comiss	xmm0, DWORD PTR __real@43fa0000
	jbe	SHORT $LN6@Exec

; 2804 : 			vec.z *= 0.999F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3f7fbe77
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 2805 : 		else

	jmp	SHORT $LN5@Exec
$LN6@Exec:

; 2806 : 			vec.z += GRAVITY * sfxFrameTime;

	movss	xmm0, DWORD PTR __real@4200b53f
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+60], xmm0
$LN5@Exec:
	jmp	SHORT $LN3@Exec
$LN7@Exec:

; 2807 : 
; 2808 : 	}
; 2809 : 	else if ( flags & SFX_TRAJECTORY )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 512				; 00000200H
	je	SHORT $LN3@Exec

; 2810 : 	{
; 2811 : 		// trajectory has no air friction
; 2812 : 		vec.z += GRAVITY * sfxFrameTime;

	movss	xmm0, DWORD PTR __real@4200b53f
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+60], xmm0
$LN3@Exec:

; 2813 : 	}
; 2814 : 
; 2815 : 	if ( (flags & SFX_NO_DOWN_VECTOR ) && vec.z > 0.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 128				; 00000080H
	je	SHORT $LN2@Exec
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@Exec

; 2816 : 	{
; 2817 : 		vec.z = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+60], xmm0
$LN2@Exec:

; 2818 : 	}
; 2819 : 
; 2820 : 	// update position based on vector
; 2821 : 	pos.x += vec.x * sfxFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+40], xmm0

; 2822 : 	pos.y += vec.y * sfxFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 2823 : 	pos.z += vec.z * sfxFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 2824 : 
; 2825 : 	if ( baseObj )		// for bsp objects

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	$LN1@Exec

; 2826 : 	{
; 2827 : 		baseObj->SetPosition (pos.x, pos.y, pos.z );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 2828 : 		baseObj->SetDelta (vec.x, vec.y, vec.z );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 2829 : 		baseObj->SetYPR(
; 2830 : 				baseObj->Yaw() + baseObj->YawDelta() * sfxFrameTime,
; 2831 : 				baseObj->Pitch() + baseObj->PitchDelta() * sfxFrameTime,
; 2832 : 				baseObj->Roll() + baseObj->RollDelta() * sfxFrameTime);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv2779[ebp]
	movss	xmm0, DWORD PTR tv2779[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2830[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?RollDelta@VuEntity@@QBEMXZ		; VuEntity::RollDelta
	fstp	DWORD PTR tv2785[ebp]
	movss	xmm0, DWORD PTR tv2785[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2830[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv2791[ebp]
	movss	xmm0, DWORD PTR tv2791[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2832[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?PitchDelta@VuEntity@@QBEMXZ		; VuEntity::PitchDelta
	fstp	DWORD PTR tv2797[ebp]
	movss	xmm0, DWORD PTR tv2797[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2832[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv2803[ebp]
	movss	xmm0, DWORD PTR tv2803[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	movss	DWORD PTR tv2834[ebp], xmm0
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YawDelta@VuEntity@@QBEMXZ		; VuEntity::YawDelta
	fstp	DWORD PTR tv2809[ebp]
	movss	xmm0, DWORD PTR tv2809[ebp]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	movss	xmm1, DWORD PTR tv2834[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 2833 : 		CalcTransformMatrix(baseObj.get());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	call	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z ; CalcTransformMatrix
	add	esp, 4
$LN1@Exec:

; 2834 : 	}
; 2835 : 
; 2836 : 	Draw();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Draw@SfxClass@@QAEHXZ			; SfxClass::Draw

; 2837 : 	return TRUE;

	mov	eax, 1
$LN81@Exec:

; 2838 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?Exec@SfxClass@@QAEHXZ ENDP				; SfxClass::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv380 = -48						; size = 8
tv356 = -40						; size = 8
_distScale$1 = -32					; size = 4
tv270 = -28						; size = 4
tv376 = -24						; size = 4
tv352 = -20						; size = 4
tv75 = -16						; size = 4
_sinAng$ = -12						; size = 4
_cosAng$ = -8						; size = 4
_this$ = -4						; size = 4
?Start@SfxClass@@QAEXXZ PROC				; SfxClass::Start
; _this$ = ecx

; 2066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2067 : 	float sinAng, cosAng;
; 2068 : 
; 2069 : 	// if it's got a trajectory, we need to recalc
; 2070 : 	if ( flags & SFX_TRAJECTORY )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 512				; 00000200H
	je	$LN16@Start

; 2071 : 	{
; 2072 : 		timeToLive = min( timeToLive * 2.0f, MAX_TIME_TO_LIVE );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@4346e65c
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@Start
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN20@Start
$LN19@Start:
	movss	xmm0, DWORD PTR __real@4346e65c
	movss	DWORD PTR tv75[ebp], xmm0
$LN20@Start:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 2073 : 
; 2074 : 		sinAng = GRAVITY * 0.5f * timeToLive / TRACER_VELOCITY;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4180b53f
	mulss	xmm0, DWORD PTR [edx+100]
	divss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _sinAng$[ebp], xmm0

; 2075 : 		cosAng = (float)sqrt( 1.0f - sinAng * sinAng );

	movss	xmm0, DWORD PTR _sinAng$[ebp]
	mulss	xmm0, DWORD PTR _sinAng$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _cosAng$[ebp]

; 2076 : 		vec.x *= cosAng;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR _cosAng$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 2077 : 		vec.y *= cosAng;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR _cosAng$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 2078 : 		vec.z =  vec.z * cosAng - TRACER_VELOCITY * sinAng;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	mulss	xmm0, DWORD PTR _cosAng$[ebp]
	movss	xmm1, DWORD PTR __real@457a0000
	mulss	xmm1, DWORD PTR _sinAng$[ebp]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+60], xmm0
$LN16@Start:

; 2079 : 	}
; 2080 : 
; 2081 : 	// check acmi recording
; 2082 : 	if ( gACMIRec.IsRecording() )

	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?IsRecording@ACMIRecorder@@QAEHXZ	; ACMIRecorder::IsRecording
	test	eax, eax
	je	$LN12@Start

; 2083 : 	{
; 2084 : 		// stationary sfx have no flags
; 2085 : 		if ( flags == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	$LN14@Start

; 2086 : 		{
; 2087 : 			acmiStatSfx.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv352[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv352[ebp]
	mov	edx, DWORD PTR tv352[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv356[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv356[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+1, xmm0

; 2088 : 			acmiStatSfx.data.type = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+5, ecx

; 2089 : 			acmiStatSfx.data.x = pos.x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+9, xmm0

; 2090 : 			acmiStatSfx.data.y = pos.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+13, xmm0

; 2091 : 			acmiStatSfx.data.z = pos.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+17, xmm0

; 2092 : 			acmiStatSfx.data.timeToLive = timeToLive;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	movss	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+21, xmm0

; 2093 : 			acmiStatSfx.data.scale = scale;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR ?acmiStatSfx@@3UACMIStationarySfxRecord@@A+25, xmm0

; 2094 : 			gACMIRec.StationarySfxRecord( &acmiStatSfx );

	push	OFFSET ?acmiStatSfx@@3UACMIStationarySfxRecord@@A ; acmiStatSfx
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z ; ACMIRecorder::StationarySfxRecord
	jmp	$LN12@Start
$LN14@Start:

; 2095 : 		}
; 2096 : 		else if ( flags & SFX_MOVES || type == SFX_BURNING_PART )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	jne	SHORT $LN11@Start
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 66			; 00000042H
	jne	$LN12@Start
$LN11@Start:

; 2097 : 		{
; 2098 : 			acmiMoveSfx.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv376[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv376[ebp]
	mov	edx, DWORD PTR tv376[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv380[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv380[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+1, xmm0

; 2099 : 			acmiMoveSfx.data.type = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+5, ecx

; 2100 : 			acmiMoveSfx.data.flags = flags;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+13, eax

; 2101 : 			acmiMoveSfx.data.user = -1;

	mov	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+9, -1

; 2102 : 			acmiMoveSfx.data.x = pos.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+17, xmm0

; 2103 : 			acmiMoveSfx.data.y = pos.y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+21, xmm0

; 2104 : 			acmiMoveSfx.data.z = pos.z;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+25, xmm0

; 2105 : 			acmiMoveSfx.data.dx = vec.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+29, xmm0

; 2106 : 			acmiMoveSfx.data.dy = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+33, xmm0

; 2107 : 			acmiMoveSfx.data.dz = vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+37, xmm0

; 2108 : 			acmiMoveSfx.data.timeToLive = timeToLive;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+41, xmm0

; 2109 : 			acmiMoveSfx.data.scale = scale;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+45, xmm0

; 2110 : 			// if we've got a base obj, store it's vistype in user for
; 2111 : 			// later reconstruction
; 2112 : 			if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@Start

; 2113 : 			{
; 2114 : 				acmiMoveSfx.data.user = ((DrawableBSP *)baseObj->drawPointer)->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?GetID@DrawableBSP@@QAEHXZ		; DrawableBSP::GetID
	mov	DWORD PTR ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A+9, eax
$LN10@Start:

; 2115 : 			}
; 2116 : 			gACMIRec.MovingSfxRecord( &acmiMoveSfx );

	push	OFFSET ?acmiMoveSfx@@3UACMIMovingSfxRecord@@A ; acmiMoveSfx
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?MovingSfxRecord@ACMIRecorder@@QAEXPAUACMIMovingSfxRecord@@@Z ; ACMIRecorder::MovingSfxRecord
$LN12@Start:

; 2117 : 		}
; 2118 : 	}
; 2119 : 
; 2120 : 	// set the time it will die
; 2121 : 	timeToLive += SIM_ELAPSED_SEC;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	addss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+100], xmm0

; 2122 : 
; 2123 : 	// get the approximate distance to the viewer
; 2124 : 	GetApproxViewDist( (float)SIM_ELAPSED_SEC );

	push	ecx
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetApproxViewDist@SfxClass@@IAEXM@Z	; SfxClass::GetApproxViewDist

; 2125 : 
; 2126 : 	// timers don't get added to draw list
; 2127 : 	if ( flags & SFX_TIMER_FLAG )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 256				; 00000100H
	je	SHORT $LN9@Start

; 2128 : 		return;

	jmp	$LN17@Start
$LN9@Start:

; 2129 : 
; 2130 : 	// insert the effect's object into the display list
; 2131 : 	if ( objParticleSys ) // MLR 2/3/2004 - 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+168], 0
	je	SHORT $LN8@Start

; 2132 : 	{
; 2133 : 		OTWDriver.InsertObject(objParticleSys);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN8@Start:

; 2134 : 	}
; 2135 : 	if ( obj2d )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN7@Start

; 2136 : 	{
; 2137 : 		OTWDriver.InsertObject(obj2d);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN7@Start:

; 2138 : 	}
; 2139 : 	if ( objBSP )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+160], 0
	je	SHORT $LN6@Start

; 2140 : 	{
; 2141 : 		OTWDriver.InsertObject(objBSP);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN6@Start:

; 2142 : 	}
; 2143 : 	if ( objTrail )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	$LN5@Start

; 2144 : 	{
; 2145 : 		// a hack -- scale trail of missile launch based on dist
; 2146 : 		if ( type == SFX_MISSILE_LAUNCH )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 21			; 00000015H
	jne	SHORT $LN4@Start

; 2147 : 		{
; 2148 : 			float distScale = max( 0.1f, approxDist/10000.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@461c4000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN21@Start
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv270[ebp], xmm0
	jmp	SHORT $LN22@Start
$LN21@Start:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+132]
	divss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR tv270[ebp], xmm0
$LN22@Start:
	movss	xmm0, DWORD PTR tv270[ebp]
	movss	DWORD PTR _distScale$1[ebp], xmm0

; 2149 : 			objTrail->SetScale( distScale );

	push	ecx
	movss	xmm0, DWORD PTR _distScale$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	call	?SetScale@DrawableObject@@QAEXM@Z	; DrawableObject::SetScale
$LN4@Start:

; 2150 : 		}
; 2151 : 		OTWDriver.InsertObject(objTrail);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject

; 2152 : 
; 2153 : 		// put in the 1st point at starting position
; 2154 : 		OTWDriver.AddTrailHead (objTrail, pos.x, pos.y, pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddTrailHead@OTWDriverClass@@QAEXPAVDrawableTrail@@MMM@Z ; OTWDriverClass::AddTrailHead
$LN5@Start:

; 2155 : 	}
; 2156 : 	if ( objTracer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 0
	je	SHORT $LN3@Start

; 2157 : 	{
; 2158 : 		OTWDriver.InsertObject(objTracer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN3@Start:

; 2159 : 	}
; 2160 : 	if ( baseObj)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@Start

; 2161 : 	{ 
; 2162 : 		if ( type != SFX_SMOKING_FEATURE && type != SFX_STEAMING_FEATURE ) // MLR 12/20/2003 - added

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 100			; 00000064H
	je	SHORT $LN1@Start
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 101			; 00000065H
	je	SHORT $LN1@Start

; 2163 : 		{
; 2164 : 			OTWDriver.InsertObject(baseObj->drawPointer);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, DWORD PTR [eax+332]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?InsertObject@OTWDriverClass@@QAEXPAVDrawableObject@@@Z ; OTWDriverClass::InsertObject
$LN1@Start:
$LN17@Start:

; 2165 : 		}
; 2166 : 	}
; 2167 : 
; 2168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Start@SfxClass@@QAEXXZ ENDP				; SfxClass::Start
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv358 = -100						; size = 4
$T2 = -96						; size = 4
tv328 = -92						; size = 4
$T3 = -88						; size = 4
tv298 = -84						; size = 4
$T4 = -80						; size = 4
tv268 = -76						; size = 4
$T5 = -72						; size = 4
tv238 = -68						; size = 4
$T6 = -64						; size = 4
tv207 = -60						; size = 4
$T7 = -56						; size = 4
tv192 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
$T10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
$T13 = -28						; size = 4
$T14 = -24						; size = 4
$T15 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SfxClass@@QAE@XZ PROC				; SfxClass::~SfxClass
; _this$ = ecx

; 1938 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SfxClass@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1939 : 	if ( inACMI == FALSE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+188], 0
	jne	$LN23@SfxClass

; 1940 : 	{
; 1941 : 		if ( objParticleSys)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+168], 0
	je	SHORT $LN22@SfxClass

; 1942 : 		{
; 1943 : 			OTWDriver.RemoveObject(objParticleSys, TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+168]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject
$LN22@SfxClass:

; 1944 : 		}
; 1945 : 		if ( obj2d )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+152], 0
	je	SHORT $LN21@SfxClass

; 1946 : 		{
; 1947 : 			OTWDriver.RemoveObject(obj2d, TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject
$LN21@SfxClass:

; 1948 : 		}
; 1949 : 	
; 1950 : 		if ( objBSP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+160], 0
	je	SHORT $LN20@SfxClass

; 1951 : 		{
; 1952 : 			OTWDriver.RemoveObject(objBSP, TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject
$LN20@SfxClass:

; 1953 : 		}
; 1954 : 	
; 1955 : 		// Smoketrails are removed
; 1956 : 		// by a timer special effect.
; 1957 : 		if ( objTrail )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+156], 0
	je	SHORT $LN19@SfxClass

; 1958 : 		{
; 1959 : 			OTWDriver.RemoveObject(objTrail, TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 1960 : 			objTrail = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 0
$LN19@SfxClass:

; 1961 : 		}
; 1962 : 	
; 1963 : 		if ( objTracer )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 0
	je	SHORT $LN18@SfxClass

; 1964 : 		{
; 1965 : 			OTWDriver.RemoveObject(objTracer, TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject
$LN18@SfxClass:

; 1966 : 		}
; 1967 : 	
; 1968 : 		if ( baseObj ){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@SfxClass

; 1969 :    			if ( type != SFX_SMOKING_FEATURE && type != SFX_STEAMING_FEATURE ){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 100			; 00000064H
	je	SHORT $LN16@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 101			; 00000065H
	je	SHORT $LN16@SfxClass

; 1970 : 				if (baseObj->drawPointer){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN16@SfxClass

; 1971 : 					OTWDriver.RemoveObject(baseObj->drawPointer, TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, DWORD PTR [eax+332]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?RemoveObject@OTWDriverClass@@QAEXPAVDrawableObject@@H@Z ; OTWDriverClass::RemoveObject

; 1972 : 					baseObj->drawPointer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR [eax+332], 0
$LN16@SfxClass:

; 1973 : 				}
; 1974 : 				// delete the object
; 1975 : 				//delete baseObj;
; 1976 : 			}
; 1977 : 			//else {
; 1978 : 			//	VuDeReferenceEntity( baseObj );
; 1979 : 			//}
; 1980 : 			baseObj.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::reset
$LN17@SfxClass:

; 1981 : 		}
; 1982 : 
; 1983 : 		if ( endMessage )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN14@SfxClass

; 1984 : 		{
; 1985 : 			delete endMessage;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T8[ebp], edx
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T15[ebp], eax
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN26@SfxClass
	push	1
	mov	ecx, DWORD PTR $T15[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T15[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv192[ebp], eax
	jmp	SHORT $LN27@SfxClass
$LN26@SfxClass:
	mov	DWORD PTR tv192[ebp], 0
$LN27@SfxClass:

; 1986 : 			endMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0
$LN14@SfxClass:

; 1987 : 		}
; 1988 : 
; 1989 : 		if ( damMessage )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+148], 0
	je	SHORT $LN13@SfxClass

; 1990 : 		{
; 1991 : 			delete damMessage;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T14[ebp], edx
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN28@SfxClass
	push	1
	mov	eax, DWORD PTR $T14[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T14[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN29@SfxClass
$LN28@SfxClass:
	mov	DWORD PTR tv207[ebp], 0
$LN29@SfxClass:

; 1992 : 			damMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0
$LN13@SfxClass:

; 1993 : 		}
; 1994 : 	}
; 1995 : 	// destruction when running from ACMI
; 1996 : 	else

	jmp	$LN12@SfxClass
$LN23@SfxClass:

; 1997 : 	{
; 1998 : 		if ( obj2d )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN11@SfxClass

; 1999 : 		{
; 2000 : 			if ( obj2d->InDisplayList() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?InDisplayList@DrawableObject@@QAEHXZ	; DrawableObject::InDisplayList
	test	eax, eax
	je	SHORT $LN10@SfxClass

; 2001 : 			{
; 2002 : 				viewPoint->RemoveObject( obj2d );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	call	?RemoveObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::RemoveObject
$LN10@SfxClass:

; 2003 : 			}
; 2004 : 			delete obj2d;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR $T6[ebp], edx
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T13[ebp], eax
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN30@SfxClass
	push	1
	mov	ecx, DWORD PTR $T13[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T13[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv238[ebp], eax
	jmp	SHORT $LN11@SfxClass
$LN30@SfxClass:
	mov	DWORD PTR tv238[ebp], 0
$LN11@SfxClass:

; 2005 : 		}
; 2006 : 	
; 2007 : 		if ( objBSP )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+160], 0
	je	SHORT $LN9@SfxClass

; 2008 : 		{
; 2009 : 			if ( objBSP->InDisplayList() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?InDisplayList@DrawableObject@@QAEHXZ	; DrawableObject::InDisplayList
	test	eax, eax
	je	SHORT $LN8@SfxClass

; 2010 : 			{
; 2011 : 				viewPoint->RemoveObject( objBSP );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+184]
	call	?RemoveObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::RemoveObject
$LN8@SfxClass:

; 2012 : 			}
; 2013 : 			delete objBSP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T12[ebp], edx
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN32@SfxClass
	push	1
	mov	eax, DWORD PTR $T12[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv268[ebp], eax
	jmp	SHORT $LN9@SfxClass
$LN32@SfxClass:
	mov	DWORD PTR tv268[ebp], 0
$LN9@SfxClass:

; 2014 : 		}
; 2015 : 	
; 2016 : 		if ( objTrail )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+156], 0
	je	SHORT $LN7@SfxClass

; 2017 : 		{
; 2018 : 			if ( objTrail->InDisplayList() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+156]
	call	?InDisplayList@DrawableObject@@QAEHXZ	; DrawableObject::InDisplayList
	test	eax, eax
	je	SHORT $LN6@SfxClass

; 2019 : 			{
; 2020 : 				viewPoint->RemoveObject( objTrail );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+184]
	call	?RemoveObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::RemoveObject
$LN6@SfxClass:

; 2021 : 			}
; 2022 : 			delete objTrail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T11[ebp], edx
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN34@SfxClass
	push	1
	mov	eax, DWORD PTR $T11[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T11[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN7@SfxClass
$LN34@SfxClass:
	mov	DWORD PTR tv298[ebp], 0
$LN7@SfxClass:

; 2023 : 		}
; 2024 : 	
; 2025 : 		if ( objTracer )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+164], 0
	je	SHORT $LN5@SfxClass

; 2026 : 		{
; 2027 : 			if ( objTracer->InDisplayList() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+164]
	call	?InDisplayList@DrawableObject@@QAEHXZ	; DrawableObject::InDisplayList
	test	eax, eax
	je	SHORT $LN4@SfxClass

; 2028 : 			{
; 2029 : 				viewPoint->RemoveObject( objTracer );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+184]
	call	?RemoveObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::RemoveObject
$LN4@SfxClass:

; 2030 : 			}
; 2031 : 			delete objTracer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T10[ebp], edx
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN36@SfxClass
	push	1
	mov	eax, DWORD PTR $T10[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T10[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv328[ebp], eax
	jmp	SHORT $LN5@SfxClass
$LN36@SfxClass:
	mov	DWORD PTR tv328[ebp], 0
$LN5@SfxClass:

; 2032 : 		}
; 2033 : 	
; 2034 : 		if ( baseObj )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??B?$VuBin@VSimBaseClass@@@@QBE_NXZ	; VuBin<SimBaseClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@SfxClass

; 2035 : 		{
; 2036 : 			if ( baseObj->drawPointer->InDisplayList() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	call	?InDisplayList@DrawableObject@@QAEHXZ	; DrawableObject::InDisplayList
	test	eax, eax
	je	SHORT $LN2@SfxClass

; 2037 : 			{
; 2038 : 				viewPoint->RemoveObject( baseObj->drawPointer );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	edx, DWORD PTR [eax+332]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	call	?RemoveObject@RViewPoint@@QAEXPAVDrawableObject@@@Z ; RViewPoint::RemoveObject
$LN2@SfxClass:

; 2039 : 			}
; 2040 : 
; 2041 : 			// Get rid of the drawable
; 2042 : 			delete baseObj->drawPointer;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR [eax+332]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T9[ebp], edx
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN38@SfxClass
	push	1
	mov	eax, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T9[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv358[ebp], eax
	jmp	SHORT $LN39@SfxClass
$LN38@SfxClass:
	mov	DWORD PTR tv358[ebp], 0
$LN39@SfxClass:

; 2043 : 			baseObj->drawPointer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	DWORD PTR [eax+332], 0
$LN12@SfxClass:

; 2044 : 
; 2045 : 			// delete the object
; 2046 : 			//delete baseObj;
; 2047 : 		}
; 2048 : 	}
; 2049 : 
; 2050 : 	// update counters
; 2051 : 	gTotSfx--;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	sub	ecx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, ecx		; gTotSfx

; 2052 : 
; 2053 : 	if (type >= 0 && !F4IsBadReadPtr(gSfxCount, sizeof(int))) // JB 010318 CTD

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jl	SHORT $LN24@SfxClass
	push	4
	push	OFFSET ?gSfxCount@@3PAHA		; gSfxCount
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN24@SfxClass

; 2054 : 		gSfxCount[ type ]--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[edx*4], eax
$LN24@SfxClass:

; 2055 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1SfxClass@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??1SfxClass@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SfxClass@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SfxClass@@QAE@XZ ENDP				; SfxClass::~SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_drawPartSys$ = 8					; size = 4
??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z PROC	; SfxClass::SfxClass
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 266  : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 267  : 	type = SFX_PARTICLE_KLUDGE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 119			; 00000077H

; 268  : 	flags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 269  : 	vec.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+52], xmm0

; 270  : 	vec.y = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+56], xmm0

; 271  : 	vec.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0

; 272  : 	drawPartSys->GetPosition(&pos);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _drawPartSys$[ebp]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 273  : 
; 274  : 	timeToLive = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+100], xmm0

; 275  : 	// scale = scaleSfx * ( 0.6f + 0.4f * gSfxLOD );
; 276  : 	scale = 1;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+104], xmm0

; 277  : 	secondaryCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 278  : 	secondaryInterval = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+120], xmm0

; 279  : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [edx+124], xmm0

; 280  : 	travelDist = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 281  : 
; 282  : 	objParticleSys = drawPartSys;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _drawPartSys$[ebp]
	mov	DWORD PTR [ecx+168], edx

; 283  : 	objTrail = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 0

; 284  : 	//RV I-Hawk - RV new trails variables
; 285  : 	TrailNew = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], 0

; 286  : 	TrailIdNew = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+180], 0

; 287  : 	objTracer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 288  : 	objBSP = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 289  : 	obj2d = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 0

; 290  : 	//baseObj = NULL;
; 291  : 	endMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 0

; 292  : 	damMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 293  : 
; 294  : 		viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 295  : 
; 296  : 	// update counters
; 297  : 	gTotSfx++;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	eax, 1
	mov	DWORD PTR ?gTotSfx@@3HA, eax		; gTotSfx

; 298  : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 299  : 	{
; 300  : 		gTotHighWaterSfx = gTotSfx;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, edx	; gTotHighWaterSfx
$LN2@SfxClass:

; 301  : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 302  : 	}
; 303  : 	gSfxCount[ type ]++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[ecx*4], edx

; 304  : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	cmp	eax, DWORD PTR ?gSfxHighWater@@3PAHA[edx*4]
	jle	SHORT $LN1@SfxClass

; 305  : 	{
; 306  : 		gSfxHighWater[type] = gSfxCount[type];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4], edx
$LN1@SfxClass:

; 307  : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 308  : 	}
; 309  : 
; 310  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@PAVDrawableParticleSys@@@Z ENDP	; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv151 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_posSfx$ = 12						; size = 4
_vecSfx$ = 16						; size = 4
_theObject$ = 20					; size = 4
_timeToLiveSfx$ = 24					; size = 4
_scaleSfx$ = 28						; size = 4
??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z PROC	; SfxClass::SfxClass
; _this$ = ecx

; 986  : ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 987  : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 988  : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 989  : 	pos = *posSfx;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _posSfx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 990  : 	vec = *vecSfx;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	eax, DWORD PTR _vecSfx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 991  : 	timeToLive = timeToLiveSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 992  : 	scale = scaleSfx;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _scaleSfx$[ebp]
	movss	DWORD PTR [edx+104], xmm0

; 993  : 	secondaryCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 994  : 	secondaryInterval = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+120], xmm0

; 995  : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [edx+124], xmm0

; 996  : 	travelDist = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 997  : 
; 998  : 	objParticleSys = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+168], 0

; 999  : 	objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 1000 : 	objTracer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 1001 : 	objBSP = theObject;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _theObject$[ebp]
	mov	DWORD PTR [ecx+160], edx

; 1002 : 	obj2d = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 0

; 1003 : 	//baseObj = NULL;
; 1004 : 	endMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 1005 : 	damMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 1006 : 
; 1007 : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], eax

; 1008 :     flags = SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 35			; 00000023H

; 1009 : 
; 1010 : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 1011 : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 1012 : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN8@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [ecx+40]
	jbe	SHORT $LN8@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN8@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	SHORT $LN8@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [ecx+48]
	jbe	SHORT $LN8@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN8@SfxClass

; 1013 :  	{
; 1014 : 	}
; 1015 : 	else {

	jmp	SHORT $LN7@SfxClass
$LN8@SfxClass:

; 1016 : 		//ShiAssert( !"Bad SFX Position Passed in!" );
; 1017 : 		pos.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 1018 : 		pos.y = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+44], xmm0

; 1019 : 		pos.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+48], xmm0
$LN7@SfxClass:

; 1020 : 	}
; 1021 : 	
; 1022 : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 1023 : 
; 1024 : 	switch( type )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR tv151[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 66		; 00000042H
	je	SHORT $LN4@SfxClass
	jmp	SHORT $LN3@SfxClass
$LN4@SfxClass:

; 1025 : 	{
; 1026 : 		case SFX_BURNING_PART:
; 1027 : 			flags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 1028 : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1
$LN3@SfxClass:

; 1029 : 			break;
; 1030 : 		default:
; 1031 : 			break;
; 1032 : 	}
; 1033 : 
; 1034 : 	// update counters
; 1035 : 	gTotSfx++;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	ecx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, ecx		; gTotSfx

; 1036 : 	if ( gTotSfx > gTotHighWaterSfx ){

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 1037 : 		gTotHighWaterSfx = gTotSfx;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, eax	; gTotHighWaterSfx
$LN2@SfxClass:

; 1038 : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 1039 : 	}
; 1040 : 	gSfxCount[ type ]++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[edx*4], eax

; 1041 : 	if ( gSfxCount[type] > gSfxHighWater[type] ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	cmp	ecx, DWORD PTR ?gSfxHighWater@@3PAHA[eax*4]
	jle	SHORT $LN1@SfxClass

; 1042 : 		gSfxHighWater[type] = gSfxCount[type];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[edx*4], eax
$LN1@SfxClass:

; 1043 : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 1044 : 	}
; 1045 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HPAUTpoint@@0PAVDrawableBSP@@MM@Z ENDP	; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_timeToLiveSfx$ = 8					; size = 4
_trail$ = 12						; size = 4
??0SfxClass@@QAE@MPAVDrawableTrail@@@Z PROC		; SfxClass::SfxClass
; _this$ = ecx

; 1052 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1053 : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 1054 : 	type = SFX_TIMER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 25			; 00000019H

; 1055 : 	flags = SFX_TIMER_FLAG;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 256			; 00000100H

; 1056 : 	timeToLive = timeToLiveSfx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 1057 : 	secondaryCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 1058 : 	secondaryInterval = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+120], xmm0

; 1059 : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [eax+124], xmm0

; 1060 : 	travelDist = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+108], xmm0

; 1061 : 	pos.x = 0.0f; // JPO initialise, it is used.

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+40], xmm0

; 1062 : 	pos.y = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+44], xmm0

; 1063 : 	pos.z = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+48], xmm0

; 1064 : 
; 1065 : 	objParticleSys = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0

; 1066 : 	objTrail = trail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _trail$[ebp]
	mov	DWORD PTR [eax+156], ecx

; 1067 : 	objTracer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], 0

; 1068 : 	objBSP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 1069 : 	obj2d = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0

; 1070 : 	//baseObj = NULL;
; 1071 : 	endMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 1072 : 	damMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0

; 1073 : 
; 1074 : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], eax

; 1075 : 
; 1076 : 	// update counters
; 1077 : 	gTotSfx++;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	edx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, edx		; gTotSfx

; 1078 : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 1079 : 	{
; 1080 : 		gTotHighWaterSfx = gTotSfx;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, ecx	; gTotHighWaterSfx
$LN2@SfxClass:

; 1081 : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 1082 : 	}
; 1083 : 	gSfxCount[ type ]++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[eax*4], ecx

; 1084 : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	cmp	edx, DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4]
	jle	SHORT $LN1@SfxClass

; 1085 : 	{
; 1086 : 		gSfxHighWater[type] = gSfxCount[type];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[eax*4], ecx
$LN1@SfxClass:

; 1087 : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 1088 : 	}
; 1089 : 
; 1090 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@MPAVDrawableTrail@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@MPAVDrawableTrail@@@Z ENDP		; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv189 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_flagsSfx$ = 12						; size = 4
_baseobjSfx$ = 16					; size = 4
_timeToLiveSfx$ = 20					; size = 4
_scaleSfx$ = 24						; size = 4
??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z PROC		; SfxClass::SfxClass
; _this$ = ecx

; 1717 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1718 : 
; 1719 : 	// ShiAssert(baseobjSfx && !vuDatabase->Find(baseobjSfx->Id()) && baseobjSfx->VuState() == VU_MEM_CREATED);
; 1720 : 
; 1721 : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 1722 : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1723 : 	flags = flagsSfx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flagsSfx$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1724 : 	baseObj.reset(baseobjSfx);

	mov	edx, DWORD PTR _baseobjSfx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::reset

; 1725 : 	vec.x = baseObj->XDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+52]

; 1726 : 	vec.y = baseObj->YDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1727 : 	vec.z = baseObj->ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+60]

; 1728 : 	timeToLive = timeToLiveSfx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 1729 : 	scale = scaleSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _scaleSfx$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 1730 : 	secondaryCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0

; 1731 : 	secondaryInterval = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+120], xmm0

; 1732 : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [ecx+124], xmm0

; 1733 : 	OTWDriver.ObjectSetData(baseObj.get(), &pos, &rot );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ObjectSetData@OTWDriverClass@@QAEXPAVSimBaseClass@@PAUTpoint@@PAUTrotation@@@Z ; OTWDriverClass::ObjectSetData

; 1734 : 	objParticleSys = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+168], 0

; 1735 :     obj2d = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 0

; 1736 :     objBSP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 1737 :     objTrail = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 0

; 1738 : 	objTracer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], 0

; 1739 : 	endMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 0

; 1740 : 	damMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 1741 : 	travelDist = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+108], xmm0

; 1742 : 
; 1743 :   F4Assert( vec.x > -10000.0F && vec.y > -10000.0F && vec.z > -10000.0F);
; 1744 :   F4Assert( vec.x <  10000.0F && vec.y <  10000.0F && vec.z <  10000.0F);
; 1745 : 
; 1746 : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 1747 : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 1748 : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN17@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [ecx+40]
	jbe	SHORT $LN17@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN17@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	SHORT $LN17@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [ecx+48]
	jbe	SHORT $LN17@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN17@SfxClass

; 1749 :  	{
; 1750 : 	}
; 1751 : 	else

	jmp	SHORT $LN16@SfxClass
$LN17@SfxClass:

; 1752 : 	{
; 1753 : 		//ShiAssert( !"Bad SFX Position Passed in!" );
; 1754 : 		pos.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 1755 : 		pos.y = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+44], xmm0

; 1756 : 		pos.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+48], xmm0
$LN16@SfxClass:

; 1757 : 	}
; 1758 : 
; 1759 : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 1760 : 
; 1761 : 	switch( type )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR tv189[ebp], ecx
	mov	edx, DWORD PTR tv189[ebp]
	sub	edx, 3
	mov	DWORD PTR tv189[ebp], edx
	cmp	DWORD PTR tv189[ebp], 98		; 00000062H
	ja	$LN3@SfxClass
	mov	eax, DWORD PTR tv189[ebp]
	movzx	ecx, BYTE PTR $LN21@SfxClass[eax]
	jmp	DWORD PTR $LN23@SfxClass[ecx*4]
$LN13@SfxClass:

; 1762 : 	{
; 1763 : 		case SFX_SMOKING_PART:
; 1764 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1765 : 			//objTrail = new DrawableTrail(TRAIL_SMOKE);
; 1766 : 			if ( gTotSfx <= gSfxLODTotCutoff &&
; 1767 : 				 gSfxCount[ SFX_AIR_SMOKECLOUD ] < gSfxLODCutoff )

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jg	SHORT $LN12@SfxClass
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN12@SfxClass

; 1768 : 			{
; 1769 : 				// for smoking part, randomly allow piece to smoke for a
; 1770 : 				// while and hit ground and stay there
; 1771 : 				if ( PRANDInt3() == 0 )

	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	test	eax, eax
	jne	SHORT $LN11@SfxClass

; 1772 : 				{
; 1773 : 					timeToLive += 90.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	addss	xmm0, DWORD PTR __real@42b40000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 1774 : 					flags &= ~SFX_EXPLODE_WHEN_DONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN11@SfxClass:

; 1775 : 				}
; 1776 : 
; 1777 : 				secondaryInterval = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+120], xmm0

; 1778 : 				secondaryCount = (int)(timeToLive * 1.0f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax
$LN12@SfxClass:

; 1779 : 			}
; 1780 : 
; 1781 : 			break;

	jmp	$LN14@SfxClass
$LN10@SfxClass:

; 1782 : 		case SFX_FLAMING_PART:
; 1783 : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 1784 : 				 gSfxCount[ SFX_FIRE1 ] > gSfxLODCutoff )

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN8@SfxClass
	mov	eax, 4
	imul	eax, 85					; 00000055H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jle	SHORT $LN9@SfxClass
$LN8@SfxClass:

; 1785 : 			{
; 1786 : 				//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1787 : 				//objTrail = new DrawableTrail(TRAIL_MEDIUM_SAM);
; 1788 : 			}
; 1789 : 			else

	jmp	SHORT $LN7@SfxClass
$LN9@SfxClass:

; 1790 : 			{
; 1791 : 				secondaryInterval = 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [edx+120], xmm0

; 1792 : 				secondaryCount = (int)(timeToLive * 10.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], ecx
$LN7@SfxClass:

; 1793 : 			}
; 1794 : 			break;

	jmp	$LN14@SfxClass
$LN6@SfxClass:

; 1795 : 		case SFX_BURNING_PART:
; 1796 : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 1797 : 			break;

	jmp	$LN14@SfxClass
$LN5@SfxClass:

; 1798 : 		case SFX_SMOKING_FEATURE:
; 1799 : 		case SFX_STEAMING_FEATURE:
; 1800 : 			// smoking features is a special case of effect.  It's used
; 1801 : 			// for having smoke rising off of smoke stacks.  The flags passed
; 1802 : 			// in will tell us which slot to use for the hardpoint
; 1803 : 
; 1804 : 			// we MUST do a VuRef so that the feature isn't deleted out
; 1805 : 			// from under us
; 1806 : 			//VuReferenceEntity( baseObj );
; 1807 : 
; 1808 : 			// temporarily use the objBSP ptr
; 1809 : 			objBSP = (DrawableBSP *)baseObj->drawPointer;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+332]
	mov	DWORD PTR [ecx+160], edx

; 1810 : 			objBSP->GetChildOffset( flags, &pos );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	call	?GetChildOffset@DrawableBSP@@QAEXHPAUTpoint@@@Z ; DrawableBSP::GetChildOffset

; 1811 : 
; 1812 : 			// get rotated offset
; 1813 : 			vec.x = pos.x * objBSP->orientation.M11 + pos.y * objBSP->orientation.M12;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+44]
	mulss	xmm1, DWORD PTR [edx+52]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1814 : 			vec.y = pos.x * objBSP->orientation.M21 + pos.y * objBSP->orientation.M22;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+44]
	mulss	xmm1, DWORD PTR [eax+64]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1815 : 			vec.z = pos.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+60], edx

; 1816 : 
; 1817 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1818 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 1819 : 
; 1820 : 			objBSP->GetPosition( &pos );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+160]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 1821 : 
; 1822 : 			// we're done borrowing this
; 1823 : 			objBSP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0
$LN3@SfxClass:
$LN14@SfxClass:

; 1824 : 
; 1825 : 			// flags = SFX_TIMER_FLAG; // MLR 12/20/2003 - Can't have this set anymore
; 1826 : 
; 1827 : 			break;
; 1828 : 		case SFX_PARTICLE_KLUDGE: // so it won't do that annoying "Bad SFX Type"
; 1829 : 			break;
; 1830 : 		default:
; 1831 : 			// bzzzzt
; 1832 : 			ShiWarning ("Bad SFX Type");
; 1833 : 			break;
; 1834 : 	}
; 1835 : 
; 1836 : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], eax

; 1837 : 
; 1838 : 	// update counters
; 1839 : 	gTotSfx++;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	edx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, edx		; gTotSfx

; 1840 : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 1841 : 	{
; 1842 : 		gTotHighWaterSfx = gTotSfx;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, ecx	; gTotHighWaterSfx
$LN2@SfxClass:

; 1843 : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 1844 : 	}
; 1845 : 	gSfxCount[ type ]++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[eax*4], ecx

; 1846 : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	cmp	edx, DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4]
	jle	SHORT $LN1@SfxClass

; 1847 : 	{
; 1848 : 		gSfxHighWater[type] = gSfxCount[type];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[eax*4], ecx
$LN1@SfxClass:

; 1849 : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 1850 : 	}
; 1851 : 
; 1852 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN23@SfxClass:
	DD	$LN13@SfxClass
	DD	$LN10@SfxClass
	DD	$LN6@SfxClass
	DD	$LN5@SfxClass
	DD	$LN3@SfxClass
$LN21@SfxClass:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HHPAVSimBaseClass@@MM@Z ENDP		; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
$T2 = -260						; size = 4
$T3 = -256						; size = 4
$T4 = -252						; size = 4
$T5 = -248						; size = 4
$T6 = -244						; size = 4
$T7 = -240						; size = 4
$T8 = -236						; size = 4
$T9 = -232						; size = 4
$T10 = -228						; size = 4
$T11 = -224						; size = 4
$T12 = -220						; size = 4
$T13 = -216						; size = 4
$T14 = -212						; size = 4
$T15 = -208						; size = 4
$T16 = -204						; size = 4
$T17 = -200						; size = 4
$T18 = -196						; size = 4
$T19 = -192						; size = 4
$T20 = -188						; size = 4
$T21 = -184						; size = 4
$T22 = -180						; size = 4
$T23 = -176						; size = 4
$T24 = -172						; size = 4
$T25 = -168						; size = 4
$T26 = -164						; size = 4
tv151 = -160						; size = 4
$T27 = -156						; size = 4
$T28 = -152						; size = 4
$T29 = -148						; size = 4
$T30 = -144						; size = 4
$T31 = -140						; size = 4
tv400 = -136						; size = 4
$T32 = -132						; size = 4
tv381 = -128						; size = 4
$T33 = -124						; size = 4
tv362 = -120						; size = 4
$T34 = -116						; size = 4
tv312 = -112						; size = 4
$T35 = -108						; size = 4
tv295 = -104						; size = 4
tv491 = -100						; size = 4
tv282 = -96						; size = 4
$T36 = -92						; size = 4
tv269 = -88						; size = 4
tv474 = -84						; size = 4
tv253 = -80						; size = 4
$T37 = -76						; size = 4
tv236 = -72						; size = 4
tv457 = -68						; size = 4
tv223 = -64						; size = 4
$T38 = -60						; size = 4
tv210 = -56						; size = 4
tv440 = -52						; size = 4
tv197 = -48						; size = 4
$T39 = -44						; size = 4
tv184 = -40						; size = 4
tv427 = -36						; size = 4
tv165 = -32						; size = 4
$T40 = -28						; size = 4
tv414 = -24						; size = 4
$T41 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_flagsSfx$ = 12						; size = 4
_posSfx$ = 16						; size = 4
_rotSfx$ = 20						; size = 4
_vecSfx$ = 24						; size = 4
_timeToLiveSfx$ = 28					; size = 4
_scaleSfx$ = 32						; size = 4
??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z PROC	; SfxClass::SfxClass
; _this$ = ecx

; 1102 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1103 : 
; 1104 : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 1105 : 	rot = *rotSfx;

	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 64					; 00000040H
	mov	ecx, 9
	mov	esi, DWORD PTR _rotSfx$[ebp]
	rep movsd

; 1106 : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1107 : 	flags = flagsSfx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flagsSfx$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1108 : 	pos = *posSfx;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR _posSfx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1109 : 	vec = *vecSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _vecSfx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 1110 : 	timeToLive = timeToLiveSfx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 1111 : 	// scale = scaleSfx * ( 0.6f + 0.4f * gSfxLOD );
; 1112 : 	scale = scaleSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _scaleSfx$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 1113 : 	secondaryCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0

; 1114 : 	secondaryInterval = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+120], xmm0

; 1115 : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [ecx+124], xmm0

; 1116 : 
; 1117 : 	objParticleSys = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0

; 1118 :     obj2d = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 0

; 1119 : 	objTrail = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 0

; 1120 : 	objTracer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], 0

; 1121 : 	objBSP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 1122 : 	//baseObj = NULL;
; 1123 : 	endMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 1124 : 	damMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 1125 : 	travelDist = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 1126 : 
; 1127 : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 1128 : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 1129 : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN28@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [edx+40]
	jbe	SHORT $LN28@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN28@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN28@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [edx+48]
	jbe	SHORT $LN28@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN28@SfxClass

; 1130 :  	{
; 1131 : 	}
; 1132 : 	else

	jmp	SHORT $LN27@SfxClass
$LN28@SfxClass:

; 1133 : 	{
; 1134 : 		MonoPrint( "Bad SFX Position Passed in!" );

	push	OFFSET ??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@
	call	_MonoPrint
	add	esp, 4

; 1135 : 		pos.x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 1136 : 		pos.y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+44], xmm0

; 1137 : 		pos.z = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+48], xmm0
$LN27@SfxClass:

; 1138 : 	}
; 1139 : 
; 1140 : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 1141 : 
; 1142 : 	switch( type )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv151[ebp], edx
	cmp	DWORD PTR tv151[ebp], 109		; 0000006dH
	ja	$LN3@SfxClass
	mov	eax, DWORD PTR tv151[ebp]
	movzx	ecx, BYTE PTR $LN92@SfxClass[eax]
	jmp	DWORD PTR $LN94@SfxClass[ecx*4]
$LN24@SfxClass:

; 1143 : 	{
; 1144 : 		case SFX_AC_AIR_EXPLOSION:
; 1145 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1146 :     		obj2d = new Drawable2D( DRAW2D_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T30[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T30[ebp], 0
	je	SHORT $LN31@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	24					; 00000018H
	mov	ecx, DWORD PTR $T30[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN32@SfxClass
$LN31@SfxClass:
	mov	DWORD PTR tv165[ebp], 0
$LN32@SfxClass:
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR $T21[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T21[ebp]
	mov	DWORD PTR [edx+152], eax

; 1147 : 			secondaryCount = (int)(timeToLive * 2.0f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR __real@40000000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], edx

; 1148 : 			secondaryInterval = 0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+120], xmm0

; 1149 : 			break;

	jmp	$LN25@SfxClass
$LN23@SfxClass:

; 1150 : 		case SFX_AIR_SMOKECLOUD:
; 1151 :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T35[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T35[ebp], 0
	je	SHORT $LN33@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T35[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv184[ebp], eax
	jmp	SHORT $LN34@SfxClass
$LN33@SfxClass:
	mov	DWORD PTR tv184[ebp], 0
$LN34@SfxClass:
	mov	ecx, DWORD PTR tv184[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T19[ebp]
	mov	DWORD PTR [edx+152], eax

; 1152 : 			break;

	jmp	$LN25@SfxClass
$LN22@SfxClass:

; 1153 : 		case SFX_AIR_DUSTCLOUD:
; 1154 :     		obj2d = new Drawable2D( DRAW2D_AIR_DUSTCLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T34[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T34[ebp], 0
	je	SHORT $LN35@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR $T34[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv197[ebp], eax
	jmp	SHORT $LN36@SfxClass
$LN35@SfxClass:
	mov	DWORD PTR tv197[ebp], 0
$LN36@SfxClass:
	mov	eax, DWORD PTR tv197[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1155 : 			break;

	jmp	$LN25@SfxClass
$LN21@SfxClass:

; 1156 : 		case SFX_GROUND_DUSTCLOUD:
; 1157 :     		obj2d = new Drawable2D( DRAW2D_GROUND_DUSTCLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T33[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T33[ebp], 0
	je	SHORT $LN37@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	mov	ecx, DWORD PTR $T33[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv210[ebp], eax
	jmp	SHORT $LN38@SfxClass
$LN37@SfxClass:
	mov	DWORD PTR tv210[ebp], 0
$LN38@SfxClass:
	mov	edx, DWORD PTR tv210[ebp]
	mov	DWORD PTR $T17[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1158 : 			break;

	jmp	$LN25@SfxClass
$LN20@SfxClass:

; 1159 : 		case SFX_WATER_CLOUD:
; 1160 :     		obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T32[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T32[ebp], 0
	je	SHORT $LN39@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T32[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv223[ebp], eax
	jmp	SHORT $LN40@SfxClass
$LN39@SfxClass:
	mov	DWORD PTR tv223[ebp], 0
$LN40@SfxClass:
	mov	ecx, DWORD PTR tv223[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR [edx+152], eax

; 1161 : 			break;

	jmp	$LN25@SfxClass
$LN19@SfxClass:

; 1162 : 		case SFX_STEAM_CLOUD:
; 1163 :     		obj2d = new Drawable2D( DRAW2D_STEAM_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T31[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T31[ebp], 0
	je	SHORT $LN41@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	55					; 00000037H
	mov	ecx, DWORD PTR $T31[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv236[ebp], eax
	jmp	SHORT $LN42@SfxClass
$LN41@SfxClass:
	mov	DWORD PTR tv236[ebp], 0
$LN42@SfxClass:
	mov	eax, DWORD PTR tv236[ebp]
	mov	DWORD PTR $T15[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T15[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1164 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1165 : 			break;

	jmp	$LN25@SfxClass
$LN18@SfxClass:

; 1166 : 		case SFX_LANDING_SMOKE:
; 1167 :     		obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T29[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T29[ebp], 0
	je	SHORT $LN43@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T29[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv253[ebp], eax
	jmp	SHORT $LN44@SfxClass
$LN43@SfxClass:
	mov	DWORD PTR tv253[ebp], 0
$LN44@SfxClass:
	mov	ecx, DWORD PTR tv253[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [edx+152], eax

; 1168 : 			break;

	jmp	$LN25@SfxClass
$LN17@SfxClass:

; 1169 : 		case SFX_VERTICAL_SMOKE:
; 1170 :     		obj2d = new Drawable2D( DRAW2D_AIR_DUSTCLOUD, scale, &pos, 4, gWaterVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T27[ebp], 0
	je	SHORT $LN45@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gWaterVerts@@3PAUTpoint@@A	; gWaterVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR $T27[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv269[ebp], eax
	jmp	SHORT $LN46@SfxClass
$LN45@SfxClass:
	mov	DWORD PTR tv269[ebp], 0
$LN46@SfxClass:
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR $T13[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1171 : 			break;

	jmp	$LN25@SfxClass
$LN16@SfxClass:

; 1172 : 		case SFX_AIR_SMOKECLOUD2:
; 1173 :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T26[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T26[ebp], 0
	je	SHORT $LN47@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	13					; 0000000dH
	mov	ecx, DWORD PTR $T26[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv282[ebp], eax
	jmp	SHORT $LN48@SfxClass
$LN47@SfxClass:
	mov	DWORD PTR tv282[ebp], 0
$LN48@SfxClass:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1174 : 			break;

	jmp	$LN25@SfxClass
$LN15@SfxClass:

; 1175 : 		case SFX_GUNSMOKE:
; 1176 :     		obj2d = new Drawable2D( DRAW2D_GUNSMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN49@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv295[ebp], eax
	jmp	SHORT $LN50@SfxClass
$LN49@SfxClass:
	mov	DWORD PTR tv295[ebp], 0
$LN50@SfxClass:
	mov	ecx, DWORD PTR tv295[ebp]
	mov	DWORD PTR $T11[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR [edx+152], eax

; 1177 : 			break;

	jmp	$LN25@SfxClass
$LN14@SfxClass:

; 1178 : 		case SFX_RAND_CRATER:
; 1179 :     		obj2d = new Drawable2D( DRAW2D_CRATER1 + PRANDInt3(), scale, &pos, &rot );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T22[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN51@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR $T22[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@PAUTrotation@@@Z ; Drawable2D::Drawable2D
	mov	DWORD PTR tv312[ebp], eax
	jmp	SHORT $LN52@SfxClass
$LN51@SfxClass:
	mov	DWORD PTR tv312[ebp], 0
$LN52@SfxClass:
	mov	ecx, DWORD PTR tv312[ebp]
	mov	DWORD PTR $T20[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T20[ebp]
	mov	DWORD PTR [edx+152], eax

; 1180 : 			break;

	jmp	$LN25@SfxClass
$LN13@SfxClass:

; 1181 : 		case SFX_CRATER2:
; 1182 :     		objBSP = new DrawableGroundVehicle( MapVisId(VIS_CRATER2),  &pos, 0.0f, 1.0f  );

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T23[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T23[ebp], 0
	je	SHORT $LN53@SfxClass
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	push	127					; 0000007fH
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T23[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv362[ebp], eax
	jmp	SHORT $LN54@SfxClass
$LN53@SfxClass:
	mov	DWORD PTR tv362[ebp], 0
$LN54@SfxClass:
	mov	edx, DWORD PTR tv362[ebp]
	mov	DWORD PTR $T18[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T18[ebp]
	mov	DWORD PTR [eax+160], ecx

; 1183 : 			break;

	jmp	$LN25@SfxClass
$LN12@SfxClass:

; 1184 : 		case SFX_CRATER3:
; 1185 :     		objBSP = new DrawableGroundVehicle( MapVisId(VIS_CRATER3),  &pos, 0.0f, 1.0f  );

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T28[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN55@SfxClass
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	push	128					; 00000080H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T28[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv381[ebp], eax
	jmp	SHORT $LN56@SfxClass
$LN55@SfxClass:
	mov	DWORD PTR tv381[ebp], 0
$LN56@SfxClass:
	mov	eax, DWORD PTR tv381[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T16[ebp]
	mov	DWORD PTR [ecx+160], edx

; 1186 : 			break;

	jmp	$LN25@SfxClass
$LN11@SfxClass:

; 1187 : 		case SFX_CRATER4:
; 1188 :     		objBSP = new DrawableGroundVehicle( MapVisId(VIS_CRATER4),  &pos, 0.0f, 1.0f  );

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN57@SfxClass
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	129					; 00000081H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T25[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv400[ebp], eax
	jmp	SHORT $LN58@SfxClass
$LN57@SfxClass:
	mov	DWORD PTR tv400[ebp], 0
$LN58@SfxClass:
	mov	ecx, DWORD PTR tv400[ebp]
	mov	DWORD PTR $T14[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR [edx+160], eax

; 1189 : 			break;

	jmp	$LN25@SfxClass
$LN10@SfxClass:

; 1190 : 		case SFX_TRAIL_SMOKECLOUD:
; 1191 :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T41[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cmp	DWORD PTR $T41[ebp], 0
	je	SHORT $LN59@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T41[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv414[ebp], eax
	jmp	SHORT $LN60@SfxClass
$LN59@SfxClass:
	mov	DWORD PTR tv414[ebp], 0
$LN60@SfxClass:
	mov	eax, DWORD PTR tv414[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1192 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1193 : 			//objTrail = new DrawableTrail(TRAIL_THINFIRE);
; 1194 : 			break;

	jmp	$LN25@SfxClass
$LN9@SfxClass:

; 1195 : 		case SFX_TRAIL_FIREBALL:
; 1196 :     		obj2d = new Drawable2D( DRAW2D_FLARE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	cmp	DWORD PTR $T40[ebp], 0
	je	SHORT $LN61@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR $T40[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv427[ebp], eax
	jmp	SHORT $LN62@SfxClass
$LN61@SfxClass:
	mov	DWORD PTR tv427[ebp], 0
$LN62@SfxClass:
	mov	edx, DWORD PTR tv427[ebp]
	mov	DWORD PTR $T10[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1197 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1198 : 			//objTrail = new DrawableTrail(TRAIL_THINFIRE);
; 1199 : 			break;

	jmp	$LN25@SfxClass
$LN8@SfxClass:

; 1200 : 		case SFX_GUNFIRE:
; 1201 :     		obj2d = new Drawable2D( DRAW2D_FLARE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	cmp	DWORD PTR $T39[ebp], 0
	je	SHORT $LN63@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR $T39[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv440[ebp], eax
	jmp	SHORT $LN64@SfxClass
$LN63@SfxClass:
	mov	DWORD PTR tv440[ebp], 0
$LN64@SfxClass:
	mov	ecx, DWORD PTR tv440[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR [edx+152], eax

; 1202 : 			break;

	jmp	$LN25@SfxClass
$LN7@SfxClass:

; 1203 : 		case SFX_EJECT1:
; 1204 :     		objBSP = new DrawableBSP( MapVisId(VIS_EJECT1), &pos, &rot, scale );

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T38[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	cmp	DWORD PTR $T38[ebp], 0
	je	SHORT $LN65@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	64					; 00000040H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T38[ebp]
	call	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z ; DrawableBSP::DrawableBSP
	mov	DWORD PTR tv457[ebp], eax
	jmp	SHORT $LN66@SfxClass
$LN65@SfxClass:
	mov	DWORD PTR tv457[ebp], 0
$LN66@SfxClass:
	mov	ecx, DWORD PTR tv457[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR [edx+160], eax

; 1205 : 			break;

	jmp	$LN25@SfxClass
$LN6@SfxClass:

; 1206 : 		case SFX_EJECT2:
; 1207 :     		objBSP = new DrawableBSP( MapVisId(VIS_EJECT2), &pos, &rot, scale );

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T37[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	cmp	DWORD PTR $T37[ebp], 0
	je	SHORT $LN67@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	65					; 00000041H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T37[ebp]
	call	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z ; DrawableBSP::DrawableBSP
	mov	DWORD PTR tv474[ebp], eax
	jmp	SHORT $LN68@SfxClass
$LN67@SfxClass:
	mov	DWORD PTR tv474[ebp], 0
$LN68@SfxClass:
	mov	ecx, DWORD PTR tv474[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [edx+160], eax

; 1208 : 			break;

	jmp	SHORT $LN25@SfxClass
$LN5@SfxClass:

; 1209 : 		/*
; 1210 : 		case SFX_MISSILE_LAUNCH:
; 1211 :     		objBSP = new DrawableBSP( VIS_MISS_LAUN, &pos, &rot, scale );
; 1212 : 			break;
; 1213 : 		*/
; 1214 : 		case SFX_DUST1:
; 1215 :     		objBSP = new DrawableBSP( MapVisId(VIS_DUST1), &pos, &rot, scale );

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T36[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	cmp	DWORD PTR $T36[ebp], 0
	je	SHORT $LN69@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	46					; 0000002eH
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T36[ebp]
	call	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z ; DrawableBSP::DrawableBSP
	mov	DWORD PTR tv491[ebp], eax
	jmp	SHORT $LN70@SfxClass
$LN69@SfxClass:
	mov	DWORD PTR tv491[ebp], 0
$LN70@SfxClass:
	mov	ecx, DWORD PTR tv491[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+160], eax
$LN3@SfxClass:
$LN25@SfxClass:

; 1216 : 			break;
; 1217 : 		case SFX_PARTICLE_KLUDGE: // so it won't do that annoying "Bad SFX Type"
; 1218 : 			break;
; 1219 : 
; 1220 : 		default:
; 1221 : 			// bzzzzt
; 1222 : 			ShiWarning ("Bad SFX Type");
; 1223 : 			break;
; 1224 : 	}
; 1225 : 
; 1226 : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], eax

; 1227 : 
; 1228 : 
; 1229 : 	// update counters
; 1230 : 	gTotSfx++;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	edx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, edx		; gTotSfx

; 1231 : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 1232 : 	{
; 1233 : 		gTotHighWaterSfx = gTotSfx;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, ecx	; gTotHighWaterSfx
$LN2@SfxClass:

; 1234 : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 1235 : 	}
; 1236 : 	gSfxCount[ type ]++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[eax*4], ecx

; 1237 : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	cmp	edx, DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4]
	jle	SHORT $LN1@SfxClass

; 1238 : 	{
; 1239 : 		gSfxHighWater[type] = gSfxCount[type];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[eax*4], ecx
$LN1@SfxClass:

; 1240 : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 1241 : 	}
; 1242 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN94@SfxClass:
	DD	$LN24@SfxClass
	DD	$LN23@SfxClass
	DD	$LN10@SfxClass
	DD	$LN9@SfxClass
	DD	$LN7@SfxClass
	DD	$LN6@SfxClass
	DD	$LN22@SfxClass
	DD	$LN15@SfxClass
	DD	$LN16@SfxClass
	DD	$LN8@SfxClass
	DD	$LN5@SfxClass
	DD	$LN14@SfxClass
	DD	$LN17@SfxClass
	DD	$LN18@SfxClass
	DD	$LN20@SfxClass
	DD	$LN21@SfxClass
	DD	$LN19@SfxClass
	DD	$LN13@SfxClass
	DD	$LN12@SfxClass
	DD	$LN11@SfxClass
	DD	$LN3@SfxClass
$LN92@SfxClass:
	DB	0
	DB	20					; 00000014H
	DB	1
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	2
	DB	3
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	4
	DB	5
	DB	20					; 00000014H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	10					; 0000000aH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	11					; 0000000bH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	12					; 0000000cH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	16					; 00000010H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$1:
	mov	eax, DWORD PTR $T30[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$2:
	mov	eax, DWORD PTR $T35[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$3:
	mov	eax, DWORD PTR $T34[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$4:
	mov	eax, DWORD PTR $T33[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$5:
	mov	eax, DWORD PTR $T32[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$6:
	mov	eax, DWORD PTR $T31[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$7:
	mov	eax, DWORD PTR $T29[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$8:
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$9:
	mov	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$10:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$11:
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$12:
	mov	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$13:
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$14:
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$15:
	mov	eax, DWORD PTR $T41[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$16:
	mov	eax, DWORD PTR $T40[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$17:
	mov	eax, DWORD PTR $T39[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$18:
	mov	eax, DWORD PTR $T38[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$19:
	mov	eax, DWORD PTR $T37[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z$20:
	mov	eax, DWORD PTR $T36[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HHPAUTpoint@@PAUTrotation@@0MM@Z ENDP	; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
$T2 = -644						; size = 4
$T3 = -640						; size = 4
$T4 = -636						; size = 4
$T5 = -632						; size = 4
$T6 = -628						; size = 4
$T7 = -624						; size = 4
$T8 = -620						; size = 4
$T9 = -616						; size = 4
$T10 = -612						; size = 4
$T11 = -608						; size = 4
$T12 = -604						; size = 4
$T13 = -600						; size = 4
$T14 = -596						; size = 4
$T15 = -592						; size = 4
$T16 = -588						; size = 4
$T17 = -584						; size = 4
$T18 = -580						; size = 4
$T19 = -576						; size = 4
$T20 = -572						; size = 4
$T21 = -568						; size = 4
$T22 = -564						; size = 4
$T23 = -560						; size = 4
$T24 = -556						; size = 4
$T25 = -552						; size = 4
$T26 = -548						; size = 4
$T27 = -544						; size = 4
$T28 = -540						; size = 4
$T29 = -536						; size = 4
$T30 = -532						; size = 4
$T31 = -528						; size = 4
$T32 = -524						; size = 4
$T33 = -520						; size = 4
$T34 = -516						; size = 4
$T35 = -512						; size = 4
$T36 = -508						; size = 4
$T37 = -504						; size = 4
$T38 = -500						; size = 4
$T39 = -496						; size = 4
$T40 = -492						; size = 4
$T41 = -488						; size = 4
$T42 = -484						; size = 4
$T43 = -480						; size = 4
$T44 = -476						; size = 4
$T45 = -472						; size = 4
$T46 = -468						; size = 4
$T47 = -464						; size = 4
$T48 = -460						; size = 4
$T49 = -456						; size = 4
$T50 = -452						; size = 4
$T51 = -448						; size = 4
$T52 = -444						; size = 4
tv703 = -440						; size = 4
$T53 = -436						; size = 4
tv683 = -432						; size = 4
$T54 = -428						; size = 4
tv663 = -424						; size = 4
$T55 = -420						; size = 4
tv643 = -416						; size = 4
$T56 = -412						; size = 4
tv623 = -408						; size = 4
$T57 = -404						; size = 4
tv603 = -400						; size = 4
$T58 = -396						; size = 4
tv587 = -392						; size = 4
$T59 = -388						; size = 4
tv574 = -384						; size = 4
$T60 = -380						; size = 4
tv558 = -376						; size = 4
$T61 = -372						; size = 4
tv545 = -368						; size = 4
$T62 = -364						; size = 4
tv532 = -360						; size = 4
$T63 = -356						; size = 4
tv519 = -352						; size = 4
$T64 = -348						; size = 4
tv502 = -344						; size = 4
tv161 = -340						; size = 4
tv488 = -336						; size = 4
tv149 = -332						; size = 4
tv442 = -328						; size = 4
tv1046 = -324						; size = 4
tv423 = -320						; size = 4
tv1017 = -316						; size = 4
tv410 = -312						; size = 4
tv988 = -308						; size = 4
tv397 = -304						; size = 4
tv959 = -300						; size = 4
tv344 = -296						; size = 4
tv946 = -292						; size = 4
tv330 = -288						; size = 4
tv914 = -284						; size = 4
$T65 = -280						; size = 4
tv885 = -276						; size = 4
tv293 = -272						; size = 4
tv872 = -268						; size = 4
tv275 = -264						; size = 4
tv840 = -260						; size = 4
tv249 = -256						; size = 4
tv722 = -252						; size = 4
tv229 = -248						; size = 4
tv206 = -244						; size = 4
$T66 = -240						; size = 4
tv1467 = -236						; size = 4
$T67 = -232						; size = 4
$T68 = -228						; size = 4
$T69 = -224						; size = 4
tv1454 = -220						; size = 4
$T70 = -216						; size = 4
$T71 = -212						; size = 4
$T72 = -208						; size = 4
tv1410 = -204						; size = 4
$T73 = -200						; size = 4
$T74 = -196						; size = 4
$T75 = -192						; size = 4
tv1372 = -188						; size = 4
$T76 = -184						; size = 4
$T77 = -180						; size = 4
$T78 = -176						; size = 4
tv1362 = -172						; size = 4
$T79 = -168						; size = 4
$T80 = -164						; size = 4
$T81 = -160						; size = 4
tv1344 = -156						; size = 4
$T82 = -152						; size = 4
$T83 = -148						; size = 4
$T84 = -144						; size = 4
tv1276 = -140						; size = 4
$T85 = -136						; size = 4
$T86 = -132						; size = 4
$T87 = -128						; size = 4
tv1263 = -124						; size = 4
$T88 = -120						; size = 4
$T89 = -116						; size = 4
$T90 = -112						; size = 4
tv1250 = -108						; size = 4
$T91 = -104						; size = 4
$T92 = -100						; size = 4
$T93 = -96						; size = 4
tv1225 = -92						; size = 4
tv320 = -88						; size = 4
$T94 = -84						; size = 4
tv303 = -80						; size = 4
tv1196 = -76						; size = 4
$T95 = -72						; size = 4
$T96 = -68						; size = 4
$T97 = -64						; size = 4
tv1167 = -60						; size = 4
$T98 = -56						; size = 4
$T99 = -52						; size = 4
$T100 = -48						; size = 4
tv1138 = -44						; size = 4
$T101 = -40						; size = 4
$T102 = -36						; size = 4
$T103 = -32						; size = 4
tv1109 = -28						; size = 4
tv1079 = -24						; size = 4
_len$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_flagsSfx$ = 12						; size = 4
_posSfx$ = 16						; size = 4
_vecSfx$ = 20						; size = 4
_timeToLiveSfx$ = 24					; size = 4
_scaleSfx$ = 28						; size = 4
??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z PROC		; SfxClass::SfxClass
; _this$ = ecx

; 1253 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 632				; 00000278H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1254 : 	float len;
; 1255 : 
; 1256 : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 1257 : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1258 : 	flags = flagsSfx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flagsSfx$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1259 : 	pos = *posSfx;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR _posSfx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1260 : 	vec = *vecSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	mov	edx, DWORD PTR _vecSfx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 1261 : 	timeToLive = timeToLiveSfx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 1262 : 	// scale = scaleSfx * ( 0.6f + 0.4f * gSfxLOD );
; 1263 : 	scale = scaleSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _scaleSfx$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 1264 : 	secondaryCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0

; 1265 : 	secondaryInterval = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+120], xmm0

; 1266 : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [ecx+124], xmm0

; 1267 : 	travelDist = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+108], xmm0

; 1268 : 
; 1269 : 	objParticleSys = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+168], 0

; 1270 :     obj2d = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0

; 1271 : 	objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 1272 : 	objTracer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 1273 : 	objBSP = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 1274 : 	//baseObj = NULL;
; 1275 : 	endMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 1276 : 	damMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0

; 1277 : 
; 1278 : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 1279 : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 1280 : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN85@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [edx+40]
	jbe	SHORT $LN85@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN85@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN85@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [edx+48]
	jbe	SHORT $LN85@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN85@SfxClass

; 1281 :  	{
; 1282 : 	}
; 1283 : 	else

	jmp	SHORT $LN84@SfxClass
$LN85@SfxClass:

; 1284 : 	{
; 1285 : 		MonoPrint("Bad SFX Position Passed in!" );

	push	OFFSET ??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@
	call	_MonoPrint
	add	esp, 4

; 1286 : 		pos.x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 1287 : 		pos.y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+44], xmm0

; 1288 : 		pos.z = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+48], xmm0
$LN84@SfxClass:

; 1289 : 	}
; 1290 : 
; 1291 : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 1292 : 	switch( type ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv149[ebp], edx
	cmp	DWORD PTR tv149[ebp], 131		; 00000083H
	ja	$LN3@SfxClass
	mov	eax, DWORD PTR tv149[ebp]
	movzx	ecx, BYTE PTR $LN246@SfxClass[eax]
	jmp	DWORD PTR $LN248@SfxClass[ecx*4]
$LN81@SfxClass:

; 1293 : 		case SFX_SPARK_TRACER:
; 1294 : 			objTracer = /*(g_bUse_DX_Engine) ? new DXDrawableTracer( 0.1f * scale):*/ new DrawableTracer( 0.1f * scale);

	push	96					; 00000060H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T103[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T103[ebp], 0
	je	SHORT $LN88@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR [edx+104]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR $T103[ebp]
	call	??0DrawableTracer@@QAE@M@Z		; DrawableTracer::DrawableTracer
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN89@SfxClass
$LN88@SfxClass:
	mov	DWORD PTR tv161[ebp], 0
$LN89@SfxClass:
	mov	eax, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T52[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T52[ebp]
	mov	DWORD PTR [ecx+164], edx

; 1295 : 	  		objTracer->SetRGB( 1.0f, 1.0f, 0.8f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+164]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 1296 : 	  		objTracer->SetAlpha( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+164]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1297 : 	  		objTracer->SetWidth( 0.1f * scale );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR [eax+104]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1298 : 			break;

	jmp	$LN82@SfxClass
$LN80@SfxClass:

; 1299 : 		case SFX_SPARKS:
; 1300 :     		obj2d = new Drawable2D( DRAW2D_SPARKS, scale * 0.2f, &pos, 4, gGroundVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T101[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T101[ebp], 0
	je	SHORT $LN90@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gGroundVerts@@3PAUTpoint@@A	; gGroundVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR $T101[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv206[ebp], eax
	jmp	SHORT $LN91@SfxClass
$LN90@SfxClass:
	mov	DWORD PTR tv206[ebp], 0
$LN91@SfxClass:
	mov	eax, DWORD PTR tv206[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1301 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1302 : 			secondaryCount = (int)(timeToLive * 10.0f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 1303 : 			secondaryInterval = 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [edx+120], xmm0

; 1304 : 			break;

	jmp	$LN82@SfxClass
$LN79@SfxClass:

; 1305 : 		case SFX_WATER_WAKE_LARGE:
; 1306 :     		obj2d = new Drawable2D( DRAW2D_EXPLSTAR_GLOW, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T100[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T100[ebp], 0
	je	SHORT $LN92@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	14					; 0000000eH
	mov	ecx, DWORD PTR $T100[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv229[ebp], eax
	jmp	SHORT $LN93@SfxClass
$LN92@SfxClass:
	mov	DWORD PTR tv229[ebp], 0
$LN93@SfxClass:
	mov	edx, DWORD PTR tv229[ebp]
	mov	DWORD PTR $T49[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T49[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1307 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1308 : 			break;

	jmp	$LN82@SfxClass
$LN78@SfxClass:

; 1309 : 		case SFX_FIRE_EXPAND:
; 1310 :     		obj2d = new Drawable2D( DRAW2D_FIRE_EXPAND, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T98[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T98[ebp], 0
	je	SHORT $LN94@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	39					; 00000027H
	mov	ecx, DWORD PTR $T98[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv249[ebp], eax
	jmp	SHORT $LN95@SfxClass
$LN94@SfxClass:
	mov	DWORD PTR tv249[ebp], 0
$LN95@SfxClass:
	mov	eax, DWORD PTR tv249[ebp]
	mov	DWORD PTR $T25[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T25[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1311 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1312 : 			secondaryCount = (int)(timeToLive * 1.0f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 1313 : 			secondaryInterval = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+120], xmm0
$LN77@SfxClass:

; 1314 : 		case SFX_FIRE_EXPAND_NOSMOKE:
; 1315 :     		obj2d = new Drawable2D( DRAW2D_FIRE_EXPAND, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T97[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T97[ebp], 0
	je	SHORT $LN96@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	39					; 00000027H
	mov	ecx, DWORD PTR $T97[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN97@SfxClass
$LN96@SfxClass:
	mov	DWORD PTR tv275[ebp], 0
$LN97@SfxClass:
	mov	edx, DWORD PTR tv275[ebp]
	mov	DWORD PTR $T47[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T47[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1316 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1317 : 			break;

	jmp	$LN82@SfxClass
$LN76@SfxClass:

; 1318 : 		case SFX_CLUSTER_BOMB:
; 1319 :     		// obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );
; 1320 : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 1321 : 			break;

	jmp	$LN82@SfxClass
$LN75@SfxClass:

; 1322 : 		case SFX_WATER_CLOUD:
; 1323 :     		obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T95[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T95[ebp], 0
	je	SHORT $LN98@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T95[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv293[ebp], eax
	jmp	SHORT $LN99@SfxClass
$LN98@SfxClass:
	mov	DWORD PTR tv293[ebp], 0
$LN99@SfxClass:
	mov	ecx, DWORD PTR tv293[ebp]
	mov	DWORD PTR $T13[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR [edx+152], eax

; 1324 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1325 : 			timeToLive= min(timeToLiveSfx, timeToLive); // JPO allow shorter

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	comiss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	jbe	SHORT $LN100@SfxClass
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR tv303[ebp], xmm0
	jmp	SHORT $LN101@SfxClass
$LN100@SfxClass:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR tv303[ebp], xmm0
$LN101@SfxClass:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv303[ebp]
	movss	DWORD PTR [edx+100], xmm0

; 1326 : 			break;

	jmp	$LN82@SfxClass
$LN74@SfxClass:

; 1327 : 		case SFX_WATER_WAKE_SMALL:
; 1328 : 			//objTrail = new DrawableTrail(TRAIL_SAM);
; 1329 : 			rot = IMatrix;

	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 64					; 00000040H
	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	rep movsd

; 1330 : 			obj2d = new Drawable2D(DRAW2D_WATERWAKE, scale, &pos, &rot);

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T65[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T65[ebp], 0
	je	SHORT $LN102@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	63					; 0000003fH
	mov	ecx, DWORD PTR $T65[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@PAUTrotation@@@Z ; Drawable2D::Drawable2D
	mov	DWORD PTR tv320[ebp], eax
	jmp	SHORT $LN103@SfxClass
$LN102@SfxClass:
	mov	DWORD PTR tv320[ebp], 0
$LN103@SfxClass:
	mov	eax, DWORD PTR tv320[ebp]
	mov	DWORD PTR $T45[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T45[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1331 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1332 : 			timeToLive= min(timeToLiveSfx, timeToLive); // JPO allow shorter

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	comiss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	jbe	SHORT $LN104@SfxClass
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR tv330[ebp], xmm0
	jmp	SHORT $LN105@SfxClass
$LN104@SfxClass:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR tv330[ebp], xmm0
$LN105@SfxClass:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv330[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 1333 : 			break;

	jmp	$LN82@SfxClass
$LN73@SfxClass:

; 1334 : 
; 1335 : 		case SFX_BLUE_CLOUD:
; 1336 :     		obj2d = new Drawable2D( DRAW2D_BLUE_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T93[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T93[ebp], 0
	je	SHORT $LN106@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	54					; 00000036H
	mov	ecx, DWORD PTR $T93[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv344[ebp], eax
	jmp	SHORT $LN107@SfxClass
$LN106@SfxClass:
	mov	DWORD PTR tv344[ebp], 0
$LN107@SfxClass:
	mov	ecx, DWORD PTR tv344[ebp]
	mov	DWORD PTR $T23[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T23[ebp]
	mov	DWORD PTR [edx+152], eax

; 1337 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1338 : 			break;

	jmp	$LN82@SfxClass
$LN72@SfxClass:

; 1339 : 		case SFX_SHAPED_FIRE_DEBRIS:
; 1340 : 			// we need to set the x basis vector in the matrix based on
; 1341 : 			// the velocity of this object
; 1342 : 			len = (float)sqrt( vec.x * vec.x + vec.y * vec.y + vec.z * vec.z );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+56]
	mulss	xmm1, DWORD PTR [eax+56]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+60]
	mulss	xmm1, DWORD PTR [edx+60]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _len$[ebp]

; 1343 : 			rot.M11 = vec.x/len;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	divss	xmm0, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+64], xmm0

; 1344 : 			rot.M12 = vec.y/len;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	divss	xmm0, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+68], xmm0

; 1345 : 			rot.M13 = vec.z/len;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	divss	xmm0, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+72], xmm0

; 1346 :     		obj2d = new Drawable2D( DRAW2D_SHAPED_FIRE_DEBRIS, scale, &pos, &rot );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T91[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T91[ebp], 0
	je	SHORT $LN108@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	29					; 0000001dH
	mov	ecx, DWORD PTR $T91[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@PAUTrotation@@@Z ; Drawable2D::Drawable2D
	mov	DWORD PTR tv397[ebp], eax
	jmp	SHORT $LN109@SfxClass
$LN108@SfxClass:
	mov	DWORD PTR tv397[ebp], 0
$LN109@SfxClass:
	mov	eax, DWORD PTR tv397[ebp]
	mov	DWORD PTR $T43[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T43[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1347 : 			break;

	jmp	$LN82@SfxClass
$LN71@SfxClass:

; 1348 : 		case SFX_SMALL_HIT_EXPLOSION:
; 1349 :     		obj2d = new Drawable2D( DRAW2D_SMALL_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T90[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T90[ebp], 0
	je	SHORT $LN110@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR $T90[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv410[ebp], eax
	jmp	SHORT $LN111@SfxClass
$LN110@SfxClass:
	mov	DWORD PTR tv410[ebp], 0
$LN111@SfxClass:
	mov	edx, DWORD PTR tv410[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1350 : 			break;

	jmp	$LN82@SfxClass
$LN70@SfxClass:

; 1351 : 		case SFX_AC_AIR_EXPLOSION:
; 1352 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1353 :     		obj2d = new Drawable2D( DRAW2D_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T88[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T88[ebp], 0
	je	SHORT $LN112@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	24					; 00000018H
	mov	ecx, DWORD PTR $T88[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv423[ebp], eax
	jmp	SHORT $LN113@SfxClass
$LN112@SfxClass:
	mov	DWORD PTR tv423[ebp], 0
$LN113@SfxClass:
	mov	ecx, DWORD PTR tv423[ebp]
	mov	DWORD PTR $T41[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T41[ebp]
	mov	DWORD PTR [edx+152], eax

; 1354 : 			secondaryCount = (int)(timeToLive * 2.0f);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR __real@40000000
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], edx

; 1355 : 			secondaryInterval = 0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+120], xmm0

; 1356 : 			break;

	jmp	$LN82@SfxClass
$LN69@SfxClass:

; 1357 : 		case SFX_MISSILE_BURST:
; 1358 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1359 :     		obj2d = new Drawable2D( DRAW2D_SMALL_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T87[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T87[ebp], 0
	je	SHORT $LN114@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR $T87[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv442[ebp], eax
	jmp	SHORT $LN115@SfxClass
$LN114@SfxClass:
	mov	DWORD PTR tv442[ebp], 0
$LN115@SfxClass:
	mov	ecx, DWORD PTR tv442[ebp]
	mov	DWORD PTR $T21[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T21[ebp]
	mov	DWORD PTR [edx+152], eax

; 1360 : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 1361 : 			break;

	jmp	$LN82@SfxClass
$LN68@SfxClass:

; 1362 : 		case SFX_ROCKET_BURST:
; 1363 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1364 :     		obj2d = new Drawable2D( DRAW2D_SMALL_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T85[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T85[ebp], 0
	je	SHORT $LN116@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR $T85[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv488[ebp], eax
	jmp	SHORT $LN117@SfxClass
$LN116@SfxClass:
	mov	DWORD PTR tv488[ebp], 0
$LN117@SfxClass:
	mov	ecx, DWORD PTR tv488[ebp]
	mov	DWORD PTR $T39[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T39[ebp]
	mov	DWORD PTR [edx+152], eax

; 1365 : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 1366 : 			break;

	jmp	$LN82@SfxClass
$LN67@SfxClass:

; 1367 : 		case SFX_WATER_WAKE_MEDIUM:
; 1368 :     		obj2d = new Drawable2D( DRAW2D_EXPLCIRC_GLOW_FADE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T84[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	cmp	DWORD PTR $T84[ebp], 0
	je	SHORT $LN118@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	34					; 00000022H
	mov	ecx, DWORD PTR $T84[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv502[ebp], eax
	jmp	SHORT $LN119@SfxClass
$LN118@SfxClass:
	mov	DWORD PTR tv502[ebp], 0
$LN119@SfxClass:
	mov	ecx, DWORD PTR tv502[ebp]
	mov	DWORD PTR $T11[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR [edx+152], eax

; 1369 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1370 : 			break;

	jmp	$LN82@SfxClass
$LN66@SfxClass:

; 1371 : 		case SFX_AC_DEBRIS:
; 1372 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1373 :     		obj2d = new Drawable2D( DRAW2D_DARK_DEBRIS, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T82[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cmp	DWORD PTR $T82[ebp], 0
	je	SHORT $LN120@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	31					; 0000001fH
	mov	ecx, DWORD PTR $T82[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv519[ebp], eax
	jmp	SHORT $LN121@SfxClass
$LN120@SfxClass:
	mov	DWORD PTR tv519[ebp], 0
$LN121@SfxClass:
	mov	edx, DWORD PTR tv519[ebp]
	mov	DWORD PTR $T37[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T37[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1374 : 			break;

	jmp	$LN82@SfxClass
$LN65@SfxClass:

; 1375 : 		case SFX_CAT_LAUNCH:
; 1376 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1377 :     		obj2d = new Drawable2D( DRAW2D_FIRE_DEBRIS, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T81[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	cmp	DWORD PTR $T81[ebp], 0
	je	SHORT $LN122@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	32					; 00000020H
	mov	ecx, DWORD PTR $T81[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv532[ebp], eax
	jmp	SHORT $LN123@SfxClass
$LN122@SfxClass:
	mov	DWORD PTR tv532[ebp], 0
$LN123@SfxClass:
	mov	ecx, DWORD PTR tv532[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T19[ebp]
	mov	DWORD PTR [edx+152], eax

; 1378 : 			break;

	jmp	$LN82@SfxClass
$LN64@SfxClass:

; 1379 : 		case SFX_FLAME:
; 1380 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1381 :     		obj2d = new Drawable2D( DRAW2D_FLAME, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T79[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	cmp	DWORD PTR $T79[ebp], 0
	je	SHORT $LN124@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	38					; 00000026H
	mov	ecx, DWORD PTR $T79[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv545[ebp], eax
	jmp	SHORT $LN125@SfxClass
$LN124@SfxClass:
	mov	DWORD PTR tv545[ebp], 0
$LN125@SfxClass:
	mov	eax, DWORD PTR tv545[ebp]
	mov	DWORD PTR $T35[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T35[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1382 : 			break;

	jmp	$LN82@SfxClass
$LN63@SfxClass:

; 1383 : 		case SFX_FLARE_GFX:
; 1384 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1385 :     		obj2d = new Drawable2D( DRAW2D_LIGHT_DEBRIS, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T78[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	cmp	DWORD PTR $T78[ebp], 0
	je	SHORT $LN126@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	33					; 00000021H
	mov	ecx, DWORD PTR $T78[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv558[ebp], eax
	jmp	SHORT $LN127@SfxClass
$LN126@SfxClass:
	mov	DWORD PTR tv558[ebp], 0
$LN127@SfxClass:
	mov	edx, DWORD PTR tv558[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1386 : 			break;

	jmp	$LN82@SfxClass
$LN62@SfxClass:

; 1387 : 		case SFX_GROUNDBURST:
; 1388 :     		// obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );
; 1389 : 			if ( rand() & 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN61@SfxClass

; 1390 :     			obj2d = new Drawable2D( DRAW2D_LIGHT_DEBRIS, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T76[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	cmp	DWORD PTR $T76[ebp], 0
	je	SHORT $LN128@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	33					; 00000021H
	mov	ecx, DWORD PTR $T76[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv574[ebp], eax
	jmp	SHORT $LN129@SfxClass
$LN128@SfxClass:
	mov	DWORD PTR tv574[ebp], 0
$LN129@SfxClass:
	mov	ecx, DWORD PTR tv574[ebp]
	mov	DWORD PTR $T33[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T33[ebp]
	mov	DWORD PTR [edx+152], eax

; 1391 : 			else

	jmp	SHORT $LN60@SfxClass
$LN61@SfxClass:

; 1392 :     			obj2d = new Drawable2D( DRAW2D_DARK_DEBRIS, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T75[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	cmp	DWORD PTR $T75[ebp], 0
	je	SHORT $LN130@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	31					; 0000001fH
	mov	ecx, DWORD PTR $T75[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv587[ebp], eax
	jmp	SHORT $LN131@SfxClass
$LN130@SfxClass:
	mov	DWORD PTR tv587[ebp], 0
$LN131@SfxClass:
	mov	eax, DWORD PTR tv587[ebp]
	mov	DWORD PTR $T17[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T17[ebp]
	mov	DWORD PTR [ecx+152], edx
$LN60@SfxClass:

; 1393 : 			break;

	jmp	$LN82@SfxClass

; 1394 : 		case SFX_SMOKETRAIL:
; 1395 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1396 : 			//objTrail = new DrawableTrail(TRAIL_MISLSMOKE);
; 1397 : 			break;

	jmp	$LN82@SfxClass
$LN58@SfxClass:

; 1398 : 		case SFX_FIRE1:
; 1399 :     		obj2d = new Drawable2D( DRAW2D_FIRE1, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T73[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	cmp	DWORD PTR $T73[ebp], 0
	je	SHORT $LN132@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	44					; 0000002cH
	mov	ecx, DWORD PTR $T73[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv603[ebp], eax
	jmp	SHORT $LN133@SfxClass
$LN132@SfxClass:
	mov	DWORD PTR tv603[ebp], 0
$LN133@SfxClass:
	mov	edx, DWORD PTR tv603[ebp]
	mov	DWORD PTR $T31[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T31[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1400 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1401 : 			break;

	jmp	$LN82@SfxClass
$LN57@SfxClass:

; 1402 : 		case SFX_SHIP_BURNING_FIRE:
; 1403 :     		obj2d = new Drawable2D( DRAW2D_FIRE2, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	cmp	DWORD PTR $T72[ebp], 0
	je	SHORT $LN134@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	45					; 0000002dH
	mov	ecx, DWORD PTR $T72[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv623[ebp], eax
	jmp	SHORT $LN135@SfxClass
$LN134@SfxClass:
	mov	DWORD PTR tv623[ebp], 0
$LN135@SfxClass:
	mov	eax, DWORD PTR tv623[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1404 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1405 : 			break;

	jmp	$LN82@SfxClass
$LN56@SfxClass:

; 1406 : 		case SFX_CAT_RANDOM_STEAM:
; 1407 :     		obj2d = new Drawable2D( DRAW2D_FIRE3, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T70[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	cmp	DWORD PTR $T70[ebp], 0
	je	SHORT $LN136@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	46					; 0000002eH
	mov	ecx, DWORD PTR $T70[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv643[ebp], eax
	jmp	SHORT $LN137@SfxClass
$LN136@SfxClass:
	mov	DWORD PTR tv643[ebp], 0
$LN137@SfxClass:
	mov	ecx, DWORD PTR tv643[ebp]
	mov	DWORD PTR $T29[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T29[ebp]
	mov	DWORD PTR [edx+152], eax

; 1408 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1409 : 			break;

	jmp	$LN82@SfxClass
$LN55@SfxClass:

; 1410 : 		case SFX_CAT_STEAM:
; 1411 :     		obj2d = new Drawable2D( DRAW2D_FIRE4, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T69[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	cmp	DWORD PTR $T69[ebp], 0
	je	SHORT $LN138@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	47					; 0000002fH
	mov	ecx, DWORD PTR $T69[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv663[ebp], eax
	jmp	SHORT $LN139@SfxClass
$LN138@SfxClass:
	mov	DWORD PTR tv663[ebp], 0
$LN139@SfxClass:
	mov	edx, DWORD PTR tv663[ebp]
	mov	DWORD PTR $T15[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T15[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1412 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1413 : 			break;

	jmp	$LN82@SfxClass
$LN54@SfxClass:

; 1414 : 		case SFX_FIRE5:
; 1415 :     		obj2d = new Drawable2D( DRAW2D_FIRE5, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T67[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	cmp	DWORD PTR $T67[ebp], 0
	je	SHORT $LN140@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	48					; 00000030H
	mov	ecx, DWORD PTR $T67[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv683[ebp], eax
	jmp	SHORT $LN141@SfxClass
$LN140@SfxClass:
	mov	DWORD PTR tv683[ebp], 0
$LN141@SfxClass:
	mov	eax, DWORD PTR tv683[ebp]
	mov	DWORD PTR $T27[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T27[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1416 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1417 : 			break;

	jmp	$LN82@SfxClass
$LN53@SfxClass:

; 1418 : 		case SFX_FIRE6:
; 1419 :     		obj2d = new Drawable2D( DRAW2D_FIRE6, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T66[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	cmp	DWORD PTR $T66[ebp], 0
	je	SHORT $LN142@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR $T66[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv703[ebp], eax
	jmp	SHORT $LN143@SfxClass
$LN142@SfxClass:
	mov	DWORD PTR tv703[ebp], 0
$LN143@SfxClass:
	mov	ecx, DWORD PTR tv703[ebp]
	mov	DWORD PTR $T51[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T51[ebp]
	mov	DWORD PTR [edx+152], eax

; 1420 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1421 : 			break;

	jmp	$LN82@SfxClass
$LN52@SfxClass:

; 1422 : 		case SFX_DEBRISTRAIL:
; 1423 : 
; 1424 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1425 : 			//objTrail = new DrawableTrail(TRAIL_DARKSMOKE);
; 1426 : 			if ( (rand() & 3 ) == 3 )

	call	_rand
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN51@SfxClass

; 1427 :     			obj2d = new Drawable2D( DRAW2D_DARK_DEBRIS, 12.0f, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T54[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	cmp	DWORD PTR $T54[ebp], 0
	je	SHORT $LN144@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR [esp], xmm0
	push	31					; 0000001fH
	mov	ecx, DWORD PTR $T54[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv722[ebp], eax
	jmp	SHORT $LN145@SfxClass
$LN144@SfxClass:
	mov	DWORD PTR tv722[ebp], 0
$LN145@SfxClass:
	mov	ecx, DWORD PTR tv722[ebp]
	mov	DWORD PTR $T50[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T50[ebp]
	mov	DWORD PTR [edx+152], eax
$LN51@SfxClass:

; 1428 : 
; 1429 : 			/*
; 1430 : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 1431 : 				 gSfxCount[ SFX_TRAILSMOKE ] > gSfxLODCutoff )
; 1432 : 			{
; 1433 : 				objTrail = new DrawableTrail(TRAIL_SMOKE);
; 1434 : 				objTrail->SetScale( max( 1.0f, scale * 0.06f ) );
; 1435 : 			}
; 1436 : 			else
; 1437 : 			{
; 1438 : 				secondaryInterval = 1.0f * (1.0f-gSfxLOD) + 0.1f;
; 1439 : 				secondaryCount = (int)(timeToLive * (1.0f/secondaryInterval) );
; 1440 : 			}
; 1441 : 			*/
; 1442 : 			break;

	jmp	$LN82@SfxClass
$LN50@SfxClass:

; 1443 : 		case SFX_SAM_LAUNCH:
; 1444 :     		// obj2d = new Drawable2D( DRAW2D_STEAM_CLOUD, scale, &pos );
; 1445 : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 1446 : 			break;

	jmp	$LN82@SfxClass
$LN49@SfxClass:

; 1447 : 		case SFX_DEBRISTRAIL_DUST:
; 1448 : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 1449 : 				 gSfxCount[ SFX_VEHICLE_DUST ] > gSfxLODCutoff )

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN47@SfxClass
	mov	eax, 4
	imul	eax, 93					; 0000005dH
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jle	SHORT $LN48@SfxClass
$LN47@SfxClass:

; 1450 : 			{
; 1451 : 				//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1452 : 				//objTrail = new DrawableTrail(TRAIL_SMOKE);
; 1453 : 				//objTrail->SetScale( max( 1.0f, scale * 0.06f ) );
; 1454 : 			}
; 1455 : 			else

	jmp	SHORT $LN46@SfxClass
$LN48@SfxClass:

; 1456 : 			{
; 1457 : 				secondaryInterval = 1.0f * (1.0f-gSfxLOD) + 0.1f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@3dcccccd
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 1458 : 				secondaryCount = (int)(timeToLive * (1.0f/secondaryInterval) );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+100]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], edx
$LN46@SfxClass:

; 1459 : 			}
; 1460 : 			break;

	jmp	$LN82@SfxClass

; 1461 : 		case SFX_FIRETRAIL:
; 1462 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1463 : 			//objTrail = new DrawableTrail(TRAIL_FIRE2);
; 1464 : 
; 1465 : 			// edg: weird crash on this -- leave it out for now....
; 1466 :     		// obj2d = new Drawable2D( DRAW2D_DARK_DEBRIS, 10.0f, &pos );
; 1467 : 
; 1468 : 			/*
; 1469 : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 1470 : 				 gSfxCount[ SFX_FIRE_EXPAND ] > gSfxLODCutoff ||
; 1471 : 				 gSfxCount[ SFX_FIRE_EXPAND_NOSMOKE ] > gSfxLODCutoff )
; 1472 : 			{
; 1473 : 				objTrail = new DrawableTrail(TRAIL_MEDIUM_SAM);
; 1474 : 				objTrail->SetScale( max( 1.0f, scale * 0.06f ) );
; 1475 : 			}
; 1476 : 			else
; 1477 : 			{
; 1478 : 				secondaryInterval = 1.0f * (1.0f-gSfxLOD) + 0.1f;
; 1479 : 				secondaryCount = (int)(timeToLive * (1.0f/secondaryInterval) );
; 1480 : 			}
; 1481 : 			*/
; 1482 : 			break;

	jmp	$LN82@SfxClass
$LN44@SfxClass:

; 1483 : 		case SFX_FIREBALL:
; 1484 : 			if ( gTotSfx >= gSfxLODTotCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	SHORT $LN43@SfxClass

; 1485 : 			{
; 1486 : 				//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1487 : 				//objTrail = new DrawableTrail(TRAIL_MEDIUM_SAM);
; 1488 : 				//objTrail->SetScale( max( 1.0f, scale * 0.06f ) );
; 1489 : 			}
; 1490 : 			else

	jmp	SHORT $LN42@SfxClass
$LN43@SfxClass:

; 1491 : 			{
; 1492 : 				secondaryInterval = 1.0f * (1.0f-gSfxLOD) + 0.3f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@3e99999a
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 1493 : 				secondaryCount = (int)(timeToLive * (1.0f/secondaryInterval) );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+100]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], edx

; 1494 : 				initSecondaryCount = secondaryCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx+116], eax
$LN42@SfxClass:

; 1495 : 			}
; 1496 : 			break;

	jmp	$LN82@SfxClass
$LN41@SfxClass:

; 1497 : 		case SFX_WATER_FIREBALL:
; 1498 : 			if ( gTotSfx >= gSfxLODTotCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	SHORT $LN40@SfxClass

; 1499 : 			{
; 1500 : 				//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1501 : 				//objTrail = new DrawableTrail(TRAIL_MEDIUM_SAM);
; 1502 : 				//objTrail->SetScale( max( 1.0f, scale * 0.06f ) );
; 1503 : 			}
; 1504 : 			else

	jmp	SHORT $LN39@SfxClass
$LN40@SfxClass:

; 1505 : 			{
; 1506 : 				secondaryInterval = 1.0f * (1.0f-gSfxLOD) + 0.3f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@3e99999a
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 1507 : 				secondaryCount = (int)(timeToLive * (1.0f/secondaryInterval) );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+100]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], edx

; 1508 : 				initSecondaryCount = secondaryCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx+116], eax
$LN39@SfxClass:

; 1509 : 			}
; 1510 : 			break;

	jmp	$LN82@SfxClass
$LN38@SfxClass:

; 1511 : 		case SFX_WATERTRAIL:
; 1512 : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 1513 : 				 gSfxCount[ SFX_WATER_CLOUD ] > gSfxLODCutoff ||
; 1514 : 				 gSfxCount[ SFX_BLUE_CLOUD ] > gSfxLODCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN36@SfxClass
	mov	edx, 4
	imul	edx, 59					; 0000003bH
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN36@SfxClass
	mov	ecx, 4
	imul	ecx, 95					; 0000005fH
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jle	SHORT $LN37@SfxClass
$LN36@SfxClass:

; 1515 : 			{
; 1516 : 				//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1517 : 				//objTrail = new DrawableTrail(TRAIL_SAM);
; 1518 : 				//objTrail->SetScale( max( 1.0f, scale * 0.06f ) );
; 1519 : 			}
; 1520 : 			else

	jmp	SHORT $LN35@SfxClass
$LN37@SfxClass:

; 1521 : 			{
; 1522 : 				secondaryInterval = 1.0f * (1.0f-gSfxLOD) + 0.2f;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	mulss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 1523 : 				secondaryCount = (int)(timeToLive * (1.0f/secondaryInterval) );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+100]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 1524 : 				initSecondaryCount = secondaryCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [edx+116], ecx
$LN35@SfxClass:

; 1525 : 			}
; 1526 : 			break;

	jmp	$LN82@SfxClass
$LN34@SfxClass:

; 1527 : 		case SFX_DURANDAL:
; 1528 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1529 : 			//objTrail = new DrawableTrail(TRAIL_SAM);
; 1530 : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 1531 : 			break;

	jmp	$LN82@SfxClass
$LN33@SfxClass:

; 1532 : 		case SFX_AIR_SMOKECLOUD:
; 1533 :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T64[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	cmp	DWORD PTR $T64[ebp], 0
	je	SHORT $LN146@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T64[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv840[ebp], eax
	jmp	SHORT $LN147@SfxClass
$LN146@SfxClass:
	mov	DWORD PTR tv840[ebp], 0
$LN147@SfxClass:
	mov	edx, DWORD PTR tv840[ebp]
	mov	DWORD PTR $T48[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T48[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1534 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1535 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 1536 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 1537 : 			break;

	jmp	$LN82@SfxClass
$LN32@SfxClass:

; 1538 : 		case SFX_FIRESMOKE:
; 1539 : 			if ( rand() & 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN31@SfxClass

; 1540 :     			obj2d = new Drawable2D( DRAW2D_FIRESMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	cmp	DWORD PTR $T58[ebp], 0
	je	SHORT $LN148@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	50					; 00000032H
	mov	ecx, DWORD PTR $T58[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv872[ebp], eax
	jmp	SHORT $LN149@SfxClass
$LN148@SfxClass:
	mov	DWORD PTR tv872[ebp], 0
$LN149@SfxClass:
	mov	ecx, DWORD PTR tv872[ebp]
	mov	DWORD PTR $T46[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T46[ebp]
	mov	DWORD PTR [edx+152], eax

; 1541 : 			else

	jmp	SHORT $LN30@SfxClass
$LN31@SfxClass:

; 1542 :     			obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T63[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	cmp	DWORD PTR $T63[ebp], 0
	je	SHORT $LN150@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T63[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv885[ebp], eax
	jmp	SHORT $LN151@SfxClass
$LN150@SfxClass:
	mov	DWORD PTR tv885[ebp], 0
$LN151@SfxClass:
	mov	eax, DWORD PTR tv885[ebp]
	mov	DWORD PTR $T44[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T44[ebp]
	mov	DWORD PTR [ecx+152], edx
$LN30@SfxClass:

; 1543 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1544 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 1545 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1546 : 			break;

	jmp	$LN82@SfxClass
$LN29@SfxClass:

; 1547 : 		case SFX_TRAILSMOKE:
; 1548 :     		obj2d = new Drawable2D( DRAW2D_TRAILSMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T55[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	cmp	DWORD PTR $T55[ebp], 0
	je	SHORT $LN152@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	51					; 00000033H
	mov	ecx, DWORD PTR $T55[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv914[ebp], eax
	jmp	SHORT $LN153@SfxClass
$LN152@SfxClass:
	mov	DWORD PTR tv914[ebp], 0
$LN153@SfxClass:
	mov	edx, DWORD PTR tv914[ebp]
	mov	DWORD PTR $T42[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T42[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1549 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1550 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 1551 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 1552 : 			break;

	jmp	$LN82@SfxClass
$LN28@SfxClass:

; 1553 : 		case SFX_BIG_SMOKE:
; 1554 : 			if ( rand() & 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN27@SfxClass

; 1555 :     			obj2d = new Drawable2D( DRAW2D_BIG_SMOKE1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T62[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	cmp	DWORD PTR $T62[ebp], 0
	je	SHORT $LN154@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	59					; 0000003bH
	mov	ecx, DWORD PTR $T62[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv946[ebp], eax
	jmp	SHORT $LN155@SfxClass
$LN154@SfxClass:
	mov	DWORD PTR tv946[ebp], 0
$LN155@SfxClass:
	mov	ecx, DWORD PTR tv946[ebp]
	mov	DWORD PTR $T40[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T40[ebp]
	mov	DWORD PTR [edx+152], eax

; 1556 : 			else

	jmp	SHORT $LN26@SfxClass
$LN27@SfxClass:

; 1557 :     			obj2d = new Drawable2D( DRAW2D_BIG_SMOKE2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T57[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	cmp	DWORD PTR $T57[ebp], 0
	je	SHORT $LN156@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	60					; 0000003cH
	mov	ecx, DWORD PTR $T57[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv959[ebp], eax
	jmp	SHORT $LN157@SfxClass
$LN156@SfxClass:
	mov	DWORD PTR tv959[ebp], 0
$LN157@SfxClass:
	mov	eax, DWORD PTR tv959[ebp]
	mov	DWORD PTR $T38[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T38[ebp]
	mov	DWORD PTR [ecx+152], edx
$LN26@SfxClass:

; 1558 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1559 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 1560 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1561 : 			break;

	jmp	$LN82@SfxClass
$LN25@SfxClass:

; 1562 : 		case SFX_BIG_DUST:
; 1563 :     		obj2d = new Drawable2D( DRAW2D_BIG_DUST, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T61[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H
	cmp	DWORD PTR $T61[ebp], 0
	je	SHORT $LN158@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	61					; 0000003dH
	mov	ecx, DWORD PTR $T61[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv988[ebp], eax
	jmp	SHORT $LN159@SfxClass
$LN158@SfxClass:
	mov	DWORD PTR tv988[ebp], 0
$LN159@SfxClass:
	mov	edx, DWORD PTR tv988[ebp]
	mov	DWORD PTR $T36[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T36[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1564 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1565 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 1566 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 1567 : 			break;

	jmp	$LN82@SfxClass
$LN24@SfxClass:

; 1568 : 		case SFX_VEHICLE_DUST:
; 1569 :     		obj2d = new Drawable2D( DRAW2D_TRAILDUST, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T53[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 35		; 00000023H
	cmp	DWORD PTR $T53[ebp], 0
	je	SHORT $LN160@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	52					; 00000034H
	mov	ecx, DWORD PTR $T53[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1017[ebp], eax
	jmp	SHORT $LN161@SfxClass
$LN160@SfxClass:
	mov	DWORD PTR tv1017[ebp], 0
$LN161@SfxClass:
	mov	ecx, DWORD PTR tv1017[ebp]
	mov	DWORD PTR $T34[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T34[ebp]
	mov	DWORD PTR [edx+152], eax

; 1570 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1571 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1572 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 1573 : 			break;

	jmp	$LN82@SfxClass
$LN23@SfxClass:

; 1574 : 		case SFX_AIR_DUSTCLOUD:
; 1575 :     		obj2d = new Drawable2D( DRAW2D_AIR_DUSTCLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T60[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 36		; 00000024H
	cmp	DWORD PTR $T60[ebp], 0
	je	SHORT $LN162@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR $T60[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1046[ebp], eax
	jmp	SHORT $LN163@SfxClass
$LN162@SfxClass:
	mov	DWORD PTR tv1046[ebp], 0
$LN163@SfxClass:
	mov	eax, DWORD PTR tv1046[ebp]
	mov	DWORD PTR $T32[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T32[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1576 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1577 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 1578 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1579 : 			break;

	jmp	$LN82@SfxClass
$LN22@SfxClass:

; 1580 : 		case SFX_GROUND_DUSTCLOUD:
; 1581 : 			if ( gSfxCount[ SFX_GROUND_DUSTCLOUD ] < gSfxLODCutoff &&
; 1582 : 				 gTotSfx < gSfxLODTotCutoff )

	mov	eax, 4
	imul	eax, 79					; 0000004fH
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	$LN21@SfxClass
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	$LN21@SfxClass

; 1583 : 			{
; 1584 :     			obj2d = new Drawable2D( DRAW2D_GROUND_DUSTCLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T56[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 37		; 00000025H
	cmp	DWORD PTR $T56[ebp], 0
	je	SHORT $LN164@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	mov	ecx, DWORD PTR $T56[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1079[ebp], eax
	jmp	SHORT $LN165@SfxClass
$LN164@SfxClass:
	mov	DWORD PTR tv1079[ebp], 0
$LN165@SfxClass:
	mov	edx, DWORD PTR tv1079[ebp]
	mov	DWORD PTR $T30[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T30[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1585 : 				timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1586 : 			}
; 1587 : 			else

	jmp	SHORT $LN20@SfxClass
$LN21@SfxClass:

; 1588 : 			{
; 1589 : 				timeToLive = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+100], xmm0
$LN20@SfxClass:

; 1590 : 			}
; 1591 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 1592 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1593 : 			break;

	jmp	$LN82@SfxClass
$LN19@SfxClass:

; 1594 : 		case SFX_LANDING_SMOKE:
; 1595 :     		obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T59[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	cmp	DWORD PTR $T59[ebp], 0
	je	SHORT $LN166@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T59[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1109[ebp], eax
	jmp	SHORT $LN167@SfxClass
$LN166@SfxClass:
	mov	DWORD PTR tv1109[ebp], 0
$LN167@SfxClass:
	mov	edx, DWORD PTR tv1109[ebp]
	mov	DWORD PTR $T28[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T28[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1596 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1597 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 1598 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 1599 : 			break;

	jmp	$LN82@SfxClass
$LN18@SfxClass:

; 1600 : 		case SFX_STEAM_CLOUD:
; 1601 :     		obj2d = new Drawable2D( DRAW2D_STEAM_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T102[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 39		; 00000027H
	cmp	DWORD PTR $T102[ebp], 0
	je	SHORT $LN168@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	55					; 00000037H
	mov	ecx, DWORD PTR $T102[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1138[ebp], eax
	jmp	SHORT $LN169@SfxClass
$LN168@SfxClass:
	mov	DWORD PTR tv1138[ebp], 0
$LN169@SfxClass:
	mov	ecx, DWORD PTR tv1138[ebp]
	mov	DWORD PTR $T26[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T26[ebp]
	mov	DWORD PTR [edx+152], eax

; 1602 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 1603 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1604 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 1605 : 			break;

	jmp	$LN82@SfxClass
$LN17@SfxClass:

; 1606 : 		case SFX_AIR_SMOKECLOUD2:
; 1607 :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T99[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 40		; 00000028H
	cmp	DWORD PTR $T99[ebp], 0
	je	SHORT $LN170@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	13					; 0000000dH
	mov	ecx, DWORD PTR $T99[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1167[ebp], eax
	jmp	SHORT $LN171@SfxClass
$LN170@SfxClass:
	mov	DWORD PTR tv1167[ebp], 0
$LN171@SfxClass:
	mov	eax, DWORD PTR tv1167[ebp]
	mov	DWORD PTR $T24[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T24[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1608 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 1609 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+52], xmm0

; 1610 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1611 : 			break;

	jmp	$LN82@SfxClass
$LN16@SfxClass:

; 1612 : 		case SFX_GUNSMOKE:
; 1613 :     		obj2d = new Drawable2D( DRAW2D_GUNSMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T96[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 41		; 00000029H
	cmp	DWORD PTR $T96[ebp], 0
	je	SHORT $LN172@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T96[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1196[ebp], eax
	jmp	SHORT $LN173@SfxClass
$LN172@SfxClass:
	mov	DWORD PTR tv1196[ebp], 0
$LN173@SfxClass:
	mov	edx, DWORD PTR tv1196[ebp]
	mov	DWORD PTR $T22[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T22[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1614 : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 1615 : 			vec.x += gWindVect.x * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 1616 : 			vec.y += gWindVect.y * 2.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@40000000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 1617 : 			break;

	jmp	$LN82@SfxClass
$LN15@SfxClass:

; 1618 : 		case SFX_TRAIL_SMOKECLOUD:
; 1619 :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T94[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 42		; 0000002aH
	cmp	DWORD PTR $T94[ebp], 0
	je	SHORT $LN174@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T94[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1225[ebp], eax
	jmp	SHORT $LN175@SfxClass
$LN174@SfxClass:
	mov	DWORD PTR tv1225[ebp], 0
$LN175@SfxClass:
	mov	ecx, DWORD PTR tv1225[ebp]
	mov	DWORD PTR $T20[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T20[ebp]
	mov	DWORD PTR [edx+152], eax

; 1620 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1621 : 			//objTrail = new DrawableTrail(TRAIL_THINFIRE);
; 1622 : 			vec.x += gWindVect.x * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 1623 : 			vec.y += gWindVect.y * 1.0f;

	movss	xmm0, DWORD PTR ?gWindVect@@3UTpoint@@A+4
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 1624 : 			break;

	jmp	$LN82@SfxClass
$LN14@SfxClass:

; 1625 : 		case SFX_MISSILE_LAUNCH:
; 1626 :     		obj2d = new Drawable2D( DRAW2D_MISSILE_GLOW, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T92[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 43		; 0000002bH
	cmp	DWORD PTR $T92[ebp], 0
	je	SHORT $LN176@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	15					; 0000000fH
	mov	ecx, DWORD PTR $T92[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1250[ebp], eax
	jmp	SHORT $LN177@SfxClass
$LN176@SfxClass:
	mov	DWORD PTR tv1250[ebp], 0
$LN177@SfxClass:
	mov	ecx, DWORD PTR tv1250[ebp]
	mov	DWORD PTR $T18[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR [edx+152], eax

; 1627 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1628 : 			//objTrail = new DrawableTrail(TRAIL_SARH_MISSILE);
; 1629 : 			break;

	jmp	$LN82@SfxClass
$LN13@SfxClass:

; 1630 : 		case SFX_TRAIL_FIREBALL:
; 1631 :     		obj2d = new Drawable2D( DRAW2D_FLARE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T89[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 44		; 0000002cH
	cmp	DWORD PTR $T89[ebp], 0
	je	SHORT $LN178@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR $T89[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1263[ebp], eax
	jmp	SHORT $LN179@SfxClass
$LN178@SfxClass:
	mov	DWORD PTR tv1263[ebp], 0
$LN179@SfxClass:
	mov	eax, DWORD PTR tv1263[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T16[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1632 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1633 : 			//objTrail = new DrawableTrail(TRAIL_THINFIRE);
; 1634 : 			break;

	jmp	$LN82@SfxClass

; 1635 : 		case SFX_TRAIL_FIRE:
; 1636 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1637 : 			//objTrail = new DrawableTrail(TRAIL_THINFIRE);
; 1638 : 			break;

	jmp	$LN82@SfxClass
$LN11@SfxClass:

; 1639 : 		case SFX_GUNFIRE:
; 1640 :     		obj2d = new Drawable2D( DRAW2D_FLARE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T86[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 45		; 0000002dH
	cmp	DWORD PTR $T86[ebp], 0
	je	SHORT $LN180@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR $T86[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1276[ebp], eax
	jmp	SHORT $LN181@SfxClass
$LN180@SfxClass:
	mov	DWORD PTR tv1276[ebp], 0
$LN181@SfxClass:
	mov	edx, DWORD PTR tv1276[ebp]
	mov	DWORD PTR $T14[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T14[ebp]
	mov	DWORD PTR [eax+152], ecx

; 1641 : 			break;

	jmp	$LN82@SfxClass
$LN10@SfxClass:

; 1642 : 		case SFX_EJECT1:
; 1643 : 			// rot = IMatrix;
; 1644 : 			// at the moment ejection comes out sideways, swap vectors
; 1645 : 			rot.M11 = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+64], xmm0

; 1646 : 			rot.M12 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+68], xmm0

; 1647 : 			rot.M13 = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+72], xmm0

; 1648 : 			rot.M21 = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+76], xmm0

; 1649 : 			rot.M22 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+80], xmm0

; 1650 : 			rot.M23 = -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+84], xmm0

; 1651 : 			rot.M31 = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+88], xmm0

; 1652 : 			rot.M32 = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+92], xmm0

; 1653 : 			rot.M33 = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+96], xmm0

; 1654 : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 1655 :     		objBSP = new DrawableBSP( MapVisId(VIS_EJECT1), &pos, &rot, scale );

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T83[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 46		; 0000002eH
	cmp	DWORD PTR $T83[ebp], 0
	je	SHORT $LN182@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	push	64					; 00000040H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T83[ebp]
	call	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z ; DrawableBSP::DrawableBSP
	mov	DWORD PTR tv1344[ebp], eax
	jmp	SHORT $LN183@SfxClass
$LN182@SfxClass:
	mov	DWORD PTR tv1344[ebp], 0
$LN183@SfxClass:
	mov	eax, DWORD PTR tv1344[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [ecx+160], edx

; 1656 : 			break;

	jmp	$LN82@SfxClass
$LN9@SfxClass:

; 1657 : 		case SFX_EJECT2:
; 1658 : 			rot = IMatrix;

	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 64					; 00000040H
	mov	ecx, 9
	mov	esi, OFFSET ?IMatrix@@3UTrotation@@B	; IMatrix
	rep movsd

; 1659 :     		objBSP = new DrawableBSP( MapVisId(VIS_EJECT2), &pos, &rot, scale );

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T80[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 47		; 0000002fH
	cmp	DWORD PTR $T80[ebp], 0
	je	SHORT $LN184@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	push	65					; 00000041H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T80[ebp]
	call	??0DrawableBSP@@QAE@HPBUTpoint@@PBUTrotation@@M@Z ; DrawableBSP::DrawableBSP
	mov	DWORD PTR tv1362[ebp], eax
	jmp	SHORT $LN185@SfxClass
$LN184@SfxClass:
	mov	DWORD PTR tv1362[ebp], 0
$LN185@SfxClass:
	mov	eax, DWORD PTR tv1362[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+160], edx

; 1660 : 			break;

	jmp	$LN82@SfxClass
$LN8@SfxClass:

; 1661 : 		case SFX_TRACER_FIRE:
; 1662 : 			objTracer = /*(g_bUse_DX_Engine) ? new DXDrawableTracer(scale) :*/ new DrawableTracer(scale);

	push	96					; 00000060H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T77[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 48		; 00000030H
	cmp	DWORD PTR $T77[ebp], 0
	je	SHORT $LN186@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR $T77[ebp]
	call	??0DrawableTracer@@QAE@M@Z		; DrawableTracer::DrawableTracer
	mov	DWORD PTR tv1372[ebp], eax
	jmp	SHORT $LN187@SfxClass
$LN186@SfxClass:
	mov	DWORD PTR tv1372[ebp], 0
$LN187@SfxClass:
	mov	ecx, DWORD PTR tv1372[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR [edx+164], eax

; 1663 : 	  		objTracer->SetRGB( 1.0f, 1.0f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1664 : 	  		objTracer->SetAlpha( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1665 : 	  		objTracer->SetWidth( 2.0f * scale );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [ecx+104]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1666 : 			break;

	jmp	$LN82@SfxClass
$LN7@SfxClass:

; 1667 : 		case SFX_GUN_TRACER:
; 1668 :     		objTracer = /*(g_bUse_DX_Engine) ? new DXDrawableTracer(scale) :*/ new DrawableTracer(scale);

	push	96					; 00000060H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T74[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 49		; 00000031H
	cmp	DWORD PTR $T74[ebp], 0
	je	SHORT $LN188@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR $T74[ebp]
	call	??0DrawableTracer@@QAE@M@Z		; DrawableTracer::DrawableTracer
	mov	DWORD PTR tv1410[ebp], eax
	jmp	SHORT $LN189@SfxClass
$LN188@SfxClass:
	mov	DWORD PTR tv1410[ebp], 0
$LN189@SfxClass:
	mov	edx, DWORD PTR tv1410[ebp]
	mov	DWORD PTR $T6[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [eax+164], ecx

; 1669 : 	  		objTracer->SetRGB( 1.0f, 1.0f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1670 : 	  		objTracer->SetAlpha( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+164]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1671 : 	  		objTracer->SetWidth( 2.0f * scale );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [ecx+104]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 1672 : 			break;

	jmp	$LN82@SfxClass
$LN6@SfxClass:

; 1673 : 		case SFX_VERTICAL_SMOKE:
; 1674 :     		obj2d = new Drawable2D( DRAW2D_AIR_DUSTCLOUD, scale, &pos, 4, gWaterVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T71[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 50		; 00000032H
	cmp	DWORD PTR $T71[ebp], 0
	je	SHORT $LN190@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gWaterVerts@@3PAUTpoint@@A	; gWaterVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR $T71[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1454[ebp], eax
	jmp	SHORT $LN191@SfxClass
$LN190@SfxClass:
	mov	DWORD PTR tv1454[ebp], 0
$LN191@SfxClass:
	mov	eax, DWORD PTR tv1454[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+152], edx

; 1675 : 			break;

	jmp	SHORT $LN82@SfxClass

; 1676 : 		case SFX_PARTICLE_KLUDGE: // so it won't do that annoying "Bad SFX Type"
; 1677 : 			break;

	jmp	SHORT $LN82@SfxClass
$LN4@SfxClass:

; 1678 : 
; 1679 : 		//Cobra TJL 11/06/04 Added GUN_SMOKE for Steve and new PS
; 1680 : 		case SFX_GUN_SMOKE:
; 1681 :     		obj2d = new Drawable2D( DRAW2D_SMALL_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T68[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 51		; 00000033H
	cmp	DWORD PTR $T68[ebp], 0
	je	SHORT $LN192@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR $T68[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1467[ebp], eax
	jmp	SHORT $LN193@SfxClass
$LN192@SfxClass:
	mov	DWORD PTR tv1467[ebp], 0
$LN193@SfxClass:
	mov	edx, DWORD PTR tv1467[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+152], ecx
$LN3@SfxClass:
$LN82@SfxClass:

; 1682 : 			break;
; 1683 : 		default:
; 1684 : 			// VP_changes. This should be checked or modified - yeah. Oct 7, 2002.
; 1685 : 			ShiWarning ("Bad SFX Type");
; 1686 : 			break;
; 1687 : 	}
; 1688 : 
; 1689 : 
; 1690 : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 1691 : 
; 1692 : 	// update counters
; 1693 : 	gTotSfx++;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	eax, 1
	mov	DWORD PTR ?gTotSfx@@3HA, eax		; gTotSfx

; 1694 : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 1695 : 	{
; 1696 : 		gTotHighWaterSfx = gTotSfx;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, edx	; gTotHighWaterSfx
$LN2@SfxClass:

; 1697 : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 1698 : 	}
; 1699 : 	gSfxCount[ type ]++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[ecx*4], edx

; 1700 : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	cmp	eax, DWORD PTR ?gSfxHighWater@@3PAHA[edx*4]
	jle	SHORT $LN1@SfxClass

; 1701 : 	{
; 1702 : 		gSfxHighWater[type] = gSfxCount[type];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4], edx
$LN1@SfxClass:

; 1703 : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 1704 : 	}
; 1705 : 
; 1706 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	2
$LN248@SfxClass:
	DD	$LN70@SfxClass
	DD	$LN71@SfxClass
	DD	$LN33@SfxClass
	DD	$LN15@SfxClass
	DD	$LN13@SfxClass
	DD	$LN69@SfxClass
	DD	$LN10@SfxClass
	DD	$LN9@SfxClass
	DD	$LN23@SfxClass
	DD	$LN16@SfxClass
	DD	$LN17@SfxClass
	DD	$LN11@SfxClass
	DD	$LN50@SfxClass
	DD	$LN14@SfxClass
	DD	$LN67@SfxClass
	DD	$LN79@SfxClass
	DD	$LN8@SfxClass
	DD	$LN6@SfxClass
	DD	$LN80@SfxClass
	DD	$LN62@SfxClass
	DD	$LN52@SfxClass
	DD	$LN19@SfxClass
	DD	$LN75@SfxClass
	DD	$LN38@SfxClass
	DD	$LN7@SfxClass
	DD	$LN66@SfxClass
	DD	$LN65@SfxClass
	DD	$LN63@SfxClass
	DD	$LN64@SfxClass
	DD	$LN49@SfxClass
	DD	$LN78@SfxClass
	DD	$LN77@SfxClass
	DD	$LN22@SfxClass
	DD	$LN72@SfxClass
	DD	$LN44@SfxClass
	DD	$LN58@SfxClass
	DD	$LN57@SfxClass
	DD	$LN56@SfxClass
	DD	$LN55@SfxClass
	DD	$LN54@SfxClass
	DD	$LN53@SfxClass
	DD	$LN32@SfxClass
	DD	$LN29@SfxClass
	DD	$LN24@SfxClass
	DD	$LN73@SfxClass
	DD	$LN41@SfxClass
	DD	$LN76@SfxClass
	DD	$LN18@SfxClass
	DD	$LN34@SfxClass
	DD	$LN28@SfxClass
	DD	$LN25@SfxClass
	DD	$LN68@SfxClass
	DD	$LN81@SfxClass
	DD	$LN74@SfxClass
	DD	$LN4@SfxClass
	DD	$LN3@SfxClass
$LN246@SfxClass:
	DB	0
	DB	1
	DB	2
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	3
	DB	4
	DB	5
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	6
	DB	7
	DB	55					; 00000037H
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	14					; 0000000eH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	15					; 0000000fH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	16					; 00000010H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	17					; 00000011H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	18					; 00000012H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	19					; 00000013H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	20					; 00000014H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	28					; 0000001cH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	55					; 00000037H
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	46					; 0000002eH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	47					; 0000002fH
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	48					; 00000030H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	55					; 00000037H
	DB	51					; 00000033H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	52					; 00000034H
	DB	53					; 00000035H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	55					; 00000037H
	DB	54					; 00000036H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$1:
	mov	eax, DWORD PTR $T103[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$2:
	mov	eax, DWORD PTR $T101[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$3:
	mov	eax, DWORD PTR $T100[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$4:
	mov	eax, DWORD PTR $T98[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$5:
	mov	eax, DWORD PTR $T97[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$6:
	mov	eax, DWORD PTR $T95[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$7:
	mov	eax, DWORD PTR $T65[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$8:
	mov	eax, DWORD PTR $T93[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$9:
	mov	eax, DWORD PTR $T91[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$10:
	mov	eax, DWORD PTR $T90[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$11:
	mov	eax, DWORD PTR $T88[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$12:
	mov	eax, DWORD PTR $T87[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$13:
	mov	eax, DWORD PTR $T85[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$14:
	mov	eax, DWORD PTR $T84[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$15:
	mov	eax, DWORD PTR $T82[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$16:
	mov	eax, DWORD PTR $T81[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$17:
	mov	eax, DWORD PTR $T79[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$18:
	mov	eax, DWORD PTR $T78[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$19:
	mov	eax, DWORD PTR $T76[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$20:
	mov	eax, DWORD PTR $T75[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$21:
	mov	eax, DWORD PTR $T73[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$22:
	mov	eax, DWORD PTR $T72[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$23:
	mov	eax, DWORD PTR $T70[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$24:
	mov	eax, DWORD PTR $T69[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$25:
	mov	eax, DWORD PTR $T67[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$26:
	mov	eax, DWORD PTR $T66[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$27:
	mov	eax, DWORD PTR $T54[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$28:
	mov	eax, DWORD PTR $T64[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$29:
	mov	eax, DWORD PTR $T58[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$30:
	mov	eax, DWORD PTR $T63[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$31:
	mov	eax, DWORD PTR $T55[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$32:
	mov	eax, DWORD PTR $T62[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$33:
	mov	eax, DWORD PTR $T57[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$34:
	mov	eax, DWORD PTR $T61[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$35:
	mov	eax, DWORD PTR $T53[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$36:
	mov	eax, DWORD PTR $T60[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$37:
	mov	eax, DWORD PTR $T56[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$38:
	mov	eax, DWORD PTR $T59[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$39:
	mov	eax, DWORD PTR $T102[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$40:
	mov	eax, DWORD PTR $T99[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$41:
	mov	eax, DWORD PTR $T96[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$42:
	mov	eax, DWORD PTR $T94[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$43:
	mov	eax, DWORD PTR $T92[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$44:
	mov	eax, DWORD PTR $T89[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$45:
	mov	eax, DWORD PTR $T86[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$46:
	mov	eax, DWORD PTR $T83[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$47:
	mov	eax, DWORD PTR $T80[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$48:
	mov	eax, DWORD PTR $T77[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$49:
	mov	eax, DWORD PTR $T74[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$50:
	mov	eax, DWORD PTR $T71[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z$51:
	mov	eax, DWORD PTR $T68[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-644]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HHPAUTpoint@@0MM@Z ENDP		; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv393 = -44						; size = 4
tv206 = -40						; size = 4
tv193 = -36						; size = 4
tv192 = -32						; size = 4
tv173 = -28						; size = 4
tv81 = -24						; size = 4
tv203 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_posSfx$ = 12						; size = 4
_vecSfx$ = 16						; size = 4
_count$ = 20						; size = 4
_interval$ = 24						; size = 4
??0SfxClass@@QAE@HPAUTpoint@@0HM@Z PROC			; SfxClass::SfxClass
; _this$ = ecx

; 886  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 887  : 
; 888  : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 889  : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 890  : 	flags = SFX_SECONDARY_DRIVER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 8

; 891  : 	pos = *posSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _posSfx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 892  : 	vec = *vecSfx;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _vecSfx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 893  : 	timeToLive = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+100], xmm0

; 894  : 	scale = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+104], xmm0

; 895  : 	secondaryCount = min(count, 100);

	cmp	DWORD PTR _count$[ebp], 100		; 00000064H
	jge	SHORT $LN13@SfxClass
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	jmp	SHORT $LN14@SfxClass
$LN13@SfxClass:
	mov	DWORD PTR tv81[ebp], 100		; 00000064H
$LN14@SfxClass:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR [edx+112], eax

; 896  : 	secondaryInterval = interval;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _interval$[ebp]
	movss	DWORD PTR [ecx+120], xmm0

; 897  : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [edx+124], xmm0

; 898  : 	travelDist = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 899  : 
; 900  : 	objParticleSys = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+168], 0

; 901  : 	objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 902  : 	objTracer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 903  : 	objBSP = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 904  : 	obj2d = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 0

; 905  : 	//baseObj = NULL;
; 906  : 	endMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 0

; 907  : 	damMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 908  : 
; 909  : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 910  : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 911  : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN10@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [eax+40]
	jbe	SHORT $LN10@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN10@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [edx+44]
	jbe	SHORT $LN10@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [eax+48]
	jbe	SHORT $LN10@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN10@SfxClass

; 912  :  	{
; 913  : 	}
; 914  : 	else

	jmp	SHORT $LN9@SfxClass
$LN10@SfxClass:

; 915  : 	{
; 916  : 		MonoPrint( "Bad SFX Position Passed in!" );

	push	OFFSET ??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@
	call	_MonoPrint
	add	esp, 4

; 917  : 		pos.x = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+40], xmm0

; 918  : 		pos.y = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+44], xmm0

; 919  : 		pos.z = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+48], xmm0
$LN9@SfxClass:

; 920  : 	}
; 921  : 
; 922  : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 923  : 
; 924  : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 925  : 
; 926  : 	// for this type, vec.x and y are the dimensions of the explosion
; 927  : 	// volume ( z is movement up ).  Base the scale on the smaller of the
; 928  : 	// x and y
; 929  : 	if ( type ==  SFX_RISING_GROUNDHIT_EXPLOSION_DEBR )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 55			; 00000037H
	jne	$LN8@SfxClass

; 930  : 	{
; 931  : 		scale = min( 400.0f, max( vec.x * 1.5f, vec.y * 1.5f) );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+56]
	mulss	xmm1, DWORD PTR __real@3fc00000
	comiss	xmm0, xmm1
	jbe	SHORT $LN15@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv173[ebp], xmm0
	jmp	SHORT $LN16@SfxClass
$LN15@SfxClass:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv173[ebp], xmm0
$LN16@SfxClass:
	movss	xmm0, DWORD PTR tv173[ebp]
	comiss	xmm0, DWORD PTR __real@43c80000
	jbe	SHORT $LN19@SfxClass
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR tv193[ebp], xmm0
	jmp	SHORT $LN20@SfxClass
$LN19@SfxClass:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@3fc00000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+56]
	mulss	xmm1, DWORD PTR __real@3fc00000
	comiss	xmm0, xmm1
	jbe	SHORT $LN17@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv192[ebp], xmm0
	jmp	SHORT $LN18@SfxClass
$LN17@SfxClass:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv192[ebp], xmm0
$LN18@SfxClass:
	movss	xmm0, DWORD PTR tv192[ebp]
	movss	DWORD PTR tv193[ebp], xmm0
$LN20@SfxClass:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR [eax+104], xmm0
$LN8@SfxClass:

; 932  : 	}
; 933  : 
; 934  : 	// for feature chain reaction set scale to vec.x and set the timer to
; 935  : 	// go off at the next interval
; 936  : 	if ( type == SFX_FEATURE_CHAIN_REACTION )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 18			; 00000012H
	jne	SHORT $LN7@SfxClass

; 937  : 	{
; 938  : 		secondaryTimer += interval;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+124]
	addss	xmm0, DWORD PTR _interval$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+124], xmm0

; 939  : 		scale = vec.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+104], eax
$LN7@SfxClass:

; 940  : 	}
; 941  : 
; 942  : 	switch ( type )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv203[ebp], edx
	mov	eax, DWORD PTR tv203[ebp]
	sub	eax, 26					; 0000001aH
	mov	DWORD PTR tv203[ebp], eax
	cmp	DWORD PTR tv203[ebp], 9
	ja	$LN3@SfxClass
	mov	ecx, DWORD PTR tv203[ebp]
	movzx	edx, BYTE PTR $LN24@SfxClass[ecx]
	jmp	DWORD PTR $LN26@SfxClass[edx*4]
$LN4@SfxClass:

; 943  : 	{
; 944  : 		case SFX_DIST_AIRBURSTS:
; 945  : 		case SFX_DIST_GROUNDBURSTS:
; 946  : 		case SFX_DIST_ARMOR:
; 947  : 		case SFX_DIST_INFANTRY:
; 948  : 		case SFX_DIST_SAMLAUNCHES:
; 949  : 		case SFX_DIST_AALAUNCHES:
; 950  : 			// secondaryCount = (int)( ((float)count) * gSfxLOD );
; 951  : 			// secondaryInterval /= gSfxLOD;
; 952  : 			secondaryInterval = max( interval, 2.5f );

	movss	xmm0, DWORD PTR _interval$[ebp]
	comiss	xmm0, DWORD PTR __real@40200000
	jbe	SHORT $LN21@SfxClass
	movss	xmm0, DWORD PTR _interval$[ebp]
	movss	DWORD PTR tv206[ebp], xmm0
	jmp	SHORT $LN22@SfxClass
$LN21@SfxClass:
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR tv206[ebp], xmm0
$LN22@SfxClass:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 953  : 			secondaryTimer += PRANDFloatPos() * 15.0f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv393[ebp]
	movss	xmm0, DWORD PTR tv393[ebp]
	mulss	xmm0, DWORD PTR __real@41700000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+124]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+124], xmm0

; 954  : 			travelDist = (float)sqrt( vec.x * vec.x + vec.y * vec.y + vec.z * vec.z + 0.1f );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+56]
	mulss	xmm1, DWORD PTR [eax+56]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+60]
	mulss	xmm1, DWORD PTR [edx+60]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+108]
$LN3@SfxClass:

; 955  : 			break;
; 956  : 		default:
; 957  : 			break;
; 958  : 	}
; 959  : 
; 960  : 	// update counters
; 961  : 	gTotSfx++;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	ecx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, ecx		; gTotSfx

; 962  : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 963  : 	{
; 964  : 		gTotHighWaterSfx = gTotSfx;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, eax	; gTotHighWaterSfx
$LN2@SfxClass:

; 965  : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 966  : 	}
; 967  : 	gSfxCount[ type ]++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[edx*4], eax

; 968  : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	cmp	ecx, DWORD PTR ?gSfxHighWater@@3PAHA[eax*4]
	jle	SHORT $LN1@SfxClass

; 969  : 	{
; 970  : 		gSfxHighWater[type] = gSfxCount[type];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[edx*4], eax
$LN1@SfxClass:

; 971  : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 972  : 	}
; 973  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN26@SfxClass:
	DD	$LN4@SfxClass
	DD	$LN3@SfxClass
$LN24@SfxClass:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@0HM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HPAUTpoint@@0HM@Z ENDP			; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv287 = -32						; size = 4
tv158 = -28						; size = 4
tv85 = -24						; size = 4
tv155 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_posSfx$ = 12						; size = 4
_count$ = 16						; size = 4
_interval$ = 20						; size = 4
??0SfxClass@@QAE@HPAUTpoint@@HM@Z PROC			; SfxClass::SfxClass
; _this$ = ecx

; 800  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@HM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 801  : 
; 802  : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 803  : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 804  : 	flags = SFX_SECONDARY_DRIVER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 8

; 805  : 	pos = *posSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _posSfx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 806  : 	vec.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+52], xmm0

; 807  : 	vec.y = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+56], xmm0

; 808  : 	vec.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0

; 809  : 	timeToLive = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+100], xmm0

; 810  : 	scale = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+104], xmm0

; 811  : 	secondaryCount = min(count, 100);

	cmp	DWORD PTR _count$[ebp], 100		; 00000064H
	jge	SHORT $LN11@SfxClass
	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv85[ebp], edx
	jmp	SHORT $LN12@SfxClass
$LN11@SfxClass:
	mov	DWORD PTR tv85[ebp], 100		; 00000064H
$LN12@SfxClass:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR [eax+112], ecx

; 812  : 	secondaryInterval = interval;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _interval$[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 813  : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [eax+124], xmm0

; 814  : 	travelDist = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+108], xmm0

; 815  : 
; 816  : 	objParticleSys = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0

; 817  : 	objTrail = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 0

; 818  : 	objTracer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], 0

; 819  : 	objBSP = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+160], 0

; 820  : 	obj2d = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 0

; 821  : 	//baseObj = NULL;
; 822  : 	endMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 823  : 	damMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 824  : 
; 825  : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 826  : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 827  : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN8@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [ecx+40]
	jbe	SHORT $LN8@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN8@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	SHORT $LN8@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [ecx+48]
	jbe	SHORT $LN8@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN8@SfxClass

; 828  :  	{
; 829  : 	}
; 830  : 	else

	jmp	SHORT $LN7@SfxClass
$LN8@SfxClass:

; 831  : 	{
; 832  : 		MonoPrint( "Bad SFX Position Passed in!" );

	push	OFFSET ??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@
	call	_MonoPrint
	add	esp, 4

; 833  : 		pos.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 834  : 		pos.y = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+44], xmm0

; 835  : 		pos.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+48], xmm0
$LN7@SfxClass:

; 836  : 	}
; 837  : 
; 838  : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 839  : 
; 840  : 	switch ( type )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR tv155[ebp], ecx
	mov	edx, DWORD PTR tv155[ebp]
	sub	edx, 26					; 0000001aH
	mov	DWORD PTR tv155[ebp], edx
	cmp	DWORD PTR tv155[ebp], 9
	ja	SHORT $LN3@SfxClass
	mov	eax, DWORD PTR tv155[ebp]
	movzx	ecx, BYTE PTR $LN16@SfxClass[eax]
	jmp	DWORD PTR $LN18@SfxClass[ecx*4]
$LN4@SfxClass:

; 841  : 	{
; 842  : 		case SFX_DIST_AIRBURSTS:
; 843  : 		case SFX_DIST_GROUNDBURSTS:
; 844  : 		case SFX_DIST_ARMOR:
; 845  : 		case SFX_DIST_INFANTRY:
; 846  : 		case SFX_DIST_SAMLAUNCHES:
; 847  : 		case SFX_DIST_AALAUNCHES:
; 848  : 			// secondaryCount = (int)( ((float)count) * gSfxLOD );
; 849  : 			// secondaryInterval /= gSfxLOD;
; 850  : 			secondaryInterval = max( interval, 2.5f );

	movss	xmm0, DWORD PTR _interval$[ebp]
	comiss	xmm0, DWORD PTR __real@40200000
	jbe	SHORT $LN13@SfxClass
	movss	xmm0, DWORD PTR _interval$[ebp]
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN14@SfxClass
$LN13@SfxClass:
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR tv158[ebp], xmm0
$LN14@SfxClass:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR [edx+120], xmm0

; 851  : 			secondaryTimer += PRANDFloatPos() * 15.0f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv287[ebp]
	movss	xmm0, DWORD PTR tv287[ebp]
	mulss	xmm0, DWORD PTR __real@41700000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+124]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+124], xmm0
$LN3@SfxClass:

; 852  : 			break;
; 853  : 		default:
; 854  : 			break;
; 855  : 	}
; 856  : 
; 857  : 
; 858  : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 859  : 
; 860  : 	// update counters
; 861  : 	gTotSfx++;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	eax, 1
	mov	DWORD PTR ?gTotSfx@@3HA, eax		; gTotSfx

; 862  : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 863  : 	{
; 864  : 		gTotHighWaterSfx = gTotSfx;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, edx	; gTotHighWaterSfx
$LN2@SfxClass:

; 865  : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 866  : 	}
; 867  : 	gSfxCount[ type ]++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[ecx*4], edx

; 868  : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	cmp	eax, DWORD PTR ?gSfxHighWater@@3PAHA[edx*4]
	jle	SHORT $LN1@SfxClass

; 869  : 	{
; 870  : 		gSfxHighWater[type] = gSfxCount[type];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4], edx
$LN1@SfxClass:

; 871  : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 872  : 	}
; 873  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN18@SfxClass:
	DD	$LN4@SfxClass
	DD	$LN3@SfxClass
$LN16@SfxClass:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@HM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@HM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@HM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HPAUTpoint@@HM@Z ENDP			; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
$T2 = -864						; size = 4
$T3 = -860						; size = 4
$T4 = -856						; size = 4
$T5 = -852						; size = 4
$T6 = -848						; size = 4
$T7 = -844						; size = 4
$T8 = -840						; size = 4
$T9 = -836						; size = 4
$T10 = -832						; size = 4
$T11 = -828						; size = 4
$T12 = -824						; size = 4
$T13 = -820						; size = 4
$T14 = -816						; size = 4
$T15 = -812						; size = 4
$T16 = -808						; size = 4
$T17 = -804						; size = 4
$T18 = -800						; size = 4
$T19 = -796						; size = 4
$T20 = -792						; size = 4
$T21 = -788						; size = 4
$T22 = -784						; size = 4
$T23 = -780						; size = 4
$T24 = -776						; size = 4
$T25 = -772						; size = 4
$T26 = -768						; size = 4
$T27 = -764						; size = 4
$T28 = -760						; size = 4
$T29 = -756						; size = 4
$T30 = -752						; size = 4
$T31 = -748						; size = 4
$T32 = -744						; size = 4
$T33 = -740						; size = 4
$T34 = -736						; size = 4
$T35 = -732						; size = 4
$T36 = -728						; size = 4
$T37 = -724						; size = 4
$T38 = -720						; size = 4
$T39 = -716						; size = 4
$T40 = -712						; size = 4
$T41 = -708						; size = 4
$T42 = -704						; size = 4
tv2182 = -700						; size = 4
$T43 = -696						; size = 4
$T44 = -692						; size = 4
$T45 = -688						; size = 4
$T46 = -684						; size = 4
$T47 = -680						; size = 4
$T48 = -676						; size = 4
$T49 = -672						; size = 4
$T50 = -668						; size = 4
$T51 = -664						; size = 4
$T52 = -660						; size = 4
$T53 = -656						; size = 4
$T54 = -652						; size = 4
$T55 = -648						; size = 4
$T56 = -644						; size = 4
$T57 = -640						; size = 4
$T58 = -636						; size = 4
$T59 = -632						; size = 4
$T60 = -628						; size = 4
$T61 = -624						; size = 4
$T62 = -620						; size = 4
$T63 = -616						; size = 4
$T64 = -612						; size = 4
$T65 = -608						; size = 4
$T66 = -604						; size = 4
$T67 = -600						; size = 4
$T68 = -596						; size = 4
$T69 = -592						; size = 4
$T70 = -588						; size = 4
tv818 = -584						; size = 4
$T71 = -580						; size = 4
tv804 = -576						; size = 4
$T72 = -572						; size = 4
tv791 = -568						; size = 4
$T73 = -564						; size = 4
tv778 = -560						; size = 4
$T74 = -556						; size = 4
tv733 = -552						; size = 4
$T75 = -548						; size = 4
tv720 = -544						; size = 4
$T76 = -540						; size = 4
tv706 = -536						; size = 4
$T77 = -532						; size = 4
$T78 = -528						; size = 4
$T79 = -524						; size = 4
$T80 = -520						; size = 4
$T81 = -516						; size = 4
$T82 = -512						; size = 4
$T83 = -508						; size = 4
$T84 = -504						; size = 4
$T85 = -500						; size = 4
$T86 = -496						; size = 4
$T87 = -492						; size = 4
$T88 = -488						; size = 4
$T89 = -484						; size = 4
$T90 = -480						; size = 4
$T91 = -476						; size = 4
$T92 = -472						; size = 4
$T93 = -468						; size = 4
$T94 = -464						; size = 4
$T95 = -460						; size = 4
$T96 = -456						; size = 4
$T97 = -452						; size = 4
$T98 = -448						; size = 4
tv153 = -444						; size = 4
$T99 = -440						; size = 4
tv1112 = -436						; size = 4
$T100 = -432						; size = 4
tv1096 = -428						; size = 4
$T101 = -424						; size = 4
tv1080 = -420						; size = 4
$T102 = -416						; size = 4
tv1064 = -412						; size = 4
$T103 = -408						; size = 4
tv1012 = -404						; size = 4
$T104 = -400						; size = 4
tv992 = -396						; size = 4
$T105 = -392						; size = 4
tv972 = -388						; size = 4
$T106 = -384						; size = 4
tv956 = -380						; size = 4
$T107 = -376						; size = 4
tv930 = -372						; size = 4
$T108 = -368						; size = 4
tv908 = -364						; size = 4
$T109 = -360						; size = 4
tv886 = -356						; size = 4
$T110 = -352						; size = 4
tv873 = -348						; size = 4
$T111 = -344						; size = 4
tv860 = -340						; size = 4
$T112 = -336						; size = 4
tv847 = -332						; size = 4
$T113 = -328						; size = 4
tv834 = -324						; size = 4
$T114 = -320						; size = 4
tv820 = -316						; size = 4
$T115 = -312						; size = 4
$T116 = -308						; size = 4
tv1504 = -304						; size = 4
$T117 = -300						; size = 4
$T118 = -296						; size = 4
$T119 = -292						; size = 4
tv1490 = -288						; size = 4
$T120 = -284						; size = 4
$T121 = -280						; size = 4
$T122 = -276						; size = 4
tv1471 = -272						; size = 4
$T123 = -268						; size = 4
$T124 = -264						; size = 4
tv704 = -260						; size = 4
tv1452 = -256						; size = 4
tv691 = -252						; size = 4
$T125 = -248						; size = 4
tv670 = -244						; size = 4
tv1434 = -240						; size = 4
tv653 = -236						; size = 4
$T126 = -232						; size = 4
tv635 = -228						; size = 4
tv1421 = -224						; size = 4
tv614 = -220						; size = 4
$T127 = -216						; size = 4
tv588 = -212						; size = 4
tv1372 = -208						; size = 4
tv557 = -204						; size = 4
$T128 = -200						; size = 4
tv519 = -196						; size = 4
tv1359 = -192						; size = 4
tv506 = -188						; size = 4
$T129 = -184						; size = 4
tv489 = -180						; size = 4
tv1342 = -176						; size = 4
tv472 = -172						; size = 4
$T130 = -168						; size = 4
tv455 = -164						; size = 4
tv1329 = -160						; size = 4
tv438 = -156						; size = 4
$T131 = -152						; size = 4
tv421 = -148						; size = 4
tv1312 = -144						; size = 4
tv372 = -140						; size = 4
$T132 = -136						; size = 4
tv359 = -132						; size = 4
tv1281 = -128						; size = 4
tv342 = -124						; size = 4
$T133 = -120						; size = 4
tv325 = -116						; size = 4
tv1265 = -112						; size = 4
tv307 = -108						; size = 4
$T134 = -104						; size = 4
tv294 = -100						; size = 4
tv1230 = -96						; size = 4
tv274 = -92						; size = 4
$T135 = -88						; size = 4
tv260 = -84						; size = 4
tv1197 = -80						; size = 4
tv239 = -76						; size = 4
$T136 = -72						; size = 4
tv221 = -68						; size = 4
tv1180 = -64						; size = 4
tv208 = -60						; size = 4
$T137 = -56						; size = 4
tv195 = -52						; size = 4
tv1164 = -48						; size = 4
tv182 = -44						; size = 4
$T138 = -40						; size = 4
tv169 = -36						; size = 4
tv1148 = -32						; size = 4
tv155 = -28						; size = 4
$T139 = -24						; size = 4
tv1132 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_posSfx$ = 12						; size = 4
_timeToLiveSfx$ = 16					; size = 4
_scaleSfx$ = 20						; size = 4
??0SfxClass@@QAE@HPAUTpoint@@MM@Z PROC			; SfxClass::SfxClass
; _this$ = ecx

; 372  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 852				; 00000354H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 373  : 
; 374  : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 375  : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 376  : 	flags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 377  : 	pos = *posSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _posSfx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 378  : 	vec.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+52], xmm0

; 379  : 	vec.y = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+56], xmm0

; 380  : 	vec.z = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0

; 381  : 	timeToLive = timeToLiveSfx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 382  : 	// scale = scaleSfx * ( 0.6f + 0.4f * gSfxLOD );
; 383  : 	scale = scaleSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _scaleSfx$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 384  : 	secondaryCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0

; 385  : 	secondaryInterval = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+120], xmm0

; 386  : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [ecx+124], xmm0

; 387  : 	travelDist = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+108], xmm0

; 388  : 
; 389  : 	objParticleSys = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+168], 0

; 390  : 	objTrail = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 0

; 391  : 	objTracer = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], 0

; 392  : 	objBSP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 393  : 	obj2d = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0

; 394  : 	//baseObj = NULL;
; 395  : 	endMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 396  : 	damMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0

; 397  : 
; 398  : 	if ( pos.x > -10000.0f && pos.x < 10000000.0f &&
; 399  : 		 pos.y > -10000.0f && pos.y < 10000000.0f &&
; 400  : 		 pos.z < 8000.0f && pos.z > -150000.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN102@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [edx+40]
	jbe	SHORT $LN102@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	comiss	xmm0, DWORD PTR __real@c61c4000
	jbe	SHORT $LN102@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4b189680
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN102@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45fa0000
	comiss	xmm0, DWORD PTR [edx+48]
	jbe	SHORT $LN102@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	comiss	xmm0, DWORD PTR __real@c8127c00
	jbe	SHORT $LN102@SfxClass

; 401  :  	{
; 402  : 	}
; 403  : 	else

	jmp	SHORT $LN101@SfxClass
$LN102@SfxClass:

; 404  : 	{
; 405  : 		MonoPrint("Bad SFX Position Passed in!" );

	push	OFFSET ??_C@_0BM@HPCNGGBG@Bad?5SFX?5Position?5Passed?5in?$CB?$AA@
	call	_MonoPrint
	add	esp, 4

; 406  : 		pos.x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 407  : 		pos.y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+44], xmm0

; 408  : 		pos.z = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+48], xmm0
$LN101@SfxClass:

; 409  : 	}
; 410  : 
; 411  : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 412  : 	
; 413  : 	switch( type )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv153[ebp], edx
	cmp	DWORD PTR tv153[ebp], 132		; 00000084H
	ja	$LN3@SfxClass
	mov	eax, DWORD PTR tv153[ebp]
	movzx	ecx, BYTE PTR $LN313@SfxClass[eax]
	jmp	DWORD PTR $LN315@SfxClass[ecx*4]
$LN98@SfxClass:

; 414  : 	{
; 415  : 		case SFX_AC_AIR_EXPLOSION:
; 416  : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv155[ebp], eax
	cmp	DWORD PTR tv155[ebp], 3
	ja	$LN91@SfxClass
	mov	edx, DWORD PTR tv155[ebp]
	jmp	DWORD PTR $LN316@SfxClass[edx*4]
$LN95@SfxClass:

; 417  : 			{
; 418  : 				case 0:
; 419  :     				obj2d = new Drawable2D( DRAW2D_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T81[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T81[ebp], 0
	je	SHORT $LN105@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	24					; 00000018H
	mov	ecx, DWORD PTR $T81[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN106@SfxClass
$LN105@SfxClass:
	mov	DWORD PTR tv169[ebp], 0
$LN106@SfxClass:
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR $T70[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T70[ebp]
	mov	DWORD PTR [eax+152], ecx

; 420  : 					break;

	jmp	$LN96@SfxClass
$LN94@SfxClass:

; 421  : 				case 1:
; 422  :     				obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T115[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T115[ebp], 0
	je	SHORT $LN107@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR $T115[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN108@SfxClass
$LN107@SfxClass:
	mov	DWORD PTR tv182[ebp], 0
$LN108@SfxClass:
	mov	ecx, DWORD PTR tv182[ebp]
	mov	DWORD PTR $T68[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T68[ebp]
	mov	DWORD PTR [edx+152], eax

; 423  : 					break;

	jmp	$LN96@SfxClass
$LN93@SfxClass:

; 424  : 				case 2:
; 425  :     				obj2d = new Drawable2D( DRAW2D_CHEM_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T114[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T114[ebp], 0
	je	SHORT $LN109@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	7
	mov	ecx, DWORD PTR $T114[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN110@SfxClass
$LN109@SfxClass:
	mov	DWORD PTR tv195[ebp], 0
$LN110@SfxClass:
	mov	eax, DWORD PTR tv195[ebp]
	mov	DWORD PTR $T35[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T35[ebp]
	mov	DWORD PTR [ecx+152], edx

; 426  : 					break;

	jmp	$LN96@SfxClass
$LN92@SfxClass:

; 427  : 				case 3:
; 428  :     				obj2d = new Drawable2D( DRAW2D_DEBRIS_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T113[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T113[ebp], 0
	je	SHORT $LN111@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	9
	mov	ecx, DWORD PTR $T113[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv208[ebp], eax
	jmp	SHORT $LN112@SfxClass
$LN111@SfxClass:
	mov	DWORD PTR tv208[ebp], 0
$LN112@SfxClass:
	mov	edx, DWORD PTR tv208[ebp]
	mov	DWORD PTR $T66[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T66[ebp]
	mov	DWORD PTR [eax+152], ecx

; 429  : 					break;

	jmp	SHORT $LN96@SfxClass
$LN91@SfxClass:

; 430  : 				case 4:
; 431  : 				default:
; 432  :     				obj2d = new Drawable2D( DRAW2D_DEBRIS_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T112[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T112[ebp], 0
	je	SHORT $LN113@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	9
	mov	ecx, DWORD PTR $T112[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv221[ebp], eax
	jmp	SHORT $LN114@SfxClass
$LN113@SfxClass:
	mov	DWORD PTR tv221[ebp], 0
$LN114@SfxClass:
	mov	ecx, DWORD PTR tv221[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx+152], eax
$LN96@SfxClass:

; 433  : 					break;
; 434  : 			}
; 435  : 			timeToLive += 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+100], xmm0

; 436  : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 437  : 			break;

	jmp	$LN99@SfxClass
$LN90@SfxClass:

; 438  : 		case SFX_TRAILSMOKE:
; 439  :     		obj2d = new Drawable2D( DRAW2D_TRAILSMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T111[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T111[ebp], 0
	je	SHORT $LN115@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	51					; 00000033H
	mov	ecx, DWORD PTR $T111[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv239[ebp], eax
	jmp	SHORT $LN116@SfxClass
$LN115@SfxClass:
	mov	DWORD PTR tv239[ebp], 0
$LN116@SfxClass:
	mov	eax, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T64[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T64[ebp]
	mov	DWORD PTR [ecx+152], edx

; 440  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 441  : 			break;

	jmp	$LN99@SfxClass
$LN89@SfxClass:

; 442  : 		case SFX_AIR_EXPLOSION:
; 443  : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 444  : 			timeToLive += 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 445  :     		obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T110[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T110[ebp], 0
	je	SHORT $LN117@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR $T110[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv260[ebp], eax
	jmp	SHORT $LN118@SfxClass
$LN117@SfxClass:
	mov	DWORD PTR tv260[ebp], 0
$LN118@SfxClass:
	mov	ecx, DWORD PTR tv260[ebp]
	mov	DWORD PTR $T33[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T33[ebp]
	mov	DWORD PTR [edx+152], eax

; 446  : 			break;

	jmp	$LN99@SfxClass
$LN88@SfxClass:

; 447  : 		case SFX_INCENDIARY_EXPLOSION:
; 448  : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 449  :     		obj2d = new Drawable2D( DRAW2D_INCENDIARY_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T109[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T109[ebp], 0
	je	SHORT $LN119@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	62					; 0000003eH
	mov	ecx, DWORD PTR $T109[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv274[ebp], eax
	jmp	SHORT $LN120@SfxClass
$LN119@SfxClass:
	mov	DWORD PTR tv274[ebp], 0
$LN120@SfxClass:
	mov	ecx, DWORD PTR tv274[ebp]
	mov	DWORD PTR $T62[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T62[ebp]
	mov	DWORD PTR [edx+152], eax

; 450  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 451  : 			break;

	jmp	$LN99@SfxClass
$LN87@SfxClass:

; 452  : 		case SFX_AIR_EXPLOSION_NOGLOW:
; 453  : 			timeToLive += 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 454  :     		obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T108[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T108[ebp], 0
	je	SHORT $LN121@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR $T108[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv294[ebp], eax
	jmp	SHORT $LN122@SfxClass
$LN121@SfxClass:
	mov	DWORD PTR tv294[ebp], 0
$LN122@SfxClass:
	mov	ecx, DWORD PTR tv294[ebp]
	mov	DWORD PTR $T17[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T17[ebp]
	mov	DWORD PTR [edx+152], eax

; 455  : 			break;

	jmp	$LN99@SfxClass
$LN86@SfxClass:

; 456  : 		case SFX_LONG_HANGING_SMOKE:
; 457  :     		// obj2d = new Drawable2D( DRAW2D_LONG_HANGING_SMOKE, scale, &pos );
; 458  :     		obj2d = new Drawable2D( DRAW2D_LONG_HANGING_SMOKE2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T107[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T107[ebp], 0
	je	SHORT $LN123@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	37					; 00000025H
	mov	ecx, DWORD PTR $T107[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv307[ebp], eax
	jmp	SHORT $LN124@SfxClass
$LN123@SfxClass:
	mov	DWORD PTR tv307[ebp], 0
$LN124@SfxClass:
	mov	eax, DWORD PTR tv307[ebp]
	mov	DWORD PTR $T60[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T60[ebp]
	mov	DWORD PTR [ecx+152], edx

; 459  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 460  : 			break;

	jmp	$LN99@SfxClass
$LN85@SfxClass:

; 461  : 		case SFX_LONG_HANGING_SMOKE2:
; 462  : 			//objTrail = new DrawableTrail(30);
; 463  : 			timeToLive = 3000;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@453b8000
	movss	DWORD PTR [edx+100], xmm0

; 464  :     		//obj2d = new Drawable2D( DRAW2D_LONG_HANGING_SMOKE2, scale, &pos );
; 465  : 			//timeToLive = obj2d->GetAlphaTimeToLive();
; 466  : 			break;

	jmp	$LN99@SfxClass
$LN84@SfxClass:

; 467  : 		case SFX_FAST_FADING_SMOKE:
; 468  :     		obj2d = new Drawable2D( DRAW2D_FAST_FADING_SMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T106[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T106[ebp], 0
	je	SHORT $LN125@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	36					; 00000024H
	mov	ecx, DWORD PTR $T106[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv325[ebp], eax
	jmp	SHORT $LN126@SfxClass
$LN125@SfxClass:
	mov	DWORD PTR tv325[ebp], 0
$LN126@SfxClass:
	mov	edx, DWORD PTR tv325[ebp]
	mov	DWORD PTR $T31[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T31[ebp]
	mov	DWORD PTR [eax+152], ecx

; 469  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 470  : 			break;

	jmp	$LN99@SfxClass
$LN83@SfxClass:

; 471  : 		case SFX_AIR_DUSTCLOUD:
; 472  :     		obj2d = new Drawable2D( DRAW2D_AIR_DUSTCLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T105[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T105[ebp], 0
	je	SHORT $LN127@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	11					; 0000000bH
	mov	ecx, DWORD PTR $T105[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv342[ebp], eax
	jmp	SHORT $LN128@SfxClass
$LN127@SfxClass:
	mov	DWORD PTR tv342[ebp], 0
$LN128@SfxClass:
	mov	eax, DWORD PTR tv342[ebp]
	mov	DWORD PTR $T58[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T58[ebp]
	mov	DWORD PTR [ecx+152], edx

; 473  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 474  : 			break;

	jmp	$LN99@SfxClass
$LN82@SfxClass:

; 475  : 		case SFX_GROUND_DUSTCLOUD:
; 476  :     		obj2d = new Drawable2D( DRAW2D_GROUND_DUSTCLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T104[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T104[ebp], 0
	je	SHORT $LN129@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	mov	ecx, DWORD PTR $T104[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv359[ebp], eax
	jmp	SHORT $LN130@SfxClass
$LN129@SfxClass:
	mov	DWORD PTR tv359[ebp], 0
$LN130@SfxClass:
	mov	ecx, DWORD PTR tv359[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR [edx+152], eax

; 477  : 			break;

	jmp	$LN99@SfxClass
$LN81@SfxClass:

; 478  : 		case SFX_WATER_CLOUD:
; 479  :     		obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T103[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	cmp	DWORD PTR $T103[ebp], 0
	je	SHORT $LN131@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T103[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv372[ebp], eax
	jmp	SHORT $LN132@SfxClass
$LN131@SfxClass:
	mov	DWORD PTR tv372[ebp], 0
$LN132@SfxClass:
	mov	eax, DWORD PTR tv372[ebp]
	mov	DWORD PTR $T56[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T56[ebp]
	mov	DWORD PTR [ecx+152], edx

; 480  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 481  : 			break;

	jmp	$LN99@SfxClass
$LN80@SfxClass:

; 482  : 		case SFX_STEAM_CLOUD:
; 483  :     		obj2d = new Drawable2D( DRAW2D_STEAM_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T102[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cmp	DWORD PTR $T102[ebp], 0
	je	SHORT $LN133@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	55					; 00000037H
	mov	ecx, DWORD PTR $T102[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv421[ebp], eax
	jmp	SHORT $LN134@SfxClass
$LN133@SfxClass:
	mov	DWORD PTR tv421[ebp], 0
$LN134@SfxClass:
	mov	ecx, DWORD PTR tv421[ebp]
	mov	DWORD PTR $T29[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T29[ebp]
	mov	DWORD PTR [edx+152], eax

; 484  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 485  : 			break;

	jmp	$LN99@SfxClass
$LN79@SfxClass:

; 486  : 		case SFX_BLUE_CLOUD:
; 487  :     		obj2d = new Drawable2D( DRAW2D_BLUE_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T101[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	cmp	DWORD PTR $T101[ebp], 0
	je	SHORT $LN135@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	54					; 00000036H
	mov	ecx, DWORD PTR $T101[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv438[ebp], eax
	jmp	SHORT $LN136@SfxClass
$LN135@SfxClass:
	mov	DWORD PTR tv438[ebp], 0
$LN136@SfxClass:
	mov	edx, DWORD PTR tv438[ebp]
	mov	DWORD PTR $T54[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T54[ebp]
	mov	DWORD PTR [eax+152], ecx

; 488  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 489  : 			break;

	jmp	$LN99@SfxClass
$LN78@SfxClass:

; 490  : 		case SFX_LANDING_SMOKE:
; 491  :     		obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T100[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	cmp	DWORD PTR $T100[ebp], 0
	je	SHORT $LN137@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T100[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv455[ebp], eax
	jmp	SHORT $LN138@SfxClass
$LN137@SfxClass:
	mov	DWORD PTR tv455[ebp], 0
$LN138@SfxClass:
	mov	eax, DWORD PTR tv455[ebp]
	mov	DWORD PTR $T15[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T15[ebp]
	mov	DWORD PTR [ecx+152], edx

; 492  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 493  : 			break;

	jmp	$LN99@SfxClass
$LN77@SfxClass:

; 494  : 		case SFX_AIR_SMOKECLOUD:
; 495  :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T99[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	cmp	DWORD PTR $T99[ebp], 0
	je	SHORT $LN139@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T99[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv472[ebp], eax
	jmp	SHORT $LN140@SfxClass
$LN139@SfxClass:
	mov	DWORD PTR tv472[ebp], 0
$LN140@SfxClass:
	mov	ecx, DWORD PTR tv472[ebp]
	mov	DWORD PTR $T52[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T52[ebp]
	mov	DWORD PTR [edx+152], eax

; 496  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 497  : 			break;

	jmp	$LN99@SfxClass
$LN76@SfxClass:

; 498  : 		case SFX_AIR_SMOKECLOUD2:
; 499  :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T98[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	cmp	DWORD PTR $T98[ebp], 0
	je	SHORT $LN141@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	13					; 0000000dH
	mov	ecx, DWORD PTR $T98[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv489[ebp], eax
	jmp	SHORT $LN142@SfxClass
$LN141@SfxClass:
	mov	DWORD PTR tv489[ebp], 0
$LN142@SfxClass:
	mov	edx, DWORD PTR tv489[ebp]
	mov	DWORD PTR $T27[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T27[ebp]
	mov	DWORD PTR [eax+152], ecx

; 500  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 501  : 			break;

	jmp	$LN99@SfxClass
$LN75@SfxClass:

; 502  : 		case SFX_GUNFIRE:
; 503  :     		obj2d = new Drawable2D( DRAW2D_FLARE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T96[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	cmp	DWORD PTR $T96[ebp], 0
	je	SHORT $LN143@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR $T96[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv506[ebp], eax
	jmp	SHORT $LN144@SfxClass
$LN143@SfxClass:
	mov	DWORD PTR tv506[ebp], 0
$LN144@SfxClass:
	mov	eax, DWORD PTR tv506[ebp]
	mov	DWORD PTR $T50[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T50[ebp]
	mov	DWORD PTR [ecx+152], edx

; 504  : 			break;

	jmp	$LN99@SfxClass
$LN74@SfxClass:

; 505  : 		case SFX_GUNSMOKE:
; 506  :     		obj2d = new Drawable2D( DRAW2D_GUNSMOKE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T94[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	cmp	DWORD PTR $T94[ebp], 0
	je	SHORT $LN145@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T94[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv519[ebp], eax
	jmp	SHORT $LN146@SfxClass
$LN145@SfxClass:
	mov	DWORD PTR tv519[ebp], 0
$LN146@SfxClass:
	mov	edx, DWORD PTR tv519[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [eax+152], ecx

; 507  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 508  : 			break;

	jmp	$LN99@SfxClass
$LN73@SfxClass:

; 509  : 		case SFX_GROUND_PENETRATION:
; 510  : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 511  : 			break;

	jmp	$LN99@SfxClass
$LN72@SfxClass:

; 512  : 		case SFX_AIR_PENETRATION:
; 513  : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 514  : 			break;

	jmp	$LN99@SfxClass
$LN71@SfxClass:

; 515  : 		case SFX_GROUND_EXPLOSION:
; 516  : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 517  : 				 gSfxCount[ SFX_CAT_STEAM ] > gSfxLODCutoff ||
; 518  : 				 gSfxCount[ SFX_FIRE5 ] > gSfxLODCutoff )

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN69@SfxClass
	mov	ecx, 4
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN69@SfxClass
	mov	eax, 4
	imul	eax, 89					; 00000059H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jle	$LN70@SfxClass
$LN69@SfxClass:

; 519  : 			{
; 520  : 				scale *= 0.20f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+104], xmm0

; 521  : 				pos.z -= scale;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR [edx+104]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 522  :     			obj2d = new Drawable2D( DRAW2D_GROUND_STRIKE, scale, &pos, 4, gGroundVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T92[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	cmp	DWORD PTR $T92[ebp], 0
	je	SHORT $LN147@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gGroundVerts@@3PAUTpoint@@A	; gGroundVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	22					; 00000016H
	mov	ecx, DWORD PTR $T92[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv557[ebp], eax
	jmp	SHORT $LN148@SfxClass
$LN147@SfxClass:
	mov	DWORD PTR tv557[ebp], 0
$LN148@SfxClass:
	mov	eax, DWORD PTR tv557[ebp]
	mov	DWORD PTR $T48[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T48[ebp]
	mov	DWORD PTR [ecx+152], edx

; 523  : 				secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 524  : 			}
; 525  : 			else

	jmp	SHORT $LN68@SfxClass
$LN70@SfxClass:

; 526  : 			{
; 527  : 				pos.z -= scale;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR [edx+104]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 528  : 				secondaryCount = 10;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 10			; 0000000aH

; 529  : 				secondaryInterval = 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [edx+120], xmm0
$LN68@SfxClass:

; 530  : 			}
; 531  : 			break;

	jmp	$LN99@SfxClass
$LN67@SfxClass:

; 532  : 		case SFX_GROUND_EXPLOSION_NO_CRATER:
; 533  : 			pos.z -= scale;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR [ecx+104]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0

; 534  :     		obj2d = new Drawable2D( DRAW2D_GROUND_STRIKE, scale, &pos, 4, gGroundVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T90[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	cmp	DWORD PTR $T90[ebp], 0
	je	SHORT $LN149@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gGroundVerts@@3PAUTpoint@@A	; gGroundVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	22					; 00000016H
	mov	ecx, DWORD PTR $T90[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv588[ebp], eax
	jmp	SHORT $LN150@SfxClass
$LN149@SfxClass:
	mov	DWORD PTR tv588[ebp], 0
$LN150@SfxClass:
	mov	edx, DWORD PTR tv588[ebp]
	mov	DWORD PTR $T25[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T25[ebp]
	mov	DWORD PTR [eax+152], ecx

; 535  : 			break;

	jmp	$LN99@SfxClass
$LN66@SfxClass:

; 536  : 		case SFX_WATER_EXPLOSION:
; 537  : 			if ( gTotSfx >= gSfxLODTotCutoff )

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	$LN65@SfxClass

; 538  : 			{
; 539  : 				scale *= 0.20f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 540  : 				pos.z -= scale;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	subss	xmm0, DWORD PTR [eax+104]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 541  :     			obj2d = new Drawable2D( DRAW2D_WATER_STRIKE, scale, &pos, 4, gWaterVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T88[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	cmp	DWORD PTR $T88[ebp], 0
	je	SHORT $LN151@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gWaterVerts@@3PAUTpoint@@A	; gWaterVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	23					; 00000017H
	mov	ecx, DWORD PTR $T88[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv614[ebp], eax
	jmp	SHORT $LN152@SfxClass
$LN151@SfxClass:
	mov	DWORD PTR tv614[ebp], 0
$LN152@SfxClass:
	mov	ecx, DWORD PTR tv614[ebp]
	mov	DWORD PTR $T46[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T46[ebp]
	mov	DWORD PTR [edx+152], eax

; 542  : 			}
; 543  : 			else

	jmp	SHORT $LN64@SfxClass
$LN65@SfxClass:

; 544  : 			{
; 545  : 				pos.z -= scale;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR [edx+104]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm0
$LN64@SfxClass:

; 546  : 			}
; 547  : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 548  : 			break;

	jmp	$LN99@SfxClass
$LN63@SfxClass:

; 549  : 		case SFX_DUSTCLOUD:
; 550  :     		// obj2d = new Drawable2D( DRAW2D_SHOCK_RING, scale, &pos, 4, gShockVerts, gFireUvs );
; 551  :     		obj2d = new Drawable2D( DRAW2D_SHOCK_RING, scale, &pos, (struct Trotation *)&IMatrix );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T86[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	cmp	DWORD PTR $T86[ebp], 0
	je	SHORT $LN153@SfxClass
	push	OFFSET ?IMatrix@@3UTrotation@@B		; IMatrix
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	27					; 0000001bH
	mov	ecx, DWORD PTR $T86[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@PAUTrotation@@@Z ; Drawable2D::Drawable2D
	mov	DWORD PTR tv635[ebp], eax
	jmp	SHORT $LN154@SfxClass
$LN153@SfxClass:
	mov	DWORD PTR tv635[ebp], 0
$LN154@SfxClass:
	mov	ecx, DWORD PTR tv635[ebp]
	mov	DWORD PTR $T13[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR [edx+152], eax

; 552  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 553  : 			break;

	jmp	$LN99@SfxClass
$LN62@SfxClass:

; 554  : 		case SFX_SHOCK_RING_SMALL:
; 555  :     		// obj2d = new Drawable2D( DRAW2D_SHOCK_RING, scale, &pos, 4, gShockVerts, gFireUvs );
; 556  :     		obj2d = new Drawable2D( DRAW2D_SHOCK_RING_SMALL, scale, &pos, (struct Trotation *)&IMatrix );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T84[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	cmp	DWORD PTR $T84[ebp], 0
	je	SHORT $LN155@SfxClass
	push	OFFSET ?IMatrix@@3UTrotation@@B		; IMatrix
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	35					; 00000023H
	mov	ecx, DWORD PTR $T84[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@PAUTrotation@@@Z ; Drawable2D::Drawable2D
	mov	DWORD PTR tv653[ebp], eax
	jmp	SHORT $LN156@SfxClass
$LN155@SfxClass:
	mov	DWORD PTR tv653[ebp], 0
$LN156@SfxClass:
	mov	edx, DWORD PTR tv653[ebp]
	mov	DWORD PTR $T44[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T44[ebp]
	mov	DWORD PTR [eax+152], ecx

; 557  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 558  : 			break;

	jmp	$LN99@SfxClass
$LN61@SfxClass:

; 559  : 		case SFX_GROUND_FLASH:
; 560  :     		obj2d = new Drawable2D( DRAW2D_GROUND_FLASH, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T82[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	cmp	DWORD PTR $T82[ebp], 0
	je	SHORT $LN157@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	56					; 00000038H
	mov	ecx, DWORD PTR $T82[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv670[ebp], eax
	jmp	SHORT $LN158@SfxClass
$LN157@SfxClass:
	mov	DWORD PTR tv670[ebp], 0
$LN158@SfxClass:
	mov	eax, DWORD PTR tv670[ebp]
	mov	DWORD PTR $T23[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T23[ebp]
	mov	DWORD PTR [ecx+152], edx

; 561  : 			// SCR 11/17/98  Lets not draw ground flashes when its light out
; 562  : 			if (TheTimeOfDay.GetLightLevel() < 0.5f)

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetLightLevel@CTimeOfDay@@QAEMXZ	; CTimeOfDay::GetLightLevel
	fstp	DWORD PTR tv2182[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR tv2182[ebp]
	jbe	SHORT $LN60@SfxClass

; 563  : 			{
; 564  : 				timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 565  : 			} else {

	jmp	SHORT $LN59@SfxClass
$LN60@SfxClass:

; 566  : 				timeToLive = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+100], xmm0
$LN59@SfxClass:

; 567  : 			}
; 568  : 			break;

	jmp	$LN99@SfxClass
$LN58@SfxClass:

; 569  : 		case SFX_FEATURE_EXPLOSION:
; 570  :     		obj2d = new Drawable2D( DRAW2D_GROUND_GLOW, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T80[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	cmp	DWORD PTR $T80[ebp], 0
	je	SHORT $LN159@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	57					; 00000039H
	mov	ecx, DWORD PTR $T80[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv691[ebp], eax
	jmp	SHORT $LN160@SfxClass
$LN159@SfxClass:
	mov	DWORD PTR tv691[ebp], 0
$LN160@SfxClass:
	mov	edx, DWORD PTR tv691[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR [eax+152], ecx

; 571  : 			break;

	jmp	$LN99@SfxClass
$LN57@SfxClass:

; 572  : 		case SFX_MISSILE_BURST:
; 573  :     		obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T78[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	cmp	DWORD PTR $T78[ebp], 0
	je	SHORT $LN161@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR $T78[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv704[ebp], eax
	jmp	SHORT $LN162@SfxClass
$LN161@SfxClass:
	mov	DWORD PTR tv704[ebp], 0
$LN162@SfxClass:
	mov	ecx, DWORD PTR tv704[ebp]
	mov	DWORD PTR $T41[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T41[ebp]
	mov	DWORD PTR [edx+152], eax

; 574  : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 575  : 			// just testing this....
; 576  :     		// obj2d = new Drawable2D( DRAW2D_CLOUD1, 1.0f, &pos, 4, cverts, cuvs );
; 577  : 			// timeToLive = 30.0f;
; 578  : 			break;

	jmp	$LN99@SfxClass
$LN56@SfxClass:

; 579  : 		case SFX_SMALL_HIT_EXPLOSION:
; 580  : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv706[ebp], eax
	cmp	DWORD PTR tv706[ebp], 3
	ja	$LN49@SfxClass
	mov	edx, DWORD PTR tv706[ebp]
	jmp	DWORD PTR $LN317@SfxClass[edx*4]
$LN53@SfxClass:

; 581  : 			{
; 582  : 				case 0:
; 583  :     				obj2d = new Drawable2D( DRAW2D_SMALL_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T123[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	cmp	DWORD PTR $T123[ebp], 0
	je	SHORT $LN163@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR $T123[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv720[ebp], eax
	jmp	SHORT $LN164@SfxClass
$LN163@SfxClass:
	mov	DWORD PTR tv720[ebp], 0
$LN164@SfxClass:
	mov	edx, DWORD PTR tv720[ebp]
	mov	DWORD PTR $T21[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T21[ebp]
	mov	DWORD PTR [eax+152], ecx

; 584  : 					break;

	jmp	$LN54@SfxClass
$LN52@SfxClass:

; 585  : 				case 1:
; 586  :     				obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T122[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	cmp	DWORD PTR $T122[ebp], 0
	je	SHORT $LN165@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR $T122[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv733[ebp], eax
	jmp	SHORT $LN166@SfxClass
$LN165@SfxClass:
	mov	DWORD PTR tv733[ebp], 0
$LN166@SfxClass:
	mov	ecx, DWORD PTR tv733[ebp]
	mov	DWORD PTR $T39[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T39[ebp]
	mov	DWORD PTR [edx+152], eax

; 587  : 					break;

	jmp	$LN54@SfxClass
$LN51@SfxClass:

; 588  : 				case 2:
; 589  :     				obj2d = new Drawable2D( DRAW2D_SMALL_CHEM_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T120[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	cmp	DWORD PTR $T120[ebp], 0
	je	SHORT $LN167@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	6
	mov	ecx, DWORD PTR $T120[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv778[ebp], eax
	jmp	SHORT $LN168@SfxClass
$LN167@SfxClass:
	mov	DWORD PTR tv778[ebp], 0
$LN168@SfxClass:
	mov	eax, DWORD PTR tv778[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+152], edx

; 590  : 					break;

	jmp	$LN54@SfxClass
$LN50@SfxClass:

; 591  : 				case 3:
; 592  :     				obj2d = new Drawable2D( DRAW2D_SMALL_DEBRIS_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T119[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	cmp	DWORD PTR $T119[ebp], 0
	je	SHORT $LN169@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	8
	mov	ecx, DWORD PTR $T119[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv791[ebp], eax
	jmp	SHORT $LN170@SfxClass
$LN169@SfxClass:
	mov	DWORD PTR tv791[ebp], 0
$LN170@SfxClass:
	mov	edx, DWORD PTR tv791[ebp]
	mov	DWORD PTR $T37[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T37[ebp]
	mov	DWORD PTR [eax+152], ecx

; 593  : 					break;

	jmp	SHORT $LN54@SfxClass
$LN49@SfxClass:

; 594  : 				case 4:
; 595  : 				default:
; 596  :     				obj2d = new Drawable2D( DRAW2D_SMALL_DEBRIS_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T117[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H
	cmp	DWORD PTR $T117[ebp], 0
	je	SHORT $LN171@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	8
	mov	ecx, DWORD PTR $T117[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv804[ebp], eax
	jmp	SHORT $LN172@SfxClass
$LN171@SfxClass:
	mov	DWORD PTR tv804[ebp], 0
$LN172@SfxClass:
	mov	ecx, DWORD PTR tv804[ebp]
	mov	DWORD PTR $T19[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T19[ebp]
	mov	DWORD PTR [edx+152], eax
$LN54@SfxClass:

; 597  : 					break;
; 598  : 			}
; 599  : 			break;

	jmp	$LN99@SfxClass
$LN48@SfxClass:

; 600  : 		case SFX_AAA_EXPLOSION:
; 601  :     		obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T116[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 35		; 00000023H
	cmp	DWORD PTR $T116[ebp], 0
	je	SHORT $LN173@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR $T116[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv818[ebp], eax
	jmp	SHORT $LN174@SfxClass
$LN173@SfxClass:
	mov	DWORD PTR tv818[ebp], 0
$LN174@SfxClass:
	mov	eax, DWORD PTR tv818[ebp]
	mov	DWORD PTR $T69[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T69[ebp]
	mov	DWORD PTR [ecx+152], edx

; 602  : 			break;

	jmp	$LN99@SfxClass
$LN47@SfxClass:

; 603  : 		case SFX_CAMP_HIT_EXPLOSION_DEBRISTRAIL:
; 604  : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 605  : 			break;

	jmp	$LN99@SfxClass
$LN46@SfxClass:

; 606  : 		case SFX_HIT_EXPLOSION:
; 607  : 		case SFX_HIT_EXPLOSION_NOGLOW:
; 608  : 		case SFX_VEHICLE_EXPLOSION:
; 609  : 		case SFX_HIT_EXPLOSION_NOSMOKE:
; 610  : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv820[ebp], eax
	cmp	DWORD PTR tv820[ebp], 3
	ja	$LN39@SfxClass
	mov	ecx, DWORD PTR tv820[ebp]
	jmp	DWORD PTR $LN318@SfxClass[ecx*4]
$LN43@SfxClass:

; 611  : 			{
; 612  : 				case 0:
; 613  :     				obj2d = new Drawable2D( DRAW2D_HIT_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T97[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 36		; 00000024H
	cmp	DWORD PTR $T97[ebp], 0
	je	SHORT $LN175@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	24					; 00000018H
	mov	ecx, DWORD PTR $T97[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv834[ebp], eax
	jmp	SHORT $LN176@SfxClass
$LN175@SfxClass:
	mov	DWORD PTR tv834[ebp], 0
$LN176@SfxClass:
	mov	ecx, DWORD PTR tv834[ebp]
	mov	DWORD PTR $T67[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T67[ebp]
	mov	DWORD PTR [edx+152], eax

; 614  : 					break;

	jmp	$LN44@SfxClass
$LN42@SfxClass:

; 615  : 				case 1:
; 616  :     				obj2d = new Drawable2D( DRAW2D_AIR_EXPLOSION2, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T71[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 37		; 00000025H
	cmp	DWORD PTR $T71[ebp], 0
	je	SHORT $LN177@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	ecx, DWORD PTR $T71[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv847[ebp], eax
	jmp	SHORT $LN178@SfxClass
$LN177@SfxClass:
	mov	DWORD PTR tv847[ebp], 0
$LN178@SfxClass:
	mov	eax, DWORD PTR tv847[ebp]
	mov	DWORD PTR $T65[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T65[ebp]
	mov	DWORD PTR [ecx+152], edx

; 617  : 					break;

	jmp	$LN44@SfxClass
$LN41@SfxClass:

; 618  : 				case 2:
; 619  :     				obj2d = new Drawable2D( DRAW2D_CHEM_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T95[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	cmp	DWORD PTR $T95[ebp], 0
	je	SHORT $LN179@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	7
	mov	ecx, DWORD PTR $T95[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv860[ebp], eax
	jmp	SHORT $LN180@SfxClass
$LN179@SfxClass:
	mov	DWORD PTR tv860[ebp], 0
$LN180@SfxClass:
	mov	edx, DWORD PTR tv860[ebp]
	mov	DWORD PTR $T63[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T63[ebp]
	mov	DWORD PTR [eax+152], ecx

; 620  : 					break;

	jmp	$LN44@SfxClass
$LN40@SfxClass:

; 621  : 				case 3:
; 622  :     				obj2d = new Drawable2D( DRAW2D_DEBRIS_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T79[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 39		; 00000027H
	cmp	DWORD PTR $T79[ebp], 0
	je	SHORT $LN181@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	9
	mov	ecx, DWORD PTR $T79[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv873[ebp], eax
	jmp	SHORT $LN182@SfxClass
$LN181@SfxClass:
	mov	DWORD PTR tv873[ebp], 0
$LN182@SfxClass:
	mov	ecx, DWORD PTR tv873[ebp]
	mov	DWORD PTR $T61[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T61[ebp]
	mov	DWORD PTR [edx+152], eax

; 623  : 					break;

	jmp	SHORT $LN44@SfxClass
$LN39@SfxClass:

; 624  : 				case 4:
; 625  : 				default:
; 626  :     				obj2d = new Drawable2D( DRAW2D_DEBRIS_EXPLOSION, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T93[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 40		; 00000028H
	cmp	DWORD PTR $T93[ebp], 0
	je	SHORT $LN183@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	9
	mov	ecx, DWORD PTR $T93[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv886[ebp], eax
	jmp	SHORT $LN184@SfxClass
$LN183@SfxClass:
	mov	DWORD PTR tv886[ebp], 0
$LN184@SfxClass:
	mov	eax, DWORD PTR tv886[ebp]
	mov	DWORD PTR $T59[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T59[ebp]
	mov	DWORD PTR [ecx+152], edx
$LN44@SfxClass:

; 627  : 					break;
; 628  : 			}
; 629  : 			timeToLive += 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 630  : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 631  : 			// just testing this....
; 632  :     		// obj2d = new Drawable2D( DRAW2D_CLOUD1, 1.0f, &pos, 4, cverts, cuvs );
; 633  : 			// timeToLive = 30.0f;
; 634  : 			break;

	jmp	$LN99@SfxClass
$LN38@SfxClass:

; 635  : 		case SFX_VEHICLE_BURNING:
; 636  : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 637  : 			break;

	jmp	$LN99@SfxClass
$LN37@SfxClass:

; 638  : 		case SFX_FIRE:
; 639  :     		obj2d = new Drawable2D( DRAW2D_FIRE, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T74[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 41		; 00000029H
	cmp	DWORD PTR $T74[ebp], 0
	je	SHORT $LN185@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	21					; 00000015H
	mov	ecx, DWORD PTR $T74[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv908[ebp], eax
	jmp	SHORT $LN186@SfxClass
$LN185@SfxClass:
	mov	DWORD PTR tv908[ebp], 0
$LN186@SfxClass:
	mov	eax, DWORD PTR tv908[ebp]
	mov	DWORD PTR $T57[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T57[ebp]
	mov	DWORD PTR [ecx+152], edx

; 640  : 			secondaryCount = (int)(timeToLive * 1.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@3f800000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], ecx

; 641  : 			secondaryInterval = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+120], xmm0

; 642  : 			break;

	jmp	$LN99@SfxClass
$LN36@SfxClass:

; 643  : 		case SFX_FIRE_EXPAND:
; 644  :     		obj2d = new Drawable2D( DRAW2D_FIRE_EXPAND, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T91[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 42		; 0000002aH
	cmp	DWORD PTR $T91[ebp], 0
	je	SHORT $LN187@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	39					; 00000027H
	mov	ecx, DWORD PTR $T91[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv930[ebp], eax
	jmp	SHORT $LN188@SfxClass
$LN187@SfxClass:
	mov	DWORD PTR tv930[ebp], 0
$LN188@SfxClass:
	mov	eax, DWORD PTR tv930[ebp]
	mov	DWORD PTR $T55[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T55[ebp]
	mov	DWORD PTR [ecx+152], edx

; 645  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 646  : 			secondaryCount = (int)(timeToLive * 1.0f);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+100]
	mulss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 647  : 			secondaryInterval = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+120], xmm0

; 648  : 			break;

	jmp	$LN99@SfxClass
$LN35@SfxClass:

; 649  : 		case SFX_FIRE_NOSMOKE:
; 650  :     		obj2d = new Drawable2D( DRAW2D_FIRE, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T77[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 43		; 0000002bH
	cmp	DWORD PTR $T77[ebp], 0
	je	SHORT $LN189@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	21					; 00000015H
	mov	ecx, DWORD PTR $T77[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv956[ebp], eax
	jmp	SHORT $LN190@SfxClass
$LN189@SfxClass:
	mov	DWORD PTR tv956[ebp], 0
$LN190@SfxClass:
	mov	edx, DWORD PTR tv956[ebp]
	mov	DWORD PTR $T53[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T53[ebp]
	mov	DWORD PTR [eax+152], ecx

; 651  : 			break;

	jmp	$LN99@SfxClass
$LN34@SfxClass:

; 652  : 		case SFX_FIRE1:
; 653  :     		obj2d = new Drawable2D( DRAW2D_FIRE1, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T89[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 44		; 0000002cH
	cmp	DWORD PTR $T89[ebp], 0
	je	SHORT $LN191@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	44					; 0000002cH
	mov	ecx, DWORD PTR $T89[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv972[ebp], eax
	jmp	SHORT $LN192@SfxClass
$LN191@SfxClass:
	mov	DWORD PTR tv972[ebp], 0
$LN192@SfxClass:
	mov	ecx, DWORD PTR tv972[ebp]
	mov	DWORD PTR $T51[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T51[ebp]
	mov	DWORD PTR [edx+152], eax

; 654  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 655  : 			break;

	jmp	$LN99@SfxClass
$LN33@SfxClass:

; 656  : 		case SFX_SHIP_BURNING_FIRE:
; 657  :     		obj2d = new Drawable2D( DRAW2D_FIRE2, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T72[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 45		; 0000002dH
	cmp	DWORD PTR $T72[ebp], 0
	je	SHORT $LN193@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	45					; 0000002dH
	mov	ecx, DWORD PTR $T72[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv992[ebp], eax
	jmp	SHORT $LN194@SfxClass
$LN193@SfxClass:
	mov	DWORD PTR tv992[ebp], 0
$LN194@SfxClass:
	mov	edx, DWORD PTR tv992[ebp]
	mov	DWORD PTR $T49[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T49[ebp]
	mov	DWORD PTR [eax+152], ecx

; 658  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+100]

; 659  : 			break;

	jmp	$LN99@SfxClass
$LN32@SfxClass:

; 660  : 		case SFX_CAT_RANDOM_STEAM:
; 661  :     		obj2d = new Drawable2D( DRAW2D_FIRE3, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T87[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 46		; 0000002eH
	cmp	DWORD PTR $T87[ebp], 0
	je	SHORT $LN195@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	46					; 0000002eH
	mov	ecx, DWORD PTR $T87[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1012[ebp], eax
	jmp	SHORT $LN196@SfxClass
$LN195@SfxClass:
	mov	DWORD PTR tv1012[ebp], 0
$LN196@SfxClass:
	mov	eax, DWORD PTR tv1012[ebp]
	mov	DWORD PTR $T47[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T47[ebp]
	mov	DWORD PTR [ecx+152], edx

; 662  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]

; 663  : 			break;

	jmp	$LN99@SfxClass
$LN31@SfxClass:

; 664  : 		case SFX_CAT_STEAM:
; 665  :     		obj2d = new Drawable2D( DRAW2D_FIRE4, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T76[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 47		; 0000002fH
	cmp	DWORD PTR $T76[ebp], 0
	je	SHORT $LN197@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	47					; 0000002fH
	mov	ecx, DWORD PTR $T76[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1064[ebp], eax
	jmp	SHORT $LN198@SfxClass
$LN197@SfxClass:
	mov	DWORD PTR tv1064[ebp], 0
$LN198@SfxClass:
	mov	ecx, DWORD PTR tv1064[ebp]
	mov	DWORD PTR $T45[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T45[ebp]
	mov	DWORD PTR [edx+152], eax

; 666  : 			break;

	jmp	$LN99@SfxClass
$LN30@SfxClass:

; 667  : 		case SFX_FIRE5:
; 668  :     		obj2d = new Drawable2D( DRAW2D_FIRE5, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T85[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 48		; 00000030H
	cmp	DWORD PTR $T85[ebp], 0
	je	SHORT $LN199@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	48					; 00000030H
	mov	ecx, DWORD PTR $T85[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1080[ebp], eax
	jmp	SHORT $LN200@SfxClass
$LN199@SfxClass:
	mov	DWORD PTR tv1080[ebp], 0
$LN200@SfxClass:
	mov	eax, DWORD PTR tv1080[ebp]
	mov	DWORD PTR $T43[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T43[ebp]
	mov	DWORD PTR [ecx+152], edx

; 669  : 			break;

	jmp	$LN99@SfxClass
$LN29@SfxClass:

; 670  : 		case SFX_FIRE6:
; 671  :     		obj2d = new Drawable2D( DRAW2D_FIRE6, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T73[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 49		; 00000031H
	cmp	DWORD PTR $T73[ebp], 0
	je	SHORT $LN201@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	49					; 00000031H
	mov	ecx, DWORD PTR $T73[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1096[ebp], eax
	jmp	SHORT $LN202@SfxClass
$LN201@SfxClass:
	mov	DWORD PTR tv1096[ebp], 0
$LN202@SfxClass:
	mov	edx, DWORD PTR tv1096[ebp]
	mov	DWORD PTR $T42[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T42[ebp]
	mov	DWORD PTR [eax+152], ecx

; 672  : 			break;

	jmp	$LN99@SfxClass
$LN28@SfxClass:

; 673  : 		case SFX_FIRE7:
; 674  :     		obj2d = new Drawable2D( DRAW2D_FIRE7, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T83[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 50		; 00000032H
	cmp	DWORD PTR $T83[ebp], 0
	je	SHORT $LN203@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	53					; 00000035H
	mov	ecx, DWORD PTR $T83[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1112[ebp], eax
	jmp	SHORT $LN204@SfxClass
$LN203@SfxClass:
	mov	DWORD PTR tv1112[ebp], 0
$LN204@SfxClass:
	mov	ecx, DWORD PTR tv1112[ebp]
	mov	DWORD PTR $T40[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T40[ebp]
	mov	DWORD PTR [edx+152], eax

; 675  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 676  : 			break;

	jmp	$LN99@SfxClass
$LN27@SfxClass:

; 677  : 		case SFX_FIRE_HOT:
; 678  :     		obj2d = new Drawable2D( DRAW2D_FIRE_HOT, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T75[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 51		; 00000033H
	cmp	DWORD PTR $T75[ebp], 0
	je	SHORT $LN205@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	41					; 00000029H
	mov	ecx, DWORD PTR $T75[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1132[ebp], eax
	jmp	SHORT $LN206@SfxClass
$LN205@SfxClass:
	mov	DWORD PTR tv1132[ebp], 0
$LN206@SfxClass:
	mov	edx, DWORD PTR tv1132[ebp]
	mov	DWORD PTR $T38[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T38[ebp]
	mov	DWORD PTR [eax+152], ecx

; 679  : 			break;

	jmp	$LN99@SfxClass
$LN26@SfxClass:

; 680  : 		case SFX_FIRE_MED:
; 681  :     		obj2d = new Drawable2D( DRAW2D_FIRE_MED, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T139[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 52		; 00000034H
	cmp	DWORD PTR $T139[ebp], 0
	je	SHORT $LN207@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	42					; 0000002aH
	mov	ecx, DWORD PTR $T139[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1148[ebp], eax
	jmp	SHORT $LN208@SfxClass
$LN207@SfxClass:
	mov	DWORD PTR tv1148[ebp], 0
$LN208@SfxClass:
	mov	ecx, DWORD PTR tv1148[ebp]
	mov	DWORD PTR $T36[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T36[ebp]
	mov	DWORD PTR [edx+152], eax

; 682  : 			break;

	jmp	$LN99@SfxClass
$LN25@SfxClass:

; 683  : 		case SFX_FIRE_COOL:
; 684  :     		obj2d = new Drawable2D( DRAW2D_FIRE_COOL, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T138[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 53		; 00000035H
	cmp	DWORD PTR $T138[ebp], 0
	je	SHORT $LN209@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	43					; 0000002bH
	mov	ecx, DWORD PTR $T138[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1164[ebp], eax
	jmp	SHORT $LN210@SfxClass
$LN209@SfxClass:
	mov	DWORD PTR tv1164[ebp], 0
$LN210@SfxClass:
	mov	eax, DWORD PTR tv1164[ebp]
	mov	DWORD PTR $T34[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T34[ebp]
	mov	DWORD PTR [ecx+152], edx

; 685  : 			break;

	jmp	$LN99@SfxClass
$LN24@SfxClass:

; 686  : 		case SFX_FIRE_EXPAND_NOSMOKE:
; 687  :     		obj2d = new Drawable2D( DRAW2D_FIRE_EXPAND, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T137[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 54		; 00000036H
	cmp	DWORD PTR $T137[ebp], 0
	je	SHORT $LN211@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	39					; 00000027H
	mov	ecx, DWORD PTR $T137[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1180[ebp], eax
	jmp	SHORT $LN212@SfxClass
$LN211@SfxClass:
	mov	DWORD PTR tv1180[ebp], 0
$LN212@SfxClass:
	mov	edx, DWORD PTR tv1180[ebp]
	mov	DWORD PTR $T32[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T32[ebp]
	mov	DWORD PTR [eax+152], ecx

; 688  : 			break;

	jmp	$LN99@SfxClass
$LN23@SfxClass:

; 689  : 		case SFX_SPARKS:
; 690  : 		case SFX_SPARKS_NO_DEBRIS:
; 691  :     		obj2d = new Drawable2D( DRAW2D_SPARKS, scale * 0.2f, &pos, 4, gGroundVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T136[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 55		; 00000037H
	cmp	DWORD PTR $T136[ebp], 0
	je	SHORT $LN213@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gGroundVerts@@3PAUTpoint@@A	; gGroundVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	25					; 00000019H
	mov	ecx, DWORD PTR $T136[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1197[ebp], eax
	jmp	SHORT $LN214@SfxClass
$LN213@SfxClass:
	mov	DWORD PTR tv1197[ebp], 0
$LN214@SfxClass:
	mov	ecx, DWORD PTR tv1197[ebp]
	mov	DWORD PTR $T30[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T30[ebp]
	mov	DWORD PTR [edx+152], eax

; 692  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 693  : 			secondaryCount = (int)(timeToLive * 10.0f);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], ecx

; 694  : 			secondaryInterval = 0.1f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [eax+120], xmm0

; 695  : 			break;

	jmp	$LN99@SfxClass
$LN22@SfxClass:

; 696  : 		case SFX_ARTILLERY_EXPLOSION:
; 697  : 			pos.z -= scale * 0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+48]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm1

; 698  :     		obj2d = new Drawable2D( DRAW2D_ARTILLERY_EXPLOSION, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T135[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 56		; 00000038H
	cmp	DWORD PTR $T135[ebp], 0
	je	SHORT $LN215@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR $T135[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1230[ebp], eax
	jmp	SHORT $LN216@SfxClass
$LN215@SfxClass:
	mov	DWORD PTR tv1230[ebp], 0
$LN216@SfxClass:
	mov	eax, DWORD PTR tv1230[ebp]
	mov	DWORD PTR $T28[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T28[ebp]
	mov	DWORD PTR [ecx+152], edx

; 699  : 			pos.z += scale * 0.5f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0

; 700  : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 701  : 			break;

	jmp	$LN99@SfxClass
$LN21@SfxClass:

; 702  : 		case SFX_GROUND_STRIKE_NOFIRE:
; 703  : 			secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 704  : 			pos.z -= scale * 0.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+48]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm1

; 705  : 			if ( (rand() & 3 ) == 3 )

	call	_rand
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN20@SfxClass

; 706  :     			obj2d = new Drawable2D( DRAW2D_GROUND_STRIKE, scale, &pos, 4, gGroundVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T134[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 57		; 00000039H
	cmp	DWORD PTR $T134[ebp], 0
	je	SHORT $LN217@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gGroundVerts@@3PAUTpoint@@A	; gGroundVerts
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	22					; 00000016H
	mov	ecx, DWORD PTR $T134[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1265[ebp], eax
	jmp	SHORT $LN218@SfxClass
$LN217@SfxClass:
	mov	DWORD PTR tv1265[ebp], 0
$LN218@SfxClass:
	mov	ecx, DWORD PTR tv1265[ebp]
	mov	DWORD PTR $T26[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T26[ebp]
	mov	DWORD PTR [edx+152], eax

; 707  : 			else

	jmp	SHORT $LN19@SfxClass
$LN20@SfxClass:

; 708  :     			obj2d = new Drawable2D( DRAW2D_ARTILLERY_EXPLOSION, scale, &pos, 4, gFireVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T133[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 58		; 0000003aH
	cmp	DWORD PTR $T133[ebp], 0
	je	SHORT $LN219@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gFireVerts@@3PAUTpoint@@A	; gFireVerts
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	mov	ecx, DWORD PTR $T133[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1281[ebp], eax
	jmp	SHORT $LN220@SfxClass
$LN219@SfxClass:
	mov	DWORD PTR tv1281[ebp], 0
$LN220@SfxClass:
	mov	eax, DWORD PTR tv1281[ebp]
	mov	DWORD PTR $T24[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T24[ebp]
	mov	DWORD PTR [ecx+152], edx
$LN19@SfxClass:

; 709  : 			pos.z += scale * 0.5f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0

; 710  : 			break;

	jmp	$LN99@SfxClass
$LN18@SfxClass:

; 711  : 		case SFX_GROUND_STRIKE:
; 712  : 			secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 713  : 			if ( gTotSfx >= gSfxLODTotCutoff ||
; 714  : 				 gSfxCount[ SFX_CAT_STEAM ] > gSfxLODCutoff ||
; 715  : 				 gSfxCount[ SFX_FIRE5 ] > gSfxLODCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN16@SfxClass
	mov	edx, 4
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN16@SfxClass
	mov	ecx, 4
	imul	ecx, 89					; 00000059H
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jle	SHORT $LN17@SfxClass
$LN16@SfxClass:

; 716  : 			{
; 717  :     			obj2d = new Drawable2D( DRAW2D_GROUND_STRIKE, scale, &pos, 4, gGroundVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T132[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 59		; 0000003bH
	cmp	DWORD PTR $T132[ebp], 0
	je	SHORT $LN221@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gGroundVerts@@3PAUTpoint@@A	; gGroundVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	22					; 00000016H
	mov	ecx, DWORD PTR $T132[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1312[ebp], eax
	jmp	SHORT $LN222@SfxClass
$LN221@SfxClass:
	mov	DWORD PTR tv1312[ebp], 0
$LN222@SfxClass:
	mov	edx, DWORD PTR tv1312[ebp]
	mov	DWORD PTR $T22[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T22[ebp]
	mov	DWORD PTR [eax+152], ecx
$LN17@SfxClass:

; 718  : 			}
; 719  : 			break;

	jmp	$LN99@SfxClass
$LN15@SfxClass:

; 720  : 		case SFX_WATER_STRIKE:
; 721  : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 722  :     		obj2d = new Drawable2D( DRAW2D_WATER_STRIKE, scale, &pos, 4, gWaterVerts, gFireUvs );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 60		; 0000003cH
	cmp	DWORD PTR $T131[ebp], 0
	je	SHORT $LN223@SfxClass
	push	OFFSET ?gFireUvs@@3PAUTpoint@@A		; gFireUvs
	push	OFFSET ?gWaterVerts@@3PAUTpoint@@A	; gWaterVerts
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	23					; 00000017H
	mov	ecx, DWORD PTR $T131[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@H00@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1329[ebp], eax
	jmp	SHORT $LN224@SfxClass
$LN223@SfxClass:
	mov	DWORD PTR tv1329[ebp], 0
$LN224@SfxClass:
	mov	edx, DWORD PTR tv1329[ebp]
	mov	DWORD PTR $T20[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T20[ebp]
	mov	DWORD PTR [eax+152], ecx

; 723  : 			break;

	jmp	$LN99@SfxClass
$LN14@SfxClass:

; 724  : 		case SFX_CLUSTER_BURST:
; 725  :     		obj2d = new Drawable2D( DRAW2D_SMOKECLOUD1, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T130[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 61		; 0000003dH
	cmp	DWORD PTR $T130[ebp], 0
	je	SHORT $LN225@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR $T130[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1342[ebp], eax
	jmp	SHORT $LN226@SfxClass
$LN225@SfxClass:
	mov	DWORD PTR tv1342[ebp], 0
$LN226@SfxClass:
	mov	ecx, DWORD PTR tv1342[ebp]
	mov	DWORD PTR $T18[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR [edx+152], eax

; 726  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 727  : 			break;

	jmp	$LN99@SfxClass
$LN13@SfxClass:

; 728  : 		case SFX_CHAFF:
; 729  :     		obj2d = new Drawable2D( DRAW2D_EXPLCROSS_GLOW, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T129[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 62		; 0000003eH
	cmp	DWORD PTR $T129[ebp], 0
	je	SHORT $LN227@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	17					; 00000011H
	mov	ecx, DWORD PTR $T129[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1359[ebp], eax
	jmp	SHORT $LN228@SfxClass
$LN227@SfxClass:
	mov	DWORD PTR tv1359[ebp], 0
$LN228@SfxClass:
	mov	edx, DWORD PTR tv1359[ebp]
	mov	DWORD PTR $T16[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR [eax+152], ecx

; 730  : 			break;

	jmp	$LN99@SfxClass
$LN12@SfxClass:

; 731  : 		case SFX_WATER_WAKE_LARGE:
; 732  :     		obj2d = new Drawable2D( DRAW2D_EXPLSTAR_GLOW, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T128[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 63		; 0000003fH
	cmp	DWORD PTR $T128[ebp], 0
	je	SHORT $LN229@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	14					; 0000000eH
	mov	ecx, DWORD PTR $T128[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1372[ebp], eax
	jmp	SHORT $LN230@SfxClass
$LN229@SfxClass:
	mov	DWORD PTR tv1372[ebp], 0
$LN230@SfxClass:
	mov	ecx, DWORD PTR tv1372[ebp]
	mov	DWORD PTR $T14[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR [edx+152], eax

; 733  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+100]

; 734  : 			break;

	jmp	$LN99@SfxClass
$LN11@SfxClass:

; 735  : 		case SFX_WATER_WAKE_MEDIUM:
; 736  :     		obj2d = new Drawable2D( DRAW2D_EXPLCIRC_GLOW_FADE, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T127[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 64		; 00000040H
	cmp	DWORD PTR $T127[ebp], 0
	je	SHORT $LN231@SfxClass
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	push	34					; 00000022H
	mov	ecx, DWORD PTR $T127[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1421[ebp], eax
	jmp	SHORT $LN232@SfxClass
$LN231@SfxClass:
	mov	DWORD PTR tv1421[ebp], 0
$LN232@SfxClass:
	mov	edx, DWORD PTR tv1421[ebp]
	mov	DWORD PTR $T12[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [eax+152], ecx

; 737  : 			break;

	jmp	$LN99@SfxClass
$LN10@SfxClass:

; 738  : 		case SFX_WATERCLOUD:
; 739  :     		obj2d = new Drawable2D( DRAW2D_SMOKERING, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T126[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 65		; 00000041H
	cmp	DWORD PTR $T126[ebp], 0
	je	SHORT $LN233@SfxClass
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR [esp], xmm0
	push	5
	mov	ecx, DWORD PTR $T126[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1434[ebp], eax
	jmp	SHORT $LN234@SfxClass
$LN233@SfxClass:
	mov	DWORD PTR tv1434[ebp], 0
$LN234@SfxClass:
	mov	ecx, DWORD PTR tv1434[ebp]
	mov	DWORD PTR $T10[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [edx+152], eax

; 740  : 			break;

	jmp	$LN99@SfxClass
$LN9@SfxClass:

; 741  : 		case SFX_CRATER2:
; 742  :     		objBSP = new DrawableGroundVehicle( MapVisId(VIS_CRATER2),  &pos, 0.0f, 1.0f  );

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T125[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 66		; 00000042H
	cmp	DWORD PTR $T125[ebp], 0
	je	SHORT $LN235@SfxClass
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	push	127					; 0000007fH
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T125[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv1452[ebp], eax
	jmp	SHORT $LN236@SfxClass
$LN235@SfxClass:
	mov	DWORD PTR tv1452[ebp], 0
$LN236@SfxClass:
	mov	edx, DWORD PTR tv1452[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [eax+160], ecx

; 743  : 			break;

	jmp	$LN99@SfxClass
$LN8@SfxClass:

; 744  : 		case SFX_CRATER3:
; 745  :     		objBSP = new DrawableGroundVehicle( MapVisId(VIS_CRATER3),  &pos, 0.0f, 1.0f  );

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T124[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 67		; 00000043H
	cmp	DWORD PTR $T124[ebp], 0
	je	SHORT $LN237@SfxClass
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	push	128					; 00000080H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T124[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv1471[ebp], eax
	jmp	SHORT $LN238@SfxClass
$LN237@SfxClass:
	mov	DWORD PTR tv1471[ebp], 0
$LN238@SfxClass:
	mov	eax, DWORD PTR tv1471[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [ecx+160], edx

; 746  : 			break;

	jmp	$LN99@SfxClass
$LN7@SfxClass:

; 747  : 		case SFX_CRATER4:
; 748  :     		objBSP = new DrawableGroundVehicle( MapVisId(VIS_CRATER4),  &pos, 0.0f, 1.0f  );

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T121[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 68		; 00000044H
	cmp	DWORD PTR $T121[ebp], 0
	je	SHORT $LN239@SfxClass
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	129					; 00000081H
	call	?MapVisId@@YAKK@Z			; MapVisId
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T121[ebp]
	call	??0DrawableGroundVehicle@@QAE@HPAUTpoint@@MM@Z ; DrawableGroundVehicle::DrawableGroundVehicle
	mov	DWORD PTR tv1490[ebp], eax
	jmp	SHORT $LN240@SfxClass
$LN239@SfxClass:
	mov	DWORD PTR tv1490[ebp], 0
$LN240@SfxClass:
	mov	ecx, DWORD PTR tv1490[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [edx+160], eax

; 749  : 			break;

	jmp	$LN99@SfxClass

; 750  : 		case SFX_BURNING_PART:
; 751  : 		case SFX_CLUSTER_BOMB:
; 752  : 			// edg NOTE: should never do this one here.  However, I think there's
; 753  : 			// a problem with the creation of the burning part object and I've seen
; 754  : 			// ACMI try to use this constructor to create the effect.  This shouldn't
; 755  : 			// be a big problem since the fire will be created anyway.  This will just
; 756  : 			// be a kind of NULL effect in ACMI
; 757  : 			break;

	jmp	$LN99@SfxClass

; 758  : //		case SFX_PILOT_SPLAT:
; 759  : //    		obj2d = new Drawable2D( DRAW2D_GROUND_STRIKE, scale, &pos, 4, gFireVerts, gFireUvs );
; 760  : 		case SFX_PARTICLE_KLUDGE: // so it won't do that annoying "Bad SFX Type"
; 761  : 			break;

	jmp	$LN99@SfxClass
$LN4@SfxClass:

; 762  : 		//Cobra TJL 11/06/04 Added per Steve and new PS file
; 763  : 		case SFX_NUKE:
; 764  : 			obj2d = new Drawable2D( DRAW2D_WATER_CLOUD, scale, &pos );

	push	296					; 00000128H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T118[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 69		; 00000045H
	cmp	DWORD PTR $T118[ebp], 0
	je	SHORT $LN241@SfxClass
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	push	30					; 0000001eH
	mov	ecx, DWORD PTR $T118[ebp]
	call	??0Drawable2D@@QAE@HMPAUTpoint@@@Z	; Drawable2D::Drawable2D
	mov	DWORD PTR tv1504[ebp], eax
	jmp	SHORT $LN242@SfxClass
$LN241@SfxClass:
	mov	DWORD PTR tv1504[ebp], 0
$LN242@SfxClass:
	mov	eax, DWORD PTR tv1504[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+152], edx

; 765  : 			timeToLive = obj2d->GetAlphaTimeToLive();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+100]
$LN3@SfxClass:
$LN99@SfxClass:

; 766  : 			break;
; 767  : 		default:
; 768  : 			// VP_changes This should be checked and modified, frequently stops here, yeah. Oct 7, 2002
; 769  : 			ShiWarning ("Bad SFX Type");
; 770  : 			break;
; 771  : 	}
; 772  : 
; 773  : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 774  : 
; 775  : 	// update counters
; 776  : 	gTotSfx++;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	eax, 1
	mov	DWORD PTR ?gTotSfx@@3HA, eax		; gTotSfx

; 777  : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 778  : 	{
; 779  : 		gTotHighWaterSfx = gTotSfx;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, edx	; gTotHighWaterSfx
$LN2@SfxClass:

; 780  : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 781  : 	}
; 782  : 	gSfxCount[ type ]++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[ecx*4], edx

; 783  : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	cmp	eax, DWORD PTR ?gSfxHighWater@@3PAHA[edx*4]
	jle	SHORT $LN1@SfxClass

; 784  : 	{
; 785  : 		gSfxHighWater[type] = gSfxCount[type];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4], edx
$LN1@SfxClass:

; 786  : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 787  : 	}
; 788  : 
; 789  : 
; 790  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN315@SfxClass:
	DD	$LN98@SfxClass
	DD	$LN56@SfxClass
	DD	$LN77@SfxClass
	DD	$LN71@SfxClass
	DD	$LN57@SfxClass
	DD	$LN14@SfxClass
	DD	$LN89@SfxClass
	DD	$LN10@SfxClass
	DD	$LN83@SfxClass
	DD	$LN74@SfxClass
	DD	$LN76@SfxClass
	DD	$LN75@SfxClass
	DD	$LN66@SfxClass
	DD	$LN13@SfxClass
	DD	$LN11@SfxClass
	DD	$LN12@SfxClass
	DD	$LN67@SfxClass
	DD	$LN37@SfxClass
	DD	$LN18@SfxClass
	DD	$LN15@SfxClass
	DD	$LN46@SfxClass
	DD	$LN23@SfxClass
	DD	$LN22@SfxClass
	DD	$LN63@SfxClass
	DD	$LN21@SfxClass
	DD	$LN86@SfxClass
	DD	$LN35@SfxClass
	DD	$LN78@SfxClass
	DD	$LN81@SfxClass
	DD	$LN87@SfxClass
	DD	$LN62@SfxClass
	DD	$LN84@SfxClass
	DD	$LN85@SfxClass
	DD	$LN48@SfxClass
	DD	$LN72@SfxClass
	DD	$LN73@SfxClass
	DD	$LN36@SfxClass
	DD	$LN24@SfxClass
	DD	$LN82@SfxClass
	DD	$LN27@SfxClass
	DD	$LN26@SfxClass
	DD	$LN25@SfxClass
	DD	$LN34@SfxClass
	DD	$LN33@SfxClass
	DD	$LN32@SfxClass
	DD	$LN31@SfxClass
	DD	$LN30@SfxClass
	DD	$LN29@SfxClass
	DD	$LN90@SfxClass
	DD	$LN28@SfxClass
	DD	$LN79@SfxClass
	DD	$LN80@SfxClass
	DD	$LN61@SfxClass
	DD	$LN58@SfxClass
	DD	$LN9@SfxClass
	DD	$LN8@SfxClass
	DD	$LN7@SfxClass
	DD	$LN47@SfxClass
	DD	$LN38@SfxClass
	DD	$LN88@SfxClass
	DD	$LN4@SfxClass
	DD	$LN3@SfxClass
$LN313@SfxClass:
	DB	0
	DB	1
	DB	2
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	3
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	4
	DB	5
	DB	6
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	61					; 0000003dH
	DB	12					; 0000000cH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	15					; 0000000fH
	DB	61					; 0000003dH
	DB	16					; 00000010H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	20					; 00000014H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	21					; 00000015H
	DB	61					; 0000003dH
	DB	29					; 0000001dH
	DB	20					; 00000014H
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	61					; 0000003dH
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	61					; 0000003dH
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	61					; 0000003dH
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	61					; 0000003dH
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	61					; 0000003dH
	DB	48					; 00000030H
	DB	61					; 0000003dH
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	51					; 00000033H
	DB	52					; 00000034H
	DB	53					; 00000035H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	54					; 00000036H
	DB	55					; 00000037H
	DB	56					; 00000038H
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	20					; 00000014H
	DB	61					; 0000003dH
	DB	57					; 00000039H
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	61					; 0000003dH
	DB	60					; 0000003cH
	npad	3
$LN316@SfxClass:
	DD	$LN95@SfxClass
	DD	$LN94@SfxClass
	DD	$LN93@SfxClass
	DD	$LN92@SfxClass
$LN317@SfxClass:
	DD	$LN53@SfxClass
	DD	$LN52@SfxClass
	DD	$LN51@SfxClass
	DD	$LN50@SfxClass
$LN318@SfxClass:
	DD	$LN43@SfxClass
	DD	$LN42@SfxClass
	DD	$LN41@SfxClass
	DD	$LN40@SfxClass
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$1:
	mov	eax, DWORD PTR $T81[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$2:
	mov	eax, DWORD PTR $T115[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$3:
	mov	eax, DWORD PTR $T114[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$4:
	mov	eax, DWORD PTR $T113[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$5:
	mov	eax, DWORD PTR $T112[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$6:
	mov	eax, DWORD PTR $T111[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$7:
	mov	eax, DWORD PTR $T110[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$8:
	mov	eax, DWORD PTR $T109[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$9:
	mov	eax, DWORD PTR $T108[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$10:
	mov	eax, DWORD PTR $T107[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$11:
	mov	eax, DWORD PTR $T106[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$12:
	mov	eax, DWORD PTR $T105[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$13:
	mov	eax, DWORD PTR $T104[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$14:
	mov	eax, DWORD PTR $T103[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$15:
	mov	eax, DWORD PTR $T102[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$16:
	mov	eax, DWORD PTR $T101[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$17:
	mov	eax, DWORD PTR $T100[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$18:
	mov	eax, DWORD PTR $T99[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$19:
	mov	eax, DWORD PTR $T98[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$20:
	mov	eax, DWORD PTR $T96[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$21:
	mov	eax, DWORD PTR $T94[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$22:
	mov	eax, DWORD PTR $T92[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$23:
	mov	eax, DWORD PTR $T90[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$24:
	mov	eax, DWORD PTR $T88[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$25:
	mov	eax, DWORD PTR $T86[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$26:
	mov	eax, DWORD PTR $T84[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$27:
	mov	eax, DWORD PTR $T82[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$28:
	mov	eax, DWORD PTR $T80[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$29:
	mov	eax, DWORD PTR $T78[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$30:
	mov	eax, DWORD PTR $T123[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$31:
	mov	eax, DWORD PTR $T122[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$32:
	mov	eax, DWORD PTR $T120[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$33:
	mov	eax, DWORD PTR $T119[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$34:
	mov	eax, DWORD PTR $T117[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$35:
	mov	eax, DWORD PTR $T116[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$36:
	mov	eax, DWORD PTR $T97[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$37:
	mov	eax, DWORD PTR $T71[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$38:
	mov	eax, DWORD PTR $T95[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$39:
	mov	eax, DWORD PTR $T79[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$40:
	mov	eax, DWORD PTR $T93[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$41:
	mov	eax, DWORD PTR $T74[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$42:
	mov	eax, DWORD PTR $T91[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$43:
	mov	eax, DWORD PTR $T77[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$44:
	mov	eax, DWORD PTR $T89[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$45:
	mov	eax, DWORD PTR $T72[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$46:
	mov	eax, DWORD PTR $T87[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$47:
	mov	eax, DWORD PTR $T76[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$48:
	mov	eax, DWORD PTR $T85[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$49:
	mov	eax, DWORD PTR $T73[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$50:
	mov	eax, DWORD PTR $T83[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$51:
	mov	eax, DWORD PTR $T75[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$52:
	mov	eax, DWORD PTR $T139[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$53:
	mov	eax, DWORD PTR $T138[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$54:
	mov	eax, DWORD PTR $T137[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$55:
	mov	eax, DWORD PTR $T136[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$56:
	mov	eax, DWORD PTR $T135[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$57:
	mov	eax, DWORD PTR $T134[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$58:
	mov	eax, DWORD PTR $T133[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$59:
	mov	eax, DWORD PTR $T132[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$60:
	mov	eax, DWORD PTR $T131[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$61:
	mov	eax, DWORD PTR $T130[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$62:
	mov	eax, DWORD PTR $T129[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$63:
	mov	eax, DWORD PTR $T128[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$64:
	mov	eax, DWORD PTR $T127[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$65:
	mov	eax, DWORD PTR $T126[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$66:
	mov	eax, DWORD PTR $T125[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$67:
	mov	eax, DWORD PTR $T124[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$68:
	mov	eax, DWORD PTR $T121[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0SfxClass@@QAE@HPAUTpoint@@MM@Z$69:
	mov	eax, DWORD PTR $T118[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0SfxClass@@QAE@HPAUTpoint@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-856]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HPAUTpoint@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HPAUTpoint@@MM@Z ENDP			; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv209 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_endM$ = 8						; size = 4
_damM$ = 12						; size = 4
??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z PROC ; SfxClass::SfxClass
; _this$ = ecx

; 318  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 319  : 
; 320  : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 321  : 	type = SFX_MESSAGE_TIMER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 105			; 00000069H

; 322  : 	flags = SFX_TIMER_FLAG | SFX_SECONDARY_DRIVER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 264			; 00000108H

; 323  : 	endMessage = endM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _endM$[ebp]
	mov	DWORD PTR [eax+144], ecx

; 324  : 	damMessage = damM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _damM$[ebp]
	mov	DWORD PTR [edx+148], eax

; 325  : 	vec.x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+52], xmm0

; 326  : 	vec.y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+56], xmm0

; 327  : 	vec.z = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+60], xmm0

; 328  : 	pos.x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 329  : 	pos.y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+44], xmm0

; 330  : 	pos.z = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+48], xmm0

; 331  : 	timeToLive = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+100], xmm0

; 332  : 	// scale = scaleSfx * ( 0.6f + 0.4f * gSfxLOD );
; 333  : 	scale = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+104], xmm0

; 334  : 	secondaryCount = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 1

; 335  : 	secondaryInterval = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+120], xmm0

; 336  : 	secondaryTimer = SIM_ELAPSED_SEC + PRANDFloatPos() * 25.0f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv209[ebp]
	movss	xmm0, DWORD PTR tv209[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	addss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+124], xmm0

; 337  : 	travelDist = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 338  : 
; 339  : 	objParticleSys = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+168], 0

; 340  : 	objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 341  : 	objTracer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 342  : 	objBSP = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 343  : 	obj2d = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 0

; 344  : 	//baseObj = NULL;
; 345  : 
; 346  : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], eax

; 347  : 
; 348  : 	// update counters
; 349  : 	gTotSfx++;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	edx, 1
	mov	DWORD PTR ?gTotSfx@@3HA, edx		; gTotSfx

; 350  : 	if ( gTotSfx > gTotHighWaterSfx )

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 351  : 	{
; 352  : 		gTotHighWaterSfx = gTotSfx;

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, ecx	; gTotHighWaterSfx
$LN2@SfxClass:

; 353  : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 354  : 	}
; 355  : 	gSfxCount[ type ]++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[eax*4], ecx

; 356  : 	if ( gSfxCount[type] > gSfxHighWater[type] )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	cmp	edx, DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4]
	jle	SHORT $LN1@SfxClass

; 357  : 	{
; 358  : 		gSfxHighWater[type] = gSfxCount[type];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[eax*4], ecx
$LN1@SfxClass:

; 359  : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 360  : 	}
; 361  : 
; 362  : 
; 363  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@PAVFalconMissileEndMessage@@PAVFalconDamageMessage@@@Z ENDP ; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_timetl$ = -96						; size = 4
tv258 = -92						; size = 4
_numRunning$ = -88					; size = 4
tv292 = -84						; size = 4
tv308 = -80						; size = 4
tv298 = -76						; size = 4
tv318 = -72						; size = 4
tv286 = -68						; size = 4
tv313 = -64						; size = 4
_numBursts$ = -60					; size = 4
tv190 = -56						; size = 4
tv167 = -52						; size = 4
tv135 = -48						; size = 4
_i$ = -44						; size = 4
_groundHit$ = -40					; size = 4
_debrisScale$ = -36					; size = 4
_this$ = -32						; size = 4
_mvec$ = -28						; size = 12
_mpos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?StartRandomDebris@SfxClass@@IAEXXZ PROC		; SfxClass::StartRandomDebris
; _this$ = ecx

; 5999 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 6000 : 	Tpoint mvec, mpos;
; 6001 : 	int i, numBursts;
; 6002 : 	float debrisScale;
; 6003 : 	float timetl;
; 6004 : 	int numRunning;
; 6005 : 	BOOL groundHit = FALSE;

	mov	DWORD PTR _groundHit$[ebp], 0

; 6006 : 
; 6007 : 	numRunning = gSfxCount[ SFX_AC_DEBRIS ] +
; 6008 : 				 gSfxCount[ SFX_FLARE_GFX ] +
; 6009 : 				 gSfxCount[ SFX_DEBRISTRAIL ] +
; 6010 : 				 gSfxCount[ SFX_FIRETRAIL ] +
; 6011 : 				 gSfxCount[ SFX_CAT_LAUNCH ];

	mov	eax, 4
	imul	eax, 62					; 0000003eH
	mov	ecx, 4
	shl	ecx, 6
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	add	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	mov	eax, 4
	imul	eax, 53					; 00000035H
	add	edx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	mov	ecx, 4
	imul	ecx, 56					; 00000038H
	add	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	mov	eax, 4
	imul	eax, 63					; 0000003fH
	add	edx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	mov	DWORD PTR _numRunning$[ebp], edx

; 6012 : 
; 6013 : 	if ( numRunning > gSfxLODCutoff * 3 ||
; 6014 : 		 gTotSfx >= gSfxLODTotCutoff )

	mov	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	imul	ecx, 3
	cmp	DWORD PTR _numRunning$[ebp], ecx
	jg	SHORT $LN21@StartRando
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	SHORT $LN22@StartRando
$LN21@StartRando:

; 6015 : 		return;

	jmp	$LN23@StartRando
$LN22@StartRando:

; 6016 : 
; 6017 : 	debrisScale = 3.0f;

	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _debrisScale$[ebp], xmm0

; 6018 : 	timetl = 0.5f + 2.0f * debrisScale / 10.0f;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _debrisScale$[ebp]
	divss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _timetl$[ebp], xmm0

; 6019 : 	mpos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mpos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mpos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mpos$[ebp+8], eax

; 6020 : 
; 6021 : 	if ( type == SFX_WATER_EXPLOSION ||
; 6022 : 		 type == SFX_GROUND_STRIKE ||
; 6023 : 		 type == SFX_WATER_STRIKE ||
; 6024 : 		 type == SFX_ARTILLERY_EXPLOSION ||
; 6025 : 		 type == SFX_GROUND_EXPLOSION )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 19			; 00000013H
	je	SHORT $LN19@StartRando
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 38			; 00000026H
	je	SHORT $LN19@StartRando
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 39			; 00000027H
	je	SHORT $LN19@StartRando
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 45			; 0000002dH
	je	SHORT $LN19@StartRando
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 5
	jne	$LN20@StartRando
$LN19@StartRando:

; 6026 : 	{
; 6027 : 		debrisScale = min( 7.0f, scale * 0.1f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR __real@40e00000
	jbe	SHORT $LN25@StartRando
	movss	xmm0, DWORD PTR __real@40e00000
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN26@StartRando
$LN25@StartRando:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv135[ebp], xmm0
$LN26@StartRando:
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR _debrisScale$[ebp], xmm0

; 6028 : 		mpos.z = OTWDriver.GetGroundLevel( mpos.x, mpos.y ) - 3.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv258[ebp]
	movss	xmm0, DWORD PTR tv258[ebp]
	subss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 6029 : 		groundHit = TRUE;

	mov	DWORD PTR _groundHit$[ebp], 1
	jmp	SHORT $LN15@StartRando
$LN20@StartRando:

; 6030 : 	}
; 6031 : 	else if ( type == SFX_SPARKS )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 44			; 0000002cH
	jne	SHORT $LN15@StartRando

; 6032 : 	{
; 6033 : 		mpos.z = OTWDriver.GetGroundLevel( mpos.x, mpos.y );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _mpos$[ebp+8]

; 6034 : 		if ( pos.z - mpos.z > -10.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR _mpos$[ebp+8]
	comiss	xmm0, DWORD PTR __real@c1200000
	jbe	SHORT $LN16@StartRando

; 6035 : 		{
; 6036 : 			groundHit = TRUE;

	mov	DWORD PTR _groundHit$[ebp], 1

; 6037 : 			mpos.z -= 3.0f;

	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	subss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 6038 : 		}
; 6039 : 		else

	jmp	SHORT $LN15@StartRando
$LN16@StartRando:

; 6040 : 		{
; 6041 : 			mpos.z = pos.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0
$LN15@StartRando:

; 6042 : 		}
; 6043 : 	}
; 6044 : 
; 6045 : 	// try and scale debris to smaller size if viewed close
; 6046 : 	if ( approxDist < 15000.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@466a6000
	comiss	xmm0, DWORD PTR [edx+132]
	jbe	SHORT $LN14@StartRando

; 6047 : 	{
; 6048 : 		debrisScale = max( 0.5f, debrisScale * approxDist/15000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _debrisScale$[ebp]
	mulss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@466a6000
	movss	xmm1, DWORD PTR __real@3f000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN27@StartRando
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv167[ebp], xmm0
	jmp	SHORT $LN28@StartRando
$LN27@StartRando:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _debrisScale$[ebp]
	mulss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@466a6000
	movss	DWORD PTR tv167[ebp], xmm0
$LN28@StartRando:
	movss	xmm0, DWORD PTR tv167[ebp]
	movss	DWORD PTR _debrisScale$[ebp], xmm0
$LN14@StartRando:

; 6049 : 	}
; 6050 : 
; 6051 : 	numBursts = (int)( 7.0f * gSfxLOD );

	movss	xmm0, DWORD PTR __real@40e00000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si edx, xmm0
	mov	DWORD PTR _numBursts$[ebp], edx

; 6052 : 
; 6053 : 	for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@StartRando
$LN12@StartRando:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@StartRando:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	$LN11@StartRando

; 6054 : 	{
; 6055 : 
; 6056 : 		if ( groundHit == TRUE )

	cmp	DWORD PTR _groundHit$[ebp], 1
	jne	$LN10@StartRando

; 6057 : 		{
; 6058 : 			mvec.x = 80.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv286[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	mulss	xmm0, DWORD PTR __real@42a00000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 6059 : 			mvec.y = 80.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv292[ebp]
	movss	xmm0, DWORD PTR tv292[ebp]
	mulss	xmm0, DWORD PTR __real@42a00000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 6060 : 			mvec.z = -30.0f * PRANDFloatPos() * scale * 0.03f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv298[ebp]
	movss	xmm0, DWORD PTR tv298[ebp]
	mulss	xmm0, DWORD PTR __real@c1f00000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 6061 : 			mvec.z = min( -80.0f, mvec.z );

	movss	xmm0, DWORD PTR _mvec$[ebp+8]
	comiss	xmm0, DWORD PTR __real@c2a00000
	jbe	SHORT $LN29@StartRando
	movss	xmm0, DWORD PTR __real@c2a00000
	movss	DWORD PTR tv190[ebp], xmm0
	jmp	SHORT $LN30@StartRando
$LN29@StartRando:
	movss	xmm0, DWORD PTR _mvec$[ebp+8]
	movss	DWORD PTR tv190[ebp], xmm0
$LN30@StartRando:
	movss	xmm0, DWORD PTR tv190[ebp]
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 6062 : 		}
; 6063 : 		else

	jmp	SHORT $LN9@StartRando
$LN10@StartRando:

; 6064 : 		{
; 6065 : 			mvec.x = 90.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv308[ebp]
	movss	xmm0, DWORD PTR tv308[ebp]
	mulss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 6066 : 			mvec.y = 90.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv313[ebp]
	movss	xmm0, DWORD PTR tv313[ebp]
	mulss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 6067 : 			mvec.z = 90.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv318[ebp]
	movss	xmm0, DWORD PTR tv318[ebp]
	mulss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN9@StartRando:

; 6068 : 		}
; 6069 : 
; 6070 : 		if ( type == SFX_WATER_EXPLOSION ||
; 6071 : 		 	 type == SFX_WATER_STRIKE )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 19			; 00000013H
	je	SHORT $LN7@StartRando
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 39			; 00000027H
	jne	SHORT $LN8@StartRando
$LN7@StartRando:

; 6072 : 	    {
; 6073 : 			/*
; 6074 : 			OTWDriver.AddSfxRequest(
; 6075 : 				new SfxClass( SFX_FLARE_GFX,		// type
; 6076 : 				SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 6077 : 				&mpos,					// world pos
; 6078 : 				&mvec,					// vel vector
; 6079 : 				timetl,					// time to live
; 6080 : 				debrisScale ) );				// scale
; 6081 : 				*/
; 6082 : 		}
; 6083 : 		else if ( type == SFX_SPARKS )

	jmp	SHORT $LN5@StartRando
$LN8@StartRando:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 44			; 0000002cH
	jne	SHORT $LN5@StartRando

; 6084 : 		{
; 6085 : 			if ( (rand() & 1) || groundHit )

	call	_rand
$LN5@StartRando:

; 6086 : 			{}
; 6087 : 				/*
; 6088 : 				OTWDriver.AddSfxRequest(
; 6089 : 					new SfxClass( SFX_AC_DEBRIS,		// type
; 6090 : 					SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 6091 : 					&mpos,					// world pos
; 6092 : 					&mvec,					// vel vector
; 6093 : 					timetl,					// time to live
; 6094 : 					debrisScale ) );				// scale
; 6095 : 					*/
; 6096 : 			else
; 6097 : 			{}
; 6098 : 			/*
; 6099 : 				OTWDriver.AddSfxRequest(
; 6100 : 					new SfxClass( SFX_EXPLSTAR_GLOW,		// type
; 6101 : 					SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 6102 : 					&mpos,					// world pos
; 6103 : 					&mvec,					// vel vector
; 6104 : 					timetl,					// time to live
; 6105 : 					debrisScale ) );				// scale
; 6106 : 					*/
; 6107 : 		}
; 6108 : 		else
; 6109 : 		{
; 6110 : 			/*
; 6111 : 			OTWDriver.AddSfxRequest(
; 6112 : 				new SfxClass( SFX_AC_DEBRIS,		// type
; 6113 : 				SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 6114 : 				&mpos,					// world pos
; 6115 : 				&mvec,					// vel vector
; 6116 : 				timetl,					// time to live
; 6117 : 				debrisScale ) );				// scale
; 6118 : 				*/
; 6119 : 		}
; 6120 : 	}

	jmp	$LN12@StartRando
$LN11@StartRando:
$LN23@StartRando:

; 6121 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?StartRandomDebris@SfxClass@@IAEXXZ ENDP		; SfxClass::StartRandomDebris
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GroundReflection@SfxClass@@IAEXXZ PROC			; SfxClass::GroundReflection
; _this$ = ecx

; 5683 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5684 : 	// NOTE: a big simplification is that we will assume the ground
; 5685 : 	// normal is always pointing up ( 0, 0, -1 ).  The reflection vector
; 5686 : 	// therefore becomes a simple matter of making the z component of
; 5687 : 	// movement vector negative.  To be accurate, we may need to end up
; 5688 : 	// constructing what amounts to a reflection matrix built from
; 5689 : 	// retrieving the ground normal and then multiply the vector by the
; 5690 : 	// matrix.
; 5691 : 	if ( vec.z > 0.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@GroundRefl

; 5692 : 		vec.z = -vec.z;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+60], xmm0
$LN1@GroundRefl:

; 5693 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GroundReflection@SfxClass@@IAEXXZ ENDP			; SfxClass::GroundReflection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_distScale$2 = -44					; size = 4
$T3 = -40						; size = 4
tv341 = -36						; size = 4
tv267 = -32						; size = 4
$T4 = -28						; size = 4
tv140 = -24						; size = 4
tv208 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hitGround$ = 8						; size = 4
___formal$ = 12						; size = 4
_groundType$ = 16					; size = 4
?RunSfxCompletion@SfxClass@@IAEXHMH@Z PROC		; SfxClass::RunSfxCompletion
; _this$ = ecx

; 5428 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RunSfxCompletion@SfxClass@@IAEXHMH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5429 : 	// do we explode at end?
; 5430 : 	if ( flags & SFX_EXPLODE_WHEN_DONE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 4
	je	$LN31@RunSfxComp

; 5431 : 	{
; 5432 : 		// add new effect!
; 5433 : 		if ( hitGround )

	cmp	DWORD PTR _hitGround$[ebp], 0
	je	$LN30@RunSfxComp

; 5434 : 		{
; 5435 : 			pos.z -= 40.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	subss	xmm0, DWORD PTR __real@42200000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 5436 : 			//  water river is 1-2
; 5437 : 		 	if ( (groundType == COVERAGE_WATER || groundType == COVERAGE_RIVER) )

	cmp	DWORD PTR _groundType$[ebp], 1
	je	SHORT $LN28@RunSfxComp
	cmp	DWORD PTR _groundType$[ebp], 2
	jne	SHORT $LN29@RunSfxComp
$LN28@RunSfxComp:

; 5438 : 			{
; 5439 : 				F4SoundFXSetPos( SFX_SPLASH, TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	107					; 0000006bH
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5440 : 				/*
; 5441 : 				OTWDriver.AddSfxRequest(
; 5442 : 						new SfxClass( SFX_WATER_STRIKE,				// type
; 5443 : 						&pos,					// world pos
; 5444 : 						2.0f,							// time to live
; 5445 : 						100.0f ) );							// scale
; 5446 : 						*/
; 5447 : 			}
; 5448 : 			else

	jmp	SHORT $LN26@RunSfxComp
$LN29@RunSfxComp:

; 5449 : 			{
; 5450 : 				if ( PRANDInt6() )

	call	?PRANDInt6@@YAHXZ			; PRANDInt6
$LN26@RunSfxComp:

; 5451 : 				{
; 5452 : 					/*
; 5453 : 					OTWDriver.AddSfxRequest(
; 5454 : 						new SfxClass( SFX_GROUND_STRIKE,				// type
; 5455 : 						&pos,					// world pos
; 5456 : 						2.0f,							// time to live
; 5457 : 						100.0f ) );							// scale
; 5458 : 						*/
; 5459 : 				}
; 5460 : 				else
; 5461 : 				{
; 5462 : 					/*
; 5463 : 					OTWDriver.AddSfxRequest(
; 5464 : 						new SfxClass( SFX_ARTILLERY_EXPLOSION,				// type
; 5465 : 						&pos,					// world pos
; 5466 : 						2.0f,							// time to live
; 5467 : 						100.0f ) );							// scale
; 5468 : 						*/
; 5469 : 				}
; 5470 : 
; 5471 : 				// temp craters
; 5472 : 				/*
; 5473 : 				OTWDriver.AddSfxRequest(
; 5474 : 							new SfxClass( SFX_RAND_CRATER,				// type
; 5475 : 							0,								// flags
; 5476 : 							&pos,							// world pos
; 5477 : 							(struct Trotation *)&IMatrix,						// world orientation
; 5478 : 							&vec,							// vector
; 5479 : 							15.0f,							// time to live
; 5480 : 							50.0f + 50.0f * PRANDFloatPos() ) );							// scale
; 5481 : 				*/
; 5482 : 			}
; 5483 : 		}
; 5484 : 		else if ( type == SFX_GUNFIRE ||

	jmp	$LN20@RunSfxComp
$LN30@RunSfxComp:

; 5485 : 				  type == SFX_SMOKING_PART ||
; 5486 : 				  type == SFX_FLAMING_PART ||
; 5487 : 				  type == SFX_MISSILE_LAUNCH )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 17			; 00000011H
	je	SHORT $LN22@RunSfxComp
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 3
	je	SHORT $LN22@RunSfxComp
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 4
	je	SHORT $LN22@RunSfxComp
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 21			; 00000015H
	jne	SHORT $LN23@RunSfxComp
$LN22@RunSfxComp:

; 5488 : 		{
; 5489 : 			/*
; 5490 : 			OTWDriver.AddSfxRequest(
; 5491 : 					new SfxClass( SFX_AAA_EXPLOSION,				// type
; 5492 : 					&pos,					// world pos
; 5493 : 					1.2f,							// time to live
; 5494 : 					40.0f ) );						// scale
; 5495 : 					*/
; 5496 : 		}
; 5497 : 		else if ( type == SFX_TRACER_FIRE )

	jmp	SHORT $LN20@RunSfxComp
$LN23@RunSfxComp:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 36			; 00000024H
	jne	SHORT $LN20@RunSfxComp

; 5498 : 		{
; 5499 : 			float distScale = max( 0.1f, approxDist/200000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN34@RunSfxComp
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv140[ebp], xmm0
	jmp	SHORT $LN35@RunSfxComp
$LN34@RunSfxComp:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv140[ebp], xmm0
$LN35@RunSfxComp:
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _distScale$2[ebp], xmm0
$LN20@RunSfxComp:

; 5500 : 			/*
; 5501 : 			OTWDriver.AddSfxRequest(
; 5502 : 					new SfxClass( SFX_AAA_EXPLOSION,				// type
; 5503 : 					&pos,					// world pos
; 5504 : 					1.5f,							// time to live
; 5505 : 					400.0f * distScale) );						// scale
; 5506 : 					*/
; 5507 : 		}
; 5508 : 		else
; 5509 : 		{
; 5510 : 			/*
; 5511 : 			OTWDriver.AddSfxRequest(
; 5512 : 					new SfxClass( SFX_AC_AIR_EXPLOSION,		// type
; 5513 : 					&pos,					// world pos
; 5514 : 					2.0f,							// time to live
; 5515 : 					250.0f ) );						// scale
; 5516 : 					*/
; 5517 : 		}
; 5518 : 		if ( hitGround )

	cmp	DWORD PTR _hitGround$[ebp], 0
	je	SHORT $LN18@RunSfxComp

; 5519 : 			F4SoundFXSetPos( SFX_BOOMG1 + PRANDInt5(), TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 28					; 0000001cH
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5520 : 		else

	jmp	SHORT $LN17@RunSfxComp
$LN18@RunSfxComp:

; 5521 : 			F4SoundFXSetPos( SFX_BOOMA1 + PRANDInt5(), TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 43					; 0000002bH
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H
$LN17@RunSfxComp:
	jmp	$LN2@RunSfxComp
$LN31@RunSfxComp:

; 5522 : 	}
; 5523 : 	else if ( hitGround )

	cmp	DWORD PTR _hitGround$[ebp], 0
	je	$LN2@RunSfxComp

; 5524 : 	{
; 5525 : 		pos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 10.0f;

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv341[ebp]
	movss	xmm0, DWORD PTR tv341[ebp]
	subss	xmm0, DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 5526 : 	 	if ( (groundType == COVERAGE_WATER ||
; 5527 : 			  groundType == COVERAGE_RIVER) &&
; 5528 : 			  type != SFX_FLARE_GFX )

	cmp	DWORD PTR _groundType$[ebp], 1
	je	SHORT $LN13@RunSfxComp
	cmp	DWORD PTR _groundType$[ebp], 2
	jne	SHORT $LN14@RunSfxComp
$LN13@RunSfxComp:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 64			; 00000040H
	je	SHORT $LN14@RunSfxComp

; 5529 : 		{
; 5530 : 			F4SoundFXSetPos( SFX_SPLASH, TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	107					; 0000006bH
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5531 : 			/*
; 5532 : 			OTWDriver.AddSfxRequest(
; 5533 : 					new SfxClass( SFX_WATER_STRIKE,				// type
; 5534 : 					&pos,					// world pos
; 5535 : 					1.5f,							// time to live
; 5536 : 					20.0f ) );							// scale
; 5537 : 					*/
; 5538 : 		}
; 5539 : 		else

	jmp	$LN2@RunSfxComp
$LN14@RunSfxComp:

; 5540 : 		{
; 5541 : 			if ( type == SFX_GROUNDBURST )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 49			; 00000031H
	jne	$LN11@RunSfxComp

; 5542 : 			{
; 5543 : 				switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv208[ebp], eax
	cmp	DWORD PTR tv208[ebp], 1
	je	SHORT $LN7@RunSfxComp
	cmp	DWORD PTR tv208[ebp], 2
	je	SHORT $LN6@RunSfxComp
	cmp	DWORD PTR tv208[ebp], 4
	je	$LN4@RunSfxComp
	jmp	$LN9@RunSfxComp

; 5544 : 				{
; 5545 : 					case 0:
; 5546 : 						/*
; 5547 : 						OTWDriver.AddSfxRequest(
; 5548 : 							new SfxClass( SFX_GROUND_STRIKE_NOFIRE,	// type
; 5549 : 							&pos,					// world pos
; 5550 : 							1.5f,					// time to live
; 5551 : 							15.0f ) );				// scale
; 5552 : 							*/
; 5553 : 						break;

	jmp	$LN9@RunSfxComp
$LN7@RunSfxComp:

; 5554 : 					case 1:
; 5555 : 						vec.x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+52], xmm0

; 5556 : 						vec.y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+56], xmm0

; 5557 : 						vec.z = -50.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2480000
	movss	DWORD PTR [eax+60], xmm0

; 5558 : 						/*
; 5559 : 						OTWDriver.AddSfxRequest(
; 5560 : 							new SfxClass( SFX_FIRE4,		// type
; 5561 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 5562 : 							&pos,					// world pos
; 5563 : 							&vec,					// vel vector
; 5564 : 							1.5,					// time to live
; 5565 : 							20.25f ) );				// scale
; 5566 : 							*/
; 5567 : 						break;

	jmp	$LN9@RunSfxComp
$LN6@RunSfxComp:

; 5568 : 					case 2:
; 5569 : 						/*
; 5570 : 						OTWDriver.AddSfxRequest(
; 5571 : 							new SfxClass(SFX_SMALL_HIT_EXPLOSION,				// type
; 5572 : 							&pos,							// world pos
; 5573 : 							1.5f,			// time to live
; 5574 : 							15.0f) );		// scale
; 5575 : 							*/
; 5576 : 						F4SoundFXSetPos( SFX_BOOMG1 + PRANDInt5(), TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 28					; 0000001cH
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5577 : 						break;

	jmp	SHORT $LN9@RunSfxComp

; 5578 : 					case 3:
; 5579 : 						/*
; 5580 : 						OTWDriver.AddSfxRequest(
; 5581 : 							new SfxClass( SFX_GROUND_FLASH,			// type
; 5582 : 							&pos,					// world pos
; 5583 : 							2.2f,					// time to live
; 5584 : 							75.4f ) );				// scale
; 5585 : 							*/
; 5586 : 						break;

	jmp	SHORT $LN9@RunSfxComp
$LN4@RunSfxComp:

; 5587 : 					case 4:
; 5588 : 						/*
; 5589 : 						OTWDriver.AddSfxRequest(
; 5590 : 							new SfxClass( SFX_AAA_EXPLOSION,	// type
; 5591 : 							&pos,					// world pos
; 5592 : 							1.5f,					// time to live
; 5593 : 							15.0f ) );				// scale
; 5594 : 							*/
; 5595 : 						F4SoundFXSetPos( SFX_BOOMG1 + PRANDInt5(), TRUE, pos.x, pos.y, pos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 28					; 0000001cH
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H
$LN9@RunSfxComp:
$LN11@RunSfxComp:
$LN2@RunSfxComp:

; 5596 : 						break;
; 5597 : 				}
; 5598 : 			}
; 5599 : 			else if ( type == SFX_GUN_TRACER )
; 5600 : 			{
; 5601 : 				/*
; 5602 : 				OTWDriver.AddSfxRequest(
; 5603 : 					new SfxClass(SFX_SPARKS,				// type
; 5604 : 					&pos,							// world pos
; 5605 : 					0.75f,							// time to live
; 5606 : 					31.0f));						// scale
; 5607 : 					*/
; 5608 : 			}
; 5609 : 		}
; 5610 : 	}
; 5611 : 
; 5612 : 	/*
; 5613 : 	if ( type == SFX_FIRE1 )
; 5614 : 	{
; 5615 : 		OTWDriver.AddSfxRequest(
; 5616 : 					new SfxClass(SFX_FIRE2,				// type
; 5617 : 					&pos,							// world pos
; 5618 : 					0.3f,			// time to live
; 5619 : 					scale * 1.1 ) );		// scale
; 5620 : 	}
; 5621 : 	else if ( type == SFX_FIRE2 )
; 5622 : 	{
; 5623 : 		OTWDriver.AddSfxRequest(
; 5624 : 					new SfxClass(SFX_FIRE3,				// type
; 5625 : 					&pos,							// world pos
; 5626 : 					0.3f,			// time to live
; 5627 : 					scale * 1.1 ) );		// scale
; 5628 : 	}
; 5629 : 	else if ( type == SFX_FIRE3 )
; 5630 : 	{
; 5631 : 		OTWDriver.AddSfxRequest(
; 5632 : 					new SfxClass(SFX_FIRE4,				// type
; 5633 : 					&pos,							// world pos
; 5634 : 					0.3f,			// time to live
; 5635 : 					scale * 1.1 ) );		// scale
; 5636 : 	}
; 5637 : 	else if ( type == SFX_FIRE4 )
; 5638 : 	{
; 5639 : 		OTWDriver.AddSfxRequest(
; 5640 : 					new SfxClass(SFX_FIRE5,				// type
; 5641 : 					&pos,							// world pos
; 5642 : 					0.3f,			// time to live
; 5643 : 					scale * 1.1 ) );		// scale
; 5644 : 	}
; 5645 : 	else if ( type == SFX_FIRE5 )
; 5646 : 	{
; 5647 : 		OTWDriver.AddSfxRequest(
; 5648 : 					new SfxClass(SFX_FIRE6,				// type
; 5649 : 					&pos,							// world pos
; 5650 : 					0.3f,			// time to live
; 5651 : 					scale * 1.1 ) );		// scale
; 5652 : 	}
; 5653 : 	else if ( type == SFX_FIRE6 )
; 5654 : 	{
; 5655 : 		OTWDriver.AddSfxRequest(
; 5656 : 					new SfxClass(SFX_FIRE7,				// type
; 5657 : 					&pos,							// world pos
; 5658 : 					0.3f,			// time to live
; 5659 : 					scale * 1.1 ) );		// scale
; 5660 : 	}
; 5661 : 	else
; 5662 : 	*/
; 5663 : 
; 5664 : 	// all trails get timed out
; 5665 : 	if ( objTrail && type != SFX_TIMER )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	SHORT $LN1@RunSfxComp
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 25			; 00000019H
	je	SHORT $LN1@RunSfxComp

; 5666 : 	{
; 5667 : 		OTWDriver.AddSfxRequest(
; 5668 : 				new SfxClass( 
; 5669 : 				30.0f,							// time to live
; 5670 : 				objTrail ) );						// scale

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN36@RunSfxComp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0SfxClass@@QAE@MPAVDrawableTrail@@@Z	; SfxClass::SfxClass
	mov	DWORD PTR tv267[ebp], eax
	jmp	SHORT $LN37@RunSfxComp
$LN36@RunSfxComp:
	mov	DWORD PTR tv267[ebp], 0
$LN37@RunSfxComp:
	mov	eax, DWORD PTR tv267[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest

; 5671 : 		objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0
$LN1@RunSfxComp:

; 5672 : 	}
; 5673 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RunSfxCompletion@SfxClass@@IAEXHMH@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RunSfxCompletion@SfxClass@@IAEXHMH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RunSfxCompletion@SfxClass@@IAEXHMH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RunSfxCompletion@SfxClass@@IAEXHMH@Z ENDP		; SfxClass::RunSfxCompletion
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv602 = -768						; size = 4
tv1163 = -764						; size = 4
tv1225 = -760						; size = 4
tv1180 = -756						; size = 4
_mflags$ = -752						; size = 4
_trigWind$2 = -748					; size = 8
tv1938 = -740						; size = 4
tv1945 = -736						; size = 4
tv1930 = -732						; size = 4
tv2377 = -728						; size = 4
tv2264 = -724						; size = 4
tv1952 = -720						; size = 4
tv2502 = -716						; size = 4
tv2088 = -712						; size = 4
tv2319 = -708						; size = 4
tv2028 = -704						; size = 4
tv2214 = -700						; size = 4
tv2669 = -696						; size = 4
tv1924 = -692						; size = 4
tv2700 = -688						; size = 4
tv3484 = -684						; size = 4
tv2642 = -680						; size = 4
tv3469 = -676						; size = 4
tv2552 = -672						; size = 4
tv3514 = -668						; size = 4
tv2441 = -664						; size = 4
tv3438 = -660						; size = 4
tv2359 = -656						; size = 4
tv3430 = -652						; size = 4
tv2286 = -648						; size = 4
tv3423 = -644						; size = 4
tv2239 = -640						; size = 4
$T3 = -636						; size = 4
tv2194 = -632						; size = 4
tv3363 = -628						; size = 4
tv2049 = -624						; size = 4
tv3352 = -620						; size = 4
tv1984 = -616						; size = 4
tv3345 = -612						; size = 4
tv2682 = -608						; size = 4
tv3312 = -604						; size = 4
tv2656 = -600						; size = 4
tv3301 = -596						; size = 4
tv2628 = -592						; size = 4
tv3294 = -588						; size = 4
tv2564 = -584						; size = 4
tv3280 = -580						; size = 4
tv2520 = -576						; size = 4
tv1411 = -572						; size = 4
tv2458 = -568						; size = 4
tv3256 = -564						; size = 4
tv2385 = -560						; size = 4
tv3245 = -556						; size = 4
tv2369 = -552						; size = 4
tv3238 = -548						; size = 4
tv2327 = -544						; size = 4
tv3224 = -540						; size = 4
tv2294 = -536						; size = 4
tv3200 = -532						; size = 4
tv2274 = -528						; size = 4
tv3189 = -524						; size = 4
tv2251 = -520						; size = 4
tv3182 = -516						; size = 4
tv2229 = -512						; size = 4
tv1307 = -508						; size = 4
tv2204 = -504						; size = 4
tv3152 = -500						; size = 4
tv2183 = -496						; size = 4
tv3141 = -492						; size = 4
tv2078 = -488						; size = 4
tv3134 = -484						; size = 4
tv2038 = -480						; size = 4
tv3090 = -476						; size = 4
tv2006 = -472						; size = 4
tv3079 = -468						; size = 4
tv1970 = -464						; size = 4
tv3072 = -460						; size = 4
tv2689 = -456						; size = 4
tv3040 = -452						; size = 4
tv2675 = -448						; size = 4
tv3033 = -444						; size = 4
tv2663 = -440						; size = 4
tv3026 = -436						; size = 4
tv2649 = -432						; size = 4
tv3018 = -428						; size = 4
tv2634 = -424						; size = 4
tv3011 = -420						; size = 4
tv2594 = -416						; size = 4
tv3004 = -412						; size = 4
tv2584 = -408						; size = 4
tv2981 = -404						; size = 4
tv2558 = -400						; size = 4
tv2976 = -396						; size = 4
tv2542 = -392						; size = 4
tv2971 = -388						; size = 4
tv2514 = -384						; size = 4
tv2962 = -380						; size = 4
tv2463 = -376						; size = 4
tv2949 = -372						; size = 4
tv2453 = -368						; size = 4
tv2930 = -364						; size = 4
tv2389 = -360						; size = 4
tv2925 = -356						; size = 4
tv2381 = -352						; size = 4
tv2920 = -348						; size = 4
tv2373 = -344						; size = 4
tv2911 = -340						; size = 4
tv2364 = -336						; size = 4
tv2904 = -332						; size = 4
tv2344 = -328						; size = 4
tv2897 = -324						; size = 4
tv2323 = -320						; size = 4
tv2883 = -316						; size = 4
$T4 = -312						; size = 4
tv2876 = -308						; size = 4
tv2290 = -304						; size = 4
tv2869 = -300						; size = 4
tv2278 = -296						; size = 4
tv2861 = -292						; size = 4
tv2268 = -288						; size = 4
tv2855 = -284						; size = 4
tv2255 = -280						; size = 4
tv2844 = -276						; size = 4
tv2243 = -272						; size = 4
tv2838 = -268						; size = 4
tv2233 = -264						; size = 4
tv2832 = -260						; size = 4
tv2218 = -256						; size = 4
tv2828 = -252						; size = 4
tv2208 = -248						; size = 4
tv2817 = -244						; size = 4
tv2198 = -240						; size = 4
tv2810 = -236						; size = 4
tv2187 = -232						; size = 4
tv2791 = -228						; size = 4
tv2094 = -224						; size = 4
tv2784 = -220						; size = 4
tv2083 = -216						; size = 4
tv2771 = -212						; size = 4
tv2073 = -208						; size = 4
tv2765 = -204						; size = 4
tv2043 = -200						; size = 4
tv2759 = -196						; size = 4
tv2033 = -192						; size = 4
tv2749 = -188						; size = 4
tv2013 = -184						; size = 4
tv2742 = -180						; size = 4
tv1999 = -176						; size = 4
tv2716 = -172						; size = 4
tv1977 = -168						; size = 4
tv2710 = -164						; size = 4
tv2704 = -160						; size = 4
tv2589 = -156						; size = 4
tv556 = -152						; size = 4
tv1349 = -148						; size = 4
tv509 = -144						; size = 4
tv65 = -140						; size = 4
$T5 = -136						; size = 4
_radstep$ = -132					; size = 4
_wind$6 = -128						; size = 4
tv1391 = -124						; size = 4
tv1593 = -120						; size = 4
tv1329 = -116						; size = 4
$T7 = -112						; size = 4
tv1284 = -108						; size = 4
tv1513 = -104						; size = 4
tv1143 = -100						; size = 4
tv1452 = -96						; size = 4
tv1205 = -92						; size = 4
_randint$8 = -88					; size = 4
_rads$ = -84						; size = 4
_distScale$ = -80					; size = 4
_numBursts$ = -76					; size = 4
_i$ = -72						; size = 4
_this$ = -68						; size = 4
_vec2$ = -64						; size = 12
_windvec$9 = -52					; size = 12
_mvec$ = -40						; size = 12
_mpos$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RunSecondarySfx@SfxClass@@IAEXXZ PROC			; SfxClass::RunSecondarySfx
; _this$ = ecx

; 3039 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RunSecondarySfx@SfxClass@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 756				; 000002f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3040 : 	Tpoint mpos, mvec, vec2;
; 3041 : 	float distScale=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _distScale$[ebp], xmm0

; 3042 : 	int mflags = SFX_MOVES | SFX_USES_GRAVITY | SFX_EXPLODE_WHEN_DONE;

	mov	DWORD PTR _mflags$[ebp], 7

; 3043 : 	int numBursts=0,i=0;

	mov	DWORD PTR _numBursts$[ebp], 0
	mov	DWORD PTR _i$[ebp], 0

; 3044 : 	float rads=0.0F, radstep=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rads$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _radstep$[ebp], xmm0

; 3045 : 
; 3046 : 	switch ( type )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 116		; 00000074H
	ja	$LN1@RunSeconda
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN285@RunSeconda[edx]
	jmp	DWORD PTR $LN287@RunSeconda[eax*4]
$LN258@RunSeconda:

; 3047 : 	{
; 3048 : 		case SFX_DURANDAL:
; 3049 : 			mvec.x = vec.x * 0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3050 : 			mvec.y = vec.y * 0.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3051 : 			mvec.z = -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3052 : 
; 3053 : 			//RV - I-Hawk - Remming all unused PS calls...
; 3054 : 			/*
; 3055 : 			OTWDriver.AddSfxRequest(
; 3056 : 				new SfxClass (SFX_WATER_CLOUD,			// type
; 3057 : 				SFX_MOVES,						// flags
; 3058 : 				&pos,							// world pos
; 3059 : 				&mvec,							// vector
; 3060 : 				2.0f,							// time to live
; 3061 : 				10.5f ));		// scale
; 3062 : 				*/
; 3063 : 			break;

	jmp	$LN259@RunSeconda
$LN257@RunSeconda:

; 3064 : 
; 3065 : 		case SFX_MESSAGE_TIMER:
; 3066 : 			if ( endMessage )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN256@RunSeconda

; 3067 : 			{
; 3068 : 				FalconSendMessage(endMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 3069 : 				endMessage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 0
$LN256@RunSeconda:

; 3070 : 			}
; 3071 : 			if ( damMessage )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+148], 0
	je	SHORT $LN255@RunSeconda

; 3072 : 			{
; 3073 : 				FalconSendMessage(damMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 3074 : 				damMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0
$LN255@RunSeconda:

; 3075 : 			}
; 3076 : 			break;

	jmp	$LN259@RunSeconda
$LN254@RunSeconda:

; 3077 : 
; 3078 : #if 1  // MLR 12/19/2003 - Out with the crap, in with the new
; 3079 : 		case SFX_SMOKING_FEATURE:
; 3080 : 		case SFX_STEAMING_FEATURE:
; 3081 : 			// sfr: until Alex fix this
; 3082 : #define MEMCORRUPTION_FIX_HACK 0
; 3083 : #if MEMCORRUPTION_FIX_HACK
; 3084 : #else
; 3085 : 	   //RV - I-Hawk - Not using a objtrail for this anymore  
; 3086 : 		//if(objTrail){
; 3087 : 			mlTrig trigWind;
; 3088 : 			Tpoint windvec;
; 3089 : 			float wind;
; 3090 : 
; 3091 : 			// current wind
; 3092 : 			mlSinCos(&trigWind, ((WeatherClass*)realWeather)->WindHeadingAt(&pos));

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?WindHeadingAt@WeatherClass@@QAEMPBUTpoint@@@Z ; WeatherClass::WindHeadingAt
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _trigWind$2[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 3093 : 			wind =  ((WeatherClass*)realWeather)->WindSpeedInFeetPerSecond(&pos);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	call	?WindSpeedInFeetPerSecond@WeatherClass@@QAEMPBUTpoint@@@Z ; WeatherClass::WindSpeedInFeetPerSecond
	fstp	DWORD PTR _wind$6[ebp]

; 3094 : 			windvec.x = trigWind.cos * wind;

	movss	xmm0, DWORD PTR _trigWind$2[ebp+4]
	mulss	xmm0, DWORD PTR _wind$6[ebp]
	movss	DWORD PTR _windvec$9[ebp], xmm0

; 3095 : 			windvec.y = trigWind.sin * wind;

	movss	xmm0, DWORD PTR _trigWind$2[ebp]
	mulss	xmm0, DWORD PTR _wind$6[ebp]
	movss	DWORD PTR _windvec$9[ebp+4], xmm0

; 3096 : 			windvec.z = -10;

	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR _windvec$9[ebp+8], xmm0

; 3097 : 			
; 3098 : 			//objTrail->SetHeadVelocity(&windvec);
; 3099 : 
; 3100 : 			//RV- I-Hawk- Replaced older trail for features smoke with a new PS effect
; 3101 : 			//OTWDriver.AddTrailHead(objTrail, pos.x, pos.y, pos.z);
; 3102 : 			/*
; 3103 : 			SfxClass *sfx = new SfxClass(
; 3104 : 				SFX_SMOKETRAIL,		// type
; 3105 : 				SFX_MOVES,
; 3106 : 				&pos,							// world pos
; 3107 : 				&windvec,
; 3108 : 				1.0f,							// time to live
; 3109 : 				1.0f                       // scale
; 3110 : 			);
; 3111 : 			OTWDriver.AddSfxRequest(sfx);
; 3112 : 			*/
; 3113 : 			DrawableParticleSys::PS_AddParticleEx((SFX_SMOKETRAIL + 1),
; 3114 : 							 &pos,
; 3115 : 							 &windvec);

	lea	edx, DWORD PTR _windvec$9[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	53					; 00000035H
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 3116 : 		//}
; 3117 : 		
; 3118 : #endif // MEMCORRUPTION_FIX_HACK
; 3119 : 		break;

	jmp	$LN259@RunSeconda
$LN253@RunSeconda:

; 3120 : #else
; 3121 : 		case SFX_SMOKING_FEATURE:
; 3122 : 
; 3123 : 			mvec.x = 20.0f * PRANDFloat();
; 3124 : 			mvec.y = 20.0f * PRANDFloat();
; 3125 : 			mvec.z = -80.0f;
; 3126 : 			if ( rand() & 1 )
; 3127 : 				//RV - I-Hawk - Remming all unused PS calls...
; 3128 : 				/*
; 3129 : 				OTWDriver.AddSfxRequest(
; 3130 : 					new SfxClass (SFX_FIRESMOKE,				// type
; 3131 : 					SFX_MOVES,
; 3132 : 					&pos,							// world pos
; 3133 : 					&mvec,							// world pos
; 3134 : 					2.5f,							// time to live
; 3135 : 					scale ) );		// scale
; 3136 : 					*/
; 3137 : 			else
; 3138 : 				/*
; 3139 : 				OTWDriver.AddSfxRequest(
; 3140 : 					new SfxClass (SFX_STEAM_CLOUD,				// type
; 3141 : 					SFX_MOVES,
; 3142 : 					&pos,							// world pos
; 3143 : 					&mvec,							// world pos
; 3144 : 					2.5f,							// time to live
; 3145 : 					scale ) );		// scale
; 3146 : 					*/
; 3147 : 			break;
; 3148 : 
; 3149 : 		case SFX_STEAMING_FEATURE:
; 3150 : 
; 3151 : 			mvec.x = 20.0f * PRANDFloat();
; 3152 : 			mvec.y = 20.0f * PRANDFloat();
; 3153 : 			mvec.z = -80.0f;
; 3154 : 			/*
; 3155 : 			OTWDriver.AddSfxRequest(
; 3156 : 				new SfxClass (SFX_STEAM_CLOUD,				// type
; 3157 : 				SFX_MOVES,
; 3158 : 				&pos,							// world pos
; 3159 : 				&mvec,							// world pos
; 3160 : 				2.5f,							// time to live
; 3161 : 				scale ) );		// scale
; 3162 : 				*/
; 3163 : 			break;
; 3164 : #endif
; 3165 : 		case SFX_FEATURE_CHAIN_REACTION:
; 3166 : 			// continue applying chain reaction until returns false.
; 3167 : 			if ( SimFeatureClass::ApplyChainReaction( &pos, scale ) == TRUE )

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	call	?ApplyChainReaction@SimFeatureClass@@SAHPAUTpoint@@M@Z ; SimFeatureClass::ApplyChainReaction
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN252@RunSeconda

; 3168 : 			{
; 3169 : 				secondaryTimer = SIM_ELAPSED_SEC + 1.0f;

	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+124], xmm0

; 3170 : 				secondaryCount = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1
$LN252@RunSeconda:

; 3171 : 			}
; 3172 : 			break;

	jmp	$LN259@RunSeconda
$LN251@RunSeconda:

; 3173 : 
; 3174 : 		case SFX_CLUSTER_BOMB:
; 3175 : 			mvec.x = vec.x * 0.5f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3176 : 			mvec.y = vec.y * 0.5f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3177 : 			mvec.z = -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3178 : 
; 3179 : 			/*
; 3180 : 			OTWDriver.AddSfxRequest(
; 3181 : 				new SfxClass (SFX_WATER_CLOUD,			// type
; 3182 : 				SFX_MOVES,						// flags
; 3183 : 				&pos,							// world pos
; 3184 : 				&mvec,							// vector
; 3185 : 				2.0f,							// time to live
; 3186 : 				10.5f ));		// scale
; 3187 : 				*/
; 3188 : 			DrawableParticleSys::PS_AddParticleEx((SFX_WATER_CLOUD + 1),
; 3189 : 									&pos,
; 3190 : 									&mvec);

	lea	ecx, DWORD PTR _mvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	push	60					; 0000003cH
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 3191 :             
; 3192 : 			if ( gSfxCount[ SFX_GROUNDBURST ] > gSfxLODCutoff ||
; 3193 : 			 	 gTotSfx >= gSfxLODTotCutoff )

	mov	eax, 4
	imul	eax, 49					; 00000031H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN249@RunSeconda
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	SHORT $LN250@RunSeconda
$LN249@RunSeconda:

; 3194 : 			{
; 3195 : 				numBursts = 10 + FloatToInt32(PRANDFloatPos() * 20.0f);

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv1924[ebp]
	movss	xmm0, DWORD PTR tv1924[ebp]
	mulss	xmm0, DWORD PTR __real@41a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _numBursts$[ebp], eax

; 3196 : 			}
; 3197 : 			else

	jmp	SHORT $LN248@RunSeconda
$LN250@RunSeconda:

; 3198 : 			{
; 3199 : 				numBursts = 40 + FloatToInt32(PRANDFloatPos() * 40.0f);

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv1930[ebp]
	movss	xmm0, DWORD PTR tv1930[ebp]
	mulss	xmm0, DWORD PTR __real@42200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 40					; 00000028H
	mov	DWORD PTR _numBursts$[ebp], eax
$LN248@RunSeconda:

; 3200 : 			}
; 3201 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN247@RunSeconda
$LN246@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN247@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	$LN245@RunSeconda

; 3202 : 			{
; 3203 : 				// mvec.x = 1.2f * (mpos.x - pos.x) + 40.0f * PRANDFloat();
; 3204 : 				// mvec.y = 1.2f * (mpos.y - pos.y) + 40.0f * PRANDFloat();
; 3205 : 				// mvec.z = 1.2f * (mpos.z - pos.z) - 30.0f * PRANDFloatPos();
; 3206 : 				mvec.x = vec.x + 80.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1938[ebp]
	movss	xmm0, DWORD PTR tv1938[ebp]
	mulss	xmm0, DWORD PTR __real@42a00000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3207 : 				mvec.y = vec.y + 80.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1945[ebp]
	movss	xmm0, DWORD PTR tv1945[ebp]
	mulss	xmm0, DWORD PTR __real@42a00000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3208 : 				mvec.z = vec.z + 40.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1952[ebp]
	movss	xmm0, DWORD PTR tv1952[ebp]
	mulss	xmm0, DWORD PTR __real@42200000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3209 : 		
; 3210 : 				/*
; 3211 : 				OTWDriver.AddSfxRequest(
; 3212 : 					new SfxClass( SFX_GROUNDBURST,		// type
; 3213 : 					SFX_MOVES | SFX_USES_GRAVITY,
; 3214 : 					&pos,					// world pos
; 3215 : 					&mvec,					// vel vector
; 3216 : 					20.0f,					// time to live
; 3217 : 					1.5f ) );				// scale
; 3218 : 					*/
; 3219 : 				DrawableParticleSys::PS_AddParticleEx((SFX_GROUNDBURST + 1),
; 3220 : 									&pos,
; 3221 : 									&mvec);

	lea	edx, DWORD PTR _mvec$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	push	50					; 00000032H
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 3222 : 			}

	jmp	$LN246@RunSeconda
$LN245@RunSeconda:

; 3223 : 
; 3224 : 			/*
; 3225 : 			// 1st time thru we do detonation
; 3226 : 			if ( secondaryCount == 1 )
; 3227 : 			{
; 3228 : 				mpos.z = OTWDriver.GetGroundLevel( pos.x, pos.y );
; 3229 : 
; 3230 : 				// approx time to ground impact
; 3231 : 				rads = (mpos.z - pos.z)/vec.z;
; 3232 : 
; 3233 : 				for ( i = 0; i < 80; i++ )
; 3234 : 				{
; 3235 : 
; 3236 : 					// mvec.x = 1.2f * (mpos.x - pos.x) + 40.0f * PRANDFloat();
; 3237 : 					// mvec.y = 1.2f * (mpos.y - pos.y) + 40.0f * PRANDFloat();
; 3238 : 					// mvec.z = 1.2f * (mpos.z - pos.z) - 30.0f * PRANDFloatPos();
; 3239 : 					mvec.x = vec.x + 70.0f * PRANDFloat();
; 3240 : 					mvec.y = vec.y + 70.0f * PRANDFloat();
; 3241 : 					mvec.z = vec.z + 20.0f * PRANDFloat();
; 3242 : 			
; 3243 : 					OTWDriver.AddSfxRequest(
; 3244 : 						new SfxClass( SFX_GROUNDBURST,		// type
; 3245 : 						SFX_MOVES | SFX_USES_GRAVITY,
; 3246 : 						&pos,					// world pos
; 3247 : 						&mvec,					// vel vector
; 3248 : 						20.0f,					// time to live
; 3249 : 						2.5f ) );				// scale
; 3250 : 				}
; 3251 : 				secondaryTimer = SIM_ELAPSED_SEC + rads;
; 3252 : 				pos.x += vec.x * rads;
; 3253 : 				pos.y += vec.y * rads;
; 3254 : 			}
; 3255 : 			// 2nd time thru, run the ground bursts
; 3256 : 			else
; 3257 : 			{
; 3258 : 				mpos = pos;
; 3259 : 				mvec.x = vec.x * 2.0f;
; 3260 : 				mvec.y = vec.y * 2.0f;
; 3261 : 				mvec.z = 0.0f;
; 3262 : 				OTWDriver.AddSfxRequest(
; 3263 : 					new SfxClass( SFX_GROUNDBURST,		// type
; 3264 : 					&mpos,					// world pos
; 3265 : 					&mvec,					// vel vector
; 3266 : 					8,						// time to live
; 3267 : 					0.3f ) );				// scale
; 3268 : 			}
; 3269 : 			*/
; 3270 : 			break;

	jmp	$LN259@RunSeconda
$LN244@RunSeconda:

; 3271 : 		case SFX_SPARKS:
; 3272 : 		case SFX_SPARKS_NO_DEBRIS:
; 3273 : 			if ( gSfxCount[ SFX_WATER_WAKE_LARGE ] > gSfxLODCutoff ||
; 3274 : 				 gSfxCount[ SFX_SPARK_TRACER ] > gSfxLODCutoff ||
; 3275 : 			 	 gTotSfx >= gSfxLODTotCutoff ||
; 3276 : 				 (approxDist > 30000.0f && scale < 50.0f) )

	mov	ecx, 4
	imul	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN242@RunSeconda
	mov	eax, 4
	imul	eax, 117				; 00000075H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN242@RunSeconda
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN242@RunSeconda
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	comiss	xmm0, DWORD PTR __real@46ea6000
	jbe	SHORT $LN243@RunSeconda
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR [ecx+104]
	jbe	SHORT $LN243@RunSeconda
$LN242@RunSeconda:

; 3277 : 			{
; 3278 : 				break;

	jmp	$LN259@RunSeconda
$LN243@RunSeconda:

; 3279 : 			}
; 3280 : 
; 3281 : 			/*
; 3282 : 			mvec.x = PRANDFloat() * 25.0f;
; 3283 : 			mvec.y = PRANDFloat() * 25.0f;
; 3284 : 			mvec.z = PRANDFloat() * 25.0f;
; 3285 : 			mpos.x = pos.x + PRANDFloat() * scale;
; 3286 : 			mpos.y = pos.y + PRANDFloat() * scale;
; 3287 : 			mpos.z = pos.z + PRANDFloat() * scale;
; 3288 : 
; 3289 : 			OTWDriver.AddSfxRequest(
; 3290 : 		   					new SfxClass( SFX_EXPLSTAR_GLOW,				// type
; 3291 : 							SFX_MOVES | SFX_BOUNCES | SFX_USES_GRAVITY,						// flags
; 3292 : 							&mpos,							// world pos
; 3293 : 							&mvec,							// vector
; 3294 : 							1.3f,							// time to live
; 3295 : 							scale * 0.08f ) );							// scale
; 3296 : 			*/
; 3297 : 
; 3298 : 			mpos.x = pos.x + PRANDFloat() * scale * 0.3f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1970[ebp]
	movss	xmm0, DWORD PTR tv1970[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3299 : 			mpos.y = pos.y + PRANDFloat() * scale * 0.3f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1977[ebp]
	movss	xmm0, DWORD PTR tv1977[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 3300 : 			mpos.z = pos.z + PRANDFloat() * scale * 0.3f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1984[ebp]
	movss	xmm0, DWORD PTR tv1984[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 3301 : 
; 3302 : 			mvec.x = (mpos.x - pos.x) * 3.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp]
	subss	xmm0, DWORD PTR [edx+40]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3303 : 			mvec.y = (mpos.y - pos.y) * 3.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	subss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3304 : 			mvec.z = (mpos.z - pos.z) * 3.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	subss	xmm0, DWORD PTR [ecx+48]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3305 : 
; 3306 : 			/*
; 3307 : 			OTWDriver.AddSfxRequest(
; 3308 : 		   					new SfxClass( SFX_SPARK_TRACER,				// type
; 3309 : 							SFX_MOVES | SFX_BOUNCES | SFX_USES_GRAVITY,						// flags
; 3310 : 							&mpos,							// world pos
; 3311 : 							&mvec,							// vector
; 3312 : 							1.3f,							// time to live
; 3313 : 							scale ) );							// scale
; 3314 : 							*/
; 3315 : 			DrawableParticleSys::PS_AddParticleEx((SFX_SPARK_TRACER + 1),
; 3316 : 									&mpos,
; 3317 : 									&mvec);

	lea	edx, DWORD PTR _mvec$[ebp]
	push	edx
	lea	eax, DWORD PTR _mpos$[ebp]
	push	eax
	push	118					; 00000076H
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 3318 : 
; 3319 : 			mpos.x = pos.x + PRANDFloat() * scale * 0.3f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv1999[ebp]
	movss	xmm0, DWORD PTR tv1999[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3320 : 			mpos.y = pos.y + PRANDFloat() * scale * 0.3f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2006[ebp]
	movss	xmm0, DWORD PTR tv2006[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 3321 : 			mpos.z = pos.z + PRANDFloat() * scale * 0.3f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2013[ebp]
	movss	xmm0, DWORD PTR tv2013[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 3322 : 
; 3323 : 			mvec.x = (mpos.x - pos.x) * 3.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp]
	subss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3324 : 			mvec.y = (mpos.y - pos.y) * 3.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	subss	xmm0, DWORD PTR [edx+44]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3325 : 			mvec.z = (mpos.z - pos.z) * 3.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	subss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3326 : 
; 3327 : 			/*
; 3328 : 			OTWDriver.AddSfxRequest(
; 3329 : 		   					new SfxClass( SFX_SPARK_TRACER,				// type
; 3330 : 							SFX_MOVES | SFX_BOUNCES | SFX_USES_GRAVITY,						// flags
; 3331 : 							&mpos,							// world pos
; 3332 : 							&mvec,							// vector
; 3333 : 							1.3f,							// time to live
; 3334 : 							scale ) );							// scale
; 3335 : 							*/
; 3336 : 			DrawableParticleSys::PS_AddParticleEx((SFX_SPARK_TRACER + 1),
; 3337 : 									&mpos,
; 3338 : 									&mvec);

	lea	ecx, DWORD PTR _mvec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mpos$[ebp]
	push	edx
	push	118					; 00000076H
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 3339 : 			break;

	jmp	$LN259@RunSeconda
$LN241@RunSeconda:

; 3340 : 		case SFX_BILLOWING_SMOKE:
; 3341 : 			mvec.x = 10.0f +PRANDFloat() * 10.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2028[ebp]
	movss	xmm0, DWORD PTR tv2028[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3342 : 			mvec.y = 10.0f +PRANDFloat() * 10.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2033[ebp]
	movss	xmm0, DWORD PTR tv2033[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3343 : 			mvec.z = -50.0f - PRANDFloat() * 30.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2038[ebp]
	movss	xmm0, DWORD PTR tv2038[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	movss	xmm1, DWORD PTR __real@c2480000
	subss	xmm1, xmm0
	movss	DWORD PTR _mvec$[ebp+8], xmm1

; 3344 : 			mpos.x = pos.x + PRANDFloat() * 30.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2043[ebp]
	movss	xmm0, DWORD PTR tv2043[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3345 : 			mpos.y = pos.y + PRANDFloat() * 30.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2049[ebp]
	movss	xmm0, DWORD PTR tv2049[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 3346 : 			mpos.z = pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 3347 : 
; 3348 : 			if ( gSfxCount[ SFX_FIRESMOKE ] > gSfxLODCutoff ||
; 3349 : 			 	 gSfxCount[ SFX_TRAILSMOKE ] > gSfxLODCutoff ||
; 3350 : 			 	 gTotSfx >= gSfxLODTotCutoff )

	mov	eax, 4
	imul	eax, 91					; 0000005bH
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN239@RunSeconda
	mov	edx, 4
	imul	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN239@RunSeconda
	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	SHORT $LN240@RunSeconda
$LN239@RunSeconda:

; 3351 : 			{
; 3352 : 				break;

	jmp	$LN259@RunSeconda
$LN240@RunSeconda:

; 3353 : 			}
; 3354 : 
; 3355 : 			if ( rand() & 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN238@RunSeconda

; 3356 : 			{
; 3357 : 				/*
; 3358 : 				OTWDriver.AddSfxRequest(
; 3359 : 		   					new SfxClass( SFX_FIRESMOKE,				// type
; 3360 : 							SFX_MOVES,						// flags
; 3361 : 							&mpos,							// world pos
; 3362 : 							&mvec,							// vector
; 3363 : 							3.5f,							// time to live
; 3364 : 							34.5f ) );							// scale
; 3365 : 							*/
; 3366 : 				DrawableParticleSys::PS_AddParticleEx((SFX_FIRESMOKE + 1),
; 3367 : 									&mpos,
; 3368 : 									&mvec);

	lea	edx, DWORD PTR _mvec$[ebp]
	push	edx
	lea	eax, DWORD PTR _mpos$[ebp]
	push	eax
	push	92					; 0000005cH
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 3369 : 			}
; 3370 : 			else

	jmp	SHORT $LN237@RunSeconda
$LN238@RunSeconda:

; 3371 : 			{
; 3372 : 				/*
; 3373 : 				OTWDriver.AddSfxRequest(
; 3374 : 		   					new SfxClass( SFX_TRAILSMOKE,				// type
; 3375 : 							SFX_MOVES,						// flags
; 3376 : 							&mpos,							// world pos
; 3377 : 							&mvec,							// vector
; 3378 : 							3.5f,							// time to live
; 3379 : 							34.5f ) );							// scale
; 3380 : 							*/
; 3381 : 				DrawableParticleSys::PS_AddParticleEx((SFX_TRAILSMOKE + 1),
; 3382 : 									&mpos,
; 3383 : 									&mvec);

	lea	ecx, DWORD PTR _mvec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mpos$[ebp]
	push	edx
	push	93					; 0000005dH
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH
$LN237@RunSeconda:

; 3384 : 			}
; 3385 : 			break;

	jmp	$LN259@RunSeconda
$LN236@RunSeconda:

; 3386 : 		case SFX_FIRE:
; 3387 : 		case SFX_FIRE_EXPAND:
; 3388 : 
; 3389 : 			rads = approxDist/30000.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@46ea6000
	movss	DWORD PTR _rads$[ebp], xmm0

; 3390 : 			secondaryTimer = SIM_ELAPSED_SEC + 0.90f + 2.5F * rads;

	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	addss	xmm0, DWORD PTR __real@3f666666
	movss	xmm1, DWORD PTR __real@40200000
	mulss	xmm1, DWORD PTR _rads$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+124], xmm0

; 3391 : 			secondaryCount = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 1

; 3392 : 
; 3393 : 			mvec.x = 10.0f +PRANDFloat() * 10.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2073[ebp]
	movss	xmm0, DWORD PTR tv2073[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3394 : 			mvec.y = 10.0f +PRANDFloat() * 10.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2078[ebp]
	movss	xmm0, DWORD PTR tv2078[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3395 : 			mvec.z = -50.0f - PRANDFloat() * 30.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2083[ebp]
	movss	xmm0, DWORD PTR tv2083[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	movss	xmm1, DWORD PTR __real@c2480000
	subss	xmm1, xmm0
	movss	DWORD PTR _mvec$[ebp+8], xmm1

; 3396 : 			mpos.x = pos.x + PRANDFloat() * 30.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2088[ebp]
	movss	xmm0, DWORD PTR tv2088[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3397 : 			mpos.y = pos.y + PRANDFloat() * 30.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2094[ebp]
	movss	xmm0, DWORD PTR tv2094[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 3398 : 			mpos.z = pos.z - scale * 0.65f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3f266666
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1

; 3399 : 			if ( (rand() & 3 ) == 3 )

	call	_rand
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN235@RunSeconda

; 3400 : 			{
; 3401 : 				mvec.x *= 0.5f;

	movss	xmm0, DWORD PTR _mvec$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3402 : 				mvec.y *= 0.5f;

	movss	xmm0, DWORD PTR _mvec$[ebp+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3403 : 				//RV - I-Hawk - Remming all unused PS calls...
; 3404 : 				/*
; 3405 : 				OTWDriver.AddSfxRequest(
; 3406 : 		   			new SfxClass( SFX_FIRE2,		// type
; 3407 : 					SFX_NO_GROUND_CHECK | SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,						// flags
; 3408 : 					&mpos,							// world pos
; 3409 : 					&mvec,							// vector
; 3410 : 					3.5f,							// time to live
; 3411 : 					scale * 0.4f ) );							// scale
; 3412 : 					*/
; 3413 : 
; 3414 : 			}
; 3415 : 			else

	jmp	$LN234@RunSeconda
$LN235@RunSeconda:

; 3416 : 			{
; 3417 : 				// try a reduction in the number of effects running
; 3418 : 				// if ( approxDist > 10000.0f && gSfxCount[ SFX_FIRESMOKE ] > gSfxLODCutoff )
; 3419 : 				if ( gSfxCount[ SFX_FIRESMOKE ] > gSfxLODCutoff ||
; 3420 : 				 	 gTotSfx >= gSfxLODTotCutoff )

	mov	ecx, 4
	imul	ecx, 91					; 0000005bH
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jg	SHORT $LN232@RunSeconda
	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jl	SHORT $LN233@RunSeconda
$LN232@RunSeconda:

; 3421 : 					break;

	jmp	$LN259@RunSeconda
$LN233@RunSeconda:

; 3422 : 
; 3423 : 				/*
; 3424 : 				OTWDriver.AddSfxRequest(
; 3425 : 		   			new SfxClass( SFX_FIRESMOKE,				// type
; 3426 : 					SFX_MOVES,				 // flags
; 3427 : 					&mpos,							// world pos
; 3428 : 					&mvec,							// vector
; 3429 : 					3.5f,							// time to live
; 3430 : 					scale ) );							// scale
; 3431 : 					*/
; 3432 : 
; 3433 : 				if ( gSfxCount[ SFX_SHIP_BURNING_FIRE ] > gSfxLODCutoff/2 ||
; 3434 : 				 	 gTotSfx >= gSfxLODTotCutoff/2 )

	mov	ecx, 4
	imul	ecx, 86					; 00000056H
	mov	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR ?gSfxCount@@3PAHA[ecx], eax
	jg	SHORT $LN230@RunSeconda
	mov	eax, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR ?gTotSfx@@3HA, eax		; gTotSfx
	jl	SHORT $LN231@RunSeconda
$LN230@RunSeconda:

; 3435 : 					break;

	jmp	$LN259@RunSeconda
$LN231@RunSeconda:

; 3436 : 
; 3437 : 				mvec.x *= 0.5f;

	movss	xmm0, DWORD PTR _mvec$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3438 : 				mvec.y *= 0.5f;

	movss	xmm0, DWORD PTR _mvec$[ebp+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3439 : 				mpos.z = pos.z - scale * 0.15f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e19999a
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1
$LN234@RunSeconda:

; 3440 : 				/*
; 3441 : 				OTWDriver.AddSfxRequest(
; 3442 : 		   			new SfxClass( FIRE2,		// type
; 3443 : 					SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,						// flags
; 3444 : 					&mpos,							// world pos
; 3445 : 					&mvec,							// vector
; 3446 : 					3.5f,							// time to live
; 3447 : 					scale * 0.4f ) );							// scale
; 3448 : 					*/
; 3449 : 			}
; 3450 : 
; 3451 : 
; 3452 : 			break;

	jmp	$LN259@RunSeconda
$LN229@RunSeconda:

; 3453 : 		case SFX_FLAMING_PART:
; 3454 : 			mpos = pos;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _mpos$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _mpos$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _mpos$[ebp+8], ecx

; 3455 : 			// NOTE: if using scatter plot fire, add a bit to the position
; 3456 : 			mpos.z += 15.0f;

	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	addss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 3457 : 			// mpos.z -= 15.0f;
; 3458 : 
; 3459 : 			//RV - I-Hawk - Remming all unused PS calls...
; 3460 : 			/*
; 3461 : 			OTWDriver.AddSfxRequest(
; 3462 : 						new SfxClass(SFX_FIRE1,				// type
; 3463 : 						&mpos,							// world pos
; 3464 : 						0.2f,			// time to live
; 3465 : 						30.0f) );		// scale
; 3466 : 						*/
; 3467 : 			break;

	jmp	$LN259@RunSeconda
$LN228@RunSeconda:

; 3468 : 		case SFX_BURNING_PART:
; 3469 : 			mpos = pos;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _mpos$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _mpos$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _mpos$[ebp+8], edx

; 3470 : 			// NOTE: if using scatter plot fire, add a bit to the position
; 3471 : 			// mpos.z += 15.0f;
; 3472 : 			// mpos.z -= 15.0f;
; 3473 : 			// NOTE: we have to subtract out SimLibElapsedTime because it's
; 3474 : 			// already been added to timeToLive
; 3475 : 			/*
; 3476 : 			OTWDriver.AddSfxRequest(
; 3477 : 					new SfxClass(SFX_FIRE,				// type
; 3478 : 					&mpos,							// world pos
; 3479 : 					timeToLive - SIM_ELAPSED_SEC,			// time to live
; 3480 : 					40.0f) );		// scale
; 3481 : 					*/
; 3482 : 			break;

	jmp	$LN259@RunSeconda
$LN227@RunSeconda:

; 3483 : 		case SFX_FIREBALL:
; 3484 : 			mpos.x = (float)( (float)secondaryCount/(float)initSecondaryCount );

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+112]
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+116]
	divss	xmm0, xmm1
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3485 : 			if ( mpos.x > 0.90f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN226@RunSeconda
	jmp	$LN212@RunSeconda
$LN226@RunSeconda:

; 3486 : 			{
; 3487 : 				/*
; 3488 : 				OTWDriver.AddSfxRequest(
; 3489 : 						new SfxClass(SFX_FIRE_HOT,				// type
; 3490 : 						&pos,							// world pos
; 3491 : 						0.4f,			// time to live
; 3492 : 						scale * 0.4f ) );		// scale
; 3493 : 						*/
; 3494 : 			}
; 3495 : 			else if ( mpos.x > 0.85f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f59999a
	jbe	SHORT $LN224@RunSeconda

; 3496 : 			{
; 3497 : 				if ( ( rand() & 1 ) )

	call	_rand
	and	eax, 1
	je	SHORT $LN223@RunSeconda

; 3498 : 				{
; 3499 : 					mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2183[ebp]
	movss	xmm0, DWORD PTR tv2183[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3500 : 					mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2187[ebp]
	movss	xmm0, DWORD PTR tv2187[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3501 : 					mvec.z = -5.0f;

	movss	xmm0, DWORD PTR __real@c0a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN223@RunSeconda:

; 3502 : 					/*
; 3503 : 					OTWDriver.AddSfxRequest(
; 3504 : 							new SfxClass (SFX_FIRE2,		// type
; 3505 : 							SFX_MOVES,						// flags
; 3506 : 							&pos,							// world pos
; 3507 : 							&mvec,							// vector
; 3508 : 							2.0f,							// time to live
; 3509 : 							scale * 0.2f ));		// scale
; 3510 : 							*/
; 3511 : 				}
; 3512 : 				else
; 3513 : 				{
; 3514 : 					/*
; 3515 : 					OTWDriver.AddSfxRequest(
; 3516 : 						new SfxClass(SFX_FIRE_MED,				// type
; 3517 : 						&pos,							// world pos
; 3518 : 						0.4f,			// time to live
; 3519 : 						scale * 0.4f ) );		// scale
; 3520 : 						*/
; 3521 : 				}

	jmp	$LN212@RunSeconda
$LN224@RunSeconda:

; 3522 : 			}
; 3523 : 			else if ( mpos.x > 0.70f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f333333
	jbe	SHORT $LN220@RunSeconda

; 3524 : 			{
; 3525 : 				if ( ( rand() & 1 ) )

	call	_rand
	and	eax, 1
	je	SHORT $LN219@RunSeconda

; 3526 : 				{
; 3527 : 					mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2194[ebp]
	movss	xmm0, DWORD PTR tv2194[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3528 : 					mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2198[ebp]
	movss	xmm0, DWORD PTR tv2198[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3529 : 					mvec.z = -5.0f;

	movss	xmm0, DWORD PTR __real@c0a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN219@RunSeconda:

; 3530 : 					/*
; 3531 : 					OTWDriver.AddSfxRequest(
; 3532 : 							new SfxClass (SFX_FIRE2,		// type
; 3533 : 							SFX_MOVES,						// flags
; 3534 : 							&pos,							// world pos
; 3535 : 							&mvec,							// vector
; 3536 : 							2.0f,							// time to live
; 3537 : 							scale * 0.2f ));		// scale
; 3538 : 							*/
; 3539 : 				}
; 3540 : 				else
; 3541 : 				{
; 3542 : 					/*
; 3543 : 					OTWDriver.AddSfxRequest(
; 3544 : 						new SfxClass(SFX_FIRE_COOL,				// type
; 3545 : 						&pos,							// world pos
; 3546 : 						0.3f,			// time to live
; 3547 : 						scale * 0.5f ) );		// scale
; 3548 : 						*/
; 3549 : 				}

	jmp	$LN212@RunSeconda
$LN220@RunSeconda:

; 3550 : 			}
; 3551 : 			/*
; 3552 : 			else if ( mpos.x > 0.70f )
; 3553 : 			{
; 3554 : 				mvec.x = PRANDFloat() * 25.0f;
; 3555 : 				mvec.y = PRANDFloat() * 25.0f;
; 3556 : 				mvec.z = -5.0f;
; 3557 : 				OTWDriver.AddSfxRequest(
; 3558 : 						new SfxClass (SFX_FIRE2,		// type
; 3559 : 						SFX_MOVES,						// flags
; 3560 : 						&pos,							// world pos
; 3561 : 						&mvec,							// vector
; 3562 : 						2.0f,							// time to live
; 3563 : 						scale * 0.2f ));		// scale
; 3564 : 			}
; 3565 : 			*/
; 3566 : 			else if ( mpos.x > 0.90f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN216@RunSeconda

; 3567 : 			{
; 3568 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2204[ebp]
	movss	xmm0, DWORD PTR tv2204[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3569 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2208[ebp]
	movss	xmm0, DWORD PTR tv2208[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3570 : 				mvec.z = -5.0f;

	movss	xmm0, DWORD PTR __real@c0a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3571 : 				if ( ( rand() & 1 ) )

	call	_rand

; 3572 : 				{
; 3573 : 					/*
; 3574 : 					OTWDriver.AddSfxRequest(
; 3575 : 						new SfxClass (SFX_TRAILSMOKE,		// type
; 3576 : 						SFX_MOVES,						// flags
; 3577 : 						&pos,							// world pos
; 3578 : 						&mvec,							// vector
; 3579 : 						2.0f,							// time to live
; 3580 : 						5.2f ));		// scale
; 3581 : 						*/
; 3582 : 				}
; 3583 : 				else
; 3584 : 				{
; 3585 : 				/*
; 3586 : 					OTWDriver.AddSfxRequest(
; 3587 : 						new SfxClass (SFX_VEHICLE_DUST,		// type
; 3588 : 						SFX_MOVES,						// flags
; 3589 : 						&pos,							// world pos
; 3590 : 						&mvec,							// vector
; 3591 : 						2.0f,							// time to live
; 3592 : 						5.2f ));		// scale
; 3593 : 						*/
; 3594 : 				}
; 3595 : 			}
; 3596 : 			else

	jmp	SHORT $LN212@RunSeconda
$LN216@RunSeconda:

; 3597 : 			{
; 3598 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2214[ebp]
	movss	xmm0, DWORD PTR tv2214[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3599 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2218[ebp]
	movss	xmm0, DWORD PTR tv2218[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3600 : 				mvec.z = -10.0f;

	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3601 : 				if ( ( rand() & 3 ) == 3)

	call	_rand
$LN212@RunSeconda:

; 3602 : 				{
; 3603 : 					/*
; 3604 : 					OTWDriver.AddSfxRequest(
; 3605 : 						new SfxClass (SFX_TRAILSMOKE,			// type
; 3606 : 						SFX_MOVES,						// flags
; 3607 : 						&pos,							// world pos
; 3608 : 						&mvec,							// vector
; 3609 : 						2.0f,							// time to live
; 3610 : 						5.5f ));		// scale
; 3611 : 						*/
; 3612 : 				}
; 3613 : 				else
; 3614 : 				{
; 3615 : 				/*
; 3616 : 					OTWDriver.AddSfxRequest(
; 3617 : 						new SfxClass (SFX_VEHICLE_DUST,		// type
; 3618 : 						SFX_MOVES,						// flags
; 3619 : 						&pos,							// world pos
; 3620 : 						&mvec,							// vector
; 3621 : 						2.0f,							// time to live
; 3622 : 						5.2f ));		// scale
; 3623 : 						*/
; 3624 : 				}
; 3625 : 			}
; 3626 : 
; 3627 : 			break;

	jmp	$LN259@RunSeconda
$LN210@RunSeconda:

; 3628 : 		case SFX_WATER_FIREBALL:
; 3629 : 			mpos.x = (float)( (float)secondaryCount/(float)initSecondaryCount );

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+112]
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+116]
	divss	xmm0, xmm1
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3630 : 			if ( mpos.x > 0.85f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f59999a
	jbe	SHORT $LN209@RunSeconda
	jmp	$LN202@RunSeconda
$LN209@RunSeconda:

; 3631 : 			{
; 3632 : 				/*
; 3633 : 				OTWDriver.AddSfxRequest(
; 3634 : 						new SfxClass(SFX_FIRE_HOT,				// type
; 3635 : 						&pos,							// world pos
; 3636 : 						0.8f,			// time to live
; 3637 : 						scale * 0.4f ) );		// scale
; 3638 : 						*/
; 3639 : 			}
; 3640 : 			else if ( mpos.x > 0.50f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN207@RunSeconda
	jmp	$LN202@RunSeconda
$LN207@RunSeconda:

; 3641 : 			{
; 3642 : 			/*
; 3643 : 				OTWDriver.AddSfxRequest(
; 3644 : 						new SfxClass(SFX_FIRE_MED,				// type
; 3645 : 						&pos,							// world pos
; 3646 : 						0.5f,			// time to live
; 3647 : 						scale * 0.4f ) );		// scale
; 3648 : 						*/
; 3649 : 			}
; 3650 : 			else if ( mpos.x > 0.25f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	SHORT $LN205@RunSeconda

; 3651 : 			{
; 3652 : 				/*
; 3653 : 				OTWDriver.AddSfxRequest(
; 3654 : 						new SfxClass(SFX_FIRE_COOL,				// type
; 3655 : 						&pos,							// world pos
; 3656 : 						0.3f,			// time to live
; 3657 : 						scale * 0.5f ) );		// scale
; 3658 : 						*/
; 3659 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2229[ebp]
	movss	xmm0, DWORD PTR tv2229[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3660 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2233[ebp]
	movss	xmm0, DWORD PTR tv2233[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3661 : 				mvec.z = -25.0f;

	movss	xmm0, DWORD PTR __real@c1c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3662 : 				if ( (rand() & 3) == 3 )

	call	_rand

; 3663 : 				{
; 3664 : 					/*
; 3665 : 					OTWDriver.AddSfxRequest(
; 3666 : 						new SfxClass (SFX_FIRE3,		// type
; 3667 : 						SFX_MOVES,						// flags
; 3668 : 						&pos,							// world pos
; 3669 : 						&mvec,							// vector
; 3670 : 						2.0f,							// time to live
; 3671 : 						10.5f ));		// scale
; 3672 : 						*/
; 3673 : 				}
; 3674 : 				else
; 3675 : 				{
; 3676 : 					/*
; 3677 : 					OTWDriver.AddSfxRequest(
; 3678 : 						new SfxClass (SFX_BLUE_CLOUD,			// type
; 3679 : 						SFX_MOVES,						// flags
; 3680 : 						&pos,							// world pos
; 3681 : 						&mvec,							// vector
; 3682 : 						2.0f,							// time to live
; 3683 : 						10.5f ));		// scale
; 3684 : 						*/
; 3685 : 				}
; 3686 : 			}
; 3687 : 			else

	jmp	SHORT $LN202@RunSeconda
$LN205@RunSeconda:

; 3688 : 			{
; 3689 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2239[ebp]
	movss	xmm0, DWORD PTR tv2239[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3690 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2243[ebp]
	movss	xmm0, DWORD PTR tv2243[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3691 : 				mvec.z =  -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN202@RunSeconda:

; 3692 : 				/*
; 3693 : 				OTWDriver.AddSfxRequest(
; 3694 : 					new SfxClass (SFX_WATER_CLOUD,			// type
; 3695 : 					SFX_MOVES,						// flags
; 3696 : 					&pos,							// world pos
; 3697 : 					&mvec,							// vector
; 3698 : 					2.0f,							// time to live
; 3699 : 					10.5f ));		// scale
; 3700 : 					*/
; 3701 : 			}
; 3702 : 
; 3703 : 			break;

	jmp	$LN259@RunSeconda

; 3704 : 		case SFX_FIRETRAIL:
; 3705 : 			/*
; 3706 : 			OTWDriver.AddSfxRequest(
; 3707 : 					new SfxClass(SFX_FIRE_EXPAND,				// type
; 3708 : 					&pos,							// world pos
; 3709 : 					2.0f,			// time to live
; 3710 : 					scale * 0.2f ) );		// scale
; 3711 : 					*/
; 3712 : 			break;

	jmp	$LN259@RunSeconda
$LN200@RunSeconda:

; 3713 : 		case SFX_WATERTRAIL:
; 3714 : 			mpos.x = (float)( (float)secondaryCount/(float)initSecondaryCount );

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [edx+116]
	divss	xmm0, xmm1
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3715 : 			if ( mpos.x > 0.70f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f333333
	jbe	SHORT $LN199@RunSeconda

; 3716 : 			{
; 3717 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2251[ebp]
	movss	xmm0, DWORD PTR tv2251[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3718 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2255[ebp]
	movss	xmm0, DWORD PTR tv2255[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3719 : 				mvec.z = -25.0f;

	movss	xmm0, DWORD PTR __real@c1c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3720 : 				if ( (rand() & 3) == 3 )

	call	_rand

; 3721 : 				{
; 3722 : 					/*
; 3723 : 					OTWDriver.AddSfxRequest(
; 3724 : 						new SfxClass (SFX_FIRE3,		// type
; 3725 : 						SFX_MOVES,						// flags
; 3726 : 						&pos,							// world pos
; 3727 : 						&mvec,							// vector
; 3728 : 						2.0f,							// time to live
; 3729 : 						10.5f ));		// scale
; 3730 : 						*/
; 3731 : 				}
; 3732 : 				else
; 3733 : 				{
; 3734 : 				/*
; 3735 : 					OTWDriver.AddSfxRequest(
; 3736 : 						new SfxClass(SFX_BLUE_CLOUD,				// type
; 3737 : 						&pos,							// world pos
; 3738 : 						0.8f,			// time to live
; 3739 : 						scale * 0.4f ) );		// scale
; 3740 : 						*/
; 3741 : 				}

	jmp	$LN188@RunSeconda
$LN199@RunSeconda:

; 3742 : 			}
; 3743 : 			else if ( mpos.x > 0.50f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN195@RunSeconda

; 3744 : 			{
; 3745 : 				if ( (rand() & 3) == 3 )

	call	_rand

; 3746 : 				{
; 3747 : 					/*
; 3748 : 					OTWDriver.AddSfxRequest(
; 3749 : 						new SfxClass(SFX_WATER_CLOUD,				// type
; 3750 : 						&pos,							// world pos
; 3751 : 						0.5f,			// time to live
; 3752 : 						scale * 0.4f ) );		// scale
; 3753 : 						*/
; 3754 : 				}
; 3755 : 				else
; 3756 : 				{
; 3757 : 				/*
; 3758 : 					OTWDriver.AddSfxRequest(
; 3759 : 						new SfxClass(SFX_BLUE_CLOUD,				// type
; 3760 : 						&pos,							// world pos
; 3761 : 						0.5f,			// time to live
; 3762 : 						scale * 0.4f ) );		// scale
; 3763 : 						*/
; 3764 : 				}

	jmp	$LN188@RunSeconda
$LN195@RunSeconda:

; 3765 : 			}
; 3766 : 			else if ( mpos.x > 0.25f )

	movss	xmm0, DWORD PTR _mpos$[ebp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	SHORT $LN191@RunSeconda

; 3767 : 			{
; 3768 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2264[ebp]
	movss	xmm0, DWORD PTR tv2264[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3769 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2268[ebp]
	movss	xmm0, DWORD PTR tv2268[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3770 : 				mvec.z = -25.0f;

	movss	xmm0, DWORD PTR __real@c1c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3771 : 				if ( (rand() & 3) == 3 )

	call	_rand

; 3772 : 				{
; 3773 : 					/*
; 3774 : 					OTWDriver.AddSfxRequest(
; 3775 : 						new SfxClass (SFX_BLUE_CLOUD,		// type
; 3776 : 						SFX_MOVES,						// flags
; 3777 : 						&pos,							// world pos
; 3778 : 						&mvec,							// vector
; 3779 : 						2.0f,							// time to live
; 3780 : 						10.5f ));		// scale
; 3781 : 						*/
; 3782 : 				}
; 3783 : 				else
; 3784 : 				{
; 3785 : 					/*
; 3786 : 					OTWDriver.AddSfxRequest(
; 3787 : 						new SfxClass (SFX_WATER_CLOUD,			// type
; 3788 : 						SFX_MOVES,						// flags
; 3789 : 						&pos,							// world pos
; 3790 : 						&mvec,							// vector
; 3791 : 						2.0f,							// time to live
; 3792 : 						10.5f ));		// scale
; 3793 : 						*/
; 3794 : 				}
; 3795 : 			}
; 3796 : 			else

	jmp	SHORT $LN188@RunSeconda
$LN191@RunSeconda:

; 3797 : 			{
; 3798 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2274[ebp]
	movss	xmm0, DWORD PTR tv2274[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3799 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2278[ebp]
	movss	xmm0, DWORD PTR tv2278[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3800 : 				mvec.z =  -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN188@RunSeconda:

; 3801 : 				/*
; 3802 : 				OTWDriver.AddSfxRequest(
; 3803 : 					new SfxClass (SFX_WATER_CLOUD,			// type
; 3804 : 					SFX_MOVES,						// flags
; 3805 : 					&pos,							// world pos
; 3806 : 					&mvec,							// vector
; 3807 : 					2.0f,							// time to live
; 3808 : 					10.5f ));		// scale
; 3809 : 					*/
; 3810 : 			}
; 3811 : 			break;

	jmp	$LN259@RunSeconda
$LN187@RunSeconda:

; 3812 : 		case SFX_SMOKING_PART:
; 3813 : 		    if ( gSfxCount[ SFX_TRAILSMOKE ] < gSfxLODCutoff &&
; 3814 : 				 gTotSfx < gSfxLODTotCutoff )

	mov	eax, 4
	imul	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	$LN185@RunSeconda
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	$LN185@RunSeconda

; 3815 : 			{
; 3816 : 				mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2286[ebp]
	movss	xmm0, DWORD PTR tv2286[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3817 : 				mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2290[ebp]
	movss	xmm0, DWORD PTR tv2290[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3818 : 				mvec.z = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2294[ebp]
	movss	xmm0, DWORD PTR tv2294[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3819 : 
; 3820 : 				// 1st get approximation
; 3821 : 				rads = OTWDriver.GetApproxGroundLevel (pos.x, pos.y);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetApproxGroundLevel@OTWDriverClass@@QAEMMM@Z ; OTWDriverClass::GetApproxGroundLevel
	fstp	DWORD PTR _rads$[ebp]

; 3822 : 				if (  pos.z - rads  > -80.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	subss	xmm0, DWORD PTR _rads$[ebp]
	comiss	xmm0, DWORD PTR __real@c2a00000
	jbe	$LN185@RunSeconda

; 3823 : 				{
; 3824 : 					// remove the trail when we near the fround
; 3825 : 					if ( objTrail )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 0
	je	$LN184@RunSeconda

; 3826 : 					{
; 3827 : 						OTWDriver.AddSfxRequest(
; 3828 : 							new SfxClass (
; 3829 : 							21.5f,							// time to live
; 3830 : 							objTrail ));					// trail

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN263@RunSeconda
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@41ac0000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0SfxClass@@QAE@MPAVDrawableTrail@@@Z	; SfxClass::SfxClass
	mov	DWORD PTR tv509[ebp], eax
	jmp	SHORT $LN264@RunSeconda
$LN263@RunSeconda:
	mov	DWORD PTR tv509[ebp], 0
$LN264@RunSeconda:
	mov	eax, DWORD PTR tv509[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest

; 3831 : 						objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0
$LN184@RunSeconda:

; 3832 : 					}
; 3833 : 
; 3834 : 					mvec.z = -40.0f;

	movss	xmm0, DWORD PTR __real@c2200000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN185@RunSeconda:

; 3835 : 					/*
; 3836 : 					OTWDriver.AddSfxRequest(
; 3837 : 						new SfxClass (SFX_TRAILSMOKE,			// type
; 3838 : 						SFX_MOVES,						// flags
; 3839 : 						&pos,							// world pos
; 3840 : 						&mvec,							// vector
; 3841 : 						1.5f,							// time to live
; 3842 : 						3.5f ));		// scale
; 3843 : 						*/
; 3844 : 				}
; 3845 : 				else {
; 3846 : 					/*
; 3847 : 					OTWDriver.AddSfxRequest(
; 3848 : 						new SfxClass (SFX_TRAILSMOKE,			// type
; 3849 : 						SFX_MOVES,						// flags
; 3850 : 						&pos,							// world pos
; 3851 : 						&mvec,							// vector
; 3852 : 						1.0f,							// time to live
; 3853 : 						3.5f ));		// scale
; 3854 : 						*/
; 3855 : 				}
; 3856 : 			}
; 3857 : 			break;

	jmp	$LN259@RunSeconda
$LN182@RunSeconda:

; 3858 : 		case SFX_DEBRISTRAIL:
; 3859 : 			mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2319[ebp]
	movss	xmm0, DWORD PTR tv2319[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3860 : 			mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2323[ebp]
	movss	xmm0, DWORD PTR tv2323[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3861 : 			mvec.z = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2327[ebp]
	movss	xmm0, DWORD PTR tv2327[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3862 : 			/*
; 3863 : 			OTWDriver.AddSfxRequest(
; 3864 : 				new SfxClass (SFX_TRAILSMOKE,			// type
; 3865 : 				SFX_MOVES,						// flags
; 3866 : 				&pos,							// world pos
; 3867 : 				&mvec,							// vector
; 3868 : 				2.0f,							// time to live
; 3869 : 				3.5f ));		// scale
; 3870 : 				*/
; 3871 : 			break;

	jmp	$LN259@RunSeconda
$LN181@RunSeconda:

; 3872 : 		case SFX_SAM_LAUNCH:
; 3873 : 
; 3874 : 			// get a distance scale where 1.0 is about 60 miles away
; 3875 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN265@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv556[ebp], xmm0
	jmp	SHORT $LN266@RunSeconda
$LN265@RunSeconda:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv556[ebp], xmm0
$LN266@RunSeconda:
	movss	xmm0, DWORD PTR tv556[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 3876 : 		 	pos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 5.0f;

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2344[ebp]
	movss	xmm0, DWORD PTR tv2344[ebp]
	subss	xmm0, DWORD PTR __real@40a00000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 3877 : 
; 3878 : 			/*
; 3879 : 			OTWDriver.AddSfxRequest(
; 3880 : 				new SfxClass( SFX_GROUND_FLASH,			// type
; 3881 : 				&pos,					// world pos
; 3882 : 				1.0f,					// time to live
; 3883 : 				distScale * 6300.0f ) );				// scale
; 3884 : 				*/
; 3885 : 
; 3886 : 			for ( i = 0; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN180@RunSeconda
$LN179@RunSeconda:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN180@RunSeconda:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN178@RunSeconda

; 3887 : 			{
; 3888 : 				mpos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mpos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mpos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mpos$[ebp+8], eax

; 3889 : 
; 3890 : 				mpos.x += PRANDFloat() * 55.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2359[ebp]
	movss	xmm0, DWORD PTR tv2359[ebp]
	mulss	xmm0, DWORD PTR __real@425c0000
	addss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 3891 : 				mpos.y += PRANDFloat() * 55.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2364[ebp]
	movss	xmm0, DWORD PTR tv2364[ebp]
	mulss	xmm0, DWORD PTR __real@425c0000
	addss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 3892 : 
; 3893 : 				mvec.x = PRANDFloat() * 125.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2369[ebp]
	movss	xmm0, DWORD PTR tv2369[ebp]
	mulss	xmm0, DWORD PTR __real@42fa0000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3894 : 				mvec.y = PRANDFloat() * 125.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2373[ebp]
	movss	xmm0, DWORD PTR tv2373[ebp]
	mulss	xmm0, DWORD PTR __real@42fa0000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3895 : 				mvec.z = PRANDFloat() * 125.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2377[ebp]
	movss	xmm0, DWORD PTR tv2377[ebp]
	mulss	xmm0, DWORD PTR __real@42fa0000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3896 : 				/*
; 3897 : 				OTWDriver.AddSfxRequest(
; 3898 : 					new SfxClass (SFX_STEAM_CLOUD,			// type
; 3899 : 					SFX_USES_GRAVITY | SFX_MOVES | SFX_NO_DOWN_VECTOR | SFX_NO_GROUND_CHECK,				 // flags
; 3900 : 					&mpos,							// world pos
; 3901 : 					&mvec,							// vector
; 3902 : 					2.0f,							// time to live
; 3903 : 					40.5f ));		// scale
; 3904 : 					*/
; 3905 : 			}

	jmp	$LN179@RunSeconda
$LN178@RunSeconda:

; 3906 : 			break;

	jmp	$LN259@RunSeconda
$LN177@RunSeconda:

; 3907 : 		case SFX_DEBRISTRAIL_DUST:
; 3908 : 			mvec.x = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2381[ebp]
	movss	xmm0, DWORD PTR tv2381[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3909 : 			mvec.y = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2385[ebp]
	movss	xmm0, DWORD PTR tv2385[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3910 : 			mvec.z = PRANDFloat() * 25.0f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2389[ebp]
	movss	xmm0, DWORD PTR tv2389[ebp]
	mulss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3911 : 			/*
; 3912 : 			OTWDriver.AddSfxRequest(
; 3913 : 				new SfxClass (SFX_VEHICLE_DUST,			// type
; 3914 : 				SFX_MOVES,						// flags
; 3915 : 				&pos,							// world pos
; 3916 : 				&mvec,							// vector
; 3917 : 				2.0f,							// time to live
; 3918 : 				3.5f ));		// scale
; 3919 : 				*/
; 3920 : 			break;

	jmp	$LN259@RunSeconda
$LN176@RunSeconda:

; 3921 : 		case SFX_AC_AIR_EXPLOSION:
; 3922 : 			mvec.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3923 : 			mvec.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3924 : 			mvec.z = -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3925 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 3926 : 			/*
; 3927 : 			OTWDriver.AddSfxRequest(
; 3928 : 		   					new SfxClass( SFX_LONG_HANGING_SMOKE2,				// type
; 3929 : 							&pos,							// world pos
; 3930 : 							60.5f,							// time to live
; 3931 : 							scale * 0.2f ) );							// scale
; 3932 : 							*/
; 3933 : 			break;

	jmp	$LN259@RunSeconda
$LN175@RunSeconda:

; 3934 : 		case SFX_GROUND_STRIKE_NOFIRE:
; 3935 : 
; 3936 : 			mpos = pos;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _mpos$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _mpos$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _mpos$[ebp+8], ecx

; 3937 : 
; 3938 : 			mvec.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 3939 : 			mvec.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 3940 : 			mvec.z = -40.0f;

	movss	xmm0, DWORD PTR __real@c2200000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 3941 : 
; 3942 : 		    if ( gSfxCount[ SFX_TRAILSMOKE ] < gSfxLODCutoff &&
; 3943 : 			     gSfxCount[ SFX_FIRESMOKE ] < gSfxLODCutoff &&
; 3944 : 				 gTotSfx < gSfxLODTotCutoff )

	mov	edx, 4
	imul	edx, 92					; 0000005cH
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN172@RunSeconda
	mov	ecx, 4
	imul	ecx, 91					; 0000005bH
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN172@RunSeconda
	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN172@RunSeconda

; 3945 : 			{
; 3946 : 				switch ( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv602[ebp], eax
$LN172@RunSeconda:

; 3947 : 				{
; 3948 : 					case 0:
; 3949 : 						/*
; 3950 : 						OTWDriver.AddSfxRequest(
; 3951 : 							new SfxClass( SFX_FIRESMOKE,				// type
; 3952 : 							SFX_MOVES | SFX_NO_DOWN_VECTOR | SFX_NO_GROUND_CHECK,				 // flags
; 3953 : 							&mpos,							// world pos
; 3954 : 							&mvec,							// vector
; 3955 : 							3.5f,							// time to live
; 3956 : 							scale * 0.2f ) );							// scale
; 3957 : 							*/
; 3958 : 						break;
; 3959 : 					case 1:
; 3960 : 						/*
; 3961 : 						OTWDriver.AddSfxRequest(
; 3962 : 							new SfxClass( SFX_TRAILSMOKE,				// type
; 3963 : 							SFX_MOVES | SFX_NO_DOWN_VECTOR | SFX_NO_GROUND_CHECK,				 // flags
; 3964 : 							&mpos,							// world pos
; 3965 : 							&mvec,							// vector
; 3966 : 							3.5f,							// time to live
; 3967 : 							scale * 0.2f ) );							// scale
; 3968 : 							*/
; 3969 : 						break;
; 3970 : 					default:
; 3971 : 						break;
; 3972 : 				}
; 3973 : 			}
; 3974 : 			/*
; 3975 : 			OTWDriver.AddSfxRequest(
; 3976 : 				new SfxClass( SFX_GROUND_FLASH,			// type
; 3977 : 				&mpos,					// world pos
; 3978 : 				2.2f,					// time to live
; 3979 : 				scale * 2.0f ) );				// scale
; 3980 : 				*/
; 3981 : 
; 3982 : 			/*
; 3983 : 			if ( rand() & 1 )
; 3984 : 			{
; 3985 : 				OTWDriver.AddSfxRequest(
; 3986 : 					new SfxClass( SFX_SHOCK_RING_SMALL,			// type
; 3987 : 					&mpos,					// world pos
; 3988 : 					2.2f,					// time to live
; 3989 : 					scale * 0.4f ) );				// scale
; 3990 : 			}
; 3991 : 			*/
; 3992 : 
; 3993 : 			// NOTE: if using scatter plot fire, add a bit to the position
; 3994 : 			// mpos.z -= 15.0f;
; 3995 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 3996 : 
; 3997 : 			break;

	jmp	$LN259@RunSeconda
$LN168@RunSeconda:

; 3998 : 		case SFX_ARTILLERY_EXPLOSION:
; 3999 : 			mpos = pos;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _mpos$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _mpos$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _mpos$[ebp+8], ecx

; 4000 : 
; 4001 : 			mvec.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4002 : 			mvec.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4003 : 			mvec.z = -40.0f;

	movss	xmm0, DWORD PTR __real@c2200000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4004 : 			/*
; 4005 : 			OTWDriver.AddSfxRequest(
; 4006 : 		   		new SfxClass( SFX_FIRESMOKE,				// type
; 4007 : 				SFX_MOVES | SFX_NO_DOWN_VECTOR | SFX_NO_GROUND_CHECK,				 // flags
; 4008 : 				&mpos,							// world pos
; 4009 : 				&mvec,							// vector
; 4010 : 				3.5f,							// time to live
; 4011 : 				scale * 0.2f ) );							// scale
; 4012 : 				*/
; 4013 : 
; 4014 : 			/*
; 4015 : 			OTWDriver.AddSfxRequest(
; 4016 : 				new SfxClass( SFX_GROUND_FLASH,			// type
; 4017 : 				&mpos,					// world pos
; 4018 : 				2.2f,					// time to live
; 4019 : 				scale * 2.0f ) );				// scale
; 4020 : 				*/
; 4021 : 
; 4022 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4023 : 			break;

	jmp	$LN259@RunSeconda
$LN167@RunSeconda:

; 4024 : 		case SFX_GROUND_STRIKE:
; 4025 : 			mpos = pos;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _mpos$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _mpos$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _mpos$[ebp+8], edx

; 4026 : 			// NOTE: if using scatter plot fire, add a bit to the position
; 4027 : 
; 4028 : 
; 4029 : 			/*
; 4030 : 			OTWDriver.AddSfxRequest(
; 4031 : 				new SfxClass( SFX_BILLOWING_SMOKE,			// type
; 4032 : 				&mpos,					// world pos
; 4033 : 				2,					// time to live
; 4034 : 				0.3f ) );				// scale
; 4035 : 				*/
; 4036 :             
; 4037 : 			mpos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 5.0f;

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2441[ebp]
	movss	xmm0, DWORD PTR tv2441[ebp]
	subss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4038 : 			/*
; 4039 : 			OTWDriver.AddSfxRequest(
; 4040 : 				new SfxClass( SFX_GROUND_FLASH,			// type
; 4041 : 				&mpos,					// world pos
; 4042 : 				2.2f,					// time to live
; 4043 : 				scale * 2.0f ) );				// scale
; 4044 : 				*/
; 4045 : 			/*
; 4046 : 			mpos.z += 15.0f;
; 4047 : 			// mpos.z -= 15.0f;
; 4048 : 			/*
; 4049 : 			OTWDriver.AddSfxRequest(
; 4050 : 						new SfxClass(SFX_FIRE,				// type
; 4051 : 						&mpos,							// world pos
; 4052 : 						35.2f,			// time to live
; 4053 : 						70.0f) );		// scale
; 4054 : 						*/
; 4055 : 			// StartRandomDebris();
; 4056 : 			// if there'2 no 2d animation, we do a firetrail
; 4057 : 			if ( !obj2d )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	jne	$LN163@RunSeconda

; 4058 : 			{
; 4059 : 				mpos.x = pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4060 : 				mpos.y = pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4061 : 				numBursts = 3 + (int)( 3.0f * gSfxLOD );

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si edx, xmm0
	add	edx, 3
	mov	DWORD PTR _numBursts$[ebp], edx

; 4062 : 	
; 4063 : 				for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN165@RunSeconda
$LN164@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN165@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	SHORT $LN163@RunSeconda

; 4064 : 				{
; 4065 : 					// mvec.x = 10.0f * PRANDFloat() * scale * 0.01f;
; 4066 : 					// mvec.y = 10.0f * PRANDFloat() * scale * 0.01f;
; 4067 : 					mvec.z = -40.0f + PRANDFloatPos() * -80.0f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2453[ebp]
	movss	xmm0, DWORD PTR tv2453[ebp]
	mulss	xmm0, DWORD PTR __real@c2a00000
	addss	xmm0, DWORD PTR __real@c2200000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4068 : 					mvec.x = 90.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2458[ebp]
	movss	xmm0, DWORD PTR tv2458[ebp]
	mulss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4069 : 					mvec.y = 90.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2463[ebp]
	movss	xmm0, DWORD PTR tv2463[ebp]
	mulss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4070 : 	
; 4071 : 					if ( (i & 3) == 3 )
; 4072 : 					{
; 4073 : 						/*
; 4074 : 						OTWDriver.AddSfxRequest(
; 4075 : 							new SfxClass( SFX_FIRE4,		// type
; 4076 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 4077 : 							&mpos,					// world pos
; 4078 : 							&mvec,					// vel vector
; 4079 : 							1.5,					// time to live
; 4080 : 							5.0f ) );				// scale
; 4081 : 							*/
; 4082 : 					}
; 4083 : 					else
; 4084 : 					{
; 4085 : 						if ( gSfxCount[ SFX_DEBRISTRAIL ] < gSfxLODCutoff &&
; 4086 : 				 			gTotSfx < gSfxLODTotCutoff )
; 4087 : 						{
; 4088 : 							/*
; 4089 : 							OTWDriver.AddSfxRequest(
; 4090 : 								new SfxClass( SFX_DEBRISTRAIL,		// type
; 4091 : 								SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4092 : 								&mpos,					// world pos
; 4093 : 								&mvec,					// vel vector
; 4094 : 								5.0,					// time to live
; 4095 : 								scale * 0.25f ) );				// scale
; 4096 : 								*/
; 4097 : 						}
; 4098 : 					}
; 4099 : 				}

	jmp	SHORT $LN164@RunSeconda
$LN163@RunSeconda:

; 4100 : 				/*
; 4101 : 				OTWDriver.AddSfxRequest(
; 4102 : 						new SfxClass( SFX_FIREBALL,		// type
; 4103 : 						SFX_MOVES | SFX_NO_GROUND_CHECK,
; 4104 : 						&mpos,					// world pos
; 4105 : 						&mvec,					// vel vector
; 4106 : 						3.0,					// time to live
; 4107 : 						scale * 0.50f ) );				// scale
; 4108 : 				*/
; 4109 : 			}
; 4110 : 			break;

	jmp	$LN259@RunSeconda
$LN159@RunSeconda:

; 4111 : 		case SFX_WATER_STRIKE:
; 4112 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4113 : 			mpos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mpos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mpos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mpos$[ebp+8], eax

; 4114 : 			mpos.z += scale;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	addss	xmm0, DWORD PTR [ecx+104]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4115 : 			/*
; 4116 : 			OTWDriver.AddSfxRequest(
; 4117 : 				new SfxClass( SFX_SHOCK_RING_SMALL,			// type
; 4118 : 				&mpos,					// world pos
; 4119 : 				1.5f,					// time to live
; 4120 : 				scale * 0.3f ) );				// scale
; 4121 : 				*/
; 4122 : 			break;

	jmp	$LN259@RunSeconda
$LN158@RunSeconda:

; 4123 : 		case SFX_WATER_EXPLOSION:
; 4124 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4125 : 			mpos = pos;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _mpos$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _mpos$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _mpos$[ebp+8], edx

; 4126 : 			mpos.z += scale;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	addss	xmm0, DWORD PTR [eax+104]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4127 : 			/*
; 4128 : 			OTWDriver.AddSfxRequest(
; 4129 : 				new SfxClass( SFX_SHOCK_RING,			// type
; 4130 : 				&mpos,					// world pos
; 4131 : 				2.2f,					// time to live
; 4132 : 				1.0f ) );				// scale
; 4133 : 				*/
; 4134 : 
; 4135 : 			// send up some water trails
; 4136 : 			if ( obj2d == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+152], 0
	jne	$LN153@RunSeconda

; 4137 : 			{
; 4138 : 				numBursts =  2 + (int)( 6.0f * gSfxLOD );

	movss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si edx, xmm0
	add	edx, 2
	mov	DWORD PTR _numBursts$[ebp], edx

; 4139 : 				if ( numBursts )

	je	SHORT $LN156@RunSeconda

; 4140 : 				{
; 4141 : 					mpos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 10.0f;

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2502[ebp]
	movss	xmm0, DWORD PTR tv2502[ebp]
	subss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4142 : 					mpos.x = pos.x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4143 : 					mpos.y = pos.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4144 : 					mvec.z = -10.0f * scale * 0.02f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c1200000
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN156@RunSeconda:

; 4145 : 				}
; 4146 : 	
; 4147 : 				for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN155@RunSeconda
$LN154@RunSeconda:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN155@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numBursts$[ebp]
	jge	SHORT $LN153@RunSeconda

; 4148 : 				{
; 4149 : 					mvec.x = 30.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2514[ebp]
	movss	xmm0, DWORD PTR tv2514[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4150 : 					mvec.y = 30.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2520[ebp]
	movss	xmm0, DWORD PTR tv2520[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4151 : 	
; 4152 : 					/*
; 4153 : 					if ( i & 1)
; 4154 : 					{
; 4155 : 						OTWDriver.AddSfxRequest(
; 4156 : 							new SfxClass( SFX_WATER_FIREBALL,		// type
; 4157 : 							SFX_MOVES | SFX_USES_GRAVITY,
; 4158 : 							&mpos,					// world pos
; 4159 : 							&mvec,					// vel vector
; 4160 : 							3.0,					// time to live
; 4161 : 							scale * 0.25f ) );				// scale
; 4162 : 	
; 4163 : 					}
; 4164 : 					else
; 4165 : 					*/
; 4166 : 					{
; 4167 : 						/*
; 4168 : 						OTWDriver.AddSfxRequest(
; 4169 : 							new SfxClass( SFX_WATERTRAIL,		// type
; 4170 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4171 : 							&mpos,					// world pos
; 4172 : 							&mvec,					// vel vector
; 4173 : 							3.0,					// time to live
; 4174 : 							scale * 0.25f ) );				// scale
; 4175 : 							*/
; 4176 : 					}
; 4177 : 				}

	jmp	SHORT $LN154@RunSeconda
$LN153@RunSeconda:

; 4178 : 			}
; 4179 : 
; 4180 : 			break;

	jmp	$LN259@RunSeconda
$LN152@RunSeconda:

; 4181 : 		case SFX_GROUND_PENETRATION:
; 4182 : 			mpos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mpos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mpos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mpos$[ebp+8], eax

; 4183 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4184 : 			/*
; 4185 : 			OTWDriver.AddSfxRequest(
; 4186 : 				new SfxClass( SFX_SHOCK_RING,			// type
; 4187 : 				&mpos,					// world pos
; 4188 : 				2.2f,					// time to live
; 4189 : 				10.0f ) );				// scale
; 4190 : 				*/
; 4191 : 
; 4192 : 
; 4193 : 			// send up some fire trails
; 4194 : 			numBursts = 4 + (int)( 6.0f * gSfxLOD );

	movss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si ecx, xmm0
	add	ecx, 4
	mov	DWORD PTR _numBursts$[ebp], ecx

; 4195 : 			mpos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 10.0f;

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2542[ebp]
	movss	xmm0, DWORD PTR tv2542[ebp]
	subss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4196 : 			mpos.x = pos.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4197 : 			mpos.y = pos.y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4198 : 
; 4199 : 			/*
; 4200 : 			OTWDriver.AddSfxRequest(
; 4201 : 				new SfxClass( SFX_BILLOWING_SMOKE,			// type
; 4202 : 				&mpos,					// world pos
; 4203 : 				30,					// time to live
; 4204 : 				0.3f ) );				// scale
; 4205 : 				*/
; 4206 : 
; 4207 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN151@RunSeconda
$LN150@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN151@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	$LN149@RunSeconda

; 4208 : 			{
; 4209 : 				mvec.z = -80.0f * PRANDFloatPos() * scale * 0.01f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2552[ebp]
	movss	xmm0, DWORD PTR tv2552[ebp]
	mulss	xmm0, DWORD PTR __real@c2a00000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4210 : 				mvec.x = 20.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2558[ebp]
	movss	xmm0, DWORD PTR tv2558[ebp]
	mulss	xmm0, DWORD PTR __real@41a00000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4211 : 				mvec.y = 20.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2564[ebp]
	movss	xmm0, DWORD PTR tv2564[ebp]
	mulss	xmm0, DWORD PTR __real@41a00000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4212 : 
; 4213 : 				if ( (i & 7 ) == 7 )

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 7
	cmp	edx, 7
	jne	SHORT $LN148@RunSeconda
	jmp	SHORT $LN146@RunSeconda
$LN148@RunSeconda:

; 4214 : 				{
; 4215 : 					/*
; 4216 : 					OTWDriver.AddSfxRequest(
; 4217 : 						new SfxClass( SFX_FIRE5,		// type
; 4218 : 						SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 4219 : 						&mpos,					// world pos
; 4220 : 						&mvec,					// vel vector
; 4221 : 						3.0,					// time to live
; 4222 : 						scale * 0.05f ) );				// scale
; 4223 : 						*/
; 4224 : 				}
; 4225 : 				else if ( (rand() & 3) == 3 )

	call	_rand
$LN146@RunSeconda:

; 4226 : 				{
; 4227 : 					/*
; 4228 : 					OTWDriver.AddSfxRequest(
; 4229 : 						new SfxClass( SFX_DEBRISTRAIL_DUST,		// type
; 4230 : 						SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4231 : 						&mpos,					// world pos
; 4232 : 						&mvec,					// vel vector
; 4233 : 						3.0,					// time to live
; 4234 : 						scale * 0.25f ) );				// scale
; 4235 : 						*/
; 4236 : 				}
; 4237 : 				else
; 4238 : 				{
; 4239 : 					/*
; 4240 : 						OTWDriver.AddSfxRequest(
; 4241 : 							new SfxClass( SFX_DEBRISTRAIL,		// type
; 4242 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4243 : 							&mpos,					// world pos
; 4244 : 							&mvec,					// vel vector
; 4245 : 							8.0,					// time to live
; 4246 : 							scale * 0.25f ) );				// scale
; 4247 : 							*/
; 4248 : 				}
; 4249 : 			}

	jmp	$LN150@RunSeconda
$LN149@RunSeconda:

; 4250 : 
; 4251 : 			break;

	jmp	$LN259@RunSeconda
$LN144@RunSeconda:

; 4252 : 
; 4253 : 		case SFX_AIR_PENETRATION:
; 4254 : 			mpos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mpos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mpos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mpos$[ebp+8], eax

; 4255 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4256 : 
; 4257 : 			// send up some fire trails
; 4258 : 			numBursts = 2 + (int)( 2.0f * gSfxLOD );

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si ecx, xmm0
	add	ecx, 2
	mov	DWORD PTR _numBursts$[ebp], ecx

; 4259 : 
; 4260 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN143@RunSeconda
$LN142@RunSeconda:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN143@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numBursts$[ebp]
	jge	SHORT $LN141@RunSeconda

; 4261 : 			{
; 4262 : 				mvec.x = 70.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2584[ebp]
	movss	xmm0, DWORD PTR tv2584[ebp]
	mulss	xmm0, DWORD PTR __real@428c0000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4263 : 				mvec.y = 70.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2589[ebp]
	movss	xmm0, DWORD PTR tv2589[ebp]
	mulss	xmm0, DWORD PTR __real@428c0000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4264 : 				mvec.z = 70.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2594[ebp]
	movss	xmm0, DWORD PTR tv2594[ebp]
	mulss	xmm0, DWORD PTR __real@428c0000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4265 : 
; 4266 : 				/*
; 4267 : 				OTWDriver.AddSfxRequest(
; 4268 : 					new SfxClass( SFX_DEBRISTRAIL,		// type
; 4269 : 					SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4270 : 					&mpos,					// world pos
; 4271 : 					&mvec,					// vel vector
; 4272 : 					3.0,					// time to live
; 4273 : 					scale * 0.15f ) );				// scale
; 4274 : 					*/
; 4275 : 			}

	jmp	SHORT $LN142@RunSeconda
$LN141@RunSeconda:

; 4276 : 
; 4277 : 			break;

	jmp	$LN259@RunSeconda
$LN140@RunSeconda:

; 4278 : 		case SFX_GROUND_EXPLOSION:
; 4279 : 
; 4280 : 			if ( secondaryCount == 9 || obj2d )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+112], 9
	je	SHORT $LN138@RunSeconda
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN139@RunSeconda
$LN138@RunSeconda:

; 4281 : 			{
; 4282 : 				StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4283 : 				pos.z = OTWDriver.GetGroundLevel( pos.x, pos.y );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+48]

; 4284 : 				mpos = pos;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mpos$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _mpos$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _mpos$[ebp+8], eax

; 4285 : 				/*
; 4286 : 				OTWDriver.AddSfxRequest(
; 4287 : 					new SfxClass( SFX_SHOCK_RING,			// type
; 4288 : 					&mpos,					// world pos
; 4289 : 					2.2f,					// time to live
; 4290 : 					10.0f ) );				// scale
; 4291 : 				OTWDriver.AddSfxRequest(
; 4292 : 					new SfxClass( SFX_GROUND_FLASH,			// type
; 4293 : 					&mpos,					// world pos
; 4294 : 					2.2f,					// time to live
; 4295 : 					scale  ) );				// scale
; 4296 : 					*/
; 4297 : 				mpos.z = pos.z - 25.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR __real@41c80000
	movss	DWORD PTR _mpos$[ebp+8], xmm0
$LN139@RunSeconda:

; 4298 : 				/*
; 4299 : 				OTWDriver.AddSfxRequest(
; 4300 : 					new SfxClass( SFX_BILLOWING_SMOKE,			// type
; 4301 : 					&mpos,					// world pos
; 4302 : 					3,					// time to live
; 4303 : 					0.3f ) );				// scale
; 4304 : 					*/
; 4305 : 			}
; 4306 : 
; 4307 : 			if ( obj2d )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 0
	je	SHORT $LN137@RunSeconda

; 4308 : 				break;

	jmp	$LN259@RunSeconda
$LN137@RunSeconda:

; 4309 : 
; 4310 : 			if ( secondaryCount == 9 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 9
	jne	$LN136@RunSeconda

; 4311 : 			{
; 4312 : 				// mvec.z = -20.0f * scale * 0.02f;
; 4313 : 
; 4314 : 				if ( gSfxCount[ SFX_DEBRISTRAIL ] < gSfxLODCutoff &&
; 4315 : 					 gSfxCount[ SFX_FIRETRAIL ] < gSfxLODCutoff &&
; 4316 : 				 	 gTotSfx < gSfxLODTotCutoff )

	mov	ecx, 4
	imul	ecx, 53					; 00000035H
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN135@RunSeconda
	mov	eax, 4
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN135@RunSeconda
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN135@RunSeconda

; 4317 : 				{
; 4318 : 					numBursts = 8 + FloatToInt32( PRANDFloatPos() * 6.0f );

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2628[ebp]
	movss	xmm0, DWORD PTR tv2628[ebp]
	mulss	xmm0, DWORD PTR __real@40c00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 8
	mov	DWORD PTR _numBursts$[ebp], eax

; 4319 : 				}
; 4320 : 				else

	jmp	SHORT $LN134@RunSeconda
$LN135@RunSeconda:

; 4321 : 				{
; 4322 : 					numBursts = 3 + FloatToInt32( PRANDFloatPos() * 4.0f );

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2634[ebp]
	movss	xmm0, DWORD PTR tv2634[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 3
	mov	DWORD PTR _numBursts$[ebp], eax
$LN134@RunSeconda:

; 4323 : 				}
; 4324 : 	
; 4325 : 				for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN133@RunSeconda
$LN132@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN133@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	$LN131@RunSeconda

; 4326 : 				{
; 4327 : 					mpos.x = pos.x + PRANDFloat() * scale * 0.11f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2642[ebp]
	movss	xmm0, DWORD PTR tv2642[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3de147ae
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4328 : 					mpos.y = pos.y + PRANDFloat() * scale * 0.11f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2649[ebp]
	movss	xmm0, DWORD PTR tv2649[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3de147ae
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4329 : 					mpos.z = pos.z - PRANDFloatPos() * scale * 0.11f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2656[ebp]
	movss	xmm0, DWORD PTR tv2656[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3de147ae
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1

; 4330 : 
; 4331 : 					mvec.x = 30.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2663[ebp]
	movss	xmm0, DWORD PTR tv2663[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4332 : 					mvec.y = 30.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2669[ebp]
	movss	xmm0, DWORD PTR tv2669[ebp]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4333 : 					mvec.z = -8.0f * PRANDFloatPos() * scale * 0.02f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2675[ebp]
	movss	xmm0, DWORD PTR tv2675[ebp]
	mulss	xmm0, DWORD PTR __real@c1000000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4334 : 
; 4335 : 					/*
; 4336 : 					OTWDriver.AddSfxRequest(
; 4337 : 						new SfxClass(SFX_FIRE_EXPAND_NOSMOKE,				// type
; 4338 : 						SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 4339 : 						&mpos,					// world pos
; 4340 : 						&mvec,					// vel vector
; 4341 : 						1.5,					// time to live
; 4342 : 						scale * PRANDFloatPos() * 0.2f ) );		// scale
; 4343 : 					*/
; 4344 : 					if ( (rand() & 3 ) == 3 )

	call	_rand

; 4345 : 					{
; 4346 : 						/*
; 4347 : 						OTWDriver.AddSfxRequest(
; 4348 : 							new SfxClass(SFX_HIT_EXPLOSION_NOSMOKE,				// type
; 4349 : 							&mpos,					// world pos
; 4350 : 							1.8f,					// time to live
; 4351 : 							scale * 0.2f + scale * PRANDFloatPos() * 0.3f ) );		// scale
; 4352 : 							*/
; 4353 : 					}
; 4354 : 
; 4355 : 					mpos.x = pos.x + PRANDFloat() * scale * 0.05f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2682[ebp]
	movss	xmm0, DWORD PTR tv2682[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4356 : 					mpos.y = pos.y + PRANDFloat() * scale * 0.05f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2689[ebp]
	movss	xmm0, DWORD PTR tv2689[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4357 : 					mpos.z = OTWDriver.GetGroundLevel( mpos.x, mpos.y ) - 5.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2700[ebp]
	movss	xmm0, DWORD PTR tv2700[ebp]
	subss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4358 : 	
; 4359 : 					mvec.x = 10.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2704[ebp]
	movss	xmm0, DWORD PTR tv2704[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4360 : 					mvec.y = 10.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2710[ebp]
	movss	xmm0, DWORD PTR tv2710[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4361 : 					mvec.z = -18.0f * PRANDFloatPos() * scale * 0.01f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2716[ebp]
	movss	xmm0, DWORD PTR tv2716[ebp]
	mulss	xmm0, DWORD PTR __real@c1900000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4362 : 					if ( approxDist < SFX_LOD_DIST &&
; 4363 : 						 gSfxCount[ SFX_DEBRISTRAIL ] < gSfxLODCutoff &&
; 4364 : 						 gSfxCount[ SFX_FIRETRAIL ] < gSfxLODCutoff &&
; 4365 : 				 		gTotSfx < gSfxLODTotCutoff )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@47c35000
	comiss	xmm0, DWORD PTR [eax+132]
	jbe	SHORT $LN128@RunSeconda
	mov	ecx, 4
	imul	ecx, 53					; 00000035H
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN128@RunSeconda
	mov	eax, 4
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN128@RunSeconda
	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN128@RunSeconda

; 4366 : 					{
; 4367 : 						if ( rand() & 1 )

	call	_rand
$LN128@RunSeconda:

; 4368 : 						{}
; 4369 : 							/*
; 4370 : 							OTWDriver.AddSfxRequest(
; 4371 : 								new SfxClass( SFX_FIRETRAIL,		// type
; 4372 : 								SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4373 : 								&mpos,					// world pos
; 4374 : 								&mvec,					// vel vector
; 4375 : 								4.0,					// time to live
; 4376 : 								scale * 0.25f ) );				// scale
; 4377 : 								*/
; 4378 : 						else
; 4379 : 						{}
; 4380 : 						/*
; 4381 : 							OTWDriver.AddSfxRequest(
; 4382 : 									new SfxClass( SFX_DEBRISTRAIL,		// type
; 4383 : 									SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4384 : 									&mpos,					// world pos
; 4385 : 									&mvec,					// vel vector
; 4386 : 									6.0,					// time to live
; 4387 : 									scale * 0.25f ) );				// scale
; 4388 : 									*/
; 4389 : 					}
; 4390 : 				}

	jmp	$LN132@RunSeconda
$LN131@RunSeconda:

; 4391 : 				vec.z -= scale * 0.60f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3f19999a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+60]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+60], xmm1

; 4392 : 			}
; 4393 : 			else

	jmp	$LN115@RunSeconda
$LN136@RunSeconda:

; 4394 : 			{
; 4395 : 				// vec.z -= scale * 0.15f;
; 4396 : 				// if ( (rand() & 3) == 3 )
; 4397 : 				if ( secondaryCount & 1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	and	ecx, 1
	je	$LN125@RunSeconda

; 4398 : 				{
; 4399 : 					vec.z -= scale * 0.20f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+60]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm1

; 4400 : 					mpos.x = pos.x + PRANDFloat() * scale * 0.21f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2742[ebp]
	movss	xmm0, DWORD PTR tv2742[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3e570a3d
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4401 : 					mpos.y = pos.y + PRANDFloat() * scale * 0.21f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2749[ebp]
	movss	xmm0, DWORD PTR tv2749[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3e570a3d
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4402 : 					mpos.z = pos.z + vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	addss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4403 : 	
; 4404 : 					mvec.x = 10.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2759[ebp]
	movss	xmm0, DWORD PTR tv2759[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4405 : 					mvec.y = 10.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2765[ebp]
	movss	xmm0, DWORD PTR tv2765[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4406 : 					mvec.z = -10.0f * PRANDFloatPos() * scale * 0.01f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2771[ebp]
	movss	xmm0, DWORD PTR tv2771[ebp]
	mulss	xmm0, DWORD PTR __real@c1200000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4407 : 	
; 4408 : 					if ( (rand() & 1) == 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN124@RunSeconda

; 4409 : 					{
; 4410 : 						mpos.z = pos.z + vec.z * 0.3F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0
	jmp	SHORT $LN122@RunSeconda
$LN124@RunSeconda:

; 4411 : 						/*
; 4412 : 						OTWDriver.AddSfxRequest(
; 4413 : 							new SfxClass(SFX_HIT_EXPLOSION_NOSMOKE,				// type
; 4414 : 							&mpos,					// world pos
; 4415 : 							1.5f,					// time to live
; 4416 : 							scale * 0.2f + scale * PRANDFloatPos() * 0.3f ) );		// scale
; 4417 : 							*/
; 4418 : 					}
; 4419 : 					else if ( (rand() & 1) == 1 )

	call	_rand
$LN122@RunSeconda:

; 4420 : 					{}
; 4421 : 						/*
; 4422 : 						OTWDriver.AddSfxRequest(
; 4423 : 							new SfxClass( SFX_BIG_DUST,		// type
; 4424 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 4425 : 							&mpos,					// world pos
; 4426 : 							&mvec,					// vel vector
; 4427 : 							1.5,					// time to live
; 4428 : 							scale * 0.55f ) );				// scale
; 4429 : 							*/
; 4430 : 					else
; 4431 : 					{}
; 4432 : 					/*
; 4433 : 						OTWDriver.AddSfxRequest(
; 4434 : 							new SfxClass( SFX_BIG_SMOKE,		// type
; 4435 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 4436 : 							&mpos,					// world pos
; 4437 : 							&mvec,					// vel vector
; 4438 : 							1.5,					// time to live
; 4439 : 							scale * 0.55f ) );				// scale
; 4440 : 							*/
; 4441 : 				}
; 4442 : 				else

	jmp	$LN115@RunSeconda
$LN125@RunSeconda:

; 4443 : 				{
; 4444 : 					if ( (rand() & 1) == 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN119@RunSeconda

; 4445 : 					{
; 4446 : 						mpos.x = pos.x + PRANDFloat() * scale * 0.21f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2784[ebp]
	movss	xmm0, DWORD PTR tv2784[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3e570a3d
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4447 : 						mpos.y = pos.y + PRANDFloat() * scale * 0.21f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2791[ebp]
	movss	xmm0, DWORD PTR tv2791[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3e570a3d
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4448 : 						mpos.z = pos.z + vec.z * 0.3F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0
$LN119@RunSeconda:

; 4449 : 						/*
; 4450 : 						OTWDriver.AddSfxRequest(
; 4451 : 							new SfxClass(SFX_HIT_EXPLOSION_NOSMOKE,				// type
; 4452 : 							&mpos,					// world pos
; 4453 : 							1.5f,					// time to live
; 4454 : 							scale * 0.2f + scale * PRANDFloatPos() * 0.3f ) );		// scale
; 4455 : 							*/
; 4456 : 					}
; 4457 : 
; 4458 : 					if ( approxDist < SFX_LOD_DIST &&
; 4459 : 						 gSfxCount[ SFX_DEBRISTRAIL ] < gSfxLODCutoff &&
; 4460 : 						 gSfxCount[ SFX_FIRETRAIL ] < gSfxLODCutoff &&
; 4461 : 				 		gTotSfx < gSfxLODTotCutoff )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@47c35000
	comiss	xmm0, DWORD PTR [ecx+132]
	jbe	$LN115@RunSeconda
	mov	edx, 4
	imul	edx, 53					; 00000035H
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	$LN115@RunSeconda
	mov	ecx, 4
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	$LN115@RunSeconda
	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	$LN115@RunSeconda

; 4462 : 					{
; 4463 : 
; 4464 : 						for ( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN117@RunSeconda
$LN116@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN117@RunSeconda:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN115@RunSeconda

; 4465 : 						{
; 4466 : 							mpos.x = pos.x + PRANDFloat() * scale * 0.05f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2810[ebp]
	movss	xmm0, DWORD PTR tv2810[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4467 : 							mpos.y = pos.y + PRANDFloat() * scale * 0.05f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2817[ebp]
	movss	xmm0, DWORD PTR tv2817[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4468 : 							mpos.z = OTWDriver.GetGroundLevel( mpos.x, mpos.y ) - 5.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2828[ebp]
	movss	xmm0, DWORD PTR tv2828[ebp]
	subss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4469 : 			
; 4470 : 							mvec.x = 10.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2832[ebp]
	movss	xmm0, DWORD PTR tv2832[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4471 : 							mvec.y = 10.0f * PRANDFloat() * scale * 0.01f;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2838[ebp]
	movss	xmm0, DWORD PTR tv2838[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4472 : 							mvec.z = -38.0f * PRANDFloatPos() * scale * 0.01f;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2844[ebp]
	movss	xmm0, DWORD PTR tv2844[ebp]
	mulss	xmm0, DWORD PTR __real@c2180000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+104]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4473 : 			
; 4474 : 							/*
; 4475 : 							OTWDriver.AddSfxRequest(
; 4476 : 									new SfxClass( SFX_DEBRISTRAIL,		// type
; 4477 : 									SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4478 : 									&mpos,					// world pos
; 4479 : 									&mvec,					// vel vector
; 4480 : 									6.0,					// time to live
; 4481 : 									scale * 0.25f ) );				// scale
; 4482 : 									*/
; 4483 : 						}

	jmp	$LN116@RunSeconda
$LN115@RunSeconda:

; 4484 : 					}
; 4485 : 				}
; 4486 : 			}
; 4487 : 
; 4488 : 			break;

	jmp	$LN259@RunSeconda

; 4489 : 		case SFX_AIR_EXPLOSION:
; 4490 : 			/*
; 4491 : 			OTWDriver.AddSfxRequest(
; 4492 : 				new SfxClass( SFX_EXPLCROSS_GLOW,			// type
; 4493 : 				&pos,					// world pos
; 4494 : 				1.2f,					// time to live
; 4495 : 				0.1f ) );				// scale
; 4496 : 			*/
; 4497 : 			/*
; 4498 : 			OTWDriver.AddSfxRequest(
; 4499 : 				new SfxClass( SFX_EXPLCIRC_GLOW,			// type
; 4500 : 				&pos,					// world pos
; 4501 : 				1.8f,					// time to live
; 4502 : 				scale ) );				// scale
; 4503 : 				*/
; 4504 : 			break;

	jmp	$LN259@RunSeconda
$LN113@RunSeconda:

; 4505 : 		case SFX_ROCKET_BURST:
; 4506 : 			if ( gSfxCount[ SFX_SPARKS ] < gSfxLODCutoff &&
; 4507 : 				 gSfxCount[ SFX_FIRETRAIL ] < gSfxLODCutoff &&
; 4508 : 				 gTotSfx < gSfxLODTotCutoff )

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN112@RunSeconda
	mov	edx, 4
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN112@RunSeconda
	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN112@RunSeconda

; 4509 : 			{
; 4510 : 				numBursts = 24 + FloatToInt32( PRANDFloatPos() * 10.0f );

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2855[ebp]
	movss	xmm0, DWORD PTR tv2855[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 24					; 00000018H
	mov	DWORD PTR _numBursts$[ebp], eax

; 4511 : 			}
; 4512 : 			else

	jmp	SHORT $LN111@RunSeconda
$LN112@RunSeconda:

; 4513 : 			{
; 4514 : 				numBursts = 5 + FloatToInt32( PRANDFloatPos() * 10.0f );

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2861[ebp]
	movss	xmm0, DWORD PTR tv2861[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 5
	mov	DWORD PTR _numBursts$[ebp], eax
$LN111@RunSeconda:

; 4515 : 			}
; 4516 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN110@RunSeconda
$LN109@RunSeconda:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN110@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numBursts$[ebp]
	jge	SHORT $LN108@RunSeconda

; 4517 : 			{
; 4518 : 				mvec.x = vec.x + 200.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2869[ebp]
	movss	xmm0, DWORD PTR tv2869[ebp]
	mulss	xmm0, DWORD PTR __real@43480000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4519 : 				mvec.y = vec.y + 200.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2876[ebp]
	movss	xmm0, DWORD PTR tv2876[ebp]
	mulss	xmm0, DWORD PTR __real@43480000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4520 : 				mvec.z = vec.z + 200.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2883[ebp]
	movss	xmm0, DWORD PTR tv2883[ebp]
	mulss	xmm0, DWORD PTR __real@43480000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4521 : 				/*
; 4522 : 				if ( (rand() & 3) == 3 )
; 4523 : 				{
; 4524 : 					OTWDriver.AddSfxRequest(
; 4525 : 						new SfxClass( SFX_EXPLCIRC_GLOW,		// type
; 4526 : 						SFX_MOVES | SFX_USES_GRAVITY,
; 4527 : 						&pos,					// world pos
; 4528 : 						&mvec,					// vel vector
; 4529 : 						3.5f,					// time to live
; 4530 : 						12.0f ) );				// scale
; 4531 : 				}
; 4532 : 				else
; 4533 : 				*/
; 4534 : 				{
; 4535 : 					/*
; 4536 : 					OTWDriver.AddSfxRequest(
; 4537 : 						new SfxClass( SFX_SPARKS,		// type
; 4538 : 						SFX_MOVES | SFX_USES_GRAVITY,
; 4539 : 						&pos,					// world pos
; 4540 : 						&mvec,					// vel vector
; 4541 : 						3.5f,					// time to live
; 4542 : 						12.0f ) );				// scale
; 4543 : 						*/
; 4544 : 				}
; 4545 : 			}

	jmp	$LN109@RunSeconda
$LN108@RunSeconda:

; 4546 : 			break;

	jmp	$LN259@RunSeconda
$LN107@RunSeconda:

; 4547 : 		case SFX_MISSILE_BURST:
; 4548 : 			mvec.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4549 : 			mvec.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4550 : 			mvec.z = -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4551 : 			/*
; 4552 : 			OTWDriver.AddSfxRequest(
; 4553 : 		   					new SfxClass( SFX_LONG_HANGING_SMOKE2,				// type
; 4554 : 							&pos,							// world pos
; 4555 : 							30.5f,							// time to live
; 4556 : 							scale * 0.5f ) );							// scale
; 4557 : 							*/
; 4558 : 
; 4559 : 			// do som extra busts possibly...
; 4560 : 			/*
; 4561 : 			OTWDriver.AddSfxRequest(
; 4562 : 				new SfxClass( SFX_EXPLCROSS_GLOW,			// type
; 4563 : 				&pos,					// world pos
; 4564 : 				1.2f,					// time to live
; 4565 : 				0.1f ) );			 	// scale
; 4566 : 			*/
; 4567 : 			/*
; 4568 : 			OTWDriver.AddSfxRequest(
; 4569 : 				new SfxClass( SFX_EXPLCIRC_GLOW,			// type
; 4570 : 				&pos,					// world pos
; 4571 : 				1.8f,					// time to live
; 4572 : 				scale ) );			 	// scale
; 4573 : 				*/
; 4574 : 
; 4575 : 			numBursts = (int)(5.0f * gSfxLOD) + PRANDInt3();

	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si esi, xmm0
	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	add	esi, eax
	mov	DWORD PTR _numBursts$[ebp], esi

; 4576 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN106@RunSeconda
$LN105@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN106@RunSeconda:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numBursts$[ebp]
	jge	SHORT $LN104@RunSeconda

; 4577 : 			{
; 4578 : 				mvec.x = vec.x + 100.0f * PRANDFloat(); // MLR 1/2/2004 - 

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2897[ebp]
	movss	xmm0, DWORD PTR tv2897[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4579 : 				mvec.y = vec.y + 100.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2904[ebp]
	movss	xmm0, DWORD PTR tv2904[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4580 : 				mvec.z = vec.z + 100.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2911[ebp]
	movss	xmm0, DWORD PTR tv2911[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4581 : 				/*
; 4582 : 				OTWDriver.AddSfxRequest(
; 4583 : 					new SfxClass( SFX_SMOKETRAIL,		// type
; 4584 : 					SFX_MOVES | SFX_USES_GRAVITY,
; 4585 : 					&pos,					// world pos
; 4586 : 					&mvec,					// vel vector
; 4587 : 					1.0,					// time to live
; 4588 : 					10.0f ) );				// scale
; 4589 : 					*/
; 4590 : 			}

	jmp	$LN105@RunSeconda
$LN104@RunSeconda:

; 4591 : 
; 4592 : 			// just some falling pieces of junk
; 4593 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN103@RunSeconda
$LN102@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN103@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	SHORT $LN101@RunSeconda

; 4594 : 			{
; 4595 : 				mvec.x = 100.0f * PRANDFloat(); // MLR 1/2/2004 - 

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2920[ebp]
	movss	xmm0, DWORD PTR tv2920[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4596 : 				mvec.y = 100.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2925[ebp]
	movss	xmm0, DWORD PTR tv2925[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4597 : 				mvec.z = 100.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2930[ebp]
	movss	xmm0, DWORD PTR tv2930[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4598 : 				/*
; 4599 : 				OTWDriver.AddSfxRequest(
; 4600 : 					new SfxClass( SFX_SMOKETRAIL,		// type
; 4601 : 					SFX_MOVES | SFX_USES_GRAVITY,
; 4602 : 					&pos,					// world pos
; 4603 : 					&mvec,					// vel vector
; 4604 : 					1.0,					// time to live
; 4605 : 					10.0f ) );				// scale
; 4606 : 					*/
; 4607 : 			}

	jmp	SHORT $LN102@RunSeconda
$LN101@RunSeconda:

; 4608 : 
; 4609 : 			break;

	jmp	$LN259@RunSeconda
$LN100@RunSeconda:

; 4610 : 		case SFX_HIT_EXPLOSION_NOGLOW:
; 4611 : 			mvec.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4612 : 			mvec.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4613 : 			mvec.z = -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4614 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4615 : 			if ( rand() & 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN99@RunSeconda

; 4616 : 				/*
; 4617 : 				OTWDriver.AddSfxRequest(
; 4618 : 		   			new SfxClass( SFX_LONG_HANGING_SMOKE2,				// type
; 4619 : 					&pos,							// world pos
; 4620 : 					60.5f,							// time to live
; 4621 : 					scale * 0.5f ) );							// scale
; 4622 : 					*/
; 4623 : 
; 4624 : 			break;

	jmp	$LN259@RunSeconda
$LN99@RunSeconda:

; 4625 : 		case SFX_HIT_EXPLOSION_NOSMOKE:
; 4626 : 			/*
; 4627 : 			OTWDriver.AddSfxRequest(
; 4628 : 				new SfxClass( SFX_EXPLCIRC_GLOW,			// type
; 4629 : 				&pos,					// world pos
; 4630 : 				1.8f,					// time to live
; 4631 : 				scale ) );				// scale
; 4632 : 				*/
; 4633 : 			break;

	jmp	$LN259@RunSeconda
$LN97@RunSeconda:

; 4634 : 		case SFX_HIT_EXPLOSION:
; 4635 : 			mvec.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4636 : 			mvec.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4637 : 			mvec.z = -20.0f;

	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4638 : 			StartRandomDebris();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRandomDebris@SfxClass@@IAEXXZ	; SfxClass::StartRandomDebris

; 4639 : 			/*
; 4640 : 			OTWDriver.AddSfxRequest(
; 4641 : 				new SfxClass( SFX_EXPLCIRC_GLOW,			// type
; 4642 : 				&pos,					// world pos
; 4643 : 				1.8f,					// time to live
; 4644 : 				scale ) );				// scale
; 4645 : 				*/
; 4646 : 			if ( rand() & 1 )

	call	_rand
	and	eax, 1
	je	SHORT $LN96@RunSeconda

; 4647 : 				/*
; 4648 : 				OTWDriver.AddSfxRequest(
; 4649 : 		   					new SfxClass( SFX_LONG_HANGING_SMOKE2,				// type
; 4650 : 							&pos,							// world pos
; 4651 : 							60.5f,							// time to live
; 4652 : 							scale * 0.5f ) );							// scale
; 4653 : 							*/
; 4654 : 
; 4655 : 			break;

	jmp	$LN259@RunSeconda
$LN96@RunSeconda:

; 4656 : 
; 4657 : 		// these next 2 are for campaign calls only (from campweaponfire)
; 4658 : 		case SFX_VEHICLE_BURNING:
; 4659 : 			pos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 40.0f;

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2949[ebp]
	movss	xmm0, DWORD PTR tv2949[ebp]
	subss	xmm0, DWORD PTR __real@42200000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+48], xmm0

; 4660 : 			/*
; 4661 : 			OTWDriver.AddSfxRequest( new SfxClass( SFX_FIRE,
; 4662 : 				 &pos,
; 4663 : 				 60.0f,
; 4664 : 				 90.0f ) );
; 4665 : 				 */
; 4666 : 			break;

	jmp	$LN259@RunSeconda
$LN94@RunSeconda:

; 4667 : 		case SFX_CAMP_HIT_EXPLOSION_DEBRISTRAIL:
; 4668 : 			if ( pos.z > 0.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN93@RunSeconda

; 4669 : 				pos.z = OTWDriver.GetGroundLevel( pos.x, pos.y ) - 40.0f;

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv2962[ebp]
	movss	xmm0, DWORD PTR tv2962[ebp]
	subss	xmm0, DWORD PTR __real@42200000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0
$LN93@RunSeconda:

; 4670 : 			/*
; 4671 : 			OTWDriver.AddSfxRequest( new SfxClass( SFX_VEHICLE_EXPLOSION,
; 4672 : 				 &pos,
; 4673 : 				 2.0f,
; 4674 : 				 200.0f ) );
; 4675 : 				 */
; 4676 : 			break;

	jmp	$LN259@RunSeconda
$LN92@RunSeconda:

; 4677 : 
; 4678 : 		case SFX_VEHICLE_EXPLOSION:
; 4679 : 			numBursts = (int)(6.0f * gSfxLOD) + PRANDInt3();

	movss	xmm0, DWORD PTR __real@40c00000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si esi, xmm0
	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	add	esi, eax
	mov	DWORD PTR _numBursts$[ebp], esi

; 4680 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN91@RunSeconda
$LN90@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN91@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	$LN89@RunSeconda

; 4681 : 			{
; 4682 : 				mvec.x = 60.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2971[ebp]
	movss	xmm0, DWORD PTR tv2971[ebp]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4683 : 				mvec.y = 60.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv2976[ebp]
	movss	xmm0, DWORD PTR tv2976[ebp]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4684 : 				mvec.z = -80.0f * PRANDFloatPos();

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv2981[ebp]
	movss	xmm0, DWORD PTR tv2981[ebp]
	mulss	xmm0, DWORD PTR __real@c2a00000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 4685 : 
; 4686 : 				if ( approxDist < SFX_LOD_DIST &&
; 4687 : 					 gSfxCount[ SFX_DEBRISTRAIL ] < gSfxLODCutoff &&
; 4688 : 					 gSfxCount[ SFX_FIRETRAIL ] < gSfxLODCutoff &&
; 4689 : 				 	gTotSfx < gSfxLODTotCutoff )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@47c35000
	comiss	xmm0, DWORD PTR [edx+132]
	jbe	SHORT $LN87@RunSeconda
	mov	eax, 4
	imul	eax, 53					; 00000035H
	mov	ecx, DWORD PTR ?gSfxCount@@3PAHA[eax]
	cmp	ecx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN87@RunSeconda
	mov	edx, 4
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[edx]
	cmp	eax, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN87@RunSeconda
	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jge	SHORT $LN87@RunSeconda

; 4690 : 				{
; 4691 : 					if ( PRANDInt3() == 1 )

	call	?PRANDInt3@@YAHXZ			; PRANDInt3
$LN87@RunSeconda:

; 4692 : 					{
; 4693 : 						/*
; 4694 : 						OTWDriver.AddSfxRequest(
; 4695 : 							new SfxClass( SFX_DEBRISTRAIL,		// type
; 4696 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4697 : 							&pos,					// world pos
; 4698 : 							&mvec,					// vel vector
; 4699 : 							6.0,					// time to live
; 4700 : 							10.0f ) );				// scale
; 4701 : 							*/
; 4702 : 					}
; 4703 : 					else
; 4704 : 					{
; 4705 : 						/*
; 4706 : 						OTWDriver.AddSfxRequest(
; 4707 : 							new SfxClass( SFX_FIRETRAIL,		// type
; 4708 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_BOUNCES,
; 4709 : 							&pos,					// world pos
; 4710 : 							&mvec,					// vel vector
; 4711 : 							6.0,					// time to live
; 4712 : 							10.0f ) );				// scale
; 4713 : 							*/
; 4714 : 					}
; 4715 : 				}
; 4716 : 			}

	jmp	$LN90@RunSeconda
$LN89@RunSeconda:

; 4717 : 
; 4718 : 			break;

	jmp	$LN259@RunSeconda
$LN85@RunSeconda:

; 4719 : 		case SFX_DIST_AIRBURSTS:
; 4720 : 
; 4721 : 			// do LOD for distant sfx
; 4722 : 			if ( gTotSfx > gSfxLODDistCutoff )

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	edx, DWORD PTR ?gSfxLODDistCutoff@@3HA	; gSfxLODDistCutoff
	jle	SHORT $LN84@RunSeconda

; 4723 : 			{
; 4724 : 				break;

	jmp	$LN259@RunSeconda
$LN84@RunSeconda:

; 4725 : 			}
; 4726 : 
; 4727 : 			// check distance to view, if too close don't run....
; 4728 : 			// about 6 miles?
; 4729 : 			if ( approxDist < 10000.0f )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR [eax+132]
	jbe	SHORT $LN83@RunSeconda

; 4730 : 				break;

	jmp	$LN259@RunSeconda
$LN83@RunSeconda:

; 4731 : 
; 4732 : 			// get a distance scale where 1.0 is about 60 miles away
; 4733 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN267@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv1143[ebp], xmm0
	jmp	SHORT $LN268@RunSeconda
$LN267@RunSeconda:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv1143[ebp], xmm0
$LN268@RunSeconda:
	movss	xmm0, DWORD PTR tv1143[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 4734 : 	
; 4735 : 			mpos.x = pos.x + 6000.0f * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3004[ebp]
	movss	xmm0, DWORD PTR tv3004[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4736 : 			mpos.y = pos.y + 6000.0f * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3011[ebp]
	movss	xmm0, DWORD PTR tv3011[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4737 : 			mpos.z = pos.z - 6000.0f * PRANDFloatPos() * distScale;

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv3018[ebp]
	movss	xmm0, DWORD PTR tv3018[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+48]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1

; 4738 : 
; 4739 : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv1163[ebp], eax

; 4740 : 			{
; 4741 : 				case 0:
; 4742 : 				case 4:
; 4743 : 					/*
; 4744 : 					OTWDriver.AddSfxRequest(
; 4745 : 						new SfxClass( SFX_AIR_EXPLOSION_NOGLOW,			// type
; 4746 : 						&mpos,					// world pos
; 4747 : 						1.2f,					// time to live
; 4748 : 						600.0f * distScale ) );				// scale
; 4749 : 						*/
; 4750 : 					break;
; 4751 : 				case 1:
; 4752 : 				case 2:
; 4753 : 					/*
; 4754 : 					OTWDriver.AddSfxRequest(
; 4755 : 						new SfxClass( SFX_SPARKS,			// type
; 4756 : 						&mpos,					// world pos
; 4757 : 						1.2f,					// time to live
; 4758 : 						4.0f * 800.0f * distScale ) );				// scale
; 4759 : 						*/
; 4760 : 					break;
; 4761 : 				case 3:
; 4762 : 					/*
; 4763 : 					OTWDriver.AddSfxRequest(
; 4764 : 						new SfxClass( SFX_AC_AIR_EXPLOSION,			// type
; 4765 : 						&mpos,					// world pos
; 4766 : 						2.2f,					// time to live
; 4767 : 						500.0f * distScale ) );				// scale
; 4768 : 						*/
; 4769 : 					break;
; 4770 : 			}
; 4771 : 
; 4772 : 
; 4773 : 			break;

	jmp	$LN259@RunSeconda
$LN77@RunSeconda:

; 4774 : 
; 4775 : 		case SFX_AIRBURST:
; 4776 : 
; 4777 : 			mpos.x = pos.x + 800.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3026[ebp]
	movss	xmm0, DWORD PTR tv3026[ebp]
	mulss	xmm0, DWORD PTR __real@44480000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4778 : 			mpos.y = pos.y + 800.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3033[ebp]
	movss	xmm0, DWORD PTR tv3033[ebp]
	mulss	xmm0, DWORD PTR __real@44480000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4779 : 			mpos.z = pos.z + 100.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3040[ebp]
	movss	xmm0, DWORD PTR tv3040[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4780 : 
; 4781 : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv1180[ebp], eax

; 4782 : 			{
; 4783 : 				case 0:
; 4784 : 					/*
; 4785 : 					OTWDriver.AddSfxRequest(
; 4786 : 						new SfxClass( SFX_AAA_EXPLOSION,			// type
; 4787 : 						&mpos,					// world pos
; 4788 : 						1.3f,					// time to live
; 4789 : 						14.0f ) );				// scale
; 4790 : 						*/
; 4791 : 					break;
; 4792 : 				case 1:
; 4793 : 					/*
; 4794 : 					OTWDriver.AddSfxRequest(
; 4795 : 						new SfxClass( SFX_AAA_EXPLOSION,			// type
; 4796 : 						&mpos,					// world pos
; 4797 : 						1.3f,					// time to live
; 4798 : 						14.0f ) );				// scale
; 4799 : 						*/
; 4800 : 					break;
; 4801 : 				case 4:
; 4802 : 					/*
; 4803 : 					OTWDriver.AddSfxRequest(
; 4804 : 						new SfxClass( SFX_AAA_EXPLOSION,			// type
; 4805 : 						&mpos,					// world pos
; 4806 : 						1.3f,					// time to live
; 4807 : 						14.0f ) );				// scale
; 4808 : 						*/
; 4809 : 					break;
; 4810 : 				case 2:
; 4811 : 					/*
; 4812 : 					OTWDriver.AddSfxRequest(
; 4813 : 						new SfxClass( SFX_SMALL_HIT_EXPLOSION,			// type
; 4814 : 						&mpos,					// world pos
; 4815 : 						1.4f,					// time to live
; 4816 : 						13.0f ) );				// scale
; 4817 : 						*/
; 4818 : 					break;
; 4819 : 				case 3:
; 4820 : 					/*
; 4821 : 					OTWDriver.AddSfxRequest(
; 4822 : 						new SfxClass( SFX_SMALL_HIT_EXPLOSION,			// type
; 4823 : 						&mpos,					// world pos
; 4824 : 						1.4f,					// time to live
; 4825 : 						15.0f ) );				// scale
; 4826 : 						*/
; 4827 : 					break;
; 4828 : 			}
; 4829 : 
; 4830 : 			if ( gSfxCount[ SFX_LONG_HANGING_SMOKE2 ] < gSfxLODCutoff &&
; 4831 : 				 gTotSfx < gSfxLODTotCutoff )
; 4832 : 			{
; 4833 : 				/*
; 4834 : 				OTWDriver.AddSfxRequest(
; 4835 :    					new SfxClass( SFX_LONG_HANGING_SMOKE2,				// type
; 4836 : 					&mpos,							// world pos
; 4837 : 					30.5f,							// time to live
; 4838 : 					10.0f ) );							// scale
; 4839 : 					*/
; 4840 : 			}
; 4841 : 
; 4842 : 			// sound
; 4843 : 			F4SoundFXSetPos( SFX_IMPACTA1 + PRANDInt5(), TRUE, mpos.x, mpos.y, mpos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 54					; 00000036H
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 4844 : 
; 4845 : 			break;

	jmp	$LN259@RunSeconda
$LN68@RunSeconda:

; 4846 : 		
; 4847 : 		case SFX_DIST_GROUNDBURSTS:
; 4848 : 
; 4849 : 			// do LOD for distant sfx
; 4850 : 			if ( gTotSfx > gSfxLODDistCutoff )

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gSfxLODDistCutoff@@3HA	; gSfxLODDistCutoff
	jle	SHORT $LN67@RunSeconda

; 4851 : 			{
; 4852 : 				break;

	jmp	$LN259@RunSeconda
$LN67@RunSeconda:

; 4853 : 			}
; 4854 : 
; 4855 : 			// check distance to view, if too close don't run....
; 4856 : 			// about 6 miles?
; 4857 : 			if ( approxDist < 10000.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR [ecx+132]
	jbe	SHORT $LN66@RunSeconda

; 4858 : 				break;

	jmp	$LN259@RunSeconda
$LN66@RunSeconda:

; 4859 : 
; 4860 : 			// get a distance scale where 1.0 is about 60 miles away
; 4861 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN269@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv1205[ebp], xmm0
	jmp	SHORT $LN270@RunSeconda
$LN269@RunSeconda:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv1205[ebp], xmm0
$LN270@RunSeconda:
	movss	xmm0, DWORD PTR tv1205[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 4862 : 
; 4863 : 			mpos.x = pos.x + 6000.0f * PRANDFloat()* distScale ;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3072[ebp]
	movss	xmm0, DWORD PTR tv3072[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4864 : 			mpos.y = pos.y + 6000.0f * PRANDFloat()* distScale ;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3079[ebp]
	movss	xmm0, DWORD PTR tv3079[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4865 : 			mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 10.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3090[ebp]
	movss	xmm0, DWORD PTR tv3090[ebp]
	subss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4866 : 
; 4867 : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv1225[ebp], eax

; 4868 : 			{
; 4869 : 				case 0:
; 4870 : 					/*
; 4871 : 				OTWDriver.AddSfxRequest(
; 4872 : 					new SfxClass( SFX_GROUND_FLASH,			// type
; 4873 : 					&mpos,					// world pos
; 4874 : 					2.2f,					// time to live
; 4875 : 					distScale * 6300.0f ) );				// scale
; 4876 : 					*/
; 4877 : 				case 4:
; 4878 : 					/*
; 4879 : 					OTWDriver.AddSfxRequest(
; 4880 : 						// new SfxClass( SFX_GROUND_EXPLOSION_NO_CRATER,	// type
; 4881 : 						new SfxClass( SFX_SPARKS,	// type
; 4882 : 						&mpos,					// world pos
; 4883 : 						2.2f,					// time to live
; 4884 : 						4.0f * 800.0f * distScale ) );				// scale
; 4885 : 						*/
; 4886 : 					break;
; 4887 : 				case 1:
; 4888 : 					/*
; 4889 : 					OTWDriver.AddSfxRequest(
; 4890 : 					new SfxClass( SFX_FEATURE_EXPLOSION,			// type
; 4891 : 					&mpos,					// world pos
; 4892 : 					4.2f,					// time to live
; 4893 : 					distScale * 3300.0f ) );				// scale
; 4894 : 					*/
; 4895 : 					break;
; 4896 : 				case 2:
; 4897 : 					/*
; 4898 : 					OTWDriver.AddSfxRequest(
; 4899 : 						new SfxClass( SFX_ARTILLERY_EXPLOSION,			// type
; 4900 : 						&mpos,					// world pos
; 4901 : 						1.2f,					// time to live
; 4902 : 						800.0f * distScale ) );				// scale
; 4903 : 						*/
; 4904 : 					break;
; 4905 : 				case 3:
; 4906 : 					/*
; 4907 : 					OTWDriver.AddSfxRequest(
; 4908 : 						new SfxClass( SFX_AC_AIR_EXPLOSION,			// type
; 4909 : 						&mpos,					// world pos
; 4910 : 						2.2f,					// time to live
; 4911 : 						500.0f * distScale ) );				// scale
; 4912 : 						*/
; 4913 : 					break;
; 4914 : 			}
; 4915 : 
; 4916 : 
; 4917 : 			break;

	jmp	$LN259@RunSeconda
$LN59@RunSeconda:

; 4918 : 
; 4919 : 		case SFX_GROUNDBURST:
; 4920 : 
; 4921 : 			// evry time thru, we increase the radius
; 4922 : 			vec.z += 40.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	addss	xmm0, DWORD PTR __real@42200000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm0

; 4923 : 			pos.x += vec.x * sfxFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+40], xmm0

; 4924 : 			pos.y += vec.y * sfxFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR ?sfxFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 4925 : 			numBursts = 3 + (int)( vec.z * 0.08f * gSfxLOD );

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	mulss	xmm0, DWORD PTR __real@3da3d70a
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si eax, xmm0
	add	eax, 3
	mov	DWORD PTR _numBursts$[ebp], eax

; 4926 : 			radstep = 2.0f * PI / (float)numBursts;

	cvtsi2ss xmm0, DWORD PTR _numBursts$[ebp]
	movss	xmm1, DWORD PTR __real@40c90fdb
	divss	xmm1, xmm0
	movss	DWORD PTR _radstep$[ebp], xmm1

; 4927 : 			rads = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _rads$[ebp], xmm0

; 4928 : 
; 4929 : 			// perpendiclular vec
; 4930 : 			distScale = (float)sqrt( vec.x * vec.x + vec.y * vec.y );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	mulss	xmm0, DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+56]
	mulss	xmm1, DWORD PTR [ecx+56]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _distScale$[ebp]

; 4931 : 			if ( distScale < 0.0001f ) distScale = 1.0f;

	movss	xmm0, DWORD PTR __real@38d1b717
	comiss	xmm0, DWORD PTR _distScale$[ebp]
	jbe	SHORT $LN58@RunSeconda
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _distScale$[ebp], xmm0
$LN58@RunSeconda:

; 4932 : 			mvec.x = -vec.y / distScale;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _distScale$[ebp]
	movss	DWORD PTR _mvec$[ebp], xmm0

; 4933 : 			mvec.y = vec.x / distScale;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	divss	xmm0, DWORD PTR _distScale$[ebp]
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 4934 : 
; 4935 : 			distScale = min( vec.z, 200.0f );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR [ecx+60]
	jbe	SHORT $LN271@RunSeconda
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv1284[ebp], xmm0
	jmp	SHORT $LN272@RunSeconda
$LN271@RunSeconda:
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR tv1284[ebp], xmm0
$LN272@RunSeconda:
	movss	xmm0, DWORD PTR tv1284[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 4936 : 
; 4937 : 			for ( i=0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN57@RunSeconda
$LN56@RunSeconda:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN57@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _numBursts$[ebp]
	jge	$LN55@RunSeconda

; 4938 : 			{
; 4939 : 				// mpos.x = pos.x + distScale * cos( rads ) + PRANDFloat() * distScale * 0.4f;
; 4940 : 				// mpos.y = pos.y + distScale * sin( rads ) + PRANDFloat() * distScale * 0.4f;
; 4941 : 				mpos.x = pos.x + mvec.x * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3134[ebp]
	movss	xmm0, DWORD PTR tv3134[ebp]
	mulss	xmm0, DWORD PTR _mvec$[ebp]
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 4942 : 				mpos.y = pos.y + mvec.y * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3141[ebp]
	movss	xmm0, DWORD PTR tv3141[ebp]
	mulss	xmm0, DWORD PTR _mvec$[ebp+4]
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 4943 : 				mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 10.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3152[ebp]
	movss	xmm0, DWORD PTR tv3152[ebp]
	subss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 4944 : 
; 4945 : 				rads += radstep;

	movss	xmm0, DWORD PTR _rads$[ebp]
	addss	xmm0, DWORD PTR _radstep$[ebp]
	movss	DWORD PTR _rads$[ebp], xmm0

; 4946 : 
; 4947 : 				switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv1307[ebp], eax
	cmp	DWORD PTR tv1307[ebp], 1
	je	SHORT $LN51@RunSeconda
	jmp	SHORT $LN53@RunSeconda

; 4948 : 				{
; 4949 : 					case 0:
; 4950 : 						/*
; 4951 : 						OTWDriver.AddSfxRequest(
; 4952 : 							new SfxClass( SFX_GROUND_STRIKE_NOFIRE,	// type
; 4953 : 							&mpos,					// world pos
; 4954 : 							1.5f,					// time to live
; 4955 : 							15.0f ) );				// scale
; 4956 : 							*/
; 4957 : 						break;

	jmp	SHORT $LN53@RunSeconda
$LN51@RunSeconda:

; 4958 : 					case 1:
; 4959 : 						vec2.x = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vec2$[ebp], xmm0

; 4960 : 						vec2.y = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vec2$[ebp+4], xmm0

; 4961 : 						vec2.z = -50.0f;

	movss	xmm0, DWORD PTR __real@c2480000
	movss	DWORD PTR _vec2$[ebp+8], xmm0
$LN53@RunSeconda:

; 4962 : 						/*
; 4963 : 						OTWDriver.AddSfxRequest(
; 4964 : 							new SfxClass( SFX_FIRE4,		// type
; 4965 : 							SFX_MOVES | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,
; 4966 : 							&mpos,					// world pos
; 4967 : 							&vec2,					// vel vector
; 4968 : 							1.5,					// time to live
; 4969 : 							20.25f ) );				// scale
; 4970 : 							*/
; 4971 : 						break;
; 4972 : 					case 2:
; 4973 : 						/*
; 4974 : 						OTWDriver.AddSfxRequest(
; 4975 : 							new SfxClass(SFX_SMALL_HIT_EXPLOSION,				// type
; 4976 : 							&mpos,							// world pos
; 4977 : 							1.5f,			// time to live
; 4978 : 							15.0f) );		// scale
; 4979 : 							*/
; 4980 : 						break;
; 4981 : 					case 3:
; 4982 : 						/*
; 4983 : 						OTWDriver.AddSfxRequest(
; 4984 : 							new SfxClass( SFX_GROUND_STRIKE_NOFIRE,	// type
; 4985 : 							&mpos,					// world pos
; 4986 : 							1.5f,					// time to live
; 4987 : 							15.0f ) );				// scale
; 4988 : 							*/
; 4989 : 						break;
; 4990 : 					case 4:
; 4991 : 						/*
; 4992 : 						OTWDriver.AddSfxRequest(
; 4993 : 							new SfxClass( SFX_AAA_EXPLOSION,	// type
; 4994 : 							&mpos,					// world pos
; 4995 : 							1.5f,					// time to live
; 4996 : 							15.0f ) );				// scale
; 4997 : 							*/
; 4998 : 						break;
; 4999 : 				}
; 5000 : 			}

	jmp	$LN56@RunSeconda
$LN55@RunSeconda:

; 5001 : 			F4SoundFXSetPos( SFX_BOOMG1 + PRANDInt5(), TRUE, mpos.x, mpos.y, mpos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 28					; 0000001cH
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5002 : 
; 5003 : 			break;

	jmp	$LN259@RunSeconda
$LN47@RunSeconda:

; 5004 : 
; 5005 : 		case SFX_DIST_ARMOR:
; 5006 : 
; 5007 : 			// do LOD for distant sfx
; 5008 : 			if ( gTotSfx > gSfxLODDistCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODDistCutoff@@3HA	; gSfxLODDistCutoff
	jle	SHORT $LN46@RunSeconda

; 5009 : 			{
; 5010 : 				break;

	jmp	$LN259@RunSeconda
$LN46@RunSeconda:

; 5011 : 			}
; 5012 : 
; 5013 : 			// check distance to view, if too close don't run....
; 5014 : 			// about 6 miles?
; 5015 : 			if ( approxDist < 10000.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR [edx+132]
	jbe	SHORT $LN45@RunSeconda

; 5016 : 				break;

	jmp	$LN259@RunSeconda
$LN45@RunSeconda:

; 5017 : 
; 5018 : 			// get a distance scale where 1.0 is about 60 miles away
; 5019 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN273@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv1329[ebp], xmm0
	jmp	SHORT $LN274@RunSeconda
$LN273@RunSeconda:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv1329[ebp], xmm0
$LN274@RunSeconda:
	movss	xmm0, DWORD PTR tv1329[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 5020 : 
; 5021 : 			mpos.x = pos.x + 6000.0f * PRANDFloat()* distScale ;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3182[ebp]
	movss	xmm0, DWORD PTR tv3182[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5022 : 			mpos.y = pos.y + 6000.0f * PRANDFloat()* distScale ;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3189[ebp]
	movss	xmm0, DWORD PTR tv3189[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5023 : 			mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 20.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3200[ebp]
	movss	xmm0, DWORD PTR tv3200[ebp]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 5024 : 
; 5025 : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv1349[ebp], eax
	cmp	DWORD PTR tv1349[ebp], 1
	je	SHORT $LN41@RunSeconda
	cmp	DWORD PTR tv1349[ebp], 4
	je	SHORT $LN41@RunSeconda
	jmp	$LN43@RunSeconda

; 5026 : 			{
; 5027 : 				case 0:
; 5028 : 					/*
; 5029 : 					OTWDriver.AddSfxRequest(
; 5030 : 						new SfxClass( SFX_GROUND_FLASH,			// type
; 5031 : 						&mpos,					// world pos
; 5032 : 						2.2f,					// time to live
; 5033 : 						distScale * 6800.0f ) );				// scale
; 5034 : 						*/
; 5035 : 						break;

	jmp	$LN43@RunSeconda
$LN41@RunSeconda:

; 5036 : 				case 1:
; 5037 : 				case 4:
; 5038 : 					// vec is normalized, further away = faster
; 5039 : 					// mvec.x = vec.x * ( 150.0f + 3800.0f * distScale );
; 5040 : 					// mvec.y = vec.y * ( 150.0f + 3800.0f * distScale );
; 5041 : 					// mvec.z = vec.z * ( 150.0f + 3800.0f * distScale );
; 5042 : 					if ( travelDist < 12000.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@463b8000
	comiss	xmm0, DWORD PTR [ecx+108]
	jbe	SHORT $LN40@RunSeconda

; 5043 : 					{
; 5044 : 						mvec.x = vec.x / travelDist * TRACER_VELOCITY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	divss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 5045 : 						mvec.y = vec.y / travelDist * TRACER_VELOCITY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	divss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 5046 : 						mvec.z = vec.z / travelDist * TRACER_VELOCITY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	divss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 5047 : 						/*
; 5048 : 						OTWDriver.AddSfxRequest(
; 5049 : 							new SfxClass( SFX_TRACER_FIRE,			// type
; 5050 : 							SFX_EXPLODE_WHEN_DONE | SFX_MOVES | SFX_NO_GROUND_CHECK ,						// flags
; 5051 : 							&mpos,					// world pos
; 5052 : 							&mvec,					// vector for movement
; 5053 : 							travelDist/TRACER_VELOCITY,					// time to live
; 5054 : 							180.0f * distScale) );				// scale
; 5055 : 							*/
; 5056 : 					}
; 5057 : 					else

	jmp	SHORT $LN39@RunSeconda
$LN40@RunSeconda:

; 5058 : 					{
; 5059 : 						mpos.x += vec.x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5060 : 						mpos.y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	addss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5061 : 						mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 20.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3224[ebp]
	movss	xmm0, DWORD PTR tv3224[ebp]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0
$LN39@RunSeconda:
$LN43@RunSeconda:

; 5062 : 						/*
; 5063 : 						OTWDriver.AddSfxRequest(
; 5064 : 							new SfxClass( SFX_ARTILLERY_EXPLOSION,			// type
; 5065 : 							&mpos,					// world pos
; 5066 : 							1.2f,					// time to live
; 5067 : 							800.0f * distScale ) );				// scale
; 5068 : 							*/
; 5069 : 					}
; 5070 : 					break;
; 5071 : 				case 2:
; 5072 : 					/*
; 5073 : 					OTWDriver.AddSfxRequest(
; 5074 : 						new SfxClass( SFX_FEATURE_EXPLOSION,			// type
; 5075 : 						&mpos,					// world pos
; 5076 : 						4.2f,					// time to live
; 5077 : 						3300.0f * distScale ) );				// scale
; 5078 : 						*/
; 5079 : 					break;
; 5080 : 				case 3:
; 5081 : 					/*
; 5082 : 					OTWDriver.AddSfxRequest(
; 5083 : 						new SfxClass(SFX_AIR_SMOKECLOUD,			// type
; 5084 : 						&mpos,					// world pos
; 5085 : 						12.2f,					// time to live
; 5086 : 						420.0f  * distScale ) );				// scale
; 5087 : 						*/
; 5088 : 					break;
; 5089 : 			}
; 5090 : 
; 5091 : 
; 5092 : 			break;

	jmp	$LN259@RunSeconda
$LN36@RunSeconda:

; 5093 : 
; 5094 : 		case SFX_DIST_INFANTRY:
; 5095 : 
; 5096 : 			// do LOD for distant sfx
; 5097 : 			if ( gTotSfx > gSfxLODDistCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODDistCutoff@@3HA	; gSfxLODDistCutoff
	jle	SHORT $LN35@RunSeconda

; 5098 : 			{
; 5099 : 				break;

	jmp	$LN259@RunSeconda
$LN35@RunSeconda:

; 5100 : 			}
; 5101 : 
; 5102 : 			// check distance to view, if too close don't run....
; 5103 : 			// about 6 miles?
; 5104 : 			if ( approxDist < 10000.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR [edx+132]
	jbe	SHORT $LN34@RunSeconda

; 5105 : 				break;

	jmp	$LN259@RunSeconda
$LN34@RunSeconda:

; 5106 : 
; 5107 : 			// get a distance scale where 1.0 is about 60 miles away
; 5108 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN275@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv1391[ebp], xmm0
	jmp	SHORT $LN276@RunSeconda
$LN275@RunSeconda:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv1391[ebp], xmm0
$LN276@RunSeconda:
	movss	xmm0, DWORD PTR tv1391[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 5109 : 
; 5110 : 			mpos.x = pos.x + 6000.0f * PRANDFloat()* distScale ;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3238[ebp]
	movss	xmm0, DWORD PTR tv3238[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5111 : 			mpos.y = pos.y + 6000.0f * PRANDFloat()* distScale ;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3245[ebp]
	movss	xmm0, DWORD PTR tv3245[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5112 : 			mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 20.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3256[ebp]
	movss	xmm0, DWORD PTR tv3256[ebp]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 5113 : 
; 5114 : 			switch( PRANDInt5() )

	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	mov	DWORD PTR tv1411[ebp], eax
	cmp	DWORD PTR tv1411[ebp], 1
	je	SHORT $LN30@RunSeconda
	jmp	$LN32@RunSeconda

; 5115 : 			{
; 5116 : 				case 0:
; 5117 : 					/*
; 5118 : 					OTWDriver.AddSfxRequest(
; 5119 : 						new SfxClass( SFX_GROUND_FLASH,			// type
; 5120 : 						&mpos,					// world pos
; 5121 : 						2.2f,					// time to live
; 5122 : 						distScale * 6800.0f ) );				// scale
; 5123 : 						*/
; 5124 : 						break;

	jmp	$LN32@RunSeconda
$LN30@RunSeconda:

; 5125 : 				case 1:
; 5126 : 					// vec is normalized, further away = faster
; 5127 : 					// mvec.x = vec.x * ( 150.0f + 3800.0f * distScale );
; 5128 : 					// mvec.y = vec.y * ( 150.0f + 3800.0f * distScale );
; 5129 : 					// mvec.z = vec.z * ( 150.0f + 3800.0f * distScale );
; 5130 : 					mvec.x = vec.x / travelDist * TRACER_VELOCITY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	divss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 5131 : 					mvec.y = vec.y / travelDist * TRACER_VELOCITY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	divss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 5132 : 					mvec.z = vec.z / travelDist * TRACER_VELOCITY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	divss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 5133 : 					if ( travelDist < 12000.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@463b8000
	comiss	xmm0, DWORD PTR [ecx+108]
	jbe	SHORT $LN29@RunSeconda

; 5134 : 					{
; 5135 : 						/*
; 5136 : 						OTWDriver.AddSfxRequest(
; 5137 : 							new SfxClass( SFX_TRACER_FIRE,			// type
; 5138 : 							SFX_EXPLODE_WHEN_DONE | SFX_MOVES | SFX_NO_GROUND_CHECK | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,						// flags
; 5139 : 							&mpos,					// world pos
; 5140 : 							&mvec,					// vector for movement
; 5141 : 							travelDist/TRACER_VELOCITY,					// time to live
; 5142 : 							180.0f * distScale ) );				// scale
; 5143 : 							*/
; 5144 : 					}
; 5145 : 					else

	jmp	SHORT $LN28@RunSeconda
$LN29@RunSeconda:

; 5146 : 					{
; 5147 : 						mpos.x += vec.x;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp]
	addss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5148 : 						mpos.y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	addss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5149 : 						mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 20.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3280[ebp]
	movss	xmm0, DWORD PTR tv3280[ebp]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _mpos$[ebp+8], xmm0
$LN28@RunSeconda:
$LN32@RunSeconda:

; 5150 : 						/*
; 5151 : 						OTWDriver.AddSfxRequest(
; 5152 : 							new SfxClass( SFX_ARTILLERY_EXPLOSION,			// type
; 5153 : 							&mpos,					// world pos
; 5154 : 							1.2f,					// time to live
; 5155 : 							800.0f * distScale ) );				// scale
; 5156 : 							*/
; 5157 : 					}
; 5158 : 					break;
; 5159 : 				case 2:
; 5160 : 				case 3:
; 5161 : 					/*
; 5162 : 					OTWDriver.AddSfxRequest(
; 5163 : 						new SfxClass( SFX_FEATURE_EXPLOSION,			// type
; 5164 : 						&mpos,					// world pos
; 5165 : 						4.2f,					// time to live
; 5166 : 						3300.0f * distScale ) );				// scale
; 5167 : 						*/
; 5168 : 					break;
; 5169 : 				case 4:
; 5170 : 					/*
; 5171 : 					OTWDriver.AddSfxRequest(
; 5172 : 						new SfxClass(SFX_AIR_SMOKECLOUD,			// type
; 5173 : 						&mpos,					// world pos
; 5174 : 						12.2f,					// time to live
; 5175 : 						420.0f  * distScale ) );				// scale
; 5176 : 						*/
; 5177 : 					break;
; 5178 : 			}
; 5179 : 
; 5180 : 
; 5181 : 			break;

	jmp	$LN259@RunSeconda
$LN25@RunSeconda:

; 5182 : 
; 5183 : 		case SFX_DIST_SAMLAUNCHES:
; 5184 : 
; 5185 : 			// do LOD for distant sfx
; 5186 : 			if ( gTotSfx > gSfxLODDistCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODDistCutoff@@3HA	; gSfxLODDistCutoff
	jle	SHORT $LN24@RunSeconda

; 5187 : 			{
; 5188 : 				break;

	jmp	$LN259@RunSeconda
$LN24@RunSeconda:

; 5189 : 			}
; 5190 : 
; 5191 : 			// check distance to view, if too close don't run....
; 5192 : 			// about 6 miles?
; 5193 : 			if ( approxDist < 10000.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR [edx+132]
	jbe	SHORT $LN23@RunSeconda

; 5194 : 				break;

	jmp	$LN259@RunSeconda
$LN23@RunSeconda:

; 5195 : 
; 5196 : 			// get a distance scale where 1.0 is about 60 miles away
; 5197 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN277@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv1452[ebp], xmm0
	jmp	SHORT $LN278@RunSeconda
$LN277@RunSeconda:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv1452[ebp], xmm0
$LN278@RunSeconda:
	movss	xmm0, DWORD PTR tv1452[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 5198 : 
; 5199 : 			mpos.x = pos.x + 6000.0f * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3294[ebp]
	movss	xmm0, DWORD PTR tv3294[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5200 : 			mpos.y = pos.y + 6000.0f * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3301[ebp]
	movss	xmm0, DWORD PTR tv3301[ebp]
	mulss	xmm0, DWORD PTR __real@45bb8000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5201 : 			mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 50.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3312[ebp]
	movss	xmm0, DWORD PTR tv3312[ebp]
	subss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 5202 : 
; 5203 : 			// start sam launch effect
; 5204 : 			/*
; 5205 : 			OTWDriver.AddSfxRequest(
; 5206 : 				SFX_SAM_LAUNCH,			// type
; 5207 : 				0,						// flags
; 5208 : 				&mpos,					// world pos
; 5209 : 				&rot,					// orientation matrix
; 5210 : 				&mvec,					// vector for movement
; 5211 : 				2.2,					// time to live
; 5212 : 				52.0f );				// scale
; 5213 : 				*/
; 5214 : 
; 5215 : 			// start missile launch from sam loc
; 5216 : 			/*
; 5217 : 			OTWDriver.AddSfxRequest(
; 5218 : 				new SfxClass(SFX_AIR_SMOKECLOUD,			// type
; 5219 : 				&mpos,					// world pos
; 5220 : 				12.2f,					// time to live
; 5221 : 				420.0f  * distScale ) );				// scale
; 5222 : 				*/
; 5223 : 
; 5224 : 
; 5225 : 			if ( !PRANDInt3() )

	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	test	eax, eax
	jne	SHORT $LN22@RunSeconda

; 5226 : 			{
; 5227 : 				// vec is normalized, further away = faster
; 5228 : 				// mvec.x = vec.x * ( 150.0f + 1000.0f * distScale );
; 5229 : 				// mvec.y = vec.y * ( 150.0f + 1000.0f * distScale );
; 5230 : 				// mvec.z = vec.z * ( 150.0f + 1000.0f * distScale );
; 5231 : 				mvec.x = vec.x / travelDist * 1500.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	divss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 5232 : 				mvec.y = vec.y / travelDist * 1500.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	divss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 5233 : 				mvec.z = vec.z / travelDist * 1500.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	divss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 5234 : 				/*
; 5235 : 				OTWDriver.AddSfxRequest(
; 5236 : 					new SfxClass( SFX_MISSILE_LAUNCH,			// type
; 5237 : 					mflags,						// flags
; 5238 : 					&mpos,					// world pos
; 5239 : 					&mvec,					// vector for movement
; 5240 : 					travelDist/1500.0f,					// time to live
; 5241 : 					420.0f * distScale ) );				// scale
; 5242 : 					*/
; 5243 : 			}
; 5244 : 			else

	jmp	SHORT $LN21@RunSeconda
$LN22@RunSeconda:

; 5245 : 			{
; 5246 : 				// vec is normalized, further away = faster
; 5247 : 				// mvec.x = vec.x * ( 150.0f + 3800.0f * distScale );
; 5248 : 				// mvec.y = vec.y * ( 150.0f + 3800.0f * distScale );
; 5249 : 				// mvec.z = vec.z * ( 150.0f + 3800.0f * distScale );
; 5250 : 				mvec.x = vec.x / travelDist * TRACER_VELOCITY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	divss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 5251 : 				mvec.y = vec.y / travelDist * TRACER_VELOCITY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	divss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 5252 : 				mvec.z = vec.z / travelDist * TRACER_VELOCITY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	divss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN21@RunSeconda:

; 5253 : 				/*
; 5254 : 				OTWDriver.AddSfxRequest(
; 5255 : 					new SfxClass( SFX_TRACER_FIRE,			// type
; 5256 : 					SFX_EXPLODE_WHEN_DONE | SFX_MOVES | SFX_NO_GROUND_CHECK | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,						// flags
; 5257 : 					&mpos,					// world pos
; 5258 : 					&mvec,					// vector for movement
; 5259 : 					travelDist/TRACER_VELOCITY,					// time to live
; 5260 : 					180.0f * distScale ) );				// scale
; 5261 : 					*/
; 5262 : 			}
; 5263 : 
; 5264 : 			break;

	jmp	$LN259@RunSeconda
$LN20@RunSeconda:

; 5265 : 
; 5266 : 		case SFX_DIST_AALAUNCHES:
; 5267 : 
; 5268 : 			// do LOD for distant sfx
; 5269 : 			if ( gTotSfx > gSfxLODDistCutoff )

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gSfxLODDistCutoff@@3HA	; gSfxLODDistCutoff
	jle	SHORT $LN19@RunSeconda

; 5270 : 			{
; 5271 : 				break;

	jmp	$LN259@RunSeconda
$LN19@RunSeconda:

; 5272 : 			}
; 5273 : 
; 5274 : 			// check distance to view, if too close don't run....
; 5275 : 			// about 6 miles?
; 5276 : 			if ( approxDist < 10000.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@461c4000
	comiss	xmm0, DWORD PTR [edx+132]
	jbe	SHORT $LN18@RunSeconda

; 5277 : 				break;

	jmp	$LN259@RunSeconda
$LN18@RunSeconda:

; 5278 : 
; 5279 : 			// get a distance scale where 1.0 is about 60 miles away
; 5280 : 			distScale = max( 0.1f, approxDist/200000.0f );

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN279@RunSeconda
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv1513[ebp], xmm0
	jmp	SHORT $LN280@RunSeconda
$LN279@RunSeconda:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	divss	xmm0, DWORD PTR __real@48435000
	movss	DWORD PTR tv1513[ebp], xmm0
$LN280@RunSeconda:
	movss	xmm0, DWORD PTR tv1513[ebp]
	movss	DWORD PTR _distScale$[ebp], xmm0

; 5281 : 
; 5282 : 			mpos.x = pos.x + 2000.0f * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3345[ebp]
	movss	xmm0, DWORD PTR tv3345[ebp]
	mulss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5283 : 			mpos.y = pos.y + 2000.0f * PRANDFloat() * distScale;

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3352[ebp]
	movss	xmm0, DWORD PTR tv3352[ebp]
	mulss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _distScale$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5284 : 			mpos.z = OTWDriver.GetGroundLevel (mpos.x, mpos.y) - 50.0f;

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv3363[ebp]
	movss	xmm0, DWORD PTR tv3363[ebp]
	subss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 5285 : 
; 5286 : 			if ( !PRANDInt3() )

	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	test	eax, eax
	jne	SHORT $LN17@RunSeconda

; 5287 : 			{
; 5288 : 				// vec is normalized, further away = faster
; 5289 : 				// mvec.x = vec.x * ( 150.0f + 1000.0f * distScale );
; 5290 : 				// mvec.y = vec.y * ( 150.0f + 1000.0f * distScale );
; 5291 : 				// mvec.z = vec.z * ( 150.0f + 1000.0f * distScale );
; 5292 : 				mvec.x = vec.x / travelDist * 1500.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	divss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 5293 : 				mvec.y = vec.y / travelDist * 1500.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	divss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 5294 : 				mvec.z = vec.z / travelDist * 1500.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	divss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@44bb8000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 5295 : 				/*
; 5296 : 				OTWDriver.AddSfxRequest(
; 5297 : 					new SfxClass( SFX_MISSILE_LAUNCH,			// type
; 5298 : 					mflags,						// flags
; 5299 : 					&mpos,					// world pos
; 5300 : 					&mvec,					// vector for movement
; 5301 : 					travelDist/1500.0f,					// time to live
; 5302 : 					420.0f * distScale ) );				// scale
; 5303 : 					*/
; 5304 : 			}
; 5305 : 			else

	jmp	SHORT $LN16@RunSeconda
$LN17@RunSeconda:

; 5306 : 			{
; 5307 : 				// vec is normalized, further away = faster
; 5308 : 				// mvec.x = vec.x * ( 150.0f + 3800.0f * distScale );
; 5309 : 				// mvec.y = vec.y * ( 150.0f + 3800.0f * distScale );
; 5310 : 				// mvec.z = vec.z * ( 150.0f + 3800.0f * distScale );
; 5311 : 				mvec.x = vec.x / travelDist * TRACER_VELOCITY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+52]
	divss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp], xmm0

; 5312 : 				mvec.y = vec.y / travelDist * TRACER_VELOCITY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	divss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+4], xmm0

; 5313 : 				mvec.z = vec.z / travelDist * TRACER_VELOCITY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	divss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _mvec$[ebp+8], xmm0
$LN16@RunSeconda:

; 5314 : 				/*
; 5315 : 				OTWDriver.AddSfxRequest(
; 5316 : 					new SfxClass( SFX_TRACER_FIRE,			// type
; 5317 : 					SFX_EXPLODE_WHEN_DONE | SFX_MOVES | SFX_NO_GROUND_CHECK | SFX_USES_GRAVITY | SFX_NO_DOWN_VECTOR,						// flags
; 5318 : 					&mpos,					// world pos
; 5319 : 					&mvec,					// vector for movement
; 5320 : 					travelDist/TRACER_VELOCITY,					// time to live
; 5321 : 					180.0f * distScale) );				// scale
; 5322 : 					*/
; 5323 : 			}
; 5324 : 
; 5325 : 			break;

	jmp	$LN259@RunSeconda
$LN15@RunSeconda:

; 5326 : 		case SFX_INCENDIARY_EXPLOSION:
; 5327 : 			mpos.x = pos.x;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5328 : 			mpos.y = pos.y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5329 : 			mpos.z = OTWDriver.GetGroundLevel( pos.x, pos.y );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _mpos$[ebp+8]

; 5330 : 			OTWDriver.AddSfxRequest(
; 5331 : 				new SfxClass( SFX_FEATURE_EXPLOSION,			// type
; 5332 : 				&mpos,					// world pos
; 5333 : 				obj2d->GetAlphaTimeToLive(),					// time to live
; 5334 : 				scale ) );				// scale

	push	192					; 000000c0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN281@RunSeconda
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+104]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	call	?GetAlphaTimeToLive@Drawable2D@@QAEMXZ	; Drawable2D::GetAlphaTimeToLive
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _mpos$[ebp]
	push	ecx
	push	104					; 00000068H
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0SfxClass@@QAE@HPAUTpoint@@MM@Z	; SfxClass::SfxClass
	mov	DWORD PTR tv1593[ebp], eax
	jmp	SHORT $LN282@RunSeconda
$LN281@RunSeconda:
	mov	DWORD PTR tv1593[ebp], 0
$LN282@RunSeconda:
	mov	edx, DWORD PTR tv1593[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?AddSfxRequest@OTWDriverClass@@QAEXPAVSfxClass@@@Z ; OTWDriverClass::AddSfxRequest

; 5335 : 			break;

	jmp	$LN259@RunSeconda
$LN14@RunSeconda:

; 5336 : 
; 5337 : 		case SFX_NAPALM:
; 5338 : 			// send up some fire trails
; 5339 : 			/*
; 5340 : 			** EDG: Broken right now!
; 5341 : 			*/
; 5342 : 			numBursts =  2 + (int)( 2.0f * gSfxLOD );

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR ?gSfxLOD@@3MA
	cvttss2si ecx, xmm0
	add	ecx, 2
	mov	DWORD PTR _numBursts$[ebp], ecx

; 5343 : 			rads = OTWDriver.GetGroundLevel( pos.x, pos.y );

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _rads$[ebp]

; 5344 : 			mvec.z = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _mvec$[ebp+8], xmm0

; 5345 : 
; 5346 : 			for ( i = 0; i < numBursts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@RunSeconda
$LN12@RunSeconda:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@RunSeconda:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _numBursts$[ebp]
	jge	$LN11@RunSeconda

; 5347 : 			{
; 5348 : 				mpos.x = pos.x + 600.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3423[ebp]
	movss	xmm0, DWORD PTR tv3423[ebp]
	mulss	xmm0, DWORD PTR __real@44160000
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5349 : 				mpos.y = pos.y + 600.0f * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3430[ebp]
	movss	xmm0, DWORD PTR tv3430[ebp]
	mulss	xmm0, DWORD PTR __real@44160000
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5350 : 				mpos.z = rads  - 30.0f - PRANDFloatPos() * 100.0f;

	movss	xmm0, DWORD PTR _rads$[ebp]
	subss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR tv3514[ebp], xmm0
	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv3438[ebp]
	movss	xmm0, DWORD PTR tv3438[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	movss	xmm1, DWORD PTR tv3514[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _mpos$[ebp+8], xmm1

; 5351 : 
; 5352 : 				/*
; 5353 : 				OTWDriver.AddSfxRequest(
; 5354 : 					new SfxClass( SFX_INCENDIARY_EXPLOSION,		// type
; 5355 : 					&mpos,					// world pos
; 5356 : 					2.5f,					// time to live
; 5357 : 					200.0f + 500.0f * PRANDFloatPos() ) );				// scale
; 5358 : 					*/
; 5359 : 			}

	jmp	$LN12@RunSeconda
$LN11@RunSeconda:

; 5360 : 
; 5361 : 			pos.x += vec.x * 0.2f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+40], xmm0

; 5362 : 			pos.y += vec.y * 0.2f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+44], xmm0

; 5363 : 			F4SoundFXSetPos( SFX_BOOMG1, TRUE, mpos.x, mpos.y, mpos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	28					; 0000001cH
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5364 : 			break;

	jmp	$LN259@RunSeconda
$LN10@RunSeconda:

; 5365 : 
; 5366 : 		case SFX_RISING_GROUNDHIT_EXPLOSION_DEBR:
; 5367 : 			// mpos.x = pos.x + vec.x * PRANDFloat();
; 5368 : 			// mpos.y = pos.y + vec.y * PRANDFloat();
; 5369 : 			int randint;
; 5370 : 
; 5371 : 			randint = rand() & 0x03;

	call	_rand
	and	eax, 3
	mov	DWORD PTR _randint$8[ebp], eax

; 5372 : 
; 5373 : 			if ( randint == 1 )

	cmp	DWORD PTR _randint$8[ebp], 1
	jne	SHORT $LN9@RunSeconda

; 5374 : 				mpos.x = pos.x - vec.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	subss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR _mpos$[ebp], xmm0
	jmp	SHORT $LN6@RunSeconda
$LN9@RunSeconda:

; 5375 : 			else if ( randint == 0 )

	cmp	DWORD PTR _randint$8[ebp], 0
	jne	SHORT $LN7@RunSeconda

; 5376 : 				mpos.x = pos.x + vec.x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	addss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR _mpos$[ebp], xmm0

; 5377 : 			else

	jmp	SHORT $LN6@RunSeconda
$LN7@RunSeconda:

; 5378 : 				mpos.x = pos.x + vec.x * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3469[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv3469[ebp]
	mulss	xmm0, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR _mpos$[ebp], xmm0
$LN6@RunSeconda:

; 5379 : 
; 5380 : 			randint = rand() & 0x03;

	call	_rand
	and	eax, 3
	mov	DWORD PTR _randint$8[ebp], eax

; 5381 : 
; 5382 : 			if ( randint == 1 )

	cmp	DWORD PTR _randint$8[ebp], 1
	jne	SHORT $LN5@RunSeconda

; 5383 : 				mpos.y = pos.y - vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	subss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR _mpos$[ebp+4], xmm0
	jmp	SHORT $LN2@RunSeconda
$LN5@RunSeconda:

; 5384 : 			else if ( randint == 0 )

	cmp	DWORD PTR _randint$8[ebp], 0
	jne	SHORT $LN3@RunSeconda

; 5385 : 				mpos.y = pos.y + vec.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	addss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR _mpos$[ebp+4], xmm0

; 5386 : 			else

	jmp	SHORT $LN2@RunSeconda
$LN3@RunSeconda:

; 5387 : 				mpos.y = pos.y + vec.y * PRANDFloat();

	call	?PRANDFloat@@YAMXZ			; PRANDFloat
	fstp	DWORD PTR tv3484[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv3484[ebp]
	mulss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _mpos$[ebp+4], xmm0
$LN2@RunSeconda:

; 5388 : 
; 5389 : 			mpos.z = pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR _mpos$[ebp+8], xmm0

; 5390 : 
; 5391 : 			/*
; 5392 : 			OTWDriver.AddSfxRequest(
; 5393 : 				new SfxClass(SFX_VEHICLE_EXPLOSION,				// type
; 5394 : 				&mpos,							// world pos
; 5395 : 				1.5f,			// time to live
; 5396 : 				scale) );		// scale
; 5397 : 				*/
; 5398 : 
; 5399 : 
; 5400 : 			mpos.z = OTWDriver.GetGroundLevel( mpos.x, mpos.y );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _mpos$[ebp+8]

; 5401 : 			/*
; 5402 : 			OTWDriver.AddSfxRequest(
; 5403 : 				new SfxClass( SFX_GROUND_FLASH,			// type
; 5404 : 				&mpos,					// world pos
; 5405 : 				2.2f,					// time to live
; 5406 : 				scale * 1.4f ) );				// scale
; 5407 : 				*/
; 5408 : 
; 5409 : 			// sound
; 5410 : 			F4SoundFXSetPos( SFX_BOOMG1 + PRANDInt5(), TRUE, mpos.x, mpos.y, mpos.z, 1.0f );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _mpos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?PRANDInt5@@YAHXZ			; PRANDInt5
	add	eax, 28					; 0000001cH
	push	eax
	call	_F4SoundFXSetPos
	add	esp, 32					; 00000020H

; 5411 : 			// raise it
; 5412 : 			pos.z += vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	addss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+48], xmm0
$LN1@RunSeconda:
$LN259@RunSeconda:

; 5413 : 			break;
; 5414 : 		default:
; 5415 : 			break;
; 5416 : 	} // end switch
; 5417 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN287@RunSeconda:
	DD	$LN176@RunSeconda
	DD	$LN187@RunSeconda
	DD	$LN229@RunSeconda
	DD	$LN140@RunSeconda
	DD	$LN107@RunSeconda
	DD	$LN253@RunSeconda
	DD	$LN158@RunSeconda
	DD	$LN181@RunSeconda
	DD	$LN85@RunSeconda
	DD	$LN68@RunSeconda
	DD	$LN25@RunSeconda
	DD	$LN20@RunSeconda
	DD	$LN47@RunSeconda
	DD	$LN36@RunSeconda
	DD	$LN236@RunSeconda
	DD	$LN167@RunSeconda
	DD	$LN159@RunSeconda
	DD	$LN241@RunSeconda
	DD	$LN97@RunSeconda
	DD	$LN244@RunSeconda
	DD	$LN168@RunSeconda
	DD	$LN14@RunSeconda
	DD	$LN77@RunSeconda
	DD	$LN59@RunSeconda
	DD	$LN175@RunSeconda
	DD	$LN182@RunSeconda
	DD	$LN92@RunSeconda
	DD	$LN10@RunSeconda
	DD	$LN200@RunSeconda
	DD	$LN228@RunSeconda
	DD	$LN100@RunSeconda
	DD	$LN144@RunSeconda
	DD	$LN152@RunSeconda
	DD	$LN177@RunSeconda
	DD	$LN227@RunSeconda
	DD	$LN210@RunSeconda
	DD	$LN251@RunSeconda
	DD	$LN254@RunSeconda
	DD	$LN257@RunSeconda
	DD	$LN258@RunSeconda
	DD	$LN113@RunSeconda
	DD	$LN94@RunSeconda
	DD	$LN96@RunSeconda
	DD	$LN15@RunSeconda
	DD	$LN1@RunSeconda
$LN285@RunSeconda:
	DB	0
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	1
	DB	2
	DB	3
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	4
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	5
	DB	6
	DB	7
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	44					; 0000002cH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	44					; 0000002cH
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	28					; 0000001cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	19					; 00000013H
	DB	29					; 0000001dH
	DB	44					; 0000002cH
	DB	30					; 0000001eH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	14					; 0000000eH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	34					; 00000022H
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	35					; 00000023H
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	44					; 0000002cH
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RunSecondarySfx@SfxClass@@IAEXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RunSecondarySfx@SfxClass@@IAEXXZ$1:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RunSecondarySfx@SfxClass@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-764]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RunSecondarySfx@SfxClass@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?RunSecondarySfx@SfxClass@@IAEXXZ ENDP			; SfxClass::RunSecondarySfx
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv163 = -40						; size = 4
_tmp$ = -36						; size = 4
_absmin$ = -32						; size = 4
_absmid$ = -28						; size = 4
_absmax$ = -24						; size = 4
_this$ = -20						; size = 4
_viewLoc$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_currTime$ = 8						; size = 4
?GetApproxViewDist@SfxClass@@IAEXM@Z PROC		; SfxClass::GetApproxViewDist
; _this$ = ecx

; 2989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2990 : 	float absmax, absmid, absmin, tmp;
; 2991 : 	Tpoint viewLoc;
; 2992 : 
; 2993 : 	if (!viewPoint) // JB 010528

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jne	SHORT $LN5@GetApproxV

; 2994 : 		return;

	jmp	$LN6@GetApproxV
$LN5@GetApproxV:

; 2995 : 
; 2996 : 	if (F4IsBadReadPtr(viewPoint, sizeof *viewPoint)) return; // JPO CTD fix?

	push	272					; 00000110H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetApproxV
	jmp	$LN6@GetApproxV
$LN4@GetApproxV:

; 2997 : 
; 2998 : 	// get view pos
; 2999 : 	viewPoint->GetPos( &viewLoc ); // CTD Pos

	lea	ecx, DWORD PTR _viewLoc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+184]
	call	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z	; TViewPoint::GetPos

; 3000 : 
; 3001 : 
; 3002 : 	absmax = (float)fabs(viewLoc.x - pos.x);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _viewLoc$[ebp]
	subss	xmm0, DWORD PTR [eax+40]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR _absmax$[ebp]

; 3003 : 	absmid = (float)fabs(viewLoc.y - pos.y);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _viewLoc$[ebp+4]
	subss	xmm0, DWORD PTR [ecx+44]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR _absmid$[ebp]

; 3004 : 
; 3005 : 	// less weight on z dist
; 3006 : 	absmin = (float)fabs(viewLoc.z - pos.z) * 0.1f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _viewLoc$[ebp+8]
	subss	xmm0, DWORD PTR [edx+48]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv163[ebp]
	movss	xmm0, DWORD PTR tv163[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _absmin$[ebp], xmm0

; 3007 : 
; 3008 : 	// find the max
; 3009 : 	if ( absmax < absmid )

	movss	xmm0, DWORD PTR _absmid$[ebp]
	comiss	xmm0, DWORD PTR _absmax$[ebp]
	jbe	SHORT $LN3@GetApproxV

; 3010 : 	{
; 3011 : 		//swap
; 3012 : 		tmp = absmid;

	movss	xmm0, DWORD PTR _absmid$[ebp]
	movss	DWORD PTR _tmp$[ebp], xmm0

; 3013 : 		absmid = absmax;

	movss	xmm0, DWORD PTR _absmax$[ebp]
	movss	DWORD PTR _absmid$[ebp], xmm0

; 3014 : 		absmax = tmp;

	movss	xmm0, DWORD PTR _tmp$[ebp]
	movss	DWORD PTR _absmax$[ebp], xmm0
$LN3@GetApproxV:

; 3015 : 	}
; 3016 : 
; 3017 : 	if ( absmax < absmin )

	movss	xmm0, DWORD PTR _absmin$[ebp]
	comiss	xmm0, DWORD PTR _absmax$[ebp]
	jbe	SHORT $LN2@GetApproxV

; 3018 : 	{
; 3019 : 		// absmin is actually the max
; 3020 : 		approxDist =  absmin +  ( absmax + absmid ) * 0.5f ;

	movss	xmm0, DWORD PTR _absmax$[ebp]
	addss	xmm0, DWORD PTR _absmid$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _absmin$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+132], xmm0

; 3021 : 	}
; 3022 : 	else

	jmp	SHORT $LN1@GetApproxV
$LN2@GetApproxV:

; 3023 : 	{
; 3024 : 		approxDist =  absmax + ( absmin + absmid ) * 0.5f ;

	movss	xmm0, DWORD PTR _absmin$[ebp]
	addss	xmm0, DWORD PTR _absmid$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _absmax$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+132], xmm0
$LN1@GetApproxV:

; 3025 : 	}
; 3026 : 
; 3027 : 	// this is the next time to check
; 3028 : 	distTimer = currTime + VIEW_DIST_INTERVAL;

	movss	xmm0, DWORD PTR _currTime$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+128], xmm0
$LN6@GetApproxV:

; 3029 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?GetApproxViewDist@SfxClass@@IAEXM@Z ENDP		; SfxClass::GetApproxViewDist
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv202 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeSfx$ = 8						; size = 4
_flagsSfx$ = 12						; size = 4
_baseobjSfx$ = 16					; size = 4
_timeToLiveSfx$ = 20					; size = 4
_scaleSfx$ = 24						; size = 4
_slot$ = 28						; size = 4
_restpitch$ = 32					; size = 4
_restroll$ = 36						; size = 4
??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z PROC ; SfxClass::SfxClass
; _this$ = ecx

; 1865 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1866 : 	inACMI = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], 0

; 1867 : 	type = typeSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _typeSfx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 1868 : 	flags = flagsSfx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flagsSfx$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1869 : 	baseObj.reset(baseobjSfx);

	mov	edx, DWORD PTR _baseobjSfx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z ; VuBin<SimBaseClass>::reset

; 1870 : 	vec.x = baseObj->XDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+52]

; 1871 : 	vec.y = baseObj->YDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+56]

; 1872 : 	vec.z = baseObj->ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+60]

; 1873 : 	timeToLive = timeToLiveSfx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _timeToLiveSfx$[ebp]
	movss	DWORD PTR [eax+100], xmm0

; 1874 : 	scale = scaleSfx;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _scaleSfx$[ebp]
	movss	DWORD PTR [ecx+104], xmm0

; 1875 : 	RestPitch = restpitch;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _restpitch$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1876 : 	RestRoll = restroll;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _restroll$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1877 : 	CrashSlot = *slot;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR _slot$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 1878 : 	CrashPos.x = baseObj->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+20]

; 1879 : 	CrashPos.y = baseObj->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+24]

; 1880 : 	CrashPos.z = baseObj->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::operator->
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+28]

; 1881 : 
; 1882 : 	secondaryCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 1883 : 	secondaryInterval = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+120], xmm0

; 1884 : 	secondaryTimer = (float)SIM_ELAPSED_SEC;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?SimLibElapsedSeconds@@3MA
	movss	DWORD PTR [edx+124], xmm0

; 1885 : 	OTWDriver.ObjectSetData(baseObj.get(), &pos, &rot );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ObjectSetData@OTWDriverClass@@QAEXPAVSimBaseClass@@PAUTpoint@@PAUTrotation@@@Z ; OTWDriverClass::ObjectSetData

; 1886 : 
; 1887 : 	objParticleSys = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0

; 1888 :     obj2d = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 0

; 1889 :     objBSP = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 1890 :     objTrail = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 1891 : 	objTracer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 1892 : 	endMessage = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 1893 : 	damMessage = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 1894 : 	travelDist = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0

; 1895 : 
; 1896 : 	TryParticleEffect(); // if it succeeds, it changes the type

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TryParticleEffect@SfxClass@@QAEHXZ	; SfxClass::TryParticleEffect

; 1897 : 
; 1898 : 	switch( type ) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv202[ebp], edx
	cmp	DWORD PTR tv202[ebp], 3
	je	SHORT $LN5@SfxClass
	jmp	SHORT $LN3@SfxClass
$LN5@SfxClass:

; 1899 : 		case SFX_SMOKING_PART:
; 1900 : 			//RV - I-Hawk - Removing old trails calls, not needed anymore
; 1901 : 			//objTrail = new DrawableTrail(TRAIL_SMOKE);
; 1902 : 			if ( gTotSfx <= gSfxLODTotCutoff && gSfxCount[ SFX_AIR_SMOKECLOUD ] < gSfxLODCutoff ) {

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	eax, DWORD PTR ?gSfxLODTotCutoff@@3HA	; gSfxLODTotCutoff
	jg	SHORT $LN4@SfxClass
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx]
	cmp	edx, DWORD PTR ?gSfxLODCutoff@@3HA	; gSfxLODCutoff
	jge	SHORT $LN4@SfxClass

; 1903 : 				timeToLive += 90.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	addss	xmm0, DWORD PTR __real@42b40000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+100], xmm0

; 1904 : 				flags &= ~SFX_EXPLODE_WHEN_DONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1905 : 				secondaryInterval = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+120], xmm0

; 1906 : 				secondaryCount = FloatToInt32 (timeToLive);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax
$LN4@SfxClass:
$LN3@SfxClass:

; 1907 : 			}
; 1908 : 			break;
; 1909 : 		default:
; 1910 : 			break;
; 1911 : 	}
; 1912 : 
; 1913 : 	viewPoint = OTWDriver.GetViewpoint();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 1914 : 
; 1915 : 	// update counters
; 1916 : 	gTotSfx++;

	mov	eax, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	add	eax, 1
	mov	DWORD PTR ?gTotSfx@@3HA, eax		; gTotSfx

; 1917 : 	if ( gTotSfx > gTotHighWaterSfx ) {

	mov	ecx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	cmp	ecx, DWORD PTR ?gTotHighWaterSfx@@3HA	; gTotHighWaterSfx
	jle	SHORT $LN2@SfxClass

; 1918 : 		gTotHighWaterSfx = gTotSfx;

	mov	edx, DWORD PTR ?gTotSfx@@3HA		; gTotSfx
	mov	DWORD PTR ?gTotHighWaterSfx@@3HA, edx	; gTotHighWaterSfx
$LN2@SfxClass:

; 1919 : //		MonoPrint( "SFX Total High Water Mark Reached = %d\n", gTotHighWaterSfx );
; 1920 : 	}
; 1921 : 	gSfxCount[ type ]++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[ecx*4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?gSfxCount@@3PAHA[ecx*4], edx

; 1922 : 	if ( gSfxCount[type] > gSfxHighWater[type] ) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR ?gSfxCount@@3PAHA[eax*4]
	cmp	eax, DWORD PTR ?gSfxHighWater@@3PAHA[edx*4]
	jle	SHORT $LN1@SfxClass

; 1923 : 		gSfxHighWater[type] = gSfxCount[type];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR ?gSfxCount@@3PAHA[edx*4]
	mov	DWORD PTR ?gSfxHighWater@@3PAHA[ecx*4], edx
$LN1@SfxClass:

; 1924 : //		MonoPrint( "SFX Type %d High Water Reached = %d\n", type, gSfxHighWater[type] );
; 1925 : 	}
; 1926 : 
; 1927 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$VuBin@VSimBaseClass@@@@QAE@XZ	; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
__ehhandler$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SfxClass@@QAE@HHPAVSimBaseClass@@MMPAUTpoint@@MM@Z ENDP ; SfxClass::SfxClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_otwPlatform$ = -8					; size = 4
_this$ = -4						; size = 4
?TryParticleEffect@SfxClass@@QAEHXZ PROC		; SfxClass::TryParticleEffect
; _this$ = ecx

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 	SimBaseClass *otwPlatform = OTWDriver.GraphicsOwnship();

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GraphicsOwnship@OTWDriverClass@@QBEPAVSimBaseClass@@XZ ; OTWDriverClass::GraphicsOwnship
	mov	DWORD PTR _otwPlatform$[ebp], eax

; 193  : 
; 194  : 	// Cobra - Use old dust trails?
; 195  : 	if (type == SFX_VEHICLE_DUST && g_bOldDustTrail){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 93			; 0000005dH
	jne	SHORT $LN2@TryParticl
	movzx	ecx, BYTE PTR ?g_bOldDustTrail@@3_NA	; g_bOldDustTrail
	test	ecx, ecx
	je	SHORT $LN2@TryParticl

; 196  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@TryParticl
$LN2@TryParticl:

; 197  : 	}
; 198  : 
; 199  : 	if(DrawableParticleSys::IsValidPSId(type+1)){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	push	eax
	call	?IsValidPSId@DrawableParticleSys@@SAHH@Z ; DrawableParticleSys::IsValidPSId
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@TryParticl

; 200  : 		// Cobra - Kludge to fix no PS effects above overcast layer
; 201  : 		/*
; 202  : 		if (
; 203  : 			otwPlatform && realWeather->weatherCondition > FAIR && 
; 204  : 			(otwPlatform->ZPos() < (realWeather->stratusZ-realWeather->stratusDepth)))
; 205  : 			return 0;
; 206  : 		*/
; 207  : 
; 208  : 		type ++; // Cobra - the SFX.cpp type is used in AddParticle(), so add 1 to use PS ID

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], edx

; 209  : 		//objParticleSys = new DrawableParticleSys(type,1);
; 210  : 		//objParticleSys->AddParticle(type, &pos, &vec);
; 211  : 		DrawableParticleSys::PS_AddParticleEx(type, &pos, &vec);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?PS_AddParticleEx@DrawableParticleSys@@SAXHPAUTpoint@@0@Z ; DrawableParticleSys::PS_AddParticleEx
	add	esp, 12					; 0000000cH

; 212  : 		type=SFX_PARTICLE_KLUDGE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 119			; 00000077H

; 213  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN3@TryParticl
$LN1@TryParticl:

; 214  : 	}
; 215  : 	return 0;

	xor	eax, eax
$LN3@TryParticl:

; 216  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TryParticleEffect@SfxClass@@QAEHXZ ENDP		; SfxClass::TryParticleEffect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv86 = -12						; size = 4
_stopit$ = -8						; size = 4
_angle1$ = -4						; size = 4
_angle$ = 8						; size = 4
_rest$ = 12						; size = 4
_multiplier$ = 16					; size = 4
_min$ = 20						; size = 4
?RestPiece@SfxClass@@KAHPAMMMM@Z PROC			; SfxClass::RestPiece

; 2273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2274 : 	int stopit = 0;

	mov	DWORD PTR _stopit$[ebp], 0

; 2275 : 	*angle = AdjustAngle180(*angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustAngle180@SfxClass@@KAMM@Z	; SfxClass::AdjustAngle180
	add	esp, 4
	mov	ecx, DWORD PTR _angle$[ebp]
	fstp	DWORD PTR [ecx]

; 2276 : 	float angle1 = (rest - *angle);

	mov	edx, DWORD PTR _angle$[ebp]
	movss	xmm0, DWORD PTR _rest$[ebp]
	subss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _angle1$[ebp], xmm0

; 2277 : 	if (fabs(angle1) < min) stopit = 1;

	push	ecx
	movss	xmm0, DWORD PTR _angle1$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv86[ebp]
	movss	xmm0, DWORD PTR _min$[ebp]
	comiss	xmm0, DWORD PTR tv86[ebp]
	jbe	SHORT $LN2@RestPiece
	mov	DWORD PTR _stopit$[ebp], 1

; 2278 : 	else {

	jmp	SHORT $LN1@RestPiece
$LN2@RestPiece:

; 2279 : 		angle1 *= multiplier;

	movss	xmm0, DWORD PTR _angle1$[ebp]
	mulss	xmm0, DWORD PTR _multiplier$[ebp]
	movss	DWORD PTR _angle1$[ebp], xmm0

; 2280 : 		*angle += angle1;

	mov	eax, DWORD PTR _angle$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR _angle1$[ebp]
	mov	ecx, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN1@RestPiece:

; 2281 : 	}
; 2282 : 	return stopit;

	mov	eax, DWORD PTR _stopit$[ebp]

; 2283 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RestPiece@SfxClass@@KAHPAMMMM@Z ENDP			; SfxClass::RestPiece
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_angle$ = 8						; size = 4
?AdjustAngle180@SfxClass@@KAMM@Z PROC			; SfxClass::AdjustAngle180

; 2265 : {

	push	ebp
	mov	ebp, esp
$LN5@AdjustAngl:

; 2266 : 	while (angle >  PI*2) angle -= PI*2;

	movss	xmm0, DWORD PTR _angle$[ebp]
	comiss	xmm0, DWORD PTR __real@40c90fdb
	jbe	SHORT $LN4@AdjustAngl
	movss	xmm0, DWORD PTR _angle$[ebp]
	subss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _angle$[ebp], xmm0
	jmp	SHORT $LN5@AdjustAngl
$LN4@AdjustAngl:

; 2267 : 	while (angle < -PI*2) angle += PI*2;

	movss	xmm0, DWORD PTR __real@c0c90fdb
	comiss	xmm0, DWORD PTR _angle$[ebp]
	jbe	SHORT $LN2@AdjustAngl
	movss	xmm0, DWORD PTR _angle$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _angle$[ebp], xmm0
	jmp	SHORT $LN4@AdjustAngl
$LN2@AdjustAngl:

; 2268 : 	if (angle > PI) angle -= PI*2;

	movss	xmm0, DWORD PTR _angle$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN1@AdjustAngl
	movss	xmm0, DWORD PTR _angle$[ebp]
	subss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _angle$[ebp], xmm0
$LN1@AdjustAngl:

; 2269 : 	return angle;

	fld	DWORD PTR _angle$[ebp]

; 2270 : }

	pop	ebp
	ret	0
?AdjustAngle180@SfxClass@@KAMM@Z ENDP			; SfxClass::AdjustAngle180
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
tv138 = -4						; size = 4
_mat$ = 8						; size = 4
_yaw$ = 12						; size = 4
_pitch$ = 16						; size = 4
_roll$ = 20						; size = 4
?GetOrientation@SfxClass@@KAXQAY02MPAM11@Z PROC		; SfxClass::GetOrientation

; 2258 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2259 : 	*pitch = -(float)asin(mat[0][2]);

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2260 : 	*yaw   = (float)atan2(mat[0][1], mat[0][0]);

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 0
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _yaw$[ebp]
	fstp	DWORD PTR [ecx]

; 2261 : 	*roll  = (float)atan2(mat[1][2], mat[2][2]);

	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR [ecx+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _roll$[ebp]
	fstp	DWORD PTR [eax]

; 2262 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOrientation@SfxClass@@KAXQAY02MPAM11@Z ENDP		; SfxClass::GetOrientation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_result$ = 8						; size = 4
_mat$ = 12						; size = 4
?CopyMatrix@SfxClass@@KAXQAY02M0@Z PROC			; SfxClass::CopyMatrix

; 2245 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 2246 : 	result[0][0] = mat[0][0];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	esi, 4
	imul	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 2247 : 	result[1][0] = mat[1][0];

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	esi, 4
	imul	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 2248 : 	result[2][0] = mat[2][0];

	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	esi, 4
	imul	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 2249 : 	result[0][1] = mat[0][1];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 2250 : 	result[1][1] = mat[1][1];

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 2251 : 	result[2][1] = mat[2][1];

	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 2252 : 	result[0][2] = mat[0][2];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 2253 : 	result[1][2] = mat[1][2];

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 2254 : 	result[2][2] = mat[2][2];

	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 2255 : }

	pop	esi
	pop	ebp
	ret	0
?CopyMatrix@SfxClass@@KAXQAY02M0@Z ENDP			; SfxClass::CopyMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_result$ = 8						; size = 4
_point$ = 12						; size = 4
_mat$ = 16						; size = 4
?TransformPoint@SfxClass@@KAXPAUTpoint@@0QAY02M@Z PROC	; SfxClass::TransformPoint

; 2238 : {

	push	ebp
	mov	ebp, esp

; 2239 : 	result -> x = point -> x * mat[0][0] + point -> y * mat[1][0] + point -> z * mat[2][0];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	mulss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _result$[ebp]
	movss	DWORD PTR [eax], xmm0

; 2240 : 	result -> y = point -> x * mat[0][1] + point -> y * mat[1][1] + point -> z * mat[2][1];

	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _result$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 2241 : 	result -> z = point -> x * mat[0][2] + point -> y * mat[1][2] + point -> z * mat[2][2];

	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _result$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 2242 : }

	pop	ebp
	ret	0
?TransformPoint@SfxClass@@KAXPAUTpoint@@0QAY02M@Z ENDP	; SfxClass::TransformPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_result$ = 8						; size = 4
_mat$ = 12						; size = 4
_mat1$ = 16						; size = 4
?MultiplyMatrix@SfxClass@@KAXQAY02M00@Z PROC		; SfxClass::MultiplyMatrix

; 2225 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 2226 : 	result[0][0] = mat[0][0]*mat1[0][0] + mat[1][0]*mat1[0][1] + mat[2][0]*mat1[0][2];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2227 : 	result[1][0] = mat[0][0]*mat1[1][0] + mat[1][0]*mat1[1][1] + mat[2][0]*mat1[1][2];

	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2228 : 	result[2][0] = mat[0][0]*mat1[2][0] + mat[1][0]*mat1[2][1] + mat[2][0]*mat1[2][2];

	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2229 : 	result[0][1] = mat[0][1]*mat1[0][0] + mat[1][1]*mat1[0][1] + mat[2][1]*mat1[0][2];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2230 : 	result[1][1] = mat[0][1]*mat1[1][0] + mat[1][1]*mat1[1][1] + mat[2][1]*mat1[1][2];

	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2231 : 	result[2][1] = mat[0][1]*mat1[2][0] + mat[1][1]*mat1[2][1] + mat[2][1]*mat1[2][2];

	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2232 : 	result[0][2] = mat[0][2]*mat1[0][0] + mat[1][2]*mat1[0][1] + mat[2][2]*mat1[0][2];

	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+esi]
	addss	xmm0, xmm1
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 2233 : 	result[1][2] = mat[0][2]*mat1[1][0] + mat[1][2]*mat1[1][1] + mat[2][2]*mat1[1][2];

	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 2234 : 	result[2][2] = mat[0][2]*mat1[2][0] + mat[1][2]*mat1[2][1] + mat[2][2]*mat1[2][2];

	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	imul	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat1$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 2235 : }

	pop	esi
	pop	ebp
	ret	0
?MultiplyMatrix@SfxClass@@KAXQAY02M00@Z ENDP		; SfxClass::MultiplyMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_trig$ = -56						; size = 8
tv249 = -48						; size = 4
tv227 = -44						; size = 4
tv205 = -40						; size = 4
_yc$ = -36						; size = 4
_ys$ = -32						; size = 4
_Ny$ = -28						; size = 4
_Nx$ = -24						; size = 4
_z$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_Nz$ = -8						; size = 4
_s$ = -4						; size = 4
_normal$ = 8						; size = 4
_yaw$ = 12						; size = 4
_mat$ = 16						; size = 4
?CalculateGroundMatrix@SfxClass@@KAXPAUTpoint@@MQAY02M@Z PROC ; SfxClass::CalculateGroundMatrix

; 2194 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2195 : mlTrig trig;
; 2196 : 
; 2197 :    mlSinCos (&trig, yaw);

	push	ecx
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2198 : 	float yc = trig.cos;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _yc$[ebp], xmm0

; 2199 : 	float ys = trig.sin;

	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _ys$[ebp], xmm0

; 2200 : 	float Nx, Ny, Nz, x, y, z, s;
; 2201 : 	Nx = -normal -> x;

	mov	ecx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _Nx$[ebp], xmm0

; 2202 : 	Ny = -normal -> y;

	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _Ny$[ebp], xmm0

; 2203 : 	Nz = -normal -> z;

	mov	eax, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _Nz$[ebp], xmm0

; 2204 : 	s =  1.0f / (float) sqrt ( Nx*Nx + Ny*Ny + Nz*Nz );

	movss	xmm0, DWORD PTR _Nx$[ebp]
	mulss	xmm0, DWORD PTR _Nx$[ebp]
	movss	xmm1, DWORD PTR _Ny$[ebp]
	mulss	xmm1, DWORD PTR _Ny$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _Nz$[ebp]
	mulss	xmm1, DWORD PTR _Nz$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv205[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv205[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 2205 : 	mat[2][0] = Nx*s;

	movss	xmm0, DWORD PTR _Nx$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2206 : 	mat[2][1] = Ny*s;

	movss	xmm0, DWORD PTR _Ny$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2207 : 	mat[2][2] = Nz*s;

	movss	xmm0, DWORD PTR _Nz$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 2208 : 	x =  Nz*yc;

	movss	xmm0, DWORD PTR _Nz$[ebp]
	mulss	xmm0, DWORD PTR _yc$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 2209 : 	y =  Nz*ys;

	movss	xmm0, DWORD PTR _Nz$[ebp]
	mulss	xmm0, DWORD PTR _ys$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 2210 : 	z = -Nx*yc -Ny*ys;

	movss	xmm0, DWORD PTR _Nx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _yc$[ebp]
	movss	xmm1, DWORD PTR _Ny$[ebp]
	mulss	xmm1, DWORD PTR _ys$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _z$[ebp], xmm0

; 2211 : 	s =  1.0f / (float) sqrt ( x*x + y*y + z*z );

	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _y$[ebp]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _z$[ebp]
	mulss	xmm1, DWORD PTR _z$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv227[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv227[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 2212 : 	mat[0][0] = x*s;

	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2213 : 	mat[0][1] = y*s;

	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2214 : 	mat[0][2] = z*s;

	movss	xmm0, DWORD PTR _z$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 2215 : 	x = -Nz*ys;

	movss	xmm0, DWORD PTR _Nz$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _ys$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 2216 : 	y =  Nz*yc;

	movss	xmm0, DWORD PTR _Nz$[ebp]
	mulss	xmm0, DWORD PTR _yc$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 2217 : 	z =  Nx*ys - Ny*yc;

	movss	xmm0, DWORD PTR _Nx$[ebp]
	mulss	xmm0, DWORD PTR _ys$[ebp]
	movss	xmm1, DWORD PTR _Ny$[ebp]
	mulss	xmm1, DWORD PTR _yc$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _z$[ebp], xmm0

; 2218 : 	s =  1.0f / (float) sqrt ( x*x + y*y + z*z );

	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _y$[ebp]
	mulss	xmm1, DWORD PTR _y$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _z$[ebp]
	mulss	xmm1, DWORD PTR _z$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv249[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv249[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 2219 : 	mat[1][0] = x*s;

	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2220 : 	mat[1][1] = y*s;

	movss	xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 2221 : 	mat[1][2] = z*s;

	movss	xmm0, DWORD PTR _z$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 2222 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateGroundMatrix@SfxClass@@KAXPAUTpoint@@MQAY02M@Z ENDP ; SfxClass::CalculateGroundMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\sfx.cpp
_TEXT	SEGMENT
_trig$ = -24						; size = 8
_rc$ = -16						; size = 4
_pc$ = -12						; size = 4
_rs$ = -8						; size = 4
_ps$ = -4						; size = 4
_pitch$ = 8						; size = 4
_roll$ = 12						; size = 4
_mat$ = 16						; size = 4
?CalculateRestingObjectMatrix@SfxClass@@KAXMMQAY02M@Z PROC ; SfxClass::CalculateRestingObjectMatrix

; 2172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2173 : mlTrig trig;
; 2174 : 
; 2175 :    mlSinCos (&trig, roll);

	push	ecx
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2176 : 	float rs = trig.sin;

	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _rs$[ebp], xmm0

; 2177 : 	float rc = trig.cos;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _rc$[ebp], xmm0

; 2178 : 
; 2179 :    mlSinCos (&trig, pitch);

	push	ecx
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2180 : 	float ps = trig.sin;

	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _ps$[ebp], xmm0

; 2181 : 	float pc = trig.cos;

	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _pc$[ebp], xmm0

; 2182 : 	mat[0][0] =  pc;

	mov	edx, 12					; 0000000cH
	imul	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _pc$[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 2183 : 	mat[0][1] =  0.0f;

	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx], xmm0

; 2184 : 	mat[0][2] = -ps;

	movss	xmm0, DWORD PTR _ps$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 2185 : 	mat[1][0] =  ps * rs;

	movss	xmm0, DWORD PTR _ps$[ebp]
	mulss	xmm0, DWORD PTR _rs$[ebp]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2186 : 	mat[1][1] =  rc;

	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 2187 : 	mat[1][2] =  pc * rs;

	movss	xmm0, DWORD PTR _pc$[ebp]
	mulss	xmm0, DWORD PTR _rs$[ebp]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 2188 : 	mat[2][0] =  ps * rc;

	movss	xmm0, DWORD PTR _ps$[ebp]
	mulss	xmm0, DWORD PTR _rc$[ebp]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	add	edx, DWORD PTR _mat$[ebp]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 2189 : 	mat[2][1] = -rs;

	movss	xmm0, DWORD PTR _rs$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	add	ecx, DWORD PTR _mat$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 2190 : 	mat[2][2] =  pc * rc;

	movss	xmm0, DWORD PTR _pc$[ebp]
	mulss	xmm0, DWORD PTR _rc$[ebp]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _mat$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 2191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateRestingObjectMatrix@SfxClass@@KAXMMQAY02M@Z ENDP ; SfxClass::CalculateRestingObjectMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newe$ = 8						; size = 4
?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z PROC ; VuBin<SimBaseClass>::reset, COMDAT
; _this$ = ecx

; 60   : 	void reset(E *newe = NULL){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if (newe == e){ return; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newe$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@reset
	jmp	SHORT $LN2@reset
$LN1@reset:

; 62   : 		VuReferenceEntity(newe); // ref new pointer

	mov	edx, DWORD PTR _newe$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 63   : 		VuDeReferenceEntity(e);  // unref old pointer

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 64   : 		e = newe;                // get new pointer

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@reset:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$VuBin@VSimBaseClass@@@@QAEXPAVSimBaseClass@@@Z ENDP ; VuBin<SimBaseClass>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ PROC ; VuBin<SimBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ENDP ; VuBin<SimBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ PROC	; VuBin<SimBaseClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ENDP	; VuBin<SimBaseClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimBaseClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimBaseClass@@@@QBE_NXZ PROC		; VuBin<SimBaseClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimBaseClass@@@@QBE_NXZ ENDP		; VuBin<SimBaseClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??1?$VuBin@VSimBaseClass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$VuBin@VSimBaseClass@@@@QAE@XZ PROC			; VuBin<SimBaseClass>::~VuBin<SimBaseClass>, COMDAT
; _this$ = ecx

; 19   : 	~VuBin(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 		VuDeReferenceEntity((VuEntity *)e);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 21   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$VuBin@VSimBaseClass@@@@QAE@XZ ENDP			; VuBin<SimBaseClass>::~VuBin<SimBaseClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_e$ = 8							; size = 4
??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z PROC ; VuBin<SimBaseClass>::VuBin<SimBaseClass>, COMDAT
; _this$ = ecx

; 11   : 	explicit VuBin(E *e = NULL) : e(e){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], ecx

; 12   : 		VuReferenceEntity(e);

	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$VuBin@VSimBaseClass@@@@QAE@PAVSimBaseClass@@@Z ENDP ; VuBin<SimBaseClass>::VuBin<SimBaseClass>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z PROC		; OTWDriverClass::SetEndFlightVec, COMDAT
; _this$ = ecx

; 468  : 	  {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 		  endFlightVec.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+33528], xmm0

; 470  : 		  endFlightVec.y = y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+33532], xmm0

; 471  : 		  endFlightVec.z = z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [edx+33536], xmm0

; 472  : 	  }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetEndFlightVec@OTWDriverClass@@QAEXMMM@Z ENDP		; OTWDriverClass::SetEndFlightVec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z
_TEXT	SEGMENT
_Z$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z PROC	; OTWDriverClass::SetEndFlightPoint, COMDAT
; _this$ = ecx

; 456  : 	  {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		  endFlightPoint.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+33516], xmm0

; 458  : 		  endFlightPoint.y = y;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+33520], xmm0

; 459  : 		  endFlightPoint.z = z;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [edx+33524], xmm0

; 460  : 		  endFlightPointSet = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+33552], 1

; 461  : 	      float Z = GetGroundLevel( x, y );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _Z$[ebp]

; 462  : 		  if ( z + 50.0f > Z )

	movss	xmm0, DWORD PTR _z$[ebp]
	addss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR _Z$[ebp]
	jbe	SHORT $LN1@SetEndFlig

; 463  : 			  endFlightPoint.z = Z - 50.0f;

	movss	xmm0, DWORD PTR _Z$[ebp]
	subss	xmm0, DWORD PTR __real@42480000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+33524], xmm0
$LN1@SetEndFlig:

; 464  : 
; 465  : 	  }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetEndFlightPoint@OTWDriverClass@@QAEXMMM@Z ENDP	; OTWDriverClass::SetEndFlightPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?SetOwnshipPosition@OTWDriverClass@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetOwnshipPosition@OTWDriverClass@@QAEXMMM@Z PROC	; OTWDriverClass::SetOwnshipPosition, COMDAT
; _this$ = ecx

; 432  :       void SetOwnshipPosition (float x, float y, float z) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 433  :          focusPoint.x = ownshipPos.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+32108], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx+33428], xmm0

; 434  :          focusPoint.y = ownshipPos.y = y;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx+32112], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax+33432], xmm0

; 435  :          focusPoint.z = ownshipPos.z = z;};

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [ecx+32116], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [edx+33436], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetOwnshipPosition@OTWDriverClass@@QAEXMMM@Z ENDP	; OTWDriverClass::SetOwnshipPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?Scale@OTWDriverClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Scale@OTWDriverClass@@QAEMXZ PROC			; OTWDriverClass::Scale, COMDAT
; _this$ = ecx

; 342  :       float Scale (void) { return objectScale;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32124]
	mov	esp, ebp
	pop	ebp
	ret	0
?Scale@OTWDriverClass@@QAEMXZ ENDP			; OTWDriverClass::Scale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\otwdrive.h
;	COMDAT ?GraphicsOwnship@OTWDriverClass@@QBEPAVSimBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GraphicsOwnship@OTWDriverClass@@QBEPAVSimBaseClass@@XZ PROC ; OTWDriverClass::GraphicsOwnship, COMDAT
; _this$ = ecx

; 284  : 		SimBaseClass* GraphicsOwnship () const { return otwPlatform.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32336				; 00007e50H
	call	?get@?$VuBin@VSimBaseClass@@@@QBEPAVSimBaseClass@@XZ ; VuBin<SimBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GraphicsOwnship@OTWDriverClass@@QBEPAVSimBaseClass@@XZ ENDP ; OTWDriverClass::GraphicsOwnship
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?Status@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Status@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::Status, COMDAT
; _this$ = ecx

; 192  : 	int Status() const { return specialData.status; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+176]
	mov	esp, ebp
	pop	ebp
	ret	0
?Status@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::Status
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsAwake@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 177  : 	int IsAwake() const { return localFlags & OBJ_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?RollDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RollDelta@VuEntity@@QBEMXZ PROC			; VuEntity::RollDelta, COMDAT
; _this$ = ecx

; 169  : 	SM_SCALAR RollDelta() const { return orient_.droll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+80]
	mov	esp, ebp
	pop	ebp
	ret	0
?RollDelta@VuEntity@@QBEMXZ ENDP			; VuEntity::RollDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?PitchDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PitchDelta@VuEntity@@QBEMXZ PROC			; VuEntity::PitchDelta, COMDAT
; _this$ = ecx

; 168  : 	SM_SCALAR PitchDelta() const { return orient_.dpitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	mov	esp, ebp
	pop	ebp
	ret	0
?PitchDelta@VuEntity@@QBEMXZ ENDP			; VuEntity::PitchDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YawDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YawDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YawDelta, COMDAT
; _this$ = ecx

; 167  : 	SM_SCALAR YawDelta() const { return orient_.dyaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+72]
	mov	esp, ebp
	pop	ebp
	ret	0
?YawDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YawDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPRDelta@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dyaw$ = 8						; size = 4
_dpitch$ = 12						; size = 4
_droll$ = 16						; size = 4
?SetYPRDelta@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPRDelta, COMDAT
; _this$ = ecx

; 116  : 	void SetYPRDelta(SM_SCALAR dyaw, SM_SCALAR dpitch,SM_SCALAR droll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		orient_.dyaw_ = dyaw; orient_.dpitch_ = dpitch; orient_.droll_=droll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dyaw$[ebp]
	movss	DWORD PTR [eax+72], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dpitch$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _droll$[ebp]
	movss	DWORD PTR [edx+80], xmm0

; 118  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPRDelta@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPRDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPR@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?SetYPR@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPR, COMDAT
; _this$ = ecx

; 113  : 	void SetYPR(SM_SCALAR yaw, SM_SCALAR pitch, SM_SCALAR roll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 115  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPR@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\draw2d.h
;	COMDAT ?SetScale2D@Drawable2D@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?SetScale2D@Drawable2D@@QAEXM@Z PROC			; Drawable2D::SetScale2D, COMDAT
; _this$ = ecx

; 150  : 	void SetScale2D( float s ) { scale2d = s; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [eax+248], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale2D@Drawable2D@@QAEXM@Z ENDP			; Drawable2D::SetScale2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDInt6@@YAHXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDInt6@@YAHXZ PROC					; PRANDInt6, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 158  : //	return	FloatToInt32( (float)(NRANDPOS * 5.9999f) );
; 159  : 	int	x= (int)GenerateFastRandom()&0x07;

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 7
	mov	DWORD PTR _x$[ebp], eax

; 160  : 	return((x<6)?x:x-6);

	cmp	DWORD PTR _x$[ebp], 6
	jge	SHORT $LN3@PRANDInt6
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@PRANDInt6
$LN3@PRANDInt6:
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, 6
	mov	DWORD PTR tv68[ebp], ecx
$LN4@PRANDInt6:
	mov	eax, DWORD PTR tv68[ebp]

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDInt6@@YAHXZ ENDP					; PRANDInt6
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloatPos@@YAMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloatPos@@YAMXZ PROC				; PRANDFloatPos, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 151  : //	return NRANDPOS;
; 152  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 153  : 	return( x / 65535.0f);

	movss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloatPos@@YAMXZ ENDP				; PRANDFloatPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloat@@YAMXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloat@@YAMXZ PROC					; PRANDFloat, COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 144  : //	return NRAND;
; 145  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 146  : 	return( 1 - 2 * x / 65535.0f);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR tv75[ebp], xmm1
	fld	DWORD PTR tv75[ebp]

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloat@@YAMXZ ENDP					; PRANDFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDInt3@@YAHXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDInt3@@YAHXZ PROC					; PRANDInt3, COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 3
	mov	DWORD PTR _x$[ebp], eax

; 138  : 	return((x<3)?x:x-3);

	cmp	DWORD PTR _x$[ebp], 3
	jge	SHORT $LN3@PRANDInt3
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@PRANDInt3
$LN3@PRANDInt3:
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv68[ebp], ecx
$LN4@PRANDInt3:
	mov	eax, DWORD PTR tv68[ebp]

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDInt3@@YAHXZ ENDP					; PRANDInt3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDInt5@@YAHXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDInt5@@YAHXZ PROC					; PRANDInt5, COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 129  : //	return	FloatToInt32(NRANDPOS * 4.9999f);
; 130  : 	int	x= (int)GenerateFastRandom()&0x07;

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 7
	mov	DWORD PTR _x$[ebp], eax

; 131  : 	return((x<5)?x:x-5);

	cmp	DWORD PTR _x$[ebp], 5
	jge	SHORT $LN3@PRANDInt5
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@PRANDInt5
$LN3@PRANDInt5:
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, 5
	mov	DWORD PTR tv68[ebp], ecx
$LN4@PRANDInt5:
	mov	eax, DWORD PTR tv68[ebp]

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDInt5@@YAHXZ ENDP					; PRANDInt5
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetID@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@DrawableBSP@@QAEHXZ PROC				; DrawableBSP::GetID, COMDAT
; _this$ = ecx

; 72   : 	int  GetID( void )			{ return id; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+120]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@DrawableBSP@@QAEHXZ ENDP				; DrawableBSP::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawsgmt.h
;	COMDAT ?KeepStaleSegs@DrawableTrail@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?KeepStaleSegs@DrawableTrail@@QAEXH@Z PROC		; DrawableTrail::KeepStaleSegs, COMDAT
; _this$ = ecx

; 133  : 	void	KeepStaleSegs( BOOL val ) { keepStaleSegs = val; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+84], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeepStaleSegs@DrawableTrail@@QAEXH@Z ENDP		; DrawableTrail::KeepStaleSegs
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?InDisplayList@DrawableObject@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?InDisplayList@DrawableObject@@QAEHXZ PROC		; DrawableObject::InDisplayList, COMDAT
; _this$ = ecx

; 51   : 	BOOL	InDisplayList( void )	{ return (parentList != NULL); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN3@InDisplayL
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@InDisplayL
$LN3@InDisplayL:
	mov	DWORD PTR tv66[ebp], 0
$LN4@InDisplayL:
	mov	eax, DWORD PTR tv66[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?InDisplayList@DrawableObject@@QAEHXZ ENDP		; DrawableObject::InDisplayList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?SetScale@DrawableObject@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?SetScale@DrawableObject@@QAEXM@Z PROC			; DrawableObject::SetScale, COMDAT
; _this$ = ecx

; 34   :     { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   :         radius = (s/scale)*radius; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _s$[ebp]
	divss	xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+16], xmm0

; 36   :         scale = s; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 37   :     };

	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@DrawableObject@@QAEXM@Z ENDP			; DrawableObject::SetScale
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z PROC	; DrawableObject::GetPosition, COMDAT
; _this$ = ecx

; 28   : 	void GetPosition(Tpoint* pos){ *pos = position; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ENDP	; DrawableObject::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z PROC		; TViewPoint::GetPos, COMDAT
; _this$ = ecx

; 119  : 	void	GetPos( Tpoint *p )		{ *p = pos; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z ENDP		; TViewPoint::GetPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?asin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?asin@@YAMM@Z PROC					; asin, COMDAT

; 503  :         {return (asinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_asinf
	add	esp, 4
	pop	ebp
	ret	0
?asin@@YAMM@Z ENDP					; asin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _asinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_asinf	PROC						; COMDAT

; 402  :         {return ((float)asin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_asin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_asinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
