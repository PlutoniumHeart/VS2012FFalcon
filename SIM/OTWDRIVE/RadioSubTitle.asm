; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\OTWDRIVE\RadioSubTitle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?) ; RadioSubTitle::cs_radiosubtitle
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?CompareWith@ANode@@UAEHPAV1@@Z			; ANode::CompareWith
PUBLIC	??1AList@@QAE@XZ				; AList::~AList
PUBLIC	??_GAList@@QAEPAXI@Z				; AList::`scalar deleting destructor'
PUBLIC	??0RadioSubTitle@@QAE@HK@Z			; RadioSubTitle::RadioSubTitle
PUBLIC	??1RadioSubTitle@@QAE@XZ			; RadioSubTitle::~RadioSubTitle
PUBLIC	?GetTimeSortedMessages@RadioSubTitle@@QAEPAPAUColouredSubTitle@@K@Z ; RadioSubTitle::GetTimeSortedMessages
PUBLIC	?ResetAll@RadioSubTitle@@QAEXXZ			; RadioSubTitle::ResetAll
PUBLIC	?NewMessage@RadioSubTitle@@QAEXHHKD@Z		; RadioSubTitle::NewMessage
PUBLIC	?AddToMessage@RadioSubTitle@@QAEXHH@Z		; RadioSubTitle::AddToMessage
PUBLIC	?SetTTLAndMessageNum@RadioSubTitle@@QAEXHK@Z	; RadioSubTitle::SetTTLAndMessageNum
PUBLIC	?SetChannelColours@RadioSubTitle@@QAEXKKKKKKKK@Z ; RadioSubTitle::SetChannelColours
PUBLIC	?SetChannelColours@RadioSubTitle@@QAEXPAD0000000@Z ; RadioSubTitle::SetChannelColours
PUBLIC	??0Init_Error@RadioSubTitle@@QAE@PBD@Z		; RadioSubTitle::Init_Error::Init_Error
PUBLIC	??0SubTitleNode@RadioSubTitle@@QAE@XZ		; RadioSubTitle::SubTitleNode::SubTitleNode
PUBLIC	??1SubTitleNode@RadioSubTitle@@QAE@XZ		; RadioSubTitle::SubTitleNode::~SubTitleNode
PUBLIC	??_GSubTitleNode@RadioSubTitle@@QAEPAXI@Z	; RadioSubTitle::SubTitleNode::`scalar deleting destructor'
PUBLIC	??0csvLine@RadioSubTitle@@QAE@XZ		; RadioSubTitle::csvLine::csvLine
PUBLIC	??1csvLine@RadioSubTitle@@QAE@XZ		; RadioSubTitle::csvLine::~csvLine
PUBLIC	??_GcsvLine@RadioSubTitle@@QAEPAXI@Z		; RadioSubTitle::csvLine::`scalar deleting destructor'
PUBLIC	?CountLinesInFile@RadioSubTitle@@AAEHPBD@Z	; RadioSubTitle::CountLinesInFile
PUBLIC	?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z		; RadioSubTitle::ReadNewFile
PUBLIC	?breakDownLine@RadioSubTitle@@AAEXPAUcsvLine@1@PADH@Z ; RadioSubTitle::breakDownLine
PUBLIC	?HandleChunk@RadioSubTitle@@AAEXPAUcsvLine@1@PADPAH@Z ; RadioSubTitle::HandleChunk
PUBLIC	?GetRadioChunk@RadioSubTitle@@AAEPADHH@Z	; RadioSubTitle::GetRadioChunk
PUBLIC	?FindChannelColour@RadioSubTitle@@AAEKD@Z	; RadioSubTitle::FindChannelColour
PUBLIC	?FindChannelName@RadioSubTitle@@AAEPADD@Z	; RadioSubTitle::FindChannelName
PUBLIC	?AppendToString@RadioSubTitle@@AAEXPAPADPBD@Z	; RadioSubTitle::AppendToString
PUBLIC	?OverWriteString@RadioSubTitle@@AAEXPAPADPBD@Z	; RadioSubTitle::OverWriteString
PUBLIC	??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z		; _com_error::_com_error
PUBLIC	??0_com_error@@QAE@ABV0@@Z			; _com_error::_com_error
PUBLIC	??1_com_error@@UAE@XZ				; _com_error::~_com_error
PUBLIC	??_G_com_error@@UAEPAXI@Z			; _com_error::`scalar deleting destructor'
PUBLIC	??_7SubTitleNode@RadioSubTitle@@6B@		; RadioSubTitle::SubTitleNode::`vftable'
PUBLIC	??_7_com_error@@6B@				; _com_error::`vftable'
PUBLIC	??_C@_0BD@FOGFACPK@F4Talk95v1?90?90?4csv?$AA@	; `string'
PUBLIC	__TI1?AUInit_Error@RadioSubTitle@@
PUBLIC	__CTA1?AUInit_Error@RadioSubTitle@@
PUBLIC	??_R0?AUInit_Error@RadioSubTitle@@@8		; RadioSubTitle::Init_Error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUInit_Error@RadioSubTitle@@@84
PUBLIC	??_C@_0CG@DPMGOLOO@No?5frag?5lines?5in?5subtitles?5input@ ; `string'
PUBLIC	??_C@_0BJ@GFKKJABC@Could?5not?5create?5strings?$AA@ ; `string'
PUBLIC	??_C@_0CH@PANBBNOP@Error?5reading?5the?5subtitles?5inpu@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	__TI1?AV_com_error@@
PUBLIC	__CTA1?AV_com_error@@
PUBLIC	??_R0?AV_com_error@@@8				; _com_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_com_error@@@8??0_com_error@@QAE@ABV0@@Z16
PUBLIC	??_C@_08DCEAMBNI@?$FLTower?$FN?5?$AA@		; `string'
PUBLIC	??_C@_09MAGNIBJN@?$FLFlight?$FN?5?$AA@		; `string'
PUBLIC	??_C@_0O@GDGFBCDL@?$FLTo?5Package?$FN?5?$AA@	; `string'
PUBLIC	??_C@_0BD@KIOHIJHL@?$FLTo?1From?5Package?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_08HBOHJGMH@?$FLGuard?$FN?5?$AA@		; `string'
PUBLIC	??_C@_0N@ONBEGNO@?$FLProximity?$FN?5?$AA@	; `string'
PUBLIC	??_C@_0N@IJLCCJLL@?$FLBroadcast?$FN?5?$AA@	; `string'
PUBLIC	??_C@_0L@MKDKBADN@?$FLUnknown?$FN?5?$AA@	; `string'
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02BMJICGCB@rt?$AA@			; `string'
PUBLIC	??_R4SubTitleNode@RadioSubTitle@@6B@		; RadioSubTitle::SubTitleNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSubTitleNode@RadioSubTitle@@@8		; RadioSubTitle::SubTitleNode `RTTI Type Descriptor'
PUBLIC	??_R3SubTitleNode@RadioSubTitle@@8		; RadioSubTitle::SubTitleNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SubTitleNode@RadioSubTitle@@8		; RadioSubTitle::SubTitleNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SubTitleNode@RadioSubTitle@@8	; RadioSubTitle::SubTitleNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ANode@@8				; ANode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVANode@@@8				; ANode `RTTI Type Descriptor'
PUBLIC	??_R3ANode@@8					; ANode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ANode@@8					; ANode::`RTTI Base Class Array'
PUBLIC	??_R4_com_error@@6B@				; _com_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_com_error@@8				; _com_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_com_error@@8				; _com_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_com_error@@8			; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_fclose:PROC
EXTRN	_fgets:PROC
EXTRN	_fopen:PROC
EXTRN	_sscanf:PROC
EXTRN	_atoi:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	??0ANode@@QAE@XZ:PROC				; ANode::ANode
EXTRN	?GetSucc@ANode@@QAEPAXXZ:PROC			; ANode::GetSucc
EXTRN	?InsertAfter@ANode@@QAEXPAV1@@Z:PROC		; ANode::InsertAfter
EXTRN	??1ANode@@QAE@XZ:PROC				; ANode::~ANode
EXTRN	??0AList@@QAE@XZ:PROC				; AList::AList
EXTRN	?RemHead@AList@@QAEPAXXZ:PROC			; AList::RemHead
EXTRN	?AddTail@AList@@QAEXPAVANode@@@Z:PROC		; AList::AddTail
EXTRN	?GetHead@AList@@QAEPAXXZ:PROC			; AList::GetHead
EXTRN	??_E_com_error@@UAEPAXI@Z:PROC			; _com_error::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@_com_error@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_com_error@@8 DD FLAT:??_R0?AV_com_error@@@8 ; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R2_com_error@@8
rdata$r	SEGMENT
??_R2_com_error@@8 DD FLAT:??_R1A@?0A@EA@_com_error@@8	; _com_error::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_com_error@@8
rdata$r	SEGMENT
??_R3_com_error@@8 DD 00H				; _com_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R4_com_error@@6B@
rdata$r	SEGMENT
??_R4_com_error@@6B@ DD 00H				; _com_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_com_error@@@8
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R2ANode@@8
rdata$r	SEGMENT
??_R2ANode@@8 DD FLAT:??_R1A@?0A@EA@ANode@@8		; ANode::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ANode@@8
rdata$r	SEGMENT
??_R3ANode@@8 DD 00H					; ANode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ANode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVANode@@@8
_DATA	SEGMENT
??_R0?AVANode@@@8 DD FLAT:??_7type_info@@6B@		; ANode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVANode@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ANode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ANode@@8 DD FLAT:??_R0?AVANode@@@8	; ANode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ANode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SubTitleNode@RadioSubTitle@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SubTitleNode@RadioSubTitle@@8 DD FLAT:??_R0?AVSubTitleNode@RadioSubTitle@@@8 ; RadioSubTitle::SubTitleNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SubTitleNode@RadioSubTitle@@8
rdata$r	ENDS
;	COMDAT ??_R2SubTitleNode@RadioSubTitle@@8
rdata$r	SEGMENT
??_R2SubTitleNode@RadioSubTitle@@8 DD FLAT:??_R1A@?0A@EA@SubTitleNode@RadioSubTitle@@8 ; RadioSubTitle::SubTitleNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ANode@@8
rdata$r	ENDS
;	COMDAT ??_R3SubTitleNode@RadioSubTitle@@8
rdata$r	SEGMENT
??_R3SubTitleNode@RadioSubTitle@@8 DD 00H		; RadioSubTitle::SubTitleNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SubTitleNode@RadioSubTitle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSubTitleNode@RadioSubTitle@@@8
_DATA	SEGMENT
??_R0?AVSubTitleNode@RadioSubTitle@@@8 DD FLAT:??_7type_info@@6B@ ; RadioSubTitle::SubTitleNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSubTitleNode@RadioSubTitle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SubTitleNode@RadioSubTitle@@6B@
rdata$r	SEGMENT
??_R4SubTitleNode@RadioSubTitle@@6B@ DD 00H		; RadioSubTitle::SubTitleNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSubTitleNode@RadioSubTitle@@@8
	DD	FLAT:??_R3SubTitleNode@RadioSubTitle@@8
rdata$r	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt?$AA@
CONST	SEGMENT
??_C@_02BMJICGCB@rt?$AA@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MKDKBADN@?$FLUnknown?$FN?5?$AA@
CONST	SEGMENT
??_C@_0L@MKDKBADN@?$FLUnknown?$FN?5?$AA@ DB '[Unknown] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IJLCCJLL@?$FLBroadcast?$FN?5?$AA@
CONST	SEGMENT
??_C@_0N@IJLCCJLL@?$FLBroadcast?$FN?5?$AA@ DB '[Broadcast] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONBEGNO@?$FLProximity?$FN?5?$AA@
CONST	SEGMENT
??_C@_0N@ONBEGNO@?$FLProximity?$FN?5?$AA@ DB '[Proximity] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBOHJGMH@?$FLGuard?$FN?5?$AA@
CONST	SEGMENT
??_C@_08HBOHJGMH@?$FLGuard?$FN?5?$AA@ DB '[Guard] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KIOHIJHL@?$FLTo?1From?5Package?$FN?5?$AA@
CONST	SEGMENT
??_C@_0BD@KIOHIJHL@?$FLTo?1From?5Package?$FN?5?$AA@ DB '[To/From Package]'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GDGFBCDL@?$FLTo?5Package?$FN?5?$AA@
CONST	SEGMENT
??_C@_0O@GDGFBCDL@?$FLTo?5Package?$FN?5?$AA@ DB '[To Package] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MAGNIBJN@?$FLFlight?$FN?5?$AA@
CONST	SEGMENT
??_C@_09MAGNIBJN@?$FLFlight?$FN?5?$AA@ DB '[Flight] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCEAMBNI@?$FLTower?$FN?5?$AA@
CONST	SEGMENT
??_C@_08DCEAMBNI@?$FLTower?$FN?5?$AA@ DB '[Tower] ', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AV_com_error@@@8??0_com_error@@QAE@ABV0@@Z16
xdata$x	SEGMENT
__CT??_R0?AV_com_error@@@8??0_com_error@@QAE@ABV0@@Z16 DD 00H
	DD	FLAT:??_R0?AV_com_error@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	010H
	DD	FLAT:??0_com_error@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_com_error@@@8
_DATA	SEGMENT
??_R0?AV_com_error@@@8 DD FLAT:??_7type_info@@6B@	; _com_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_com_error@@', 00H
_DATA	ENDS
;	COMDAT __CTA1?AV_com_error@@
xdata$x	SEGMENT
__CTA1?AV_com_error@@ DD 01H
	DD	FLAT:__CT??_R0?AV_com_error@@@8??0_com_error@@QAE@ABV0@@Z16
xdata$x	ENDS
;	COMDAT __TI1?AV_com_error@@
xdata$x	SEGMENT
__TI1?AV_com_error@@ DD 00H
	DD	FLAT:??1_com_error@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA1?AV_com_error@@
xdata$x	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PANBBNOP@Error?5reading?5the?5subtitles?5inpu@
CONST	SEGMENT
??_C@_0CH@PANBBNOP@Error?5reading?5the?5subtitles?5inpu@ DB 'Error readin'
	DB	'g the subtitles input file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GFKKJABC@Could?5not?5create?5strings?$AA@
CONST	SEGMENT
??_C@_0BJ@GFKKJABC@Could?5not?5create?5strings?$AA@ DB 'Could not create '
	DB	'strings', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DPMGOLOO@No?5frag?5lines?5in?5subtitles?5input@
CONST	SEGMENT
??_C@_0CG@DPMGOLOO@No?5frag?5lines?5in?5subtitles?5input@ DB 'No frag lin'
	DB	'es in subtitles input file', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUInit_Error@RadioSubTitle@@@84
xdata$x	SEGMENT
__CT??_R0?AUInit_Error@RadioSubTitle@@@84 DD 00H
	DD	FLAT:??_R0?AUInit_Error@RadioSubTitle@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AUInit_Error@RadioSubTitle@@@8
_DATA	SEGMENT
??_R0?AUInit_Error@RadioSubTitle@@@8 DD FLAT:??_7type_info@@6B@ ; RadioSubTitle::Init_Error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUInit_Error@RadioSubTitle@@', 00H
_DATA	ENDS
;	COMDAT __CTA1?AUInit_Error@RadioSubTitle@@
xdata$x	SEGMENT
__CTA1?AUInit_Error@RadioSubTitle@@ DD 01H
	DD	FLAT:__CT??_R0?AUInit_Error@RadioSubTitle@@@84
xdata$x	ENDS
;	COMDAT __TI1?AUInit_Error@RadioSubTitle@@
xdata$x	SEGMENT
__TI1?AUInit_Error@RadioSubTitle@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AUInit_Error@RadioSubTitle@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@FOGFACPK@F4Talk95v1?90?90?4csv?$AA@
CONST	SEGMENT
??_C@_0BD@FOGFACPK@F4Talk95v1?90?90?4csv?$AA@ DB 'F4Talk95v1-0-0.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT
??_7_com_error@@6B@ DD FLAT:??_R4_com_error@@6B@	; _com_error::`vftable'
	DD	FLAT:??_E_com_error@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SubTitleNode@RadioSubTitle@@6B@
CONST	SEGMENT
??_7SubTitleNode@RadioSubTitle@@6B@ DD FLAT:??_R4SubTitleNode@RadioSubTitle@@6B@ ; RadioSubTitle::SubTitleNode::`vftable'
	DD	FLAT:?CompareWith@ANode@@UAEHPAV1@@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z$0
__unwindtable$?NewMessage@RadioSubTitle@@QAEXHHKD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewMessage@RadioSubTitle@@QAEXHHKD@Z$0
__unwindtable$??0RadioSubTitle@@QAE@HK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RadioSubTitle@@QAE@HK@Z$0
__ehfuncinfo$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?NewMessage@RadioSubTitle@@QAEXHHKD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NewMessage@RadioSubTitle@@QAEXHHKD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0RadioSubTitle@@QAE@HK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RadioSubTitle@@QAE@HK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AList@@QAE@XZ$0
__ehfuncinfo$??1AList@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_com_error@@UAEPAXI@Z PROC				; _com_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_com_error@@UAE@XZ			; _com_error::~_com_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_com_error@@UAEPAXI@Z ENDP				; _com_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\comdef.h
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_com_error@@UAE@XZ PROC				; _com_error::~_com_error, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_com_error@@6B@

; 295  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN2@com_error

; 296  :         m_perrinfo->Release();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
$LN2@com_error:

; 297  :     }
; 298  :     if (m_pszMsg != NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN3@com_error

; 299  :         LocalFree((HLOCAL)m_pszMsg);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4
$LN3@com_error:

; 300  :     }
; 301  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1_com_error@@UAE@XZ ENDP				; _com_error::~_com_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\comdef.h
;	COMDAT ??0_com_error@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_that$ = 8						; size = 4
??0_com_error@@QAE@ABV0@@Z PROC				; _com_error::_com_error, COMDAT
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_com_error@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 288  :     if (m_perrinfo != NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN2@com_error

; 289  :         m_perrinfo->AddRef();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+4]
	call	edx
$LN2@com_error:

; 290  :     }
; 291  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_com_error@@QAE@ABV0@@Z ENDP				; _com_error::_com_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\comdef.h
;	COMDAT ??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
_perrinfo$ = 12						; size = 4
_fAddRef$ = 16						; size = 1
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z PROC		; _com_error::_com_error, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_com_error@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _perrinfo$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 280  :     if (m_perrinfo != NULL && fAddRef) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@com_error
	movzx	ecx, BYTE PTR _fAddRef$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@com_error

; 281  :         m_perrinfo->AddRef();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+4]
	call	ecx
$LN2@com_error:

; 282  :     }
; 283  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z ENDP		; _com_error::_com_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
;	COMDAT ?OverWriteString@RadioSubTitle@@AAEXPAPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_theOldOne$ = 8						; size = 4
_theNewOne$ = 12					; size = 4
?OverWriteString@RadioSubTitle@@AAEXPAPADPBD@Z PROC	; RadioSubTitle::OverWriteString, COMDAT
; _this$ = ecx

; 640  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 	if (!theNewOne)

	cmp	DWORD PTR _theNewOne$[ebp], 0
	jne	SHORT $LN4@OverWriteS

; 642  : 	{
; 643  : 		assert(false);
; 644  : 		return;

	jmp	SHORT $LN5@OverWriteS
$LN4@OverWriteS:

; 645  : 	}
; 646  : 
; 647  : 	if (theOldOne)

	cmp	DWORD PTR _theOldOne$[ebp], 0
	je	SHORT $LN3@OverWriteS

; 648  : 	{
; 649  : 		if (*theOldOne)

	mov	eax, DWORD PTR _theOldOne$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@OverWriteS

; 650  : 		{
; 651  : 		free(*theOldOne);

	mov	ecx, DWORD PTR _theOldOne$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 652  : 		*theOldOne = 0;

	mov	eax, DWORD PTR _theOldOne$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@OverWriteS:

; 653  : 		}
; 654  : 	}
; 655  : 
; 656  : 	*theOldOne = (char*)malloc(strlen(theNewOne)+1);

	mov	ecx, DWORD PTR _theNewOne$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _theOldOne$[ebp]
	mov	DWORD PTR [edx], eax

; 657  : 	if (*theOldOne)

	mov	eax, DWORD PTR _theOldOne$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@OverWriteS

; 658  : 	{
; 659  : 		strcpy(*theOldOne,theNewOne);

	mov	ecx, DWORD PTR _theNewOne$[ebp]
	push	ecx
	mov	edx, DWORD PTR _theOldOne$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcpy
	add	esp, 8
$LN5@OverWriteS:

; 660  : 	}
; 661  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?OverWriteString@RadioSubTitle@@AAEXPAPADPBD@Z ENDP	; RadioSubTitle::OverWriteString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
;	COMDAT ?AppendToString@RadioSubTitle@@AAEXPAPADPBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_oldLen$ = -12						; size = 4
_newLen$ = -8						; size = 4
_temp$ = -4						; size = 4
_theOldOne$ = 8						; size = 4
_theNewOne$ = 12					; size = 4
?AppendToString@RadioSubTitle@@AAEXPAPADPBD@Z PROC	; RadioSubTitle::AppendToString, COMDAT
; _this$ = ecx

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 	if ((!theOldOne)||(!*theOldOne)||(!theNewOne))

	cmp	DWORD PTR _theOldOne$[ebp], 0
	je	SHORT $LN2@AppendToSt
	mov	eax, DWORD PTR _theOldOne$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@AppendToSt
	cmp	DWORD PTR _theNewOne$[ebp], 0
	jne	SHORT $LN3@AppendToSt
$LN2@AppendToSt:

; 617  : 	{
; 618  : 		assert(false);
; 619  : 		return;

	jmp	SHORT $LN4@AppendToSt
$LN3@AppendToSt:

; 620  : 	}
; 621  : 
; 622  : 	int oldLen = strlen(*theOldOne);

	mov	ecx, DWORD PTR _theOldOne$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _oldLen$[ebp], eax

; 623  : 	int newLen = strlen(theNewOne);

	mov	eax, DWORD PTR _theNewOne$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _newLen$[ebp], eax

; 624  : 
; 625  : 	char* temp = (char*)malloc(oldLen+newLen+1);

	mov	ecx, DWORD PTR _newLen$[ebp]
	mov	edx, DWORD PTR _oldLen$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _temp$[ebp], eax

; 626  : 	if (temp)

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN4@AppendToSt

; 627  : 	{
; 628  : 		strcpy(temp,*theOldOne);

	mov	ecx, DWORD PTR _theOldOne$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 629  : 		strcat(temp,theNewOne);

	mov	ecx, DWORD PTR _theNewOne$[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 630  : 
; 631  : 		free(*theOldOne);

	mov	eax, DWORD PTR _theOldOne$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 632  : 		*theOldOne = temp;

	mov	edx, DWORD PTR _theOldOne$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@AppendToSt:

; 633  : 	}
; 634  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AppendToString@RadioSubTitle@@AAEXPAPADPBD@Z ENDP	; RadioSubTitle::AppendToString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_theChannel$ = 8					; size = 1
?FindChannelName@RadioSubTitle@@AAEPADD@Z PROC		; RadioSubTitle::FindChannelName
; _this$ = ecx

; 525  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 526  : 	if (theChannel & TOFROM_TOWER)

	movsx	eax, BYTE PTR _theChannel$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN14@FindChanne

; 527  : 		return "[Tower] ";

	mov	eax, OFFSET ??_C@_08DCEAMBNI@?$FLTower?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN14@FindChanne:

; 528  : 	else if (theChannel & TOFROM_FLIGHT)

	movsx	ecx, BYTE PTR _theChannel$[ebp]
	and	ecx, 1
	je	SHORT $LN12@FindChanne

; 529  : 		return "[Flight] ";

	mov	eax, OFFSET ??_C@_09MAGNIBJN@?$FLFlight?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN12@FindChanne:

; 530  : 	else if (theChannel & TO_PACKAGE)

	movsx	edx, BYTE PTR _theChannel$[ebp]
	and	edx, 2
	je	SHORT $LN10@FindChanne

; 531  : 		return "[To Package] ";

	mov	eax, OFFSET ??_C@_0O@GDGFBCDL@?$FLTo?5Package?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN10@FindChanne:

; 532  : 	else if (theChannel & TOFROM_PACKAGE)

	movsx	eax, BYTE PTR _theChannel$[ebp]
	and	eax, 4
	je	SHORT $LN8@FindChanne

; 533  : 		return "[To/From Package] ";

	mov	eax, OFFSET ??_C@_0BD@KIOHIJHL@?$FLTo?1From?5Package?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN8@FindChanne:

; 534  : 	else if (theChannel & TO_TEAM)

	movsx	ecx, BYTE PTR _theChannel$[ebp]
	and	ecx, 8
	je	SHORT $LN6@FindChanne

; 535  : 		return "[Guard] ";

	mov	eax, OFFSET ??_C@_08HBOHJGMH@?$FLGuard?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN6@FindChanne:

; 536  : 	else if (theChannel & IN_PROXIMITY)

	movsx	edx, BYTE PTR _theChannel$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN4@FindChanne

; 537  : 		return "[Proximity] ";

	mov	eax, OFFSET ??_C@_0N@ONBEGNO@?$FLProximity?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN4@FindChanne:

; 538  : 	else if (theChannel & TO_WORLD)

	movsx	eax, BYTE PTR _theChannel$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@FindChanne

; 539  : 		return "[Broadcast] ";

	mov	eax, OFFSET ??_C@_0N@IJLCCJLL@?$FLBroadcast?$FN?5?$AA@
	jmp	SHORT $LN15@FindChanne

; 540  : 	else

	jmp	SHORT $LN15@FindChanne
$LN2@FindChanne:

; 541  : 		return "[Unknown] ";

	mov	eax, OFFSET ??_C@_0L@MKDKBADN@?$FLUnknown?$FN?5?$AA@
$LN15@FindChanne:

; 542  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindChannelName@RadioSubTitle@@AAEPADD@Z ENDP		; RadioSubTitle::FindChannelName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_theChannel$ = 8					; size = 1
?FindChannelColour@RadioSubTitle@@AAEKD@Z PROC		; RadioSubTitle::FindChannelColour
; _this$ = ecx

; 502  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 	if (theChannel & TOFROM_TOWER)

	movsx	eax, BYTE PTR _theChannel$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN14@FindChanne

; 504  : 		return colour_Tower;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+52]
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN14@FindChanne:

; 505  : 	else if (theChannel & TOFROM_FLIGHT)

	movsx	edx, BYTE PTR _theChannel$[ebp]
	and	edx, 1
	je	SHORT $LN12@FindChanne

; 506  : 		return colour_Flight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN12@FindChanne:

; 507  : 	else if (theChannel & TO_PACKAGE)

	movsx	ecx, BYTE PTR _theChannel$[ebp]
	and	ecx, 2
	je	SHORT $LN10@FindChanne

; 508  : 		return colour_ToPackage;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN10@FindChanne:

; 509  : 	else if (theChannel & TOFROM_PACKAGE)

	movsx	eax, BYTE PTR _theChannel$[ebp]
	and	eax, 4
	je	SHORT $LN8@FindChanne

; 510  : 		return colour_ToFromPackage;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN8@FindChanne:

; 511  : 	else if (theChannel & TO_TEAM)

	movsx	edx, BYTE PTR _theChannel$[ebp]
	and	edx, 8
	je	SHORT $LN6@FindChanne

; 512  : 		return colour_Team;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN6@FindChanne:

; 513  : 	else if (theChannel & IN_PROXIMITY)

	movsx	ecx, BYTE PTR _theChannel$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN4@FindChanne

; 514  : 		return colour_Proximity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	jmp	SHORT $LN15@FindChanne
	jmp	SHORT $LN15@FindChanne
$LN4@FindChanne:

; 515  : 	else if (theChannel & TO_WORLD)

	movsx	eax, BYTE PTR _theChannel$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@FindChanne

; 516  : 		return colour_World;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	jmp	SHORT $LN15@FindChanne

; 517  : 	else

	jmp	SHORT $LN15@FindChanne
$LN2@FindChanne:

; 518  : 		return colour_Standard;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
$LN15@FindChanne:

; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindChannelColour@RadioSubTitle@@AAEKD@Z ENDP		; RadioSubTitle::FindChannelColour
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_theTalker$ = 8						; size = 4
_theFrag$ = 12						; size = 4
?GetRadioChunk@RadioSubTitle@@AAEPADHH@Z PROC		; RadioSubTitle::GetRadioChunk
; _this$ = ecx

; 290  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 291  : #ifdef SHOW_FRAG_AND_TALKER___BUT_MEM_LEAK
; 292  : 	if ((theStrings[theFrag])&&(theTalker < MAX_VOICE_NUM))
; 293  : 	{
; 294  : 		char* bla = (char*)malloc(strlen(theStrings[theFrag]->Voices[theTalker])+30);	// mem leak but its only for test anyway 
; 295  : 		if (bla)
; 296  : 		{
; 297  : 			char tmp[30];
; 298  : 			sprintf(tmp,"-> %i %i ",theTalker, theFrag);
; 299  : 			strcpy(bla,theStrings[theFrag]->Voices[theTalker]);
; 300  : 			strcat(bla,tmp);
; 301  : 			return bla;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return "bla";
; 306  : 		}
; 307  : 	}
; 308  : 	else
; 309  : 		return 0;
; 310  : #else
; 311  : #ifdef NDEBUG
; 312  : 	if ((theFrag < FragCount)&&(theStrings[theFrag])&&(theTalker < MAX_VOICE_NUM)&&!F4IsBadReadPtr(theStrings[theFrag], sizeof(csvLine)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _theFrag$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN2@GetRadioCh
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _theFrag$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN2@GetRadioCh
	cmp	DWORD PTR _theTalker$[ebp], 14		; 0000000eH
	jge	SHORT $LN2@GetRadioCh
	push	72					; 00000048H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _theFrag$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetRadioCh

; 313  : 	{
; 314  : 		return theStrings[theFrag]->Voices[theTalker];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _theFrag$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _theTalker$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	jmp	SHORT $LN3@GetRadioCh

; 315  : 	}
; 316  : #else
; 317  : 	if ((theFrag < FragCount)&&(theStrings[theFrag])&&(theTalker < MAX_VOICE_NUM))
; 318  : 	{
; 319  : 		if (F4IsBadReadPtr(theStrings[theFrag], sizeof(csvLine)))
; 320  : 		{
; 321  : #pragma warning(disable:4127)
; 322  : 			ShiAssert(false);
; 323  : #pragma warning(default:4127)
; 324  : 			return 0;
; 325  : 		}
; 326  : 		else
; 327  : 			return theStrings[theFrag]->Voices[theTalker];
; 328  : 	}
; 329  : #endif
; 330  : 	else

	jmp	SHORT $LN3@GetRadioCh
$LN2@GetRadioCh:

; 331  : 		return 0;

	xor	eax, eax
$LN3@GetRadioCh:

; 332  : #endif
; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetRadioChunk@RadioSubTitle@@AAEPADHH@Z ENDP		; RadioSubTitle::GetRadioChunk
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv64 = -8						; size = 4
_ChunkIndex$ = -4					; size = 4
_theTextString$ = 8					; size = 4
_theChunk$ = 12						; size = 4
_ChunkCount$ = 16					; size = 4
?HandleChunk@RadioSubTitle@@AAEXPAUcsvLine@1@PADPAH@Z PROC ; RadioSubTitle::HandleChunk
; _this$ = ecx

; 667  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 668  : 	assert(theTextString);
; 669  : 	assert(ChunkCount);
; 670  : 
; 671  : 	// 'theChunk' is often NULL, happens when the csv reads ',,'
; 672  : 
; 673  : 	int ChunkIndex = *ChunkCount;

	mov	eax, DWORD PTR _ChunkCount$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ChunkIndex$[ebp], ecx

; 674  : 
; 675  : 	switch (ChunkIndex)

	mov	edx, DWORD PTR _ChunkIndex$[ebp]
	mov	DWORD PTR tv64[ebp], edx
	cmp	DWORD PTR tv64[ebp], 17			; 00000011H
	ja	$LN10@HandleChun
	mov	eax, DWORD PTR tv64[ebp]
	movzx	ecx, BYTE PTR $LN14@HandleChun[eax]
	jmp	DWORD PTR $LN15@HandleChun[ecx*4]
$LN9@HandleChun:

; 676  : 	{
; 677  : 	case 0:	// frag #
; 678  : 		if (theChunk)

	cmp	DWORD PTR _theChunk$[ebp], 0
	je	SHORT $LN8@HandleChun

; 679  : 		{
; 680  : 			theTextString->Fragment = atoi(theChunk);

	mov	edx, DWORD PTR _theChunk$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _theTextString$[ebp]
	mov	DWORD PTR [ecx], eax

; 681  : 			free(theChunk);		// Retro 3Jan2004 - gotta close that mem leak.. oops

	mov	edx, DWORD PTR _theChunk$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 682  : 			theChunk = 0;

	mov	DWORD PTR _theChunk$[ebp], 0
$LN8@HandleChun:

; 683  : 		}
; 684  : 		break;

	jmp	SHORT $LN10@HandleChun
$LN7@HandleChun:

; 685  : 	case 1:	// maxvoice #
; 686  : 		if (theChunk)

	cmp	DWORD PTR _theChunk$[ebp], 0
	je	SHORT $LN6@HandleChun

; 687  : 		{
; 688  : 			theTextString->VoiceCount = atoi(theChunk);

	mov	eax, DWORD PTR _theChunk$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _theTextString$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 689  : 			free(theChunk);		// Retro 3Jan2004 - gotta close that mem leak.. oops

	mov	edx, DWORD PTR _theChunk$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 690  : 			theChunk = 0;

	mov	DWORD PTR _theChunk$[ebp], 0
$LN6@HandleChun:

; 691  : 		}
; 692  : 		break;

	jmp	SHORT $LN10@HandleChun
$LN5@HandleChun:

; 693  : 	case 2: // the actual voices
; 694  : 	case 3: case 4: case 5:case 6: case 7: case 8: case 9:
; 695  : 	case 10: case 11: case 12: case 13: case 14: case 15:
; 696  : 		theTextString->Voices[ChunkIndex-2] = theChunk;

	mov	eax, DWORD PTR _ChunkIndex$[ebp]
	mov	ecx, DWORD PTR _theTextString$[ebp]
	mov	edx, DWORD PTR _theChunk$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 697  : 		break;

	jmp	SHORT $LN10@HandleChun
$LN4@HandleChun:

; 698  : 	case 16:	// summary
; 699  : 		theTextString->Summary = theChunk;

	mov	eax, DWORD PTR _theTextString$[ebp]
	mov	ecx, DWORD PTR _theChunk$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 700  : 		break;

	jmp	SHORT $LN10@HandleChun
$LN3@HandleChun:

; 701  : 	case 17:	// eval
; 702  : 		if (theChunk)

	cmp	DWORD PTR _theChunk$[ebp], 0
	je	SHORT $LN10@HandleChun

; 703  : 		{
; 704  : 			theTextString->Eval = atoi(theChunk);

	mov	edx, DWORD PTR _theChunk$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _theTextString$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 705  : 			free(theChunk);		// Retro 3Jan2004 - gotta close that mem leak.. oops

	mov	edx, DWORD PTR _theChunk$[ebp]
	push	edx
	call	_free
	add	esp, 4

; 706  : 			theChunk = 0;

	mov	DWORD PTR _theChunk$[ebp], 0
$LN10@HandleChun:

; 707  : 		}
; 708  : 		break;
; 709  : 	default:	// shoudnt happen
; 710  : 		assert(false);
; 711  : 		break;
; 712  : 	}
; 713  : 
; 714  : 	ChunkIndex++;

	mov	eax, DWORD PTR _ChunkIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ChunkIndex$[ebp], eax

; 715  : 	*ChunkCount = ChunkIndex;

	mov	ecx, DWORD PTR _ChunkCount$[ebp]
	mov	edx, DWORD PTR _ChunkIndex$[ebp]
	mov	DWORD PTR [ecx], edx

; 716  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN15@HandleChun:
	DD	$LN9@HandleChun
	DD	$LN7@HandleChun
	DD	$LN5@HandleChun
	DD	$LN4@HandleChun
	DD	$LN3@HandleChun
$LN14@HandleChun:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	4
?HandleChunk@RadioSubTitle@@AAEXPAUcsvLine@1@PADPAH@Z ENDP ; RadioSubTitle::HandleChunk
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_i$ = -36						; size = 4
_this$ = -32						; size = 4
_ChunkCount$ = -28					; size = 4
_tmp$1 = -24						; size = 4
_tmp$2 = -20						; size = 4
_len$ = -16						; size = 4
_start$ = -12						; size = 4
_end$ = -8						; size = 4
_inDoubleQuotes$ = -1					; size = 1
_theTextString$ = 8					; size = 4
_theLine$ = 12						; size = 4
_theLength$ = 16					; size = 4
?breakDownLine@RadioSubTitle@@AAEXPAUcsvLine@1@PADH@Z PROC ; RadioSubTitle::breakDownLine
; _this$ = ecx

; 732  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 733  : 	assert(theTextString);
; 734  : 	assert(theLine);
; 735  : 
; 736  : 	// set start pointer
; 737  : 	char* start = theLine;

	mov	eax, DWORD PTR _theLine$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 738  : 	char* end = theLine;

	mov	ecx, DWORD PTR _theLine$[ebp]
	mov	DWORD PTR _end$[ebp], ecx

; 739  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 740  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 741  : 	bool inDoubleQuotes = false;

	mov	BYTE PTR _inDoubleQuotes$[ebp], 0

; 742  : 
; 743  : 	int ChunkCount = 0;

	mov	DWORD PTR _ChunkCount$[ebp], 0
$LN19@breakDownL:

; 744  : 
; 745  : 	do
; 746  : 	{
; 747  : 		if (end == 0)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN16@breakDownL

; 748  : 		{
; 749  : 			assert(false);
; 750  : 			break;

	jmp	$LN20@breakDownL
$LN16@breakDownL:

; 751  : 		}
; 752  : 
; 753  : 		// check for "
; 754  : 		// if yes, look for next "
; 755  : 		if (*end == QUOTAS/*'"'*/)

	mov	edx, DWORD PTR _end$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN15@breakDownL
$LN14@breakDownL:

; 756  : 		{
; 757  : 			do
; 758  : 			{
; 759  : 				end++;

	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx

; 760  : 			} while (*end != QUOTAS/*'"'*/);

	mov	edx, DWORD PTR _end$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN14@breakDownL

; 761  : 			inDoubleQuotes = true;

	mov	BYTE PTR _inDoubleQuotes$[ebp], 1
$LN15@breakDownL:

; 762  : 		}
; 763  : 
; 764  : 		// look for SEPERATOR
; 765  : 		// set end pointer
; 766  : 		if ((*end == SEPARATOR/*','*/)||(*end == '\0'))

	mov	ecx, DWORD PTR _end$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN10@breakDownL
	mov	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN11@breakDownL
$LN10@breakDownL:

; 767  : 		{
; 768  : 			if (end > start)

	mov	edx, DWORD PTR _end$[ebp]
	cmp	edx, DWORD PTR _start$[ebp]
	jbe	$LN9@breakDownL

; 769  : 			{
; 770  : 				if (!inDoubleQuotes)

	movzx	eax, BYTE PTR _inDoubleQuotes$[ebp]
	test	eax, eax
	jne	SHORT $LN8@breakDownL

; 771  : 				{
; 772  : 					len = end - start + 1;

	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 773  : 					char* tmp = (char*)malloc(len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmp$2[ebp], eax

; 774  : 					if (tmp)

	cmp	DWORD PTR _tmp$2[ebp], 0
	je	SHORT $LN7@breakDownL

; 775  : 					{
; 776  : 						strncpy(tmp,start,len-1);

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 777  : 						tmp[len-1] = '\0';

	mov	eax, DWORD PTR _tmp$2[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax-1], 0

; 778  : 						// copy chunk, hand it to handleroutiner
; 779  : 						HandleChunk(theTextString,tmp,&ChunkCount);

	lea	ecx, DWORD PTR _ChunkCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	mov	eax, DWORD PTR _theTextString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleChunk@RadioSubTitle@@AAEXPAUcsvLine@1@PADPAH@Z ; RadioSubTitle::HandleChunk
$LN7@breakDownL:

; 780  : 					}
; 781  : 					start = end+1;

	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx

; 782  : 				}
; 783  : 				else

	jmp	SHORT $LN6@breakDownL
$LN8@breakDownL:

; 784  : 				{
; 785  : 					len = end - start - 2 + 1;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	sub	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 786  : 					char* tmp = (char*)malloc(len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmp$1[ebp], eax

; 787  : 					if (tmp)

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN5@breakDownL

; 788  : 					{
; 789  : 						strncpy(tmp,start+1,len-1);

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 790  : 						tmp[len-1] = '\0';

	mov	ecx, DWORD PTR _tmp$1[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 791  : 						// copy chunk, hand it to handleroutiner
; 792  : 						HandleChunk(theTextString,tmp,&ChunkCount);

	lea	edx, DWORD PTR _ChunkCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _theTextString$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleChunk@RadioSubTitle@@AAEXPAUcsvLine@1@PADPAH@Z ; RadioSubTitle::HandleChunk
$LN5@breakDownL:

; 793  : 					}
; 794  : 					start = end+1;

	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _start$[ebp], edx

; 795  : 					inDoubleQuotes = false;

	mov	BYTE PTR _inDoubleQuotes$[ebp], 0
$LN6@breakDownL:

; 796  : 				}

	jmp	SHORT $LN4@breakDownL
$LN9@breakDownL:

; 797  : 			}
; 798  : 			else if (start == end)

	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jne	SHORT $LN4@breakDownL

; 799  : 			{
; 800  : 				// copy chunk, hand it to handleroutiner
; 801  : 				HandleChunk(theTextString,0,&ChunkCount);

	lea	ecx, DWORD PTR _ChunkCount$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _theTextString$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleChunk@RadioSubTitle@@AAEXPAUcsvLine@1@PADPAH@Z ; RadioSubTitle::HandleChunk

; 802  : 				start = end+1;

	mov	eax, DWORD PTR _end$[ebp]
	add	eax, 1
	mov	DWORD PTR _start$[ebp], eax
$LN4@breakDownL:

; 803  : 			}
; 804  : 			else
; 805  : 			{
; 806  : 				assert(false);
; 807  : 			}
; 808  : 
; 809  : 			if (*end == '\0')

	mov	ecx, DWORD PTR _end$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN11@breakDownL

; 810  : 			{
; 811  : 				break;

	jmp	SHORT $LN20@breakDownL
$LN11@breakDownL:

; 812  : 			}
; 813  : 		}
; 814  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 815  : 		// advance pointer
; 816  : 		end++;

	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx

; 817  : 	} while (i < theLength);

	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _theLength$[ebp]
	jl	$LN19@breakDownL
$LN20@breakDownL:

; 818  : 
; 819  : //	assert(ChunkCount-1 == theTextString->VoiceCount);
; 820  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?breakDownLine@RadioSubTitle@@AAEXPAUcsvLine@1@PADH@Z ENDP ; RadioSubTitle::breakDownLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
$T2 = -2092						; size = 4
tv93 = -2088						; size = 4
$T3 = -2084						; size = 4
$T4 = -2080						; size = 4
_fp$ = -2076						; size = 4
_this$ = -2072						; size = 4
_j$5 = -2068						; size = 4
_tmp$6 = -2064						; size = 2048
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_theFileName$ = 8					; size = 4
?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z PROC		; RadioSubTitle::ReadNewFile
; _this$ = ecx

; 826  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2080				; 00000820H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 827  : 
; 828  : 	FILE* fp = fopen(theFileName,"rt");

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	mov	eax, DWORD PTR _theFileName$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 829  : 	if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN5@ReadNewFil

; 830  : 	{
; 831  : 		char tmp[MAX_READ_LEN];
; 832  : 		int j = 0;

	mov	DWORD PTR _j$5[ebp], 0
$LN4@ReadNewFil:

; 833  : 
; 834  : 		while (fgets(&tmp[0],MAX_READ_LEN,fp) != NULL)

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	2048					; 00000800H
	mov	edx, 1
	imul	edx, 0
	lea	eax, DWORD PTR _tmp$6[ebp+edx]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN3@ReadNewFil

; 835  : 		{
; 836  : 			if (j == 0)

	cmp	DWORD PTR _j$5[ebp], 0
	jne	SHORT $LN2@ReadNewFil

; 837  : 			{
; 838  : 				j++;

	mov	ecx, DWORD PTR _j$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$5[ebp], ecx

; 839  : 				continue;	// ignoring the first line

	jmp	SHORT $LN4@ReadNewFil
$LN2@ReadNewFil:

; 840  : 			}
; 841  : 
; 842  : 			tmp[strlen(tmp)-1] = 0;	// getting rid of that damn newline

	lea	edx, DWORD PTR _tmp$6[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 2048		; 00000800H
	jae	SHORT $LN8@ReadNewFil
	jmp	SHORT $LN9@ReadNewFil
$LN8@ReadNewFil:
	call	___report_rangecheckfailure
$LN9@ReadNewFil:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _tmp$6[ebp+eax], 0

; 843  : 
; 844  : 			theStrings[j-1] = new csvLine_t;

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN10@ReadNewFil
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0csvLine@RadioSubTitle@@QAE@XZ	; RadioSubTitle::csvLine::csvLine
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN11@ReadNewFil
$LN10@ReadNewFil:
	mov	DWORD PTR tv93[ebp], 0
$LN11@ReadNewFil:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _j$5[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+ecx*4-4], edx

; 845  : 			breakDownLine(theStrings[j-1],tmp,strlen(tmp));

	lea	eax, DWORD PTR _tmp$6[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _tmp$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _j$5[ebp]
	mov	edx, DWORD PTR [eax+ecx*4-4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?breakDownLine@RadioSubTitle@@AAEXPAUcsvLine@1@PADH@Z ; RadioSubTitle::breakDownLine

; 846  : 			j++;

	mov	eax, DWORD PTR _j$5[ebp]
	add	eax, 1
	mov	DWORD PTR _j$5[ebp], eax

; 847  : 		}

	jmp	$LN4@ReadNewFil
$LN3@ReadNewFil:

; 848  : 		fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 849  : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@ReadNewFil

; 850  : 	}
; 851  : 	else

	jmp	SHORT $LN7@ReadNewFil
$LN5@ReadNewFil:

; 852  : 	{
; 853  : 	 	return false;

	xor	al, al
$LN7@ReadNewFil:

; 854  : 	}
; 855  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2084]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z ENDP		; RadioSubTitle::ReadNewFile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -2064						; size = 4
_fp$ = -2060						; size = 4
_linecount$1 = -2056					; size = 4
_tmp$2 = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_theFileName$ = 8					; size = 4
?CountLinesInFile@RadioSubTitle@@AAEHPBD@Z PROC		; RadioSubTitle::CountLinesInFile
; _this$ = ecx

; 862  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2064				; 00000810H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 863  : 	FILE* fp = fopen(theFileName,"rt");

	push	OFFSET ??_C@_02BMJICGCB@rt?$AA@
	mov	eax, DWORD PTR _theFileName$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 864  : 	if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN3@CountLines

; 865  : 	{
; 866  : 		char tmp[MAX_READ_LEN];
; 867  : 		int linecount = 0;

	mov	DWORD PTR _linecount$1[ebp], 0
$LN2@CountLines:

; 868  : 
; 869  : 		while (fgets(&tmp[0],MAX_READ_LEN,fp) != NULL)

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	2048					; 00000800H
	mov	edx, 1
	imul	edx, 0
	lea	eax, DWORD PTR _tmp$2[ebp+edx]
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@CountLines

; 870  : 		{
; 871  : 			linecount++;

	mov	ecx, DWORD PTR _linecount$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _linecount$1[ebp], ecx

; 872  : 		}

	jmp	SHORT $LN2@CountLines
$LN1@CountLines:

; 873  : 		fclose(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 874  : 		return linecount;

	mov	eax, DWORD PTR _linecount$1[ebp]
	jmp	SHORT $LN4@CountLines
$LN3@CountLines:

; 875  : 	}
; 876  : 	return 0;

	xor	eax, eax
$LN4@CountLines:

; 877  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?CountLinesInFile@RadioSubTitle@@AAEHPBD@Z ENDP		; RadioSubTitle::CountLinesInFile
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GcsvLine@RadioSubTitle@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GcsvLine@RadioSubTitle@@QAEPAXI@Z PROC		; RadioSubTitle::csvLine::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1csvLine@RadioSubTitle@@QAE@XZ	; RadioSubTitle::csvLine::~csvLine
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GcsvLine@RadioSubTitle@@QAEPAXI@Z ENDP		; RadioSubTitle::csvLine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\radiosubtitle.h
;	COMDAT ??1csvLine@RadioSubTitle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
??1csvLine@RadioSubTitle@@QAE@XZ PROC			; RadioSubTitle::csvLine::~csvLine, COMDAT
; _this$ = ecx

; 90   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 			for (int i = 0; i < MAX_VOICE_NUM; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@csvLine
$LN4@csvLine:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN5@csvLine:
	cmp	DWORD PTR _i$1[ebp], 14			; 0000000eH
	jge	SHORT $LN3@csvLine

; 92   : 			{
; 93   : 				if (Voices[i])

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+8], 0
	je	SHORT $LN2@csvLine

; 94   : 				{
; 95   : 					free(Voices[i]);

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	push	edx
	call	_free
	add	esp, 4

; 96   : 					Voices[i] = 0;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], 0
$LN2@csvLine:

; 97   : 				}
; 98   : 			}

	jmp	SHORT $LN4@csvLine
$LN3@csvLine:

; 99   : 			if (Summary)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN6@csvLine

; 100  : 			{
; 101  : 				free(Summary);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_free
	add	esp, 4

; 102  : 				Summary = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0
$LN6@csvLine:

; 103  : 			}
; 104  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1csvLine@RadioSubTitle@@QAE@XZ ENDP			; RadioSubTitle::csvLine::~csvLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\radiosubtitle.h
;	COMDAT ??0csvLine@RadioSubTitle@@QAE@XZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
??0csvLine@RadioSubTitle@@QAE@XZ PROC			; RadioSubTitle::csvLine::csvLine, COMDAT
; _this$ = ecx

; 80   : 		csvLine()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		{
; 82   : 			for (int i = 0; i < MAX_VOICE_NUM; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@csvLine
$LN2@csvLine:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@csvLine:
	cmp	DWORD PTR _i$1[ebp], 14			; 0000000eH
	jge	SHORT $LN1@csvLine

; 83   : 			{
; 84   : 				Voices[i] = 0;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], 0

; 85   : 			}

	jmp	SHORT $LN2@csvLine
$LN1@csvLine:

; 86   : 			Summary = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 87   : 			Fragment = VoiceCount = Eval = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 88   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0csvLine@RadioSubTitle@@QAE@XZ ENDP			; RadioSubTitle::csvLine::csvLine
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSubTitleNode@RadioSubTitle@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSubTitleNode@RadioSubTitle@@QAEPAXI@Z PROC		; RadioSubTitle::SubTitleNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SubTitleNode@RadioSubTitle@@QAE@XZ	; RadioSubTitle::SubTitleNode::~SubTitleNode
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSubTitleNode@RadioSubTitle@@QAEPAXI@Z ENDP		; RadioSubTitle::SubTitleNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\radiosubtitle.h
;	COMDAT ??1SubTitleNode@RadioSubTitle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SubTitleNode@RadioSubTitle@@QAE@XZ PROC		; RadioSubTitle::SubTitleNode::~SubTitleNode, COMDAT
; _this$ = ecx

; 67   : 		~SubTitleNode() { free(theSpokenLine); theSpokenLine = 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SubTitleNode@RadioSubTitle@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_free
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	esp, ebp
	pop	ebp
	ret	0
??1SubTitleNode@RadioSubTitle@@QAE@XZ ENDP		; RadioSubTitle::SubTitleNode::~SubTitleNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\radiosubtitle.h
;	COMDAT ??0SubTitleNode@RadioSubTitle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SubTitleNode@RadioSubTitle@@QAE@XZ PROC		; RadioSubTitle::SubTitleNode::SubTitleNode, COMDAT
; _this$ = ecx

; 66   : 		SubTitleNode() { messageStartTime = 0; associatedChannel = 0; theSpokenLine = 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ANode@@QAE@XZ			; ANode::ANode
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SubTitleNode@RadioSubTitle@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SubTitleNode@RadioSubTitle@@QAE@XZ ENDP		; RadioSubTitle::SubTitleNode::SubTitleNode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\radiosubtitle.h
;	COMDAT ??0Init_Error@RadioSubTitle@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_reason$ = 8						; size = 4
??0Init_Error@RadioSubTitle@@QAE@PBD@Z PROC		; RadioSubTitle::Init_Error::Init_Error, COMDAT
; _this$ = ecx

; 54   : 		Init_Error(const char* reason) { theReason = reason; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _reason$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Init_Error@RadioSubTitle@@QAE@PBD@Z ENDP		; RadioSubTitle::Init_Error::Init_Error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_flightCol$ = -36					; size = 4
_toPackageCol$ = -32					; size = 4
_ToFromPackageCol$ = -28				; size = 4
_TeamCol$ = -24						; size = 4
_ProximityCol$ = -20					; size = 4
_WorldCol$ = -16					; size = 4
_TowerCol$ = -12					; size = 4
_StandardCol$ = -8					; size = 4
_temp$ = -4						; size = 4
_flight$ = 8						; size = 4
_toPackage$ = 12					; size = 4
_ToFromPackage$ = 16					; size = 4
_Team$ = 20						; size = 4
_Proximity$ = 24					; size = 4
_World$ = 28						; size = 4
_Tower$ = 32						; size = 4
_Standard$ = 36						; size = 4
?SetChannelColours@RadioSubTitle@@QAEXPAD0000000@Z PROC	; RadioSubTitle::SetChannelColours
; _this$ = ecx

; 569  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 	unsigned long flightCol = 0;

	mov	DWORD PTR _flightCol$[ebp], 0

; 571  : 	unsigned long toPackageCol = 0;

	mov	DWORD PTR _toPackageCol$[ebp], 0

; 572  : 	unsigned long ToFromPackageCol = 0;

	mov	DWORD PTR _ToFromPackageCol$[ebp], 0

; 573  : 	unsigned long TeamCol = 0;

	mov	DWORD PTR _TeamCol$[ebp], 0

; 574  : 	unsigned long ProximityCol = 0;

	mov	DWORD PTR _ProximityCol$[ebp], 0

; 575  : 	unsigned long WorldCol = 0;

	mov	DWORD PTR _WorldCol$[ebp], 0

; 576  : 	unsigned long TowerCol = 0;

	mov	DWORD PTR _TowerCol$[ebp], 0

; 577  : 	unsigned long StandardCol = 0;

	mov	DWORD PTR _StandardCol$[ebp], 0

; 578  : 
; 579  : 	unsigned long temp = 0;

	mov	DWORD PTR _temp$[ebp], 0

; 580  : 
; 581  : 	if (flight)

	cmp	DWORD PTR _flight$[ebp], 0
	je	SHORT $LN16@SetChannel

; 582  : 		if (sscanf(flight,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN16@SetChannel

; 583  : 			flightCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _flightCol$[ebp], edx
$LN16@SetChannel:

; 584  : 	if (toPackage)

	cmp	DWORD PTR _toPackage$[ebp], 0
	je	SHORT $LN14@SetChannel

; 585  : 		if (sscanf(toPackage,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _toPackage$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN14@SetChannel

; 586  : 			toPackageCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _toPackageCol$[ebp], edx
$LN14@SetChannel:

; 587  : 	if (ToFromPackage)

	cmp	DWORD PTR _ToFromPackage$[ebp], 0
	je	SHORT $LN12@SetChannel

; 588  : 		if (sscanf(ToFromPackage,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _ToFromPackage$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN12@SetChannel

; 589  : 			ToFromPackageCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ToFromPackageCol$[ebp], edx
$LN12@SetChannel:

; 590  : 	if (Team)

	cmp	DWORD PTR _Team$[ebp], 0
	je	SHORT $LN10@SetChannel

; 591  : 		if (sscanf(Team,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _Team$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN10@SetChannel

; 592  : 			TeamCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _TeamCol$[ebp], edx
$LN10@SetChannel:

; 593  : 	if (Proximity)

	cmp	DWORD PTR _Proximity$[ebp], 0
	je	SHORT $LN8@SetChannel

; 594  : 		if (sscanf(Proximity,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _Proximity$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN8@SetChannel

; 595  : 			ProximityCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ProximityCol$[ebp], edx
$LN8@SetChannel:

; 596  : 	if (World)

	cmp	DWORD PTR _World$[ebp], 0
	je	SHORT $LN6@SetChannel

; 597  : 		if (sscanf(World,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _World$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN6@SetChannel

; 598  : 			WorldCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _WorldCol$[ebp], edx
$LN6@SetChannel:

; 599  : 	if (Tower)

	cmp	DWORD PTR _Tower$[ebp], 0
	je	SHORT $LN4@SetChannel

; 600  : 		if (sscanf(Tower,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _Tower$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN4@SetChannel

; 601  : 			TowerCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _TowerCol$[ebp], edx
$LN4@SetChannel:

; 602  : 	if (Standard)

	cmp	DWORD PTR _Standard$[ebp], 0
	je	SHORT $LN2@SetChannel

; 603  : 		if (sscanf(Standard,"%x",&temp) == 1)

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, DWORD PTR _Standard$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN2@SetChannel

; 604  : 			StandardCol = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _StandardCol$[ebp], edx
$LN2@SetChannel:

; 605  : 
; 606  : 	SetChannelColours(	flightCol,toPackageCol,ToFromPackageCol,
; 607  : 						TeamCol,ProximityCol,WorldCol,
; 608  : 						TowerCol,StandardCol);

	mov	eax, DWORD PTR _StandardCol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TowerCol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _WorldCol$[ebp]
	push	edx
	mov	eax, DWORD PTR _ProximityCol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TeamCol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ToFromPackageCol$[ebp]
	push	edx
	mov	eax, DWORD PTR _toPackageCol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flightCol$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetChannelColours@RadioSubTitle@@QAEXKKKKKKKK@Z ; RadioSubTitle::SetChannelColours

; 609  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?SetChannelColours@RadioSubTitle@@QAEXPAD0000000@Z ENDP	; RadioSubTitle::SetChannelColours
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flight$ = 8						; size = 4
_toPackage$ = 12					; size = 4
_ToFromPackage$ = 16					; size = 4
_Team$ = 20						; size = 4
_Proximity$ = 24					; size = 4
_World$ = 28						; size = 4
_Tower$ = 32						; size = 4
_Standard$ = 36						; size = 4
?SetChannelColours@RadioSubTitle@@QAEXKKKKKKKK@Z PROC	; RadioSubTitle::SetChannelColours
; _this$ = ecx

; 550  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 551  : 	if (flight != 0)		colour_Flight		= flight;

	cmp	DWORD PTR _flight$[ebp], 0
	je	SHORT $LN8@SetChannel
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flight$[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN8@SetChannel:

; 552  : 	if (toPackage != 0)		colour_ToPackage	= toPackage;

	cmp	DWORD PTR _toPackage$[ebp], 0
	je	SHORT $LN7@SetChannel
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _toPackage$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN7@SetChannel:

; 553  : 	if (ToFromPackage != 0)	colour_ToFromPackage= ToFromPackage;

	cmp	DWORD PTR _ToFromPackage$[ebp], 0
	je	SHORT $LN6@SetChannel
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ToFromPackage$[ebp]
	mov	DWORD PTR [ecx+36], edx
$LN6@SetChannel:

; 554  : 	// 'Team' is the guard channel
; 555  : 	if (Team != 0)			colour_Team			= Team;

	cmp	DWORD PTR _Team$[ebp], 0
	je	SHORT $LN5@SetChannel
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Team$[ebp]
	mov	DWORD PTR [eax+40], ecx
$LN5@SetChannel:

; 556  : 	if (Proximity != 0)		colour_Proximity	= Proximity;

	cmp	DWORD PTR _Proximity$[ebp], 0
	je	SHORT $LN4@SetChannel
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Proximity$[ebp]
	mov	DWORD PTR [edx+44], eax
$LN4@SetChannel:

; 557  : 	if (World != 0)			colour_World		= World;

	cmp	DWORD PTR _World$[ebp], 0
	je	SHORT $LN3@SetChannel
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _World$[ebp]
	mov	DWORD PTR [ecx+48], edx
$LN3@SetChannel:

; 558  : 	if (Tower != 0)			colour_Tower		= Tower;

	cmp	DWORD PTR _Tower$[ebp], 0
	je	SHORT $LN2@SetChannel
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Tower$[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN2@SetChannel:

; 559  : 	if (Standard != 0)		colour_Standard		= Standard;

	cmp	DWORD PTR _Standard$[ebp], 0
	je	SHORT $LN9@SetChannel
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Standard$[ebp]
	mov	DWORD PTR [edx+56], eax
$LN9@SetChannel:

; 560  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?SetChannelColours@RadioSubTitle@@QAEXKKKKKKKK@Z ENDP	; RadioSubTitle::SetChannelColours
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_MessageNum$ = 8					; size = 4
_TTL$ = 12						; size = 4
?SetTTLAndMessageNum@RadioSubTitle@@QAEXHK@Z PROC	; RadioSubTitle::SetTTLAndMessageNum
; _this$ = ecx

; 181  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 	if (MessageNum != 0)

	cmp	DWORD PTR _MessageNum$[ebp], 0
	je	SHORT $LN4@SetTTLAndM

; 183  : 		MaxMessageNum = MessageNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _MessageNum$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 184  : 	else

	jmp	SHORT $LN3@SetTTLAndM
$LN4@SetTTLAndM:

; 185  : 		MaxMessageNum = 20;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 20			; 00000014H
$LN3@SetTTLAndM:

; 186  : 
; 187  : 	if (TTL != 0)

	cmp	DWORD PTR _TTL$[ebp], 0
	je	SHORT $LN2@SetTTLAndM

; 188  : 		messageTTL = TTL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _TTL$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 189  : 	else

	jmp	SHORT $LN5@SetTTLAndM
$LN2@SetTTLAndM:

; 190  : 		messageTTL = MESSAGE_TTL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 20000		; 00004e20H
$LN5@SetTTLAndM:

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTTLAndMessageNum@RadioSubTitle@@QAEXHK@Z ENDP	; RadioSubTitle::SetTTLAndMessageNum
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
_rchunk$ = -8						; size = 4
_this$ = -4						; size = 4
_theTalker$ = 8						; size = 4
_theFrag$ = 12						; size = 4
?AddToMessage@RadioSubTitle@@QAEXHH@Z PROC		; RadioSubTitle::AddToMessage
; _this$ = ecx

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 273  : 	EnterCriticalSection(&cs_radiosubtitle);	// locking out the graphicsthread..

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__EnterCriticalSection@4

; 274  : 
; 275  : 	char* rchunk = GetRadioChunk(theTalker, theFrag);

	mov	eax, DWORD PTR _theFrag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theTalker$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRadioChunk@RadioSubTitle@@AAEPADHH@Z ; RadioSubTitle::GetRadioChunk
	mov	DWORD PTR _rchunk$[ebp], eax

; 276  : 	if ((rchunk)&&(currentlyEditedNode))

	cmp	DWORD PTR _rchunk$[ebp], 0
	je	SHORT $LN1@AddToMessa
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN1@AddToMessa

; 277  : 	{
; 278  : 		AppendToString(&currentlyEditedNode->theSpokenLine," ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AppendToString@RadioSubTitle@@AAEXPAPADPBD@Z ; RadioSubTitle::AppendToString

; 279  : 		AppendToString(&currentlyEditedNode->theSpokenLine,rchunk);

	mov	edx, DWORD PTR _rchunk$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AppendToString@RadioSubTitle@@AAEXPAPADPBD@Z ; RadioSubTitle::AppendToString
$LN1@AddToMessa:

; 280  : 	}
; 281  : 
; 282  : 	LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 283  : 
; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddToMessage@RadioSubTitle@@QAEXHH@Z ENDP		; RadioSubTitle::AddToMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 4
_rchunk$ = -32						; size = 4
tv73 = -28						; size = 4
$T3 = -24						; size = 4
_index$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_theTalker$ = 8						; size = 4
_theFrag$ = 12						; size = 4
_thePlayTime$ = 16					; size = 4
_theFilter$ = 20					; size = 1
?NewMessage@RadioSubTitle@@QAEXHHKD@Z PROC		; RadioSubTitle::NewMessage
; _this$ = ecx

; 215  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NewMessage@RadioSubTitle@@QAEXHHKD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 	EnterCriticalSection(&cs_radiosubtitle);	// locking out the graphicsthread..

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__EnterCriticalSection@4

; 217  : 
; 218  : 	currentlyEditedNode = new SubTitleNode();

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN9@NewMessage
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0SubTitleNode@RadioSubTitle@@QAE@XZ	; RadioSubTitle::SubTitleNode::SubTitleNode
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN10@NewMessage
$LN9@NewMessage:
	mov	DWORD PTR tv73[ebp], 0
$LN10@NewMessage:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+4], edx

; 219  : 	if (!currentlyEditedNode)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@NewMessage

; 220  : 	{
; 221  : #pragma warning(disable:4127)
; 222  : 		ShiAssert(false);
; 223  : #pragma warning(default:4127)
; 224  : 		LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 225  : 		return;

	jmp	$LN7@NewMessage
$LN6@NewMessage:

; 226  : 	}
; 227  : 
; 228  : 	LinkedListCount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 229  : 	currentlyEditedNode->messageStartTime = thePlayTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _thePlayTime$[ebp]
	mov	DWORD PTR [edx+16], eax

; 230  : 	currentlyEditedNode->associatedChannel = FindChannelColour(theFilter);

	movzx	ecx, BYTE PTR _theFilter$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindChannelColour@RadioSubTitle@@AAEKD@Z ; RadioSubTitle::FindChannelColour
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+20], eax

; 231  : 	
; 232  : #ifndef DISPLAY_CHANNEL_NAME
; 233  : 	char* rchunk = GetRadioChunk(theTalker, theFrag);

	mov	edx, DWORD PTR _theFrag$[ebp]
	push	edx
	mov	eax, DWORD PTR _theTalker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRadioChunk@RadioSubTitle@@AAEPADHH@Z ; RadioSubTitle::GetRadioChunk
	mov	DWORD PTR _rchunk$[ebp], eax

; 234  : 	if (rchunk)

	cmp	DWORD PTR _rchunk$[ebp], 0
	je	SHORT $LN5@NewMessage

; 235  : 	{
; 236  : 		OverWriteString(&currentlyEditedNode->theSpokenLine, rchunk);

	mov	ecx, DWORD PTR _rchunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OverWriteString@RadioSubTitle@@AAEXPAPADPBD@Z ; RadioSubTitle::OverWriteString
$LN5@NewMessage:

; 237  : 	}
; 238  : #else
; 239  : 	char* chan = FindChannelName(theFilter);
; 240  : 	char* rchunk = GetRadioChunk(theTalker, theFrag);
; 241  : 	if (rchunk)
; 242  : 	{
; 243  : 		char* sum = (char*)malloc(strlen(chan)+strlen(rchunk)+1);
; 244  : 		if (sum)
; 245  : 		{
; 246  : 			strcpy(sum,chan);
; 247  : 			strcat(sum,rchunk);
; 248  : 
; 249  : 			OverWriteString(&currentlyEditedNode->theSpokenLine, sum);
; 250  : 			free(sum);
; 251  : 		}
; 252  : 	}
; 253  : #endif
; 254  : 
; 255  : 	SubTitleNode* index = (SubTitleNode*)theRadioChatterList->GetHead();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _index$[ebp], eax
$LN4@NewMessage:

; 256  : 	while ((index)&&(index->messageStartTime < thePlayTime))

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN3@NewMessage
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _thePlayTime$[ebp]
	jae	SHORT $LN3@NewMessage

; 257  : 	{
; 258  : 		index = (SubTitleNode*)index->GetSucc();

	mov	ecx, DWORD PTR _index$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _index$[ebp], eax

; 259  : 	}

	jmp	SHORT $LN4@NewMessage
$LN3@NewMessage:

; 260  : 	if (index)

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN2@NewMessage

; 261  : 		currentlyEditedNode->InsertAfter(index);

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?InsertAfter@ANode@@QAEXPAV1@@Z		; ANode::InsertAfter

; 262  : 	else

	jmp	SHORT $LN1@NewMessage
$LN2@NewMessage:

; 263  : 		theRadioChatterList->AddTail(currentlyEditedNode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?AddTail@AList@@QAEXPAVANode@@@Z	; AList::AddTail
$LN1@NewMessage:

; 264  : 
; 265  : 	LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN7@NewMessage:

; 266  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NewMessage@RadioSubTitle@@QAEXHHKD@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?NewMessage@RadioSubTitle@@QAEXHHKD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NewMessage@RadioSubTitle@@QAEXHHKD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NewMessage@RadioSubTitle@@QAEXHHKD@Z ENDP		; RadioSubTitle::NewMessage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_node$ = -8						; size = 4
_this$ = -4						; size = 4
?ResetAll@RadioSubTitle@@QAEXXZ PROC			; RadioSubTitle::ResetAll
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	SubTitleNode* node = 0;

	mov	DWORD PTR _node$[ebp], 0
$LN3@ResetAll:

; 199  : 	do
; 200  : 	{
; 201  : 		delete(theRadioChatterList->RemHead());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 202  : 		node = (SubTitleNode*)theRadioChatterList->GetHead();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _node$[ebp], eax

; 203  : 	} while (node);

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN3@ResetAll

; 204  : 	LinkedListCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetAll@RadioSubTitle@@QAEXXZ ENDP			; RadioSubTitle::ResetAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
$T1 = -48						; size = 16
tv83 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_nodeToDelete$4 = -20					; size = 4
_theMessages$ = -16					; size = 4
_i$ = -12						; size = 4
_this$ = -8						; size = 4
_node$ = -4						; size = 4
_theTime$ = 8						; size = 4
?GetTimeSortedMessages@RadioSubTitle@@QAEPAPAUColouredSubTitle@@K@Z PROC ; RadioSubTitle::GetTimeSortedMessages
; _this$ = ecx

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 342  : 
; 343  : 	EnterCriticalSection(&cs_radiosubtitle);	// locking out the soundthread

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__EnterCriticalSection@4

; 344  : 
; 345  : 	// Get the oldest message in the list..
; 346  : 	SubTitleNode* node = (SubTitleNode*)theRadioChatterList->GetHead();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _node$[ebp], eax

; 347  : 	if (!node)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN14@GetTimeSor

; 348  : 	{
; 349  : 		LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 350  : 		return 0;	// no messages to play..

	xor	eax, eax
	jmp	$LN17@GetTimeSor
$LN14@GetTimeSor:

; 351  : 	}
; 352  : 	
; 353  : 	// walking back in the list
; 354  : 	// we are not going to draw messages that have already outlived their TTL..
; 355  : 	// if they werent displayed by now, well, tough luck (and I betcha your FPS suck hairy donkey balls too)
; 356  : 	// these messages are going to be removed actually..
; 357  : 	// this is done for every message (node) till I find one that is still to be drawn - and as the list is
; 358  : 	// sorted by time, all following ones have also to be drawn so I break from the loop
; 359  : 	while ((node)&&(node->messageStartTime  + messageTTL < theTime))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN13@GetTimeSor
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR _theTime$[ebp]
	jae	SHORT $LN13@GetTimeSor

; 360  : 	{
; 361  : 		SubTitleNode* nodeToDelete = (SubTitleNode*)theRadioChatterList->RemHead();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR _nodeToDelete$4[ebp], eax

; 362  : 		if (nodeToDelete)

	cmp	DWORD PTR _nodeToDelete$4[ebp], 0
	je	SHORT $LN12@GetTimeSor

; 363  : 		{
; 364  : 			delete(nodeToDelete);

	mov	edx, DWORD PTR _nodeToDelete$4[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN18@GetTimeSor
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSubTitleNode@RadioSubTitle@@QAEPAXI@Z
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN19@GetTimeSor
$LN18@GetTimeSor:
	mov	DWORD PTR tv83[ebp], 0
$LN19@GetTimeSor:

; 365  : 			LinkedListCount--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN12@GetTimeSor:

; 366  : 		}
; 367  : 		node = (SubTitleNode*)theRadioChatterList->GetHead();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _node$[ebp], eax

; 368  : 	}

	jmp	SHORT $LN14@GetTimeSor
$LN13@GetTimeSor:

; 369  : 
; 370  : 	if (!node)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN11@GetTimeSor

; 371  : 	{
; 372  : 		LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 373  : 		 return 0;	// no messages to play.. (all messages were outdated)

	xor	eax, eax
	jmp	$LN17@GetTimeSor
$LN11@GetTimeSor:

; 374  : 	}
; 375  : 
; 376  : 	// the calling routine has to delete that array..
; 377  : 	ColouredSubTitle** theMessages = (ColouredSubTitle**)calloc(sizeof(ColouredSubTitle*),LinkedListCount+1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	push	eax
	push	4
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _theMessages$[ebp], eax

; 378  : 	if (!theMessages)

	cmp	DWORD PTR _theMessages$[ebp], 0
	jne	SHORT $LN10@GetTimeSor

; 379  : 	{
; 380  : 		LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 381  : 		return 0;

	xor	eax, eax
	jmp	$LN17@GetTimeSor
$LN10@GetTimeSor:

; 382  : 	}
; 383  : 
; 384  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN9@GetTimeSor:

; 385  : 
; 386  : 	while (node)

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN8@GetTimeSor

; 387  : 	{
; 388  : 		// also do NOT draw are messages (nodes) that are scheduled to be played in da future
; 389  : 		// since the list is sorted I can actually break once this condition is met
; 390  : 		if (node->messageStartTime > theTime)

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _theTime$[ebp]
	jbe	SHORT $LN7@GetTimeSor

; 391  : 		{
; 392  : 			break;

	jmp	$LN8@GetTimeSor
$LN7@GetTimeSor:

; 393  : 		}
; 394  : 		if ((node->messageStartTime < theTime)&&(theTime < node->messageStartTime + messageTTL))

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _theTime$[ebp]
	jae	$LN6@GetTimeSor
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	DWORD PTR _theTime$[ebp], eax
	jae	$LN6@GetTimeSor

; 395  : 		{
; 396  : #if 0	// Retro 23May2004
; 397  : 			theMessages[i] = (ColouredSubTitle*)malloc(sizeof(ColouredSubTitle));
; 398  : 			if (theMessages[i])
; 399  : 			{
; 400  : 				if (node->theSpokenLine)	// Retro 28Feb2004
; 401  : 				{
; 402  : 					theMessages[i]->theString = (char*)malloc(strlen(node->theSpokenLine)+1);
; 403  : 					strcpy(theMessages[i]->theString,node->theSpokenLine);
; 404  : 					theMessages[i]->theColour = node->associatedChannel;
; 405  : 					i++;
; 406  : 				}
; 407  : 				else
; 408  : 				{
; 409  : #pragma warning(disable:4127)
; 410  : 					ShiAssert(false);
; 411  : #pragma warning(default:4127)
; 412  : 				}
; 413  : 			}
; 414  : #else	// Retro 23May2004
; 415  : 			if (node->theSpokenLine)	// Retro 28Feb2004

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN6@GetTimeSor

; 416  : 			{
; 417  : 				theMessages[i] = (ColouredSubTitle*)malloc(sizeof(ColouredSubTitle));

	push	8
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _theMessages$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 418  : 				if (theMessages[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _theMessages$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN4@GetTimeSor

; 419  : 				{
; 420  : 					theMessages[i]->theString = (char*)malloc(strlen(node->theSpokenLine)+1);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _theMessages$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx], eax

; 421  : 					strcpy(theMessages[i]->theString,node->theSpokenLine);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _theMessages$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 422  : 					theMessages[i]->theColour = node->associatedChannel;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _theMessages$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+4], eax

; 423  : 					i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 424  : 				}
; 425  : 				else

	jmp	SHORT $LN6@GetTimeSor
$LN4@GetTimeSor:

; 426  : 				{
; 427  : 					throw _com_error(E_OUTOFMEMORY);

	push	0
	push	0
	push	-2147024882				; 8007000eH
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z	; _com_error::_com_error
	push	OFFSET __TI1?AV_com_error@@
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	__CxxThrowException@8
$LN6@GetTimeSor:

; 428  : 				}
; 429  : 			}
; 430  : 			else
; 431  : 			{
; 432  : #pragma warning(disable:4127)
; 433  : 				ShiAssert(false);
; 434  : #pragma warning(default:4127)
; 435  : 			}
; 436  : #endif	// Retro 23May2004
; 437  : 		}
; 438  : 		node = (SubTitleNode*)node->GetSucc();

	mov	ecx, DWORD PTR _node$[ebp]
	call	?GetSucc@ANode@@QAEPAXXZ		; ANode::GetSucc
	mov	DWORD PTR _node$[ebp], eax

; 439  : 
; 440  : 		// theres a (user-set) limit on how many messages my be displayed, so we break out here
; 441  : 		// (even if there may be messages that still should be played)
; 442  : 		if (i > MaxMessageNum)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jle	SHORT $LN1@GetTimeSor

; 443  : 			break;

	jmp	SHORT $LN8@GetTimeSor
$LN1@GetTimeSor:

; 444  : 	}

	jmp	$LN9@GetTimeSor
$LN8@GetTimeSor:

; 445  : 
; 446  : 	LeaveCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 447  : 
; 448  : 	return theMessages;

	mov	eax, DWORD PTR _theMessages$[ebp]
$LN17@GetTimeSor:

; 449  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTimeSortedMessages@RadioSubTitle@@QAEPAPAUColouredSubTitle@@K@Z ENDP ; RadioSubTitle::GetTimeSortedMessages
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
tv92 = -40						; size = 4
$T1 = -36						; size = 4
tv77 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
_node$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??1RadioSubTitle@@QAE@XZ PROC				; RadioSubTitle::~RadioSubTitle
; _this$ = ecx

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 141  : 
; 142  : 	SubTitleNode* node = 0;

	mov	DWORD PTR _node$[ebp], 0
$LN6@RadioSubTi:

; 143  : 	do
; 144  : 	{
; 145  : 		delete(theRadioChatterList->RemHead());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?RemHead@AList@@QAEPAXXZ		; AList::RemHead
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 146  : 		node = (SubTitleNode*)theRadioChatterList->GetHead();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetHead@AList@@QAEPAXXZ		; AList::GetHead
	mov	DWORD PTR _node$[ebp], eax

; 147  : 	} while (node);

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN6@RadioSubTi

; 148  : 
; 149  : 	delete(theRadioChatterList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN9@RadioSubTi
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GAList@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN10@RadioSubTi
$LN9@RadioSubTi:
	mov	DWORD PTR tv77[ebp], 0
$LN10@RadioSubTi:

; 150  : 	theRadioChatterList = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 151  : 
; 152  : #ifndef DYNAMIC_LINE_NUM	// Retro 11Jan2004
; 153  : 	for (i = 0; i < MAX_FRAG_NUM; i++)
; 154  : 	{
; 155  : 		if (theStrings[i])
; 156  : 		{
; 157  : 			delete(theStrings[i]);
; 158  : 		}
; 159  : 	}
; 160  : #else	// DYNAMIC_LINE_NUM
; 161  : 	if (theStrings)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN3@RadioSubTi
$LN2@RadioSubTi:

; 162  : 	{
; 163  : 		while (theStrings[i])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN1@RadioSubTi

; 164  : 		{
; 165  : 			delete(theStrings[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN11@RadioSubTi
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GcsvLine@RadioSubTitle@@QAEPAXI@Z
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN12@RadioSubTi
$LN11@RadioSubTi:
	mov	DWORD PTR tv92[ebp], 0
$LN12@RadioSubTi:

; 166  : 			theStrings[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 167  : 			i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 168  : 		}

	jmp	SHORT $LN2@RadioSubTi
$LN1@RadioSubTi:

; 169  : 		free(theStrings);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_free
	add	esp, 4

; 170  : 		theStrings = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN3@RadioSubTi:

; 171  : 	}
; 172  : #endif	// DYNAMIC_LINE_NUM
; 173  : 
; 174  : 	DeleteCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1RadioSubTitle@@QAE@XZ ENDP				; RadioSubTitle::~RadioSubTitle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\otwdrive\radiosubtitle.cpp
_TEXT	SEGMENT
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
$T8 = -28						; size = 4
tv78 = -24						; size = 4
$T9 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_MaximumMessageNum$ = 8					; size = 4
_TTL$ = 12						; size = 4
??0RadioSubTitle@@QAE@HK@Z PROC				; RadioSubTitle::RadioSubTitle
; _this$ = ecx

; 74   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RadioSubTitle@@QAE@HK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 
; 76   : 	if (MaximumMessageNum != 0)

	cmp	DWORD PTR _MaximumMessageNum$[ebp], 0
	je	SHORT $LN8@RadioSubTi

; 77   : 		MaxMessageNum = MaximumMessageNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _MaximumMessageNum$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 78   : 	else

	jmp	SHORT $LN7@RadioSubTi
$LN8@RadioSubTi:

; 79   : 		MaxMessageNum = 20;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 20			; 00000014H
$LN7@RadioSubTi:

; 80   : 
; 81   : 	if (TTL != 0)

	cmp	DWORD PTR _TTL$[ebp], 0
	je	SHORT $LN6@RadioSubTi

; 82   : 		messageTTL = TTL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _TTL$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 83   : 	else

	jmp	SHORT $LN5@RadioSubTi
$LN6@RadioSubTi:

; 84   : 		messageTTL = MESSAGE_TTL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 20000		; 00004e20H
$LN5@RadioSubTi:

; 85   : 
; 86   : 	theRadioChatterList = new AList();

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN11@RadioSubTi
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0AList@@QAE@XZ			; AList::AList
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN12@RadioSubTi
$LN11@RadioSubTi:
	mov	DWORD PTR tv78[ebp], 0
$LN12@RadioSubTi:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [ecx], edx

; 87   : 	currentlyEditedNode = (SubTitleNode*)0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 88   : 	LinkedListCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 89   : 
; 90   : #ifndef DYNAMIC_LINE_NUM	// Retro 11Jan2004
; 91   : 	for (int i = 0; i < MAX_FRAG_NUM; i++)
; 92   : 	{
; 93   : 		theStrings[i] = 0;
; 94   : 	}
; 95   : #endif	// DYNAMIC_LINE_NUM
; 96   : 
; 97   : 	colour_Flight		= TOFROM_FLIGHT_COLOUR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], -16711936		; ff00ff00H

; 98   : 	colour_ToPackage	= TO_PACKAGE_COLOUR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], -16776961		; ff0000ffH

; 99   : 	colour_ToFromPackage= TOFROM_PACKAGE_COLOUR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], -16711681		; ff00ffffH

; 100  : 	colour_Team			= TO_TEAM_COLOUR;		// this is the guard channel

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], -65536		; ffff0000H

; 101  : 	colour_Proximity	= IN_PROXIMITY_COLOUR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], -256		; ffffff00H

; 102  : 	colour_World		= TO_WORLD_COLOUR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], -8355712		; ff808080H

; 103  : 	colour_Tower		= TOFROM_TOWER_COLOUR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], -16777216		; ff000000H

; 104  : 	colour_Standard		= STANDARD_COLOUR;	// only used in default cases which (shouldnt happen actually)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], -1

; 105  : 
; 106  : #ifdef DYNAMIC_LINE_NUM	// Retro 11Jan2004
; 107  : 	FragCount = CountLinesInFile(THE_INPUT_FILE_NAME);

	push	OFFSET ??_C@_0BD@FOGFACPK@F4Talk95v1?90?90?4csv?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CountLinesInFile@RadioSubTitle@@AAEHPBD@Z ; RadioSubTitle::CountLinesInFile
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 108  : 	if (FragCount == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN4@RadioSubTi

; 109  : 	{
; 110  : 		throw Init_Error("No frag lines in subtitles input file");

	push	OFFSET ??_C@_0CG@DPMGOLOO@No?5frag?5lines?5in?5subtitles?5input@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0Init_Error@RadioSubTitle@@QAE@PBD@Z	; RadioSubTitle::Init_Error::Init_Error
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T7[ebp], eax
	push	OFFSET __TI1?AUInit_Error@RadioSubTitle@@
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	__CxxThrowException@8

; 111  : 	}
; 112  : 	else

	jmp	SHORT $LN3@RadioSubTi
$LN4@RadioSubTi:

; 113  : 	{
; 114  : //		theStrings = (csvLine**)calloc(sizeof(csvLine*),FragCount+100); // Retro 11Jan2004 - accounting for count-errors :p
; 115  : 		theStrings = (csvLine**)calloc(sizeof(csvLine*),FragCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	4
	call	_calloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 116  : 		if (theStrings == (csvLine**)0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN3@RadioSubTi

; 117  : 		{
; 118  : 			throw Init_Error("Could not create strings");

	push	OFFSET ??_C@_0BJ@GFKKJABC@Could?5not?5create?5strings?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0Init_Error@RadioSubTitle@@QAE@PBD@Z	; RadioSubTitle::Init_Error::Init_Error
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T6[ebp], eax
	push	OFFSET __TI1?AUInit_Error@RadioSubTitle@@
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN3@RadioSubTi:

; 119  : 		}
; 120  : 	}
; 121  : #endif	// DYNAMIC_LINE_NUM
; 122  : 
; 123  : 	if (!ReadNewFile(THE_INPUT_FILE_NAME))

	push	OFFSET ??_C@_0BD@FOGFACPK@F4Talk95v1?90?90?4csv?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadNewFile@RadioSubTitle@@AAE_NPBD@Z	; RadioSubTitle::ReadNewFile
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@RadioSubTi

; 124  : 	{
; 125  : 		throw Init_Error("Error reading the subtitles input file");

	push	OFFSET ??_C@_0CH@PANBBNOP@Error?5reading?5the?5subtitles?5inpu@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Init_Error@RadioSubTitle@@QAE@PBD@Z	; RadioSubTitle::Init_Error::Init_Error
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T5[ebp], eax
	push	OFFSET __TI1?AUInit_Error@RadioSubTitle@@
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN1@RadioSubTi:

; 126  : 	}
; 127  : 
; 128  : #ifdef WRITE_BACK_STRING_FILE
; 129  : 	WriteOut();
; 130  : #endif
; 131  : 
; 132  : 	InitializeCriticalSection(&cs_radiosubtitle);

	push	OFFSET ?cs_radiosubtitle@RadioSubTitle@@2U_RTL_CRITICAL_SECTION@@A ; RadioSubTitle::cs_radiosubtitle
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 133  : }

	mov	eax, DWORD PTR _this$[ebp]
$LN10@RadioSubTi:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0RadioSubTitle@@QAE@HK@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0RadioSubTitle@@QAE@HK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RadioSubTitle@@QAE@HK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RadioSubTitle@@QAE@HK@Z ENDP				; RadioSubTitle::RadioSubTitle
; Function compile flags: /Odtp
;	COMDAT ??_GAList@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAList@@QAEPAXI@Z PROC				; AList::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AList@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAList@@QAEPAXI@Z ENDP				; AList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1AList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AList@@QAE@XZ PROC					; AList::~AList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AList@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ANode@@QAE@XZ			; ANode::~ANode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AList@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ANode@@QAE@XZ			; ANode::~ANode
__ehhandler$??1AList@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AList@@QAE@XZ ENDP					; AList::~AList
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\alist.h
;	COMDAT ?CompareWith@ANode@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?CompareWith@ANode@@UAEHPAV1@@Z PROC			; ANode::CompareWith, COMDAT
; _this$ = ecx

; 13   : 	virtual int CompareWith(ANode *n) {return 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?CompareWith@ANode@@UAEHPAV1@@Z ENDP			; ANode::CompareWith
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
