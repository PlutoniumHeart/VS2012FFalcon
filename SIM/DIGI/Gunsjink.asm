; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\Gunsjink.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	?LastUpdateTime@VuEntity@@QBEKXZ		; VuEntity::LastUpdateTime
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?IsFiring@SimBaseClass@@QBEHXZ			; SimBaseClass::IsFiring
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?GunsJink@DigitalBrain@@IAEXXZ			; DigitalBrain::GunsJink
PUBLIC	?GunsJinkCheck@DigitalBrain@@IAEXXZ		; DigitalBrain::GunsJinkCheck
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?MaxRoll@AirframeClass@@QAEMXZ			; AirframeClass::MaxRoll
PUBLIC	?MaxGs@AirframeClass@@QAEMXZ			; AirframeClass::MaxGs
PUBLIC	?TStance@TeamClass@@QAEHE@Z			; TeamClass::TStance
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa34
PUBLIC	__real@3d8efa34
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3e685694
PUBLIC	__real@3e860a91
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3f9c61a9
PUBLIC	__real@3fc90fd9
PUBLIC	__real@40000000
PUBLIC	__real@40490fd9
PUBLIC	__real@40800000
PUBLIC	__real@40c90fd9
PUBLIC	__real@42652ee1
PUBLIC	__real@433e0000
PUBLIC	__real@457a0000
PUBLIC	__real@458ca000
PUBLIC	__real@45bb8000
PUBLIC	__real@bdb2b8c1
PUBLIC	__real@be32b8c1
PUBLIC	__real@be685694
PUBLIC	__real@be860a91
PUBLIC	__real@bf490fd9
PUBLIC	__real@c0000000
PUBLIC	__real@c0490fd9
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_fabs:PROC
EXTRN	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z:PROC	; DigitalBrain::AddMode
EXTRN	?MachHold@DigitalBrain@@IAEHMMH@Z:PROC		; DigitalBrain::MachHold
EXTRN	?SelectGroundWeapon@DigitalBrain@@IAEXXZ:PROC	; DigitalBrain::SelectGroundWeapon
EXTRN	?SetPstick@DigitalBrain@@IAEMMMH@Z:PROC		; DigitalBrain::SetPstick
EXTRN	?SetRstick@DigitalBrain@@IAEMM@Z:PROC		; DigitalBrain::SetRstick
EXTRN	?SetMaxRoll@DigitalBrain@@IAEXM@Z:PROC		; DigitalBrain::SetMaxRoll
EXTRN	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z:PROC	; DigitalBrain::SetMaxRollDelta
EXTRN	?ResetMaxRoll@DigitalBrain@@IAEXXZ:PROC		; DigitalBrain::ResetMaxRoll
EXTRN	?AGJettison@SMSClass@@QAEXXZ:PROC		; SMSClass::AGJettison
EXTRN	?vuxGameTime@@3KA:DWORD				; vuxGameTime
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibMajorFrameRate@@3MA:DWORD		; SimLibMajorFrameRate
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?SimLibLastMajorFrameTime@@3MA:DWORD		; SimLibLastMajorFrameTime
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0490fd9
CONST	SEGMENT
__real@c0490fd9 DD 0c0490fd9r			; -3.14159
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf490fd9
CONST	SEGMENT
__real@bf490fd9 DD 0bf490fd9r			; -0.785398
CONST	ENDS
;	COMDAT __real@be860a91
CONST	SEGMENT
__real@be860a91 DD 0be860a91r			; -0.261799
CONST	ENDS
;	COMDAT __real@be685694
CONST	SEGMENT
__real@be685694 DD 0be685694r			; -0.226893
CONST	ENDS
;	COMDAT __real@be32b8c1
CONST	SEGMENT
__real@be32b8c1 DD 0be32b8c1r			; -0.174533
CONST	ENDS
;	COMDAT __real@bdb2b8c1
CONST	SEGMENT
__real@bdb2b8c1 DD 0bdb2b8c1r			; -0.0872665
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@458ca000
CONST	SEGMENT
__real@458ca000 DD 0458ca000r			; 4500
CONST	ENDS
;	COMDAT __real@457a0000
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@433e0000
CONST	SEGMENT
__real@433e0000 DD 0433e0000r			; 190
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3f9c61a9
CONST	SEGMENT
__real@3f9c61a9 DD 03f9c61a9r			; 1.22173
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e860a91
CONST	SEGMENT
__real@3e860a91 DD 03e860a91r			; 0.261799
CONST	ENDS
;	COMDAT __real@3e685694
CONST	SEGMENT
__real@3e685694 DD 03e685694r			; 0.226893
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3d8efa34
CONST	SEGMENT
__real@3d8efa34 DD 03d8efa34r			; 0.0698132
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?TStance@TeamClass@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_team$ = 8						; size = 1
?TStance@TeamClass@@QAEHE@Z PROC			; TeamClass::TStance, COMDAT
; _this$ = ecx

; 317  : 	int TStance(Team team)						{ return stance[team]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _team$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [ecx+eax*2+580]
	mov	esp, ebp
	pop	ebp
	ret	4
?TStance@TeamClass@@QAEHE@Z ENDP			; TeamClass::TStance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxGs@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxGs@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxGs, COMDAT
; _this$ = ecx

; 1174 : 	float MaxGs (void) {return maxGs;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxGs@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxGs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxRoll@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?MaxRoll@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxRoll, COMDAT
; _this$ = ecx

; 1170 : 	float MaxRoll (void) {return maxRoll * RTD;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxRoll@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\gunsjink.cpp
_TEXT	SEGMENT
_lastUpdate$ = -40					; size = 4
tv140 = -36						; size = 4
_tgt_time$ = -32					; size = 4
_att_time$ = -28					; size = 4
_z$ = -24						; size = 4
_timeDelta$ = -20					; size = 4
_obj$ = -16						; size = 4
_this$ = -12						; size = 4
_twoSeconds$ = -8					; size = 4
_localData$ = -4					; size = 4
?GunsJinkCheck@DigitalBrain@@IAEXXZ PROC		; DigitalBrain::GunsJinkCheck
; _this$ = ecx

; 16   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 17   : float tgt_time=0.0F,att_time=0.0F,z=0.0F, timeDelta=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgt_time$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _att_time$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _z$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _timeDelta$[ebp], xmm0

; 18   : int twoSeconds=0;

	mov	DWORD PTR _twoSeconds$[ebp], 0

; 19   : unsigned long lastUpdate=0;

	mov	DWORD PTR _lastUpdate$[ebp], 0

; 20   : SimObjectType* obj = targetPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _obj$[ebp], ecx

; 21   : SimObjectLocalData* localData=NULL;

	mov	DWORD PTR _localData$[ebp], 0

; 22   : 
; 23   :    /*-----------------------------------------------*/
; 24   :    /* Entry conditions-                             */
; 25   :    /*                                               */
; 26   :    /* 1. Target range <= INIT_GUN_VEL feet.         */
; 27   :    /* 2. Target time to fire < ownship time to fire */
; 28   :    /* 3. Predicted bullet fire <= 2 seconds.        */
; 29   :    /*-----------------------------------------------*/
; 30   : //me123 lets check is closure is resonable too before goin into jink mode
; 31   :    if (curMode != GunsJinkMode)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 3
	je	$LN1@GunsJinkCh

; 32   :    {
; 33   : 		if ( obj == NULL )

	cmp	DWORD PTR _obj$[ebp], 0
	jne	SHORT $LN19@GunsJinkCh

; 34   : 	  	return;

	jmp	$LN21@GunsJinkCh
$LN19@GunsJinkCh:

; 35   : 
; 36   : 		if ( obj->BaseData()->IsSim() &&
; 37   : 			(((SimBaseClass*)obj->BaseData())->IsFiring() ||
; 38   : 			TeamInfo[self->GetTeam()]->TStance(obj->BaseData()->GetTeam()) == War))

	mov	ecx, DWORD PTR _obj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	$LN1@GunsJinkCh
	mov	ecx, DWORD PTR _obj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsFiring@SimBaseClass@@QBEHXZ		; SimBaseClass::IsFiring
	test	eax, eax
	jne	SHORT $LN17@GunsJinkCh
	mov	ecx, DWORD PTR _obj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv140[ebp], eax
	mov	eax, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?TStance@TeamClass@@QAEHE@Z		; TeamClass::TStance
	cmp	eax, 5
	jne	$LN1@GunsJinkCh
$LN17@GunsJinkCh:

; 39   : 		{
; 40   : 			localData = obj->localData;

	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _localData$[ebp], eax

; 41   : 
; 42   : 			if ((localData->range > 0.0f) && (localData->range < 6000.0f))//localData->rangedot > -240.0f * FTPSEC_TO_KNOTS )//me123 don't jink if he's got a high closure, he probaly woun't shoot a low Pk shot

	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN1@GunsJinkCh
	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@45bb8000
	comiss	xmm0, DWORD PTR [edx+44]
	jbe	$LN1@GunsJinkCh

; 43   : 			{
; 44   : 				if (localData->range < INIT_GUN_VEL  )

	mov	eax, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@458ca000
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	$LN1@GunsJinkCh

; 45   : 				{
; 46   : 				   /*-----------------------------------*/
; 47   : 				   /* predict time of possible gun fire */
; 48   : 				   /*-----------------------------------*/
; 49   : 				   twoSeconds = FALSE;

	mov	DWORD PTR _twoSeconds$[ebp], 0

; 50   : 				   jinkTime = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], -1

; 51   : 				   z = localData->range / INIT_GUN_VEL;

	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	divss	xmm0, DWORD PTR __real@458ca000
	movss	DWORD PTR _z$[ebp], xmm0

; 52   : 		
; 53   : 				   if ( localData->azFrom > -15.0F * DTR && localData->azFrom < (15.0F * DTR))//me123 status test. changed from 2.0 to 5.0 multible places here becourse we are not always in plane when gunning

	mov	eax, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [eax+20]
	comiss	xmm0, DWORD PTR __real@be860a91
	jbe	SHORT $LN14@GunsJinkCh
	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@3e860a91
	comiss	xmm0, DWORD PTR [ecx+20]
	jbe	SHORT $LN14@GunsJinkCh

; 54   : 				   {
; 55   : 					  twoSeconds = TRUE;

	mov	DWORD PTR _twoSeconds$[ebp], 1
	jmp	$LN8@GunsJinkCh
$LN14@GunsJinkCh:

; 56   : 				   }
; 57   : 				   else if (localData->azFrom > (5.0F * DTR) && localData->azFromdot < 0.0F)

	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	comiss	xmm0, DWORD PTR __real@3db2b8c1
	jbe	SHORT $LN12@GunsJinkCh
	mov	eax, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+24]
	jbe	SHORT $LN12@GunsJinkCh

; 58   : 				   {
; 59   : 					  if (localData->azFrom + z * localData->azFromdot < (5.0F * DTR))

	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	mulss	xmm0, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _localData$[ebp]
	addss	xmm0, DWORD PTR [edx+20]
	movss	xmm1, DWORD PTR __real@3db2b8c1
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@GunsJinkCh

; 60   : 						 twoSeconds = TRUE;

	mov	DWORD PTR _twoSeconds$[ebp], 1
$LN11@GunsJinkCh:

; 61   : 				   }

	jmp	SHORT $LN8@GunsJinkCh
$LN12@GunsJinkCh:

; 62   : 				   else if (localData->azFrom < (-5.0F * DTR) && localData->azFromdot > 0.0F)

	mov	eax, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@bdb2b8c1
	comiss	xmm0, DWORD PTR [eax+20]
	jbe	SHORT $LN8@GunsJinkCh
	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [ecx+24]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@GunsJinkCh

; 63   : 				   {
; 64   : 					  if (localData->azFrom + z * localData->azFromdot > (-5.0F * DTR))

	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	mulss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _localData$[ebp]
	addss	xmm0, DWORD PTR [eax+20]
	comiss	xmm0, DWORD PTR __real@bdb2b8c1
	jbe	SHORT $LN8@GunsJinkCh

; 65   : 						 twoSeconds = TRUE;

	mov	DWORD PTR _twoSeconds$[ebp], 1
$LN8@GunsJinkCh:

; 66   : 				   }
; 67   : 		
; 68   : 				   if (twoSeconds)

	cmp	DWORD PTR _twoSeconds$[ebp], 0
	je	$LN2@GunsJinkCh

; 69   : 				   {
; 70   : 					  twoSeconds = FALSE;

	mov	DWORD PTR _twoSeconds$[ebp], 0

; 71   : 					  if (localData->elFrom < (4.0F *DTR) && localData->elFrom > (-10.0F * DTR))//me123 status test. changed all

	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@3d8efa34
	comiss	xmm0, DWORD PTR [ecx+32]
	jbe	SHORT $LN6@GunsJinkCh
	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	comiss	xmm0, DWORD PTR __real@be32b8c1
	jbe	SHORT $LN6@GunsJinkCh

; 72   : 					  {
; 73   : 						 twoSeconds = TRUE;

	mov	DWORD PTR _twoSeconds$[ebp], 1
$LN6@GunsJinkCh:

; 74   : 					  }
; 75   : 			//		  else if (localData->elFrom > (-2.0F *DTR) && localData->elFromdot < 0.0F)
; 76   : 			//		  {
; 77   : 			//			 if (localData->elFrom + z* localData->elFromdot < (-2.0F *DTR))
; 78   : 			//				twoSeconds = TRUE;
; 79   : 			//		  }
; 80   : 			//		  else if (localData->elFrom < (-13.0F * DTR) && localData->elFromdot > 0.0F)
; 81   : 			//		  {
; 82   : 			//			 if (localData->elFrom + z* localData->elFromdot > (-13.0F * DTR))
; 83   : 			//				twoSeconds = TRUE;
; 84   : 			//		  }
; 85   : 		
; 86   : 					  /*-------------------------------------------------*/
; 87   : 					  /* estimate time to be targeted and time to attack */
; 88   : 					  /*-------------------------------------------------*/
; 89   : 				   lastUpdate = targetPtr->BaseData()->LastUpdateTime();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?LastUpdateTime@VuEntity@@QBEKXZ	; VuEntity::LastUpdateTime
	mov	DWORD PTR _lastUpdate$[ebp], eax

; 90   : 
; 91   : 				   if (lastUpdate == vuxGameTime)

	mov	ecx, DWORD PTR _lastUpdate$[ebp]
	cmp	ecx, DWORD PTR ?vuxGameTime@@3KA	; vuxGameTime
	jne	SHORT $LN5@GunsJinkCh

; 92   : 					  timeDelta = SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _timeDelta$[ebp], xmm0

; 93   : 				   else

	jmp	SHORT $LN4@GunsJinkCh
$LN5@GunsJinkCh:

; 94   : 					  timeDelta = SimLibLastMajorFrameTime;

	movss	xmm0, DWORD PTR ?SimLibLastMajorFrameTime@@3MA
	movss	DWORD PTR _timeDelta$[ebp], xmm0
$LN4@GunsJinkCh:

; 95   : 
; 96   : 				  /*-----------*/
; 97   : 					  /* him -> me */
; 98   : 					  /*-----------*/
; 99   : 					  tgt_time = ((localData->ataFrom / localData->ataFromdot) * timeDelta);

	mov	edx, DWORD PTR _localData$[ebp]
	mov	eax, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	divss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _timeDelta$[ebp]
	movss	DWORD PTR _tgt_time$[ebp], xmm0

; 100  : 					//  if (tgt_time < 0.0F)//me123 status test,
; 101  : 					//	 tgt_time = 99.0F;//me123 status test,
; 102  : 					  if (localData->ataFrom > -13.0f *DTR && localData->ataFrom < 13.0f *DTR) {tgt_time = 0.0f;}//me123 status test,

	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, DWORD PTR __real@be685694
	jbe	SHORT $LN3@GunsJinkCh
	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@3e685694
	comiss	xmm0, DWORD PTR [edx+4]
	jbe	SHORT $LN3@GunsJinkCh
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tgt_time$[ebp], xmm0
$LN3@GunsJinkCh:

; 103  : 					  /*-----------*/
; 104  : 					  /* me -> him */
; 105  : 					  /*-----------*/
; 106  : 					  att_time = (localData->ata / localData->atadot) * timeDelta;

	mov	eax, DWORD PTR _localData$[ebp]
	mov	ecx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [eax]
	divss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _timeDelta$[ebp]
	movss	DWORD PTR _att_time$[ebp], xmm0

; 107  : 					// if (att_time < 0.0F)//me123 status test,
; 108  : 					//	 att_time = 99.0F;//me123 status test,
; 109  : 					  if (localData->ata > -13.0f *DTR && localData->ata < 13.0f *DTR) {att_time = 0.0f;}//me123 status test,

	mov	edx, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, DWORD PTR __real@be685694
	jbe	SHORT $LN2@GunsJinkCh
	mov	eax, DWORD PTR _localData$[ebp]
	movss	xmm0, DWORD PTR __real@3e685694
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN2@GunsJinkCh
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _att_time$[ebp], xmm0
$LN2@GunsJinkCh:

; 110  : 				   }
; 111  : 		
; 112  : 				   /*--------------*/
; 113  : 				   /* trigger jink */
; 114  : 				   /*--------------*/
; 115  : 				   if (twoSeconds && tgt_time <= att_time)

	cmp	DWORD PTR _twoSeconds$[ebp], 0
	je	SHORT $LN1@GunsJinkCh
	movss	xmm0, DWORD PTR _att_time$[ebp]
	comiss	xmm0, DWORD PTR _tgt_time$[ebp]
	jb	SHORT $LN1@GunsJinkCh

; 116  : 				   {
; 117  : 					  AddMode(GunsJinkMode);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN1@GunsJinkCh:
$LN21@GunsJinkCh:

; 118  : 				   }
; 119  : 				}
; 120  : 		  }
; 121  : 	  }
; 122  : 
; 123  :    } // if not guns jink mode
; 124  : 
; 125  :    /*------------------------------------*/
; 126  :    /* else already in guns jink          */
; 127  :    /* this maneuver is timed and removes */
; 128  :    /* itself, but we must make sure the  */
; 129  :    /* threat is still around             */
; 130  :    /*------------------------------------*/
; 131  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GunsJinkCheck@DigitalBrain@@IAEXXZ ENDP		; DigitalBrain::GunsJinkCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\gunsjink.cpp
_TEXT	SEGMENT
tv817 = -168						; size = 8
_obj$ = -160						; size = 4
tv655 = -156						; size = 4
tv830 = -152						; size = 4
tv496 = -148						; size = 4
tv621 = -144						; size = 4
tv495 = -140						; size = 4
tv592 = -136						; size = 4
tv800 = -132						; size = 4
tv641 = -128						; size = 4
tv793 = -124						; size = 4
tv616 = -120						; size = 4
tv782 = -116						; size = 4
tv597 = -112						; size = 4
tv766 = -108						; size = 4
tv663 = -104						; size = 4
tv759 = -100						; size = 4
tv649 = -96						; size = 4
tv752 = -92						; size = 4
_aspect$ = -88						; size = 4
tv744 = -84						; size = 4
tv864 = -80						; size = 4
tv725 = -76						; size = 4
tv609 = -72						; size = 4
tv719 = -68						; size = 4
tv604 = -64						; size = 4
tv708 = -60						; size = 4
tv828 = -56						; size = 4
tv677 = -52						; size = 4
tv584 = -48						; size = 4
tv669 = -44						; size = 4
tv631 = -40						; size = 4
tv813 = -36						; size = 4
_roll_offset$ = -32					; size = 4
tv479 = -28						; size = 4
tv446 = -24						; size = 4
tv79 = -20						; size = 4
_maxPull$ = -16						; size = 4
_eroll$ = -12						; size = 4
_gunsJinkData$ = -8					; size = 4
_this$ = -4						; size = 4
?GunsJink@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::GunsJink
; _this$ = ecx

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	DWORD PTR _this$[ebp], ecx

; 135  : float aspect, roll_offset, eroll;
; 136  : SimObjectLocalData* gunsJinkData;
; 137  : SimObjectType* obj = targetList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+376]
	mov	DWORD PTR _obj$[ebp], ecx

; 138  : //int randVal;
; 139  : float maxPull;
; 140  : 
; 141  :    /*------------------------------------*/
; 142  :    /* this maneuver is timed and removes */
; 143  :    /* itself, but we must make sure the  */
; 144  :    /* threat is still around             */
; 145  :    /*------------------------------------*/
; 146  :    if ( targetPtr == NULL || targetPtr->BaseData()->IsExploding() || 
; 147  : 	   targetPtr && targetPtr->localData->range > 4000)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN36@GunsJink
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN36@GunsJink
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN37@GunsJink
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR __real@457a0000
	jbe	SHORT $LN37@GunsJink
$LN36@GunsJink:

; 148  :    {
; 149  : 	   // bail, no target
; 150  :       jinkTime = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], -1

; 151  : 	   return;

	jmp	$LN38@GunsJink
$LN37@GunsJink:

; 152  :    }
; 153  : 	// Cobra No need to go through all the stuff if we need to avoid the ground
; 154  :   if(groundAvoidNeeded)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN35@GunsJink

; 155  : 	   return;

	jmp	$LN38@GunsJink
$LN35@GunsJink:

; 156  : 
; 157  :    /*-------------------*/
; 158  :    /* energy management */
; 159  :    /*-------------------*/
; 160  :    MachHold(cornerSpeed,self->GetKias(), FALSE);//me123 from TRUE

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 161  :    /*--------------------*/
; 162  :    /* find target aspect */
; 163  :    /*--------------------*/
; 164  :    gunsJinkData = targetPtr->localData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _gunsJinkData$[ebp], ecx

; 165  :    aspect = 180.0F * DTR - gunsJinkData->ata;

	mov	edx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR __real@40490fd9
	subss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _aspect$[ebp], xmm0

; 166  : 
; 167  :    /*-----------------*/
; 168  :    /* pick roll angle */
; 169  :    /*-----------------*/
; 170  :    if (jinkTime == -1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+492], -1
	jne	$LN34@GunsJink

; 171  :    {
; 172  :       // Should I jettison stores?
; 173  :       if (self->CombatClass() != MnvrClassBomber)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+144]
	call	eax
	cmp	eax, 8
	je	SHORT $LN33@GunsJink

; 174  :       {
; 175  : 				//Cobra we do this always
; 176  : 				self->Sms->AGJettison();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+940]
	call	?AGJettison@SMSClass@@QAEXXZ		; SMSClass::AGJettison

; 177  : 				SelectGroundWeapon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectGroundWeapon@DigitalBrain@@IAEXXZ ; DigitalBrain::SelectGroundWeapon
$LN33@GunsJink:

; 178  :       }
; 179  :       ResetMaxRoll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetMaxRoll@DigitalBrain@@IAEXXZ	; DigitalBrain::ResetMaxRoll

; 180  : 
; 181  :       /*--------------------------------*/
; 182  :       /* aspect >= 60 degrees           */
; 183  :       /* put plane of wings on attacker */
; 184  :       /*--------------------------------*/
; 185  :       if (aspect >= 90.0F * DTR)//me123 changed from 60

	movss	xmm0, DWORD PTR _aspect$[ebp]
	comiss	xmm0, DWORD PTR __real@3fc90fd9
	jb	SHORT $LN32@GunsJink

; 186  :       {
; 187  :          /* offset required to put wings on attacker */
; 188  :          if (gunsJinkData->droll >= 0.0F) roll_offset = gunsJinkData->droll - 90.0F * DTR;

	mov	eax, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN31@GunsJink
	mov	ecx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	subss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR _roll_offset$[ebp], xmm0
	jmp	SHORT $LN30@GunsJink
$LN31@GunsJink:

; 189  :          else roll_offset = gunsJinkData->droll + 90.0F * DTR;

	mov	edx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	addss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR _roll_offset$[ebp], xmm0
$LN30@GunsJink:

; 190  : 
; 191  :          /* generate new phi angle */
; 192  :          newroll = self->Roll() + roll_offset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv584[ebp]
	movss	xmm0, DWORD PTR tv584[ebp]
	addss	xmm0, DWORD PTR _roll_offset$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 193  :       }
; 194  :       /*---------------------*/
; 195  :       /* aspect < 60 degrees */
; 196  :       /* roll +- 90 degrees  */
; 197  :       /*---------------------*/
; 198  :       else 

	jmp	$LN15@GunsJink
$LN32@GunsJink:

; 199  :       {
; 200  :          /* special in-plane crossing case, go the opposite direction */
; 201  :          if (targetPtr && ((targetPtr->BaseData()->Yaw()   - self->Yaw() < 15.0F * DTR) &&
; 202  :              (targetPtr->BaseData()->Pitch() - self->Pitch() < 15.0F * DTR) &&
; 203  :              (targetPtr->BaseData()->Roll()  - self->Roll() < 15.0F * DTR)))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN28@GunsJink
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv592[ebp]
	movss	xmm0, DWORD PTR tv592[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv828[ebp], xmm0
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv597[ebp]
	movss	xmm0, DWORD PTR tv828[ebp]
	subss	xmm0, DWORD PTR tv597[ebp]
	movss	xmm1, DWORD PTR __real@3e860a91
	comiss	xmm1, xmm0
	jbe	$LN28@GunsJink
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv604[ebp]
	movss	xmm0, DWORD PTR tv604[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv830[ebp], xmm0
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv609[ebp]
	movss	xmm0, DWORD PTR tv830[ebp]
	subss	xmm0, DWORD PTR tv609[ebp]
	movss	xmm1, DWORD PTR __real@3e860a91
	comiss	xmm1, xmm0
	jbe	$LN28@GunsJink
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv616[ebp]
	movss	xmm0, DWORD PTR tv616[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv864[ebp], xmm0
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv621[ebp]
	movss	xmm0, DWORD PTR tv864[ebp]
	subss	xmm0, DWORD PTR tv621[ebp]
	movss	xmm1, DWORD PTR __real@3e860a91
	comiss	xmm1, xmm0
	jbe	$LN28@GunsJink

; 204  :          {
; 205  :             if (gunsJinkData->droll >= 0.0F && gunsJinkData->az > 0.0F)

	mov	eax, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN27@GunsJink
	mov	ecx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN27@GunsJink

; 206  :             {
; 207  :                newroll = self->Roll() + 90.0F * DTR; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv631[ebp]
	movss	xmm0, DWORD PTR tv631[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fd9
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0
	jmp	$LN22@GunsJink
$LN27@GunsJink:

; 208  :             }
; 209  :             else if (gunsJinkData->droll < 0.0F && gunsJinkData->az < 0.0F)

	mov	ecx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+40]
	jbe	SHORT $LN25@GunsJink
	mov	edx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+16]
	jbe	SHORT $LN25@GunsJink

; 210  :             {
; 211  :                newroll = self->Roll() - 90.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv641[ebp]
	movss	xmm0, DWORD PTR tv641[ebp]
	subss	xmm0, DWORD PTR __real@3fc90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 212  :             }
; 213  :             else      /* fall out, normal case */

	jmp	SHORT $LN22@GunsJink
$LN25@GunsJink:

; 214  :             {
; 215  :                if (gunsJinkData->droll > 0.0F)

	mov	edx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN23@GunsJink

; 216  :                   newroll = self->Roll() - 70.0F * DTR; //me123 status test changed from 90

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv649[ebp]
	movss	xmm0, DWORD PTR tv649[ebp]
	subss	xmm0, DWORD PTR __real@3f9c61a9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 217  :                else

	jmp	SHORT $LN22@GunsJink
$LN23@GunsJink:

; 218  :                   newroll = self->Roll() + 70.0F * DTR;//me123 status test changed from 90

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv655[ebp]
	movss	xmm0, DWORD PTR tv655[ebp]
	addss	xmm0, DWORD PTR __real@3f9c61a9
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0
$LN22@GunsJink:

; 219  :             }
; 220  :          }
; 221  :          /* normal jink */
; 222  :          else

	jmp	SHORT $LN19@GunsJink
$LN28@GunsJink:

; 223  :          {
; 224  :             if (gunsJinkData->droll > 0.0F)

	mov	ecx, DWORD PTR _gunsJinkData$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN20@GunsJink

; 225  :                newroll = self->Roll() - 70.0F * DTR;//me123 status test changed from 90

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv663[ebp]
	movss	xmm0, DWORD PTR tv663[ebp]
	subss	xmm0, DWORD PTR __real@3f9c61a9
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0

; 226  :             else

	jmp	SHORT $LN19@GunsJink
$LN20@GunsJink:

; 227  :                newroll = self->Roll() + 70.0F * DTR;//me123 status test changed from 90

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv669[ebp]
	movss	xmm0, DWORD PTR tv669[ebp]
	addss	xmm0, DWORD PTR __real@3f9c61a9
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+512], xmm0
$LN19@GunsJink:

; 228  :          }
; 229  : 
; 230  :          /*--------------------------------------------*/
; 231  :          /* roll down if speed <= 60% of corner speed  */
; 232  :          /*--------------------------------------------*/
; 233  :          if (self->GetKias() <= 0.8F * cornerSpeed)//me123 status test. changed from 0.6

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv677[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm0, DWORD PTR [eax+100]
	comiss	xmm0, DWORD PTR tv677[ebp]
	jb	$LN15@GunsJink

; 234  :          {
; 235  :             if (newroll >= 0.0F && newroll <= 45.0F * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+512]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN17@GunsJink
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR [edx+512]
	jb	SHORT $LN17@GunsJink

; 236  :                newroll += 30.0F * DTR;//me123 status test changed from 20

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+512]
	addss	xmm0, DWORD PTR __real@3f060a91
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+512], xmm0
	jmp	SHORT $LN15@GunsJink
$LN17@GunsJink:

; 237  :             else if (newroll <= 0.0F && newroll >= -45.0F * DTR)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [edx+512]
	jb	SHORT $LN15@GunsJink
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+512]
	comiss	xmm0, DWORD PTR __real@bf490fd9
	jb	SHORT $LN15@GunsJink

; 238  :                newroll -= 30.0F * DTR;//me123 status test changed from 20

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+512]
	subss	xmm0, DWORD PTR __real@3f060a91
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+512], xmm0
$LN15@GunsJink:

; 239  :          }
; 240  :       }
; 241  : 
; 242  :       /*------------------------*/
; 243  :       /* roll angle corrections */
; 244  :       /*------------------------*/
; 245  :       if (newroll > 180.0F * DTR)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+512]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN14@GunsJink

; 246  :          newroll -= 360.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+512]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+512], xmm0
	jmp	SHORT $LN12@GunsJink
$LN14@GunsJink:

; 247  :       else if (newroll < -180.0F * DTR)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [eax+512]
	jbe	SHORT $LN12@GunsJink

; 248  :          newroll += 360.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+512]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+512], xmm0
$LN12@GunsJink:

; 249  : 
; 250  :       // Clamp roll to limits
; 251  :       if (newroll > af->MaxRoll())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxRoll@AirframeClass@@QAEMXZ		; AirframeClass::MaxRoll
	fstp	DWORD PTR tv708[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+512]
	comiss	xmm0, DWORD PTR tv708[ebp]
	jbe	SHORT $LN11@GunsJink

; 252  :          newroll = af->MaxRoll();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxRoll@AirframeClass@@QAEMXZ		; AirframeClass::MaxRoll
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+512]
	jmp	SHORT $LN9@GunsJink
$LN11@GunsJink:

; 253  :       else if (newroll < -af->MaxRoll())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MaxRoll@AirframeClass@@QAEMXZ		; AirframeClass::MaxRoll
	fstp	DWORD PTR tv719[ebp]
	movss	xmm0, DWORD PTR tv719[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [edx+512]
	jbe	SHORT $LN9@GunsJink

; 254  :          newroll = -af->MaxRoll();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxRoll@AirframeClass@@QAEMXZ		; AirframeClass::MaxRoll
	fstp	DWORD PTR tv725[ebp]
	movss	xmm0, DWORD PTR tv725[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+512], xmm0
$LN9@GunsJink:

; 255  : 
; 256  :       jinkTime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], 0
$LN34@GunsJink:

; 257  :    }
; 258  : 
; 259  :    // Allow unlimited rolling
; 260  :    if (self->CombatClass() != MnvrClassBomber)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	cmp	eax, 8
	je	SHORT $LN8@GunsJink

; 261  :       SetMaxRoll (190.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@433e0000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll
$LN8@GunsJink:

; 262  : 
; 263  :    /*---------------------------*/
; 264  :    /* roll to the desired angle */
; 265  :    /*---------------------------*/
; 266  :    if (jinkTime == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+492], 0
	jne	$LN6@GunsJink

; 267  :    {
; 268  :       SetPstick (-2.0F, maxGs, AirframeClass::GCommand);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+96]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 269  : 
; 270  :       /*------------*/
; 271  :       /* roll error */
; 272  :       /*------------*/
; 273  :       eroll = newroll - self->Roll();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv744[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+512]
	subss	xmm0, DWORD PTR tv744[ebp]
	movss	DWORD PTR _eroll$[ebp], xmm0

; 274  : 
; 275  :       /*-----------------------------*/
; 276  :       /* roll the shortest direction */
; 277  :       /*-----------------------------*/
; 278  :       eroll = SetRstick( eroll * RTD * 4.0F) * DTR;

	movss	xmm0, DWORD PTR _eroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR __real@40800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	DWORD PTR tv752[ebp]
	movss	xmm0, DWORD PTR tv752[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _eroll$[ebp], xmm0

; 279  :       SetMaxRollDelta (eroll);

	push	ecx
	movss	xmm0, DWORD PTR _eroll$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta

; 280  : 	  //me123 and pull like hell
; 281  :       maxPull = max (0.8F * af->MaxGs(), maxGs);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	fstp	DWORD PTR tv759[ebp]
	movss	xmm0, DWORD PTR tv759[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [edx+96]
	jbe	SHORT $LN40@GunsJink
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	fstp	DWORD PTR tv766[ebp]
	movss	xmm0, DWORD PTR tv766[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv446[ebp], xmm0
	jmp	SHORT $LN41@GunsJink
$LN40@GunsJink:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+96]
	movss	DWORD PTR tv446[ebp], xmm0
$LN41@GunsJink:
	movss	xmm0, DWORD PTR tv446[ebp]
	movss	DWORD PTR _maxPull$[ebp], xmm0

; 282  :       SetPstick ( maxPull, af->MaxGs(), AirframeClass::GCommand);

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _maxPull$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 283  : 	  /*-----------------------*/
; 284  : 	   /* stop rolling and pull */
; 285  : 	   /*-----------------------*/
; 286  : 	   if (fabs(eroll) < 5.0F * DTR)//me123 status test, from 5

	push	ecx
	movss	xmm0, DWORD PTR _eroll$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv782[ebp]
	movss	xmm0, DWORD PTR __real@3db2b8c1
	comiss	xmm0, DWORD PTR tv782[ebp]
	jbe	SHORT $LN6@GunsJink

; 287  : 	   { 
; 288  : 		  jinkTime = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+492], 1

; 289  : 		  SetRstick( 0.5F );//me123 status test, from 0

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)
$LN6@GunsJink:

; 290  : 	   }
; 291  :    }   
; 292  : 
; 293  :    /*-----------------------*/
; 294  :    /* pull max gs for 2 sec */
; 295  :    /*-----------------------*/
; 296  :    if (jinkTime > 0 || groundAvoidNeeded) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+492], 0
	ja	SHORT $LN4@GunsJink
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	$LN5@GunsJink
$LN4@GunsJink:

; 297  :    {
; 298  :       maxPull = max (0.8F * af->MaxGs(), maxGs);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	fstp	DWORD PTR tv793[ebp]
	movss	xmm0, DWORD PTR tv793[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+96]
	jbe	SHORT $LN42@GunsJink
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	fstp	DWORD PTR tv800[ebp]
	movss	xmm0, DWORD PTR tv800[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv479[ebp], xmm0
	jmp	SHORT $LN43@GunsJink
$LN42@GunsJink:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR tv479[ebp], xmm0
$LN43@GunsJink:
	movss	xmm0, DWORD PTR tv479[ebp]
	movss	DWORD PTR _maxPull$[ebp], xmm0

; 299  :       SetPstick ( maxPull, af->MaxGs(), AirframeClass::GCommand);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _maxPull$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 300  : 
; 301  :       if (jinkTime++ > SimLibMajorFrameRate*2.0F + 1.0F)//me123 status test, pull for 5sec instead of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+492]
	mov	DWORD PTR tv813[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv813[ebp]
	mov	ecx, DWORD PTR tv813[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv817[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv817[ebp]
	movss	DWORD PTR tv495[ebp], xmm0
	movss	xmm0, DWORD PTR ?SimLibMajorFrameRate@@3MA
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv496[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+492]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], eax
	movss	xmm0, DWORD PTR tv495[ebp]
	comiss	xmm0, DWORD PTR tv496[ebp]
	jbe	SHORT $LN3@GunsJink

; 302  :       {
; 303  :          ResetMaxRoll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetMaxRoll@DigitalBrain@@IAEXXZ	; DigitalBrain::ResetMaxRoll

; 304  :          jinkTime = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], -1

; 305  :       }
; 306  :       else

	jmp	SHORT $LN2@GunsJink
$LN3@GunsJink:

; 307  :       {
; 308  :          // Stay in guns jink
; 309  :          AddMode(GunsJinkMode);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN2@GunsJink:

; 310  :       }
; 311  :    }
; 312  :    else

	jmp	SHORT $LN1@GunsJink
$LN5@GunsJink:

; 313  :    {
; 314  :       // Stay in guns jink
; 315  :      AddMode(GunsJinkMode);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN1@GunsJink:
$LN38@GunsJink:

; 316  :    }
; 317  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GunsJink@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::GunsJink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsFiring@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsFiring@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsFiring, COMDAT
; _this$ = ecx

; 176  : 	int IsFiring() const { return (specialData.flags & OBJ_FIRING_GUN ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 64					; 00000040H
	je	SHORT $LN3@IsFiring
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsFiring
$LN3@IsFiring:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsFiring:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFiring@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsFiring
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?LastUpdateTime@VuEntity@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LastUpdateTime@VuEntity@@QBEKXZ PROC			; VuEntity::LastUpdateTime, COMDAT
; _this$ = ecx

; 172  : 	VU_TIME LastUpdateTime() const { return lastUpdateTime_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esp, ebp
	pop	ebp
	ret	0
?LastUpdateTime@VuEntity@@QBEKXZ ENDP			; VuEntity::LastUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
