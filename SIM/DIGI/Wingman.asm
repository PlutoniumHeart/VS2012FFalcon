; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\Wingman.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?BvrLookup@@3PAW4BVRProfileType@DigitalBrain@@A	; BvrLookup
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
_DATA	SEGMENT
?BvrLookup@@3PAW4BVRProfileType@DigitalBrain@@A DD 01H	; BvrLookup
	DD	04H
	DD	07H
	DD	02H
	DD	05H
	DD	08H
	DD	03H
	DD	06H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	013H
_DATA	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?EntityId@VuMessage@@QBE?AVVU_ID@@XZ		; VuMessage::EntityId
PUBLIC	?SetBvrCurrProfile@DigitalBrain@@QAEXW4BVRProfileType@1@@Z ; DigitalBrain::SetBvrCurrProfile
PUBLIC	?ReceiveOrders@DigitalBrain@@UAEXPAVFalconEvent@@@Z ; DigitalBrain::ReceiveOrders
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?IsAwake@SimBaseClass@@QBEHXZ			; SimBaseClass::IsAwake
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ	; AircraftClass::DBrain
EXTRN	___report_rangecheckfailure:PROC
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z:PROC ; DigitalBrain::FlightMemberWantsFuel
EXTRN	?AiClearLeadersSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiClearLeadersSix
EXTRN	?AiCheckOwnSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiCheckOwnSix
EXTRN	?AiBreakLeft@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiBreakLeft
EXTRN	?AiBreakRight@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiBreakRight
EXTRN	?AiGoShooter@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiGoShooter
EXTRN	?AiGoCover@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiGoCover
EXTRN	?AiSearchForTargets@DigitalBrain@@AAEXD@Z:PROC	; DigitalBrain::AiSearchForTargets
EXTRN	?AiResumeFlightPlan@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiResumeFlightPlan
EXTRN	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z:PROC ; DigitalBrain::AiRejoin
EXTRN	?AiSetRadarActive@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiSetRadarActive
EXTRN	?AiSetRadarStby@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiSetRadarStby
EXTRN	?AiBuddySpikeReact@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiBuddySpikeReact
EXTRN	?AiRaygun@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiRaygun
EXTRN	?AiRTB@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiRTB
EXTRN	?AiDesignateTarget@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiDesignateTarget
EXTRN	?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z:PROC ; DigitalBrain::AiSetWeaponsAction
EXTRN	?AiSetFormation@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiSetFormation
EXTRN	?AiKickout@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiKickout
EXTRN	?AiCloseup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiCloseup
EXTRN	?AiToggleSide@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiToggleSide
EXTRN	?AiIncreaseRelativeAltitude@DigitalBrain@@AAEXXZ:PROC ; DigitalBrain::AiIncreaseRelativeAltitude
EXTRN	?AiDecreaseRelativeAltitude@DigitalBrain@@AAEXXZ:PROC ; DigitalBrain::AiDecreaseRelativeAltitude
EXTRN	?AiGiveBra@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiGiveBra
EXTRN	?AiGiveStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiGiveStatus
EXTRN	?AiGiveDamageReport@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiGiveDamageReport
EXTRN	?AiGiveFuelStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiGiveFuelStatus
EXTRN	?AiGiveWeaponsStatus@DigitalBrain@@AAEXXZ:PROC	; DigitalBrain::AiGiveWeaponsStatus
EXTRN	?AiPromote@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiPromote
EXTRN	?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiSmokeOn
EXTRN	?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiSmokeOff
EXTRN	?AiGlueWing@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiGlueWing
EXTRN	?AiSplitWing@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiSplitWing
EXTRN	?AiDropStores@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiDropStores
EXTRN	?AiECMOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiECMOn
EXTRN	?AiECMOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiECMOff
EXTRN	?AiInitSSOffset@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiInitSSOffset
EXTRN	?AiInitPince@DigitalBrain@@AAEXPAVFalconWingmanMsg@@H@Z:PROC ; DigitalBrain::AiInitPince
EXTRN	?AiInitFlex@DigitalBrain@@AAEXXZ:PROC		; DigitalBrain::AiInitFlex
EXTRN	?AiInitChainsaw@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiInitChainsaw
EXTRN	?AiInitPosthole@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:PROC ; DigitalBrain::AiInitPosthole
EXTRN	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z:PROC ; CampBaseClass::GetComponentIndex
EXTRN	?AiIsFullResponse@@YAHHH@Z:PROC			; AiIsFullResponse
EXTRN	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z:PROC ; AiMakeRadioResponse
EXTRN	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z:PROC ; AiRespondShortCallSign
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ PROC	; AircraftClass::DBrain, COMDAT
; _this$ = ecx

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]
	mov	esp, ebp
	pop	ebp
	ret	0
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ENDP	; AircraftClass::DBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsAwake@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 177  : 	int IsAwake() const { return localFlags & OBJ_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingman.cpp
_TEXT	SEGMENT
$T1 = -76						; size = 8
_p_flight$ = -68					; size = 4
tv438 = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
tv178 = -52						; size = 4
tv241 = -48						; size = 4
_command$ = -44						; size = 4
_fromIndex$ = -40					; size = 4
_p_from$ = -36						; size = 4
_wingMsg$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_theEvent$ = 8						; size = 4
?ReceiveOrders@DigitalBrain@@UAEXPAVFalconEvent@@@Z PROC ; DigitalBrain::ReceiveOrders
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 
; 36   : 	FalconWingmanMsg					*wingMsg;
; 37   : 	FalconWingmanMsg::WingManCmd	command;
; 38   : 	FlightClass							*p_flight;
; 39   : 	AircraftClass						*p_from;
; 40   : 	int									fromIndex;
; 41   : 	short									edata[10];
; 42   : 
; 43   :    if (!self->IsAwake() || self->IsDead())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN100@ReceiveOrd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	je	SHORT $LN101@ReceiveOrd
$LN100@ReceiveOrd:

; 44   : 	   return;

	jmp	$LN103@ReceiveOrd
$LN101@ReceiveOrd:

; 45   : 
; 46   :    //we can't follow orders about how to fly if we're on the ground still!
; 47   : 	if(self->OnGround() || atcstatus >= lOnFinal)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN98@ReceiveOrd
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 11			; 0000000bH
	jl	SHORT $LN99@ReceiveOrd
$LN98@ReceiveOrd:

; 48   : 		return;

	jmp	$LN103@ReceiveOrd
$LN99@ReceiveOrd:

; 49   : 
; 50   : 	wingMsg = (FalconWingmanMsg *)theEvent;

	mov	edx, DWORD PTR _theEvent$[ebp]
	mov	DWORD PTR _wingMsg$[ebp], edx

; 51   : 	command = (FalconWingmanMsg::WingManCmd) wingMsg->dataBlock.command;

	mov	eax, DWORD PTR _wingMsg$[ebp]
	mov	ecx, DWORD PTR [eax+58]
	mov	DWORD PTR _command$[ebp], ecx

; 52   : 
; 53   : 	p_flight		= (FlightClass*) vuDatabase->Find(wingMsg->EntityId());

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _wingMsg$[ebp]
	call	?EntityId@VuMessage@@QBE?AVVU_ID@@XZ	; VuMessage::EntityId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _p_flight$[ebp], eax

; 54   : 	p_from		= (AircraftClass*) vuDatabase->Find(wingMsg->dataBlock.from);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _p_from$[ebp], eax

; 55   : 	fromIndex	= p_flight->GetComponentIndex(p_from);

	mov	eax, DWORD PTR _p_from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p_flight$[ebp]
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _fromIndex$[ebp], eax

; 56   : 
; 57   : 	if(curMode == GunsJinkMode || curMode == MissileDefeatMode || curMode == DefensiveModes){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 3
	je	SHORT $LN96@ReceiveOrd
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 4
	je	SHORT $LN96@ReceiveOrd
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 6
	jne	$LN97@ReceiveOrd
$LN96@ReceiveOrd:

; 58   : 		
; 59   : 		switch(command) {

	mov	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	cmp	DWORD PTR tv178[ebp], 91		; 0000005bH
	ja	$LN94@ReceiveOrd
	mov	edx, DWORD PTR tv178[ebp]
	movzx	eax, BYTE PTR $LN108@ReceiveOrd[edx]
	jmp	DWORD PTR $LN111@ReceiveOrd[eax*4]
$LN93@ReceiveOrd:

; 60   : 		// Commands that change Action and Search States
; 61   : 			case FalconWingmanMsg::WMRTB:
; 62   : 			case FalconWingmanMsg::WMClearSix:
; 63   : 			case FalconWingmanMsg::WMCheckSix:
; 64   : 			case FalconWingmanMsg::WMBreakRight:
; 65   : 			case FalconWingmanMsg::WMBreakLeft:
; 66   : 			case FalconWingmanMsg::WMPosthole:
; 67   : 			case FalconWingmanMsg::WMPince:
; 68   : 			case FalconWingmanMsg::WMChainsaw:
; 69   : 			case FalconWingmanMsg::WMSSOffset:
; 70   : 			case FalconWingmanMsg::WMFlex:
; 71   : 			case FalconWingmanMsg::WMShooterMode:
; 72   : 			case FalconWingmanMsg::WMCoverMode:
; 73   : 			case FalconWingmanMsg::WMSearchGround:
; 74   : 			case FalconWingmanMsg::WMSearchAir:
; 75   : 			case FalconWingmanMsg::WMResumeNormal:
; 76   : 			case FalconWingmanMsg::WMRejoin:
; 77   : 			case FalconWingmanMsg::WMAssignTarget:
; 78   : 			case FalconWingmanMsg::WMAssignGroup:
; 79   : 			case FalconWingmanMsg::WMWeaponsHold:
; 80   : 			case FalconWingmanMsg::WMSpread:
; 81   : 			case FalconWingmanMsg::WMWedge:
; 82   : 			case FalconWingmanMsg::WMTrail:
; 83   : 			case FalconWingmanMsg::WMLadder:
; 84   : 			case FalconWingmanMsg::WMStack:
; 85   : 			case FalconWingmanMsg::WMResCell:
; 86   : 			case FalconWingmanMsg::WMBox:
; 87   : 			case FalconWingmanMsg::WMArrowHead:
; 88   : 			case FalconWingmanMsg::WMFluidFour:
; 89   : 			case FalconWingmanMsg::WMVic:
; 90   : 			case FalconWingmanMsg::WMFinger4:
; 91   : 			case FalconWingmanMsg::WMEchelon:
; 92   : 			case FalconWingmanMsg::WMForm1:
; 93   : 			case FalconWingmanMsg::WMForm2:
; 94   : 			case FalconWingmanMsg::WMForm3:
; 95   : 			case FalconWingmanMsg::WMForm4:
; 96   : 			case FalconWingmanMsg::WMKickout:
; 97   : 			case FalconWingmanMsg::WMCloseup:
; 98   : 			case FalconWingmanMsg::WMToggleSide:
; 99   : 			case FalconWingmanMsg::WMIncreaseRelAlt:
; 100  : 			case FalconWingmanMsg::WMDecreaseRelAlt:
; 101  : 				edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	dx, BYTE PTR [eax+425]
	mov	eax, 2
	imul	eax, 0
	mov	WORD PTR _edata$[ebp+eax], dx

; 102  : 				edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + self->GetCampaignObject()->GetComponentIndex(self) + 1;		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	edx, DWORD PTR [eax+esi*4-3]
	mov	eax, 2
	shl	eax, 0
	mov	WORD PTR _edata$[ebp+eax], dx

; 103  : 				edata[2] = -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 104  : 				edata[3] = -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 105  :    				AiMakeRadioResponse( self, rcUNABLE, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	219					; 000000dbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 106  : // 2001-07-28 ADDED BY S.G. AI NEEDS TO KNOW WHAT DO TO ONCE HE FINISHES HIS DEFENSE...
; 107  : 				switch(command) {

	mov	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv241[ebp], edx
	mov	eax, DWORD PTR tv241[ebp]
	sub	eax, 9
	mov	DWORD PTR tv241[ebp], eax
	cmp	DWORD PTR tv241[ebp], 14		; 0000000eH
	ja	SHORT $LN91@ReceiveOrd
	mov	ecx, DWORD PTR tv241[ebp]
	movzx	edx, BYTE PTR $LN109@ReceiveOrd[ecx]
	jmp	DWORD PTR $LN112@ReceiveOrd[edx*4]
$LN90@ReceiveOrd:

; 108  : 					case FalconWingmanMsg::WMShooterMode:
; 109  : 						AiGoShooter();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGoShooter@DigitalBrain@@AAEXXZ	; DigitalBrain::AiGoShooter

; 110  : 						break;

	jmp	SHORT $LN91@ReceiveOrd
$LN89@ReceiveOrd:

; 111  : 
; 112  : 					case FalconWingmanMsg::WMCoverMode:
; 113  : 						AiGoCover();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGoCover@DigitalBrain@@AAEXXZ		; DigitalBrain::AiGoCover

; 114  : 						break;

	jmp	SHORT $LN91@ReceiveOrd
$LN88@ReceiveOrd:

; 115  : 
; 116  : 					case FalconWingmanMsg::WMRejoin:
; 117  : 						AiRejoin(wingMsg, AI_REJOIN); // 2001-10-23 ADDED AI_REJOIN BY S.G. So the AI knows it comes from the lead

	push	2
	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z ; DigitalBrain::AiRejoin

; 118  : 						//underOrders = FALSE;
; 119  : 						break;

	jmp	SHORT $LN91@ReceiveOrd
$LN87@ReceiveOrd:

; 120  : 
; 121  : 					// Commands that affect mode basis
; 122  : 					case FalconWingmanMsg::WMAssignTarget:
; 123  : 					case FalconWingmanMsg::WMAssignGroup:
; 124  : 						AiDesignateTarget(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiDesignateTarget@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDesignateTarget
$LN91@ReceiveOrd:

; 125  : 						break;
; 126  : 				}
; 127  : // END OF ADDED SECTION
; 128  : 			break;

	jmp	$LN94@ReceiveOrd
$LN86@ReceiveOrd:

; 129  : 
; 130  : 			case FalconWingmanMsg::WMRaygun:
; 131  : 				AiRaygun(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRaygun@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiRaygun

; 132  : 				break;

	jmp	$LN94@ReceiveOrd
$LN85@ReceiveOrd:

; 133  : 
; 134  : 			case FalconWingmanMsg::WMBuddySpike:
; 135  : 				AiBuddySpikeReact(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiBuddySpikeReact@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiBuddySpikeReact

; 136  : 				break;

	jmp	$LN94@ReceiveOrd
$LN84@ReceiveOrd:

; 137  : 
; 138  : 			case FalconWingmanMsg::WMRadarOn:
; 139  : 				AiSetRadarActive(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetRadarActive@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetRadarActive

; 140  : 				break;

	jmp	$LN94@ReceiveOrd
$LN83@ReceiveOrd:

; 141  : 
; 142  : 			case FalconWingmanMsg::WMRadarStby:
; 143  : 				AiSetRadarStby(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetRadarStby@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetRadarStby

; 144  : 				break;

	jmp	$LN94@ReceiveOrd
$LN82@ReceiveOrd:

; 145  : 
; 146  : 				// Transient Commands
; 147  : 			case FalconWingmanMsg::WMGiveBra:
; 148  : 				AiGiveBra(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveBra@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveBra

; 149  : 				break;

	jmp	$LN94@ReceiveOrd
$LN81@ReceiveOrd:

; 150  : 
; 151  : 			case FalconWingmanMsg::WMGiveStatus:
; 152  : 				AiGiveStatus(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveStatus

; 153  : 				break;

	jmp	$LN94@ReceiveOrd
$LN80@ReceiveOrd:

; 154  : 
; 155  : 			case FalconWingmanMsg::WMGiveDamageReport:
; 156  : 				AiGiveDamageReport(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveDamageReport@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveDamageReport

; 157  : 				break;

	jmp	$LN94@ReceiveOrd
$LN79@ReceiveOrd:

; 158  : 
; 159  : 			case FalconWingmanMsg::WMGiveFuelState:
; 160  : 				AiGiveFuelStatus(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveFuelStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveFuelStatus

; 161  : 				break;

	jmp	$LN94@ReceiveOrd
$LN78@ReceiveOrd:

; 162  : 
; 163  : 			case FalconWingmanMsg::WMWeaponsFree:
; 164  : 				AiSetWeaponsAction(wingMsg, AI_WEAPONS_FREE);

	push	1
	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z ; DigitalBrain::AiSetWeaponsAction

; 165  : 				break;

	jmp	$LN94@ReceiveOrd
$LN77@ReceiveOrd:

; 166  : 
; 167  : 			case FalconWingmanMsg::WMGiveWeaponsCheck:
; 168  : 				AiGiveWeaponsStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveWeaponsStatus@DigitalBrain@@AAEXXZ ; DigitalBrain::AiGiveWeaponsStatus

; 169  : 				break;

	jmp	$LN94@ReceiveOrd
$LN76@ReceiveOrd:

; 170  : 
; 171  : 			case FalconWingmanMsg::WMSmokeOn:
; 172  : 				AiSmokeOn(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSmokeOn

; 173  : 				break;

	jmp	$LN94@ReceiveOrd
$LN75@ReceiveOrd:

; 174  : 
; 175  : 			case FalconWingmanMsg::WMSmokeOff:
; 176  : 				AiSmokeOff(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSmokeOff

; 177  : 				break;

	jmp	$LN94@ReceiveOrd
$LN74@ReceiveOrd:

; 178  : 
; 179  :          case FalconWingmanMsg::WMJokerFuel:
; 180  :             edata[0] = isWing;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+24]
	mov	WORD PTR _edata$[ebp+ecx], ax

; 181  :             edata[1] = 0;

	mov	DWORD PTR $T2[ebp], 2
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN104@ReceiveOrd
	jmp	SHORT $LN105@ReceiveOrd
$LN104@ReceiveOrd:
	call	___report_rangecheckfailure
$LN105@ReceiveOrd:
	xor	ecx, ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+edx], cx

; 182  :            	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	337					; 00000151H
	mov	ecx, DWORD PTR _p_from$[ebp]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 183  :             if (!isWing)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN73@ReceiveOrd

; 184  :                FlightMemberWantsFuel(SaidJoker);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN73@ReceiveOrd:

; 185  :             break;

	jmp	$LN94@ReceiveOrd
$LN72@ReceiveOrd:

; 186  : 
; 187  :          case FalconWingmanMsg::WMBingoFuel:
; 188  :             edata[0] = isWing;

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+24]
	mov	WORD PTR _edata$[ebp+eax], dx

; 189  :             edata[1] = 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx

; 190  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	337					; 00000151H
	mov	eax, DWORD PTR _p_from$[ebp]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 191  :             if (!isWing)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN71@ReceiveOrd

; 192  :                FlightMemberWantsFuel(SaidBingo);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN71@ReceiveOrd:

; 193  :             break;

	jmp	$LN94@ReceiveOrd
$LN70@ReceiveOrd:

; 194  : 
; 195  :          case FalconWingmanMsg::WMFumes:
; 196  :             edata[0] = isWing;

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+24]
	mov	WORD PTR _edata$[ebp+edx], cx

; 197  :             edata[1] = 2;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax

; 198  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	337					; 00000151H
	mov	edx, DWORD PTR _p_from$[ebp]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 199  :             if (!isWing)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN69@ReceiveOrd

; 200  :                FlightMemberWantsFuel(SaidFumes);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN69@ReceiveOrd:

; 201  :             break;

	jmp	$LN94@ReceiveOrd
$LN68@ReceiveOrd:

; 202  : 
; 203  :          case FalconWingmanMsg::WMFlameout:
; 204  :             edata[0] = isWing;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+24]
	mov	WORD PTR _edata$[ebp+ecx], ax

; 205  :             edata[1] = 3;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 3
	mov	WORD PTR _edata$[ebp+ecx], dx

; 206  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	337					; 00000151H
	mov	ecx, DWORD PTR _p_from$[ebp]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 207  :             if (!isWing)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN67@ReceiveOrd

; 208  :                FlightMemberWantsFuel(SaidFlameout);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN67@ReceiveOrd:

; 209  :             break;

	jmp	$LN94@ReceiveOrd
$LN66@ReceiveOrd:

; 210  : 
; 211  : 			case FalconWingmanMsg::WMGlue:
; 212  : 				AiGlueWing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGlueWing@DigitalBrain@@AAEXXZ	; DigitalBrain::AiGlueWing

; 213  : 				break;

	jmp	$LN94@ReceiveOrd
$LN65@ReceiveOrd:

; 214  : 
; 215  : 			case FalconWingmanMsg::WMSplit:
; 216  : 				AiSplitWing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitWing@DigitalBrain@@AAEXXZ	; DigitalBrain::AiSplitWing

; 217  : 				break;

	jmp	$LN94@ReceiveOrd
$LN64@ReceiveOrd:

; 218  : 
; 219  : 			case FalconWingmanMsg::WMDropStores:
; 220  : 				AiDropStores(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiDropStores@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDropStores
$LN63@ReceiveOrd:

; 221  : 
; 222  : 			case FalconWingmanMsg::WMECMOn:
; 223  : 				AiECMOn(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiECMOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiECMOn

; 224  : 				break;

	jmp	$LN94@ReceiveOrd
$LN62@ReceiveOrd:

; 225  : 
; 226  : 			case FalconWingmanMsg::WMECMOff:
; 227  : 				AiECMOff(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiECMOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiECMOff

; 228  : 				break;

	jmp	$LN94@ReceiveOrd
$LN61@ReceiveOrd:

; 229  : 
; 230  : 			// 2002-03-15 ADDED BY S.G. BVR profiles that the player can send to his element
; 231  : 			case FalconWingmanMsg::WMPlevel1a:
; 232  : 			case FalconWingmanMsg::WMPlevel2a:
; 233  : 			case FalconWingmanMsg::WMPlevel3a:
; 234  : 			case FalconWingmanMsg::WMPlevel1b:
; 235  : 			case FalconWingmanMsg::WMPlevel2b:
; 236  : 			case FalconWingmanMsg::WMPlevel3b:
; 237  : 			case FalconWingmanMsg::WMPlevel1c:
; 238  : 			case FalconWingmanMsg::WMPlevel2c:
; 239  : 			case FalconWingmanMsg::WMPlevel3c:
; 240  : 			case FalconWingmanMsg::WMPbeamdeploy:
; 241  : 			case FalconWingmanMsg::WMPbeambeam:
; 242  : 			case FalconWingmanMsg::WMPwall:
; 243  : 			case FalconWingmanMsg::WMPgrinder:
; 244  : 			case FalconWingmanMsg::WMPwideazimuth:
; 245  : 			case FalconWingmanMsg::WMPshortazimuth:
; 246  : 			case FalconWingmanMsg::WMPwideLT:
; 247  : 			case FalconWingmanMsg::WMPShortLT:
; 248  : 			case FalconWingmanMsg::WMPDefensive:
; 249  : 				if (flightLead && ((AircraftClass *)flightLead)->DBrain())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN60@ReceiveOrd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	test	eax, eax
	je	SHORT $LN60@ReceiveOrd

; 250  : 					((AircraftClass *)flightLead)->DBrain()->SetBvrCurrProfile(BvrLookup[command - FalconWingmanMsg::WMPlevel1a]);

	mov	edx, DWORD PTR _command$[ebp]
	mov	eax, DWORD PTR ?BvrLookup@@3PAW4BVRProfileType@DigitalBrain@@A[edx*4-296]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetBvrCurrProfile@DigitalBrain@@QAEXW4BVRProfileType@1@@Z ; DigitalBrain::SetBvrCurrProfile
$LN60@ReceiveOrd:

; 251  : 
; 252  : 				fromIndex	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _fromIndex$[ebp], eax

; 253  : 				if(AiIsFullResponse(fromIndex, wingMsg->dataBlock.to)) {

	mov	edx, DWORD PTR _wingMsg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _fromIndex$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@ReceiveOrd

; 254  : 					edata[0] = fromIndex;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _fromIndex$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 255  : 					edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 256  : 					AiMakeRadioResponse( self, rcROGER, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	179					; 000000b3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 257  : 				}
; 258  : 				else

	jmp	SHORT $LN94@ReceiveOrd
$LN59@ReceiveOrd:

; 259  : 					AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN94@ReceiveOrd:

; 260  : 
; 261  : 				break;
; 262  : 			// END OF ADDED SECTION 2002-03-15
; 263  : 		}
; 264  : 	}
; 265  : 	else {

	jmp	$LN103@ReceiveOrd
$LN97@ReceiveOrd:

; 266  : 		switch(command) {

	mov	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv438[ebp], edx
	cmp	DWORD PTR tv438[ebp], 91		; 0000005bH
	ja	$LN103@ReceiveOrd
	mov	eax, DWORD PTR tv438[ebp]
	movzx	ecx, BYTE PTR $LN110@ReceiveOrd[eax]
	jmp	DWORD PTR $LN113@ReceiveOrd[ecx*4]
$LN54@ReceiveOrd:

; 267  : 
; 268  : 			// Other Commands
; 269  : 			case FalconWingmanMsg::WMPromote:
; 270  : 				AiPromote();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiPromote@DigitalBrain@@AAEXXZ		; DigitalBrain::AiPromote

; 271  : 				break;

	jmp	$LN103@ReceiveOrd
$LN53@ReceiveOrd:

; 272  : 	
; 273  : 			case FalconWingmanMsg::WMRadarOn:
; 274  : 				AiSetRadarActive(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetRadarActive@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetRadarActive

; 275  : 				break;

	jmp	$LN103@ReceiveOrd
$LN52@ReceiveOrd:

; 276  : 
; 277  : 			case FalconWingmanMsg::WMRadarStby:
; 278  : 				AiSetRadarStby(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetRadarStby@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetRadarStby

; 279  : 				break;

	jmp	$LN103@ReceiveOrd
$LN51@ReceiveOrd:

; 280  : 
; 281  : 			case FalconWingmanMsg::WMBuddySpike:
; 282  : 				AiBuddySpikeReact(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiBuddySpikeReact@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiBuddySpikeReact

; 283  : 				break;

	jmp	$LN103@ReceiveOrd
$LN50@ReceiveOrd:

; 284  : 
; 285  : 			case FalconWingmanMsg::WMRaygun:
; 286  : 				AiRaygun(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRaygun@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiRaygun

; 287  : 				break;

	jmp	$LN103@ReceiveOrd
$LN49@ReceiveOrd:

; 288  : 
; 289  : 			// Commands that change Action and Search States
; 290  : 			case FalconWingmanMsg::WMRTB:
; 291  : 				AiRTB(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRTB@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiRTB

; 292  : 				break;

	jmp	$LN103@ReceiveOrd
$LN48@ReceiveOrd:

; 293  : 
; 294  : 			case FalconWingmanMsg::WMClearSix:
; 295  : 				AiClearLeadersSix(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearLeadersSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiClearLeadersSix

; 296  : 				break;

	jmp	$LN103@ReceiveOrd
$LN47@ReceiveOrd:

; 297  : 
; 298  : 			case FalconWingmanMsg::WMCheckSix:
; 299  : 				AiCheckOwnSix(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckOwnSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiCheckOwnSix

; 300  : 				break;

	jmp	$LN103@ReceiveOrd
$LN46@ReceiveOrd:

; 301  : 
; 302  : 			case FalconWingmanMsg::WMBreakRight:
; 303  : 					AiBreakRight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiBreakRight@DigitalBrain@@AAEXXZ	; DigitalBrain::AiBreakRight

; 304  : 				break;

	jmp	$LN103@ReceiveOrd
$LN45@ReceiveOrd:

; 305  : 
; 306  : 			case FalconWingmanMsg::WMBreakLeft:
; 307  : 					AiBreakLeft();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiBreakLeft@DigitalBrain@@AAEXXZ	; DigitalBrain::AiBreakLeft

; 308  : 				break;

	jmp	$LN103@ReceiveOrd
$LN44@ReceiveOrd:

; 309  : 
; 310  : 			case FalconWingmanMsg::WMPosthole:
; 311  : 					AiInitPosthole(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiInitPosthole@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiInitPosthole

; 312  : 				break;

	jmp	$LN103@ReceiveOrd
$LN43@ReceiveOrd:

; 313  : 
; 314  : 
; 315  : 			case FalconWingmanMsg::WMSSOffset:
; 316  : 					AiInitSSOffset(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiInitSSOffset@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiInitSSOffset

; 317  : 				break;

	jmp	$LN103@ReceiveOrd
$LN42@ReceiveOrd:

; 318  : 
; 319  : 			case FalconWingmanMsg::WMPince:
; 320  : 					AiInitPince(wingMsg, TRUE);

	push	1
	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiInitPince@DigitalBrain@@AAEXPAVFalconWingmanMsg@@H@Z ; DigitalBrain::AiInitPince

; 321  : 				break;

	jmp	$LN103@ReceiveOrd
$LN41@ReceiveOrd:

; 322  : 
; 323  : 			case FalconWingmanMsg::WMChainsaw:
; 324  : 					AiInitChainsaw(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiInitChainsaw@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiInitChainsaw

; 325  : 				break;

	jmp	$LN103@ReceiveOrd
$LN40@ReceiveOrd:

; 326  : 
; 327  : 			case FalconWingmanMsg::WMFlex:
; 328  : 					AiInitFlex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiInitFlex@DigitalBrain@@AAEXXZ	; DigitalBrain::AiInitFlex

; 329  : 				break;

	jmp	$LN103@ReceiveOrd
$LN39@ReceiveOrd:

; 330  : 
; 331  : 
; 332  : 			case FalconWingmanMsg::WMShooterMode:
; 333  : 				AiGoShooter();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGoShooter@DigitalBrain@@AAEXXZ	; DigitalBrain::AiGoShooter

; 334  : 				break;

	jmp	$LN103@ReceiveOrd
$LN38@ReceiveOrd:

; 335  : 
; 336  : 			case FalconWingmanMsg::WMCoverMode:
; 337  : 				AiGoCover();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGoCover@DigitalBrain@@AAEXXZ		; DigitalBrain::AiGoCover

; 338  : 				break;

	jmp	$LN103@ReceiveOrd
$LN37@ReceiveOrd:

; 339  : 
; 340  : 
; 341  : 			case FalconWingmanMsg::WMSearchGround:
; 342  : 				AiSearchForTargets(DOMAIN_LAND);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSearchForTargets@DigitalBrain@@AAEXD@Z ; DigitalBrain::AiSearchForTargets

; 343  : 				break;

	jmp	$LN103@ReceiveOrd
$LN36@ReceiveOrd:

; 344  : 
; 345  : 
; 346  : 			case FalconWingmanMsg::WMSearchAir:
; 347  : 				AiSearchForTargets(DOMAIN_AIR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSearchForTargets@DigitalBrain@@AAEXD@Z ; DigitalBrain::AiSearchForTargets

; 348  : 				break;

	jmp	$LN103@ReceiveOrd
$LN35@ReceiveOrd:

; 349  : 
; 350  : 
; 351  : 			case FalconWingmanMsg::WMResumeNormal:
; 352  : 				AiResumeFlightPlan(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiResumeFlightPlan@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiResumeFlightPlan

; 353  : 				break;

	jmp	$LN103@ReceiveOrd
$LN34@ReceiveOrd:

; 354  : 
; 355  : 
; 356  : 			case FalconWingmanMsg::WMRejoin:
; 357  : 				AiRejoin(wingMsg, AI_REJOIN); // 2001-10-23 ADDED AI_REJOIN BY S.G. So the AI knows it comes from the lead

	push	2
	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z ; DigitalBrain::AiRejoin

; 358  : 				//underOrders = FALSE;
; 359  : 				break;

	jmp	$LN103@ReceiveOrd
$LN33@ReceiveOrd:

; 360  : 
; 361  : 			// Commands that affect mode basis
; 362  : 			case FalconWingmanMsg::WMAssignTarget:
; 363  : 			case FalconWingmanMsg::WMAssignGroup:
; 364  : 				AiDesignateTarget(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiDesignateTarget@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDesignateTarget

; 365  : 				break;

	jmp	$LN103@ReceiveOrd
$LN32@ReceiveOrd:

; 366  : 
; 367  : 
; 368  : 			case FalconWingmanMsg::WMWeaponsHold:
; 369  : 				AiSetWeaponsAction(wingMsg, AI_WEAPONS_HOLD);

	push	0
	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z ; DigitalBrain::AiSetWeaponsAction

; 370  : 				break;

	jmp	$LN103@ReceiveOrd
$LN31@ReceiveOrd:

; 371  : 
; 372  : 
; 373  : 			case FalconWingmanMsg::WMWeaponsFree:
; 374  : 				AiSetWeaponsAction(wingMsg, AI_WEAPONS_FREE);

	push	1
	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z ; DigitalBrain::AiSetWeaponsAction

; 375  : 				break;

	jmp	$LN103@ReceiveOrd
$LN30@ReceiveOrd:

; 376  : 
; 377  : 			// Commands that modify formation
; 378  : 			case FalconWingmanMsg::WMSpread:
; 379  : 			case FalconWingmanMsg::WMWedge:
; 380  : 			case FalconWingmanMsg::WMTrail:
; 381  : 			case FalconWingmanMsg::WMLadder:
; 382  : 			case FalconWingmanMsg::WMStack:
; 383  : 			case FalconWingmanMsg::WMResCell:
; 384  : 			case FalconWingmanMsg::WMBox:
; 385  : 			case FalconWingmanMsg::WMArrowHead:
; 386  : 			case FalconWingmanMsg::WMFluidFour:
; 387  : 			case FalconWingmanMsg::WMVic:
; 388  : 			case FalconWingmanMsg::WMFinger4:
; 389  : 			case FalconWingmanMsg::WMEchelon:
; 390  : 			case FalconWingmanMsg::WMForm1:
; 391  : 			case FalconWingmanMsg::WMForm2:
; 392  : 			case FalconWingmanMsg::WMForm3:
; 393  : 			case FalconWingmanMsg::WMForm4:
; 394  : 				AiSetFormation(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetFormation@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetFormation

; 395  : 				break;

	jmp	$LN103@ReceiveOrd
$LN29@ReceiveOrd:

; 396  : 
; 397  : 
; 398  : 			case FalconWingmanMsg::WMKickout:
; 399  : 				AiKickout(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiKickout@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiKickout

; 400  : 				break;

	jmp	$LN103@ReceiveOrd
$LN28@ReceiveOrd:

; 401  : 
; 402  : 
; 403  : 			case FalconWingmanMsg::WMCloseup:
; 404  : 				AiCloseup(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCloseup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiCloseup

; 405  : 				break;

	jmp	$LN103@ReceiveOrd
$LN27@ReceiveOrd:

; 406  : 
; 407  : 
; 408  : 			case FalconWingmanMsg::WMToggleSide:
; 409  : 				AiToggleSide();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiToggleSide@DigitalBrain@@AAEXXZ	; DigitalBrain::AiToggleSide

; 410  : 				break;

	jmp	$LN103@ReceiveOrd
$LN26@ReceiveOrd:

; 411  : 
; 412  : 
; 413  : 			case FalconWingmanMsg::WMIncreaseRelAlt:
; 414  : 				AiIncreaseRelativeAltitude();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiIncreaseRelativeAltitude@DigitalBrain@@AAEXXZ ; DigitalBrain::AiIncreaseRelativeAltitude

; 415  : 				break;

	jmp	$LN103@ReceiveOrd
$LN25@ReceiveOrd:

; 416  : 
; 417  : 
; 418  : 			case FalconWingmanMsg::WMDecreaseRelAlt:
; 419  : 				AiDecreaseRelativeAltitude();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiDecreaseRelativeAltitude@DigitalBrain@@AAEXXZ ; DigitalBrain::AiDecreaseRelativeAltitude

; 420  : 				break;

	jmp	$LN103@ReceiveOrd
$LN24@ReceiveOrd:

; 421  : 
; 422  : 
; 423  : 			// Transient Commands
; 424  : 			case FalconWingmanMsg::WMGiveBra:
; 425  : 				AiGiveBra(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveBra@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveBra

; 426  : 				break;

	jmp	$LN103@ReceiveOrd
$LN23@ReceiveOrd:

; 427  : 
; 428  : 
; 429  : 			case FalconWingmanMsg::WMGiveStatus:
; 430  : 				AiGiveStatus(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveStatus

; 431  : 				break;

	jmp	$LN103@ReceiveOrd
$LN22@ReceiveOrd:

; 432  : 
; 433  : 
; 434  : 			case FalconWingmanMsg::WMGiveDamageReport:
; 435  : 				AiGiveDamageReport(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveDamageReport@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveDamageReport

; 436  : 				break;

	jmp	$LN103@ReceiveOrd
$LN21@ReceiveOrd:

; 437  : 
; 438  : 
; 439  : 			case FalconWingmanMsg::WMGiveFuelState:
; 440  : 				AiGiveFuelStatus(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveFuelStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveFuelStatus

; 441  : 				break;

	jmp	$LN103@ReceiveOrd
$LN20@ReceiveOrd:

; 442  : 
; 443  : 
; 444  : 			case FalconWingmanMsg::WMGiveWeaponsCheck:
; 445  : 				AiGiveWeaponsStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGiveWeaponsStatus@DigitalBrain@@AAEXXZ ; DigitalBrain::AiGiveWeaponsStatus

; 446  : 				break;

	jmp	$LN103@ReceiveOrd
$LN19@ReceiveOrd:

; 447  : 
; 448  : 			case FalconWingmanMsg::WMSmokeOn:
; 449  : 				AiSmokeOn(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSmokeOn

; 450  : 				break;

	jmp	$LN103@ReceiveOrd
$LN18@ReceiveOrd:

; 451  : 
; 452  : 			case FalconWingmanMsg::WMSmokeOff:
; 453  : 				AiSmokeOff(wingMsg);

	mov	edx, DWORD PTR _wingMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSmokeOff

; 454  : 				break;

	jmp	$LN103@ReceiveOrd
$LN17@ReceiveOrd:

; 455  : 
; 456  : 			case FalconWingmanMsg::WMECMOn:
; 457  : 				AiECMOn(wingMsg);

	mov	eax, DWORD PTR _wingMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiECMOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiECMOn

; 458  : 				break;

	jmp	$LN103@ReceiveOrd
$LN16@ReceiveOrd:

; 459  : 
; 460  : 			case FalconWingmanMsg::WMECMOff:
; 461  : 				AiECMOff(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiECMOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiECMOff

; 462  : 				break;

	jmp	$LN103@ReceiveOrd
$LN15@ReceiveOrd:

; 463  : 
; 464  : 
; 465  :          case FalconWingmanMsg::WMJokerFuel:
; 466  :             edata[0] = isWing;

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+24]
	mov	WORD PTR _edata$[ebp+edx], cx

; 467  :             edata[1] = 0;

	mov	DWORD PTR $T3[ebp], 2
	cmp	DWORD PTR $T3[ebp], 20			; 00000014H
	jae	SHORT $LN106@ReceiveOrd
	jmp	SHORT $LN107@ReceiveOrd
$LN106@ReceiveOrd:
	call	___report_rangecheckfailure
$LN107@ReceiveOrd:
	xor	edx, edx
	mov	eax, DWORD PTR $T3[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx

; 468  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	337					; 00000151H
	mov	edx, DWORD PTR _p_from$[ebp]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 469  :             if (!isWing)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN14@ReceiveOrd

; 470  :                FlightMemberWantsFuel(SaidJoker);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN14@ReceiveOrd:

; 471  :             break;

	jmp	$LN103@ReceiveOrd
$LN13@ReceiveOrd:

; 472  : 
; 473  :          case FalconWingmanMsg::WMBingoFuel:
; 474  :             edata[0] = isWing;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+24]
	mov	WORD PTR _edata$[ebp+ecx], ax

; 475  :             edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 476  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	337					; 00000151H
	mov	ecx, DWORD PTR _p_from$[ebp]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 477  :             if (!isWing)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN12@ReceiveOrd

; 478  :                FlightMemberWantsFuel(SaidBingo);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN12@ReceiveOrd:

; 479  :             break;

	jmp	$LN103@ReceiveOrd
$LN11@ReceiveOrd:

; 480  : 
; 481  :          case FalconWingmanMsg::WMFumes:
; 482  :             edata[0] = isWing;

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+24]
	mov	WORD PTR _edata$[ebp+eax], dx

; 483  :             edata[1] = 2;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx

; 484  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	337					; 00000151H
	mov	eax, DWORD PTR _p_from$[ebp]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 485  :             if (!isWing)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN10@ReceiveOrd

; 486  :                FlightMemberWantsFuel(SaidFumes);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN10@ReceiveOrd:

; 487  :             break;

	jmp	$LN103@ReceiveOrd
$LN9@ReceiveOrd:

; 488  : 
; 489  :          case FalconWingmanMsg::WMFlameout:
; 490  :             edata[0] = isWing;

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+24]
	mov	WORD PTR _edata$[ebp+edx], cx

; 491  :             edata[1] = 3;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 3
	mov	WORD PTR _edata$[ebp+edx], ax

; 492  :          	AiMakeRadioResponse( p_from, rcFUELCRITICAL, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	337					; 00000151H
	mov	edx, DWORD PTR _p_from$[ebp]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 493  :             if (!isWing)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN8@ReceiveOrd

; 494  :                FlightMemberWantsFuel(SaidFlameout);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlightMemberWantsFuel@DigitalBrain@@QAEXH@Z ; DigitalBrain::FlightMemberWantsFuel
$LN8@ReceiveOrd:

; 495  :             break;

	jmp	$LN103@ReceiveOrd
$LN7@ReceiveOrd:

; 496  : 
; 497  : 			case FalconWingmanMsg::WMGlue:
; 498  : 				AiGlueWing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGlueWing@DigitalBrain@@AAEXXZ	; DigitalBrain::AiGlueWing

; 499  : 				break;

	jmp	$LN103@ReceiveOrd
$LN6@ReceiveOrd:

; 500  : 
; 501  : 			case FalconWingmanMsg::WMSplit:
; 502  : 				AiSplitWing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitWing@DigitalBrain@@AAEXXZ	; DigitalBrain::AiSplitWing

; 503  : 				break;

	jmp	$LN103@ReceiveOrd
$LN5@ReceiveOrd:

; 504  : 
; 505  : 			case FalconWingmanMsg::WMDropStores:
; 506  : 				AiDropStores(wingMsg);

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiDropStores@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDropStores
$LN4@ReceiveOrd:

; 507  : 
; 508  : 			// 2002-03-15 ADDED BY S.G. BVR profiles that the player can send to his element
; 509  : 			case FalconWingmanMsg::WMPlevel1a:
; 510  : 			case FalconWingmanMsg::WMPlevel2a:
; 511  : 			case FalconWingmanMsg::WMPlevel3a:
; 512  : 			case FalconWingmanMsg::WMPlevel1b:
; 513  : 			case FalconWingmanMsg::WMPlevel2b:
; 514  : 			case FalconWingmanMsg::WMPlevel3b:
; 515  : 			case FalconWingmanMsg::WMPlevel1c:
; 516  : 			case FalconWingmanMsg::WMPlevel2c:
; 517  : 			case FalconWingmanMsg::WMPlevel3c:
; 518  : 			case FalconWingmanMsg::WMPbeamdeploy:
; 519  : 			case FalconWingmanMsg::WMPbeambeam:
; 520  : 			case FalconWingmanMsg::WMPwall:
; 521  : 			case FalconWingmanMsg::WMPgrinder:
; 522  : 			case FalconWingmanMsg::WMPwideazimuth:
; 523  : 			case FalconWingmanMsg::WMPshortazimuth:
; 524  : 			case FalconWingmanMsg::WMPwideLT:
; 525  : 			case FalconWingmanMsg::WMPShortLT:
; 526  : 			case FalconWingmanMsg::WMPDefensive:
; 527  : 				if (flightLead && ((AircraftClass *)flightLead)->DBrain())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+708], 0
	je	SHORT $LN3@ReceiveOrd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	test	eax, eax
	je	SHORT $LN3@ReceiveOrd

; 528  : 					((AircraftClass *)flightLead)->DBrain()->SetBvrCurrProfile(BvrLookup[command - FalconWingmanMsg::WMPlevel1a]);

	mov	ecx, DWORD PTR _command$[ebp]
	mov	edx, DWORD PTR ?BvrLookup@@3PAW4BVRProfileType@DigitalBrain@@A[ecx*4-296]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetBvrCurrProfile@DigitalBrain@@QAEXW4BVRProfileType@1@@Z ; DigitalBrain::SetBvrCurrProfile
$LN3@ReceiveOrd:

; 529  : 
; 530  : 				fromIndex	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _fromIndex$[ebp], eax

; 531  : 				if(AiIsFullResponse(fromIndex, wingMsg->dataBlock.to)) {

	mov	ecx, DWORD PTR _wingMsg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _fromIndex$[ebp]
	push	eax
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@ReceiveOrd

; 532  : 					edata[0] = fromIndex;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _fromIndex$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 533  : 					edata[1] = 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx

; 534  : 					AiMakeRadioResponse( self, rcROGER, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	179					; 000000b3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 535  : 				}
; 536  : 				else

	jmp	SHORT $LN103@ReceiveOrd
$LN2@ReceiveOrd:

; 537  : 					AiRespondShortCallSign(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN103@ReceiveOrd:

; 538  : 
; 539  : 				break;
; 540  : 			// END OF ADDED SECTION 2002-03-15
; 541  : 		} // end switch
; 542  : 	}
; 543  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN111@ReceiveOrd:
	DD	$LN93@ReceiveOrd
	DD	$LN78@ReceiveOrd
	DD	$LN82@ReceiveOrd
	DD	$LN81@ReceiveOrd
	DD	$LN80@ReceiveOrd
	DD	$LN79@ReceiveOrd
	DD	$LN77@ReceiveOrd
	DD	$LN83@ReceiveOrd
	DD	$LN84@ReceiveOrd
	DD	$LN85@ReceiveOrd
	DD	$LN76@ReceiveOrd
	DD	$LN75@ReceiveOrd
	DD	$LN86@ReceiveOrd
	DD	$LN74@ReceiveOrd
	DD	$LN72@ReceiveOrd
	DD	$LN70@ReceiveOrd
	DD	$LN68@ReceiveOrd
	DD	$LN65@ReceiveOrd
	DD	$LN66@ReceiveOrd
	DD	$LN64@ReceiveOrd
	DD	$LN63@ReceiveOrd
	DD	$LN62@ReceiveOrd
	DD	$LN61@ReceiveOrd
	DD	$LN94@ReceiveOrd
$LN108@ReceiveOrd:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	0
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	7
	DB	8
	DB	9
	DB	23					; 00000017H
	DB	0
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	23					; 00000017H
	DB	19					; 00000013H
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
$LN112@ReceiveOrd:
	DD	$LN87@ReceiveOrd
	DD	$LN90@ReceiveOrd
	DD	$LN89@ReceiveOrd
	DD	$LN88@ReceiveOrd
	DD	$LN91@ReceiveOrd
$LN109@ReceiveOrd:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	npad	1
$LN113@ReceiveOrd:
	DD	$LN30@ReceiveOrd
	DD	$LN33@ReceiveOrd
	DD	$LN39@ReceiveOrd
	DD	$LN38@ReceiveOrd
	DD	$LN32@ReceiveOrd
	DD	$LN31@ReceiveOrd
	DD	$LN46@ReceiveOrd
	DD	$LN45@ReceiveOrd
	DD	$LN48@ReceiveOrd
	DD	$LN47@ReceiveOrd
	DD	$LN42@ReceiveOrd
	DD	$LN44@ReceiveOrd
	DD	$LN41@ReceiveOrd
	DD	$LN40@ReceiveOrd
	DD	$LN34@ReceiveOrd
	DD	$LN35@ReceiveOrd
	DD	$LN37@ReceiveOrd
	DD	$LN36@ReceiveOrd
	DD	$LN29@ReceiveOrd
	DD	$LN28@ReceiveOrd
	DD	$LN27@ReceiveOrd
	DD	$LN26@ReceiveOrd
	DD	$LN25@ReceiveOrd
	DD	$LN24@ReceiveOrd
	DD	$LN23@ReceiveOrd
	DD	$LN22@ReceiveOrd
	DD	$LN21@ReceiveOrd
	DD	$LN20@ReceiveOrd
	DD	$LN49@ReceiveOrd
	DD	$LN54@ReceiveOrd
	DD	$LN52@ReceiveOrd
	DD	$LN53@ReceiveOrd
	DD	$LN51@ReceiveOrd
	DD	$LN43@ReceiveOrd
	DD	$LN19@ReceiveOrd
	DD	$LN18@ReceiveOrd
	DD	$LN50@ReceiveOrd
	DD	$LN15@ReceiveOrd
	DD	$LN13@ReceiveOrd
	DD	$LN11@ReceiveOrd
	DD	$LN9@ReceiveOrd
	DD	$LN6@ReceiveOrd
	DD	$LN7@ReceiveOrd
	DD	$LN5@ReceiveOrd
	DD	$LN17@ReceiveOrd
	DD	$LN16@ReceiveOrd
	DD	$LN4@ReceiveOrd
	DD	$LN103@ReceiveOrd
$LN110@ReceiveOrd:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	47					; 0000002fH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	47					; 0000002fH
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	47					; 0000002fH
	DB	43					; 0000002bH
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
?ReceiveOrders@DigitalBrain@@UAEXPAVFalconEvent@@@Z ENDP ; DigitalBrain::ReceiveOrders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetBvrCurrProfile@DigitalBrain@@QAEXW4BVRProfileType@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newProfile$ = 8					; size = 4
?SetBvrCurrProfile@DigitalBrain@@QAEXW4BVRProfileType@1@@Z PROC ; DigitalBrain::SetBvrCurrProfile, COMDAT
; _this$ = ecx

; 643  : 	void SetBvrCurrProfile(BVRProfileType newProfile) { bvrCurrProfile = newProfile; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newProfile$[ebp]
	mov	DWORD PTR [eax+632], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBvrCurrProfile@DigitalBrain@@QAEXW4BVRProfileType@1@@Z ENDP ; DigitalBrain::SetBvrCurrProfile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?EntityId@VuMessage@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?EntityId@VuMessage@@QBE?AVVU_ID@@XZ PROC		; VuMessage::EntityId, COMDAT
; _this$ = ecx

; 157  : 	VU_ID EntityId() const { return entityId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityId@VuMessage@@QBE?AVVU_ID@@XZ ENDP		; VuMessage::EntityId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
