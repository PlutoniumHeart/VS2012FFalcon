; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\landme.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_PreFlightTable DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	09H
	DD	00H
	DD	01H
	DD	00H
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:?EngineStart@@YAHPAVAircraftClass@@@Z
	DD	04H
	DD	00H
	DD	01H
	DD	00H
	DD	05H
	DD	0800H
	DD	06H
	DD	00H
	DD	05H
	DD	04H
	DD	02H
	DD	00H
	DD	05H
	DD	02H
	DD	01H
	DD	00H
	DD	05H
	DD	01H
	DD	01H
	DD	00H
	DD	05H
	DD	08H
	DD	01H
	DD	00H
	DD	05H
	DD	0400H
	DD	03H
	DD	00H
	DD	05H
	DD	0200H
	DD	01H
	DD	00H
	DD	05H
	DD	080H
	DD	01H
	DD	00H
	DD	05H
	DD	0100H
	DD	01H
	DD	00H
	DD	05H
	DD	010H
	DD	01H
	DD	00H
	DD	05H
	DD	020H
	DD	01H
	DD	00H
	DD	05H
	DD	040H
	DD	01H
	DD	00H
	DD	05H
	DD	020000H
	DD	01H
	DD	00H
	DD	07H
	DD	00H
	DD	01H
	DD	00H
	DD	05H
	DD	01000H
	DD	02H
	DD	00H
	DD	05H
	DD	02000H
	DD	02H
	DD	00H
	DD	05H
	DD	04000H
	DD	02H
	DD	00H
	DD	05H
	DD	08000H
	DD	02H
	DD	00H
	DD	05H
	DD	0200000H
	DD	02H
	DD	00H
	DD	0aH
	DD	00H
	DD	01H
	DD	00H
	DD	0cH
	DD	04H
	DD	01H
	DD	00H
	DD	0cH
	DD	010H
	DD	01H
	DD	00H
	DD	0cH
	DD	08H
	DD	01H
	DD	00H
	DD	0cH
	DD	040H
	DD	01H
	DD	00H
	DD	0dH
	DD	02H
	DD	01e5H
	DD	00H
	DD	0dH
	DD	020H
	DD	00H
	DD	00H
	DD	0eH
	DD	01H
	DD	01H
	DD	00H
	DD	0eH
	DD	02H
	DD	01H
	DD	00H
	DD	06H
	DD	0400000H
	DD	03H
	DD	00H
	DD	0bH
	DD	00H
	DD	01H
	DD	00H
	DD	08H
	DD	00H
	DD	01H
	DD	00H
	DD	0fH
	DD	00H
	DD	01H
	DD	00H
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::OwnerId
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	?GetRunwayStats@ATCBrain@@QAEPAUrunwayStatsStruct@@XZ ; ATCBrain::GetRunwayStats
PUBLIC	?MinDeagTime@ATCBrain@@QAEKXZ			; ATCBrain::MinDeagTime
PUBLIC	?IsAtFirstTaxipoint@DigitalBrain@@QAEHXZ	; DigitalBrain::IsAtFirstTaxipoint
PUBLIC	?Land@DigitalBrain@@IAEXXZ			; DigitalBrain::Land
PUBLIC	?TakeOff@DigitalBrain@@IAEXXZ			; DigitalBrain::TakeOff
PUBLIC	?PreFlight@DigitalBrain@@IAEHXZ			; DigitalBrain::PreFlight
PUBLIC	?QuickPreFlight@DigitalBrain@@IAEXXZ		; DigitalBrain::QuickPreFlight
PUBLIC	?TaxiBack@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ; DigitalBrain::TaxiBack
PUBLIC	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
PUBLIC	?CheckPoint@DigitalBrain@@IAEPAVSimBaseClass@@MM@Z ; DigitalBrain::CheckPoint
PUBLIC	?CheckTaxiCollision@DigitalBrain@@IAEHXZ	; DigitalBrain::CheckTaxiCollision
PUBLIC	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z	; DigitalBrain::SimpleGroundTrack
PUBLIC	?FindParkingSpot@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ; DigitalBrain::FindParkingSpot
PUBLIC	?CloseToTrackPoint@DigitalBrain@@IAE_NXZ	; DigitalBrain::CloseToTrackPoint
PUBLIC	?AtFinalTaxiPoint@DigitalBrain@@IAE_NXZ		; DigitalBrain::AtFinalTaxiPoint
PUBLIC	?BestParkSpot@DigitalBrain@@IAEHPAVObjectiveClass@@@Z ; DigitalBrain::BestParkSpot
PUBLIC	?RandomStuff@DigitalBrain@@IAEXPAVSimBaseClass@@@Z ; DigitalBrain::RandomStuff
PUBLIC	?SetDebugLabel@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::SetDebugLabel
PUBLIC	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z	; DigitalBrain::CalcWaitTime
PUBLIC	?ResetTaxiState@DigitalBrain@@QAEXXZ		; DigitalBrain::ResetTaxiState
PUBLIC	?SetTaxiPoint@DigitalBrain@@QAEXH@Z		; DigitalBrain::SetTaxiPoint
PUBLIC	?GetTaxiPoint@DigitalBrain@@QAEHXZ		; DigitalBrain::GetTaxiPoint
PUBLIC	?UpdateTaxipoint@DigitalBrain@@QAEXXZ		; DigitalBrain::UpdateTaxipoint
PUBLIC	?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ ; DigitalBrain::GetLeader
PUBLIC	?FindDesiredTaxiPoint@DigitalBrain@@QAEHKH@Z	; DigitalBrain::FindDesiredTaxiPoint
PUBLIC	?FindDesiredTaxiPoint@DigitalBrain@@QAEHK@Z	; DigitalBrain::FindDesiredTaxiPoint
PUBLIC	?SetTrackPoint@DigitalBrain@@QAEXMM@Z		; DigitalBrain::SetTrackPoint
PUBLIC	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z		; DigitalBrain::SetTrackPoint
PUBLIC	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint
PUBLIC	?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z ; DigitalBrain::DealWithBlocker
PUBLIC	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z ; DigitalBrain::WingmanTakeRunway
PUBLIC	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@@Z ; DigitalBrain::WingmanTakeRunway
PUBLIC	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z	; DigitalBrain::OffsetTrackPoint
PUBLIC	?SetATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::SetATCFlag
PUBLIC	?ClearATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::ClearATCFlag
PUBLIC	?IsSetATC@DigitalBrain@@QAEHH@Z			; DigitalBrain::IsSetATC
PUBLIC	?ResetATC@DigitalBrain@@QAEXXZ			; DigitalBrain::ResetATC
PUBLIC	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
PUBLIC	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus
PUBLIC	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
PUBLIC	?RwTime@DigitalBrain@@QAEKXZ			; DigitalBrain::RwTime
PUBLIC	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ	; DigitalBrain::CalculateNextTurnDistance
PUBLIC	?ReadyToGo@DigitalBrain@@QAEHXZ			; DigitalBrain::ReadyToGo
PUBLIC	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z	; DigitalBrain::CalculateTaxiSpeed
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?SetSwitch@SimMoverClass@@QAEXHH@Z		; SimMoverClass::SetSwitch
PUBLIC	?GetSwitch@SimMoverClass@@QAEHH@Z		; SimMoverClass::GetSwitch
PUBLIC	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z	; AircraftClass::IsAcStatusBitsSet
PUBLIC	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn
PUBLIC	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
PUBLIC	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z	; AircraftClass::INSOn
PUBLIC	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z	; AircraftClass::INSOff
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	?RaltOn@AircraftClass@@QAEXXZ			; AircraftClass::RaltOn
PUBLIC	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn
PUBLIC	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
PUBLIC	?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ; AircraftClass::MainPower
PUBLIC	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z	; AircraftClass::SetPGM
PUBLIC	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ	; AircraftClass::DBrain
PUBLIC	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
PUBLIC	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
PUBLIC	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
PUBLIC	?GetNumberEngines@AirframeClass@@QAEHXZ		; AirframeClass::GetNumberEngines
PUBLIC	?HasDragChute@AirframeClass@@QAE_NXZ		; AirframeClass::HasDragChute
PUBLIC	?DragChuteMaxSpeed@AirframeClass@@QAEMXZ	; AirframeClass::DragChuteMaxSpeed
PUBLIC	?HasThrRev@AirframeClass@@QAEHXZ		; AirframeClass::HasThrRev
PUBLIC	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
PUBLIC	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag
PUBLIC	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag
PUBLIC	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch
PUBLIC	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z	; AirframeClass::SetFuelPump
PUBLIC	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource
PUBLIC	?SetThrotl@AirframeClass@@QAEXM@Z		; AirframeClass::SetThrotl
PUBLIC	?MinVcas@AirframeClass@@QAEMXZ			; AirframeClass::MinVcas
PUBLIC	?MaxVcas@AirframeClass@@QAEMXZ			; AirframeClass::MaxVcas
PUBLIC	?CornerVcas@AirframeClass@@QAEMXZ		; AirframeClass::CornerVcas
PUBLIC	?Fuel@AirframeClass@@QAEMXZ			; AirframeClass::Fuel
PUBLIC	?SetFlag@AirframeClass@@QAEXH@Z			; AirframeClass::SetFlag
PUBLIC	?ClearFlag@AirframeClass@@QAEXH@Z		; AirframeClass::ClearFlag
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?GetSimpleMode@AirframeClass@@QAEHXZ		; AirframeClass::GetSimpleMode
PUBLIC	?GetLandingAoASpd@AirframeClass@@QAEMXZ		; AirframeClass::GetLandingAoASpd
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
PUBLIC	?Radius@DrawableObject@@QBEMXZ			; DrawableObject::Radius
PUBLIC	?LabelColor@DrawableBSP@@QAEKXZ			; DrawableBSP::LabelColor
PUBLIC	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm
PUBLIC	?SetICPFlag@ICPClass@@QAEXH@Z			; ICPClass::SetICPFlag
PUBLIC	?SetICPSecondaryMode@ICPClass@@QAEXH@Z		; ICPClass::SetICPSecondaryMode
PUBLIC	?GetLightLevel@CTimeOfDay@@QAEMXZ		; CTimeOfDay::GetLightLevel
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDFloatPos@@YAMXZ				; PRANDFloatPos
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_C@_0CA@GLBKACGL@Speed?3?5?$CFd?5kts?0?5PointDist?3?5?$CFd?5ft?$AA@ ; `string'
PUBLIC	??_C@_0BC@OBEDLAHJ@TaxiPt?5?$CFd?0?5type?3?5?$AA@ ; `string'
PUBLIC	??_C@_0M@PPBOKGPO@SmallParkPt?$AA@		; `string'
PUBLIC	??_C@_0M@NKALPJKJ@LargeParkPt?$AA@		; `string'
PUBLIC	??_C@_09GFOPPOAM@TakeoffPt?$AA@			; `string'
PUBLIC	??_C@_08PJMGDEDN@RunwayPt?$AA@			; `string'
PUBLIC	??_C@_06NOMCLABP@TaxiPt?$AA@			; `string'
PUBLIC	??_C@_0L@ENOFFMFD@CritTaxiPt?$AA@		; `string'
PUBLIC	??_C@_0N@COEEMFNJ@TakeRunwayPt?$AA@		; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@392c987a
PUBLIC	__real@3c8efa34
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3d56a98a
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e2cd59c
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f19999a
PUBLIC	__real@3f266666
PUBLIC	__real@3f30a3d7
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f5f66f1
PUBLIC	__real@3f7f064f
PUBLIC	__real@3f7f7cee
PUBLIC	__real@3f800000
PUBLIC	__real@3f8ccccd
PUBLIC	__real@3f99999a
PUBLIC	__real@3f9c61a9
PUBLIC	__real@3fa00000
PUBLIC	__real@3fb2b8c1
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3fd80b03
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@4050e0dc3c000000
PUBLIC	__real@40a00000
PUBLIC	__real@40c90fd9
PUBLIC	__real@40c90fdb
PUBLIC	__real@41000000
PUBLIC	__real@410706e2
PUBLIC	__real@41200000
PUBLIC	__real@41428963
PUBLIC	__real@41700000
PUBLIC	__real@418706e2
PUBLIC	__real@419c0000
PUBLIC	__real@41a00000
PUBLIC	__real@420706e2
PUBLIC	__real@42200000
PUBLIC	__real@42220842
PUBLIC	__real@42480000
PUBLIC	__real@424a8a53
PUBLIC	__real@426c4c0b
PUBLIC	__real@42700000
PUBLIC	__real@428706e2
PUBLIC	__real@42960000
PUBLIC	__real@42a00000
PUBLIC	__real@42a8c89a
PUBLIC	__real@42c80000
PUBLIC	__real@42ca8a53
PUBLIC	__real@42f00000
PUBLIC	__real@4328c89a
PUBLIC	__real@43480000
PUBLIC	__real@43870000
PUBLIC	__real@43960000
PUBLIC	__real@43c80000
PUBLIC	__real@43fa0000
PUBLIC	__real@447a0000
PUBLIC	__real@453b8000
PUBLIC	__real@45610000
PUBLIC	__real@457a0000
PUBLIC	__real@45bb8000
PUBLIC	__real@45c80000
PUBLIC	__real@46610000
PUBLIC	__real@468e6944
PUBLIC	__real@471c4000
PUBLIC	__real@476d5a1c
PUBLIC	__real@477fff00
PUBLIC	__real@48320395
PUBLIC	__real@48742400
PUBLIC	__real@4a095440
PUBLIC	__real@4a742400
PUBLIC	__real@4b095440
PUBLIC	__real@4b0cd705
PUBLIC	__real@4c0cd705
PUBLIC	__real@502bec79
PUBLIC	__real@50bd75c0
PUBLIC	__real@50eb3111
PUBLIC	__real@8000000000000000
PUBLIC	__real@bc8a1142
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0490fdb
PUBLIC	__real@c1a00000
PUBLIC	__real@c2480000
PUBLIC	__real@c3480000
PUBLIC	__real@c4fa0000
PUBLIC	__real@c5bde1b0
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_sprintf:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z:PROC ; VuGridIterator::VuGridIterator
EXTRN	??1VuGridIterator@@UAE@XZ:PROC			; VuGridIterator::~VuGridIterator
EXTRN	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetFirst
EXTRN	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetNext
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z:PROC ; ATCBrain::RequestEmerClearance
EXTRN	?GetOppositeRunway@ATCBrain@@QAEHH@Z:PROC	; ATCBrain::GetOppositeRunway
EXTRN	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z:PROC	; ATCBrain::FindBestTakeoffRunway
EXTRN	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z:PROC ; ATCBrain::FindBestLandingRunway
EXTRN	?FindAbortPt@ATCBrain@@QAEXPAVAircraftClass@@PAM11@Z:PROC ; ATCBrain::FindAbortPt
EXTRN	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z:PROC ; ATCBrain::FindTakeoffPt
EXTRN	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z:PROC ; ATCBrain::FindRunwayPt
EXTRN	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z:PROC ; ATCBrain::FindFinalPt
EXTRN	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z:PROC ; ATCBrain::FindBasePt
EXTRN	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z:PROC ; ATCBrain::FindFirstLegPt
EXTRN	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z:PROC ; ATCBrain::DetermineAngle
EXTRN	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z:PROC ; ATCBrain::GetAltitude
EXTRN	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z:PROC ; ATCBrain::CalculateMinMaxTime
EXTRN	?IsOnRunway@ATCBrain@@QAEHMM@Z:PROC		; ATCBrain::IsOnRunway
EXTRN	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z:PROC ; ATCBrain::IsOnRunway
EXTRN	?IsOnRunway@ATCBrain@@QAEHH@Z:PROC		; ATCBrain::IsOnRunway
EXTRN	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z:PROC ; ATCBrain::UseSectionTakeoff
EXTRN	?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z:PROC ; CheckTaxiPointGlobal
EXTRN	?Loiter@DigitalBrain@@IAEXXZ:PROC		; DigitalBrain::Loiter
EXTRN	?GoToCurrentWaypoint@DigitalBrain@@IAEXXZ:PROC	; DigitalBrain::GoToCurrentWaypoint
EXTRN	?SelectNextWaypoint@DigitalBrain@@IAEXXZ:PROC	; DigitalBrain::SelectNextWaypoint
EXTRN	?SelectGroundWeapon@DigitalBrain@@IAEXXZ:PROC	; DigitalBrain::SelectGroundWeapon
EXTRN	?SimpleTrack@DigitalBrain@@IAEXW4SimpleTrackMode@1@M@Z:PROC ; DigitalBrain::SimpleTrack
EXTRN	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z:PROC ; DigitalBrain::SimpleTrackAzimuth
EXTRN	?SimpleGoToCurrentWaypoint@DigitalBrain@@IAEXXZ:PROC ; DigitalBrain::SimpleGoToCurrentWaypoint
EXTRN	?SimpleGroundTrackSpeed@DigitalBrain@@IAEMM@Z:PROC ; DigitalBrain::SimpleGroundTrackSpeed
EXTRN	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z:PROC	; DigitalBrain::SetMaxRollDelta
EXTRN	?TrackPoint@DigitalBrain@@IAEMMM@Z:PROC		; DigitalBrain::TrackPoint
EXTRN	?TrackPointLanding@DigitalBrain@@IAEMM@Z:PROC	; DigitalBrain::TrackPointLanding
EXTRN	?MyWingman@DigitalBrain@@QAEPAVSimBaseClass@@XZ:PROC ; DigitalBrain::MyWingman
EXTRN	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z:PROC ; DigitalBrain::AiRejoin
EXTRN	?SetAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::SetAcStatusBits
EXTRN	?ClearAcStatusBits@AircraftClass@@QAEXH@Z:PROC	; AircraftClass::ClearAcStatusBits
EXTRN	?SwitchINSToAlign@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SwitchINSToAlign
EXTRN	?SwitchINSToNav@AircraftClass@@QAEXXZ:PROC	; AircraftClass::SwitchINSToNav
EXTRN	?HomeAirbase@AircraftClass@@QAE?AVVU_ID@@XZ:PROC ; AircraftClass::HomeAirbase
EXTRN	?LandingAirbase@AircraftClass@@QAE?AVVU_ID@@XZ:PROC ; AircraftClass::LandingAirbase
EXTRN	?DivertAirbase@AircraftClass@@QAE?AVVU_ID@@XZ:PROC ; AircraftClass::DivertAirbase
EXTRN	?PreFlight@AircraftClass@@QAEXXZ:PROC		; AircraftClass::PreFlight
EXTRN	?IncMainPower@AircraftClass@@QAEXXZ:PROC	; AircraftClass::IncMainPower
EXTRN	?DecMainPower@AircraftClass@@QAEXXZ:PROC	; AircraftClass::DecMainPower
EXTRN	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z:PROC ; CampBaseClass::GetComponentIndex
EXTRN	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentNumber
EXTRN	?NumberOfComponents@CampBaseClass@@QAEHXZ:PROC	; CampBaseClass::NumberOfComponents
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?FindNearbyAirbase@@YAPAVObjectiveClass@@FF@Z:PROC ; FindNearbyAirbase
EXTRN	?FindNearestFriendlyRunway@@YAPAVObjectiveClass@@EFF@Z:PROC ; FindNearestFriendlyRunway
EXTRN	?GridToSim@@YAMF@Z:PROC				; GridToSim
EXTRN	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z:PROC	; ConvertSimToGrid
EXTRN	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconRadioChatterMessage::FalconRadioChatterMessage
EXTRN	?ConvertWingNumberToCallNumber@@YAFH@Z:PROC	; ConvertWingNumberToCallNumber
EXTRN	??0FalconATCMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconATCMessage::FalconATCMessage
EXTRN	?TEFClose@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFClose
EXTRN	?TEFTakeoff@AirframeClass@@QAEXXZ:PROC		; AirframeClass::TEFTakeoff
EXTRN	?LEFClose@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFClose
EXTRN	?LEFTakeoff@AirframeClass@@QAEXXZ:PROC		; AirframeClass::LEFTakeoff
EXTRN	?CanopyToggle@AirframeClass@@QAEXXZ:PROC	; AirframeClass::CanopyToggle
EXTRN	?JfsEngineStart@AirframeClass@@QAEXXZ:PROC	; AirframeClass::JfsEngineStart
EXTRN	?CalcDesSpeed@AirframeClass@@QAEMM@Z:PROC	; AirframeClass::CalcDesSpeed
EXTRN	?CalcTASfromCAS@AirframeClass@@QAEMM@Z:PROC	; AirframeClass::CalcTASfromCAS
EXTRN	?GetParkType@AirframeClass@@QAEHXZ:PROC		; AirframeClass::GetParkType
EXTRN	?GetTaxiPosition@@YAHHH@Z:PROC			; GetTaxiPosition
EXTRN	?GetFirstPt@@YAHH@Z:PROC			; GetFirstPt
EXTRN	?GetNextPt@@YAHH@Z:PROC				; GetNextPt
EXTRN	?GetNextTaxiPt@@YAHH@Z:PROC			; GetNextTaxiPt
EXTRN	?GetNextPtLoop@@YAHH@Z:PROC			; GetNextPtLoop
EXTRN	?GetPrevTaxiPt@@YAHH@Z:PROC			; GetPrevTaxiPt
EXTRN	?GetPrevPtLoop@@YAHH@Z:PROC			; GetPrevPtLoop
EXTRN	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z:PROC ; TranslatePointData
EXTRN	?GetQueue@@YAHH@Z:PROC				; GetQueue
EXTRN	?GetNextParkTypePt@@YAHHH@Z:PROC		; GetNextParkTypePt
EXTRN	?GetPilotVoiceID@FlightClass@@QAEEH@Z:PROC	; FlightClass::GetPilotVoiceID
EXTRN	?RegroupAircraft@@YAXPAVAircraftClass@@@Z:PROC	; RegroupAircraft
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?GetMEA@TMap@@QAEMMM@Z:PROC			; TMap::GetMEA
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?ClearStrings@ICPClass@@QAEXXZ:PROC		; ICPClass::ClearStrings
EXTRN	?LeaveCNI@ICPClass@@QAEXXZ:PROC			; ICPClass::LeaveCNI
EXTRN	?ChangeToCNI@ICPClass@@QAEXXZ:PROC		; ICPClass::ChangeToCNI
EXTRN	?InitialiseInstruments@CockpitManager@@QAEXXZ:PROC ; CockpitManager::InitialiseInstruments
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?PtHeaderDataTable@@3PAUPtHeaderDataType@@A:DWORD ; PtHeaderDataTable
EXTRN	?PtDataTable@@3PAUPtDataType@@A:DWORD		; PtDataTable
EXTRN	?RealUnitProxList@@3PAVVuGridTree@@A:DWORD	; RealUnitProxList
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?TheMap@@3VTMap@@A:BYTE				; TheMap
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?TheTimeOfDay@@3VCTimeOfDay@@A:BYTE		; TheTimeOfDay
EXTRN	?gameCompressionRatio@@3HA:DWORD		; gameCompressionRatio
EXTRN	?g_nReagTimer@@3HA:DWORD			; g_nReagTimer
EXTRN	?g_nShowDebugLabels@@3HA:DWORD			; g_nShowDebugLabels
EXTRN	?g_fTaxiEarly@@3MA:DWORD			; g_fTaxiEarly
EXTRN	?g_nTaxiLaunchTime@@3HA:DWORD			; g_nTaxiLaunchTime
EXTRN	?g_bMPFix@@3_NA:BYTE				; g_bMPFix
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c5bde1b0
CONST	SEGMENT
__real@c5bde1b0 DD 0c5bde1b0r			; -6076.21
CONST	ENDS
;	COMDAT __real@c4fa0000
CONST	SEGMENT
__real@c4fa0000 DD 0c4fa0000r			; -2000
CONST	ENDS
;	COMDAT __real@c3480000
CONST	SEGMENT
__real@c3480000 DD 0c3480000r			; -200
CONST	ENDS
;	COMDAT __real@c2480000
CONST	SEGMENT
__real@c2480000 DD 0c2480000r			; -50
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bc8a1142
CONST	SEGMENT
__real@bc8a1142 DD 0bc8a1142r			; -0.0168539
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@50eb3111
CONST	SEGMENT
__real@50eb3111 DD 050eb3111r			; 3.15669e+010
CONST	ENDS
;	COMDAT __real@50bd75c0
CONST	SEGMENT
__real@50bd75c0 DD 050bd75c0r			; 2.54289e+010
CONST	ENDS
;	COMDAT __real@502bec79
CONST	SEGMENT
__real@502bec79 DD 0502bec79r			; 1.15376e+010
CONST	ENDS
;	COMDAT __real@4c0cd705
CONST	SEGMENT
__real@4c0cd705 DD 04c0cd705r			; 3.69203e+007
CONST	ENDS
;	COMDAT __real@4b0cd705
CONST	SEGMENT
__real@4b0cd705 DD 04b0cd705r			; 9.23009e+006
CONST	ENDS
;	COMDAT __real@4b095440
CONST	SEGMENT
__real@4b095440 DD 04b095440r			; 9e+006
CONST	ENDS
;	COMDAT __real@4a742400
CONST	SEGMENT
__real@4a742400 DD 04a742400r			; 4e+006
CONST	ENDS
;	COMDAT __real@4a095440
CONST	SEGMENT
__real@4a095440 DD 04a095440r			; 2.25e+006
CONST	ENDS
;	COMDAT __real@48742400
CONST	SEGMENT
__real@48742400 DD 048742400r			; 250000
CONST	ENDS
;	COMDAT __real@48320395
CONST	SEGMENT
__real@48320395 DD 048320395r			; 182286
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@476d5a1c
CONST	SEGMENT
__real@476d5a1c DD 0476d5a1cr			; 60762.1
CONST	ENDS
;	COMDAT __real@471c4000
CONST	SEGMENT
__real@471c4000 DD 0471c4000r			; 40000
CONST	ENDS
;	COMDAT __real@468e6944
CONST	SEGMENT
__real@468e6944 DD 0468e6944r			; 18228.6
CONST	ENDS
;	COMDAT __real@46610000
CONST	SEGMENT
__real@46610000 DD 046610000r			; 14400
CONST	ENDS
;	COMDAT __real@45c80000
CONST	SEGMENT
__real@45c80000 DD 045c80000r			; 6400
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@457a0000
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@45610000
CONST	SEGMENT
__real@45610000 DD 045610000r			; 3600
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@43870000
CONST	SEGMENT
__real@43870000 DD 043870000r			; 270
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@4328c89a
CONST	SEGMENT
__real@4328c89a DD 04328c89ar			; 168.784
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42ca8a53
CONST	SEGMENT
__real@42ca8a53 DD 042ca8a53r			; 101.27
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42a8c89a
CONST	SEGMENT
__real@42a8c89a DD 042a8c89ar			; 84.3918
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42960000
CONST	SEGMENT
__real@42960000 DD 042960000r			; 75
CONST	ENDS
;	COMDAT __real@428706e2
CONST	SEGMENT
__real@428706e2 DD 0428706e2r			; 67.5134
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@426c4c0b
CONST	SEGMENT
__real@426c4c0b DD 0426c4c0br			; 59.0743
CONST	ENDS
;	COMDAT __real@424a8a53
CONST	SEGMENT
__real@424a8a53 DD 0424a8a53r			; 50.6351
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42220842
CONST	SEGMENT
__real@42220842 DD 042220842r			; 40.5081
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@420706e2
CONST	SEGMENT
__real@420706e2 DD 0420706e2r			; 33.7567
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@419c0000
CONST	SEGMENT
__real@419c0000 DD 0419c0000r			; 19.5
CONST	ENDS
;	COMDAT __real@418706e2
CONST	SEGMENT
__real@418706e2 DD 0418706e2r			; 16.8784
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41428963
CONST	SEGMENT
__real@41428963 DD 041428963r			; 12.1585
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@410706e2
CONST	SEGMENT
__real@410706e2 DD 0410706e2r			; 8.43918
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4050e0dc3c000000
CONST	SEGMENT
__real@4050e0dc3c000000 DQ 04050e0dc3c000000r	; 67.5134
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fd80b03
CONST	SEGMENT
__real@3fd80b03 DD 03fd80b03r			; 1.68784
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb2b8c1
CONST	SEGMENT
__real@3fb2b8c1 DD 03fb2b8c1r			; 1.39626
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f9c61a9
CONST	SEGMENT
__real@3f9c61a9 DD 03f9c61a9r			; 1.22173
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7f7cee
CONST	SEGMENT
__real@3f7f7cee DD 03f7f7ceer			; 0.998
CONST	ENDS
;	COMDAT __real@3f7f064f
CONST	SEGMENT
__real@3f7f064f DD 03f7f064fr			; 0.99619
CONST	ENDS
;	COMDAT __real@3f5f66f1
CONST	SEGMENT
__real@3f5f66f1 DD 03f5f66f1r			; 0.872665
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f30a3d7
CONST	SEGMENT
__real@3f30a3d7 DD 03f30a3d7r			; 0.69
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@3e2cd59c
CONST	SEGMENT
__real@3e2cd59c DD 03e2cd59cr			; 0.168784
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3d56a98a
CONST	SEGMENT
__real@3d56a98a DD 03d56a98ar			; 0.0524078
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@392c987a
CONST	SEGMENT
__real@392c987a DD 0392c987ar			; 0.0001646
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@COEEMFNJ@TakeRunwayPt?$AA@
CONST	SEGMENT
??_C@_0N@COEEMFNJ@TakeRunwayPt?$AA@ DB 'TakeRunwayPt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ENOFFMFD@CritTaxiPt?$AA@
CONST	SEGMENT
??_C@_0L@ENOFFMFD@CritTaxiPt?$AA@ DB 'CritTaxiPt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOMCLABP@TaxiPt?$AA@
CONST	SEGMENT
??_C@_06NOMCLABP@TaxiPt?$AA@ DB 'TaxiPt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJMGDEDN@RunwayPt?$AA@
CONST	SEGMENT
??_C@_08PJMGDEDN@RunwayPt?$AA@ DB 'RunwayPt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GFOPPOAM@TakeoffPt?$AA@
CONST	SEGMENT
??_C@_09GFOPPOAM@TakeoffPt?$AA@ DB 'TakeoffPt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKALPJKJ@LargeParkPt?$AA@
CONST	SEGMENT
??_C@_0M@NKALPJKJ@LargeParkPt?$AA@ DB 'LargeParkPt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PPBOKGPO@SmallParkPt?$AA@
CONST	SEGMENT
??_C@_0M@PPBOKGPO@SmallParkPt?$AA@ DB 'SmallParkPt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OBEDLAHJ@TaxiPt?5?$CFd?0?5type?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@OBEDLAHJ@TaxiPt?5?$CFd?0?5type?3?5?$AA@ DB 'TaxiPt %d, type: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GLBKACGL@Speed?3?5?$CFd?5kts?0?5PointDist?3?5?$CFd?5ft?$AA@
CONST	SEGMENT
??_C@_0CA@GLBKACGL@Speed?3?5?$CFd?5kts?0?5PointDist?3?5?$CFd?5ft?$AA@ DB 'S'
	DB	'peed: %d kts, PointDist: %d ft', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ$0
__unwindtable$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z$0
__unwindtable$?TakeOff@DigitalBrain@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TakeOff@DigitalBrain@@IAEXXZ$0
__unwindtable$?Land@DigitalBrain@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Land@DigitalBrain@@IAEXXZ$0
__unwindtable$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z$1
__unwindtable$?CheckTaxiCollision@DigitalBrain@@IAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckTaxiCollision@DigitalBrain@@IAEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CheckTaxiCollision@DigitalBrain@@IAEHXZ$1
__ehfuncinfo$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CheckTaxiCollision@DigitalBrain@@IAEHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckTaxiCollision@DigitalBrain@@IAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?TakeOff@DigitalBrain@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TakeOff@DigitalBrain@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Land@DigitalBrain@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Land@DigitalBrain@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_self$ = 8						; size = 4
?EngineStart@@YAHPAVAircraftClass@@@Z PROC		; EngineStart

; 3818 : {

	push	ebp
	mov	ebp, esp

; 3819 :     if (self->af->IsSet(AirframeClass::EngineStopped))

	push	134217728				; 08000000H
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN7@EngineStar

; 3820 : 	{
; 3821 : /* RAS - not sure if this has any side effects so commenting it out for now
; 3822 : 		//RAS-5Nov04-Set Parking Brake when Starting Engines
; 3823 : 		if(!self->af->IsSet((AirframeClass::WheelBrakes)))
; 3824 : */
; 3825 : 			self->af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	ecx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3826 : 
; 3827 : 		if /*(self->af->rpm > 0.2f)*/ (self->af->IsSet(AirframeClass::JfsStart)) { // Jfs is runnning time to light

	push	268435456				; 10000000H
	mov	edx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN7@EngineStar

; 3828 : 			self->af->SetThrotl(0.1f); // advance the throttle to light.

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetThrotl@AirframeClass@@QAEXM@Z	; AirframeClass::SetThrotl

; 3829 : 			self->af->ClearFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 3830 : 			self->af->engine1Throttle = 0.3F;

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [eax+1520], xmm0
$LN7@EngineStar:

; 3831 : 
; 3832 : 	}
; 3833 : 	}
; 3834 : 	//TJL 01/22/04 multi-engine
; 3835 : 	if (self->af->IsEngineFlag(AirframeClass::EngineStopped2))

	push	8
	mov	ecx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN5@EngineStar

; 3836 : 	{
; 3837 : 		if /*(self->af->rpm2 > 0.2f)*/(self->af->IsSet(AirframeClass::JfsStart))

	push	268435456				; 10000000H
	mov	edx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN5@EngineStar

; 3838 : 		{
; 3839 : 			self->af->SetThrotl(0.1f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetThrotl@AirframeClass@@QAEXM@Z	; AirframeClass::SetThrotl

; 3840 : 			self->af->ClearEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	ecx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 3841 :   		    self->af->engine2Throttle = 0.3F;

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [eax+1524], xmm0
$LN5@EngineStar:

; 3842 : 		}
; 3843 : 	}
; 3844 : 
; 3845 : /*	//TJL 08/15/04 Trying to fix this
; 3846 : 	if (self->af->IsSet(AirframeClass::JfsStart)) 
; 3847 : 	{
; 3848 : 		// nothing much happening
; 3849 : 	}
; 3850 : 		else { // start the JFS
; 3851 : 	    self->af->JfsEngineStart();
; 3852 : 		return 0;
; 3853 : */
; 3854 : 
; 3855 : 	//RAS-5Nov04-Fix for Ramp Start Preflight (All items would not get accomplished because the engine
; 3856 : 	//start routine was looping in the JfsEngineStart() function
; 3857 :     if(self->af->IsSet(AirframeClass::EngineStopped))

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN4@EngineStar

; 3858 : 	{
; 3859 : 		self->af->JfsEngineStart();

	mov	edx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?JfsEngineStart@AirframeClass@@QAEXXZ	; AirframeClass::JfsEngineStart

; 3860 : 		return 0;

	xor	eax, eax
	jmp	$LN9@EngineStar
$LN4@EngineStar:

; 3861 : 	}
; 3862 : 	
; 3863 : 
; 3864 : 	if (self->af->rpm > 0.69f) { // at idle

	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1212]
	comiss	xmm0, DWORD PTR __real@3f30a3d7
	jbe	SHORT $LN3@EngineStar

; 3865 : 	    self->af->SetThrotl(0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?SetThrotl@AirframeClass@@QAEXM@Z	; AirframeClass::SetThrotl

; 3866 : 		self->af->engine1Throttle = 0.0F;

	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1520], xmm0

; 3867 : 		self->af->engine2Throttle = 0.0F;

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1524], xmm0

; 3868 : 		self->DBrain()->throtl = 0.0F;

	mov	ecx, DWORD PTR _self$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 3869 : 	    return 1; // finished engine start up

	mov	eax, 1
	jmp	SHORT $LN9@EngineStar
	jmp	SHORT $LN1@EngineStar
$LN3@EngineStar:

; 3870 : 	}
; 3871 : 	else if (self->af->rpm > 0.5f) { // engine now running

	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1212]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN1@EngineStar

; 3872 : 	    self->af->SetThrotl(0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?SetThrotl@AirframeClass@@QAEXM@Z	; AirframeClass::SetThrotl

; 3873 : 		self->af->engine1Throttle = 0.0F;

	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+1520], xmm0

; 3874 : 		self->af->engine2Throttle = 0.0F;

	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+1524], xmm0
$LN1@EngineStar:

; 3875 : 	}
; 3876 :     return 0;

	xor	eax, eax
$LN9@EngineStar:

; 3877 : 	/*
; 3878 : 	
; 3879 :     }
; 3880 :     else {
; 3881 : 	*/
; 3882 : }

	pop	ebp
	ret	0
?EngineStart@@YAHPAVAircraftClass@@@Z ENDP		; EngineStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDFloatPos@@YAMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDFloatPos@@YAMXZ PROC				; PRANDFloatPos, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 151  : //	return NRANDPOS;
; 152  : 	float	x=	(float)(GenerateFastRandom()&0xffff);

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 65535				; 0000ffffH
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 153  : 	return( x / 65535.0f);

	movss	xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR __real@477fff00
	movss	DWORD PTR tv72[ebp], xmm0
	fld	DWORD PTR tv72[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDFloatPos@@YAMXZ ENDP				; PRANDFloatPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetLightLevel@CTimeOfDay@@QAEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?GetLightLevel@CTimeOfDay@@QAEMXZ PROC			; CTimeOfDay::GetLightLevel, COMDAT
; _this$ = ecx

; 108  : 	float GetLightLevel()						{ return Ambient + Diffuse; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	addss	xmm0, DWORD PTR [ecx+224]
	movss	DWORD PTR tv71[ebp], xmm0
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLightLevel@CTimeOfDay@@QAEMXZ ENDP			; CTimeOfDay::GetLightLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?SetICPSecondaryMode@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?SetICPSecondaryMode@ICPClass@@QAEXH@Z PROC		; ICPClass::SetICPSecondaryMode, COMDAT
; _this$ = ecx

; 575  :    void SetICPSecondaryMode(int num) {mICPSecondaryMode = num;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetICPSecondaryMode@ICPClass@@QAEXH@Z ENDP		; ICPClass::SetICPSecondaryMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?SetICPFlag@ICPClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetICPFlag@ICPClass@@QAEXH@Z PROC			; ICPClass::SetICPFlag, COMDAT
; _this$ = ecx

; 497  : 	void SetICPFlag (int newFlag) {ICPModeFlags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1376]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1376], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetICPFlag@ICPClass@@QAEXH@Z ENDP			; ICPClass::SetICPFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newState$ = 8						; size = 4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z PROC ; SMSBaseClass::SetMasterArm, COMDAT
; _this$ = ecx

; 93   : 	void SetMasterArm (MasterArmState newState) {masterArm = newState;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newState$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ENDP ; SMSBaseClass::SetMasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?LabelColor@DrawableBSP@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LabelColor@DrawableBSP@@QAEKXZ PROC			; DrawableBSP::LabelColor, COMDAT
; _this$ = ecx

; 63   : 	DWORD LabelColor()										{ return labelColor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+164]
	mov	esp, ebp
	pop	ebp
	ret	0
?LabelColor@DrawableBSP@@QAEKXZ ENDP			; DrawableBSP::LabelColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?Radius@DrawableObject@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Radius@DrawableObject@@QBEMXZ PROC			; DrawableObject::Radius, COMDAT
; _this$ = ecx

; 27   : 	float Radius() const { return radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?Radius@DrawableObject@@QBEMXZ ENDP			; DrawableObject::Radius
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ PROC ; PlayerOptionsClass::GetStartFlag, COMDAT
; _this$ = ecx

; 201  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 			switch(SimStartFlags) // MLR 12/11/2003 - Sanity check

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	jl	SHORT $LN2@GetStartFl
	cmp	DWORD PTR tv65[ebp], 2
	jle	SHORT $LN1@GetStartFl
	jmp	SHORT $LN2@GetStartFl
$LN1@GetStartFl:

; 203  : 			{
; 204  : 			case START_RUNWAY:
; 205  : 			case START_TAXI:
; 206  : 			case START_RAMP:
; 207  : 				return(SimStartFlags); 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	jmp	SHORT $LN4@GetStartFl
$LN2@GetStartFl:

; 208  : 			}
; 209  : 			return(START_RUNWAY);

	xor	eax, eax
$LN4@GetStartFl:

; 210  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ENDP ; PlayerOptionsClass::GetStartFlag
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetLandingAoASpd@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandingAoASpd@AirframeClass@@QAEMXZ PROC		; AirframeClass::GetLandingAoASpd, COMDAT
; _this$ = ecx

; 1228 : 	float GetLandingAoASpd() { return CalcDesSpeed(auxaeroData->landingAOA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+224]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcDesSpeed@AirframeClass@@QAEMM@Z	; AirframeClass::CalcDesSpeed
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandingAoASpd@AirframeClass@@QAEMXZ ENDP		; AirframeClass::GetLandingAoASpd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetSimpleMode@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSimpleMode@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetSimpleMode, COMDAT
; _this$ = ecx

; 1224 : 	int  GetSimpleMode(void) {return simpleMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+824]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSimpleMode@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetSimpleMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::ClearFlag, COMDAT
; _this$ = ecx

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::SetFlag, COMDAT
; _this$ = ecx

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Fuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Fuel@AirframeClass@@QAEMXZ PROC			; AirframeClass::Fuel, COMDAT
; _this$ = ecx

; 1183 : 	float Fuel (void) {return fuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?Fuel@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Fuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?CornerVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CornerVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::CornerVcas, COMDAT
; _this$ = ecx

; 1178 : 	float CornerVcas(void) {return cornerVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+84]
	mov	esp, ebp
	pop	ebp
	ret	0
?CornerVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::CornerVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxVcas, COMDAT
; _this$ = ecx

; 1176 : 	float MaxVcas(void) {return maxVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+80]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MinVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::MinVcas, COMDAT
; _this$ = ecx

; 1175 : 	float MinVcas(void) {return minVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	mov	esp, ebp
	pop	ebp
	ret	0
?MinVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MinVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetThrotl@AirframeClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newThrot$ = 8						; size = 4
?SetThrotl@AirframeClass@@QAEXM@Z PROC			; AirframeClass::SetThrotl, COMDAT
; _this$ = ecx

; 1164 : 	void SetThrotl (float newThrot) {throtl = newThrot;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newThrot$[ebp]
	movss	DWORD PTR [eax+1512], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetThrotl@AirframeClass@@QAEXM@Z ENDP			; AirframeClass::SetThrotl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_as$ = 8						; size = 4
?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z PROC	; AirframeClass::SetAirSource, COMDAT
; _this$ = ecx

; 1111 : 	void SetAirSource(AirSource as) { airSource = as; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _as$[ebp]
	mov	DWORD PTR [eax+1800], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ENDP	; AirframeClass::SetAirSource
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fp$ = 8						; size = 4
?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z PROC	; AirframeClass::SetFuelPump, COMDAT
; _this$ = ecx

; 1090 : 	void SetFuelPump(FuelPump fp) { fuelPump = fp; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fp$[ebp]
	mov	DWORD PTR [eax+1684], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ENDP	; AirframeClass::SetFuelPump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fs$ = 8						; size = 4
?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z PROC ; AirframeClass::SetFuelSwitch, COMDAT
; _this$ = ecx

; 1081 : 	void SetFuelSwitch(FuelSwitch fs) { fuelSwitch = fs; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fs$[ebp]
	mov	DWORD PTR [eax+1680], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ENDP ; AirframeClass::SetFuelSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::ClearEngineFlag, COMDAT
; _this$ = ecx

; 1072 : 	void ClearEngineFlag(EngineFlags ef) { engineFlags &= ~ ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _ef$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+1676]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::ClearEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ef$ = 8						; size = 4
?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z PROC ; AirframeClass::SetEngineFlag, COMDAT
; _this$ = ecx

; 1071 : 	void SetEngineFlag(EngineFlags ef) { engineFlags |= ef; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	or	ecx, DWORD PTR _ef$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1676], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ENDP ; AirframeClass::SetEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_ef$ = 8						; size = 4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z PROC ; AirframeClass::IsEngineFlag, COMDAT
; _this$ = ecx

; 1070 : 	int IsEngineFlag(EngineFlags ef) { return (engineFlags & ef) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1676]
	and	ecx, DWORD PTR _ef$[ebp]
	je	SHORT $LN3@IsEngineFl
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEngineFl
$LN3@IsEngineFl:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEngineFl:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ENDP ; AirframeClass::IsEngineFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HasThrRev@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasThrRev@AirframeClass@@QAEHXZ PROC			; AirframeClass::HasThrRev, COMDAT
; _this$ = ecx

; 1015 : 	int HasThrRev() { return auxaeroData->hasThrRev; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4028]
	mov	esp, ebp
	pop	ebp
	ret	0
?HasThrRev@AirframeClass@@QAEHXZ ENDP			; AirframeClass::HasThrRev
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?DragChuteMaxSpeed@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DragChuteMaxSpeed@AirframeClass@@QAEMXZ PROC		; AirframeClass::DragChuteMaxSpeed, COMDAT
; _this$ = ecx

; 1008 : 	float DragChuteMaxSpeed() { return auxaeroData->dragChuteMaxSpeed; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+232]
	mov	esp, ebp
	pop	ebp
	ret	0
?DragChuteMaxSpeed@AirframeClass@@QAEMXZ ENDP		; AirframeClass::DragChuteMaxSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?HasDragChute@AirframeClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?HasDragChute@AirframeClass@@QAE_NXZ PROC		; AirframeClass::HasDragChute, COMDAT
; _this$ = ecx

; 1007 : 	bool HasDragChute() { return auxaeroData->dragChuteCd > 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+228]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@HasDragChu
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@HasDragChu
$LN3@HasDragChu:
	mov	DWORD PTR tv67[ebp], 0
$LN4@HasDragChu:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?HasDragChute@AirframeClass@@QAE_NXZ ENDP		; AirframeClass::HasDragChute
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetNumberEngines@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumberEngines@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetNumberEngines, COMDAT
; _this$ = ecx

; 802  : 	int GetNumberEngines() {return auxaeroData->nEngines;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+344]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberEngines@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetNumberEngines
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ PROC	; UnitClass::GetFirstUnitWP, COMDAT
; _this$ = ecx

; 431  : 	WayPoint GetFirstUnitWP()				{ return wp_list; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+244]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ENDP	; UnitClass::GetFirstUnitWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ PROC ; SimulationDriver::GetPlayerEntity, COMDAT
; _this$ = ecx

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ENDP ; SimulationDriver::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ PROC ; CampBaseClass::GetComponents, COMDAT
; _this$ = ecx

; 141  : 	TailInsertList *GetComponents() const		{	return components; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ENDP ; CampBaseClass::GetComponents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ PROC	; AircraftClass::DBrain, COMDAT
; _this$ = ecx

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]
	mov	esp, ebp
	pop	ebp
	ret	0
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ENDP	; AircraftClass::DBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z PROC	; AircraftClass::SetPGM, COMDAT
; _this$ = ecx

; 544  : 	void SetPGM (EWSPGMSwitch t) { EWSPgm = t; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+1496], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ENDP	; AircraftClass::SetPGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ PROC ; AircraftClass::MainPower, COMDAT
; _this$ = ecx

; 519  : 	MainPowerType MainPower() { return mainPower; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1484]
	mov	esp, ebp
	pop	ebp
	ret	0
?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ENDP ; AircraftClass::MainPower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z PROC ; AircraftClass::PowerSwitchOn, COMDAT
; _this$ = ecx

; 513  : 	int PowerSwitchOn(AvionicsPowerFlags fl) { return (powerFlags & fl) ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1480]
	and	ecx, DWORD PTR _fl$[ebp]
	je	SHORT $LN3@PowerSwitc
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@PowerSwitc
$LN3@PowerSwitc:
	mov	DWORD PTR tv67[ebp], 0
$LN4@PowerSwitc:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ENDP ; AircraftClass::PowerSwitchOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z PROC ; AircraftClass::PowerOn, COMDAT
; _this$ = ecx

; 509  : 	void PowerOn (AvionicsPowerFlags fl) { powerFlags |= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1480]
	or	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1480], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ENDP ; AircraftClass::PowerOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?RaltOn@AircraftClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RaltOn@AircraftClass@@QAEXXZ PROC			; AircraftClass::RaltOn, COMDAT
; _this$ = ecx

; 417  : 	void RaltOn() {RALTStatus = RON;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1004], 2
	mov	esp, ebp
	pop	ebp
	ret	0
?RaltOn@AircraftClass@@QAEXXZ ENDP			; AircraftClass::RaltOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSOff, COMDAT
; _this$ = ecx

; 210  : 	void INSOff(INSAlignFlags fl) { INSFlags &= ~fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+768]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSOn, COMDAT
; _this$ = ecx

; 209  : 	void INSOn(INSAlignFlags fl) { INSFlags |= fl; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	or	ecx, DWORD PTR _fl$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z PROC ; AircraftClass::ExtlState, COMDAT
; _this$ = ecx

; 188  : 	int ExtlState(ExtlLightFlags fl) const { return (IsAcStatusBitsSet(fl) ? 1 : 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ; AircraftClass::IsAcStatusBitsSet
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ExtlState
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@ExtlState
$LN3@ExtlState:
	mov	DWORD PTR tv69[ebp], 0
$LN4@ExtlState:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ENDP ; AircraftClass::ExtlState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fl$ = 8						; size = 4
?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z PROC	; AircraftClass::ExtlOn, COMDAT
; _this$ = ecx

; 186  : 	void ExtlOn(ExtlLightFlags fl) { SetAcStatusBits(fl); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ENDP	; AircraftClass::ExtlOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_bits$ = 8						; size = 4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z PROC		; AircraftClass::IsAcStatusBitsSet, COMDAT
; _this$ = ecx

; 170  : 	bool IsAcStatusBitsSet(int bits) const { return (status_bits & bits) == bits; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	and	ecx, DWORD PTR _bits$[ebp]
	cmp	ecx, DWORD PTR _bits$[ebp]
	jne	SHORT $LN3@IsAcStatus
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAcStatus
$LN3@IsAcStatus:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAcStatus:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAcStatusBitsSet@AircraftClass@@QBE_NH@Z ENDP		; AircraftClass::IsAcStatusBitsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?GetSwitch@SimMoverClass@@QAEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_num$ = 8						; size = 4
?GetSwitch@SimMoverClass@@QAEHH@Z PROC			; SimMoverClass::GetSwitch, COMDAT
; _this$ = ecx

; 135  : 	int GetSwitch (int num) { return num < numSwitches ? switchData[num] : 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN3@GetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@GetSwitch
$LN3@GetSwitch:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetSwitch:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSwitch@SimMoverClass@@QAEHH@Z ENDP			; SimMoverClass::GetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?SetSwitch@SimMoverClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_num$ = 8						; size = 4
_val$ = 12						; size = 4
?SetSwitch@SimMoverClass@@QAEXHH@Z PROC			; SimMoverClass::SetSwitch, COMDAT
; _this$ = ecx

; 134  : 	void SetSwitch (int num, int val) { ShiAssert(num < numSwitches); if (num < numSwitches) { switchData[num] = val; switchChange[num] = TRUE;} }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+604]
	jge	SHORT $LN2@SetSwitch
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	edx, DWORD PTR _num$[ebp]
	mov	DWORD PTR [ecx+edx*4], 1
$LN2@SetSwitch:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSwitch@SimMoverClass@@QAEXHH@Z ENDP			; SimMoverClass::SetSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv175 = -44						; size = 4
_prevY$ = -40						; size = 4
_prevX$ = -36						; size = 4
_Airbase$ = -32						; size = 4
tv143 = -28						; size = 4
tv142 = -24						; size = 4
tv135 = -20						; size = 4
_dy$ = -16						; size = 4
_dx$ = -12						; size = 4
_point$ = -8						; size = 4
_this$ = -4						; size = 4
_time$ = 8						; size = 4
?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z PROC		; DigitalBrain::CalculateTaxiSpeed
; _this$ = ecx

; 2926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 2927 : 	ObjectiveClass *Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 2928 : 
; 2929 : 	ShiAssert(Airbase);
; 2930 : 
; 2931 : 	float prevX, prevY, dx, dy;
; 2932 : 	//float nextX, nextY;
; 2933 : 	int point;
; 2934 : //	point = GetNextPt(curTaxiPoint);
; 2935 : 	point = GetNextTaxiPt(curTaxiPoint);	// 07JAN04 - FRB - Get *taxi* point	we are at now

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 2936 : 
; 2937 : 	if(point && time)

	cmp	DWORD PTR _point$[ebp], 0
	je	$LN2@CalculateT
	movss	xmm0, DWORD PTR _time$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@CalculateT

; 2938 : 	{
; 2939 : 		//TranslatePointData(Airbase, curTaxiPoint, &nextX, &nextY);
; 2940 : 		TranslatePointData(Airbase, point, &prevX, &prevY);

	lea	edx, DWORD PTR _prevY$[ebp]
	push	edx
	lea	eax, DWORD PTR _prevX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2941 : 		//dx = prevX - nextX;
; 2942 : 		//dy = prevY - nextY;
; 2943 : 		dx = prevX - trackX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _prevX$[ebp]
	subss	xmm0, DWORD PTR [eax+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2944 : 		dy = prevY - trackY;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _prevY$[ebp]
	subss	xmm0, DWORD PTR [ecx+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2945 : 
; 2946 : 		//how fast do we go to cover the distance in (time) seconds?
; 2947 : 		desiredSpeed = (float)sqrt(dx*dx + dy*dy)/time;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv175[ebp]
	movss	xmm0, DWORD PTR tv175[ebp]
	divss	xmm0, DWORD PTR _time$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+336], xmm0

; 2948 : 
; 2949 : 		ShiAssert(!_isnan(desiredSpeed))
; 2950 : 	}
; 2951 : 	else

	jmp	SHORT $LN1@CalculateT
$LN2@CalculateT:

; 2952 : 		desiredSpeed = 5.0F * KNOTS_TO_FTPSEC;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@410706e2
	movss	DWORD PTR [eax+336], xmm0
$LN1@CalculateT:

; 2953 : 
; 2954 : 	//no matter how late, we don't taxi at more than 30 knots or less than 5
; 2955 : 	desiredSpeed = max(5.0F*KNOTS_TO_FTPSEC, min(desiredSpeed,24.0F*KNOTS_TO_FTPSEC));	//RAS - 10Oct04 - changed from 30 to 24 max based on Booster's input

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42220842
	comiss	xmm0, DWORD PTR [ecx+336]
	jbe	SHORT $LN5@CalculateT
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN6@CalculateT
$LN5@CalculateT:
	movss	xmm0, DWORD PTR __real@42220842
	movss	DWORD PTR tv135[ebp], xmm0
$LN6@CalculateT:
	movss	xmm0, DWORD PTR __real@410706e2
	comiss	xmm0, DWORD PTR tv135[ebp]
	jbe	SHORT $LN9@CalculateT
	movss	xmm0, DWORD PTR __real@410706e2
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN10@CalculateT
$LN9@CalculateT:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42220842
	comiss	xmm0, DWORD PTR [eax+336]
	jbe	SHORT $LN7@CalculateT
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN8@CalculateT
$LN7@CalculateT:
	movss	xmm0, DWORD PTR __real@42220842
	movss	DWORD PTR tv142[ebp], xmm0
$LN8@CalculateT:
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
$LN10@CalculateT:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR [edx+336], xmm0

; 2956 : //	desiredSpeed = max(10.0F*KNOTS_TO_FTPSEC, min(desiredSpeed,30.0F*KNOTS_TO_FTPSEC));	 // 24JAN04 - FRB - was 5 min
; 2957 : 																																											 
; 2958 : 	return desiredSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+336]

; 2959 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ENDP		; DigitalBrain::CalculateTaxiSpeed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv316 = -36						; size = 4
tv302 = -32						; size = 4
_flight$ = -28						; size = 4
tv280 = -24						; size = 4
_runway$ = -20						; size = 4
_Airbase$ = -16						; size = 4
_retval$ = -12						; size = 4
_wingman$ = -8						; size = 4
_this$ = -4						; size = 4
?ReadyToGo@DigitalBrain@@QAEHXZ PROC			; DigitalBrain::ReadyToGo
; _this$ = ecx

; 3196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3197 : 	int retval = FALSE, runway;

	mov	DWORD PTR _retval$[ebp], 0

; 3198 : 	FlightClass *flight = (FlightClass*)self->GetCampaignObject();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$[ebp], eax

; 3199 : 	ObjectiveClass	*Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	push	edx
	mov	eax, DWORD PTR [ecx+308]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 3200 : 	AircraftClass *wingman = NULL;

	mov	DWORD PTR _wingman$[ebp], 0

; 3201 : 
; 3202 : 	if(!Airbase)

	cmp	DWORD PTR _Airbase$[ebp], 0
	jne	SHORT $LN19@ReadyToGo

; 3203 : 		return TRUE;

	mov	eax, 1
	jmp	$LN20@ReadyToGo
$LN19@ReadyToGo:

; 3204 : 
; 3205 : 	if(!isWing && !IsSetATC(PermitTakeoff))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN18@ReadyToGo
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN18@ReadyToGo

; 3206 : 		return FALSE;

	xor	eax, eax
	jmp	$LN20@ReadyToGo
$LN18@ReadyToGo:

; 3207 : 
; 3208 : 	if( (!isWing || self->vehicleInUnit == 2) && 
; 3209 : 		rwtime + WINGMAN_WAIT_TIME < SimLibElapsedTime && 	// FRB - check WINGMAN_WAIT_TIME value (is 30 secs)
; 3210 : 		waittimer <= SimLibElapsedTime  )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN16@ReadyToGo
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jne	SHORT $LN17@ReadyToGo
$LN16@ReadyToGo:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	add	ecx, 15000				; 00003a98H
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN17@ReadyToGo
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	ja	SHORT $LN17@ReadyToGo

; 3211 : 	{
; 3212 : 		retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
	jmp	$LN2@ReadyToGo
$LN17@ReadyToGo:

; 3213 : 	}
; 3214 : 	else if(self->GetVt() < 2.0F && waittimer <= SimLibElapsedTime)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv280[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR tv280[ebp]
	jbe	$LN2@ReadyToGo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	ja	$LN2@ReadyToGo

; 3215 : 	{
; 3216 : 		if (Airbase->brain->UseSectionTakeoff(flight, rwIndex) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _flight$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	$LN13@ReadyToGo

; 3217 : 		{
; 3218 : 			wingman = (AircraftClass*)MyWingman();				

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MyWingman@DigitalBrain@@QAEPAVSimBaseClass@@XZ ; DigitalBrain::MyWingman
	mov	DWORD PTR _wingman$[ebp], eax

; 3219 : 
; 3220 : 			if(wingman && Airbase->brain)

	cmp	DWORD PTR _wingman$[ebp], 0
	je	$LN12@ReadyToGo
	mov	ecx, DWORD PTR _Airbase$[ebp]
	cmp	DWORD PTR [ecx+240], 0
	je	$LN12@ReadyToGo

; 3221 : 			{
; 3222 : 				runway = Airbase->brain->IsOnRunway(wingman);

	mov	edx, DWORD PTR _wingman$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	DWORD PTR _runway$[ebp], eax

; 3223 : 				if( !wingman->OnGround() )

	mov	ecx, DWORD PTR _wingman$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _wingman$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN11@ReadyToGo

; 3224 : 					retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
	jmp	SHORT $LN9@ReadyToGo
$LN11@ReadyToGo:

; 3225 : 				else if(wingman->GetVt() > 40.0F * KNOTS_TO_FTPSEC && (runway == rwIndex || Airbase->brain->GetOppositeRunway(runway) == rwIndex))

	mov	ecx, DWORD PTR _wingman$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _wingman$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv302[ebp]
	movss	xmm0, DWORD PTR tv302[ebp]
	comiss	xmm0, DWORD PTR __real@428706e2
	jbe	SHORT $LN9@ReadyToGo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _runway$[ebp]
	cmp	edx, DWORD PTR [ecx+304]
	je	SHORT $LN8@ReadyToGo
	mov	eax, DWORD PTR _runway$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+304]
	jne	SHORT $LN9@ReadyToGo
$LN8@ReadyToGo:

; 3226 : 					retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN9@ReadyToGo:

; 3227 : 
; 3228 : 				if(isWing == 0 || self->vehicleInUnit == 2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@ReadyToGo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	cmp	eax, 2
	jne	SHORT $LN5@ReadyToGo
$LN6@ReadyToGo:

; 3229 : 				{					
; 3230 : 					if(wingman->GetVt() < 2.0F && (runway == rwIndex || Airbase->brain->GetOppositeRunway(runway) == rwIndex) )

	mov	ecx, DWORD PTR _wingman$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _wingman$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv316[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR tv316[ebp]
	jbe	SHORT $LN5@ReadyToGo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _runway$[ebp]
	cmp	edx, DWORD PTR [ecx+304]
	je	SHORT $LN4@ReadyToGo
	mov	eax, DWORD PTR _runway$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+304]
	jne	SHORT $LN5@ReadyToGo
$LN4@ReadyToGo:

; 3231 : 						retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN5@ReadyToGo:

; 3232 : 				}
; 3233 : 			}
; 3234 : 			else 

	jmp	SHORT $LN3@ReadyToGo
$LN12@ReadyToGo:

; 3235 : 				retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN3@ReadyToGo:

; 3236 : 		}
; 3237 : 		else 

	jmp	SHORT $LN2@ReadyToGo
$LN13@ReadyToGo:

; 3238 : 			retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN2@ReadyToGo:

; 3239 : 	}
; 3240 : 
; 3241 : 	if(wingman && retval && !IsSetATC(WingmanReady))

	cmp	DWORD PTR _wingman$[ebp], 0
	je	SHORT $LN1@ReadyToGo
	cmp	DWORD PTR _retval$[ebp], 0
	je	SHORT $LN1@ReadyToGo
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN1@ReadyToGo

; 3242 : 	{
; 3243 : 		SetATCFlag(WingmanReady);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 3244 : 		waittimer = CampaignSeconds + SimLibElapsedTime;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 3245 : 
; 3246 : 		retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
$LN1@ReadyToGo:

; 3247 : 	}
; 3248 : 
; 3249 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN20@ReadyToGo:

; 3250 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadyToGo@DigitalBrain@@QAEHXZ ENDP			; DigitalBrain::ReadyToGo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv515 = -84						; size = 4
tv509 = -80						; size = 4
tv468 = -76						; size = 4
tv462 = -72						; size = 4
tv405 = -68						; size = 4
tv399 = -64						; size = 4
tv381 = -60						; size = 4
_baseY$ = -56						; size = 4
_baseX$ = -52						; size = 4
_cosAngle$ = -48					; size = 4
tv135 = -44						; size = 4
_vt$ = -40						; size = 4
_finalY$ = -36						; size = 4
_finalX$ = -32						; size = 4
_Airbase$ = -28						; size = 4
_dy$ = -24						; size = 4
_dx$ = -20						; size = 4
_newHeading$ = -16					; size = 4
_curHeading$ = -12					; size = 4
_deltaHdg$ = -8						; size = 4
_this$ = -4						; size = 4
?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ PROC	; DigitalBrain::CalculateNextTurnDistance
; _this$ = ecx

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 	float curHeading=0.0F, newHeading=0.0F, cosAngle=1.0F, deltaHdg=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _curHeading$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _newHeading$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cosAngle$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0

; 237  : 	float baseX=0.0F, baseY=0.0F, finalX=0.0F, finalY=0.0F, dx=0.0F, dy=0.0F, vt=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _baseX$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _baseY$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _finalX$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _finalY$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _vt$[ebp], xmm0

; 238  : 	ObjectiveClass *Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 239  : 	
; 240  : 	turnDist = 500.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43fa0000
	movss	DWORD PTR [eax+340], xmm0

; 241  : 
; 242  : 	if (Airbase && Airbase->brain){

	cmp	DWORD PTR _Airbase$[ebp], 0
	je	$LN28@CalculateN
	mov	ecx, DWORD PTR _Airbase$[ebp]
	cmp	DWORD PTR [ecx+240], 0
	je	$LN28@CalculateN

; 243  : 		// sfr: get a rwindex if we still dont have one
; 244  : 		if (rwIndex == 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+304], 0
	jne	SHORT $LN27@CalculateN

; 245  : 			rwIndex = Airbase->brain->FindBestLandingRunway(self);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax
$LN27@CalculateN:

; 246  : 		}
; 247  : 
; 248  : 		//vt = sqrt(self->XDelta() * self->XDelta() + self->YDelta() * self->YDelta());
; 249  : 		vt = af->MinVcas() * KNOTS_TO_FTPSEC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv381[ebp]
	movss	xmm0, DWORD PTR tv381[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _vt$[ebp], xmm0

; 250  : 
; 251  : 		cosAngle = Airbase->brain->DetermineAngle(self, rwIndex, atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 252  : 
; 253  : 		switch(atcstatus){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR tv135[ebp], edx
	mov	eax, DWORD PTR tv135[ebp]
	sub	eax, 8
	mov	DWORD PTR tv135[ebp], eax
	cmp	DWORD PTR tv135[ebp], 3
	ja	$LN25@CalculateN
	mov	ecx, DWORD PTR tv135[ebp]
	jmp	DWORD PTR $LN31@CalculateN[ecx*4]
$LN24@CalculateN:

; 254  : 			case lFirstLeg:
; 255  : 				dx = self->XPos() - trackX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv399[ebp]
	movss	xmm0, DWORD PTR tv399[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 256  : 				dy = self->YPos() - trackY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv405[ebp]
	movss	xmm0, DWORD PTR tv405[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 257  : 				curHeading = (float)atan2(dy,dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _curHeading$[ebp]

; 258  : 				if(curHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _curHeading$[ebp]
	jbe	SHORT $LN23@CalculateN

; 259  : 					curHeading += PI * 2.0F;

	movss	xmm0, DWORD PTR _curHeading$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _curHeading$[ebp], xmm0
$LN23@CalculateN:

; 260  : 
; 261  : 				Airbase->brain->FindFinalPt(self, rwIndex, &finalX, &finalY);

	lea	eax, DWORD PTR _finalY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _finalX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 262  : 				if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN22@CalculateN

; 263  : 				{
; 264  : 					Airbase->brain->FindBasePt(self, rwIndex, finalX, finalY, &baseX, &baseY);

	lea	ecx, DWORD PTR _baseY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _baseX$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 265  : 					dx = trackX - baseX;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+148]
	subss	xmm0, DWORD PTR _baseX$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 266  : 					dy = trackY - baseY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+152]
	subss	xmm0, DWORD PTR _baseY$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 267  : 				}
; 268  : 				else

	jmp	SHORT $LN21@CalculateN
$LN22@CalculateN:

; 269  : 				{
; 270  : 					dx = trackX - finalX;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+148]
	subss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 271  : 					dy = trackY - finalY;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0
$LN21@CalculateN:

; 272  : 				}
; 273  : 				newHeading = (float)atan2(dy,dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _newHeading$[ebp]

; 274  : 				if(newHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _newHeading$[ebp]
	jbe	SHORT $LN20@CalculateN

; 275  : 					newHeading += PI * 2.0F;

	movss	xmm0, DWORD PTR _newHeading$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _newHeading$[ebp], xmm0
$LN20@CalculateN:

; 276  : 
; 277  : 				deltaHdg = newHeading - curHeading;

	movss	xmm0, DWORD PTR _newHeading$[ebp]
	subss	xmm0, DWORD PTR _curHeading$[ebp]
	movss	DWORD PTR _deltaHdg$[ebp], xmm0

; 278  : 				if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN19@CalculateN

; 279  : 					deltaHdg = -(deltaHdg - PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	subss	xmm0, DWORD PTR __real@40490fdb
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
	jmp	SHORT $LN17@CalculateN
$LN19@CalculateN:

; 280  : 				else if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$[ebp]
	jbe	SHORT $LN17@CalculateN

; 281  : 					deltaHdg = -(deltaHdg + PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	addss	xmm0, DWORD PTR __real@40490fdb
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
$LN17@CalculateN:

; 282  : 				turnDist = (float)fabs( deltaHdg * 12.15854203708F * vt );

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	mulss	xmm0, DWORD PTR __real@41428963
	mulss	xmm0, DWORD PTR _vt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+340]

; 283  : 			break;

	jmp	$LN25@CalculateN
$LN16@CalculateN:

; 284  : 			case lToBase:
; 285  : 				dx = self->XPos() - trackX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv462[ebp]
	movss	xmm0, DWORD PTR tv462[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 286  : 				dy = self->YPos() - trackY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv468[ebp]
	movss	xmm0, DWORD PTR tv468[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [ecx+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 287  : 				curHeading = (float)atan2(dy,dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _curHeading$[ebp]

; 288  : 				if(curHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _curHeading$[ebp]
	jbe	SHORT $LN15@CalculateN

; 289  : 					curHeading += PI * 2.0F;

	movss	xmm0, DWORD PTR _curHeading$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _curHeading$[ebp], xmm0
$LN15@CalculateN:

; 290  : 
; 291  : 				Airbase->brain->FindFinalPt(self, rwIndex, &finalX, &finalY);

	lea	edx, DWORD PTR _finalY$[ebp]
	push	edx
	lea	eax, DWORD PTR _finalX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 292  : 				dx = trackX - finalX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 293  : 				dy = trackY - finalY;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 294  : 				newHeading = (float)atan2(dy,dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _newHeading$[ebp]

; 295  : 				if(newHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _newHeading$[ebp]
	jbe	SHORT $LN14@CalculateN

; 296  : 					newHeading += PI * 2.0F;

	movss	xmm0, DWORD PTR _newHeading$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _newHeading$[ebp], xmm0
$LN14@CalculateN:

; 297  : 
; 298  : 				deltaHdg = newHeading - curHeading;

	movss	xmm0, DWORD PTR _newHeading$[ebp]
	subss	xmm0, DWORD PTR _curHeading$[ebp]
	movss	DWORD PTR _deltaHdg$[ebp], xmm0

; 299  : 				if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN13@CalculateN

; 300  : 					deltaHdg = -(deltaHdg - PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	subss	xmm0, DWORD PTR __real@40490fdb
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
	jmp	SHORT $LN11@CalculateN
$LN13@CalculateN:

; 301  : 				else if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$[ebp]
	jbe	SHORT $LN11@CalculateN

; 302  : 					deltaHdg = -(deltaHdg + PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	addss	xmm0, DWORD PTR __real@40490fdb
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
$LN11@CalculateN:

; 303  : 				turnDist = (float)fabs( deltaHdg * 12.15854203708F * vt );

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	mulss	xmm0, DWORD PTR __real@41428963
	mulss	xmm0, DWORD PTR _vt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+340]

; 304  : 			break;

	jmp	$LN25@CalculateN
$LN10@CalculateN:

; 305  : 			case lToFinal:
; 306  : 			case lOnFinal:
; 307  : 				dx = self->XPos() - trackX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv509[ebp]
	movss	xmm0, DWORD PTR tv509[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [ecx+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 308  : 				dy = self->YPos() - trackY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv515[ebp]
	movss	xmm0, DWORD PTR tv515[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 309  : 				curHeading = (float)atan2(dy,dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _curHeading$[ebp]

; 310  : 				if(curHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _curHeading$[ebp]
	jbe	SHORT $LN9@CalculateN

; 311  : 					curHeading += PI * 2.0F;

	movss	xmm0, DWORD PTR _curHeading$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _curHeading$[ebp], xmm0
$LN9@CalculateN:

; 312  : 				
; 313  : 				newHeading = PtHeaderDataTable[rwIndex].data * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+10]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _newHeading$[ebp], xmm0

; 314  : 
; 315  : 				deltaHdg = newHeading - curHeading;

	movss	xmm0, DWORD PTR _newHeading$[ebp]
	subss	xmm0, DWORD PTR _curHeading$[ebp]
	movss	DWORD PTR _deltaHdg$[ebp], xmm0

; 316  : 				if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN8@CalculateN

; 317  : 					deltaHdg = -(deltaHdg - PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	subss	xmm0, DWORD PTR __real@40490fdb
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
	jmp	SHORT $LN6@CalculateN
$LN8@CalculateN:

; 318  : 				else if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$[ebp]
	jbe	SHORT $LN6@CalculateN

; 319  : 					deltaHdg = -(deltaHdg + PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	addss	xmm0, DWORD PTR __real@40490fdb
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
$LN6@CalculateN:

; 320  : 				turnDist = (float)fabs( deltaHdg * 12.15854203708F * vt );

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	mulss	xmm0, DWORD PTR __real@41428963
	mulss	xmm0, DWORD PTR _vt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+340]

; 321  : 				if(turnDist < 4000.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@457a0000
	comiss	xmm0, DWORD PTR [eax+340]
	jbe	SHORT $LN5@CalculateN

; 322  : 					turnDist = 4000.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR [ecx+340], xmm0
$LN5@CalculateN:
$LN25@CalculateN:

; 323  : 			break;
; 324  : 		}
; 325  : 		turnDist += (0.5F * vt);

	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR _vt$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+340]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+340], xmm0
$LN28@CalculateN:

; 326  : 	}	
; 327  : 
; 328  : 
; 329  : 	if(self->IsPlayer()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN4@CalculateN

; 330  : 		if(turnDist < 400.0F){

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43c80000
	comiss	xmm0, DWORD PTR [edx+340]
	jbe	SHORT $LN3@CalculateN

; 331  : 			turnDist = 400.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [eax+340], xmm0
$LN3@CalculateN:

; 332  : 		}
; 333  : 	}

	jmp	SHORT $LN1@CalculateN
$LN4@CalculateN:

; 334  : 	else if(turnDist < 300.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR [ecx+340]
	jbe	SHORT $LN1@CalculateN

; 335  : 		turnDist = 300.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [edx+340], xmm0
$LN1@CalculateN:

; 336  : 	}
; 337  : 	return turnDist;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+340]

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@CalculateN:
	DD	$LN24@CalculateN
	DD	$LN16@CalculateN
	DD	$LN10@CalculateN
	DD	$LN10@CalculateN
?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ENDP	; DigitalBrain::CalculateNextTurnDistance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?RwTime@DigitalBrain@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RwTime@DigitalBrain@@QAEKXZ PROC			; DigitalBrain::RwTime, COMDAT
; _this$ = ecx

; 772  : 	VU_TIME RwTime(void)	{return rwtime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]
	mov	esp, ebp
	pop	ebp
	ret	0
?RwTime@DigitalBrain@@QAEKXZ ENDP			; DigitalBrain::RwTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ PROC	; DigitalBrain::ATCStatus, COMDAT
; _this$ = ecx

; 765  : 	AtcStatusEnum	ATCStatus(void)							{return atcstatus;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]
	mov	esp, ebp
	pop	ebp
	ret	0
?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ENDP	; DigitalBrain::ATCStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_status$ = 8						; size = 4
?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z PROC ; DigitalBrain::SetATCStatus, COMDAT
; _this$ = ecx

; 764  : 	void			SetATCStatus(AtcStatusEnum status)		{atcstatus = status;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+328], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ENDP ; DigitalBrain::SetATCStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
$T2 = -72						; size = 8
$T3 = -64						; size = 8
$T4 = -56						; size = 4
$T5 = -52						; size = 4
tv186 = -48						; size = 4
tv173 = -44						; size = 4
$T6 = -40						; size = 4
tv168 = -36						; size = 4
tv145 = -32						; size = 4
$T7 = -28						; size = 4
_atc$ = -24						; size = 4
_this$ = -20						; size = 4
_ATCMessage$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_msg$ = 8						; size = 4
?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z PROC	; DigitalBrain::SendATCMsg
; _this$ = ecx

; 2855 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2856 : 	//atcstatus = msg;
; 2857 : 	//hack so we don't send atc messages to taskforces
; 2858 : 	CampBaseClass *atc = (CampBaseClass*)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _atc$[ebp], eax

; 2859 : 	if(!atc || !atc->IsObjective()){

	cmp	DWORD PTR _atc$[ebp], 0
	je	SHORT $LN12@SendATCMsg
	mov	eax, DWORD PTR _atc$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _atc$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	jne	SHORT $LN13@SendATCMsg
$LN12@SendATCMsg:

; 2860 : 		return;

	jmp	$LN14@SendATCMsg
$LN13@SendATCMsg:

; 2861 : 	}
; 2862 : 
; 2863 : 	FalconATCMessage* ATCMessage;
; 2864 : 	if (g_bMPFix){

	movzx	ecx, BYTE PTR ?g_bMPFix@@3_NA		; g_bMPFix
	test	ecx, ecx
	je	$LN11@SendATCMsg

; 2865 : 		ATCMessage = new FalconATCMessage( 
; 2866 : 			airbase, (VuTargetEntity*) vuDatabase->Find(vuLocalSessionEntity->Game()->OwnerId()) 
; 2867 : 		);

	push	62					; 0000003eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN16@SendATCMsg
	push	1
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::operator->
	mov	ecx, eax
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	ecx, eax
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconATCMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconATCMessage::FalconATCMessage
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN17@SendATCMsg
$LN16@SendATCMsg:
	mov	DWORD PTR tv145[ebp], 0
$LN17@SendATCMsg:
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _ATCMessage$[ebp], ecx

; 2868 : 	}
; 2869 : 	else {

	jmp	$LN10@SendATCMsg
$LN11@SendATCMsg:

; 2870 : 		ATCMessage = new FalconATCMessage( airbase, FalconLocalGame );

	push	62					; 0000003eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN20@SendATCMsg
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@SendATCMsg
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN19@SendATCMsg
$LN18@SendATCMsg:
	mov	DWORD PTR tv168[ebp], 0
$LN19@SendATCMsg:
	push	1
	mov	eax, DWORD PTR tv168[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	push	edx
	mov	eax, DWORD PTR [ecx+308]
	push	eax
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0FalconATCMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconATCMessage::FalconATCMessage
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN21@SendATCMsg
$LN20@SendATCMsg:
	mov	DWORD PTR tv173[ebp], 0
$LN21@SendATCMsg:
	mov	ecx, DWORD PTR tv173[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _ATCMessage$[ebp], edx
$LN10@SendATCMsg:

; 2871 : 	}
; 2872 : 
; 2873 : 	ATCMessage->dataBlock.from		= self->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 2874 : 	ATCMessage->dataBlock.status	= (short)msg;

	mov	edx, DWORD PTR _ATCMessage$[ebp]
	mov	ax, WORD PTR _msg$[ebp]
	mov	WORD PTR [edx+60], ax

; 2875 : 
; 2876 : 	switch(msg){

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR tv186[ebp], ecx
	cmp	DWORD PTR tv186[ebp], 29		; 0000001dH
	ja	SHORT $LN8@SendATCMsg
	mov	edx, DWORD PTR tv186[ebp]
	movzx	eax, BYTE PTR $LN24@SendATCMsg[edx]
	jmp	DWORD PTR $LN26@SendATCMsg[eax*4]
$LN7@SendATCMsg:

; 2877 : 		case lReqClearance:
; 2878 : 			ATCMessage->dataBlock.type		= FalconATCMessage::RequestClearance;

	mov	ecx, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2879 : 			break;

	jmp	SHORT $LN8@SendATCMsg
$LN6@SendATCMsg:

; 2880 : 		case lTakingPosition:
; 2881 : 			ATCMessage->dataBlock.type		= FalconATCMessage::ContactApproach;

	mov	edx, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [edx+56], 2

; 2882 : 			break;		

	jmp	SHORT $LN8@SendATCMsg
$LN5@SendATCMsg:

; 2883 : 		case lReqEmerClearance:
; 2884 : 			ATCMessage->dataBlock.type		= FalconATCMessage::RequestEmerClearance;

	mov	eax, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [eax+56], 1

; 2885 : 			break;

	jmp	SHORT $LN8@SendATCMsg
$LN4@SendATCMsg:

; 2886 : 		case tReqTaxi:
; 2887 : 			ATCMessage->dataBlock.type		= FalconATCMessage::RequestTaxi;

	mov	ecx, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [ecx+56], 4

; 2888 : 		break;

	jmp	SHORT $LN8@SendATCMsg
$LN3@SendATCMsg:

; 2889 : 		case tReqTakeoff:
; 2890 : 			ATCMessage->dataBlock.type		= FalconATCMessage::RequestTakeoff;

	mov	edx, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [edx+56], 3

; 2891 : 		break;

	jmp	SHORT $LN8@SendATCMsg
$LN2@SendATCMsg:

; 2892 : 		case tEmerStop:	
; 2893 : 		case lAborted:
; 2894 : 		case lIngressing:
; 2895 : 		case lHolding:
; 2896 : 		case lFirstLeg:
; 2897 : 		case lToBase:
; 2898 : 		case lToFinal:
; 2899 : 		case lOnFinal:
; 2900 : 		case lLanded:
; 2901 : 		case lTaxiOff:
; 2902 : 		case lEmerHold:
; 2903 : 		case lEmergencyToBase:
; 2904 : 		case lEmergencyToFinal:
; 2905 : 		case lEmergencyOnFinal:
; 2906 : 		case lCrashed:
; 2907 : 		case tTaxi:
; 2908 : 		case tHoldShort:
; 2909 : 		case tPrepToTakeRunway:
; 2910 : 		case tTakeRunway:
; 2911 : 		case tTakeoff:
; 2912 : 		case tFlyOut:
; 2913 : 		case noATC:
; 2914 : 		case tTaxiBack:
; 2915 : 			ATCMessage->dataBlock.type		= FalconATCMessage::UpdateStatus;

	mov	eax, DWORD PTR _ATCMessage$[ebp]
	mov	DWORD PTR [eax+56], 5
$LN8@SendATCMsg:

; 2916 : 			break;
; 2917 : 		default:
; 2918 : 			//we shouldn't get here
; 2919 : 			ShiWarning("Sending unknown ATC message type");
; 2920 : 	}
; 2921 : 
; 2922 : 	FalconSendMessage(ATCMessage, TRUE);

	push	1
	mov	ecx, DWORD PTR _ATCMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN14@SendATCMsg:

; 2923 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN26@SendATCMsg:
	DD	$LN2@SendATCMsg
	DD	$LN7@SendATCMsg
	DD	$LN5@SendATCMsg
	DD	$LN6@SendATCMsg
	DD	$LN4@SendATCMsg
	DD	$LN3@SendATCMsg
	DD	$LN8@SendATCMsg
$LN24@SendATCMsg:
	DB	0
	DB	1
	DB	2
	DB	0
	DB	3
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	6
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	5
	DB	0
	DB	0
	DB	6
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ENDP	; DigitalBrain::SendATCMsg
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
?ResetATC@DigitalBrain@@QAEXXZ PROC			; DigitalBrain::ResetATC
; _this$ = ecx

; 74   : void DigitalBrain::ResetATC(){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 	SetATCStatus(noATC);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 76   : 	if (!(moreFlags & NewHomebase)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+968]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN1@ResetATC

; 77   : 		// we set a new airbase to head to (for example because of fumes fuel -> Actions.cpp)
; 78   : 		airbase = self->HomeAirbase();

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?HomeAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ; AircraftClass::HomeAirbase
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+308], ecx
	mov	DWORD PTR [eax+312], edx
$LN1@ResetATC:

; 79   : 	}
; 80   : 	rwIndex = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 0

; 81   : 	rwtime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+316], 0

; 82   : 	waittimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0

; 83   : 	SetTaxiPoint(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 84   : 	desiredSpeed = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+336], xmm0

; 85   : 	turnDist = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+340], xmm0

; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetATC@DigitalBrain@@QAEXXZ ENDP			; DigitalBrain::ResetATC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?IsSetATC@DigitalBrain@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetATC@DigitalBrain@@QAEHH@Z PROC			; DigitalBrain::IsSetATC, COMDAT
; _this$ = ecx

; 709  : 	int		IsSetATC(int flag)								{return (atcFlags & flag) && TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetATC
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@IsSetATC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetATC
$LN3@IsSetATC:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetATC:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetATC@DigitalBrain@@QAEHH@Z ENDP			; DigitalBrain::IsSetATC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?ClearATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearATCFlag@DigitalBrain@@QAEXH@Z PROC		; DigitalBrain::ClearATCFlag, COMDAT
; _this$ = ecx

; 708  : 	void	ClearATCFlag(int flag)							{atcFlags &= ~flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+300]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearATCFlag@DigitalBrain@@QAEXH@Z ENDP		; DigitalBrain::ClearATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetATCFlag@DigitalBrain@@QAEXH@Z PROC			; DigitalBrain::SetATCFlag, COMDAT
; _this$ = ecx

; 707  : 	void	SetATCFlag(int flag)							{atcFlags |= flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetATCFlag@DigitalBrain@@QAEXH@Z ENDP			; DigitalBrain::SetATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv436 = -96						; size = 4
tv429 = -92						; size = 4
tv393 = -88						; size = 4
tv387 = -84						; size = 4
tv205 = -80						; size = 4
tv164 = -76						; size = 4
tv163 = -72						; size = 4
tv156 = -68						; size = 4
_x1$ = -64						; size = 4
_y1$ = -60						; size = 4
_queue$1 = -56						; size = 4
_tmpY$ = -52						; size = 4
_tmpX$ = -48						; size = 4
_length$2 = -44						; size = 4
_runwayStats$ = -40					; size = 4
_point$ = -36						; size = 4
_relx$ = -32						; size = 4
_Airbase$ = -28						; size = 4
_cosHdg$ = -24						; size = 4
_sinHdg$ = -20						; size = 4
_dist$ = -16						; size = 4
_dx$ = -12						; size = 4
_dy$ = -8						; size = 4
_this$ = -4						; size = 4
_offDist$ = 8						; size = 4
_dir$ = 12						; size = 4
?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z PROC		; DigitalBrain::OffsetTrackPoint
; _this$ = ecx

; 2962 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 2963 : 	float dx=0.0F, dy=0.0F, dist=0.0F, relx=0.0F, x1=0.0F, y1=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dist$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _relx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _y1$[ebp], xmm0

; 2964 : 	float cosHdg=1.0F, sinHdg=0.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cosHdg$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 2965 : 	int point=0;

	mov	DWORD PTR _point$[ebp], 0

; 2966 : 	float tmpX=0.0F, tmpY=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tmpX$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 2967 : 	ObjectiveClass *Airbase = NULL;

	mov	DWORD PTR _Airbase$[ebp], 0

; 2968 : 	runwayStatsStruct *runwayStats = NULL;

	mov	DWORD PTR _runwayStats$[ebp], 0

; 2969 : 
; 2970 : 	if(dir == centerRunway)

	cmp	DWORD PTR _dir$[ebp], 10		; 0000000aH
	jne	$LN18@OffsetTrac

; 2971 : 	{
; 2972 : 		Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 2973 : 		if(Airbase)

	cmp	DWORD PTR _Airbase$[ebp], 0
	je	$LN17@OffsetTrac

; 2974 : 		{
; 2975 : 			int queue = GetQueue(rwIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$1[ebp], eax

; 2976 : 			runwayStats = Airbase->brain->GetRunwayStats();

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?GetRunwayStats@ATCBrain@@QAEPAUrunwayStatsStruct@@XZ ; ATCBrain::GetRunwayStats
	mov	DWORD PTR _runwayStats$[ebp], eax

; 2977 : 			float length = runwayStats[queue].halfheight;

	mov	eax, DWORD PTR _queue$1[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _runwayStats$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+12]
	movss	DWORD PTR _length$2[ebp], xmm0

; 2978 : 			//TranslatePointData(Airbase, pt, &x1, &y1);
; 2979 : 			x1 = runwayStats[queue].centerX;

	mov	edx, DWORD PTR _queue$1[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _runwayStats$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+16]
	movss	DWORD PTR _x1$[ebp], xmm0

; 2980 : 			y1 = runwayStats[queue].centerY;

	mov	ecx, DWORD PTR _queue$1[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _runwayStats$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2981 : 			
; 2982 : 			dx = x1 - self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv387[ebp]
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR tv387[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2983 : 			dy = y1 - self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv393[ebp]
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR tv393[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2984 : 			
; 2985 : 			relx = (	PtHeaderDataTable[rwIndex].cosHeading*dx + 
; 2986 : 						PtHeaderDataTable[rwIndex].sinHeading*dy);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR [ecx+eax+12]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 2987 : 
; 2988 : 			relx = max(min(relx,length - TAXI_CHECK_DIST),0.0F);

	movss	xmm0, DWORD PTR _length$2[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	SHORT $LN21@OffsetTrac
	movss	xmm0, DWORD PTR _relx$[ebp]
	movss	DWORD PTR tv156[ebp], xmm0
	jmp	SHORT $LN22@OffsetTrac
$LN21@OffsetTrac:
	movss	xmm0, DWORD PTR _length$2[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR tv156[ebp], xmm0
$LN22@OffsetTrac:
	movss	xmm0, DWORD PTR tv156[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN25@OffsetTrac
	movss	xmm0, DWORD PTR _length$2[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	SHORT $LN23@OffsetTrac
	movss	xmm0, DWORD PTR _relx$[ebp]
	movss	DWORD PTR tv163[ebp], xmm0
	jmp	SHORT $LN24@OffsetTrac
$LN23@OffsetTrac:
	movss	xmm0, DWORD PTR _length$2[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR tv163[ebp], xmm0
$LN24@OffsetTrac:
	movss	xmm0, DWORD PTR tv163[ebp]
	movss	DWORD PTR tv164[ebp], xmm0
	jmp	SHORT $LN26@OffsetTrac
$LN25@OffsetTrac:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv164[ebp], xmm0
$LN26@OffsetTrac:
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _relx$[ebp], xmm0

; 2989 : 
; 2990 : 			SetTrackPoint(
; 2991 : 				x1 - relx * PtHeaderDataTable[rwIndex].cosHeading, 
; 2992 : 				y1 - relx * PtHeaderDataTable[rwIndex].sinHeading
; 2993 : 			);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _relx$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+12]
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _relx$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+16]
	movss	xmm1, DWORD PTR _x1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
$LN17@OffsetTrac:

; 2994 : 		}
; 2995 : 		return;

	jmp	$LN19@OffsetTrac
$LN18@OffsetTrac:

; 2996 : 	}
; 2997 : 
; 2998 : 	dx = trackX - self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv429[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR tv429[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2999 : 	dy = trackY - self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv436[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR tv436[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3000 : 	dist = (float)sqrt(dx*dx + dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3001 : 	
; 3002 : 	//these are cos and sin of hdg to offset point along
; 3003 : 	switch(dir)

	mov	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR tv205[ebp], eax
	cmp	DWORD PTR tv205[ebp], 9
	ja	$LN15@OffsetTrac
	mov	ecx, DWORD PTR tv205[ebp]
	jmp	DWORD PTR $LN27@OffsetTrac[ecx*4]
$LN14@OffsetTrac:

; 3004 : 	{
; 3005 : 	case offForward: //forward
; 3006 : 		cosHdg = dx/dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3007 : 		sinHdg = dy/dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3008 : 		break;

	jmp	$LN15@OffsetTrac
$LN13@OffsetTrac:

; 3009 : 	case offRight: //right
; 3010 : 		cosHdg = -dy/dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3011 : 		sinHdg = dx/dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3012 : 		break;

	jmp	$LN15@OffsetTrac
$LN12@OffsetTrac:

; 3013 : 	case offBack: //back
; 3014 : 		cosHdg = -dx/dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3015 : 		sinHdg = -dy/dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3016 : 		break;

	jmp	$LN15@OffsetTrac
$LN11@OffsetTrac:

; 3017 : 	case offLeft: //left
; 3018 : 		cosHdg = dy/dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3019 : 		sinHdg = -dx/dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3020 : 		break;

	jmp	$LN15@OffsetTrac
$LN10@OffsetTrac:

; 3021 : 	case downRunway:
; 3022 : 		cosHdg = PtHeaderDataTable[rwIndex].cosHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3023 : 		sinHdg = PtHeaderDataTable[rwIndex].sinHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+12]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3024 : 		break;

	jmp	$LN15@OffsetTrac
$LN9@OffsetTrac:

; 3025 : 	case upRunway:
; 3026 : 		cosHdg = -PtHeaderDataTable[rwIndex].cosHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3027 : 		sinHdg = -PtHeaderDataTable[rwIndex].sinHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3028 : 		break;

	jmp	$LN15@OffsetTrac
$LN8@OffsetTrac:

; 3029 : 	case rightRunway:
; 3030 : 		cosHdg = -PtHeaderDataTable[rwIndex].sinHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3031 : 		sinHdg = PtHeaderDataTable[rwIndex].cosHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3032 : 		break;

	jmp	$LN15@OffsetTrac
$LN7@OffsetTrac:

; 3033 : 	case leftRunway:
; 3034 : 		cosHdg = PtHeaderDataTable[rwIndex].sinHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+12]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3035 : 		sinHdg = -PtHeaderDataTable[rwIndex].cosHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3036 : 		break;

	jmp	$LN15@OffsetTrac
$LN6@OffsetTrac:

; 3037 : 	case taxiLeft:
; 3038 : 		Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+312]
	push	eax
	mov	ecx, DWORD PTR [edx+308]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 3039 : 		if(Airbase)

	cmp	DWORD PTR _Airbase$[ebp], 0
	je	$LN5@OffsetTrac

; 3040 : 		{
; 3041 : 			point = GetPrevPtLoop(curTaxiPoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 3042 : 			TranslatePointData (Airbase, point, &tmpX, &tmpY);

	lea	ecx, DWORD PTR _tmpY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpX$[ebp]
	push	edx
	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3043 : 			dx = tmpX - trackX;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	subss	xmm0, DWORD PTR [edx+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3044 : 			dy = tmpY - trackY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	subss	xmm0, DWORD PTR [eax+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3045 : 			dist = (float)sqrt(dx*dx + dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3046 : 			cosHdg = dy/dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3047 : 			sinHdg = -dx/dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _sinHdg$[ebp], xmm0
$LN5@OffsetTrac:

; 3048 : 		}
; 3049 : 		break;

	jmp	$LN15@OffsetTrac
$LN4@OffsetTrac:

; 3050 : 	case taxiRight:
; 3051 : 		Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	push	edx
	mov	eax, DWORD PTR [ecx+308]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 3052 : 		if(Airbase)

	cmp	DWORD PTR _Airbase$[ebp], 0
	je	$LN3@OffsetTrac

; 3053 : 		{
; 3054 : 			if(PtDataTable[curTaxiPoint].type == RunwayPt)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 1
	jne	SHORT $LN2@OffsetTrac

; 3055 : 				point = GetNextPtLoop(curTaxiPoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 3056 : 			else

	jmp	SHORT $LN1@OffsetTrac
$LN2@OffsetTrac:

; 3057 : 				point = GetPrevPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax
$LN1@OffsetTrac:

; 3058 : 			TranslatePointData (Airbase, point, &tmpX, &tmpY);

	lea	eax, DWORD PTR _tmpY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3059 : 			dx = tmpX - trackX;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	subss	xmm0, DWORD PTR [ecx+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3060 : 			dy = tmpY - trackY;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	subss	xmm0, DWORD PTR [edx+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3061 : 			dist = (float)sqrt(dx*dx + dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3062 : 			cosHdg = -dy/dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3063 : 			sinHdg = dx/dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _sinHdg$[ebp], xmm0
$LN3@OffsetTrac:
$LN15@OffsetTrac:

; 3064 : 		}
; 3065 : 		break;
; 3066 : 	}
; 3067 : 
; 3068 : 	SetTrackPoint(trackX + cosHdg*offDist, trackY + sinHdg*offDist);

	movss	xmm0, DWORD PTR _sinHdg$[ebp]
	mulss	xmm0, DWORD PTR _offDist$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+152]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _cosHdg$[ebp]
	mulss	xmm0, DWORD PTR _offDist$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+148]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
$LN19@OffsetTrac:

; 3069 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN27@OffsetTrac:
	DD	$LN14@OffsetTrac
	DD	$LN13@OffsetTrac
	DD	$LN12@OffsetTrac
	DD	$LN11@OffsetTrac
	DD	$LN6@OffsetTrac
	DD	$LN4@OffsetTrac
	DD	$LN10@OffsetTrac
	DD	$LN9@OffsetTrac
	DD	$LN8@OffsetTrac
	DD	$LN7@OffsetTrac
?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ENDP		; DigitalBrain::OffsetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_leader$ = -8						; size = 4
_this$ = -4						; size = 4
_Airbase$ = 8						; size = 4
?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@@Z PROC ; DigitalBrain::WingmanTakeRunway
; _this$ = ecx

; 2205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2206 : 	AircraftClass *leader = (AircraftClass*)self->GetCampaignObject()->GetComponentNumber(self->vehicleInUnit - 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _leader$[ebp], eax

; 2207 : 
; 2208 : 	return WingmanTakeRunway(Airbase, (AircraftClass *)flightLead, leader);

	mov	ecx, DWORD PTR _leader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z ; DigitalBrain::WingmanTakeRunway

; 2209 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@@Z ENDP ; DigitalBrain::WingmanTakeRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv641 = -56						; size = 4
tv635 = -52						; size = 4
tv622 = -48						; size = 4
tv616 = -44						; size = 4
tv606 = -40						; size = 4
tv561 = -36						; size = 4
tv551 = -32						; size = 4
tv545 = -28						; size = 4
tv521 = -24						; size = 4
tv71 = -20						; size = 4
_tempX$ = -16						; size = 4
_tempY$ = -12						; size = 4
_pt$ = -8						; size = 4
_this$ = -4						; size = 4
_Airbase$ = 8						; size = 4
_FlightLead$ = 12					; size = 4
_leader$ = 16						; size = 4
?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z PROC ; DigitalBrain::WingmanTakeRunway
; _this$ = ecx

; 2212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2213 : 	int pt;
; 2214 : 	float tempX, tempY;
; 2215 : 	//when this function is called, I already know that the point will not move me past any wingmen in front
; 2216 : 	//of me unless they are gone or off the ground
; 2217 : 
; 2218 : 	switch(self->vehicleInUnit)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	dl, BYTE PTR [ecx+664]
	mov	BYTE PTR tv71[ebp], dl
	cmp	BYTE PTR tv71[ebp], 0
	je	SHORT $LN36@WingmanTak
	cmp	BYTE PTR tv71[ebp], 1
	je	SHORT $LN35@WingmanTak
	cmp	BYTE PTR tv71[ebp], 2
	je	$LN25@WingmanTak
	jmp	$LN16@WingmanTak
$LN36@WingmanTak:

; 2219 : 	{
; 2220 : 	case 0:
; 2221 : 		ShiWarning("This should never happen");
; 2222 : 		return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak

; 2223 : 		break;

	jmp	$LN37@WingmanTak
$LN35@WingmanTak:

; 2224 : 
; 2225 : 	case 1:	
; 2226 : 		pt = GetPrevPtLoop(curTaxiPoint);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 2227 : 		
; 2228 : 		TranslatePointData(Airbase, pt, &tempX, &tempY);

	lea	edx, DWORD PTR _tempY$[ebp]
	push	edx
	lea	eax, DWORD PTR _tempX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2229 : 		if(!Airbase->brain->IsOnRunway(tempX, tempY))

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tempY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	jne	SHORT $LN34@WingmanTak

; 2230 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
	jmp	$LN26@WingmanTak
$LN34@WingmanTak:

; 2231 : 		else if(!FlightLead)

	cmp	DWORD PTR _FlightLead$[ebp], 0
	jne	SHORT $LN32@WingmanTak

; 2232 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
	jmp	$LN26@WingmanTak
$LN32@WingmanTak:

; 2233 : 		else if(!FlightLead->OnGround())

	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN30@WingmanTak

; 2234 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
	jmp	$LN26@WingmanTak
$LN30@WingmanTak:

; 2235 : 		else if(Airbase->brain->IsOnRunway(FlightLead)  && Airbase->brain->UseSectionTakeoff((Flight)self->GetCampaignObject(),rwIndex))

	mov	ecx, DWORD PTR _FlightLead$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN28@WingmanTak
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN28@WingmanTak

; 2236 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak

; 2237 : 		//RAS-28Oct04-Speed up #2 taking Rwy
; 2238 : 		else if(Airbase->brain->IsOnRunway(FlightLead)  && !Airbase->brain->UseSectionTakeoff((Flight)self->GetCampaignObject(),rwIndex)

	jmp	SHORT $LN26@WingmanTak
$LN28@WingmanTak:

; 2239 : 			&& FlightLead->GetVt() > 40.0 * KNOTS_TO_FTPSEC)

	mov	ecx, DWORD PTR _FlightLead$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN26@WingmanTak
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	jne	SHORT $LN26@WingmanTak
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv521[ebp]
	movss	xmm0, DWORD PTR tv521[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4050e0dc3c000000
	jbe	SHORT $LN26@WingmanTak

; 2240 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
$LN26@WingmanTak:

; 2241 : 		break;

	jmp	$LN37@WingmanTak
$LN25@WingmanTak:

; 2242 : 
; 2243 : 	case 2: // Element Leader
; 2244 : 		pt = GetPrevPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 2245 : 		
; 2246 : 		TranslatePointData(Airbase, pt, &tempX, &tempY);

	lea	eax, DWORD PTR _tempY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pt$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2247 : 		if(!Airbase->brain->IsOnRunway(tempX, tempY))

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tempY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	jne	SHORT $LN24@WingmanTak

; 2248 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
$LN24@WingmanTak:

; 2249 : 
; 2250 : 		//RAS - 16Oct04 - Get aircraft on runway and airborne sooner by checking to see if aircraft in
; 2251 : 		//front of them on t/o roll are greater than 80 kts, if so, take the runway
; 2252 : 		if(FlightLead && !FlightLead->OnGround()) // Cobra - if Flight leader is in the air

	cmp	DWORD PTR _FlightLead$[ebp], 0
	je	SHORT $LN23@WingmanTak
	mov	edx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN23@WingmanTak

; 2253 : 		{
; 2254 : 			if (
; 2255 : 				(FlightLead->GetVt() > 40 * KNOTS_TO_FTPSEC) && 
; 2256 : 				leader && 
; 2257 : 				(leader->GetVt() > 40.0 * KNOTS_TO_FTPSEC)
; 2258 : 			){

	mov	eax, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv545[ebp]
	movss	xmm0, DWORD PTR tv545[ebp]
	comiss	xmm0, DWORD PTR __real@428706e2
	jbe	SHORT $LN22@WingmanTak
	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN22@WingmanTak
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv551[ebp]
	movss	xmm0, DWORD PTR tv551[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4050e0dc3c000000
	jbe	SHORT $LN22@WingmanTak

; 2259 : 				return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
$LN22@WingmanTak:

; 2260 : 			}
; 2261 : 		}

	jmp	SHORT $LN17@WingmanTak
$LN23@WingmanTak:

; 2262 : 
; 2263 : 		//RAS - 16Oct04 - Get aircraft on runway and airborne sooner by checking to see if aircraft in
; 2264 : 		//front of them on t/o roll are greater than 50 kts, if so, take the runway
; 2265 : 
; 2266 : 		else if(leader && leader->OnGround() && leader->GetVt() > 40.0 * KNOTS_TO_FTPSEC)

	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN20@WingmanTak
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN20@WingmanTak
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv561[ebp]
	movss	xmm0, DWORD PTR tv561[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4050e0dc3c000000
	jbe	SHORT $LN20@WingmanTak

; 2267 :             return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
	jmp	SHORT $LN17@WingmanTak
$LN20@WingmanTak:

; 2268 : 		else if(leader && !leader->OnGround())

	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN18@WingmanTak
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN18@WingmanTak

; 2269 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak

; 2270 : 		else

	jmp	SHORT $LN17@WingmanTak
$LN18@WingmanTak:

; 2271 : 			return FALSE;

	xor	eax, eax
	jmp	$LN39@WingmanTak
$LN17@WingmanTak:

; 2272 : 		break;

	jmp	$LN37@WingmanTak
$LN16@WingmanTak:

; 2273 : 
; 2274 : 	default:
; 2275 : 	case 3: // Element Wingman
; 2276 : 		pt = GetPrevPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 2277 : 		
; 2278 : 		TranslatePointData(Airbase, pt, &tempX, &tempY);

	lea	eax, DWORD PTR _tempY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pt$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2279 : 		if(!Airbase->brain->IsOnRunway(tempX, tempY))

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tempY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	jne	SHORT $LN15@WingmanTak

; 2280 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
	jmp	$LN11@WingmanTak
$LN15@WingmanTak:

; 2281 : 		else if(leader && Airbase->brain->IsOnRunway(leader)  && Airbase->brain->UseSectionTakeoff((Flight)self->GetCampaignObject(),rwIndex))

	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN13@WingmanTak
	mov	edx, DWORD PTR _leader$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN13@WingmanTak
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN13@WingmanTak

; 2282 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak

; 2283 : 		//RAS-28Oct04-Speed up #4 taking Rwy
; 2284 : 		else if (leader && Airbase->brain->IsOnRunway(leader)  && !Airbase->brain->UseSectionTakeoff((Flight)self->GetCampaignObject(),rwIndex)

	jmp	SHORT $LN11@WingmanTak
$LN13@WingmanTak:

; 2285 : 			&& leader->GetVt() > 40.0 * KNOTS_TO_FTPSEC)

	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN11@WingmanTak
	mov	edx, DWORD PTR _leader$[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN11@WingmanTak
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	jne	SHORT $LN11@WingmanTak
	mov	edx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv606[ebp]
	movss	xmm0, DWORD PTR tv606[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4050e0dc3c000000
	jbe	SHORT $LN11@WingmanTak

; 2286 : 			return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
$LN11@WingmanTak:

; 2287 : 
; 2288 : 		//RAS - 28Oct04 -speed up #4 taking rwy
; 2289 : 		if(FlightLead && !FlightLead->OnGround())

	cmp	DWORD PTR _FlightLead$[ebp], 0
	je	SHORT $LN9@WingmanTak
	mov	eax, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN9@WingmanTak

; 2290 : 		{
; 2291 : 			if(FlightLead->GetVt() > 50 * KNOTS_TO_FTPSEC && leader && leader->GetVt() > 40.0 * KNOTS_TO_FTPSEC)

	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv616[ebp]
	movss	xmm0, DWORD PTR tv616[ebp]
	comiss	xmm0, DWORD PTR __real@42a8c89a
	jbe	SHORT $LN9@WingmanTak
	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN9@WingmanTak
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv622[ebp]
	movss	xmm0, DWORD PTR tv622[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4050e0dc3c000000
	jbe	SHORT $LN9@WingmanTak

; 2292 : 				return TRUE;

	mov	eax, 1
	jmp	$LN39@WingmanTak
$LN9@WingmanTak:

; 2293 : 		}
; 2294 : 
; 2295 : 		FlightLead = (AircraftClass*)self->GetCampaignObject()->GetComponentNumber(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _FlightLead$[ebp], eax

; 2296 : 
; 2297 : 		//RAS - 28Oct04 -speed up #4 taking rwy
; 2298 : 		if(FlightLead && !FlightLead->OnGround())

	cmp	DWORD PTR _FlightLead$[ebp], 0
	je	SHORT $LN8@WingmanTak
	mov	edx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN8@WingmanTak

; 2299 : 		{
; 2300 : 			if(FlightLead->GetVt() > 50 * KNOTS_TO_FTPSEC && leader && leader->GetVt() > 40.0 * KNOTS_TO_FTPSEC)

	mov	eax, DWORD PTR _FlightLead$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _FlightLead$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv635[ebp]
	movss	xmm0, DWORD PTR tv635[ebp]
	comiss	xmm0, DWORD PTR __real@42a8c89a
	jbe	SHORT $LN7@WingmanTak
	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN7@WingmanTak
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv641[ebp]
	movss	xmm0, DWORD PTR tv641[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4050e0dc3c000000
	jbe	SHORT $LN7@WingmanTak

; 2301 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $LN39@WingmanTak
$LN7@WingmanTak:

; 2302 : 		}

	jmp	SHORT $LN1@WingmanTak
$LN8@WingmanTak:

; 2303 : 		else if(!leader)

	cmp	DWORD PTR _leader$[ebp], 0
	jne	SHORT $LN5@WingmanTak

; 2304 :             return TRUE;

	mov	eax, 1
	jmp	SHORT $LN39@WingmanTak
	jmp	SHORT $LN1@WingmanTak
$LN5@WingmanTak:

; 2305 : 		else if(!leader->OnGround())

	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN3@WingmanTak

; 2306 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN39@WingmanTak
	jmp	SHORT $LN1@WingmanTak
$LN3@WingmanTak:

; 2307 : 		else if(Airbase->brain->IsOnRunway(leader) && Airbase->brain->UseSectionTakeoff((Flight)self->GetCampaignObject(),rwIndex))

	mov	ecx, DWORD PTR _leader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN1@WingmanTak
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN1@WingmanTak

; 2308 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN39@WingmanTak
$LN1@WingmanTak:
$LN37@WingmanTak:

; 2309 : 		break;
; 2310 : 	}
; 2311 : 
; 2312 : 	return FALSE;

	xor	eax, eax
$LN39@WingmanTak:

; 2313 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z ENDP ; DigitalBrain::WingmanTakeRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv631 = -76						; size = 4
tv685 = -72						; size = 4
tv626 = -68						; size = 4
tv622 = -64						; size = 4
tv683 = -60						; size = 4
tv617 = -56						; size = 4
tv605 = -52						; size = 4
_tx$1 = -48						; size = 4
_ty$2 = -44						; size = 4
tv237 = -40						; size = 4
tv136 = -36						; size = 4
tv406 = -32						; size = 4
_ry$ = -28						; size = 4
_extraWait$ = -24					; size = 4
_inTheWay2$ = -20					; size = 4
_tmpY$ = -16						; size = 4
_tmpX$ = -12						; size = 4
_this$ = -8						; size = 4
_BigBoy$ = -1						; size = 1
_inTheWay$ = 8						; size = 4
_Airbase$ = 12						; size = 4
?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z PROC ; DigitalBrain::DealWithBlocker
; _this$ = ecx

; 2316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2317 : 	float tmpX=0.0F, tmpY=0.0F, ry=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tmpX$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tmpY$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ry$[ebp], xmm0

; 2318 : 	int extraWait = 0;

	mov	DWORD PTR _extraWait$[ebp], 0

; 2319 : 	bool BigBoy = false;

	mov	BYTE PTR _BigBoy$[ebp], 0

; 2320 : 
; 2321 : 	SimBaseClass *inTheWay2 = NULL;

	mov	DWORD PTR _inTheWay2$[ebp], 0

; 2322 : 
; 2323 : 	// Cobra - "large" aircraft?
; 2324 : 	if (self->af->GetParkType() == LargeParkPt)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN47@DealWithBl

; 2325 : 		BigBoy = true;

	mov	BYTE PTR _BigBoy$[ebp], 1
$LN47@DealWithBl:

; 2326 : 
; 2327 : 	desiredSpeed = 0.0F;	

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+336], xmm0

; 2328 : 	
; 2329 : 	if(inTheWay->GetCampaignObject() == self->GetCampaignObject() && self->vehicleInUnit > ((AircraftClass*)inTheWay)->vehicleInUnit)

	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	esi, eax
	jne	SHORT $LN46@DealWithBl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	eax, edx
	jle	SHORT $LN46@DealWithBl

; 2330 : 	{
; 2331 : 		return;//we never taxi around fellow flight members

	jmp	$LN48@DealWithBl
$LN46@DealWithBl:

; 2332 : 	}
; 2333 : 
; 2334 : 	switch(PtDataTable[curTaxiPoint].type)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	al, BYTE PTR [edx+ecx+8]
	mov	BYTE PTR tv136[ebp], al
	cmp	BYTE PTR tv136[ebp], 1
	je	SHORT $LN42@DealWithBl
	cmp	BYTE PTR tv136[ebp], 2
	je	SHORT $LN43@DealWithBl
	jmp	$LN41@DealWithBl
$LN43@DealWithBl:

; 2335 : 	{	
; 2336 : 		case TakeoffPt:
; 2337 : 			SetTaxiPoint(
; 2338 : 				Airbase->brain->FindTakeoffPt(
; 2339 : 					(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tmpX, &tmpY
; 2340 : 				)
; 2341 : 			);

	lea	ecx, DWORD PTR _tmpY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpX$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, BYTE PTR [eax+664]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2342 : 			break;

	jmp	$LN44@DealWithBl
$LN42@DealWithBl:

; 2343 : 		case RunwayPt:
; 2344 : 		{
; 2345 : 			float tx, ty;
; 2346 : 			SetTaxiPoint(
; 2347 : 				Airbase->brain->FindRunwayPt(
; 2348 : 					(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 2349 : 				)
; 2350 : 			);

	lea	ecx, DWORD PTR _ty$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, BYTE PTR [eax+664]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindRunwayPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2351 : 			SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2352 : 		}
; 2353 : 		break;

	jmp	SHORT $LN44@DealWithBl
$LN41@DealWithBl:

; 2354 : 
; 2355 : 		default:
; 2356 : 		case TaxiPt:
; 2357 : 			TranslatePointData(Airbase, curTaxiPoint, &tmpX, &tmpY);

	lea	ecx, DWORD PTR _tmpY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpX$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H
$LN44@DealWithBl:

; 2358 : 			break;
; 2359 : 	}
; 2360 : 
; 2361 : 	if(tmpX != trackX || tmpY != trackY)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	ucomiss	xmm0, DWORD PTR [eax+148]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN39@DealWithBl
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	ucomiss	xmm0, DWORD PTR [ecx+152]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@DealWithBl
$LN39@DealWithBl:

; 2362 : 		inTheWay2 = CheckPoint (tmpX, tmpY);

	push	ecx
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckPoint@DigitalBrain@@IAEPAVSimBaseClass@@MM@Z ; DigitalBrain::CheckPoint
	mov	DWORD PTR _inTheWay2$[ebp], eax

; 2363 : 	else

	jmp	SHORT $LN38@DealWithBl
$LN40@DealWithBl:

; 2364 : 		inTheWay2 = inTheWay;

	mov	edx, DWORD PTR _inTheWay$[ebp]
	mov	DWORD PTR _inTheWay2$[ebp], edx
$LN38@DealWithBl:

; 2365 : 
; 2366 : 	if(atcstatus != tTakeRunway)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 26			; 0000001aH
	je	SHORT $LN36@DealWithBl

; 2367 : 	{
; 2368 : 		extraWait = FalconLocalGame->rules.AiPatience;	// FRB - not *that* patient!

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN50@DealWithBl
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv237[ebp], eax
	jmp	SHORT $LN51@DealWithBl
$LN50@DealWithBl:
	mov	DWORD PTR tv237[ebp], 0
$LN51@DealWithBl:
	mov	edx, DWORD PTR tv237[ebp]
	mov	eax, DWORD PTR [edx+420]
	mov	DWORD PTR _extraWait$[ebp], eax

; 2369 : 
; 2370 : 		if(rwtime > SimLibElapsedTime)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+316]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jbe	SHORT $LN36@DealWithBl

; 2371 : 			extraWait += (rwtime - SimLibElapsedTime) / 20;	// FRB - Could be a long extra wait (was 20)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	xor	edx, edx
	mov	ecx, 20					; 00000014H
	div	ecx
	add	eax, DWORD PTR _extraWait$[ebp]
	mov	DWORD PTR _extraWait$[ebp], eax
$LN36@DealWithBl:

; 2372 : 	}
; 2373 : 
; 2374 : 	if(!inTheWay2 && (!inTheWay->IsAirplane() || ((AircraftClass*)inTheWay)->DBrain()->RwTime() > rwtime) )

	cmp	DWORD PTR _inTheWay2$[ebp], 0
	jne	$LN35@DealWithBl
	mov	edx, DWORD PTR _inTheWay$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	SHORT $LN34@DealWithBl
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?RwTime@DigitalBrain@@QAEKXZ		; DigitalBrain::RwTime
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+316]
	jbe	$LN35@DealWithBl
$LN34@DealWithBl:

; 2375 : 	{
; 2376 : 		SetTrackPoint(tmpX, tmpY);

	push	ecx
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2377 : 		waittimer = CalcWaitTime(Airbase->brain);

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 2378 : 		if(SimLibElapsedTime > waittimer + TAKEOFF_TIME_DELTA){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	add	eax, 10000				; 00002710H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, eax	; SimLibElapsedTime
	jbe	SHORT $LN33@DealWithBl

; 2379 : 			CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2380 : 		}
; 2381 : 		else{

	jmp	SHORT $LN32@DealWithBl
$LN33@DealWithBl:

; 2382 : 			CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN32@DealWithBl:

; 2383 : 		}
; 2384 : 	}
; 2385 : 	else if((isWing && (!inTheWay2 || inTheWay2->GetCampaignObject() != self->GetCampaignObject() || 

	jmp	$LN25@DealWithBl
$LN35@DealWithBl:

; 2386 : 			self->vehicleInUnit < ((AircraftClass*)inTheWay2)->vehicleInUnit)) || 
; 2387 : 			(inTheWay->GetVt() < 5.0F && SimLibElapsedTime > waittimer + extraWait) || 
; 2388 : 			(inTheWay->IsAirplane() && ((AircraftClass*)inTheWay)->DBrain()->RwTime() > rwtime))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN28@DealWithBl
	cmp	DWORD PTR _inTheWay2$[ebp], 0
	je	$LN29@DealWithBl
	mov	ecx, DWORD PTR _inTheWay2$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	esi, eax
	jne	$LN29@DealWithBl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	mov	eax, DWORD PTR _inTheWay2$[ebp]
	movzx	ecx, BYTE PTR [eax+664]
	cmp	edx, ecx
	jl	SHORT $LN29@DealWithBl
$LN28@DealWithBl:
	mov	edx, DWORD PTR _inTheWay$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv605[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR tv605[ebp]
	jbe	SHORT $LN27@DealWithBl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	add	ecx, DWORD PTR _extraWait$[ebp]
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, ecx	; SimLibElapsedTime
	ja	SHORT $LN29@DealWithBl
$LN27@DealWithBl:
	mov	edx, DWORD PTR _inTheWay$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN25@DealWithBl
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?RwTime@DigitalBrain@@QAEKXZ		; DigitalBrain::RwTime
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+316]
	jbe	$LN25@DealWithBl
$LN29@DealWithBl:

; 2389 : 	{
; 2390 : 		tmpX = inTheWay->XPos() - self->XPos();

	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv617[ebp]
	movss	xmm0, DWORD PTR tv617[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv683[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv622[ebp]
	movss	xmm0, DWORD PTR tv683[ebp]
	subss	xmm0, DWORD PTR tv622[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 2391 : 		tmpY = inTheWay->YPos() - self->YPos();

	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv626[ebp]
	movss	xmm0, DWORD PTR tv626[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv685[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv631[ebp]
	movss	xmm0, DWORD PTR tv685[ebp]
	subss	xmm0, DWORD PTR tv631[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 2392 : 		ry	= self->dmx[1][0] * tmpX + self->dmx[1][1] * tmpY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 2393 : 
; 2394 : 		switch(PtDataTable[GetPrevPtLoop(curTaxiPoint)].type)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	dl, BYTE PTR [ecx+eax+8]
	mov	BYTE PTR tv406[ebp], dl
	cmp	BYTE PTR tv406[ebp], 0
	jbe	SHORT $LN24@DealWithBl
	cmp	BYTE PTR tv406[ebp], 2
	jbe	$LN5@DealWithBl
	cmp	BYTE PTR tv406[ebp], 15			; 0000000fH
	je	SHORT $LN18@DealWithBl
$LN24@DealWithBl:

; 2395 : 		{
; 2396 : 			default:
; 2397 : 			case CritTaxiPt:
; 2398 : 			case TaxiPt:
; 2399 : 				if (!BigBoy) // Skip the dance for big boys

	movzx	eax, BYTE PTR _BigBoy$[ebp]
	test	eax, eax
	jne	SHORT $LN21@DealWithBl
$LN22@DealWithBl:

; 2400 : 				{
; 2401 : 					while(CheckTaxiTrackPoint() == inTheWay)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	cmp	eax, DWORD PTR _inTheWay$[ebp]
	jne	SHORT $LN21@DealWithBl

; 2402 : 					{
; 2403 : 						if(ry > 0.0F)

	movss	xmm0, DWORD PTR _ry$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN20@DealWithBl

; 2404 : 							OffsetTrackPoint(10.0F, offLeft);

	push	3
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2405 : 						else

	jmp	SHORT $LN19@DealWithBl
$LN20@DealWithBl:

; 2406 : 							OffsetTrackPoint(10.0F, offRight);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN19@DealWithBl:

; 2407 : 					}

	jmp	SHORT $LN22@DealWithBl
$LN21@DealWithBl:

; 2408 : 				}
; 2409 : 				CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2410 : 			break;

	jmp	$LN25@DealWithBl
$LN18@DealWithBl:

; 2411 : 
; 2412 : 			case TakeRunwayPt:
; 2413 : 				//take runway if we have permission, else holdshort
; 2414 : 				if(isWing || IsSetATC(PermitRunway) || IsSetATC(PermitTakeRunway))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN16@DealWithBl
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN16@DealWithBl
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN17@DealWithBl
$LN16@DealWithBl:

; 2415 : 				{					
; 2416 : 					while(CheckTaxiTrackPoint() == inTheWay)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	cmp	eax, DWORD PTR _inTheWay$[ebp]
	jne	SHORT $LN14@DealWithBl

; 2417 : 					{
; 2418 : 						if(ry > 0.0F)

	movss	xmm0, DWORD PTR _ry$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN13@DealWithBl

; 2419 : 							OffsetTrackPoint(10.0F, offLeft);

	push	3
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2420 : 						else

	jmp	SHORT $LN12@DealWithBl
$LN13@DealWithBl:

; 2421 : 							OffsetTrackPoint(10.0F, offRight);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN12@DealWithBl:

; 2422 : 					}

	jmp	SHORT $LN16@DealWithBl
$LN14@DealWithBl:

; 2423 : 					CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
	jmp	$LN10@DealWithBl
$LN17@DealWithBl:

; 2424 : 				}
; 2425 : 				else if(PtDataTable[curTaxiPoint].type == TakeRunwayPt)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN10@DealWithBl
$LN9@DealWithBl:

; 2426 : 				{
; 2427 : 					while(CheckTaxiTrackPoint() == inTheWay)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	cmp	eax, DWORD PTR _inTheWay$[ebp]
	jne	SHORT $LN8@DealWithBl

; 2428 : 					{
; 2429 : 						if(ry > 0.0F)

	movss	xmm0, DWORD PTR _ry$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@DealWithBl

; 2430 : 							OffsetTrackPoint(10.0F, offLeft);

	push	3
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2431 : 						else

	jmp	SHORT $LN6@DealWithBl
$LN7@DealWithBl:

; 2432 : 							OffsetTrackPoint(10.0F, offRight);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN6@DealWithBl:

; 2433 : 					}

	jmp	SHORT $LN9@DealWithBl
$LN8@DealWithBl:

; 2434 : 					CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN10@DealWithBl:

; 2435 : 				}
; 2436 : 				break;

	jmp	SHORT $LN25@DealWithBl
$LN5@DealWithBl:

; 2437 : 
; 2438 : 			case RunwayPt:
; 2439 : 			case TakeoffPt:		
; 2440 : 				//take runway if we have permission, else holdshort
; 2441 : 				if(isWing || IsSetATC(PermitRunway))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@DealWithBl
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN4@DealWithBl
$LN3@DealWithBl:

; 2442 : 				{
; 2443 : 					while(CheckTaxiTrackPoint() == inTheWay)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	cmp	eax, DWORD PTR _inTheWay$[ebp]
	jne	SHORT $LN1@DealWithBl

; 2444 : 						OffsetTrackPoint(20.0F, downRunway);

	push	6
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
	jmp	SHORT $LN3@DealWithBl
$LN1@DealWithBl:

; 2445 : 					CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN4@DealWithBl:
$LN25@DealWithBl:
$LN48@DealWithBl:

; 2446 : 				}
; 2447 : 				break;
; 2448 : 		}
; 2449 : 	} 
; 2450 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z ENDP ; DigitalBrain::DealWithBlocker
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_tx$1 = -128						; size = 4
_ty$2 = -124						; size = 4
_tx$3 = -120						; size = 4
_ty$4 = -116						; size = 4
_tx$5 = -112						; size = 4
_ty$6 = -108						; size = 4
_tx$7 = -104						; size = 4
_ty$8 = -100						; size = 4
_tx$9 = -96						; size = 4
_ty$10 = -92						; size = 4
_tx$11 = -88						; size = 4
_ty$12 = -84						; size = 4
_tx$13 = -80						; size = 4
_ty$14 = -76						; size = 4
_tx$15 = -72						; size = 4
_ty$16 = -68						; size = 4
_tx$17 = -64						; size = 4
_ty$18 = -60						; size = 4
tv1128 = -56						; size = 4
_tx$19 = -52						; size = 4
_ty$20 = -48						; size = 4
tv1030 = -44						; size = 4
_tempX$21 = -40						; size = 4
_tempY$22 = -36						; size = 4
_HP_Is_Leader$ = -32					; size = 4
tv269 = -28						; size = 4
_minPoint$ = -24					; size = 4
_pt$ = -20						; size = 4
_flight_leader$ = -16					; size = 4
_leader$ = -12						; size = 4
_this$ = -8						; size = 4
_HP_Moving$ = -1					; size = 1
_Airbase$ = 8						; size = 4
?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z PROC ; DigitalBrain::ChooseNextPoint
; _this$ = ecx

; 2453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 2454 : 	int pt = 0;

	mov	DWORD PTR _pt$[ebp], 0

; 2455 : 	BOOL HP_Is_Leader = FALSE;

	mov	DWORD PTR _HP_Is_Leader$[ebp], 0

; 2456 : 	bool HP_Moving = false; // Cobra

	mov	BYTE PTR _HP_Moving$[ebp], 0

; 2457 : 	desiredSpeed = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+336], xmm0

; 2458 : 	AircraftClass *leader = NULL;

	mov	DWORD PTR _leader$[ebp], 0

; 2459 : 	int minPoint = GetFirstPt(rwIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _minPoint$[ebp], eax

; 2460 : 	//RAS - 15Oct04 - used to determine if human lead has Combat AP on
; 2461 : 	AircraftClass	*flight_leader = NULL; 

	mov	DWORD PTR _flight_leader$[ebp], 0

; 2462 : 
; 2463 : 	//RAS - add AircraftClass for testing for Combat Autopilot
; 2464 : 	flight_leader = (AircraftClass*)self->GetCampaignObject()->GetComponentNumber(0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _flight_leader$[ebp], eax

; 2465 : 
; 2466 : 	// Cobra - Is the Human Pilot (HP) on the move?
; 2467 : 	if (flight_leader && flight_leader->GetVt() > 10.0f * KNOTS_TO_FTPSEC){

	cmp	DWORD PTR _flight_leader$[ebp], 0
	je	SHORT $LN74@ChooseNext
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv1030[ebp]
	movss	xmm0, DWORD PTR tv1030[ebp]
	comiss	xmm0, DWORD PTR __real@418706e2
	jbe	SHORT $LN74@ChooseNext

; 2468 : 		HP_Moving = true;

	mov	BYTE PTR _HP_Moving$[ebp], 1
$LN74@ChooseNext:

; 2469 : 	}
; 2470 : 
; 2471 : 	// Cobra - If Human Pilot in control, then clear his parking spot and tell the AI to taxi to the runway
; 2472 : 	if (flight_leader && flight_leader->IsPlayer() &&  flight_leader->AutopilotType()!=AircraftClass::CombatAP)

	cmp	DWORD PTR _flight_leader$[ebp], 0
	je	SHORT $LN72@ChooseNext
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN72@ChooseNext
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN72@ChooseNext

; 2473 : 	{
; 2474 : 		HP_Is_Leader = TRUE;

	mov	DWORD PTR _HP_Is_Leader$[ebp], 1

; 2475 : 		if (HP_Moving){

	movzx	ecx, BYTE PTR _HP_Moving$[ebp]
	test	ecx, ecx
	je	SHORT $LN72@ChooseNext

; 2476 : 			// Cobra - Make HP's parking spot available
; 2477 : 			PtDataTable[flight_leader->spawnpoint].flags &= ~PT_OCCUPIED;

	mov	edx, DWORD PTR _flight_leader$[ebp]
	mov	eax, DWORD PTR [edx+1792]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _flight_leader$[ebp]
	mov	ecx, DWORD PTR [eax+1792]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [eax+ecx+9], dl

; 2478 : 			((AircraftClass*)flight_leader)->DBrain()->SetTaxiPoint(GetFirstPt(rwIndex));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN72@ChooseNext:

; 2479 : 		}
; 2480 : 	}
; 2481 : 
; 2482 : 	//RAS - if human(i.e. CombatAP not on) then skip this and taxi
; 2483 : 	if (
; 2484 : 		flight_leader && 
; 2485 : 		(
; 2486 : 			(flight_leader->IsPlayer() && 
; 2487 : 			(flight_leader->AutopilotType()==AircraftClass::CombatAP)) ||
; 2488 : 			!flight_leader->IsPlayer()
; 2489 : 		)
; 2490 : 	){

	cmp	DWORD PTR _flight_leader$[ebp], 0
	je	SHORT $LN68@ChooseNext
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN69@ChooseNext
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN70@ChooseNext
$LN69@ChooseNext:
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN68@ChooseNext
$LN70@ChooseNext:

; 2491 : 		if( SimLibElapsedTime < waittimer && !IsSetATC(PermitRunway) && !IsSetATC(PermitTakeRunway)){ 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	ecx, DWORD PTR [eax+344]
	jae	SHORT $LN68@ChooseNext
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN68@ChooseNext
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN68@ChooseNext

; 2492 : 			return;

	jmp	$LN75@ChooseNext
$LN68@ChooseNext:

; 2493 : 		}
; 2494 : 	}
; 2495 : 
; 2496 : 	if (isWing){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$LN61@ChooseNext

; 2497 : 		leader = (AircraftClass*)self->GetCampaignObject()->GetComponentNumber(self->vehicleInUnit - 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _leader$[ebp], eax

; 2498 : 		if (HP_Is_Leader && HP_Moving && leader && (leader == flight_leader || leader->IsPlayer())){

	cmp	DWORD PTR _HP_Is_Leader$[ebp], 0
	je	SHORT $LN66@ChooseNext
	movzx	ecx, BYTE PTR _HP_Moving$[ebp]
	test	ecx, ecx
	je	SHORT $LN66@ChooseNext
	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN66@ChooseNext
	mov	edx, DWORD PTR _leader$[ebp]
	cmp	edx, DWORD PTR _flight_leader$[ebp]
	je	SHORT $LN65@ChooseNext
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN66@ChooseNext
$LN65@ChooseNext:

; 2499 : 			// Cobra
; 2500 : 			minPoint =GetFirstPt(rwIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _minPoint$[ebp], eax

; 2501 : 		}
; 2502 : 		else if (

	jmp	SHORT $LN61@ChooseNext
$LN66@ChooseNext:

; 2503 : 			leader && 
; 2504 : 			leader->IsPlayer() && 
; 2505 : 			HP_Moving && leader->AutopilotType()!=AircraftClass::CombatAP
; 2506 : 		){

	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN63@ChooseNext
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN63@ChooseNext
	movzx	edx, BYTE PTR _HP_Moving$[ebp]
	test	edx, edx
	je	SHORT $LN63@ChooseNext
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN63@ChooseNext

; 2507 : 			// Cobra
; 2508 : 			minPoint =GetFirstPt(rwIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _minPoint$[ebp], eax
	jmp	SHORT $LN61@ChooseNext
$LN63@ChooseNext:

; 2509 : 		}
; 2510 : 		else if (leader && leader->OnGround() && leader->DBrain()->ATCStatus() != tTaxiBack){

	cmp	DWORD PTR _leader$[ebp], 0
	je	SHORT $LN61@ChooseNext
	mov	edx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN61@ChooseNext
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
	cmp	eax, 29					; 0000001dH
	je	SHORT $LN61@ChooseNext

; 2511 : 			minPoint = leader->DBrain()->GetTaxiPoint();

	mov	ecx, DWORD PTR _leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?GetTaxiPoint@DigitalBrain@@QAEHXZ	; DigitalBrain::GetTaxiPoint
	mov	DWORD PTR _minPoint$[ebp], eax
$LN61@ChooseNext:

; 2512 : 		}
; 2513 : 
; 2514 : /*
; 2515 : 		if (flightLead && flightLead->IsPlayer() && flightlead->AutopilotType()!=AircraftClass::CombatAP) // Cobra
; 2516 : 			minPoint =0;
; 2517 : 		else
; 2518 : 		if(flightLead && flightLead->OnGround() && 
; 2519 : 			((AircraftClass*)flightLead)->DBrain()->GetTaxiPoint() > minPoint && 
; 2520 : 			((AircraftClass*)flightLead)->DBrain()->ATCStatus() != tTaxiBack	)
; 2521 : 				minPoint = ((AircraftClass*)flightLead)->DBrain()->GetTaxiPoint();
; 2522 : */
; 2523 : 	}
; 2524 : 
; 2525 : //	else if( SimLibElapsedTime < waittimer && !IsSetATC(PermitRunway) && !IsSetATC(PermitTakeRunway))
; 2526 : //		return;
; 2527 : 
; 2528 : 
; 2529 : 	switch (PtDataTable[GetPrevPtLoop(curTaxiPoint)].type){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+eax+8]
	mov	DWORD PTR tv269[ebp], eax
	mov	ecx, DWORD PTR tv269[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv269[ebp], ecx
	cmp	DWORD PTR tv269[ebp], 14		; 0000000eH
	ja	$LN53@ChooseNext
	mov	edx, DWORD PTR tv269[ebp]
	movzx	eax, BYTE PTR $LN77@ChooseNext[edx]
	jmp	DWORD PTR $LN78@ChooseNext[eax*4]
$LN58@ChooseNext:

; 2530 : 		case LargeParkPt:
; 2531 : 		case SmallParkPt: // skip these on taxi
; 2532 : 			if (isWing && GetPrevPtLoop(curTaxiPoint) <= minPoint){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN57@ChooseNext
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	cmp	eax, DWORD PTR _minPoint$[ebp]
	jg	SHORT $LN57@ChooseNext

; 2533 : 				return;

	jmp	$LN75@ChooseNext

; 2534 : 			}
; 2535 : 			else {

	jmp	$LN56@ChooseNext
$LN57@ChooseNext:

; 2536 : 				//just taxi along
; 2537 : 				pt = GetPrevTaxiPt(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 2538 : 				if ((pt == 0) || (isWing && pt <= minPoint)){

	cmp	DWORD PTR _pt$[ebp], 0
	je	SHORT $LN54@ChooseNext
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN55@ChooseNext
	mov	ecx, DWORD PTR _pt$[ebp]
	cmp	ecx, DWORD PTR _minPoint$[ebp]
	jg	SHORT $LN55@ChooseNext
$LN54@ChooseNext:

; 2539 : 					return;

	jmp	$LN75@ChooseNext
$LN55@ChooseNext:

; 2540 : 				}
; 2541 : 				SetTaxiPoint(pt);

	mov	edx, DWORD PTR _pt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2542 : 				float tx, ty;
; 2543 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$20[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2544 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$20[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$19[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2545 : 				CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2546 : 				waittimer = CalcWaitTime(Airbase->brain);

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
$LN56@ChooseNext:

; 2547 : 			}
; 2548 : 			break;	

	jmp	$LN59@ChooseNext
$LN53@ChooseNext:

; 2549 : 		default:
; 2550 : 		case CritTaxiPt:
; 2551 : 		case TaxiPt:
; 2552 : 			if (isWing && GetPrevTaxiPt(curTaxiPoint) <= minPoint){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN52@ChooseNext
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	cmp	eax, DWORD PTR _minPoint$[ebp]
	jg	SHORT $LN52@ChooseNext

; 2553 : 				// 17JAN04 - FRB - Get taxi pt
; 2554 : 				return;

	jmp	$LN75@ChooseNext
$LN52@ChooseNext:

; 2555 : 			}
; 2556 : 
; 2557 : 			// RAS-11Nov04-check to see if we are in parking and if our leader is in parking or in next
; 2558 : 			// spot after parking, if so, don't move.
; 2559 : 			// This allows aircraft to file out of parking versus all move at once.
; 2560 : 			// sfr: added leader check and concatenated 2 checks in one if
; 2561 : 			if (isWing && leader && (	
; 2562 : 					PtDataTable[curTaxiPoint].type == SmallParkPt || 
; 2563 : 					PtDataTable[curTaxiPoint].type == LargeParkPt
; 2564 : 				) && (
; 2565 : 					(
; 2566 : 						PtDataTable[leader->DBrain()->curTaxiPoint].type == SmallParkPt || 
; 2567 : 						PtDataTable[leader->DBrain()->curTaxiPoint].type == LargeParkPt
; 2568 : 					) || (
; 2569 : 						leader->DBrain()->curTaxiPoint >= (leader->spawnpoint)-1 && 
; 2570 : 						leader->GetVt() < 0.1f * KNOTS_TO_FTPSEC
; 2571 : 					)
; 2572 : 				)
; 2573 : 			){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$LN51@ChooseNext
	cmp	DWORD PTR _leader$[ebp], 0
	je	$LN51@ChooseNext
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN50@ChooseNext
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 12					; 0000000cH
	jne	$LN51@ChooseNext
$LN50@ChooseNext:
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	edx, DWORD PTR [eax+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 11					; 0000000bH
	je	SHORT $LN49@ChooseNext
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	edx, DWORD PTR [eax+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN49@ChooseNext
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	edx, DWORD PTR _leader$[ebp]
	mov	ecx, DWORD PTR [edx+1792]
	sub	ecx, 1
	cmp	DWORD PTR [eax+332], ecx
	jl	SHORT $LN51@ChooseNext
	mov	edx, DWORD PTR _leader$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _leader$[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv1128[ebp]
	movss	xmm0, DWORD PTR __real@3e2cd59c
	comiss	xmm0, DWORD PTR tv1128[ebp]
	jbe	SHORT $LN51@ChooseNext
$LN49@ChooseNext:

; 2574 : 				return;

	jmp	$LN75@ChooseNext
$LN51@ChooseNext:

; 2575 : 			}
; 2576 : 
; 2577 : 			// Cobra - Close the canopy
; 2578 : 			if (af->canopyState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movzx	edx, BYTE PTR [ecx+1588]
	test	edx, edx
	je	SHORT $LN48@ChooseNext

; 2579 : 				af->canopyState = false; // OK

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	BYTE PTR [ecx+1588], 0
$LN48@ChooseNext:

; 2580 : 
; 2581 : 			// Cobra - Clear parking spot occupied flag
; 2582 : 			PtDataTable[self->spawnpoint].flags &= ~PT_OCCUPIED; // Cobra - Make HP's parking spot available

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+1792]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+1792]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [edx+ecx+9], al

; 2583 : 
; 2584 : 			//just taxi along
; 2585 : 			pt = GetPrevTaxiPt(curTaxiPoint);    // 17JAN04 - FRB - Get taxi pt (prev pt may be parking pt)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 2586 : 			if (!pt){

	cmp	DWORD PTR _pt$[ebp], 0
	jne	SHORT $LN47@ChooseNext

; 2587 : 				// no more TaxiPt's, must be at entrance to runway
; 2588 : 				SetTaxiPoint(GetPrevPtLoop(curTaxiPoint));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2589 : 			}
; 2590 : 			else {

	jmp	SHORT $LN46@ChooseNext
$LN47@ChooseNext:

; 2591 : 				SetTaxiPoint(pt);

	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN46@ChooseNext:

; 2592 : 			}
; 2593 : 
; 2594 : 			float tx, ty;
; 2595 : 			TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$18[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2596 : 			SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$18[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$17[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2597 : 			CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2598 : 			if(isWing){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN45@ChooseNext

; 2599 : 				// FRB - let the leader get out first
; 2600 : 				waittimer = CalcWaitTime(Airbase->brain);

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 2601 : 			}
; 2602 : 			else{

	jmp	SHORT $LN44@ChooseNext
$LN45@ChooseNext:

; 2603 : 				waittimer = 0;	// FRB - try no wait time

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0
$LN44@ChooseNext:

; 2604 : 			}
; 2605 : 		break;

	jmp	$LN59@ChooseNext
$LN43@ChooseNext:

; 2606 : 		case TakeRunwayPt:
; 2607 : 			//take runway if we have permission, else holdshort
; 2608 : 			if(isWing){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN42@ChooseNext

; 2609 : 				if(GetPrevPtLoop(curTaxiPoint) == minPoint && !IsSetATC(PermitRunway)){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	cmp	eax, DWORD PTR _minPoint$[ebp]
	jne	SHORT $LN41@ChooseNext
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN41@ChooseNext

; 2610 : 					return;

	jmp	$LN75@ChooseNext
$LN41@ChooseNext:

; 2611 : 				}
; 2612 : 				if(GetPrevPtLoop(curTaxiPoint) < minPoint){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	cmp	eax, DWORD PTR _minPoint$[ebp]
	jge	SHORT $LN40@ChooseNext

; 2613 : 					return;

	jmp	$LN75@ChooseNext
$LN40@ChooseNext:

; 2614 : 				}
; 2615 : 				if(WingmanTakeRunway(Airbase, (AircraftClass*)flightLead, leader)){

	mov	edx, DWORD PTR _leader$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z ; DigitalBrain::WingmanTakeRunway
	test	eax, eax
	je	$LN39@ChooseNext

; 2616 : 					SetTaxiPoint(GetPrevPtLoop(curTaxiPoint));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2617 : 					float tx, ty;
; 2618 : 					TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$16[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2619 : 					SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$16[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$15[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2620 : 					CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2621 : 	//				waittimer = CalcWaitTime(Airbase->brain);
; 2622 : 					waittimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0

; 2623 : 
; 2624 : 					//RAS - 17Oct04
; 2625 : 					if(atcstatus != tTakeRunway){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 26			; 0000001aH
	je	SHORT $LN38@ChooseNext

; 2626 : 						atcstatus = tTakeRunway;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 26			; 0000001aH

; 2627 : 						SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN38@ChooseNext:

; 2628 : 					}
; 2629 : 					//end RAS
; 2630 : 				}

	jmp	$LN34@ChooseNext
$LN39@ChooseNext:

; 2631 : 				else if(!Airbase->brain->IsOnRunway(GetPrevPtLoop(GetPrevPtLoop(curTaxiPoint)))){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHH@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	jne	$LN36@ChooseNext

; 2632 : 					SetTaxiPoint(GetPrevPtLoop(GetPrevPtLoop(curTaxiPoint)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2633 : 					float tx, ty;
; 2634 : 					TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$14[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2635 : 					SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$14[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2636 : 					CalculateTaxiSpeed(HurryUp);		 // FRB - he is already at least 2 taxipts behind

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2637 : 	//				waittimer = CalcWaitTime(Airbase->brain);	 // <<-- not long
; 2638 : 					waittimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0
	jmp	SHORT $LN34@ChooseNext
$LN36@ChooseNext:

; 2639 : 				}
; 2640 : 				else if(self->af->IsSet(AirframeClass::OverRunway)){

	push	8388608					; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN34@ChooseNext

; 2641 : 					OffsetTrackPoint(50.0F, rightRunway);	 

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2642 : 					CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN34@ChooseNext:

; 2643 : 				}
; 2644 : 			}

	jmp	$LN20@ChooseNext
$LN42@ChooseNext:

; 2645 : 			else if( IsSetATC(PermitRunway) && !self->IsSetFalcFlag(FEC_HOLDSHORT) ){					

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN32@ChooseNext
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	$LN32@ChooseNext

; 2646 : 				float tx, ty;
; 2647 : 				atcstatus = tTakeRunway;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 26			; 0000001aH

; 2648 : 				SetTaxiPoint(GetPrevPtLoop(curTaxiPoint));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2649 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$12[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2650 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$11[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2651 : 				CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2652 : 				waittimer = CalcWaitTime(Airbase->brain);	 

	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
	jmp	$LN20@ChooseNext
$LN32@ChooseNext:

; 2653 : 	//			waittimer = 0;
; 2654 : 			}
; 2655 : 			else if( IsSetATC(PermitTakeRunway) && !self->IsSetFalcFlag(FEC_HOLDSHORT) ){

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN30@ChooseNext
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	$LN30@ChooseNext

; 2656 : 				pt = GetPrevPtLoop(curTaxiPoint);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 2657 : 				float tempX, tempY;
; 2658 : 				TranslatePointData(Airbase, pt, &tempX, &tempY);

	lea	edx, DWORD PTR _tempY$22[ebp]
	push	edx
	lea	eax, DWORD PTR _tempX$21[ebp]
	push	eax
	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2659 : 				if(!Airbase->brain->IsOnRunway(tempX, tempY)){

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tempY$22[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempX$21[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	jne	SHORT $LN29@ChooseNext

; 2660 : 					SetTaxiPoint(pt);

	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2661 : 					SetTrackPoint(tempX, tempY);

	push	ecx
	movss	xmm0, DWORD PTR _tempY$22[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempX$21[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2662 : 					//CalculateTaxiSpeed(MoveAlong);
; 2663 : 					CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2664 : 					//waittimer = CalcWaitTime(Airbase->brain);	 // <<-- not long
; 2665 : 					waittimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0
$LN29@ChooseNext:

; 2666 : 				}
; 2667 : 			}

	jmp	$LN20@ChooseNext
$LN30@ChooseNext:

; 2668 : 			else if(PtDataTable[curTaxiPoint].type == TakeRunwayPt && !self->IsSetFalcFlag(FEC_HOLDSHORT) ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 15					; 0000000fH
	jne	$LN27@ChooseNext
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	$LN27@ChooseNext

; 2669 : 				SetATCFlag(PermitTakeRunway);					

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 2670 : 				SetTaxiPoint(GetPrevPtLoop(curTaxiPoint));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2671 : 				float tx, ty;
; 2672 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	ecx, DWORD PTR _ty$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$9[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2673 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$10[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$9[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2674 : 				//CalculateTaxiSpeed(MoveAlong);	
; 2675 : 				CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2676 : 				if(atcstatus != tTakeRunway){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 26			; 0000001aH
	je	SHORT $LN26@ChooseNext

; 2677 : 					SendATCMsg(tPrepToTakeRunway);

	push	25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 2678 : 					atcstatus = tTaxi;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 22			; 00000016H
$LN26@ChooseNext:

; 2679 : 				}
; 2680 : 				//waittimer = CalcWaitTime(Airbase->brain);
; 2681 : 				waittimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0
	jmp	$LN20@ChooseNext
$LN27@ChooseNext:

; 2682 : 			}
; 2683 : 			else if(!Airbase->brain->IsOnRunway(GetPrevPtLoop(GetPrevPtLoop(curTaxiPoint)))){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHH@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	jne	$LN24@ChooseNext

; 2684 : 				SetTaxiPoint(GetPrevPtLoop(GetPrevPtLoop(curTaxiPoint)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2685 : 				float tx, ty;
; 2686 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$8[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2687 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$8[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$7[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2688 : 				CalculateTaxiSpeed(HurryUp);																 

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2689 : 				//waittimer = CalcWaitTime(Airbase->brain);	 // <<-- not long
; 2690 : 				waittimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0
	jmp	$LN20@ChooseNext
$LN24@ChooseNext:

; 2691 : 			}
; 2692 : 			else if(self->af->IsSet(AirframeClass::OverRunway)){

	push	8388608					; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN22@ChooseNext

; 2693 : 				OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2694 : 				CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2695 : 				//CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff
; 2696 : 			}
; 2697 : 			else {

	jmp	SHORT $LN20@ChooseNext
$LN22@ChooseNext:

; 2698 : 				if(atcstatus != tTakeRunway && !self->IsSetFalcFlag(FEC_HOLDSHORT)){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 26			; 0000001aH
	je	SHORT $LN20@ChooseNext
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	SHORT $LN20@ChooseNext

; 2699 : 					atcstatus = tHoldShort;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 24			; 00000018H

; 2700 : 					SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN20@ChooseNext:

; 2701 : 				}
; 2702 : 			}
; 2703 : 		break;

	jmp	$LN59@ChooseNext
$LN19@ChooseNext:

; 2704 : 		case TakeoffPt:
; 2705 : 			//take runway if we have permission, else holdshort
; 2706 : 			if(isWing){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN18@ChooseNext

; 2707 : 				if(WingmanTakeRunway(Airbase, (AircraftClass*)flightLead, leader)){

	mov	ecx, DWORD PTR _leader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z ; DigitalBrain::WingmanTakeRunway
	test	eax, eax
	je	$LN17@ChooseNext

; 2708 : 					float tx, ty;
; 2709 : 					SetTaxiPoint(
; 2710 : 						Airbase->brain->FindTakeoffPt(
; 2711 : 							(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 2712 : 						)
; 2713 : 					);

	lea	edx, DWORD PTR _ty$6[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2714 : 					SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$6[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2715 : 					//CalculateTaxiSpeed(MoveAlong);
; 2716 : 					CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2717 : 					if(atcstatus != tTakeRunway){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 26			; 0000001aH
	je	SHORT $LN16@ChooseNext

; 2718 : 						atcstatus = tTakeRunway;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 26			; 0000001aH

; 2719 : 						SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN16@ChooseNext:

; 2720 : 					}
; 2721 : 					//waittimer = CalcWaitTime(Airbase->brain);		 // FRB - do we have to wait?
; 2722 : 					waittimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0
	jmp	SHORT $LN14@ChooseNext
$LN17@ChooseNext:

; 2723 : 				}
; 2724 : 				else if(self->af->IsSet(AirframeClass::OverRunway)){

	push	8388608					; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN14@ChooseNext

; 2725 : 					OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2726 : 					//CalculateTaxiSpeed(MoveAlong);
; 2727 : 					CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN14@ChooseNext:

; 2728 : 				}
; 2729 : 			}

	jmp	$LN7@ChooseNext
$LN18@ChooseNext:

; 2730 : 			else if(IsSetATC(PermitRunway) && !self->IsSetFalcFlag(FEC_HOLDSHORT)){

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN12@ChooseNext
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	$LN12@ChooseNext

; 2731 : 				SetATCFlag(PermitRunway);					

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 2732 : 				float tx, ty;
; 2733 : 				SetTaxiPoint(
; 2734 : 					Airbase->brain->FindTakeoffPt(
; 2735 : 						(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 2736 : 					)
; 2737 : 				);

	lea	ecx, DWORD PTR _ty$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, BYTE PTR [eax+664]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2738 : 				SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$3[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2739 : 				CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2740 : 				//CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff
; 2741 : 				if(atcstatus != tTakeRunway){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 26			; 0000001aH
	je	SHORT $LN11@ChooseNext

; 2742 : 					atcstatus = tTakeRunway;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 26			; 0000001aH

; 2743 : 					SendATCMsg(atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN11@ChooseNext:

; 2744 : 				}
; 2745 : 				waittimer = CalcWaitTime(Airbase->brain);		 // FRB - do we have to wait?

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
	jmp	$LN7@ChooseNext
$LN12@ChooseNext:

; 2746 : 				//waittimer = 0;
; 2747 : 			}
; 2748 : 			else if(self->af->IsSet(AirframeClass::OverRunway)){

	push	8388608					; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN9@ChooseNext

; 2749 : 				OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2750 : 				CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2751 : 				//CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff
; 2752 : 				waittimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0

; 2753 : 			}
; 2754 : 			else if (

	jmp	SHORT $LN7@ChooseNext
$LN9@ChooseNext:

; 2755 : 				PtDataTable[curTaxiPoint].type != TakeRunwayPt && 
; 2756 : 				!IsSetATC(PermitTakeRunway) && 
; 2757 : 				!self->IsSetFalcFlag(FEC_HOLDSHORT)
; 2758 : 			){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 15					; 0000000fH
	je	SHORT $LN7@ChooseNext
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN7@ChooseNext
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	test	eax, eax
	jne	SHORT $LN7@ChooseNext

; 2759 : 				atcstatus = tHoldShort;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 24			; 00000018H

; 2760 : 				SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN7@ChooseNext:

; 2761 : 			}
; 2762 : 		break;

	jmp	$LN59@ChooseNext
$LN6@ChooseNext:

; 2763 : 		case RunwayPt:
; 2764 : 		{
; 2765 : 			if (
; 2766 : 				isWing && 
; 2767 : 				!WingmanTakeRunway(Airbase, (AircraftClass*)flightLead, leader) && 
; 2768 : 				self->af->IsSet(AirframeClass::OverRunway)
; 2769 : 			){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN5@ChooseNext
	mov	edx, DWORD PTR _leader$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@PAVAircraftClass@@1@Z ; DigitalBrain::WingmanTakeRunway
	test	eax, eax
	jne	SHORT $LN5@ChooseNext
	push	8388608					; 00800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN5@ChooseNext

; 2770 : 				OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2771 : 				//CalculateTaxiSpeed(MoveAlong);
; 2772 : 				CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2773 : 				waittimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0

; 2774 : 				break;

	jmp	$LN59@ChooseNext
	jmp	SHORT $LN3@ChooseNext
$LN5@ChooseNext:

; 2775 : 			}
; 2776 : 			else if(!isWing && !IsSetATC(PermitRunway)){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@ChooseNext
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN3@ChooseNext

; 2777 : 				if(self->af->IsSet(AirframeClass::OverRunway)){

	push	8388608					; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN2@ChooseNext

; 2778 : 					OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2779 : 					CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2780 : 					//CalculateTaxiSpeed(HurryUp);    // 17JAN04 - FRB - expedite takeoff
; 2781 : 					waittimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0
$LN2@ChooseNext:

; 2782 : 				}
; 2783 : 				break;

	jmp	$LN59@ChooseNext
$LN3@ChooseNext:

; 2784 : 			}
; 2785 : 			//takeoff and get out of the way
; 2786 : 			SetATCFlag(PermitRunway);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 2787 : 			if(atcstatus != tTakeRunway && atcstatus != tTakeoff){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 26			; 0000001aH
	je	SHORT $LN1@ChooseNext
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 27			; 0000001bH
	je	SHORT $LN1@ChooseNext

; 2788 : 				atcstatus = tTakeRunway;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 26			; 0000001aH
$LN1@ChooseNext:

; 2789 : 			}
; 2790 : 			float tx, ty;
; 2791 : 			SetTaxiPoint(
; 2792 : 				Airbase->brain->FindRunwayPt(
; 2793 : 					(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 2794 : 				)
; 2795 : 			);

	lea	ecx, DWORD PTR _ty$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, BYTE PTR [eax+664]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindRunwayPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2796 : 			SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2797 : 			desiredSpeed = 30.0F * KNOTS_TO_FTPSEC;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@424a8a53
	movss	DWORD PTR [ecx+336], xmm0

; 2798 : 			//waittimer = CalcWaitTime(Airbase->brain);			 // FRB - do we have to wait?
; 2799 : 			waittimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0
$LN59@ChooseNext:
$LN75@ChooseNext:

; 2800 : 		}
; 2801 : 		break;
; 2802 : 	}
; 2803 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN78@ChooseNext:
	DD	$LN6@ChooseNext
	DD	$LN19@ChooseNext
	DD	$LN58@ChooseNext
	DD	$LN43@ChooseNext
	DD	$LN53@ChooseNext
$LN77@ChooseNext:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	4
	DB	3
?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ENDP ; DigitalBrain::ChooseNextPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTrackPoint@DigitalBrain@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetTrackPoint@DigitalBrain@@QAEXMMM@Z PROC		; DigitalBrain::SetTrackPoint, COMDAT
; _this$ = ecx

; 699  : 	void	SetTrackPoint(float x, float y, float z){ SetTrackPoint(x, y); trackZ = z; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+156], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTrackPoint@DigitalBrain@@QAEXMMM@Z ENDP		; DigitalBrain::SetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTrackPoint@DigitalBrain@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetTrackPoint@DigitalBrain@@QAEXMM@Z PROC		; DigitalBrain::SetTrackPoint, COMDAT
; _this$ = ecx

; 698  : 	void	SetTrackPoint(float x, float y){ trackX = x; trackY=y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+148], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+152], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTrackPoint@DigitalBrain@@QAEXMM@Z ENDP		; DigitalBrain::SetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_prevPt$ = -20						; size = 4
_parkPt$ = -16						; size = 4
_this$ = -12						; size = 4
_time_til_takeoff$ = -8					; size = 4
_tp$ = -4						; size = 4
_takeoffTime$ = 8					; size = 4
?FindDesiredTaxiPoint@DigitalBrain@@QAEHK@Z PROC	; DigitalBrain::FindDesiredTaxiPoint
; _this$ = ecx

; 3078 : int DigitalBrain::FindDesiredTaxiPoint(ulong takeoffTime){

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3079 : 	// sfr: check for no runway
; 3080 : 	if (rwIndex == 0){ return -1; }

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+304], 0
	jne	SHORT $LN17@FindDesire
	or	eax, -1
	jmp	$LN18@FindDesire
$LN17@FindDesire:

; 3081 : 
; 3082 : 	// in TAKEOFF_TIME_DELTA (10) seconds blocks
; 3083 : 	int	time_til_takeoff=0, tp, prevPt, parkPt;

	mov	DWORD PTR _time_til_takeoff$[ebp], 0

; 3084 : 	if(takeoffTime > SimLibElapsedTime){

	mov	ecx, DWORD PTR _takeoffTime$[ebp]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jbe	SHORT $LN16@FindDesire

; 3085 : 		time_til_takeoff = (takeoffTime - Camp_GetCurrentTime()) / (TAKEOFF_TIME_DELTA);

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	edx, DWORD PTR _takeoffTime$[ebp]
	sub	edx, eax
	mov	eax, edx
	xor	edx, edx
	mov	ecx, 10000				; 00002710H
	div	ecx
	mov	DWORD PTR _time_til_takeoff$[ebp], eax
$LN16@FindDesire:

; 3086 : 	}
; 3087 : 	if (time_til_takeoff < 0){

	cmp	DWORD PTR _time_til_takeoff$[ebp], 0
	jge	SHORT $LN15@FindDesire

; 3088 : 		time_til_takeoff = 0;

	mov	DWORD PTR _time_til_takeoff$[ebp], 0
$LN15@FindDesire:

; 3089 : 	}
; 3090 : 
; 3091 : 	tp = GetFirstPt(rwIndex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax

; 3092 : 
; 3093 : 	// Cobra - Hack to get the fighter a/c leaders on the front row of parking area
; 3094 : 	if ((af->GetParkType() == SmallParkPt) && (tp = GetNextParkTypePt(tp, af->GetParkType()))){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN14@FindDesire
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	push	eax
	mov	eax, DWORD PTR _tp$[ebp]
	push	eax
	call	?GetNextParkTypePt@@YAHHH@Z		; GetNextParkTypePt
	add	esp, 8
	mov	DWORD PTR _tp$[ebp], eax
	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN14@FindDesire

; 3095 : 		PtDataTable[tp].flags |= PT_OCCUPIED;	// 02JAN04 - FRB - Block use of first parking spot

	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	or	eax, 4
	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [edx+ecx+9], al
$LN14@FindDesire:

; 3096 : 	}
; 3097 : 
; 3098 : 	tp = GetFirstPt(rwIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax

; 3099 : 	prevPt = tp+1;

	mov	edx, DWORD PTR _tp$[ebp]
	add	edx, 1
	mov	DWORD PTR _prevPt$[ebp], edx

; 3100 : 	parkPt = -1; // FRB

	mov	DWORD PTR _parkPt$[ebp], -1

; 3101 : 	tp = GetNextPt(tp);	

	mov	eax, DWORD PTR _tp$[ebp]
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax
$LN13@FindDesire:

; 3102 : 	//	while (tp && time_til_takeoff) // Cobra - Taxi Mode puts a/c in parking and taxiway spots
; 3103 : 	while (tp){

	cmp	DWORD PTR _tp$[ebp], 0
	je	$LN12@FindDesire

; 3104 : 		if(PtDataTable[tp].type == CritTaxiPt){

	mov	ecx, DWORD PTR _tp$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN11@FindDesire

; 3105 : 			break;

	jmp	$LN12@FindDesire
$LN11@FindDesire:

; 3106 : 		}
; 3107 : 
; 3108 : 		prevPt = tp;

	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR _prevPt$[ebp], ecx

; 3109 : 		tp = GetNextPt(tp);	// FRB - Look at all of them

	mov	edx, DWORD PTR _tp$[ebp]
	push	edx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _tp$[ebp], eax

; 3110 : 
; 3111 : 		// 17JAN04 - FRB - Locate a suitable parking spot
; 3112 : 		if ((PtDataTable[tp].type == SmallParkPt) || (PtDataTable[tp].type == LargeParkPt)){

	mov	eax, DWORD PTR _tp$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 11					; 0000000bH
	je	SHORT $LN9@FindDesire
	mov	eax, DWORD PTR _tp$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 12					; 0000000cH
	jne	SHORT $LN10@FindDesire
$LN9@FindDesire:

; 3113 : 			if (PtDataTable[tp].flags & PT_OCCUPIED){

	mov	eax, DWORD PTR _tp$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	and	edx, 4
	je	SHORT $LN8@FindDesire

; 3114 : 				time_til_takeoff--;

	mov	eax, DWORD PTR _time_til_takeoff$[ebp]
	sub	eax, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], eax

; 3115 : 				continue;  // Taken

	jmp	$LN13@FindDesire
	jmp	SHORT $LN10@FindDesire
$LN8@FindDesire:

; 3116 : 			}
; 3117 : 			else if (af->GetParkType() == PtDataTable[tp].type){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	mov	edx, DWORD PTR _tp$[ebp]
	imul	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+edx+8]
	cmp	eax, edx
	jne	SHORT $LN6@FindDesire

; 3118 : 				parkPt = tp; 

	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR _parkPt$[ebp], eax

; 3119 : 				time_til_takeoff--;

	mov	ecx, DWORD PTR _time_til_takeoff$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], ecx

; 3120 : 				break;

	jmp	SHORT $LN12@FindDesire

; 3121 : 			}
; 3122 : 			else {

	jmp	SHORT $LN10@FindDesire
$LN6@FindDesire:

; 3123 : 				time_til_takeoff--;

	mov	edx, DWORD PTR _time_til_takeoff$[ebp]
	sub	edx, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], edx

; 3124 : 				continue;  // Taken

	jmp	$LN13@FindDesire
$LN10@FindDesire:

; 3125 : 			}
; 3126 : 		}
; 3127 : 		time_til_takeoff--;

	mov	eax, DWORD PTR _time_til_takeoff$[ebp]
	sub	eax, 1
	mov	DWORD PTR _time_til_takeoff$[ebp], eax

; 3128 : 	}

	jmp	$LN13@FindDesire
$LN12@FindDesire:

; 3129 : 
; 3130 : 	// Cobra - Adjust taxi time
; 3131 : 	//	if (time_til_takeoff > (takeoffTime-Camp_GetCurrentTime())/(TAKEOFF_TIME_DELTA))
; 3132 : 	// 17JAN04 - FRB - Use nearest Parking spot
; 3133 : 	if (parkPt >= 0){

	cmp	DWORD PTR _parkPt$[ebp], 0
	jl	SHORT $LN4@FindDesire

; 3134 : 		tp = parkPt;

	mov	ecx, DWORD PTR _parkPt$[ebp]
	mov	DWORD PTR _tp$[ebp], ecx

; 3135 : 		PtDataTable[tp].flags |= PT_OCCUPIED;	// 02JAN04 - FRB - Reserve parking spot

	mov	edx, DWORD PTR _tp$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+9]
	or	ecx, 4
	mov	edx, DWORD PTR _tp$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [eax+edx+9], cl

; 3136 : 		SetTaxiPoint(self->spawnpoint = tp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [edx+1792], eax
	mov	ecx, DWORD PTR _tp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 3137 : 		return tp;

	mov	eax, DWORD PTR _tp$[ebp]
	jmp	SHORT $LN18@FindDesire
	jmp	SHORT $LN3@FindDesire
$LN4@FindDesire:

; 3138 : 	}
; 3139 : 	else if (tp){

	cmp	DWORD PTR _tp$[ebp], 0
	je	SHORT $LN2@FindDesire

; 3140 : 		SetTaxiPoint(self->spawnpoint = tp);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _tp$[ebp]
	mov	DWORD PTR [eax+1792], ecx
	mov	edx, DWORD PTR _tp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 3141 : 		return tp;

	mov	eax, DWORD PTR _tp$[ebp]
	jmp	SHORT $LN18@FindDesire

; 3142 : 	}
; 3143 : 	else{

	jmp	SHORT $LN3@FindDesire
$LN2@FindDesire:

; 3144 : 		self->spawnpoint = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [ecx+1792], -1
$LN3@FindDesire:

; 3145 : 	}
; 3146 : 	return -1;

	or	eax, -1
$LN18@FindDesire:

; 3147 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindDesiredTaxiPoint@DigitalBrain@@QAEHK@Z ENDP	; DigitalBrain::FindDesiredTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_takeoffTime$ = 8					; size = 4
_rwIndx$ = 12						; size = 4
?FindDesiredTaxiPoint@DigitalBrain@@QAEHKH@Z PROC	; DigitalBrain::FindDesiredTaxiPoint
; _this$ = ecx

; 3072 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3073 : 	rwIndex = rwIndx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rwIndx$[ebp]
	mov	DWORD PTR [eax+304], ecx

; 3074 : 	return FindDesiredTaxiPoint(takeoffTime);

	mov	edx, DWORD PTR _takeoffTime$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindDesiredTaxiPoint@DigitalBrain@@QAEHK@Z ; DigitalBrain::FindDesiredTaxiPoint

; 3075 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindDesiredTaxiPoint@DigitalBrain@@QAEHKH@Z ENDP	; DigitalBrain::FindDesiredTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_cit$ = -48						; size = 12
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
_this$ = -24						; size = 4
_prev$ = -20						; size = 4
_cur$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ PROC	; DigitalBrain::GetLeader
; _this$ = ecx

; 3792 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3793 : 	VuEntity		*cur;
; 3794 : 	VuEntity		*prev = NULL;

	mov	DWORD PTR _prev$[ebp], 0

; 3795 : 
; 3796 : 	VuListIterator	cit(self->GetCampaignObject()->GetComponents());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _cit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3797 : 	cur = cit.GetFirst();

	lea	ecx, DWORD PTR _cit$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _cur$[ebp], eax
$LN5@GetLeader:

; 3798 : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@GetLeader

; 3799 : 	{
; 3800 : 		if(cur == self)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR [ecx+56]
	jne	SHORT $LN3@GetLeader

; 3801 : 		{
; 3802 : 			if(prev)

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN2@GetLeader

; 3803 : 				return ((AircraftClass*)prev);

	mov	eax, DWORD PTR _prev$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN6@GetLeader

; 3804 : 			else 

	jmp	SHORT $LN3@GetLeader
$LN2@GetLeader:

; 3805 : 				return NULL;

	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN6@GetLeader
$LN3@GetLeader:

; 3806 : 		}
; 3807 : 		prev = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 3808 : 		
; 3809 : 		cur = cit.GetNext();

	lea	ecx, DWORD PTR _cit$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _cur$[ebp], eax

; 3810 : 	}

	jmp	SHORT $LN5@GetLeader
$LN4@GetLeader:

; 3811 : 	return NULL;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T2[ebp]
$LN6@GetLeader:

; 3812 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ$0:
	lea	ecx, DWORD PTR _cit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLeader@DigitalBrain@@QAEPAVAircraftClass@@XZ ENDP	; DigitalBrain::GetLeader
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_tx$1 = -52						; size = 4
_ty$2 = -48						; size = 4
_tmpY$ = -44						; size = 4
_tmpX$ = -40						; size = 4
_closestDist$ = -36					; size = 4
_dist$ = -32						; size = 4
_dy$ = -28						; size = 4
_dx$ = -24						; size = 4
_Airbase$ = -20						; size = 4
_i$ = -16						; size = 4
_taxiPoint$ = -12					; size = 4
_closest$ = -8						; size = 4
_this$ = -4						; size = 4
?UpdateTaxipoint@DigitalBrain@@QAEXXZ PROC		; DigitalBrain::UpdateTaxipoint
; _this$ = ecx

; 3724 : {																					 // Not used by Landme.cpp

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 3725 : 	
; 3726 : //	if((!self->OnGround()) || (atcstatus == tTakeRunway))	 // 07FEB04 - FRB - added atcstatus check
; 3727 : 	//RAS-12Nov04-If your a player then if we're on the ground, we need to update our taxi point
; 3728 : 	if((!self->OnGround()) || !self->IsPlayer() && (atcstatus == tTakeRunway))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN13@UpdateTaxi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN14@UpdateTaxi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 26			; 0000001aH
	jne	SHORT $LN14@UpdateTaxi
$LN13@UpdateTaxi:

; 3729 : 		return;

	jmp	$LN15@UpdateTaxi
$LN14@UpdateTaxi:

; 3730 : 
; 3731 : 	ObjectiveClass *Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+312]
	push	eax
	mov	ecx, DWORD PTR [edx+308]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 3732 : 	float tmpX, tmpY, dx, dy, dist, closestDist =  4000000.0F;

	movss	xmm0, DWORD PTR __real@4a742400
	movss	DWORD PTR _closestDist$[ebp], xmm0

; 3733 : 	int taxiPoint, i, closest = curTaxiPoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	mov	DWORD PTR _closest$[ebp], eax

; 3734 : 
; 3735 : //	SetDebugLabel(Airbase);
; 3736 : 
; 3737 : 	taxiPoint = GetPrevPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _taxiPoint$[ebp], eax

; 3738 : 	
; 3739 : 	// Cobra - Move 2 Pt's forward to make sure we are pass an adjacent parking pt.
; 3740 : //	taxiPoint = GetPrevPtLoop(taxiPoint);
; 3741 : //	for(i = 0; i < 5; i++)
; 3742 : 	for(i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@UpdateTaxi
$LN11@UpdateTaxi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@UpdateTaxi:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN10@UpdateTaxi

; 3743 : 	{
; 3744 : 		TranslatePointData(Airbase, taxiPoint, &tmpX, &tmpY);

	lea	ecx, DWORD PTR _tmpY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tmpX$[ebp]
	push	edx
	mov	eax, DWORD PTR _taxiPoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3745 : 		dx = tmpX - af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	subss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3746 : 		dy = tmpY - af->y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	subss	xmm0, DWORD PTR [edx+1112]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3747 : 		dist = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 3748 : 		if ( dist < closestDist )

	movss	xmm0, DWORD PTR _closestDist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN9@UpdateTaxi

; 3749 : 		{
; 3750 : 			closestDist = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _closestDist$[ebp], xmm0

; 3751 : 			closest = taxiPoint;

	mov	eax, DWORD PTR _taxiPoint$[ebp]
	mov	DWORD PTR _closest$[ebp], eax
$LN9@UpdateTaxi:

; 3752 : 		}
; 3753 : 		taxiPoint = GetNextPtLoop(taxiPoint);

	mov	ecx, DWORD PTR _taxiPoint$[ebp]
	push	ecx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _taxiPoint$[ebp], eax

; 3754 : 	}

	jmp	$LN11@UpdateTaxi
$LN10@UpdateTaxi:

; 3755 : 
; 3756 : 	if(closest != curTaxiPoint)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _closest$[ebp]
	cmp	eax, DWORD PTR [edx+332]
	je	$LN8@UpdateTaxi

; 3757 : 	{
; 3758 : 		// Cobra - Skip looking at parking pts.
; 3759 : //		if(closest == GetNextPtLoop(curTaxiPoint) && self->AutopilotType() == AircraftClass::APOff)
; 3760 : 		if(closest == GetNextTaxiPt(curTaxiPoint) && self->AutopilotType() == AircraftClass::APOff)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	cmp	DWORD PTR _closest$[ebp], eax
	jne	SHORT $LN7@UpdateTaxi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 4
	jne	SHORT $LN7@UpdateTaxi

; 3761 : 		{
; 3762 : 			if( IsSetATC(CheckTaxiBack) && atcstatus != tTaxiBack)

	push	33554432				; 02000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN6@UpdateTaxi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 29			; 0000001dH
	je	SHORT $LN6@UpdateTaxi

; 3763 : 			{
; 3764 : 				atcstatus = tTaxiBack;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 29			; 0000001dH

; 3765 : 				SendATCMsg(atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 3766 : 			}
; 3767 : 			else

	jmp	SHORT $LN5@UpdateTaxi
$LN6@UpdateTaxi:

; 3768 : 				SetATCFlag(CheckTaxiBack);

	push	33554432				; 02000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag
$LN5@UpdateTaxi:
	jmp	SHORT $LN3@UpdateTaxi
$LN7@UpdateTaxi:

; 3769 : 		}
; 3770 : 		// Cobra - Skip looking at parking pts.
; 3771 : //		else if(closest == GetPrevPtLoop(curTaxiPoint) && atcstatus == tTaxiBack)
; 3772 : 		else if(closest == GetPrevTaxiPt(curTaxiPoint) && atcstatus == tTaxiBack)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	cmp	DWORD PTR _closest$[ebp], eax
	jne	SHORT $LN3@UpdateTaxi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 29			; 0000001dH
	jne	SHORT $LN3@UpdateTaxi

; 3773 : 		{
; 3774 : 			if(IsSetATC(PermitRunway))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN2@UpdateTaxi

; 3775 : 				atcstatus = tTakeRunway;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 26			; 0000001aH

; 3776 : 			else

	jmp	SHORT $LN1@UpdateTaxi
$LN2@UpdateTaxi:

; 3777 : 				atcstatus = tTaxi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 22			; 00000016H
$LN1@UpdateTaxi:

; 3778 : 			SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 3779 : 			ClearATCFlag(CheckTaxiBack);

	push	33554432				; 02000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag
$LN3@UpdateTaxi:

; 3780 : 		}
; 3781 : 		SetTaxiPoint(closest);

	mov	eax, DWORD PTR _closest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 3782 : 		float tx, ty;
; 3783 : 		TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	ecx, DWORD PTR _ty$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 3784 : 		SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 3785 : 		CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 3786 : 		waittimer = CalcWaitTime(Airbase->brain);

	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], eax
$LN8@UpdateTaxi:
$LN15@UpdateTaxi:

; 3787 : 	}
; 3788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTaxipoint@DigitalBrain@@QAEXXZ ENDP		; DigitalBrain::UpdateTaxipoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?GetTaxiPoint@DigitalBrain@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTaxiPoint@DigitalBrain@@QAEHXZ PROC			; DigitalBrain::GetTaxiPoint, COMDAT
; _this$ = ecx

; 691  : 	int		GetTaxiPoint(void)								{return curTaxiPoint;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTaxiPoint@DigitalBrain@@QAEHXZ ENDP			; DigitalBrain::GetTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTaxiPoint@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pt$ = 8						; size = 4
?SetTaxiPoint@DigitalBrain@@QAEXH@Z PROC		; DigitalBrain::SetTaxiPoint, COMDAT
; _this$ = ecx

; 690  : 	void	SetTaxiPoint(int pt)							{curTaxiPoint = pt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [eax+332], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTaxiPoint@DigitalBrain@@QAEXH@Z ENDP		; DigitalBrain::SetTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_w$1 = -136						; size = 4
tv678 = -132						; size = 4
_tx$2 = -128						; size = 4
_u$3 = -124						; size = 4
_ty$4 = -120						; size = 4
_ty$5 = -116						; size = 4
_runwaypt$ = -112					; size = 4
tv688 = -108						; size = 4
_x2$ = -104						; size = 4
_tx$6 = -100						; size = 4
_y2$ = -96						; size = 4
_rwLocalIndex$ = -92					; size = 4
_cosAngle$7 = -88					; size = 4
_closestDist$ = -84					; size = 4
_action$8 = -80						; size = 4
_dist$ = -76						; size = 4
_gy$ = -72						; size = 2
_atcb$ = -68						; size = 4
_takeoffpt$ = -64					; size = 4
_gx$ = -60						; size = 2
_runwayStats$9 = -56					; size = 4
_closest$ = -52						; size = 4
_taxiPoint$ = -48					; size = 4
_dx$ = -44						; size = 4
_relx$ = -40						; size = 4
_dy$ = -36						; size = 4
_x1$ = -32						; size = 4
_y1$ = -28						; size = 4
_Airbase$ = -24						; size = 4
_this$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?ResetTaxiState@DigitalBrain@@QAEXXZ PROC		; DigitalBrain::ResetTaxiState
; _this$ = ecx

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 	// sfr: this is causing a big mess,
; 91   : 	// so Im renaming rwindex to rwLocalIndex (avoid confusion with member variable)
; 92   : 	// I just renamed here and the usages, nothing else... this code is confusing
; 93   : 	int takeoffpt, runwaypt, rwLocalIndex;
; 94   : 	float x1, y1, x2, y2;
; 95   : 	float dx, dy, relx;
; 96   : 	//float deltaHdg;
; 97   : 	//ObjectiveClass *Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);
; 98   : 
; 99   : 	// sfr: fixing xy order
; 100  : 	GridIndex gx, gy;				
; 101  : 	//gx = SimToGrid(self->YPos());
; 102  : 	//gy = SimToGrid(self->XPos());
; 103  : 	::vector pos = { self->XPos(), self->YPos()};

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _pos$[ebp+4]
	xor	edx, edx
	mov	DWORD PTR _pos$[ebp+8], edx

; 104  : 	ConvertSimToGrid(&pos, &gx, &gy);

	lea	eax, DWORD PTR _gy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH

; 105  : 	Objective Airbase = FindNearbyAirbase(gx, gy);

	movzx	eax, WORD PTR _gy$[ebp]
	push	eax
	movzx	ecx, WORD PTR _gx$[ebp]
	push	ecx
	call	?FindNearbyAirbase@@YAPAVObjectiveClass@@FF@Z ; FindNearbyAirbase
	add	esp, 8
	mov	DWORD PTR _Airbase$[ebp], eax

; 106  : 	if(!self->OnGround() || !Airbase){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN26@ResetTaxiS
	cmp	DWORD PTR _Airbase$[ebp], 0
	jne	SHORT $LN27@ResetTaxiS
$LN26@ResetTaxiS:

; 107  : 		if(atcstatus >= tReqTaxi){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 19			; 00000013H
	jl	SHORT $LN25@ResetTaxiS

; 108  : 			ResetATC();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetATC@DigitalBrain@@QAEXXZ		; DigitalBrain::ResetATC
$LN25@ResetTaxiS:

; 109  : 		}
; 110  : 		return;

	jmp	$LN28@ResetTaxiS
$LN27@ResetTaxiS:

; 111  : 	}
; 112  : 
; 113  : 	// sfr: no runway index means it doesnt have a runway yet
; 114  : 	// get one now
; 115  : 	ATCBrain *atcb = Airbase->brain;

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	mov	DWORD PTR _atcb$[ebp], eax

; 116  : 	if (atcb == NULL){ return; }

	cmp	DWORD PTR _atcb$[ebp], 0
	jne	SHORT $LN24@ResetTaxiS
	jmp	$LN28@ResetTaxiS
$LN24@ResetTaxiS:

; 117  : 	if (rwIndex == 0){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	jne	SHORT $LN20@ResetTaxiS

; 118  : 		UnitClass *u = static_cast<UnitClass*>(self->GetCampaignObject());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _u$3[ebp], eax

; 119  : 		WayPoint w = u->GetCurrentUnitWP();

	mov	ecx, DWORD PTR _u$3[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	DWORD PTR _w$1[ebp], eax

; 120  : 		int action = w->GetWPAction();

	mov	ecx, DWORD PTR _w$1[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	mov	DWORD PTR _action$8[ebp], eax

; 121  : 		if (action == WP_TAKEOFF){

	cmp	DWORD PTR _action$8[ebp], 1
	jne	SHORT $LN22@ResetTaxiS

; 122  : 			rwIndex = atcb->FindBestTakeoffRunway(TRUE);

	push	1
	mov	ecx, DWORD PTR _atcb$[ebp]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax
	jmp	SHORT $LN20@ResetTaxiS
$LN22@ResetTaxiS:

; 123  : 		}
; 124  : 		else if (action == WP_LAND){

	cmp	DWORD PTR _action$8[ebp], 7
	jne	SHORT $LN20@ResetTaxiS

; 125  : 			rwIndex = atcb->FindBestLandingRunway(self, TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _atcb$[ebp]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax
$LN20@ResetTaxiS:

; 126  : 		}
; 127  : 	}
; 128  : 
; 129  : 	// this should never happen, but it does
; 130  : 	if (rwIndex == 0){ return; }

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+304], 0
	jne	SHORT $LN19@ResetTaxiS
	jmp	$LN28@ResetTaxiS
$LN19@ResetTaxiS:

; 131  : 
; 132  : 	float dist, closestDist =  4000000.0F;

	movss	xmm0, DWORD PTR __real@4a742400
	movss	DWORD PTR _closestDist$[ebp], xmm0

; 133  : 	int taxiPoint, closest = curTaxiPoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	mov	DWORD PTR _closest$[ebp], ecx

; 134  : 
; 135  : 
; 136  : 	taxiPoint = GetFirstPt(rwIndex)+1;	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _taxiPoint$[ebp], eax
$LN18@ResetTaxiS:

; 137  : 	while(taxiPoint){

	cmp	DWORD PTR _taxiPoint$[ebp], 0
	je	$LN17@ResetTaxiS

; 138  : 		TranslatePointData(Airbase, taxiPoint, &x1, &y1);

	lea	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	eax, DWORD PTR _taxiPoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 139  : 		dx = x1 - af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR _dx$[ebp], xmm0

; 140  : 		dy = y1 - af->y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR [edx+1112]
	movss	DWORD PTR _dy$[ebp], xmm0

; 141  : 		dist = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 142  : 		if (dist < closestDist){

	movss	xmm0, DWORD PTR _closestDist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN16@ResetTaxiS

; 143  : 			closestDist = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _closestDist$[ebp], xmm0

; 144  : 			closest = taxiPoint;

	mov	eax, DWORD PTR _taxiPoint$[ebp]
	mov	DWORD PTR _closest$[ebp], eax
$LN16@ResetTaxiS:

; 145  : 		}
; 146  : 		taxiPoint = GetNextPt(taxiPoint);

	mov	ecx, DWORD PTR _taxiPoint$[ebp]
	push	ecx
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	mov	DWORD PTR _taxiPoint$[ebp], eax

; 147  : 	}

	jmp	$LN18@ResetTaxiS
$LN17@ResetTaxiS:

; 148  : 
; 149  : 	if (closest != curTaxiPoint){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _closest$[ebp]
	cmp	eax, DWORD PTR [edx+332]
	je	SHORT $LN15@ResetTaxiS

; 150  : 		SetTaxiPoint(closest);

	mov	ecx, DWORD PTR _closest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 151  : 		self->spawnpoint = closest;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _closest$[ebp]
	mov	DWORD PTR [eax+1792], ecx

; 152  : 		float tx, ty;
; 153  : 		TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$5[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 154  : 		SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$5[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$6[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
$LN15@ResetTaxiS:

; 155  : 	}
; 156  : 
; 157  : 	if(self->AutopilotType() == AircraftClass::APOff){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 4
	jne	SHORT $LN14@ResetTaxiS

; 158  : 		return;

	jmp	$LN28@ResetTaxiS
$LN14@ResetTaxiS:

; 159  : 	}
; 160  : 	
; 161  : 	if( (atcstatus == tTakeRunway || atcstatus == tTakeoff) && 
; 162  : 		 (PtDataTable[curTaxiPoint].type == TakeoffPt || PtDataTable[curTaxiPoint].type == RunwayPt) )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 26			; 0000001aH
	je	SHORT $LN12@ResetTaxiS
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 27			; 0000001bH
	jne	$LN13@ResetTaxiS
$LN12@ResetTaxiS:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	je	SHORT $LN11@ResetTaxiS
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 1
	jne	$LN13@ResetTaxiS
$LN11@ResetTaxiS:

; 163  : 	{
; 164  : 		rwLocalIndex = Airbase->brain->IsOnRunway(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	DWORD PTR _rwLocalIndex$[ebp], eax

; 165  : 
; 166  : 		takeoffpt = 
; 167  : 			Airbase->brain->FindTakeoffPt(
; 168  : 				(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &x1, &y1
; 169  : 			);

	lea	eax, DWORD PTR _y1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	mov	DWORD PTR _takeoffpt$[ebp], eax

; 170  : 		runwaypt = 
; 171  : 			Airbase->brain->FindRunwayPt(
; 172  : 				(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &x2, &y2
; 173  : 			);

	lea	eax, DWORD PTR _y2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindRunwayPt
	mov	DWORD PTR _runwaypt$[ebp], eax

; 174  : 
; 175  : 		float cosAngle =	self->platformAngles.sinsig * PtHeaderDataTable[rwIndex].sinHeading + 
; 176  : 							self->platformAngles.cossig * PtHeaderDataTable[rwIndex].cosHeading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+372]
	mulss	xmm0, DWORD PTR [edx+eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR [ecx+376]
	mulss	xmm1, DWORD PTR [edx+eax+16]
	addss	xmm0, xmm1
	movss	DWORD PTR _cosAngle$7[ebp], xmm0

; 177  : 	
; 178  : 		runwayStatsStruct *runwayStats = Airbase->brain->GetRunwayStats();

	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetRunwayStats@ATCBrain@@QAEPAUrunwayStatsStruct@@XZ ; ATCBrain::GetRunwayStats
	mov	DWORD PTR _runwayStats$9[ebp], eax

; 179  : 		dx = runwayStats[PtHeaderDataTable[rwIndex].runwayNum].centerX - self->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	esi, BYTE PTR [eax+edx+24]
	imul	esi, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv678[ebp]
	mov	edx, DWORD PTR _runwayStats$9[ebp]
	movss	xmm0, DWORD PTR [edx+esi+16]
	subss	xmm0, DWORD PTR tv678[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 180  : 		dy = runwayStats[PtHeaderDataTable[rwIndex].runwayNum].centerY - self->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	esi, BYTE PTR [edx+ecx+24]
	imul	esi, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv688[ebp]
	mov	ecx, DWORD PTR _runwayStats$9[ebp]
	movss	xmm0, DWORD PTR [ecx+esi+20]
	subss	xmm0, DWORD PTR tv688[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 181  : 		
; 182  : 		relx = PtHeaderDataTable[rwIndex].cosHeading*dx + PtHeaderDataTable[rwIndex].sinHeading*dy;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR [ecx+eax+12]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 183  : 
; 184  : 		if (
; 185  : 			cosAngle > 0.99619F && 
; 186  : 			PtHeaderDataTable[rwIndex].runwayNum == PtHeaderDataTable[rwLocalIndex].runwayNum &&
; 187  : 			runwayStats[PtHeaderDataTable[rwIndex].runwayNum].halfheight + relx > 3000.0F 
; 188  : 		){

	movss	xmm0, DWORD PTR _cosAngle$7[ebp]
	comiss	xmm0, DWORD PTR __real@3f7f064f
	jbe	$LN10@ResetTaxiS
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	eax, DWORD PTR _rwLocalIndex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [ecx+eax+24]
	cmp	edx, eax
	jne	SHORT $LN10@ResetTaxiS
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _runwayStats$9[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+12]
	addss	xmm0, DWORD PTR _relx$[ebp]
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	SHORT $LN10@ResetTaxiS

; 189  : 			SetTrackPoint(x2, y2);

	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 190  : 			SetTaxiPoint(runwaypt);

	mov	eax, DWORD PTR _runwaypt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
	jmp	$LN7@ResetTaxiS
$LN10@ResetTaxiS:

; 191  : 		}
; 192  : 		else if( relx > 0.0F){

	movss	xmm0, DWORD PTR _relx$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@ResetTaxiS

; 193  : 			SetTrackPoint(
; 194  : 				x1 - relx * PtHeaderDataTable[rwIndex].cosHeading,
; 195  : 				y1 - relx * PtHeaderDataTable[rwIndex].sinHeading
; 196  : 			);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _relx$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+12]
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _relx$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+16]
	movss	xmm1, DWORD PTR _x1$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 197  : 			SetTaxiPoint(takeoffpt);

	mov	ecx, DWORD PTR _takeoffpt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 198  : 		}
; 199  : 		else {

	jmp	SHORT $LN7@ResetTaxiS
$LN8@ResetTaxiS:

; 200  : 			SetTrackPoint(x1, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 201  : 			SetTaxiPoint(takeoffpt);

	mov	edx, DWORD PTR _takeoffpt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN7@ResetTaxiS:

; 202  : 		}
; 203  : 		atcstatus = tTakeRunway;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 26			; 0000001aH

; 204  : 	}
; 205  : 	else	

	jmp	$LN1@ResetTaxiS
$LN13@ResetTaxiS:

; 206  : 	{
; 207  : 		if(PtDataTable[curTaxiPoint].type == TakeoffPt || PtDataTable[curTaxiPoint].type == RunwayPt)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 2
	je	SHORT $LN4@ResetTaxiS
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 1
	jne	SHORT $LN5@ResetTaxiS
$LN4@ResetTaxiS:

; 208  : 		{
; 209  : 			float tx, ty;
; 210  : 			takeoffpt = Airbase->brain->FindTakeoffPt(
; 211  : 				(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 212  : 			);

	lea	eax, DWORD PTR _ty$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	mov	DWORD PTR _takeoffpt$[ebp], eax

; 213  : 			SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$2[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 214  : 		}
; 215  : 		else

	jmp	$LN1@ResetTaxiS
$LN5@ResetTaxiS:

; 216  : 		{
; 217  : 			TranslatePointData(Airbase, curTaxiPoint, &x1, &y1);

	lea	eax, DWORD PTR _y1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 218  : 			dx = x1 - af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR _dx$[ebp], xmm0

; 219  : 			dy = y1 - af->y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR _y1$[ebp]
	subss	xmm0, DWORD PTR [edx+1112]
	movss	DWORD PTR _dy$[ebp], xmm0

; 220  : 			relx	= self->platformAngles.cospsi * dx + self->platformAngles.sinpsi * dy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR [ecx+408]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movss	xmm1, DWORD PTR [eax+404]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 221  : 			if(relx < 0.0F){

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	SHORT $LN2@ResetTaxiS

; 222  : 				ChooseNextPoint(Airbase);	

	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint

; 223  : 			}
; 224  : 			else {

	jmp	SHORT $LN1@ResetTaxiS
$LN2@ResetTaxiS:

; 225  : 				SetTrackPoint(x1, y1);

	push	ecx
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
$LN1@ResetTaxiS:

; 226  : 			}
; 227  : 		}
; 228  : 	}
; 229  : 
; 230  :    // Make sure ground weapon list is up to date
; 231  :    SelectGroundWeapon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectGroundWeapon@DigitalBrain@@IAEXXZ ; DigitalBrain::SelectGroundWeapon
$LN28@ResetTaxiS:

; 232  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetTaxiState@DigitalBrain@@QAEXXZ ENDP		; DigitalBrain::ResetTaxiState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv190 = -72						; size = 8
tv174 = -64						; size = 8
tv165 = -56						; size = 8
tv156 = -48						; size = 8
tv188 = -40						; size = 4
tv183 = -36						; size = 4
tv170 = -32						; size = 4
tv161 = -28						; size = 4
tv152 = -24						; size = 4
_count$ = -20						; size = 4
tv66 = -16						; size = 4
_this$ = -12						; size = 4
_time$ = -8						; size = 4
tv185 = -2						; size = 2
_Atc$ = 8						; size = 4
?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z PROC	; DigitalBrain::CalcWaitTime
; _this$ = ecx

; 3150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 3151 : 	VU_TIME count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3152 : 	VU_TIME time = rwtime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	mov	DWORD PTR _time$[ebp], ecx

; 3153 : 
; 3154 : 	switch(atcstatus)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 19					; 00000013H
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 8
	ja	SHORT $LN6@CalcWaitTi
	mov	edx, DWORD PTR tv66[ebp]
	movzx	eax, BYTE PTR $LN14@CalcWaitTi[edx]
	jmp	DWORD PTR $LN15@CalcWaitTi[eax*4]
$LN9@CalcWaitTi:

; 3155 : 	{
; 3156 : 	case tPrepToTakeRunway:
; 3157 : 	case tTakeRunway:
; 3158 : 	case tTakeoff:
; 3159 : 		time = SimLibElapsedTime + static_cast<VU_TIME>(MoveAlong * CampaignSeconds);	 // FRB - 5 ==> MoveAlong

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 3000				; 00000bb8H
	mov	DWORD PTR _time$[ebp], ecx

; 3160 : 		break;

	jmp	$LN10@CalcWaitTi
$LN8@CalcWaitTi:

; 3161 : 			
; 3162 : 	case tEmerStop:
; 3163 : 		time = SimLibElapsedTime + 2 * TAKEOFF_TIME_DELTA;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 20000				; 00004e20H
	mov	DWORD PTR _time$[ebp], edx

; 3164 : 		break;

	jmp	$LN10@CalcWaitTi
$LN7@CalcWaitTi:

; 3165 : 
; 3166 : 	case tHoldShort:
; 3167 : 	case tReqTaxi:
; 3168 : 	case tReqTakeoff:
; 3169 : //		time = SimLibElapsedTime + TAKEOFF_TIME_DELTA;	 // FRB - elapse time 10 sec???
; 3170 : 		time = SimLibElapsedTime + static_cast<VU_TIME>(MoveAlong * CampaignSeconds);	 // FRB - 2

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 3000				; 00000bb8H
	mov	DWORD PTR _time$[ebp], eax

; 3171 : 		break;

	jmp	$LN10@CalcWaitTi
$LN6@CalcWaitTi:

; 3172 : 	
; 3173 : 	case tTaxi:		
; 3174 : 	default:
; 3175 : 		
; 3176 : 		count = GetTaxiPosition(curTaxiPoint, rwIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetTaxiPosition@@YAHHH@Z		; GetTaxiPosition
	add	esp, 8
	mov	DWORD PTR _count$[ebp], eax

; 3177 : 		if(rwtime > count * (MoveAlong * CampaignSeconds) + SimLibElapsedTime)	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+316]
	mov	DWORD PTR tv152[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv152[ebp]
	mov	ecx, DWORD PTR tv152[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv156[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv156[ebp]
	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv161[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv161[ebp]
	mov	eax, DWORD PTR tv161[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv165[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv165[ebp]
	mulss	xmm1, DWORD PTR __real@453b8000
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv170[ebp], ecx
	cvtsi2sd xmm2, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR tv170[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm2, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv174[ebp], xmm2
	cvtsd2ss xmm2, QWORD PTR tv174[ebp]
	addss	xmm1, xmm2
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@CalcWaitTi

; 3178 : 		{
; 3179 : 			time = ((rwtime - (count * (VU_TIME)(MoveAlong * CampaignSeconds) + SimLibElapsedTime)) + SimLibElapsedTime);	  // FRB - (count * TAKEOFF_TIME_DELTA) is delta time

	mov	eax, DWORD PTR _count$[ebp]
	imul	eax, 3000				; 00000bb8H
	add	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+316]
	sub	edx, eax
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _time$[ebp], edx

; 3180 : 			time -= (VU_TIME)(g_fTaxiEarly * CampaignSeconds);		//RAS - 10Oct04 - Added hold short delay to start taxi sooner

	movss	xmm0, DWORD PTR ?g_fTaxiEarly@@3MA
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv183[ebp], xmm0
	fld	DWORD PTR tv183[ebp]
	fnstcw	WORD PTR tv185[ebp]
	movzx	eax, WORD PTR tv185[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv188[ebp], eax
	fldcw	WORD PTR tv188[ebp]
	fistp	QWORD PTR tv190[ebp]
	fldcw	WORD PTR tv185[ebp]
	mov	eax, DWORD PTR _time$[ebp]
	sub	eax, DWORD PTR tv190[ebp]
	mov	DWORD PTR _time$[ebp], eax

; 3181 : 			if(time < SimLibElapsedTime)

	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN4@CalcWaitTi

; 3182 : 				time = SimLibElapsedTime;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _time$[ebp], edx
$LN4@CalcWaitTi:

; 3183 : 		}

	jmp	SHORT $LN1@CalcWaitTi
$LN5@CalcWaitTi:

; 3184 : 			
; 3185 : 		else if(PtDataTable[curTaxiPoint].type <= TakeoffPt)																				//        rwtime is Sim clock time

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 2
	jg	SHORT $LN2@CalcWaitTi

; 3186 : 			
; 3187 : 			time = SimLibElapsedTime + (VU_TIME)(MoveAlong * CampaignSeconds);

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 3000				; 00000bb8H
	mov	DWORD PTR _time$[ebp], ecx

; 3188 : 		else

	jmp	SHORT $LN1@CalcWaitTi
$LN2@CalcWaitTi:

; 3189 : 			time = SimLibElapsedTime + (VU_TIME)(HurryUp * CampaignSeconds);

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 1000				; 000003e8H
	mov	DWORD PTR _time$[ebp], edx
$LN1@CalcWaitTi:
$LN10@CalcWaitTi:

; 3190 : 	}
; 3191 : 
; 3192 : 	return time;

	mov	eax, DWORD PTR _time$[ebp]

; 3193 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN15@CalcWaitTi:
	DD	$LN7@CalcWaitTi
	DD	$LN8@CalcWaitTi
	DD	$LN9@CalcWaitTi
	DD	$LN6@CalcWaitTi
$LN14@CalcWaitTi:
	DB	0
	DB	0
	DB	1
	DB	3
	DB	3
	DB	0
	DB	2
	DB	2
	DB	2
?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ENDP	; DigitalBrain::CalcWaitTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetDebugLabel@DigitalBrain@@QAEXPAVObjectiveClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetDebugLabel@DigitalBrain@@QAEXPAVObjectiveClass@@@Z PROC ; DigitalBrain::SetDebugLabel, COMDAT
; _this$ = ecx

; 684  : 	void	SetDebugLabel(ObjectiveClass*)			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDebugLabel@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ENDP ; DigitalBrain::SetDebugLabel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv223 = -28						; size = 4
tv218 = -24						; size = 4
tv205 = -20						; size = 4
tv195 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
_setTaxiLight$ = -1					; size = 1
_inTheWay$ = 8						; size = 4
?RandomStuff@DigitalBrain@@IAEXPAVSimBaseClass@@@Z PROC	; DigitalBrain::RandomStuff
; _this$ = ecx

; 1357 : void DigitalBrain::RandomStuff(SimBaseClass *inTheWay){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1358 : 	// will be used below as needed
; 1359 : 	bool setTaxiLight;
; 1360 : 	if (TheTimeOfDay.GetLightLevel() >= 0.65f){

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetLightLevel@CTimeOfDay@@QAEMXZ	; CTimeOfDay::GetLightLevel
	fstp	DWORD PTR tv195[ebp]
	movss	xmm0, DWORD PTR tv195[ebp]
	comiss	xmm0, DWORD PTR __real@3f266666
	jb	SHORT $LN20@RandomStuf

; 1361 : 		setTaxiLight = false;

	mov	BYTE PTR _setTaxiLight$[ebp], 0

; 1362 : 		//self->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);
; 1363 : 	}
; 1364 : 	else {

	jmp	SHORT $LN19@RandomStuf
$LN20@RandomStuf:

; 1365 : 		setTaxiLight = true;

	mov	BYTE PTR _setTaxiLight$[ebp], 1
$LN19@RandomStuf:

; 1366 : 		//self->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);
; 1367 : 	}
; 1368 : 
; 1369 : 	switch(atcstatus){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 11					; 0000000bH
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 16			; 00000010H
	ja	$LN17@RandomStuf
	mov	eax, DWORD PTR tv68[ebp]
	movzx	ecx, BYTE PTR $LN23@RandomStuf[eax]
	jmp	DWORD PTR $LN24@RandomStuf[ecx*4]

; 1370 : 		case noATC:
; 1371 : 		case lReqClearance:
; 1372 : 		case lReqEmerClearance:
; 1373 : 		case lIngressing:
; 1374 : 		case lTakingPosition:
; 1375 : 		case lAborted:
; 1376 : 		case lEmerHold:
; 1377 : 		case lHolding:
; 1378 : 		case lFirstLeg:
; 1379 : 		case lToBase:
; 1380 : 		case lToFinal:
; 1381 : 		case lEmergencyToBase:
; 1382 : 		case lEmergencyToFinal:
; 1383 : 		case lClearToLand:
; 1384 : 		case lCrashed:
; 1385 : 		break;

	jmp	$LN17@RandomStuf
$LN15@RandomStuf:

; 1386 : 
; 1387 : 		case lEmergencyOnFinal:
; 1388 : 		case lOnFinal:
; 1389 : 			self->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 1390 : 		break;

	jmp	$LN17@RandomStuf
$LN14@RandomStuf:

; 1391 : 
; 1392 : 		case lLanded:
; 1393 : 		{
; 1394 : 			if (setTaxiLight && PRANDFloatPos()>0.998f){

	movzx	eax, BYTE PTR _setTaxiLight$[ebp]
	test	eax, eax
	je	SHORT $LN13@RandomStuf
	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv205[ebp]
	movss	xmm0, DWORD PTR tv205[ebp]
	comiss	xmm0, DWORD PTR __real@3f7f7cee
	jbe	SHORT $LN13@RandomStuf

; 1395 : 				self->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 1396 : 				self->SetSwitch(COMP_3DPIT_INTERIOR_LIGHTS, TRUE);

	push	1
	push	127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN13@RandomStuf:

; 1397 : 			}
; 1398 : 		}
; 1399 : 		break;

	jmp	$LN17@RandomStuf
$LN12@RandomStuf:

; 1400 : 		case lTaxiOff:
; 1401 : 		{
; 1402 : 			if (AtFinalTaxiPoint() && desiredSpeed==0){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AtFinalTaxiPoint@DigitalBrain@@IAE_NXZ	; DigitalBrain::AtFinalTaxiPoint
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@RandomStuf
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+336]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@RandomStuf

; 1403 : 				self->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT); 

	push	32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN11@RandomStuf:

; 1404 : 			}
; 1405 : 			if (setTaxiLight){ 

	movzx	eax, BYTE PTR _setTaxiLight$[ebp]
	test	eax, eax
	je	SHORT $LN10@RandomStuf

; 1406 : 				self->SetSwitch(COMP_3DPIT_INTERIOR_LIGHTS, TRUE); 

	push	1
	push	127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN10@RandomStuf:

; 1407 : 			}
; 1408 : 		}
; 1409 : 		break;

	jmp	$LN17@RandomStuf
$LN9@RandomStuf:

; 1410 : 		case tReqTaxi:
; 1411 : 		case tReqTakeoff:
; 1412 : 		case tEmerStop:
; 1413 : 		case tTaxi:					
; 1414 : 		{
; 1415 : 			//if (PRANDFloatPos()>0.998f || inTheWay){ // FRB
; 1416 : 			//	af->canopyState = false;
; 1417 : 			//}
; 1418 : 			if (setTaxiLight && (PRANDFloatPos()>0.998f || inTheWay)){

	movzx	edx, BYTE PTR _setTaxiLight$[ebp]
	test	edx, edx
	je	SHORT $LN8@RandomStuf
	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv218[ebp]
	movss	xmm0, DWORD PTR tv218[ebp]
	comiss	xmm0, DWORD PTR __real@3f7f7cee
	ja	SHORT $LN7@RandomStuf
	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	SHORT $LN8@RandomStuf
$LN7@RandomStuf:

; 1419 : 				self->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
$LN8@RandomStuf:

; 1420 : 			}
; 1421 : 			if (PRANDFloatPos()>0.998f){

	call	?PRANDFloatPos@@YAMXZ			; PRANDFloatPos
	fstp	DWORD PTR tv223[ebp]
	movss	xmm0, DWORD PTR tv223[ebp]
	comiss	xmm0, DWORD PTR __real@3f7f7cee
	jbe	SHORT $LN6@RandomStuf

; 1422 : 				self->SetSwitch(COMP_3DPIT_INTERIOR_LIGHTS, FALSE);

	push	0
	push	127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch
$LN6@RandomStuf:

; 1423 : 			}
; 1424 : 		}
; 1425 : 		break;

	jmp	SHORT $LN17@RandomStuf
$LN5@RandomStuf:

; 1426 : 		case tWait:
; 1427 : 		case tHoldShort:
; 1428 : 		case tPrepToTakeRunway:
; 1429 : 		case tTakeRunway:			
; 1430 : 		case tTakeoff:	
; 1431 : 		{			
; 1432 : 			if (setTaxiLight){

	movzx	edx, BYTE PTR _setTaxiLight$[ebp]
	test	edx, edx
	je	SHORT $LN4@RandomStuf

; 1433 : 				self->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
$LN4@RandomStuf:

; 1434 : 			}
; 1435 : 			self->SetSwitch(COMP_3DPIT_INTERIOR_LIGHTS, FALSE);

	push	0
	push	127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1436 : 			af->canopyState = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	BYTE PTR [eax+1588], 0
$LN17@RandomStuf:

; 1437 : 		}
; 1438 : 		break;
; 1439 : 		case tFlyOut:
; 1440 : 		case tTaxiBack:	
; 1441 : 		break;	
; 1442 : 	}
; 1443 : 
; 1444 : //	if (af->LLON){ self->SetAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT); }
; 1445 : //	else { self->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT); }
; 1446 : 
; 1447 : 	if (self->GetSwitch(COMP_3DPIT_INTERIOR_LIGHTS)){ self->SetAcStatusBits(AircraftClass::ACSTATUS_PITLIGHT); }

	push	127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetSwitch@SimMoverClass@@QAEHH@Z	; SimMoverClass::GetSwitch
	test	eax, eax
	je	SHORT $LN2@RandomStuf
	push	256					; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits
	jmp	SHORT $LN1@RandomStuf
$LN2@RandomStuf:

; 1448 : 	else { self->ClearAcStatusBits(AircraftClass::ACSTATUS_PITLIGHT); }

	push	256					; 00000100H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN1@RandomStuf:

; 1449 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN24@RandomStuf:
	DD	$LN15@RandomStuf
	DD	$LN14@RandomStuf
	DD	$LN12@RandomStuf
	DD	$LN9@RandomStuf
	DD	$LN5@RandomStuf
	DD	$LN17@RandomStuf
$LN23@RandomStuf:
	DB	0
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	0
	DB	5
	DB	3
	DB	3
	DB	3
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
?RandomStuff@DigitalBrain@@IAEXPAVSimBaseClass@@@Z ENDP	; DigitalBrain::RandomStuff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_x$ = -24						; size = 4
_y$ = -20						; size = 4
_pktype$ = -16						; size = 4
_npt$ = -12						; size = 4
_this$ = -8						; size = 4
_pt$ = -4						; size = 4
_Airbase$ = 8						; size = 4
?BestParkSpot@DigitalBrain@@IAEHPAVObjectiveClass@@@Z PROC ; DigitalBrain::BestParkSpot
; _this$ = ecx

; 1186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1187 : 	float x, y;
; 1188 : 	int pktype = af->GetParkType();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	mov	DWORD PTR _pktype$[ebp], eax

; 1189 : 	int npt, pt = curTaxiPoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR _pt$[ebp], edx

; 1190 : #if 1	 // 17JAN04 - FRB -	Find the *closest* available parking spot.
; 1191 : 	pt = GetNextParkTypePt(curTaxiPoint, pktype); // find first available parking spot

	mov	eax, DWORD PTR _pktype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetNextParkTypePt@@YAHHH@Z		; GetNextParkTypePt
	add	esp, 8
	mov	DWORD PTR _pt$[ebp], eax

; 1192 : 	npt = pt;

	mov	eax, DWORD PTR _pt$[ebp]
	mov	DWORD PTR _npt$[ebp], eax
$LN3@BestParkSp:

; 1193 : 	while(PtDataTable[npt].flags != PT_LAST) 

	mov	ecx, DWORD PTR _npt$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	cmp	eax, 2
	je	SHORT $LN2@BestParkSp

; 1194 : 	{
; 1195 : 		pt = npt;

	mov	ecx, DWORD PTR _npt$[ebp]
	mov	DWORD PTR _pt$[ebp], ecx

; 1196 : 		TranslatePointData(Airbase, pt, &x, &y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1197 : 		if (CheckPoint(x, y) == NULL) 						

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckPoint@DigitalBrain@@IAEPAVSimBaseClass@@MM@Z ; DigitalBrain::CheckPoint
	test	eax, eax
	jne	SHORT $LN1@BestParkSp

; 1198 : 		{ // this is good?
; 1199 : 			return pt;

	mov	eax, DWORD PTR _pt$[ebp]
	jmp	SHORT $LN4@BestParkSp
$LN1@BestParkSp:

; 1200 : 		}
; 1201 : 		npt = GetNextParkTypePt(pt, pktype);

	mov	eax, DWORD PTR _pktype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	call	?GetNextParkTypePt@@YAHHH@Z		; GetNextParkTypePt
	add	esp, 8
	mov	DWORD PTR _npt$[ebp], eax

; 1202 : 	}

	jmp	SHORT $LN3@BestParkSp
$LN2@BestParkSp:

; 1203 : #else
; 1204 : 	while ((npt = GetNextParkTypePt(pt, pktype)) != 0) // find last possible parking spot
; 1205 : 		pt = npt;
; 1206 : 	if (PtDataTable[pt].type != pktype) // just in case we found none	 // FRB - isn't pt == 0 here???
; 1207 : 		return 0;
; 1208 : 	while (pt > curTaxiPoint) 
; 1209 : 	{
; 1210 : 		TranslatePointData(Airbase, pt, &x, &y);
; 1211 : 		if (CheckPoint(x, y) == NULL) 
; 1212 : 		{ // this is good?
; 1213 : 			return pt;
; 1214 : 		}
; 1215 : 		pt = GetPrevParkTypePt(pt, pktype); // ok try another	 // FRB - shouldn't it be GetNextParkTypePt
; 1216 : 	}
; 1217 : #endif
; 1218 : 	return pt;

	mov	eax, DWORD PTR _pt$[ebp]
$LN4@BestParkSp:

; 1219 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BestParkSpot@DigitalBrain@@IAEHPAVObjectiveClass@@@Z ENDP ; DigitalBrain::BestParkSpot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AtFinalTaxiPoint@DigitalBrain@@IAE_NXZ PROC		; DigitalBrain::AtFinalTaxiPoint
; _this$ = ecx

; 1279 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1280 : 	// final point is one of these
; 1281 : 	if (PtDataTable[curTaxiPoint].type == SmallParkPt ||
; 1282 : 		PtDataTable[curTaxiPoint].type == LargeParkPt ||
; 1283 : 		PtDataTable[curTaxiPoint].flags == PT_LAST) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN1@AtFinalTax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN1@AtFinalTax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	cmp	edx, 2
	jne	SHORT $LN2@AtFinalTax
$LN1@AtFinalTax:

; 1284 : 		return CloseToTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseToTrackPoint@DigitalBrain@@IAE_NXZ ; DigitalBrain::CloseToTrackPoint
	jmp	SHORT $LN3@AtFinalTax
$LN2@AtFinalTax:

; 1285 : 	}
; 1286 : 	return false;

	xor	al, al
$LN3@AtFinalTax:

; 1287 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AtFinalTaxiPoint@DigitalBrain@@IAE_NXZ ENDP		; DigitalBrain::AtFinalTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv129 = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?CloseToTrackPoint@DigitalBrain@@IAE_NXZ PROC		; DigitalBrain::CloseToTrackPoint
; _this$ = ecx

; 1290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1291 : 	if (fabs(trackX - af->x) < TAXI_CHECK_DIST && 
; 1292 : 		fabs(trackY - af->y) < TAXI_CHECK_DIST) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+148]
	subss	xmm0, DWORD PTR [ecx+1108]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv88[ebp]
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR tv88[ebp]
	jbe	SHORT $LN1@CloseToTra
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR [ecx+1112]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv129[ebp]
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR tv129[ebp]
	jbe	SHORT $LN1@CloseToTra

; 1293 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@CloseToTra
$LN1@CloseToTra:

; 1294 : 	return false;

	xor	al, al
$LN2@CloseToTra:

; 1295 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseToTrackPoint@DigitalBrain@@IAE_NXZ ENDP		; DigitalBrain::CloseToTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_bestpt$ = -12						; size = 4
_this$ = -8						; size = 4
_pt$ = -4						; size = 4
_Airbase$ = 8						; size = 4
?FindParkingSpot@DigitalBrain@@IAEXPAVObjectiveClass@@@Z PROC ; DigitalBrain::FindParkingSpot
; _this$ = ecx

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1223 : #if 1		
; 1224 : 	int bestpt = BestParkSpot(Airbase);

	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BestParkSpot@DigitalBrain@@IAEHPAVObjectiveClass@@@Z ; DigitalBrain::BestParkSpot
	mov	DWORD PTR _bestpt$[ebp], eax

; 1225 : 	int pt = GetNextPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax
$LN7@FindParkin:

; 1226 : 	while(PtDataTable[pt].flags != PT_LAST) 

	mov	eax, DWORD PTR _pt$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	cmp	edx, 2
	je	SHORT $LN6@FindParkin

; 1227 : 	{
; 1228 : 		if (pt == bestpt) { 

	mov	eax, DWORD PTR _pt$[ebp]
	cmp	eax, DWORD PTR _bestpt$[ebp]
	jne	SHORT $LN5@FindParkin

; 1229 : 			// next taxi point is our favoured parking spot
; 1230 : 			SetTaxiPoint(pt);

	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1231 : 			return;

	jmp	SHORT $LN8@FindParkin

; 1232 : 		}
; 1233 : 		else if (

	jmp	SHORT $LN4@FindParkin
$LN5@FindParkin:

; 1234 : 			PtDataTable[pt].type == SmallParkPt || // already used (not bestpt), skip
; 1235 : 			PtDataTable[pt].type == LargeParkPt
; 1236 : 		){

	mov	edx, DWORD PTR _pt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 11					; 0000000bH
	je	SHORT $LN2@FindParkin
	mov	edx, DWORD PTR _pt$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN3@FindParkin
$LN2@FindParkin:

; 1237 : 			pt = GetNextPtLoop(pt);

	mov	edx, DWORD PTR _pt$[ebp]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _pt$[ebp], eax

; 1238 : 		}
; 1239 : 		else {

	jmp	SHORT $LN4@FindParkin
$LN3@FindParkin:

; 1240 : 			SetTaxiPoint(pt); // keep on trucking	

	mov	eax, DWORD PTR _pt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1241 : 			return;	  

	jmp	SHORT $LN8@FindParkin
$LN4@FindParkin:

; 1242 : 		}
; 1243 : 	}

	jmp	SHORT $LN7@FindParkin
$LN6@FindParkin:

; 1244 : 	SetTaxiPoint(pt);

	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN8@FindParkin:

; 1245 : #else
; 1246 : 	float x, y;
; 1247 : 	int pt = GetNextPtLoop(curTaxiPoint);
; 1248 : 	int pktype = af->GetParkType();
; 1249 : 
; 1250 : 	while(PtDataTable[pt].flags != PT_LAST) 
; 1251 : 	{
; 1252 : 		if (PtDataTable[pt].type == pktype) 
; 1253 : 		{
; 1254 : 			TranslatePointData(Airbase, pt, &x, &y);
; 1255 : 			if (CheckPoint(x, y) == NULL) 
; 1256 : 			{
; 1257 : 				SetTaxiPoint(pt);
; 1258 : 				return;
; 1259 : 			}
; 1260 : 			pt ++; // try next
; 1261 : 		}
; 1262 : 		else if (PtDataTable[pt].type == SmallParkPt ||
; 1263 : 			PtDataTable[pt].type == LargeParkPt) 
; 1264 : 		{
; 1265 : 			pt = GetNextPtLoop(pt);
; 1266 : 		}
; 1267 : 		else 
; 1268 : 		{ // not a parking spot, so carry on
; 1269 : 			SetTaxiPoint(pt);
; 1270 : 			return;
; 1271 : 		}
; 1272 : 	}
; 1273 : 	SetTaxiPoint(pt);
; 1274 : #endif
; 1275 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindParkingSpot@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ENDP ; DigitalBrain::FindParkingSpot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv1299 = -196						; size = 4
tv1395 = -192						; size = 4
tv1691 = -188						; size = 4
tv1455 = -184						; size = 4
tv1636 = -180						; size = 4
$T2 = -176						; size = 4
tv943 = -172						; size = 4
tv1441 = -168						; size = 4
tv942 = -164						; size = 4
_Airbase$3 = -160					; size = 4
tv1602 = -156						; size = 4
_Airbase$4 = -152					; size = 4
tv1577 = -148						; size = 4
tv1447 = -144						; size = 4
tv1568 = -140						; size = 4
tv1405 = -136						; size = 4
tv1700 = -132						; size = 4
tv1390 = -128						; size = 4
tv1561 = -124						; size = 4
tv1555 = -120						; size = 4
_Airbase$5 = -116					; size = 4
_unitWalker$6 = -112					; size = 12
_taxiPoint$7 = -100					; size = 4
_taxiPoint$8 = -96					; size = 4
_taxiPoint$9 = -92					; size = 4
_range$10 = -88						; size = 4
_stickError$ = -84					; size = 4
_minAz$ = -80						; size = 4
_myRad$ = -76						; size = 4
_testRad$ = -72						; size = 4
_numOnRight$ = -68					; size = 4
_numOnLeft$ = -64					; size = 4
_dist$ = -60						; size = 4
_azErr$ = -56						; size = 4
_az$ = -52						; size = 4
_tmpX$ = -48						; size = 4
_tmpY$ = -44						; size = 4
_BigBoy$ = -37						; size = 1
_testObject$ = -36					; size = 4
_ry$ = -32						; size = 4
_yft$ = -28						; size = 4
_xft$ = -24						; size = 4
_rx$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_speed$ = 8						; size = 4
?SimpleGroundTrack@DigitalBrain@@IAEHM@Z PROC		; DigitalBrain::SimpleGroundTrack
; _this$ = ecx

; 3373 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3374 : 	float tmpX, tmpY;
; 3375 : 	float rx, ry;
; 3376 : 	float az, azErr;
; 3377 : 	float stickError;
; 3378 : 	SimBaseClass* testObject;
; 3379 : 	int numOnLeft, numOnRight;
; 3380 : 	float myRad, testRad, xft, yft, dist;
; 3381 : 	float minAz = 1000.0f;	

	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _minAz$[ebp], xmm0

; 3382 : 	bool BigBoy = false;

	mov	BYTE PTR _BigBoy$[ebp], 0

; 3383 : 	
; 3384 : 	if(speed > 0.0f) //RAS - 14Oct04 - Keep AI from rolling if they aren't supposed to, if Player can't move, then change this

	movss	xmm0, DWORD PTR _speed$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN65@SimpleGrou

; 3385 :         af->ClearFlag(AirframeClass::WheelBrakes);  //RAS - may need to add this line to playerEntity section below

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN65@SimpleGrou:

; 3386 : 	xft = trackX - af->x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR _xft$[ebp], xmm0

; 3387 : 	yft = trackY - af->y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+152]
	subss	xmm0, DWORD PTR [edx+1112]
	movss	DWORD PTR _yft$[ebp], xmm0

; 3388 : 	// get relative position and az
; 3389 : 	rx	= self->dmx[0][0] * xft + self->dmx[0][1] * yft;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 3390 : 	ry	= self->dmx[1][0] * xft + self->dmx[1][1] * yft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 3391 : 
; 3392 : 	if(self == SimDriver.GetPlayerEntity() && IsSetATC(StopPlane))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	jne	$LN64@SimpleGrou
	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN64@SimpleGrou

; 3393 : 	{
; 3394 : 		// call simple track to set the stick
; 3395 : 		if(rx < 10.0F)

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	$LN63@SimpleGrou

; 3396 : 		{
; 3397 : //			int taxiPoint = GetPrevPtLoop(curTaxiPoint);
; 3398 : 			int taxiPoint = GetPrevTaxiPt(curTaxiPoint);	// 03JAN04 - FRB - Skip Parking spots

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _taxiPoint$8[ebp], eax

; 3399 : 			if (!taxiPoint)

	cmp	DWORD PTR _taxiPoint$8[ebp], 0
	jne	SHORT $LN62@SimpleGrou

; 3400 : 				taxiPoint = GetPrevPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _taxiPoint$8[ebp], eax
$LN62@SimpleGrou:

; 3401 : 			ObjectiveClass	*Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$4[ebp], eax

; 3402 : 
; 3403 : 			TranslatePointData(Airbase, taxiPoint, &tmpX, &tmpY);

	lea	eax, DWORD PTR _tmpY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _taxiPoint$8[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$4[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3404 : 			xft = tmpX - af->x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	subss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR _xft$[ebp], xmm0

; 3405 : 			yft = tmpY - af->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	subss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR _yft$[ebp], xmm0

; 3406 : 			// get relative position and az
; 3407 : 			rx	= self->dmx[0][0] * xft + self->dmx[0][1] * yft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 3408 : 			ry	= self->dmx[1][0] * xft + self->dmx[1][1] * yft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 3409 : 			if(gameCompressionRatio)

	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 0	; gameCompressionRatio
	je	SHORT $LN61@SimpleGrou

; 3410 : 				// JB 020315 Why divide by gameCompressionRation?  It screws up taxing for one thing.
; 3411 : 				rStick = SimpleTrackAzimuth(rx , ry, self->GetVt());///gameCompressionRatio;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z ; DigitalBrain::SimpleTrackAzimuth
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]

; 3412 : 			else

	jmp	SHORT $LN60@SimpleGrou
$LN61@SimpleGrou:

; 3413 : 				rStick = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+32], xmm0
$LN60@SimpleGrou:

; 3414 : 			pStick = 0.0F;	

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+28], xmm0

; 3415 : 			throtl = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 3416 : 			af->vt = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1120], xmm0

; 3417 : 			af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3418 : 		}
; 3419 : 		else

	jmp	SHORT $LN59@SimpleGrou
$LN63@SimpleGrou:

; 3420 : 			TrackPoint(0.0f, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)
$LN59@SimpleGrou:

; 3421 : 
; 3422 : 		return FALSE;

	xor	eax, eax
	jmp	$LN66@SimpleGrou
$LN64@SimpleGrou:

; 3423 : 	}
; 3424 : 
; 3425 : 	if ( atcstatus == tTakeoff )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 27			; 0000001bH
	jne	$LN58@SimpleGrou

; 3426 : 	{
; 3427 : 		// once we're taking off just do it....
; 3428 : 		//aim for a five degree climb	
; 3429 : 	  af->LEFTakeoff();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?LEFTakeoff@AirframeClass@@QAEXXZ	; AirframeClass::LEFTakeoff

; 3430 : 	  af->TEFTakeoff();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?TEFTakeoff@AirframeClass@@QAEXXZ	; AirframeClass::TEFTakeoff

; 3431 : 		rStick = SimpleTrackAzimuth(rx + 1000.0F, ry, self->GetVt());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _rx$[ebp]
	addss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z ; DigitalBrain::SimpleTrackAzimuth
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]

; 3432 : 
; 3433 : 		pStick = 5 * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3db2b8c1
	movss	DWORD PTR [edx+28], xmm0

; 3434 : 		throtl = 1.5f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [eax+40], xmm0

; 3435 : 	}
; 3436 : 	else

	jmp	$LN57@SimpleGrou
$LN58@SimpleGrou:

; 3437 : 	{
; 3438 : 		// cheat a bit so we don't chase around in a circle
; 3439 : 		// if we're getting close to our track point, slow and
; 3440 : 		// rotate towards it
; 3441 : 		
; 3442 : 		dist = xft * xft + yft * yft;

	movss	xmm0, DWORD PTR _xft$[ebp]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	movss	xmm1, DWORD PTR _yft$[ebp]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 3443 : 		if ( dist < TAXI_CHECK_DIST * TAXI_CHECK_DIST) // * 4.0F) // Cobra - 120' may be not close enough

	movss	xmm0, DWORD PTR __real@45610000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN55@SimpleGrou

; 3444 : 		{
; 3445 : 			az	= (float) atan2 (ry,rx);

	cvtss2sd xmm0, DWORD PTR _rx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _az$[ebp]

; 3446 : 			if ( fabs( az ) > 30.0f * DTR )

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1299[ebp]
	movss	xmm0, DWORD PTR tv1299[ebp]
	comiss	xmm0, DWORD PTR __real@3f060a91
	jbe	SHORT $LN55@SimpleGrou

; 3447 : 				speed *= 0.5f;

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _speed$[ebp], xmm0
$LN55@SimpleGrou:

; 3448 : 		}
; 3449 : 
; 3450 : 		// call simple track to set the stick
; 3451 : 		TrackPoint(0.0f, speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)
$LN57@SimpleGrou:

; 3452 : 	}	
; 3453 : 
; 3454 : 	if ( speed == 0.0f )

	movss	xmm0, DWORD PTR _speed$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN54@SimpleGrou

; 3455 : 	{
; 3456 : 		// if no speed we're done
; 3457 : 		if(rx < 10.0F)

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	$LN53@SimpleGrou

; 3458 : 		{
; 3459 : //			int taxiPoint = GetPrevPtLoop(curTaxiPoint);
; 3460 : 			int taxiPoint = GetPrevTaxiPt(curTaxiPoint);	// 03JAN04 - FRB - Skip Parking spots

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _taxiPoint$7[ebp], eax

; 3461 : 			if (!taxiPoint)

	cmp	DWORD PTR _taxiPoint$7[ebp], 0
	jne	SHORT $LN52@SimpleGrou

; 3462 : 				taxiPoint = GetPrevPtLoop(curTaxiPoint);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _taxiPoint$7[ebp], eax
$LN52@SimpleGrou:

; 3463 : 			ObjectiveClass	*Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+312]
	push	eax
	mov	ecx, DWORD PTR [edx+308]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$3[ebp], eax

; 3464 : 
; 3465 : 			TranslatePointData(Airbase, taxiPoint, &tmpX, &tmpY);

	lea	edx, DWORD PTR _tmpY$[ebp]
	push	edx
	lea	eax, DWORD PTR _tmpX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _taxiPoint$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$3[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3466 : 			xft = tmpX - af->x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	subss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _xft$[ebp], xmm0

; 3467 : 			yft = tmpY - af->y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _yft$[ebp], xmm0

; 3468 : 			// get relative position and az
; 3469 : 			rx	= self->dmx[0][0] * xft + self->dmx[0][1] * yft;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 3470 : 			ry	= self->dmx[1][0] * xft + self->dmx[1][1] * yft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 3471 : 			if(gameCompressionRatio)

	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 0	; gameCompressionRatio
	je	SHORT $LN51@SimpleGrou

; 3472 : 				// JB 020315 Why divide by gameCompressionRation?  It screws up taxing for one thing.
; 3473 : 				rStick = SimpleTrackAzimuth(rx , ry, self->GetVt());///gameCompressionRatio;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z ; DigitalBrain::SimpleTrackAzimuth
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+32]

; 3474 : 			else

	jmp	SHORT $LN50@SimpleGrou
$LN51@SimpleGrou:

; 3475 : 				rStick = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+32], xmm0
$LN50@SimpleGrou:

; 3476 : 			pStick = 0.0F;			

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+28], xmm0
$LN53@SimpleGrou:

; 3477 : 		}
; 3478 : 		return FALSE;

	xor	eax, eax
	jmp	$LN66@SimpleGrou
$LN54@SimpleGrou:

; 3479 : 	}
; 3480 : 
; 3481 : 	// Cobra - "large" aircraft?
; 3482 : 	if (self->af->GetParkType() == LargeParkPt)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN49@SimpleGrou

; 3483 : 		BigBoy = true;

	mov	BYTE PTR _BigBoy$[ebp], 1
$LN49@SimpleGrou:

; 3484 : 
; 3485 : 	if(!self->OnGround())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN48@SimpleGrou

; 3486 : 		return FALSE;

	xor	eax, eax
	jmp	$LN66@SimpleGrou
$LN48@SimpleGrou:

; 3487 : 
; 3488 : 	// init the stick error
; 3489 : 	stickError = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _stickError$[ebp], xmm0

; 3490 : 	numOnLeft = 0;

	mov	DWORD PTR _numOnLeft$[ebp], 0

; 3491 : 	numOnRight = 0;

	mov	DWORD PTR _numOnRight$[ebp], 0

; 3492 : 
; 3493 : 	if ( self->drawPointer )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN47@SimpleGrou

; 3494 : 		myRad = self->drawPointer->Radius();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR _myRad$[ebp]

; 3495 : 	else

	jmp	SHORT $LN46@SimpleGrou
$LN47@SimpleGrou:

; 3496 : 		myRad = 40.0f;

	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR _myRad$[ebp], xmm0
$LN46@SimpleGrou:

; 3497 : 
; 3498 : 	// Cobra - Tell the big boys they are really not that big
; 3499 : 	if (BigBoy)

	movzx	edx, BYTE PTR _BigBoy$[ebp]
	test	edx, edx
	je	SHORT $LN45@SimpleGrou

; 3500 : 		myRad = 10.f;

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _myRad$[ebp], xmm0
$LN45@SimpleGrou:

; 3501 : 
; 3502 : 	// loop thru all sim objects
; 3503 : 	{
; 3504 : 		VuListIterator	unitWalker(SimDriver.objectList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A
	push	eax
	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3505 : 		testObject = (SimBaseClass*) unitWalker.GetFirst();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN73@SimpleGrou:

; 3506 : 		while (testObject){

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN43@SimpleGrou

; 3507 : 			// ignore objects under these conditions:
; 3508 : 			//		Ourself
; 3509 : 			//		Not on ground
; 3510 : 			if ( !testObject->OnGround() ||
; 3511 : 				testObject == self )

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN41@SimpleGrou
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _testObject$[ebp]
	cmp	edx, DWORD PTR [ecx+56]
	jne	SHORT $LN42@SimpleGrou
$LN41@SimpleGrou:

; 3512 : 			{
; 3513 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3514 : 				continue;

	jmp	SHORT $LN73@SimpleGrou
$LN42@SimpleGrou:

; 3515 : 			}
; 3516 : 
; 3517 : 			// range from us to object
; 3518 : 			tmpX = testObject->XPos() - af->x;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1390[ebp]
	movss	xmm0, DWORD PTR tv1390[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	subss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 3519 : 			tmpY = testObject->YPos() - af->y;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1395[ebp]
	movss	xmm0, DWORD PTR tv1395[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 3520 : 
; 3521 : 			// Cobra - if too far to be in the way, skip it
; 3522 : 			if ((tmpX*tmpX + tmpY*tmpY) > (200.f * 200.f))

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@471c4000
	jbe	SHORT $LN40@SimpleGrou

; 3523 : 			{
; 3524 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3525 : 				continue;

	jmp	$LN73@SimpleGrou
$LN40@SimpleGrou:

; 3526 : 			}
; 3527 : 
; 3528 : 			if ( testObject->drawPointer )

	mov	ecx, DWORD PTR _testObject$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN39@SimpleGrou

; 3529 : 				testRad = testObject->drawPointer->Radius() + myRad;

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv1405[ebp]
	movss	xmm0, DWORD PTR tv1405[ebp]
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0

; 3530 : 			else

	jmp	SHORT $LN38@SimpleGrou
$LN39@SimpleGrou:

; 3531 : 				testRad = 40.0f + myRad;

	movss	xmm0, DWORD PTR __real@42200000
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0
$LN38@SimpleGrou:

; 3532 : 
; 3533 : 			dist = (float)sqrt(tmpX*tmpX + tmpY*tmpY);

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3534 : 			float range = dist - testRad - MAX_RANGE_COLL;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _testRad$[ebp]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _range$10[ebp], xmm0

; 3535 : 
; 3536 : 			//rangeSquare = tmpX*tmpX + tmpY*tmpY - testRad * testRad - MAX_RANGE_SQ;
; 3537 : 			
; 3538 : 			// if object is greater than 2 x max range continue to next
; 3539 : 			//if ( rangeSquare > MAX_RANGE_SQ )
; 3540 : 			if(range > MAX_RANGE_COLL)	// MAX_RANGE_COLL = 20'

	movss	xmm0, DWORD PTR _range$10[ebp]
	comiss	xmm0, DWORD PTR __real@41a00000
	jbe	SHORT $LN37@SimpleGrou

; 3541 : 			{
; 3542 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3543 : 				continue;

	jmp	$LN73@SimpleGrou
$LN37@SimpleGrou:

; 3544 : 			}
; 3545 : 
; 3546 : 			// get relative position and az
; 3547 : 			rx	= self->dmx[0][0] * tmpX + self->dmx[0][1] * tmpY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 3548 : 			ry	= self->dmx[1][0] * tmpX + self->dmx[1][1] * tmpY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 3549 : 
; 3550 : 			az	= (float) atan2 (ry,rx);		

	cvtss2sd xmm0, DWORD PTR _rx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _az$[ebp]

; 3551 : 
; 3552 : 			// reject anything more than MAX_AZ deg off our nose
; 3553 : 			// Cobra - Restrict large a/c to narrow view
; 3554 : 			if ((BigBoy && (fabs(az) > 10.f*DTR)) ||
; 3555 : 					(fabs(az) > MAX_AZ))

	movzx	edx, BYTE PTR _BigBoy$[ebp]
	test	edx, edx
	je	SHORT $LN34@SimpleGrou
	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1441[ebp]
	movss	xmm0, DWORD PTR tv1441[ebp]
	comiss	xmm0, DWORD PTR __real@3e32b8c1
	ja	SHORT $LN35@SimpleGrou
$LN34@SimpleGrou:
	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1447[ebp]
	movss	xmm0, DWORD PTR tv1447[ebp]
	comiss	xmm0, DWORD PTR __real@3f9c61a9
	jbe	SHORT $LN36@SimpleGrou
$LN35@SimpleGrou:

; 3556 : 			{
; 3557 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3558 : 				continue;

	jmp	$LN73@SimpleGrou
$LN36@SimpleGrou:

; 3559 : 			}
; 3560 : 	/*
; 3561 : 			// Cobra - Skip a/c on parking spots
; 3562 : 			if (((AircraftClass*)testObject)->DBrain() && 
; 3563 : 					(((AircraftClass*)testObject)->DBrain()->GetTaxiPoint() == LargeParkPt ||
; 3564 : 					((AircraftClass*)testObject)->DBrain()->GetTaxiPoint() == SmallParkPt))
; 3565 : 			{
; 3566 : 				testObject = (SimBaseClass*) unitWalker.GetNext();
; 3567 : 				continue;
; 3568 : 			}
; 3569 : 	*/
; 3570 : 			if(rx > 0.0F && fabs(ry) > testRad && range < 0.0F && 
; 3571 : 				testObject->GetCampaignObject() == self->GetCampaignObject() && 
; 3572 : 				self->vehicleInUnit > ((AircraftClass*)testObject)->vehicleInUnit)

	movss	xmm0, DWORD PTR _rx$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN33@SimpleGrou
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1455[ebp]
	movss	xmm0, DWORD PTR tv1455[ebp]
	comiss	xmm0, DWORD PTR _testRad$[ebp]
	jbe	$LN33@SimpleGrou
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _range$10[ebp]
	jbe	$LN33@SimpleGrou
	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	esi, eax
	jne	$LN33@SimpleGrou
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	mov	ecx, DWORD PTR _testObject$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	eax, edx
	jle	$LN33@SimpleGrou

; 3573 : 			{
; 3574 : 				xft = trackX - af->x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+148]
	subss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _xft$[ebp], xmm0

; 3575 : 				yft = trackY - af->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR _yft$[ebp], xmm0

; 3576 : 				// get relative position and az
; 3577 : 				rx	= self->dmx[0][0] * xft + self->dmx[0][1] * yft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 3578 : 				ry	= self->dmx[1][0] * xft + self->dmx[1][1] * yft;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 3579 : 				if(rx < 10.0F)

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	$LN32@SimpleGrou

; 3580 : 				{
; 3581 : 	//				int taxiPoint = GetPrevPtLoop(curTaxiPoint);
; 3582 : 					int taxiPoint = GetPrevTaxiPt(curTaxiPoint);	// 03JAN04 - FRB - Skip Parking spots

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _taxiPoint$9[ebp], eax

; 3583 : 					if (!taxiPoint)

	cmp	DWORD PTR _taxiPoint$9[ebp], 0
	jne	SHORT $LN31@SimpleGrou

; 3584 : 						taxiPoint = GetPrevPtLoop(curTaxiPoint);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevPtLoop@@YAHH@Z			; GetPrevPtLoop
	add	esp, 4
	mov	DWORD PTR _taxiPoint$9[ebp], eax
$LN31@SimpleGrou:

; 3585 : 					ObjectiveClass	*Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$5[ebp], eax

; 3586 : 
; 3587 : 					TranslatePointData(Airbase, taxiPoint, &tmpX, &tmpY);

	lea	eax, DWORD PTR _tmpY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _taxiPoint$9[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$5[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3588 : 					xft = tmpX - af->x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR _tmpX$[ebp]
	subss	xmm0, DWORD PTR [edx+1108]
	movss	DWORD PTR _xft$[ebp], xmm0

; 3589 : 					yft = tmpY - af->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR _tmpY$[ebp]
	subss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR _yft$[ebp], xmm0

; 3590 : 					// get relative position and az
; 3591 : 					rx	= self->dmx[0][0] * xft + self->dmx[0][1] * yft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 3592 : 					ry	= self->dmx[1][0] * xft + self->dmx[1][1] * yft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 3593 : 					if(gameCompressionRatio)

	cmp	DWORD PTR ?gameCompressionRatio@@3HA, 0	; gameCompressionRatio
	je	SHORT $LN30@SimpleGrou

; 3594 : 						// JB 020315 Why divide by gameCompressionRation?  It screws up taxing for one thing.
; 3595 : 						rStick = SimpleTrackAzimuth(rx , ry, self->GetVt());///gameCompressionRatio;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z ; DigitalBrain::SimpleTrackAzimuth
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]

; 3596 : 					else

	jmp	SHORT $LN29@SimpleGrou
$LN30@SimpleGrou:

; 3597 : 						rStick = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+32], xmm0
$LN29@SimpleGrou:

; 3598 : 					pStick = 0.0F;		

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+28], xmm0

; 3599 : 					throtl = SimpleGroundTrackSpeed(0.0F);	

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrackSpeed@DigitalBrain@@IAEMM@Z ; DigitalBrain::SimpleGroundTrackSpeed
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+40]

; 3600 : 				}
; 3601 : 				else

	jmp	SHORT $LN28@SimpleGrou
$LN32@SimpleGrou:

; 3602 : 					TrackPoint(0.0f, speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)
$LN28@SimpleGrou:

; 3603 : 				return TRUE;

	mov	DWORD PTR $T2[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN66@SimpleGrou
$LN33@SimpleGrou:

; 3604 : 			}
; 3605 : 
; 3606 : 			if ( fabs(az) < fabs(minAz) )

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1555[ebp]
	movss	xmm0, DWORD PTR tv1555[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _minAz$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv1700[ebp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1561[ebp]
	movss	xmm0, DWORD PTR tv1561[ebp]
	movss	xmm1, DWORD PTR tv1700[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN27@SimpleGrou

; 3607 : 			{
; 3608 : 				minAz = az;

	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR _minAz$[ebp], xmm0
$LN27@SimpleGrou:

; 3609 : 			}
; 3610 : 			// have we reached a situation where it's impossible to
; 3611 : 			// move forward without colliding?
; 3612 : 			if ( fabs(az) < 80.0F*DTR && rx > 5.0f && rx < testRad*1.5F && fabs( ry ) < testRad*1.25F )

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1568[ebp]
	movss	xmm0, DWORD PTR __real@3fb2b8c1
	comiss	xmm0, DWORD PTR tv1568[ebp]
	jbe	$LN26@SimpleGrou
	movss	xmm0, DWORD PTR _rx$[ebp]
	comiss	xmm0, DWORD PTR __real@40a00000
	jbe	SHORT $LN26@SimpleGrou
	movss	xmm0, DWORD PTR _testRad$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	SHORT $LN26@SimpleGrou
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1577[ebp]
	movss	xmm0, DWORD PTR _testRad$[ebp]
	mulss	xmm0, DWORD PTR __real@3fa00000
	comiss	xmm0, DWORD PTR tv1577[ebp]
	jbe	SHORT $LN26@SimpleGrou

; 3613 : 			{
; 3614 : 				// count the number of blocks to our left and right
; 3615 : 				// to be used later
; 3616 : 				if ( ry > 0.0f )

	movss	xmm0, DWORD PTR _ry$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN25@SimpleGrou

; 3617 : 					numOnRight++;

	mov	edx, DWORD PTR _numOnRight$[ebp]
	add	edx, 1
	mov	DWORD PTR _numOnRight$[ebp], edx

; 3618 : 				else

	jmp	SHORT $LN24@SimpleGrou
$LN25@SimpleGrou:

; 3619 : 					numOnLeft++;

	mov	eax, DWORD PTR _numOnLeft$[ebp]
	add	eax, 1
	mov	DWORD PTR _numOnLeft$[ebp], eax
$LN24@SimpleGrou:

; 3620 : 
; 3621 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3622 : 				continue;

	jmp	$LN73@SimpleGrou
$LN26@SimpleGrou:

; 3623 : 			}
; 3624 : 
; 3625 : 			// OK, we've got an object in front of our 3-6 line and
; 3626 : 			// within range.  The potential field will work by deflecting
; 3627 : 			// our nose (rstick).  The closer the object and the more towards
; 3628 : 			// our nose, the stronger is the deflection
; 3629 : 
; 3630 : 			
; 3631 : 			if ( az > 0.0f )

	movss	xmm0, DWORD PTR _az$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN23@SimpleGrou

; 3632 : 				azErr = -1.0F + ry/dist;

	movss	xmm0, DWORD PTR _ry$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	addss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _azErr$[ebp], xmm0
	jmp	SHORT $LN18@SimpleGrou
$LN23@SimpleGrou:

; 3633 : 			else if ( az < 0.0f )

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _az$[ebp]
	jbe	SHORT $LN21@SimpleGrou

; 3634 : 				azErr = 1.0F + ry/dist;

	movss	xmm0, DWORD PTR _ry$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _azErr$[ebp], xmm0
	jmp	SHORT $LN18@SimpleGrou
$LN21@SimpleGrou:

; 3635 : 			else if ( rStick > 0.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@SimpleGrou

; 3636 : 				azErr = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _azErr$[ebp], xmm0

; 3637 : 			else

	jmp	SHORT $LN18@SimpleGrou
$LN19@SimpleGrou:

; 3638 : 				azErr = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _azErr$[ebp], xmm0
$LN18@SimpleGrou:

; 3639 : 
; 3640 : 			// this deflection is now modulated by the proximity -- the closer
; 3641 : 			// the stronger the force
; 3642 : 			// weight the range higher
; 3643 : 			azErr *= ( MAX_RANGE_COLL  - range ) / (MAX_RANGE_COLL * 0.4F);

	movss	xmm0, DWORD PTR __real@41a00000
	subss	xmm0, DWORD PTR _range$10[ebp]
	divss	xmm0, DWORD PTR __real@41000000
	mulss	xmm0, DWORD PTR _azErr$[ebp]
	movss	DWORD PTR _azErr$[ebp], xmm0

; 3644 : 
; 3645 : 			// now accumulate the stick error
; 3646 : 			stickError += azErr;

	movss	xmm0, DWORD PTR _stickError$[ebp]
	addss	xmm0, DWORD PTR _azErr$[ebp]
	movss	DWORD PTR _stickError$[ebp], xmm0

; 3647 : 
; 3648 : 
; 3649 : 			testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3650 : 		}

	jmp	$LN73@SimpleGrou
$LN43@SimpleGrou:

; 3651 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 3652 : 	//===================================
; 3653 : 
; 3654 : 	// test blockages directly in front
; 3655 : 	// cheat: if we get stuck just rotate in place
; 3656 : 	if( (numOnLeft || numOnRight) && fabs(minAz) > 70.0f * DTR)

	cmp	DWORD PTR _numOnLeft$[ebp], 0
	jne	SHORT $LN16@SimpleGrou
	cmp	DWORD PTR _numOnRight$[ebp], 0
	je	SHORT $LN17@SimpleGrou
$LN16@SimpleGrou:
	push	ecx
	movss	xmm0, DWORD PTR _minAz$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1602[ebp]
	movss	xmm0, DWORD PTR tv1602[ebp]
	comiss	xmm0, DWORD PTR __real@3f9c61a9
	jbe	SHORT $LN17@SimpleGrou

; 3657 : 	{
; 3658 : 		rStick = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+32], xmm0

; 3659 : 		pStick = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+28], xmm0

; 3660 : 		throtl *= 0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+40], xmm0

; 3661 : 		tiebreaker = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+956], 0
	jmp	$LN5@SimpleGrou
$LN17@SimpleGrou:

; 3662 : 	}
; 3663 : 	else if (tiebreaker > 10) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+956], 10			; 0000000aH
	jle	$LN14@SimpleGrou

; 3664 : 	{
; 3665 : 		af->sigma -= 10.0f * DTR * SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR [eax+1176]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	DWORD PTR [edx+1176], xmm1

; 3666 : 		af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3667 : 		throtl = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 3668 : 		if (tiebreaker ++ - 10 > rand() % 20)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR tv942[ebp], eax
	call	_rand
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv943[ebp], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+956], eax
	mov	edx, DWORD PTR tv942[ebp]
	cmp	edx, DWORD PTR tv943[ebp]
	jle	SHORT $LN13@SimpleGrou

; 3669 : 			tiebreaker = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+956], 0
$LN13@SimpleGrou:

; 3670 : 		return TRUE;

	mov	eax, 1
	jmp	$LN66@SimpleGrou
	jmp	$LN5@SimpleGrou
$LN14@SimpleGrou:

; 3671 : 	}
; 3672 : 	else if ( numOnLeft && numOnRight )

	cmp	DWORD PTR _numOnLeft$[ebp], 0
	je	$LN11@SimpleGrou
	cmp	DWORD PTR _numOnRight$[ebp], 0
	je	$LN11@SimpleGrou

; 3673 : 	{
; 3674 : 		if(fabs(minAz) > 50.0f * DTR)

	push	ecx
	movss	xmm0, DWORD PTR _minAz$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1636[ebp]
	movss	xmm0, DWORD PTR tv1636[ebp]
	comiss	xmm0, DWORD PTR __real@3f5f66f1
	jbe	SHORT $LN10@SimpleGrou

; 3675 : 		{
; 3676 : 			rStick = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+32], xmm0

; 3677 : 			pStick = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+28], xmm0

; 3678 : 			throtl *= 0.5f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+40], xmm0

; 3679 : 		}
; 3680 : 		else

	jmp	SHORT $LN9@SimpleGrou
$LN10@SimpleGrou:

; 3681 : 		{
; 3682 : 			af->sigma -= 10.0f * DTR * SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR [eax+1176]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	DWORD PTR [edx+1176], xmm1

; 3683 : 			af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3684 : 			throtl = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0
$LN9@SimpleGrou:

; 3685 : 		}
; 3686 : 		tiebreaker ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+956], eax

; 3687 : 		return TRUE;

	mov	eax, 1
	jmp	$LN66@SimpleGrou
	jmp	$LN5@SimpleGrou
$LN11@SimpleGrou:

; 3688 : 	}
; 3689 : 	else if ( numOnRight )

	cmp	DWORD PTR _numOnRight$[ebp], 0
	je	SHORT $LN7@SimpleGrou

; 3690 : 	{
; 3691 : 		af->sigma -= 10.0f * DTR * SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR [eax+1176]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	DWORD PTR [edx+1176], xmm1

; 3692 : 		af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3693 : 		throtl = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 3694 : 		tiebreaker ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+956], eax

; 3695 : 		return TRUE;

	mov	eax, 1
	jmp	$LN66@SimpleGrou
	jmp	SHORT $LN5@SimpleGrou
$LN7@SimpleGrou:

; 3696 : 	}
; 3697 : 	else if ( numOnLeft )

	cmp	DWORD PTR _numOnLeft$[ebp], 0
	je	SHORT $LN5@SimpleGrou

; 3698 : 	{
; 3699 : 		af->sigma += 10.0f * DTR * SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	addss	xmm0, DWORD PTR [eax+1176]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	DWORD PTR [edx+1176], xmm0

; 3700 : 		af->SetFlag(AirframeClass::WheelBrakes);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3701 : 		throtl = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0

; 3702 : 		tiebreaker ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+956], eax

; 3703 : 		return TRUE;

	mov	eax, 1
	jmp	$LN66@SimpleGrou
$LN5@SimpleGrou:

; 3704 : 	}
; 3705 : 	tiebreaker = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+956], 0

; 3706 : 	// we now apply the stick error to rstick
; 3707 : 	// make sure we clamp rstick
; 3708 : 	rStick += stickError;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR _stickError$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32], xmm0

; 3709 : 	if ( rStick > 1.0f )

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN4@SimpleGrou

; 3710 : 		rStick = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+32], xmm0
	jmp	SHORT $LN2@SimpleGrou
$LN4@SimpleGrou:

; 3711 : 	else if ( rStick < -1.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR [ecx+32]
	jbe	SHORT $LN2@SimpleGrou

; 3712 : 		rStick = -1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+32], xmm0
$LN2@SimpleGrou:

; 3713 : 
; 3714 : 	// readjust throttle if our stick error is large
; 3715 : 	if ( fabs( stickError ) > 0.5f )

	push	ecx
	movss	xmm0, DWORD PTR _stickError$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1691[ebp]
	movss	xmm0, DWORD PTR tv1691[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN1@SimpleGrou

; 3716 : 	{
; 3717 : 		throtl = SimpleGroundTrackSpeed(speed * 0.75f); // speed = desired speed (ft/sec)	

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f400000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrackSpeed@DigitalBrain@@IAEMM@Z ; DigitalBrain::SimpleGroundTrackSpeed
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+40]
$LN1@SimpleGrou:

; 3718 : 	}
; 3719 : 
; 3720 : 	return FALSE;

	xor	eax, eax
$LN66@SimpleGrou:

; 3721 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z$0:
	lea	ecx, DWORD PTR _unitWalker$6[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-192]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SimpleGroundTrack@DigitalBrain@@IAEHM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ENDP		; DigitalBrain::SimpleGroundTrack
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_gridIt$ = -156						; size = 60
tv347 = -96						; size = 4
tv384 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
_unitWalker$4 = -80					; size = 12
_campBase$ = -68					; size = 4
_rangeSquare$ = -64					; size = 4
_testObject$ = -60					; size = 4
_this$ = -56						; size = 4
_org$ = -52						; size = 12
_vec$ = -40						; size = 12
_pos$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CheckTaxiCollision@DigitalBrain@@IAEHXZ PROC		; DigitalBrain::CheckTaxiCollision
; _this$ = ecx

; 3278 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckTaxiCollision@DigitalBrain@@IAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3279 : 	Tpoint org, pos, vec;
; 3280 : 	float rangeSquare;
; 3281 : 	SimBaseClass* testObject;
; 3282 : 	CampBaseClass* campBase;
; 3283 : 	#ifdef VU_GRID_TREE_Y_MAJOR
; 3284 : 	VuGridIterator gridIt(RealUnitProxList, af->y, af->x, NM_TO_FT * 3.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@468e6944
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?RealUnitProxList@@3PAVVuGridTree@@A ; RealUnitProxList
	push	ecx
	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3285 : 	#else
; 3286 : 	VuGridIterator gridIt(RealUnitProxList, af->x, af->y, NM_TO_FT * 3.0F);
; 3287 : 	#endif
; 3288 : 
; 3289 : 
; 3290 : 	// Cobra - No on-ground collisions for "large" aircraft.
; 3291 : //	if (self->af->GetParkType() == LargeParkPt)
; 3292 : //		return FALSE;
; 3293 : 
; 3294 : 	// get the 1st objective that contains the bomb
; 3295 :     campBase = (CampBaseClass*) gridIt.GetFirst();

	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _campBase$[ebp], eax
$LN15@CheckTaxiC:

; 3296 : 
; 3297 : 	// main loop through campaign units
; 3298 : 	while ( campBase )

	cmp	DWORD PTR _campBase$[ebp], 0
	je	$LN9@CheckTaxiC

; 3299 : 	{
; 3300 : 		// skip campaign unit if no sim components
; 3301 : 		if (!campBase->GetComponents())

	mov	ecx, DWORD PTR _campBase$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	jne	SHORT $LN8@CheckTaxiC

; 3302 : 		{
; 3303 : 			campBase = (CampBaseClass*) gridIt.GetNext();

	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _campBase$[ebp], eax

; 3304 : 			continue;

	jmp	SHORT $LN15@CheckTaxiC
$LN8@CheckTaxiC:

; 3305 : 		}
; 3306 : 		// loop thru each element in the objective
; 3307 : 		VuListIterator	unitWalker(campBase->GetComponents());

	mov	ecx, DWORD PTR _campBase$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3308 : 		testObject = (SimBaseClass*) unitWalker.GetFirst();

	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN17@CheckTaxiC:

; 3309 : 		while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN6@CheckTaxiC

; 3310 : 		{
; 3311 : 			// ignore objects under these conditions:
; 3312 : 			//		Ourself
; 3313 : 			//		Not on ground
; 3314 : 			//		no drawpointer
; 3315 : 			if ( !testObject->OnGround() ||
; 3316 : 				 testObject == self ||
; 3317 : 				 !testObject->drawPointer )

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN4@CheckTaxiC
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _testObject$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN4@CheckTaxiC
	mov	edx, DWORD PTR _testObject$[ebp]
	cmp	DWORD PTR [edx+332], 0
	jne	SHORT $LN5@CheckTaxiC
$LN4@CheckTaxiC:

; 3318 : 			{
; 3319 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3320 : 				continue;

	jmp	SHORT $LN17@CheckTaxiC
$LN5@CheckTaxiC:

; 3321 : 			}
; 3322 : 
; 3323 : 			// range from tracking point to object
; 3324 : 			pos.x = testObject->XPos() - af->x;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv347[ebp]
	movss	xmm0, DWORD PTR tv347[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	subss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _pos$[ebp], xmm0

; 3325 : 			pos.y = testObject->YPos() - af->y;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv384[ebp]
	movss	xmm0, DWORD PTR tv384[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _pos$[ebp+4], xmm0

; 3326 : 			rangeSquare = pos.x*pos.x + pos.y*pos.y;

	movss	xmm0, DWORD PTR _pos$[ebp]
	mulss	xmm0, DWORD PTR _pos$[ebp]
	movss	xmm1, DWORD PTR _pos$[ebp+4]
	mulss	xmm1, DWORD PTR _pos$[ebp+4]
	addss	xmm0, xmm1
	movss	DWORD PTR _rangeSquare$[ebp], xmm0

; 3327 : 
; 3328 : 			// if object is greater than given range don't check
; 3329 : 			// also, perhaps a degenerate case, if too close and overlapping
; 3330 : 			if ( rangeSquare > 80.0f * 80.0f || rangeSquare < 10.0f * 10.0f )

	movss	xmm0, DWORD PTR _rangeSquare$[ebp]
	comiss	xmm0, DWORD PTR __real@45c80000
	ja	SHORT $LN2@CheckTaxiC
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _rangeSquare$[ebp]
	jbe	SHORT $LN3@CheckTaxiC
$LN2@CheckTaxiC:

; 3331 : 			{
; 3332 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3333 : 				continue;

	jmp	$LN17@CheckTaxiC
$LN3@CheckTaxiC:

; 3334 : 			}
; 3335 : 
; 3336 : 			// origin of ray
; 3337 : 			rangeSquare = self->drawPointer->Radius();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR _rangeSquare$[ebp]

; 3338 : 			org.x = af->x + self->dmx[0][0] * rangeSquare * 1.1f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _rangeSquare$[ebp]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	addss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _org$[ebp], xmm0

; 3339 : 			org.y = af->y + self->dmx[0][1] * rangeSquare * 1.1f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _rangeSquare$[ebp]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	addss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR _org$[ebp+4], xmm0

; 3340 : 			org.z = af->z + self->dmx[0][2] * rangeSquare * 1.1f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [eax+edx+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _rangeSquare$[ebp]
	mulss	xmm0, DWORD PTR __real@3f8ccccd
	addss	xmm0, DWORD PTR [ecx+1116]
	movss	DWORD PTR _org$[ebp+8], xmm0

; 3341 : 
; 3342 : 			// vector of ray
; 3343 : 			vec.x = self->dmx[0][0] * 80.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR _vec$[ebp], xmm0

; 3344 : 			vec.y = self->dmx[0][1] * 80.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR _vec$[ebp+4], xmm0

; 3345 : 			vec.z = self->dmx[0][2] * 80.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR _vec$[ebp+8], xmm0

; 3346 : 
; 3347 : 			// do ray, box intersection test
; 3348 : 		    if ( testObject->drawPointer->GetRayHit( &org, &vec, &pos, 1.0f ) )

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _org$[ebp]
	push	edx
	mov	eax, DWORD PTR _testObject$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	mov	edx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+332]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	test	eax, eax
	je	SHORT $LN1@CheckTaxiC

; 3349 : 			{
; 3350 : 				return TRUE;

	mov	DWORD PTR $T3[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN11@CheckTaxiC
$LN1@CheckTaxiC:

; 3351 : 			}
; 3352 : 
; 3353 : 			testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 3354 : 		}

	jmp	$LN17@CheckTaxiC
$LN6@CheckTaxiC:

; 3355 : 
; 3356 : 		// get the next objective that contains the bomb
; 3357 : 		campBase = (CampBaseClass*) gridIt.GetNext();

	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _campBase$[ebp], eax

; 3358 : 
; 3359 : 	} // end objective loop

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	jmp	$LN15@CheckTaxiC
$LN9@CheckTaxiC:

; 3360 : 
; 3361 : 	return FALSE;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	eax, DWORD PTR $T2[ebp]
$LN11@CheckTaxiC:

; 3362 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckTaxiCollision@DigitalBrain@@IAEHXZ$0:
	lea	ecx, DWORD PTR _gridIt$[ebp]
	jmp	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
__unwindfunclet$?CheckTaxiCollision@DigitalBrain@@IAEHXZ$1:
	lea	ecx, DWORD PTR _unitWalker$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?CheckTaxiCollision@DigitalBrain@@IAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckTaxiCollision@DigitalBrain@@IAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckTaxiCollision@DigitalBrain@@IAEHXZ ENDP		; DigitalBrain::CheckTaxiCollision
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CheckPoint@DigitalBrain@@IAEPAVSimBaseClass@@MM@Z PROC	; DigitalBrain::CheckPoint
; _this$ = ecx

; 3265 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3266 : 	return CheckTaxiPointGlobal(self,x,y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z ; CheckTaxiPointGlobal
	add	esp, 12					; 0000000cH

; 3267 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CheckPoint@DigitalBrain@@IAEPAVSimBaseClass@@MM@Z ENDP	; DigitalBrain::CheckPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ PROC ; DigitalBrain::CheckTaxiTrackPoint
; _this$ = ecx

; 3260 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3261 : 	return CheckPoint (trackX, trackY);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+152]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+148]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckPoint@DigitalBrain@@IAEPAVSimBaseClass@@MM@Z ; DigitalBrain::CheckPoint

; 3262 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ENDP ; DigitalBrain::CheckTaxiTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_tx$1 = -32						; size = 4
_ty$2 = -28						; size = 4
tv254 = -24						; size = 4
tv245 = -20						; size = 4
_tx$3 = -16						; size = 4
_ty$4 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_Airbase$ = 8						; size = 4
?TaxiBack@DigitalBrain@@IAEXPAVObjectiveClass@@@Z PROC	; DigitalBrain::TaxiBack
; _this$ = ecx

; 2806 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2807 : 	if(atcstatus != lTaxiOff){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 14			; 0000000eH
	je	SHORT $LN11@TaxiBack

; 2808 : 		atcstatus = lTaxiOff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 14			; 0000000eH

; 2809 : 		SendATCMsg(noATC);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN11@TaxiBack:

; 2810 : 	}
; 2811 : 
; 2812 : 	switch(PtDataTable[curTaxiPoint].type){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	dl, BYTE PTR [ecx+eax+8]
	mov	BYTE PTR tv75[ebp], dl
	cmp	BYTE PTR tv75[ebp], 0
	jbe	$LN9@TaxiBack
	cmp	BYTE PTR tv75[ebp], 2
	jbe	SHORT $LN8@TaxiBack
	cmp	BYTE PTR tv75[ebp], 15			; 0000000fH
	je	SHORT $LN8@TaxiBack
	jmp	SHORT $LN9@TaxiBack
$LN8@TaxiBack:

; 2813 : 		case TakeRunwayPt:
; 2814 : 		case TakeoffPt:
; 2815 : 		case RunwayPt:
; 2816 : 			if(curTaxiPoint){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN7@TaxiBack

; 2817 : 				SetTaxiPoint(GetNextTaxiPt(curTaxiPoint));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2818 : 				float tx, ty;
; 2819 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2820 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$3[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2821 : 				OffsetTrackPoint(120.0F, offRight);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@42f00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN7@TaxiBack:
$LN9@TaxiBack:

; 2822 : 			}
; 2823 : 		break;
; 2824 : 	}
; 2825 : 
; 2826 : 	if (fabs(trackX - af->x) < TAXI_CHECK_DIST && fabs(trackY - af->y) < TAXI_CHECK_DIST ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+148]
	subss	xmm0, DWORD PTR [eax+1108]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv245[ebp]
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR tv245[ebp]
	jbe	$LN5@TaxiBack
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR [eax+1112]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv254[ebp]
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR tv254[ebp]
	jbe	SHORT $LN5@TaxiBack

; 2827 : 		SetTaxiPoint(GetNextTaxiPt(curTaxiPoint));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 2828 : 		if(curTaxiPoint){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN5@TaxiBack

; 2829 : 			float tx, ty;
; 2830 : 			TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$2[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2831 : 			SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 2832 : 			OffsetTrackPoint(120.0F, offRight);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@42f00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN5@TaxiBack:

; 2833 : 		}
; 2834 : 	}
; 2835 : 
; 2836 : 	if (self != SimDriver.GetPlayerEntity()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	je	SHORT $LN3@TaxiBack

; 2837 : 		if(!curTaxiPoint || PtDataTable[curTaxiPoint].flags & PT_LAST){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN2@TaxiBack
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+9]
	and	eax, 2
	je	SHORT $LN3@TaxiBack
$LN2@TaxiBack:

; 2838 : 			// 02JAN04 - FRB - Make parking spot available for others
; 2839 : 			PtDataTable[curTaxiPoint].flags &= ~PT_OCCUPIED;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+9]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [edx+eax+9], cl

; 2840 : 			RegroupAircraft(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4
$LN3@TaxiBack:

; 2841 : 		}
; 2842 : 	}
; 2843 : 
; 2844 : 	if (CheckTaxiTrackPoint()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	test	eax, eax
	je	SHORT $LN1@TaxiBack

; 2845 : 		OffsetTrackPoint(80.0F, offRight);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN1@TaxiBack:

; 2846 : 	}
; 2847 : 	CalculateTaxiSpeed(10.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 2848 : 	SimpleGroundTrack( desiredSpeed );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 2849 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TaxiBack@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ENDP	; DigitalBrain::TaxiBack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?QuickPreFlight@DigitalBrain@@IAEXXZ PROC		; DigitalBrain::QuickPreFlight
; _this$ = ecx

; 4087 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4088 :     ShiAssert(af != NULL && self != NULL);
; 4089 :     self->PreFlight();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?PreFlight@AircraftClass@@QAEXXZ	; AircraftClass::PreFlight

; 4090 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?QuickPreFlight@DigitalBrain@@IAEXXZ ENDP		; DigitalBrain::QuickPreFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
tv71 = -12						; size = 4
_theRadar$1 = -8					; size = 4
_this$ = -4						; size = 4
?PreFlight@DigitalBrain@@IAEHXZ PROC			; DigitalBrain::PreFlight
; _this$ = ecx

; 3934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3935 :     ShiAssert(af != NULL);
; 3936 :     if (SimLibElapsedTime < mNextPreflightAction) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	ecx, DWORD PTR [eax+908]
	jae	SHORT $LN40@PreFlight
	xor	eax, eax
	jmp	$LN41@PreFlight
$LN40@PreFlight:

; 3937 :     
; 3938 :     switch (PreFlightTable[mActionIndex].action) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax]
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 15			; 0000000fH
	ja	$LN3@PreFlight
	mov	edx, DWORD PTR tv71[ebp]
	jmp	DWORD PTR $LN43@PreFlight[edx*4]
$LN37@PreFlight:

; 3939 :     case PreflightActions::FNX:
; 3940 : 	if ((*PreFlightTable[mActionIndex].fnx)(self) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+12]
	call	ecx
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN36@PreFlight

; 3941 : 	    return 0;

	xor	eax, eax
	jmp	$LN41@PreFlight
$LN36@PreFlight:

; 3942 : 	mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+8]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], ecx

; 3943 : 	break;

	jmp	$LN38@PreFlight
$LN35@PreFlight:

; 3944 : 	
; 3945 :     case PreflightActions::CANOPY:
; 3946 : 		if (!af->canopyState) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movzx	edx, BYTE PTR [ecx+1588]
	test	edx, edx
	jne	SHORT $LN34@PreFlight

; 3947 : 			af->canopyState = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	BYTE PTR [ecx+1588], 1

; 3948 : 			mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+8]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], ecx
$LN34@PreFlight:

; 3949 : 		}
; 3950 : 		break;

	jmp	$LN38@PreFlight
$LN33@PreFlight:

; 3951 :     case PreflightActions::FUEL1:
; 3952 : 	if (af->IsEngineFlag(AirframeClass::MasterFuelOff)) {

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	je	SHORT $LN32@PreFlight

; 3953 : 	    af->ClearEngineFlag(AirframeClass::MasterFuelOff);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 3954 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+8]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], ecx
$LN32@PreFlight:

; 3955 : 	}
; 3956 : 	break;

	jmp	$LN38@PreFlight
$LN31@PreFlight:

; 3957 :     case PreflightActions::MAINPOWER:
; 3958 : 	if (self->MainPower() != AircraftClass::MainPowerMain) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ; AircraftClass::MainPower
	cmp	eax, 2
	je	SHORT $LN30@PreFlight

; 3959 : 	    self->IncMainPower();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IncMainPower@AircraftClass@@QAEXXZ	; AircraftClass::IncMainPower

; 3960 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+8]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], ecx

; 3961 : 	    return 0; //keep clicking til we get to the right state

	xor	eax, eax
	jmp	$LN41@PreFlight
$LN30@PreFlight:

; 3962 : 	}
; 3963 : 	break;

	jmp	$LN38@PreFlight
$LN29@PreFlight:

; 3964 :     case PreflightActions::FUEL2:
; 3965 : 	af->SetFuelPump(AirframeClass::FP_NORM);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFuelPump@AirframeClass@@QAEXW4FuelPump@1@@Z ; AirframeClass::SetFuelPump

; 3966 : 	af->SetFuelSwitch(AirframeClass::FS_NORM);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?SetFuelSwitch@AirframeClass@@QAEXW4FuelSwitch@1@@Z ; AirframeClass::SetFuelSwitch

; 3967 : 	af->ClearEngineFlag(AirframeClass::WingFirst);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?ClearEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::ClearEngineFlag

; 3968 : 	af->SetAirSource(AirframeClass::AS_NORM);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetAirSource@AirframeClass@@QAEXW4AirSource@1@@Z ; AirframeClass::SetAirSource

; 3969 : 	mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	mov	eax, DWORD PTR _PreFlightTable[edx+8]
	imul	eax, 1000				; 000003e8H
	add	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], eax

; 3970 : 	break;

	jmp	$LN38@PreFlight
$LN28@PreFlight:

; 3971 :     case PreflightActions::RALTON:
; 3972 : 	if (self->RALTStatus == AircraftClass::RaltStatus::ROFF) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	cmp	DWORD PTR [eax+1004], 0
	jne	SHORT $LN27@PreFlight

; 3973 : 	    self->RaltOn();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?RaltOn@AircraftClass@@QAEXXZ		; AircraftClass::RaltOn

; 3974 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+8]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], ecx
$LN27@PreFlight:

; 3975 : 	}
; 3976 : 	break;

	jmp	$LN38@PreFlight
$LN26@PreFlight:

; 3977 :     case PreflightActions::AFFLAGS:
; 3978 : 	if (!af->IsSet(PreFlightTable[mActionIndex].data)) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN25@PreFlight

; 3979 : 	    af->SetFlag(PreFlightTable[mActionIndex].data);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	mov	eax, DWORD PTR _PreFlightTable[edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 3980 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+8]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], ecx
$LN25@PreFlight:

; 3981 : 	}
; 3982 : 	break;

	jmp	$LN38@PreFlight
$LN24@PreFlight:

; 3983 :     case PreflightActions::POWERON:
; 3984 : 	if (!self->PowerSwitchOn((AircraftClass::AvionicsPowerFlags)PreFlightTable[mActionIndex].data)) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?PowerSwitchOn@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerSwitchOn
	test	eax, eax
	jne	$LN23@PreFlight

; 3985 : 	    self->PowerOn((AircraftClass::AvionicsPowerFlags)PreFlightTable[mActionIndex].data);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	mov	eax, DWORD PTR _PreFlightTable[edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?PowerOn@AircraftClass@@QAEXW4AvionicsPowerFlags@1@@Z ; AircraftClass::PowerOn

; 3986 : 		//MI additional check for HUD, now that the dial indicates the status
; 3987 : 		if(PreFlightTable[mActionIndex].data == AircraftClass::HUDPower)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	cmp	DWORD PTR _PreFlightTable[eax+4], 2048	; 00000800H
	jne	SHORT $LN21@PreFlight

; 3988 : 		{
; 3989 : 			if(TheHud && self == SimDriver.GetPlayerEntity())

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN21@PreFlight
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	jne	SHORT $LN21@PreFlight

; 3990 : 				TheHud->SymWheelPos = 1.0F;

	mov	edx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+5136], xmm0
$LN21@PreFlight:

; 3991 : 		}
; 3992 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+8]
	imul	edx, 1000				; 000003e8H
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+908], edx
$LN23@PreFlight:

; 3993 : 	}
; 3994 : 	break;

	jmp	$LN38@PreFlight
$LN20@PreFlight:

; 3995 :     case PreflightActions::RADAR:
; 3996 : 	{
; 3997 : 	    RadarClass* theRadar = (RadarClass*) FindSensor (self, SensorClass::Radar);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$1[ebp], eax

; 3998 : 	    if (theRadar)

	cmp	DWORD PTR _theRadar$1[ebp], 0
	je	SHORT $LN19@PreFlight

; 3999 : 		theRadar->SetMode (RadarClass::AA);

	push	18					; 00000012H
	mov	eax, DWORD PTR _theRadar$1[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _theRadar$1[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
$LN19@PreFlight:

; 4000 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	mov	eax, DWORD PTR _PreFlightTable[edx+8]
	imul	eax, 1000				; 000003e8H
	add	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], eax

; 4001 : 	}
; 4002 : 	break;

	jmp	$LN38@PreFlight
$LN18@PreFlight:

; 4003 : 	case PreflightActions::SEAT:
; 4004 : 	{
; 4005 : 		self->SeatArmed = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	BYTE PTR [eax+1052], 1

; 4006 : 		mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	mov	eax, DWORD PTR _PreFlightTable[edx+8]
	imul	eax, 1000				; 000003e8H
	add	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], eax

; 4007 : 	}
; 4008 : 	break;

	jmp	$LN38@PreFlight
$LN17@PreFlight:

; 4009 : 	case PreflightActions::EWSPGM:
; 4010 : 	{
; 4011 : 		self->SetPGM(AircraftClass::EWSPGMSwitch::Man);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SetPGM@AircraftClass@@QAEXW4EWSPGMSwitch@1@@Z ; AircraftClass::SetPGM

; 4012 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+8]
	imul	edx, 1000				; 000003e8H
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+908], edx

; 4013 : 	}
; 4014 : 	break;

	jmp	$LN38@PreFlight
$LN16@PreFlight:

; 4015 : 	case PreflightActions::MASTERARM:
; 4016 : 	{
; 4017 : 		self->Sms->SetMasterArm(SMSBaseClass::Arm);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+940]
	call	?SetMasterArm@SMSBaseClass@@QAEXW4MasterArmState@1@@Z ; SMSBaseClass::SetMasterArm

; 4018 : 		mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+8]
	imul	edx, 1000				; 000003e8H
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+908], edx

; 4019 : 	}
; 4020 : 	break;

	jmp	$LN38@PreFlight
$LN15@PreFlight:

; 4021 : 	case PreflightActions::EXTLON:
; 4022 : 	if (!self->ExtlState((AircraftClass::ExtlLightFlags)PreFlightTable[mActionIndex].data)) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	mov	eax, DWORD PTR _PreFlightTable[edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ExtlState@AircraftClass@@QBEHW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlState
	test	eax, eax
	jne	SHORT $LN14@PreFlight

; 4023 : 	    self->ExtlOn((AircraftClass::ExtlLightFlags)PreFlightTable[mActionIndex].data);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ExtlOn@AircraftClass@@QAEXW4ExtlLightFlags@1@@Z ; AircraftClass::ExtlOn

; 4024 : 	    mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+8]
	imul	edx, 1000				; 000003e8H
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+908], edx
$LN14@PreFlight:

; 4025 : 
; 4026 : 	}
; 4027 : 	break;

	jmp	$LN38@PreFlight
$LN13@PreFlight:

; 4028 : 	case PreflightActions::INS:
; 4029 : 		//turn on aligning flag
; 4030 : 		if(PreFlightTable[mActionIndex].data == AircraftClass::INS_AlignNorm) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	cmp	DWORD PTR _PreFlightTable[edx+4], 2
	jne	$LN11@PreFlight

; 4031 : 		{
; 4032 : 			self->INSOff(AircraftClass::INS_PowerOff);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff

; 4033 : 			if(self == SimDriver.GetPlayerEntity() && OTWDriver.pCockpitManager)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	jne	SHORT $LN11@PreFlight
	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN11@PreFlight

; 4034 : 			{
; 4035 : 				self->SwitchINSToAlign();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SwitchINSToAlign@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToAlign

; 4036 : 				self->INSAlignmentTimer = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+772], xmm0

; 4037 : 				self->HasAligned = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	BYTE PTR [eax+781], 0

; 4038 : 				//Set the UFC
; 4039 : 				OTWDriver.pCockpitManager->mpIcp->ClearStrings();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?ClearStrings@ICPClass@@QAEXXZ		; ICPClass::ClearStrings

; 4040 : 				OTWDriver.pCockpitManager->mpIcp->LeaveCNI();

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?LeaveCNI@ICPClass@@QAEXXZ		; ICPClass::LeaveCNI

; 4041 : 				OTWDriver.pCockpitManager->mpIcp->SetICPFlag(ICPClass::MODE_LIST);

	push	4
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?SetICPFlag@ICPClass@@QAEXH@Z		; ICPClass::SetICPFlag

; 4042 : 				OTWDriver.pCockpitManager->mpIcp->SetICPSecondaryMode(23);	//SIX Button, INS Page

	push	23					; 00000017H
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?SetICPSecondaryMode@ICPClass@@QAEXH@Z	; ICPClass::SetICPSecondaryMode
$LN11@PreFlight:

; 4043 : 			}
; 4044 : 		}
; 4045 : 		self->INSOn((AircraftClass::INSAlignFlags)PreFlightTable[mActionIndex].data);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	mov	ecx, DWORD PTR _PreFlightTable[eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?INSOn@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOn

; 4046 : 		mNextPreflightAction = SimLibElapsedTime + PreFlightTable[mActionIndex].timedelay * CampaignSeconds;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	mov	edx, DWORD PTR _PreFlightTable[ecx+8]
	imul	edx, 1000				; 000003e8H
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+908], edx

; 4047 : 		
; 4048 : 		if(self->INSState(AircraftClass::INS_Aligned) && self->INSState(AircraftClass::INS_AlignNorm))

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN10@PreFlight
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN10@PreFlight

; 4049 : 			self->INSOff(AircraftClass::INS_AlignNorm);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?INSOff@AircraftClass@@QAEXW4INSAlignFlags@1@@Z ; AircraftClass::INSOff
$LN10@PreFlight:

; 4050 : 
; 4051 : 		if(self == SimDriver.GetPlayerEntity() && OTWDriver.pCockpitManager &&
; 4052 : 			PreFlightTable[mActionIndex].data == AircraftClass::INS_Nav)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	jne	SHORT $LN9@PreFlight
	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN9@PreFlight
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	shl	eax, 4
	cmp	DWORD PTR _PreFlightTable[eax+4], 32	; 00000020H
	jne	SHORT $LN9@PreFlight

; 4053 : 		{
; 4054 : 			//CNI page
; 4055 : 			OTWDriver.pCockpitManager->mpIcp->ChangeToCNI();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?ChangeToCNI@ICPClass@@QAEXXZ		; ICPClass::ChangeToCNI

; 4056 : 			//Mark us as aligned
; 4057 : 			self->SwitchINSToNav();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SwitchINSToNav@AircraftClass@@QAEXXZ	; AircraftClass::SwitchINSToNav
$LN9@PreFlight:

; 4058 : 		}
; 4059 : 	break;

	jmp	SHORT $LN38@PreFlight
$LN8@PreFlight:

; 4060 : 	case PreflightActions::VOLUME:
; 4061 : 		if(PreFlightTable[mActionIndex].data == 1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	shl	ecx, 4
	cmp	DWORD PTR _PreFlightTable[ecx+4], 1
	jne	SHORT $LN7@PreFlight

; 4062 : 			self->MissileVolume = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [eax+876], 0
	jmp	SHORT $LN5@PreFlight
$LN7@PreFlight:

; 4063 : 		else if(PreFlightTable[mActionIndex].data == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	shl	edx, 4
	cmp	DWORD PTR _PreFlightTable[edx+4], 2
	jne	SHORT $LN5@PreFlight

; 4064 : 			self->ThreatVolume = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [ecx+880], 0
$LN5@PreFlight:

; 4065 : 	break;

	jmp	SHORT $LN38@PreFlight
$LN4@PreFlight:

; 4066 : 	case PreflightActions::FLAPS:
; 4067 : 	    af->TEFTakeoff();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?TEFTakeoff@AirframeClass@@QAEXXZ	; AirframeClass::TEFTakeoff

; 4068 : 	    af->LEFTakeoff();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?LEFTakeoff@AirframeClass@@QAEXXZ	; AirframeClass::LEFTakeoff
$LN3@PreFlight:
$LN38@PreFlight:

; 4069 : 	    break;
; 4070 :     default:
; 4071 : 	ShiWarning("Bad Preflight Table");
; 4072 : 	break;
; 4073 :     }
; 4074 :     // force switch positions.
; 4075 :     if (self == SimDriver.GetPlayerEntity() && OTWDriver.pCockpitManager)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	jne	SHORT $LN2@PreFlight
	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN2@PreFlight

; 4076 :        OTWDriver.pCockpitManager->InitialiseInstruments();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?InitialiseInstruments@CockpitManager@@QAEXXZ ; CockpitManager::InitialiseInstruments
$LN2@PreFlight:

; 4077 : 
; 4078 :     mActionIndex ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+912], eax

; 4079 :     if (mActionIndex < MAX_PF_ACTIONS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+912], 38			; 00000026H
	jge	SHORT $LN1@PreFlight

; 4080 : 	return 0;

	xor	eax, eax
	jmp	SHORT $LN41@PreFlight
$LN1@PreFlight:

; 4081 :     mActionIndex = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+912], 0

; 4082 :     mNextPreflightAction = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], 0

; 4083 :     return 1;

	mov	eax, 1
$LN41@PreFlight:

; 4084 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN43@PreFlight:
	DD	$LN35@PreFlight
	DD	$LN33@PreFlight
	DD	$LN29@PreFlight
	DD	$LN37@PreFlight
	DD	$LN28@PreFlight
	DD	$LN24@PreFlight
	DD	$LN26@PreFlight
	DD	$LN20@PreFlight
	DD	$LN18@PreFlight
	DD	$LN31@PreFlight
	DD	$LN17@PreFlight
	DD	$LN16@PreFlight
	DD	$LN15@PreFlight
	DD	$LN13@PreFlight
	DD	$LN8@PreFlight
	DD	$LN4@PreFlight
?PreFlight@DigitalBrain@@IAEHXZ ENDP			; DigitalBrain::PreFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
$T2 = -420						; size = 8
$T3 = -412						; size = 8
$T4 = -404						; size = 8
$T5 = -396						; size = 8
_dz$6 = -388						; size = 4
_tx$7 = -384						; size = 4
tv2429 = -380						; size = 8
tv2420 = -372						; size = 8
_ty$8 = -364						; size = 4
_ty$9 = -360						; size = 4
tv2002 = -356						; size = 4
_ty$10 = -352						; size = 4
_tx$11 = -348						; size = 4
_tx$12 = -344						; size = 4
tv2581 = -340						; size = 4
_ty$13 = -336						; size = 4
_cosAngle$14 = -332					; size = 4
tv2676 = -328						; size = 4
tv2626 = -324						; size = 4
_x$15 = -320						; size = 4
tv2863 = -316						; size = 4
$T16 = -312						; size = 4
tv2855 = -308						; size = 4
_tx$17 = -304						; size = 4
tv2842 = -300						; size = 4
tv2671 = -296						; size = 4
tv2800 = -292						; size = 4
tv2619 = -288						; size = 4
tv2777 = -284						; size = 4
tv2575 = -280						; size = 4
tv2770 = -276						; size = 4
_ty$18 = -272						; size = 4
tv2757 = -268						; size = 4
_tx$19 = -264						; size = 4
tv2946 = -260						; size = 4
_tx$20 = -256						; size = 4
tv2742 = -252						; size = 4
_y$21 = -248						; size = 4
tv2736 = -244						; size = 4
_npt$22 = -240						; size = 4
tv2944 = -236						; size = 4
_ty$23 = -232						; size = 4
tv2731 = -228						; size = 4
tv1994 = -224						; size = 4
tv2725 = -220						; size = 4
tv2041 = -216						; size = 4
$T24 = -212						; size = 4
_ty$25 = -208						; size = 4
_dist$26 = -204						; size = 4
tv394 = -200						; size = 4
tv1479 = -196						; size = 4
_w$27 = -192						; size = 4
_elements$28 = -188					; size = 4
_tx$29 = -184						; size = 4
tv2425 = -180						; size = 4
tv301 = -176						; size = 4
tv2416 = -172						; size = 4
_flight$30 = -168					; size = 4
_tx$31 = -164						; size = 4
_ty$32 = -160						; size = 4
tv692 = -156						; size = 4
_rx$ = -152						; size = 4
_elemleader$33 = -148					; size = 4
_dx$34 = -144						; size = 4
tv605 = -140						; size = 4
_dy$35 = -136						; size = 4
_t2t$36 = -132						; size = 4
tv738 = -128						; size = 4
tv632 = -124						; size = 4
_factor$37 = -120					; size = 4
_acHeading$38 = -116					; size = 4
_dir$39 = -112						; size = 4
_flight$40 = -108					; size = 4
_tmpWaypoint$41 = -104					; size = 4
_xft$ = -100						; size = 4
_hdgToPt$42 = -96					; size = 4
_yft$ = -92						; size = 4
_wingman$43 = -88					; size = 4
_distSq$ = -84						; size = 4
_flight_leader$ = -80					; size = 4
_Airbase$44 = -76					; size = 4
_deltaHdg$45 = -72					; size = 4
_radioMessage$46 = -68					; size = 4
_legHeading$47 = -64					; size = 4
_inTheWay$ = -60					; size = 4
_Airbase$ = -56						; size = 4
_this$ = -52						; size = 4
_label$48 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?TakeOff@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::TakeOff
; _this$ = ecx

; 1454 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TakeOff@DigitalBrain@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 408				; 00000198H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1455 : 	SimBaseClass	*inTheWay = NULL;

	mov	DWORD PTR _inTheWay$[ebp], 0

; 1456 : 	ObjectiveClass	*Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 1457 : 	float			xft, yft, rx, distSq;
; 1458 : 	AircraftClass	*flight_leader = NULL;		//RAS - 12Nov04 - used to check for human movement in RAMP start

	mov	DWORD PTR _flight_leader$[ebp], 0

; 1459 : 	
; 1460 : 
; 1461 : 	flight_leader = (AircraftClass*)self->GetCampaignObject()->GetComponentNumber(0); //RAS

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _flight_leader$[ebp], eax

; 1462 : 
; 1463 : 	if(!Airbase || !Airbase->IsObjective() || !Airbase->brain){

	cmp	DWORD PTR _Airbase$[ebp], 0
	je	SHORT $LN160@TakeOff
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN160@TakeOff
	mov	ecx, DWORD PTR _Airbase$[ebp]
	cmp	DWORD PTR [ecx+240], 0
	jne	SHORT $LN161@TakeOff
$LN160@TakeOff:

; 1464 : 		//need to find the airbase or we don't know where to go
; 1465 : 		// JB carrier ShiWarning("Show this to Dave P. (no airbase)");
; 1466 : 		//Cobra Appears aircraft were getting stuck in takeoff mode 
; 1467 : 		//and looping in waypoint/takeoff mode.  This cycles them to next point
; 1468 : 		//since they don't have normal takeoff routines when doing carrier stuff
; 1469 : 		
; 1470 : 		// RV - Biker - Only switch to next WP if we are at takeoff 
; 1471 : 		if (self->curWaypoint->GetWPAction() == WP_TAKEOFF) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	SHORT $LN159@TakeOff

; 1472 : 			self->curWaypoint = self->curWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+728]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [edx+728], eax
$LN159@TakeOff:

; 1473 : 		return;

	jmp	$LN162@TakeOff
$LN161@TakeOff:

; 1474 : 	}
; 1475 : 
; 1476 : 	if(self->IsSetFlag(ON_GROUND) && af->Fuel() <= 0.0F && self->GetVt() < 5.0F)

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN157@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv1994[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv1994[ebp]
	jb	SHORT $LN157@TakeOff
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv2002[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR tv2002[ebp]
	jbe	SHORT $LN157@TakeOff

; 1477 : 	{
; 1478 : 		if(self != SimDriver.GetPlayerEntity())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	je	SHORT $LN157@TakeOff

; 1479 : 				RegroupAircraft (self); //no gas get him out of the way

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4
$LN157@TakeOff:

; 1480 : 	}
; 1481 : 
; 1482 : 	if(af->IsSet(AirframeClass::EngineOff))

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN156@TakeOff

; 1483 : 		af->ClearFlag(AirframeClass::EngineOff);

	push	32768					; 00008000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN156@TakeOff:

; 1484 : 	//TJL 01/22/04 multi-engine
; 1485 : 	if(af->IsSet(AirframeClass::EngineOff2))

	push	536870912				; 20000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN155@TakeOff

; 1486 : 		af->ClearFlag(AirframeClass::EngineOff2);

	push	536870912				; 20000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN155@TakeOff:

; 1487 : 	if(af->IsSet(AirframeClass::ThrottleCheck))

	push	65536					; 00010000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN154@TakeOff

; 1488 : 		af->ClearFlag(AirframeClass::ThrottleCheck);

	push	65536					; 00010000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag
$LN154@TakeOff:

; 1489 : 
; 1490 : 	SetDebugLabel(Airbase);

	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDebugLabel@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::SetDebugLabel

; 1491 : 
; 1492 : 	//Cobra This was causing CAP to switch off Fred ;)
; 1493 : 	//me123 make sure ap if off for player in multiplay
; 1494 : 	if(self == SimDriver.GetPlayerEntity() && IsSetATC(StopPlane) && SimDriver.GetPlayerEntity()->IsLocal()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], eax
	jne	SHORT $LN153@TakeOff
	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN153@TakeOff
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, eax
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN153@TakeOff

; 1495 : 		ClearATCFlag(StopPlane);

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1496 : 		af->ClearFlag(AirframeClass::WheelBrakes);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 1497 : 		/*if(self->AutopilotType()==AircraftClass::CombatAP)
; 1498 : 			self->SetAutopilot(AircraftClass::APOff);*/ //Offensive code ;)
; 1499 : 		// Cobra - still trying to stop creep forward
; 1500 : 		// sfr: WTF is this???????????????? @todo remove this shit
; 1501 : 		af->vt = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+1120], xmm0

; 1502 : 		return;

	jmp	$LN162@TakeOff
$LN153@TakeOff:

; 1503 : 	}
; 1504 : 	// JPO - should we run preflight checks...
; 1505 : 	if (!IsSetATC(DonePreflight) && curTaxiPoint) 

	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	$LN136@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	$LN136@TakeOff

; 1506 : 	{
; 1507 : 		VU_TIME t2t; // time to takeoff
; 1508 : 		if (rwtime > 0) // value given by ATC

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+316], 0
	jbe	SHORT $LN151@TakeOff

; 1509 : 			t2t = rwtime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	mov	DWORD PTR _t2t$36[ebp], ecx

; 1510 : 		else 

	jmp	SHORT $LN150@TakeOff
$LN151@TakeOff:

; 1511 : 			t2t = self->curWaypoint->GetWPDepartureTime(); // else original scheduled time

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+728]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _t2t$36[ebp], eax
$LN150@TakeOff:

; 1512 : 
; 1513 : 		// Cobra - Start with canopy open if on parking spot
; 1514 : 		if ((PlayerOptions.GetStartFlag() != PlayerOptionsClass::START_RUNWAY) && 
; 1515 : 			((af->GetParkType() != LargeParkPt)))

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetStartFlag@PlayerOptionsClass@@QAE?AW4StartFlag@1@XZ ; PlayerOptionsClass::GetStartFlag
	test	eax, eax
	je	$LN147@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN147@TakeOff

; 1516 : 		{ 
; 1517 : 			af->canopyState = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	BYTE PTR [eax+1588], 1

; 1518 : 			self->ClearAcStatusBits(AircraftClass::ACSTATUS_EXT_LANDINGLIGHT);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits

; 1519 : 			if(TheTimeOfDay.GetLightLevel() < 0.65f){

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetLightLevel@CTimeOfDay@@QAEMXZ	; CTimeOfDay::GetLightLevel
	fstp	DWORD PTR tv2041[ebp]
	movss	xmm0, DWORD PTR __real@3f266666
	comiss	xmm0, DWORD PTR tv2041[ebp]
	jbe	SHORT $LN148@TakeOff

; 1520 : 				self->SetSwitch (COMP_3DPIT_INTERIOR_LIGHTS, TRUE); // Cobra - Light up cockpit

	push	1
	push	127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1521 : 				self->SetAcStatusBits(AircraftClass::ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?SetAcStatusBits@AircraftClass@@QAEXH@Z	; AircraftClass::SetAcStatusBits

; 1522 : 			}
; 1523 : 			else {

	jmp	SHORT $LN147@TakeOff
$LN148@TakeOff:

; 1524 : 				self->SetSwitch (COMP_3DPIT_INTERIOR_LIGHTS, FALSE); // Cobra - Light up cockpit

	push	0
	push	127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?SetSwitch@SimMoverClass@@QAEXHH@Z	; SimMoverClass::SetSwitch

; 1525 : 				self->ClearAcStatusBits(AircraftClass::ACSTATUS_PITLIGHT);

	push	256					; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ClearAcStatusBits@AircraftClass@@QAEXH@Z ; AircraftClass::ClearAcStatusBits
$LN147@TakeOff:

; 1526 : 			}
; 1527 : 		}
; 1528 : 
; 1529 : 
; 1530 : 		//RAS - 14Oct04 - Orig = 3, take max of g_nTaxiLaunchTime or 3 min
; 1531 : 		if (SimLibElapsedTime > t2t - max(g_nTaxiLaunchTime * CampaignMinutes, 3 * CampaignMinutes)){

	mov	eax, DWORD PTR ?g_nTaxiLaunchTime@@3HA	; g_nTaxiLaunchTime
	imul	eax, 60000				; 0000ea60H
	cmp	eax, 180000				; 0002bf20H
	jle	SHORT $LN164@TakeOff
	mov	ecx, DWORD PTR ?g_nTaxiLaunchTime@@3HA	; g_nTaxiLaunchTime
	imul	ecx, 60000				; 0000ea60H
	mov	DWORD PTR tv301[ebp], ecx
	jmp	SHORT $LN165@TakeOff
$LN164@TakeOff:
	mov	DWORD PTR tv301[ebp], 180000		; 0002bf20H
$LN165@TakeOff:
	mov	edx, DWORD PTR _t2t$36[ebp]
	sub	edx, DWORD PTR tv301[ebp]
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, edx	; SimLibElapsedTime
	jbe	SHORT $LN146@TakeOff

; 1532 : 			// emergency pre-flight
; 1533 : 			QuickPreFlight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?QuickPreFlight@DigitalBrain@@IAEXXZ	; DigitalBrain::QuickPreFlight
	jmp	$LN137@TakeOff
$LN146@TakeOff:

; 1534 : 		}
; 1535 : 		else if (SimLibElapsedTime < t2t - PlayerOptionsClass::RAMP_MINUTES * CampaignMinutes){

	mov	eax, DWORD PTR _t2t$36[ebp]
	sub	eax, 1200000				; 00124f80H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, eax	; SimLibElapsedTime
	jae	SHORT $LN144@TakeOff

; 1536 : 			return; // not time for startup yet

	jmp	$LN162@TakeOff

; 1537 : 		}
; 1538 : 		else if (

	jmp	$LN137@TakeOff
$LN144@TakeOff:

; 1539 : 			PtDataTable[curTaxiPoint].flags == PT_LAST ||
; 1540 : 			PtDataTable[curTaxiPoint].type == SmallParkPt ||
; 1541 : 			PtDataTable[curTaxiPoint].type == LargeParkPt
; 1542 : 		){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+9]
	cmp	ecx, 2
	je	SHORT $LN141@TakeOff
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 11					; 0000000bH
	je	SHORT $LN141@TakeOff
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN142@TakeOff
$LN141@TakeOff:

; 1543 : 			//RAS-12Nov04-If flight leader is Human and does not have combat autopilot on and
; 1544 : 			//has left parking, then quick preflight wingman so they can follow human lead
; 1545 : 			if (
; 1546 : 				isWing && flight_leader && flight_leader->AutopilotType() != AircraftClass::CombatAP
; 1547 : 				&& flight_leader->DBrain()->curTaxiPoint != flight_leader->spawnpoint
; 1548 : 			){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN140@TakeOff
	cmp	DWORD PTR _flight_leader$[ebp], 0
	je	SHORT $LN140@TakeOff
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN140@TakeOff
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	edx, DWORD PTR _flight_leader$[ebp]
	mov	eax, DWORD PTR [eax+332]
	cmp	eax, DWORD PTR [edx+1792]
	je	SHORT $LN140@TakeOff

; 1549 : 				QuickPreFlight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?QuickPreFlight@DigitalBrain@@IAEXXZ	; DigitalBrain::QuickPreFlight

; 1550 : 				SetATCFlag(DonePreflight);

	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 1551 : 				return;

	jmp	$LN162@TakeOff
	jmp	SHORT $LN138@TakeOff
$LN140@TakeOff:

; 1552 : 			}
; 1553 : 			else if (!PreFlight()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreFlight@DigitalBrain@@IAEHXZ		; DigitalBrain::PreFlight
	test	eax, eax
	jne	SHORT $LN138@TakeOff

; 1554 : 				// slow preflight
; 1555 :                 return;

	jmp	$LN162@TakeOff
$LN138@TakeOff:

; 1556 : 			}
; 1557 : 		}
; 1558 : 		else {

	jmp	SHORT $LN137@TakeOff
$LN142@TakeOff:

; 1559 : 			QuickPreFlight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?QuickPreFlight@DigitalBrain@@IAEXXZ	; DigitalBrain::QuickPreFlight
$LN137@TakeOff:

; 1560 : 		}
; 1561 : 		SetATCFlag(DonePreflight);

	push	-2147483648				; 80000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 1562 : 
; 1563 : 		// COBRA - RED - Wingmans always confirm to humans when have checked in
; 1564 : 		// sfr: added NULL check
; 1565 : 		if (isWing && flight_leader && flight_leader->IsPlayer() ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	$LN136@TakeOff
	cmp	DWORD PTR _flight_leader$[ebp], 0
	je	$LN136@TakeOff
	mov	ecx, DWORD PTR _flight_leader$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	$LN136@TakeOff

; 1566 : 			//short					edata[10];
; 1567 : 			FalconRadioChatterMessage* radioMessage = new FalconRadioChatterMessage(
; 1568 : 				self->Id(), FalconLocalSession 
; 1569 : 			);

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN166@TakeOff
	push	1
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv394[ebp], eax
	jmp	SHORT $LN167@TakeOff
$LN166@TakeOff:
	mov	DWORD PTR tv394[ebp], 0
$LN167@TakeOff:
	mov	eax, DWORD PTR tv394[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR _radioMessage$46[ebp], ecx

; 1570 : 			radioMessage->dataBlock.from = self->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _radioMessage$46[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 1571 : 			radioMessage->dataBlock.to = MESSAGE_FOR_FLIGHT;

	mov	ecx, DWORD PTR _radioMessage$46[ebp]
	mov	BYTE PTR [ecx+60], 3

; 1572 : 			radioMessage->dataBlock.voice_id = 
; 1573 : 				((Flight)(self->GetCampaignObject()))->GetPilotVoiceID(self->vehicleInUnit);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, BYTE PTR [eax+664]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetPilotVoiceID@FlightClass@@QAEEH@Z	; FlightClass::GetPilotVoiceID
	mov	ecx, DWORD PTR _radioMessage$46[ebp]
	mov	BYTE PTR [ecx+61], al

; 1574 : 			radioMessage->dataBlock.message = rcREADYFORDERARTURE;

	mov	edx, 322				; 00000142H
	mov	eax, DWORD PTR _radioMessage$46[ebp]
	mov	WORD PTR [eax+62], dx

; 1575 : 			radioMessage->dataBlock.edata[0] = -1;

	mov	ecx, 2
	imul	ecx, 0
	or	edx, -1
	mov	eax, DWORD PTR _radioMessage$46[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1576 : 			radioMessage->dataBlock.edata[1] = -1;

	mov	ecx, 2
	shl	ecx, 0
	or	edx, -1
	mov	eax, DWORD PTR _radioMessage$46[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1577 : 			radioMessage->dataBlock.edata[2] = 
; 1578 : 				ConvertWingNumberToCallNumber(self->GetCampaignObject()->GetComponentIndex(self));;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	push	eax
	call	?ConvertWingNumberToCallNumber@@YAFH@Z	; ConvertWingNumberToCallNumber
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _radioMessage$46[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1579 : 			radioMessage->dataBlock.time_to_play = 3000; 

	mov	eax, DWORD PTR _radioMessage$46[ebp]
	mov	DWORD PTR [eax+56], 3000		; 00000bb8H

; 1580 : 			FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$46[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN136@TakeOff:

; 1581 : 		}
; 1582 : 	}
; 1583 : 
; 1584 :     // if we're damaged taxi back
; 1585 : 	if ( self->pctStrength < 0.7f && self->IsSetFlag(ON_GROUND)){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR __real@3f333333
	comiss	xmm0, DWORD PTR [eax+292]
	jbe	SHORT $LN135@TakeOff
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN135@TakeOff

; 1586 : 		TaxiBack(Airbase);

	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaxiBack@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ; DigitalBrain::TaxiBack

; 1587 : 		return;

	jmp	$LN162@TakeOff
$LN135@TakeOff:

; 1588 : 	}
; 1589 : 
; 1590 : 	xft = trackX - af->x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+148]
	subss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _xft$[ebp], xmm0

; 1591 : 	yft = trackY - af->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR [ecx+1112]
	movss	DWORD PTR _yft$[ebp], xmm0

; 1592 : 	rx	= self->dmx[0][0] * xft + self->dmx[0][1] * yft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 1593 : 	distSq = xft*xft + yft*yft;

	movss	xmm0, DWORD PTR _xft$[ebp]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	movss	xmm1, DWORD PTR _yft$[ebp]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _distSq$[ebp], xmm0

; 1594 : 
; 1595 : 	groundAvoidNeeded = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0

; 1596 : 
; 1597 : 	//RAS - This doesn't run on every airbase spawning aircraft, should it?  <== No
; 1598 : 	if(!curTaxiPoint){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+332], 0
	jne	$LN131@TakeOff

; 1599 : 		// Spawning
; 1600 : 		Flight flight = (Flight)self->GetCampaignObject();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$30[ebp], eax

; 1601 : 		if(flight){

	cmp	DWORD PTR _flight$30[ebp], 0
	je	$LN131@TakeOff

; 1602 : 			WayPoint	w;
; 1603 : 	
; 1604 : 			w = flight->GetFirstUnitWP();

	mov	ecx, DWORD PTR _flight$30[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$27[ebp], eax

; 1605 : 			if (w){

	cmp	DWORD PTR _w$27[ebp], 0
	je	$LN131@TakeOff

; 1606 : 				// FRB - spawn point	- tp on correct parking spot type (Small/Large)
; 1607 : 				SetTaxiPoint(FindDesiredTaxiPoint(w->GetWPDepartureTime()));				

	mov	ecx, DWORD PTR _w$27[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindDesiredTaxiPoint@DigitalBrain@@QAEHK@Z ; DigitalBrain::FindDesiredTaxiPoint
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1608 : 				if (curTaxiPoint)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	$LN131@TakeOff

; 1609 : 				{
; 1610 : 					self->spawnpoint = curTaxiPoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+1792], edx

; 1611 : 					float tx, ty;
; 1612 : 					TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$23[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1613 : 					SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$23[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$12[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1614 : 					CalcWaitTime(Airbase->brain);

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime

; 1615 : 					int npt = GetPrevTaxiPt(curTaxiPoint); // this is next place to go to

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetPrevTaxiPt@@YAHH@Z			; GetPrevTaxiPt
	add	esp, 4
	mov	DWORD PTR _npt$22[ebp], eax

; 1616 : 					float x, y;
; 1617 : 					TranslatePointData(Airbase, npt, &x, &y);

	lea	eax, DWORD PTR _y$21[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _npt$22[ebp]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 1618 : 					self->af->initialPsi = self->af->psi = self->af->sigma = (float)atan2 ( (y - self->af->y), (x - self->af->x) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR _x$15[ebp]
	subss	xmm0, DWORD PTR [eax+1108]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR _y$21[ebp]
	subss	xmm0, DWORD PTR [eax+1112]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv605[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR tv605[ebp]
	movss	DWORD PTR [eax+1176], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR tv605[ebp]
	movss	DWORD PTR [eax+1168], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR tv605[ebp]
	movss	DWORD PTR [eax+1332], xmm0

; 1619 : 					self->af->initialX = self->af->x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+932]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	mov	edx, DWORD PTR [eax+1108]
	mov	DWORD PTR [ecx+1316], edx

; 1620 : 					self->af->initialY = self->af->y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [ecx+932]
	mov	ecx, DWORD PTR [edx+1112]
	mov	DWORD PTR [eax+1320], ecx

; 1621 : 					af->canopyState = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	BYTE PTR [eax+1588], 1
$LN131@TakeOff:

; 1622 : 				}
; 1623 : 			}
; 1624 : 		}
; 1625 : 	}
; 1626 : 
; 1627 : 	if (g_nShowDebugLabels & 0x80000)

	mov	ecx, DWORD PTR ?g_nShowDebugLabels@@3HA	; g_nShowDebugLabels
	and	ecx, 524288				; 00080000H
	je	$LN120@TakeOff

; 1628 : 	{
; 1629 : 		char label [32];
; 1630 : 		sprintf(label,"TaxiPt %d, type: ",curTaxiPoint);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	push	OFFSET ??_C@_0BC@OBEDLAHJ@TaxiPt?5?$CFd?0?5type?3?5?$AA@
	lea	ecx, DWORD PTR _label$48[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1631 : 		switch (PtDataTable[curTaxiPoint].type)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	mov	DWORD PTR tv632[ebp], edx
	mov	eax, DWORD PTR tv632[ebp]
	sub	eax, 1
	mov	DWORD PTR tv632[ebp], eax
	cmp	DWORD PTR tv632[ebp], 18		; 00000012H
	ja	$LN128@TakeOff
	mov	ecx, DWORD PTR tv632[ebp]
	movzx	edx, BYTE PTR $LN171@TakeOff[ecx]
	jmp	DWORD PTR $LN175@TakeOff[edx*4]
$LN127@TakeOff:

; 1632 : 		{
; 1633 : 		case SmallParkPt:
; 1634 : 			strcat(label,"SmallParkPt");

	push	OFFSET ??_C@_0M@PPBOKGPO@SmallParkPt?$AA@
	lea	eax, DWORD PTR _label$48[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1635 : 			break;

	jmp	SHORT $LN128@TakeOff
$LN126@TakeOff:

; 1636 : 		case LargeParkPt:
; 1637 : 			strcat(label,"LargeParkPt");

	push	OFFSET ??_C@_0M@NKALPJKJ@LargeParkPt?$AA@
	lea	ecx, DWORD PTR _label$48[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1638 : 			break;

	jmp	SHORT $LN128@TakeOff
$LN125@TakeOff:

; 1639 : 		case TakeoffPt:	
; 1640 : 			strcat(label,"TakeoffPt");

	push	OFFSET ??_C@_09GFOPPOAM@TakeoffPt?$AA@
	lea	edx, DWORD PTR _label$48[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1641 : 			break;

	jmp	SHORT $LN128@TakeOff
$LN124@TakeOff:

; 1642 : 		case RunwayPt:
; 1643 : 			strcat(label,"RunwayPt");

	push	OFFSET ??_C@_08PJMGDEDN@RunwayPt?$AA@
	lea	eax, DWORD PTR _label$48[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1644 : 			break;

	jmp	SHORT $LN128@TakeOff
$LN123@TakeOff:

; 1645 : 		case TaxiPt:
; 1646 : 			strcat(label,"TaxiPt");

	push	OFFSET ??_C@_06NOMCLABP@TaxiPt?$AA@
	lea	ecx, DWORD PTR _label$48[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1647 : 			break;

	jmp	SHORT $LN128@TakeOff
$LN122@TakeOff:

; 1648 : 		case CritTaxiPt:
; 1649 : 			strcat(label,"CritTaxiPt");

	push	OFFSET ??_C@_0L@ENOFFMFD@CritTaxiPt?$AA@
	lea	edx, DWORD PTR _label$48[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1650 : 			break;

	jmp	SHORT $LN128@TakeOff
$LN121@TakeOff:

; 1651 : 		case TakeRunwayPt:
; 1652 : 			strcat(label,"TakeRunwayPt");

	push	OFFSET ??_C@_0N@COEEMFNJ@TakeRunwayPt?$AA@
	lea	eax, DWORD PTR _label$48[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN128@TakeOff:

; 1653 : 			break;
; 1654 : 		}
; 1655 : 		if (self->drawPointer)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN120@TakeOff

; 1656 : 			((DrawableBSP*)self->drawPointer)->SetLabel(label,((DrawableBSP*)self->drawPointer)->LabelColor());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+332]
	call	?LabelColor@DrawableBSP@@QAEKXZ		; DrawableBSP::LabelColor
	push	eax
	lea	edx, DWORD PTR _label$48[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+332]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+332]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN120@TakeOff:

; 1657 : 	}
; 1658 : 
; 1659 : 
; 1660 : 	switch(atcstatus)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR tv692[ebp], edx
	cmp	DWORD PTR tv692[ebp], 29		; 0000001dH
	ja	$LN1@TakeOff
	mov	eax, DWORD PTR tv692[ebp]
	movzx	ecx, BYTE PTR $LN172@TakeOff[eax]
	jmp	DWORD PTR $LN176@TakeOff[ecx*4]
$LN117@TakeOff:

; 1661 : 	{
; 1662 : 	case noATC:
; 1663 : 		AI_MESSAGE(0,"AI - NO_ATC");
; 1664 : 		if(!self->IsSetFlag(ON_GROUND))

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN116@TakeOff

; 1665 : 		{	
; 1666 : //			ShiAssert(!"Show this to Dave P. (not on ground)");
; 1667 : 			if(isWing)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN115@TakeOff

; 1668 : 				self->curWaypoint = self->curWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+728]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [edx+728], eax

; 1669 : 			else

	jmp	SHORT $LN114@TakeOff
$LN115@TakeOff:

; 1670 : 				SelectNextWaypoint();			

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectNextWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::SelectNextWaypoint
$LN114@TakeOff:

; 1671 : 			break;

	jmp	$LN118@TakeOff
$LN116@TakeOff:

; 1672 : 		}
; 1673 : 		
; 1674 : 		trackZ = af->groundZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1272]
	mov	DWORD PTR [edx+156], eax

; 1675 : 		ClearATCFlag(RequestTakeoff);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1676 : 		ClearATCFlag(PermitRunway);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1677 : 		ClearATCFlag(PermitTakeoff);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1678 : 		
; 1679 : 		switch(PtDataTable[curTaxiPoint].type)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	mov	DWORD PTR tv738[ebp], ecx
	mov	edx, DWORD PTR tv738[ebp]
	sub	edx, 1
	mov	DWORD PTR tv738[ebp], edx
	cmp	DWORD PTR tv738[ebp], 11		; 0000000bH
	ja	$LN101@TakeOff
	mov	eax, DWORD PTR tv738[ebp]
	movzx	ecx, BYTE PTR $LN173@TakeOff[eax]
	jmp	DWORD PTR $LN177@TakeOff[ecx*4]
$LN111@TakeOff:

; 1680 : 		{
; 1681 : 			case SmallParkPt:
; 1682 : 			case LargeParkPt:
; 1683 : 			{
; 1684 : 				atcstatus = tReqTakeoff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 20			; 00000014H

; 1685 : 				waittimer = SimLibElapsedTime + TAKEOFF_TIME_DELTA;  

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 10000				; 00002710H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 1686 : 				float tx, ty;
; 1687 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$10[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1688 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$10[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$20[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1689 : 				if(!isWing){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN110@TakeOff

; 1690 : 					SendATCMsg(tReqTakeoff);

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN110@TakeOff:

; 1691 : 				}
; 1692 : 				break;

	jmp	$LN112@TakeOff
$LN109@TakeOff:

; 1693 : 			}
; 1694 : 			case TakeoffPt:	
; 1695 : 			{
; 1696 : 				atcstatus = tReqTakeoff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 20			; 00000014H

; 1697 : 				rwIndex = Airbase->brain->IsOnRunway(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 1698 : 				float tx, ty;
; 1699 : 				if(GetFirstPt(rwIndex) == curTaxiPoint - 1){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	sub	edx, 1
	cmp	eax, edx
	jne	SHORT $LN108@TakeOff

; 1700 : 					SetTaxiPoint(
; 1701 : 						Airbase->brain->FindTakeoffPt(
; 1702 : 							(Flight)self->GetCampaignObject(), 
; 1703 : 							self->vehicleInUnit, 
; 1704 : 							rwIndex, 
; 1705 : 							&tx, &ty
; 1706 : 						)
; 1707 : 					);

	lea	eax, DWORD PTR _ty$25[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$29[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1708 : 				}
; 1709 : 				else {

	jmp	SHORT $LN107@TakeOff
$LN108@TakeOff:

; 1710 : 					rwIndex = Airbase->brain->GetOppositeRunway(rwIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 1711 : 					SetTaxiPoint(
; 1712 : 						Airbase->brain->FindTakeoffPt(
; 1713 : 							(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 1714 : 						)
; 1715 : 					);					

	lea	edx, DWORD PTR _ty$25[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$29[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN107@TakeOff:

; 1716 : 				}
; 1717 : 				SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$25[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$29[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1718 : 				waittimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+344], eax

; 1719 : 				if( !isWing ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN106@TakeOff

; 1720 : 					SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN106@TakeOff:

; 1721 : 				}
; 1722 : 			}
; 1723 : 			break;

	jmp	$LN112@TakeOff
$LN105@TakeOff:

; 1724 : 			case RunwayPt:
; 1725 : 			{
; 1726 : 				atcstatus = tReqTakeoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 20			; 00000014H

; 1727 : 				rwIndex = Airbase->brain->IsOnRunway(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 1728 : 				float tx, ty;
; 1729 : 				if(GetFirstPt(rwIndex) == curTaxiPoint){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+332]
	jne	SHORT $LN104@TakeOff

; 1730 : 					SetTaxiPoint(
; 1731 : 						Airbase->brain->FindRunwayPt(
; 1732 : 							(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 1733 : 						)
; 1734 : 					);

	lea	eax, DWORD PTR _ty$32[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$31[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindRunwayPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1735 : 				}
; 1736 : 				else {

	jmp	SHORT $LN103@TakeOff
$LN104@TakeOff:

; 1737 : 					rwIndex = Airbase->brain->GetOppositeRunway(rwIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 1738 : 					SetTaxiPoint(
; 1739 : 						Airbase->brain->FindRunwayPt(
; 1740 : 							(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 1741 : 						)
; 1742 : 					);

	lea	edx, DWORD PTR _ty$32[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$31[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+664]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindRunwayPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN103@TakeOff:

; 1743 : 				}
; 1744 : 				SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$32[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$31[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1745 : 
; 1746 : 				waittimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+344], eax

; 1747 : 				if( !isWing ) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN102@TakeOff

; 1748 : 					SendATCMsg(tReqTakeoff);

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN102@TakeOff:

; 1749 : 				}
; 1750 : 				break;

	jmp	SHORT $LN112@TakeOff
$LN101@TakeOff:

; 1751 : 			}
; 1752 : 			case TaxiPt:
; 1753 : 			case CritTaxiPt:
; 1754 : 			case TakeRunwayPt:
; 1755 : 			default:
; 1756 : 			{
; 1757 : 				float tx, ty;
; 1758 : 				atcstatus = tReqTakeoff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 20			; 00000014H

; 1759 : 				TranslatePointData(Airbase, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1760 : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$9[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$19[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1761 : 				//			waittimer = SimLibElapsedTime + TAKEOFF_TIME_DELTA;
; 1762 : 				waittimer = SimLibElapsedTime + (VU_TIME)(HurryUp*CampaignSeconds);  // FRB - speed up moving

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx

; 1763 : 				if( !isWing ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN100@TakeOff

; 1764 : 					SendATCMsg(tReqTakeoff);

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN100@TakeOff:
$LN112@TakeOff:

; 1765 : 				}
; 1766 : 				break;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 		SimpleGroundTrack(0.0F);		

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1771 : 		break;

	jmp	$LN118@TakeOff
$LN99@TakeOff:

; 1772 : 
; 1773 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1774 : 	case tReqTakeoff:
; 1775 : 	case tReqTaxi:
; 1776 : 		AI_MESSAGE(0,"AI - REQ TAXI");
; 1777 : 		// 17JAN04 - FRB - clear occupied parking spot flag
; 1778 : 		if (
; 1779 : 			(PtDataTable[curTaxiPoint].type == SmallParkPt) || 
; 1780 : 			(PtDataTable[curTaxiPoint].type == LargeParkPt)
; 1781 : 		){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 11					; 0000000bH
	je	SHORT $LN97@TakeOff
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN98@TakeOff
$LN97@TakeOff:

; 1782 : 			PtDataTable[curTaxiPoint].flags &= ~PT_OCCUPIED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+9]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [edx+eax+9], cl
$LN98@TakeOff:

; 1783 : 		}
; 1784 : 
; 1785 : 		if(SimLibElapsedTime > waittimer + TAKEOFF_TIME_DELTA){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	add	ecx, 10000				; 00002710H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, ecx	; SimLibElapsedTime
	jbe	SHORT $LN96@TakeOff

; 1786 : 			//we've been waiting too long, call again
; 1787 : 			SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 1788 : 			waittimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+344], edx
$LN96@TakeOff:

; 1789 : 		}
; 1790 : 		//we're waiting to get a response back
; 1791 : 		SimpleGroundTrack(0.0F);	

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1792 : 		break;

	jmp	$LN118@TakeOff
$LN95@TakeOff:

; 1793 : 
; 1794 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1795 : 	case tWait:
; 1796 : 		AI_MESSAGE(0,"AI - WAITING");
; 1797 : 		desiredSpeed = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+336], xmm0

; 1798 : 		if ( 
; 1799 : 			(distSq < TAXI_CHECK_DIST * TAXI_CHECK_DIST) || 
; 1800 : 			(rx < 1.0F && distSq < TAXI_CHECK_DIST*TAXI_CHECK_DIST*4.0F)
; 1801 : 		){

	movss	xmm0, DWORD PTR __real@45610000
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	ja	SHORT $LN93@TakeOff
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	SHORT $LN94@TakeOff
	movss	xmm0, DWORD PTR __real@46610000
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	jbe	SHORT $LN94@TakeOff
$LN93@TakeOff:

; 1802 : 			ChooseNextPoint(Airbase);

	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint

; 1803 : 		}
; 1804 : 		else {		

	jmp	$LN92@TakeOff
$LN94@TakeOff:

; 1805 : 			inTheWay = CheckTaxiTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	mov	DWORD PTR _inTheWay$[ebp], eax

; 1806 : 			if ( inTheWay ){

	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	SHORT $LN91@TakeOff

; 1807 : 				if(isWing){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN90@TakeOff

; 1808 : 					DealWithBlocker(inTheWay, Airbase);

	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z ; DigitalBrain::DealWithBlocker
$LN90@TakeOff:

; 1809 : 				}
; 1810 : 			}
; 1811 : 			else {

	jmp	SHORT $LN87@TakeOff
$LN91@TakeOff:

; 1812 : 				//default speed
; 1813 : 				if(SimLibElapsedTime > waittimer + TAKEOFF_TIME_DELTA){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	add	eax, 10000				; 00002710H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, eax	; SimLibElapsedTime
	jbe	SHORT $LN88@TakeOff

; 1814 : 					CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 1815 : 				}
; 1816 : 				else {

	jmp	SHORT $LN87@TakeOff
$LN88@TakeOff:

; 1817 : 					CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN87@TakeOff:

; 1818 : 				}
; 1819 : 			}
; 1820 : 			trackZ = af->groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1272]
	mov	DWORD PTR [eax+156], ecx
$LN92@TakeOff:

; 1821 : 		}			
; 1822 : 		
; 1823 : 		SimpleGroundTrack( desiredSpeed );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1824 : 	break;

	jmp	$LN118@TakeOff
$LN86@TakeOff:

; 1825 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1826 : 	case tTaxi:		
; 1827 : 		AI_MESSAGE(0,"AI - TAXING");
; 1828 : 		// 17JAN04 - FRB - clear occupied parking spot flag
; 1829 : 		if ((PtDataTable[curTaxiPoint].type == SmallParkPt) || (PtDataTable[curTaxiPoint].type == LargeParkPt)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN84@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	ecx, BYTE PTR [eax+edx+8]
	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN85@TakeOff
$LN84@TakeOff:

; 1830 : 			PtDataTable[curTaxiPoint].flags &= ~PT_OCCUPIED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [eax+ecx+9], dl
$LN85@TakeOff:

; 1831 : 		}
; 1832 : 
; 1833 : 		desiredSpeed = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+336], xmm0

; 1834 : 		//if we haven't reached our desired taxi point, we need to move
; 1835 : 		if ( 
; 1836 : 			(distSq < TAXI_CHECK_DIST * TAXI_CHECK_DIST) || 
; 1837 : 			(rx < 1.0F && distSq < TAXI_CHECK_DIST*TAXI_CHECK_DIST*4.0F)
; 1838 : 		){

	movss	xmm0, DWORD PTR __real@45610000
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	ja	SHORT $LN82@TakeOff
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	SHORT $LN83@TakeOff
	movss	xmm0, DWORD PTR __real@46610000
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	jbe	SHORT $LN83@TakeOff
$LN82@TakeOff:

; 1839 : 			ChooseNextPoint(Airbase);

	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint

; 1840 : 		}
; 1841 : 		else {	

	jmp	$LN81@TakeOff
$LN83@TakeOff:

; 1842 : 			inTheWay = CheckTaxiTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	mov	DWORD PTR _inTheWay$[ebp], eax

; 1843 : 			if ( inTheWay ){

	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	SHORT $LN80@TakeOff

; 1844 : 				//someone is in the way
; 1845 : 				DealWithBlocker(inTheWay, Airbase);

	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z ; DigitalBrain::DealWithBlocker

; 1846 : 			}
; 1847 : 			else {

	jmp	SHORT $LN77@TakeOff
$LN80@TakeOff:

; 1848 : 				//default speed
; 1849 : 				if(SimLibElapsedTime > waittimer + TAKEOFF_TIME_DELTA){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	add	eax, 10000				; 00002710H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, eax	; SimLibElapsedTime
	jbe	SHORT $LN78@TakeOff

; 1850 : 					CalculateTaxiSpeed(HurryUp);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 1851 : 				}
; 1852 : 				else {

	jmp	SHORT $LN77@TakeOff
$LN78@TakeOff:

; 1853 : 					CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN77@TakeOff:

; 1854 : 				}
; 1855 : 			}
; 1856 : 			trackZ = af->groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1272]
	mov	DWORD PTR [eax+156], ecx
$LN81@TakeOff:

; 1857 : 		}
; 1858 : 		SimpleGroundTrack( desiredSpeed );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1859 : 	break;

	jmp	$LN118@TakeOff
$LN76@TakeOff:

; 1860 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1861 : 	case tHoldShort:
; 1862 : 		AI_MESSAGE(0,"AI - HOLDSHORT");
; 1863 : 
; 1864 : 		desiredSpeed = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+336], xmm0

; 1865 : 		if(rwtime < (MoveAlong * CampaignSeconds + SimLibElapsedTime) && waittimer < SimLibElapsedTime){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+316]
	mov	DWORD PTR tv2416[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv2416[ebp]
	mov	eax, DWORD PTR tv2416[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv2420[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv2420[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv2425[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv2425[ebp]
	mov	edx, DWORD PTR tv2425[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv2429[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv2429[ebp]
	addss	xmm1, DWORD PTR __real@453b8000
	comiss	xmm1, xmm0
	jbe	SHORT $LN75@TakeOff
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN75@TakeOff

; 1866 : 			SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 1867 : 			waittimer = CalcWaitTime(Airbase->brain);

	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
$LN75@TakeOff:

; 1868 : 		}
; 1869 : 
; 1870 : 		ChooseNextPoint(Airbase);	

	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint

; 1871 : 
; 1872 : 		if(desiredSpeed == 0.0F && Airbase->brain->IsOnRunway(trackX, trackY)){			

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+336]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN74@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+152]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+148]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN74@TakeOff

; 1873 : 			OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 1874 : 			//CalculateTaxiSpeed(MoveAlong);
; 1875 : 			CalculateTaxiSpeed(HurryUp);  // 17JAN04 - FRB - Expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN74@TakeOff:

; 1876 : 		}
; 1877 : 
; 1878 : 		SimpleGroundTrack( desiredSpeed );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1879 : 		break;

	jmp	$LN118@TakeOff
$LN73@TakeOff:

; 1880 : 
; 1881 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1882 : 	case tTakeRunway:
; 1883 : 		AI_MESSAGE(0,"AI - TAKE RUNWAY");
; 1884 : 		desiredSpeed = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+336], xmm0

; 1885 : 		//if we haven't reached our desired taxi point, we need to move
; 1886 : 		if ( 
; 1887 : 			(distSq < TAXI_CHECK_DIST * TAXI_CHECK_DIST) || 
; 1888 : 			(rx < 0.0F && distSq < TAXI_CHECK_DIST*TAXI_CHECK_DIST*4.0F)
; 1889 : 		){

	movss	xmm0, DWORD PTR __real@45610000
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	ja	SHORT $LN71@TakeOff
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _rx$[ebp]
	jbe	SHORT $LN72@TakeOff
	movss	xmm0, DWORD PTR __real@46610000
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	jbe	SHORT $LN72@TakeOff
$LN71@TakeOff:

; 1890 : 			if (PtDataTable[curTaxiPoint].type != RunwayPt){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	eax, BYTE PTR [edx+ecx+8]
	cmp	eax, 1
	je	SHORT $LN70@TakeOff

; 1891 : 				ChooseNextPoint(Airbase);	 

	mov	ecx, DWORD PTR _Airbase$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint
$LN70@TakeOff:

; 1892 : 			}
; 1893 : 		}
; 1894 : 		else {		

	jmp	SHORT $LN69@TakeOff
$LN72@TakeOff:

; 1895 : 			inTheWay = CheckTaxiTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	mov	DWORD PTR _inTheWay$[ebp], eax

; 1896 : 			if ( inTheWay ){

	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	SHORT $LN68@TakeOff

; 1897 : 				DealWithBlocker(inTheWay, Airbase);

	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	eax, DWORD PTR _inTheWay$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z ; DigitalBrain::DealWithBlocker

; 1898 : 			}
; 1899 : 			else  {

	jmp	SHORT $LN67@TakeOff
$LN68@TakeOff:

; 1900 : //				CalculateTaxiSpeed(MoveAlong);
; 1901 : 				CalculateTaxiSpeed(HurryUp);  // 17JAN04 - FRB - Expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN67@TakeOff:

; 1902 : 			}
; 1903 : 			trackZ = af->groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1272]
	mov	DWORD PTR [eax+156], ecx
$LN69@TakeOff:

; 1904 : 		}
; 1905 : 
; 1906 : 		if(PtDataTable[curTaxiPoint].type == RunwayPt)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 1
	jne	$LN59@TakeOff

; 1907 : 		{
; 1908 : 			if(isWing && self->af->IsSet(AirframeClass::OverRunway) && !WingmanTakeRunway(Airbase) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN65@TakeOff
	push	8388608					; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	$LN65@TakeOff
	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WingmanTakeRunway@DigitalBrain@@QAEHPAVObjectiveClass@@@Z ; DigitalBrain::WingmanTakeRunway
	test	eax, eax
	jne	$LN65@TakeOff

; 1909 : 			{
; 1910 : 				float tx, ty;
; 1911 : 				SetTaxiPoint(
; 1912 : 					Airbase->brain->FindTakeoffPt(
; 1913 : 						(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 1914 : 					)
; 1915 : 				);

	lea	ecx, DWORD PTR _ty$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movzx	ecx, BYTE PTR [eax+664]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1916 : 				OffsetTrackPoint(50.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@42480000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 1917 : //				CalculateTaxiSpeed(MoveAlong);
; 1918 : 				CalculateTaxiSpeed(HurryUp);  // 17JAN04 - FRB - Expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 1919 : 				curTaxiPoint++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+332], edx
	jmp	$LN59@TakeOff
$LN65@TakeOff:

; 1920 : 			}
; 1921 : 			else if(!self->af->IsSet(AirframeClass::OverRunway)){

	push	8388608					; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN63@TakeOff

; 1922 : 				OffsetTrackPoint(0.0F, centerRunway);

	push	10					; 0000000aH
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 1923 : 				curTaxiPoint++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+332], ecx

; 1924 : 			}
; 1925 : 			else {

	jmp	$LN59@TakeOff
$LN63@TakeOff:

; 1926 : 				float cosAngle =	self->platformAngles.sinsig * PtHeaderDataTable[rwIndex].sinHeading + 
; 1927 : 									self->platformAngles.cossig * PtHeaderDataTable[rwIndex].cosHeading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+372]
	mulss	xmm0, DWORD PTR [edx+eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR [ecx+376]
	mulss	xmm1, DWORD PTR [edx+eax+16]
	addss	xmm0, xmm1
	movss	DWORD PTR _cosAngle$14[ebp], xmm0

; 1928 : 			
; 1929 : 				if (cosAngle >  0.99619F){

	movss	xmm0, DWORD PTR _cosAngle$14[ebp]
	comiss	xmm0, DWORD PTR __real@3f7f064f
	jbe	SHORT $LN59@TakeOff

; 1930 : 					if(ReadyToGo()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadyToGo@DigitalBrain@@QAEHXZ		; DigitalBrain::ReadyToGo
	test	eax, eax
	je	SHORT $LN60@TakeOff

; 1931 : 						waittimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0

; 1932 : 						atcstatus = tTakeoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 27			; 0000001bH

; 1933 : 						SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 1934 : 						trackZ = af->groundZ - 500.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1272]
	subss	xmm0, DWORD PTR __real@43fa0000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm0

; 1935 : 					}
; 1936 : 					else {

	jmp	SHORT $LN59@TakeOff
$LN60@TakeOff:

; 1937 : 						desiredSpeed = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+336], xmm0
$LN59@TakeOff:

; 1938 : 					}
; 1939 : 				}
; 1940 : 			}
; 1941 : 		}
; 1942 : 
; 1943 : 		SimpleGroundTrack( desiredSpeed );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1944 : 
; 1945 : 		// edg: test for fuckupedness -- I've seen planes taking the runway
; 1946 : 		// which are already in the air (bad trackX and Y?).  They never
; 1947 : 		// get out of this take runway cycle.   If we find ourselves in
; 1948 : 		// this state go to take off since we're off already....
; 1949 : 		if ( !self->OnGround() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN58@TakeOff

; 1950 : 		{
; 1951 : 			ShiWarning("Show this to Dave P. (not on ground)");
; 1952 : 			waittimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0

; 1953 : 			atcstatus = tTakeoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 27			; 0000001bH

; 1954 : 			SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN58@TakeOff:

; 1955 : 		}
; 1956 : 		break;

	jmp	$LN118@TakeOff
$LN57@TakeOff:

; 1957 : 
; 1958 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1959 : 	case tTakeoff:
; 1960 : 		AI_MESSAGE(0,"AI - TAKEOFF");
; 1961 : 		if(self->OnGround() && !self->af->IsSet(AirframeClass::OverRunway))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN56@TakeOff
	push	8388608					; 00800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN56@TakeOff

; 1962 : 		{
; 1963 : 			float tx, ty;
; 1964 : 			SetTaxiPoint(
; 1965 : 				Airbase->brain->FindTakeoffPt(
; 1966 : 					(Flight)self->GetCampaignObject(), self->vehicleInUnit, rwIndex, &tx, &ty
; 1967 : 				)
; 1968 : 			);

	lea	eax, DWORD PTR _ty$18[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	eax, BYTE PTR [edx+664]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1969 : 			SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$18[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$11[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1970 : 			atcstatus = tTakeRunway;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 26			; 0000001aH

; 1971 : 			SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 1972 : //			CalculateTaxiSpeed(MoveAlong);
; 1973 : 			CalculateTaxiSpeed(HurryUp);  // 17JAN04 - FRB - Expedite takeoff

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)

; 1974 : 			SimpleGroundTrack(desiredSpeed);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1975 : 			return;

	jmp	$LN162@TakeOff
$LN56@TakeOff:

; 1976 : 		}
; 1977 : 
; 1978 : 		if(self->OnGround())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN55@TakeOff

; 1979 : 			SimpleGroundTrack(af->MinVcas() * KNOTS_TO_FTPSEC);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv2575[ebp]
	movss	xmm0, DWORD PTR tv2575[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1980 : 		else

	jmp	SHORT $LN54@TakeOff
$LN55@TakeOff:

; 1981 : 			TrackPoint(0.0F, (af->MinVcas() + 50.0F) * KNOTS_TO_FTPSEC);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv2581[ebp]
	movss	xmm0, DWORD PTR tv2581[ebp]
	addss	xmm0, DWORD PTR __real@42480000
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)
$LN54@TakeOff:

; 1982 : 
; 1983 : 		if(af->z - af->groundZ < -20.0F && af->gearHandle > -1.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [ecx+1116]
	subss	xmm0, DWORD PTR [eax+1272]
	movss	xmm1, DWORD PTR __real@c1a00000
	comiss	xmm1, xmm0
	jbe	SHORT $LN53@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1556]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN53@TakeOff

; 1984 : 			af->gearHandle = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0
$LN53@TakeOff:

; 1985 : 
; 1986 : 		if (af->z - af->groundZ < -50.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [eax+1116]
	subss	xmm0, DWORD PTR [edx+1272]
	movss	xmm1, DWORD PTR __real@c2480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN52@TakeOff

; 1987 : 		{
; 1988 : 			if(af->gearHandle > -1.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [ecx+1556]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN51@TakeOff

; 1989 : 				af->gearHandle = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1556], xmm0
$LN51@TakeOff:

; 1990 : 			atcstatus = tFlyOut;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 28			; 0000001cH

; 1991 : 			SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN52@TakeOff:

; 1992 : 		}		
; 1993 : 		break;

	jmp	$LN118@TakeOff
$LN50@TakeOff:

; 1994 : 
; 1995 : 	//////////////////////////////////////////////////////////////////////////////////////
; 1996 : 	case tFlyOut:
; 1997 : 		AI_MESSAGE(0,"AI - FLYOUT");
; 1998 : 		int				elements;
; 1999 : 		trackZ = af->groundZ - 500.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1272]
	subss	xmm0, DWORD PTR __real@43fa0000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm0

; 2000 : 		if(af->gearHandle > -1.0F) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1556]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN49@TakeOff

; 2001 : 			af->gearHandle = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0
$LN49@TakeOff:

; 2002 : 
; 2003 : 		// 2001-10-16 added by M.N. #1 performs a 90 base leg to waypoint 2 at takeoff
; 2004 : 		// Needed so that lead that will perform the leg will first fly out before it starts the leg
; 2005 : 		if ( af->z - af->groundZ > -200.0F || (fabs(xft) < 200.0F && fabs(yft) < 200.0F) ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [eax+1116]
	subss	xmm0, DWORD PTR [edx+1272]
	comiss	xmm0, DWORD PTR __real@c3480000
	ja	SHORT $LN47@TakeOff
	push	ecx
	movss	xmm0, DWORD PTR _xft$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2619[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR tv2619[ebp]
	jbe	SHORT $LN48@TakeOff
	push	ecx
	movss	xmm0, DWORD PTR _yft$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2626[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR tv2626[ebp]
	jbe	SHORT $LN48@TakeOff
$LN47@TakeOff:

; 2006 : 			break;

	jmp	$LN118@TakeOff
$LN48@TakeOff:

; 2007 : 		}
; 2008 : 
; 2009 : 		elements = self->GetCampaignObject()->NumberOfComponents();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	mov	DWORD PTR _elements$28[ebp], eax

; 2010 : 
; 2011 : 		// 2001-10-16 M.N. added elemleader check -> perform a 90 base leg until element lead has taken off
; 2012 : 		if (!isWing && elements > 1) // Code for the flightlead

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN46@TakeOff
	cmp	DWORD PTR _elements$28[ebp], 1
	jle	$LN46@TakeOff

; 2013 : 		{
; 2014 : 			// wingy or lead
; 2015 : 			AircraftClass *elemleader = 
; 2016 : 				(AircraftClass*)self->GetCampaignObject()->GetComponentNumber(elements == 2 ? 1 : 2); 

	cmp	DWORD PTR _elements$28[ebp], 2
	jne	SHORT $LN168@TakeOff
	mov	DWORD PTR tv1479[ebp], 1
	jmp	SHORT $LN169@TakeOff
$LN168@TakeOff:
	mov	DWORD PTR tv1479[ebp], 2
$LN169@TakeOff:
	mov	edx, DWORD PTR tv1479[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _elemleader$33[ebp], eax

; 2017 : 			if (elemleader) // is #3 in a 4- and 3-ship flight, #2 in a 2-ship flight

	cmp	DWORD PTR _elemleader$33[ebp], 0
	je	$LN41@TakeOff

; 2018 : 			{
; 2019 : 				airbase = self->LandingAirbase(); // JPO - now we set to go home

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?LandingAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ; AircraftClass::LandingAirbase
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+308], ecx
	mov	DWORD PTR [eax+312], edx

; 2020 : 				ObjectiveClass *Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	push	edx
	mov	eax, DWORD PTR [ecx+308]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$44[ebp], eax

; 2021 : 				if (!Airbase || elemleader->af->z - elemleader->af->groundZ < -50.0F) // #3 has taken off -> lead continue to next WP

	cmp	DWORD PTR _Airbase$44[ebp], 0
	je	SHORT $LN43@TakeOff
	mov	ecx, DWORD PTR _elemleader$33[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _elemleader$33[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [edx+1116]
	subss	xmm0, DWORD PTR [ecx+1272]
	movss	xmm1, DWORD PTR __real@c2480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN44@TakeOff
$LN43@TakeOff:

; 2022 : 				{
; 2023 : 					onStation = NotThereYet;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 0

; 2024 : 					SelectNextWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectNextWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::SelectNextWaypoint

; 2025 : 					atcstatus = noATC;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 0

; 2026 : 					SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 2027 : 					
; 2028 : 				}
; 2029 : 				else 

	jmp	$LN41@TakeOff
$LN44@TakeOff:

; 2030 : 				{	// #1 and #2 do a takeoff leg - find direction to next waypoint
; 2031 : 
; 2032 : 					int dir;
; 2033 : 					float			tx,ty,dx,dy,dz,dist;
; 2034 : 					float			deltaHdg, hdgToPt, acHeading, legHeading;
; 2035 : 
; 2036 : 					acHeading = self->Yaw(); // fix, use aircrafts real heading instead of runway heading

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _acHeading$38[ebp]

; 2037 : 
; 2038 : 					WayPointClass* tmpWaypoint = self->curWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+728]
	mov	DWORD PTR _tmpWaypoint$41[ebp], eax

; 2039 : 					if (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$41[ebp], 0
	je	$LN41@TakeOff

; 2040 : 					{
; 2041 : 						ShiAssert (tmpWaypoint->GetWPAction() == WP_TAKEOFF);
; 2042 : // add this if we have	if (tmpWaypoint->GetWPAction() != WP_TAKEOFF && tmpWaypoint->GetPrevWP())
; 2043 : // a failed assertion		tmpWaypoint = tmpWaypoint->GetPrevWP();
; 2044 : 					
; 2045 : 					tmpWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$41[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWaypoint$41[ebp], eax

; 2046 : 					tmpWaypoint->GetLocation(&dx,&dy,&dz);

	lea	ecx, DWORD PTR _dz$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _dy$35[ebp]
	push	edx
	lea	eax, DWORD PTR _dx$34[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpWaypoint$41[ebp]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 2047 : 	
; 2048 : 					tx = dx - Airbase->XPos();

	mov	ecx, DWORD PTR _Airbase$44[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv2671[ebp]
	movss	xmm0, DWORD PTR _dx$34[ebp]
	subss	xmm0, DWORD PTR tv2671[ebp]
	movss	DWORD PTR _tx$17[ebp], xmm0

; 2049 : 					ty = dy - Airbase->YPos();

	mov	ecx, DWORD PTR _Airbase$44[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv2676[ebp]
	movss	xmm0, DWORD PTR _dy$35[ebp]
	subss	xmm0, DWORD PTR tv2676[ebp]
	movss	DWORD PTR _ty$13[ebp], xmm0

; 2050 : 					hdgToPt = (float)atan2(ty, tx);

	cvtss2sd xmm0, DWORD PTR _tx$17[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ty$13[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _hdgToPt$42[ebp]

; 2051 : 					if(hdgToPt < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _hdgToPt$42[ebp]
	jbe	SHORT $LN40@TakeOff

; 2052 : 						hdgToPt += PI * 2.0F;

	movss	xmm0, DWORD PTR _hdgToPt$42[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _hdgToPt$42[ebp], xmm0
$LN40@TakeOff:

; 2053 : 
; 2054 : 	
; 2055 : 					if(acHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _acHeading$38[ebp]
	jbe	SHORT $LN39@TakeOff

; 2056 : 						acHeading += PI * 2.0F;

	movss	xmm0, DWORD PTR _acHeading$38[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _acHeading$38[ebp], xmm0
$LN39@TakeOff:

; 2057 : 
; 2058 : 					deltaHdg = hdgToPt - acHeading;

	movss	xmm0, DWORD PTR _hdgToPt$42[ebp]
	subss	xmm0, DWORD PTR _acHeading$38[ebp]
	movss	DWORD PTR _deltaHdg$45[ebp], xmm0

; 2059 : 					if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN38@TakeOff

; 2060 : 						deltaHdg -= (2.0F*PI);

	movss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	subss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _deltaHdg$45[ebp], xmm0
	jmp	SHORT $LN36@TakeOff
$LN38@TakeOff:

; 2061 : 					else if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	jbe	SHORT $LN36@TakeOff

; 2062 : 					deltaHdg += (2.0F*PI);

	movss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _deltaHdg$45[ebp], xmm0
$LN36@TakeOff:

; 2063 : 					if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	jbe	SHORT $LN35@TakeOff

; 2064 : 						dir = 1;

	mov	DWORD PTR _dir$39[ebp], 1
	jmp	SHORT $LN30@TakeOff
$LN35@TakeOff:

; 2065 : 					else if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN33@TakeOff

; 2066 : 						dir = 0;

	mov	DWORD PTR _dir$39[ebp], 0
	jmp	SHORT $LN30@TakeOff
$LN33@TakeOff:

; 2067 : 					else if(deltaHdg < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _deltaHdg$45[ebp]
	jbe	SHORT $LN31@TakeOff

; 2068 : 						dir = 0;//left

	mov	DWORD PTR _dir$39[ebp], 0

; 2069 : 					else

	jmp	SHORT $LN30@TakeOff
$LN31@TakeOff:

; 2070 : 						dir = 1;//right

	mov	DWORD PTR _dir$39[ebp], 1
$LN30@TakeOff:

; 2071 : 					
; 2072 : 					legHeading = hdgToPt;

	movss	xmm0, DWORD PTR _hdgToPt$42[ebp]
	movss	DWORD PTR _legHeading$47[ebp], xmm0

; 2073 : 
; 2074 : 					// MN CTD fix #2
; 2075 : 					AircraftClass *wingman = NULL;

	mov	DWORD PTR _wingman$43[ebp], 0

; 2076 : 					FlightClass *flight = NULL;

	mov	DWORD PTR _flight$40[ebp], 0

; 2077 : 					flight = (FlightClass*)self->GetCampaignObject();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$40[ebp], eax

; 2078 : 					ShiAssert(!F4IsBadReadPtr(flight,sizeof(FlightClass)));
; 2079 : 					float factor = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _factor$37[ebp], xmm0

; 2080 : 					if (flight)

	cmp	DWORD PTR _flight$40[ebp], 0
	je	$LN27@TakeOff

; 2081 : 					{
; 2082 : 						wingman = (AircraftClass*)flight->GetComponentNumber(1); // my wingy = 1 in each case

	push	1
	mov	ecx, DWORD PTR _flight$40[ebp]
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _wingman$43[ebp], eax

; 2083 : 						ShiAssert(!F4IsBadReadPtr(wingman,sizeof(AircraftClass)));
; 2084 : 					
; 2085 : 						if (wingman && wingman->af && (wingman->af->z - wingman->af->groundZ < -200.0F))	// My wingman has flown out

	cmp	DWORD PTR _wingman$43[ebp], 0
	je	SHORT $LN28@TakeOff
	mov	edx, DWORD PTR _wingman$43[ebp]
	cmp	DWORD PTR [edx+932], 0
	je	SHORT $LN28@TakeOff
	mov	eax, DWORD PTR _wingman$43[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _wingman$43[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [ecx+1116]
	subss	xmm0, DWORD PTR [eax+1272]
	movss	xmm1, DWORD PTR __real@c3480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN28@TakeOff

; 2086 : 							factor = 45.0F * DTR;

	movss	xmm0, DWORD PTR __real@3f490fd9
	movss	DWORD PTR _factor$37[ebp], xmm0
$LN28@TakeOff:

; 2087 : 					
; 2088 : 						ShiAssert(Airbase->brain);
; 2089 : 						if (Airbase->brain && Airbase->brain->UseSectionTakeoff(flight, rwIndex))	// If our wingman took off with us, stay on a 90 leg

	mov	ecx, DWORD PTR _Airbase$44[ebp]
	cmp	DWORD PTR [ecx+240], 0
	je	SHORT $LN27@TakeOff
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _flight$40[ebp]
	push	ecx
	mov	edx, DWORD PTR _Airbase$44[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN27@TakeOff

; 2090 : 							factor = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _factor$37[ebp], xmm0
$LN27@TakeOff:

; 2091 : 					}
; 2092 : 					
; 2093 : 					if (dir)

	cmp	DWORD PTR _dir$39[ebp], 0
	je	SHORT $LN26@TakeOff

; 2094 : 						legHeading = legHeading - (90.0F * DTR - factor);

	movss	xmm0, DWORD PTR __real@3fc90fd9
	subss	xmm0, DWORD PTR _factor$37[ebp]
	movss	xmm1, DWORD PTR _legHeading$47[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _legHeading$47[ebp], xmm1

; 2095 : 					else

	jmp	SHORT $LN25@TakeOff
$LN26@TakeOff:

; 2096 : 						legHeading = legHeading + (90.0F * DTR - factor);

	movss	xmm0, DWORD PTR __real@3fc90fd9
	subss	xmm0, DWORD PTR _factor$37[ebp]
	addss	xmm0, DWORD PTR _legHeading$47[ebp]
	movss	DWORD PTR _legHeading$47[ebp], xmm0
$LN25@TakeOff:

; 2097 : 
; 2098 : 					if (legHeading >=360.0F * DTR)

	movss	xmm0, DWORD PTR _legHeading$47[ebp]
	comiss	xmm0, DWORD PTR __real@40c90fd9
	jb	SHORT $LN24@TakeOff

; 2099 : 						legHeading -= 360.0F * DTR;

	movss	xmm0, DWORD PTR _legHeading$47[ebp]
	subss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _legHeading$47[ebp], xmm0
$LN24@TakeOff:

; 2100 : 					if (legHeading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _legHeading$47[ebp]
	jbe	SHORT $LN23@TakeOff

; 2101 : 						legHeading += 360.0F * DTR;

	movss	xmm0, DWORD PTR _legHeading$47[ebp]
	addss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _legHeading$47[ebp], xmm0
$LN23@TakeOff:

; 2102 : 
; 2103 : 					dist = 10.0F * NM_TO_FT;

	movss	xmm0, DWORD PTR __real@476d5a1c
	movss	DWORD PTR _dist$26[ebp], xmm0

; 2104 : 
; 2105 : 					// Set up a new trackpoint
; 2106 : 
; 2107 : 					dx = Airbase->XPos() + dist * cos (legHeading);

	mov	ecx, DWORD PTR _Airbase$44[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv2725[ebp]
	movss	xmm0, DWORD PTR tv2725[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _legHeading$47[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2944[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv2731[ebp]
	movss	xmm0, DWORD PTR tv2731[ebp]
	mulss	xmm0, DWORD PTR _dist$26[ebp]
	movss	xmm1, DWORD PTR tv2944[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _dx$34[ebp], xmm1

; 2108 : 					dy = Airbase->YPos() + dist * sin (legHeading);

	mov	ecx, DWORD PTR _Airbase$44[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv2736[ebp]
	movss	xmm0, DWORD PTR tv2736[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _legHeading$47[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv2946[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv2742[ebp]
	movss	xmm0, DWORD PTR tv2742[ebp]
	mulss	xmm0, DWORD PTR _dist$26[ebp]
	movss	xmm1, DWORD PTR tv2946[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _dy$35[ebp], xmm1

; 2109 : 
; 2110 : 					SetTrackPoint(dx, dy, -2000.0F + af->groundZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@c4fa0000
	addss	xmm0, DWORD PTR [ecx+1272]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$35[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$34[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 2111 : 
; 2112 : 					SetMaxRollDelta(75.0F); // don't roll too much

	push	ecx
	movss	xmm0, DWORD PTR __real@42960000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta

; 2113 : 					SimpleTrack(SimpleTrackSpd, (af->MinVcas() * 1.2f)); // fly as slow as possible ~ 178 kts

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv2757[ebp]
	movss	xmm0, DWORD PTR tv2757[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrack@DigitalBrain@@IAEXW4SimpleTrackMode@1@M@Z ; DigitalBrain::SimpleTrack

; 2114 : 					SetMaxRollDelta(100.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta

; 2115 : 					break;

	jmp	$LN118@TakeOff
$LN41@TakeOff:

; 2116 : 					}
; 2117 : 
; 2118 : 				}
; 2119 : 			}
; 2120 : 		}
; 2121 : 		else

	jmp	$LN21@TakeOff
$LN46@TakeOff:

; 2122 : 		// In the air and ready to go
; 2123 : 		if ( af->z - af->groundZ < -200.0F || (fabs(xft) < 200.0F && fabs(yft) < 200.0F) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [ecx+1116]
	subss	xmm0, DWORD PTR [eax+1272]
	movss	xmm1, DWORD PTR __real@c3480000
	comiss	xmm1, xmm0
	ja	SHORT $LN20@TakeOff
	push	ecx
	movss	xmm0, DWORD PTR _xft$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2770[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR tv2770[ebp]
	jbe	$LN21@TakeOff
	push	ecx
	movss	xmm0, DWORD PTR _yft$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2777[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR tv2777[ebp]
	jbe	$LN21@TakeOff
$LN20@TakeOff:

; 2124 : 		{
; 2125 : 			 onStation = NotThereYet;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+132], 0

; 2126 : 			 if(isWing)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN19@TakeOff

; 2127 : 				self->curWaypoint = self->curWaypoint->GetNextWP();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+728], eax

; 2128 : 			else

	jmp	SHORT $LN18@TakeOff
$LN19@TakeOff:

; 2129 : 				SelectNextWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectNextWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::SelectNextWaypoint
$LN18@TakeOff:

; 2130 : 			 atcstatus = noATC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 0

; 2131 : 			 SendATCMsg(atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 2132 : #ifdef DAVE_DBG
; 2133 : 			 SetLabel(self);
; 2134 : #endif
; 2135 : 			
; 2136 : 			 if (isWing)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN17@TakeOff

; 2137 : 				AiRejoin(NULL, AI_TAKEOFF); // JPO actually a takeoff signal

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z ; DigitalBrain::AiRejoin
$LN17@TakeOff:

; 2138 : 			 airbase = self->LandingAirbase(); // JPO - now we set to go home

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?LandingAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ; AircraftClass::LandingAirbase
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], edx
	mov	DWORD PTR [ecx+312], eax
$LN21@TakeOff:

; 2139 : 		}
; 2140 : 		
; 2141 : 		TrackPoint(0.0F, (af->MinVcas() + 50.0F) * KNOTS_TO_FTPSEC);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv2800[ebp]
	movss	xmm0, DWORD PTR tv2800[ebp]
	addss	xmm0, DWORD PTR __real@42480000
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)

; 2142 : 		break;

	jmp	$LN118@TakeOff
$LN16@TakeOff:

; 2143 : 
; 2144 : 	//////////////////////////////////////////////////////////////////////////////////////
; 2145 : 	case tEmerStop:
; 2146 : 		desiredSpeed = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+336], xmm0

; 2147 : 		if(waittimer < SimLibElapsedTime)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN15@TakeOff

; 2148 : 		{
; 2149 : 			SendATCMsg(atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 2150 : 			waittimer = CalcWaitTime(Airbase->brain);

	mov	edx, DWORD PTR _Airbase$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcWaitTime@DigitalBrain@@QAEHPAVATCBrain@@@Z ; DigitalBrain::CalcWaitTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
$LN15@TakeOff:

; 2151 : 		}
; 2152 : 
; 2153 : 		if(!isWing || (flightLead && flightLead->OnGround()))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN13@TakeOff
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	$LN10@TakeOff
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+708]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+708]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN10@TakeOff
$LN13@TakeOff:

; 2154 : 		{
; 2155 : 			while(Airbase->brain->IsOnRunway(trackX, trackY))

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+152]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+148]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN11@TakeOff

; 2156 : 			{			
; 2157 : 				OffsetTrackPoint(20.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2158 : 				desiredSpeed = 20.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [ecx+336], xmm0

; 2159 : 			}

	jmp	SHORT $LN13@TakeOff
$LN11@TakeOff:

; 2160 : 
; 2161 : 			if(Airbase->brain->IsOnRunway(self) && self->GetVt() < 5.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN10@TakeOff
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv2842[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR tv2842[ebp]
	jbe	SHORT $LN10@TakeOff

; 2162 : 			{
; 2163 : 				OffsetTrackPoint(20.0F, rightRunway);

	push	8
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint

; 2164 : 				desiredSpeed = 20.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [ecx+336], xmm0
$LN10@TakeOff:

; 2165 : 			}
; 2166 : 		}
; 2167 : 		
; 2168 : 		if (fabs(trackX - af->x) > TAXI_CHECK_DIST || fabs(trackY - af->y) > TAXI_CHECK_DIST )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+148]
	subss	xmm0, DWORD PTR [eax+1108]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2855[ebp]
	movss	xmm0, DWORD PTR tv2855[ebp]
	comiss	xmm0, DWORD PTR __real@42700000
	ja	SHORT $LN8@TakeOff
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR [eax+1112]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv2863[ebp]
	movss	xmm0, DWORD PTR tv2863[ebp]
	comiss	xmm0, DWORD PTR __real@42700000
	jbe	SHORT $LN9@TakeOff
$LN8@TakeOff:

; 2169 : 		{
; 2170 : 			inTheWay = CheckTaxiTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	mov	DWORD PTR _inTheWay$[ebp], eax

; 2171 : 			if ( inTheWay )

	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	SHORT $LN7@TakeOff

; 2172 : 			{
; 2173 : 				if(isWing)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN6@TakeOff

; 2174 : 					DealWithBlocker(inTheWay, Airbase);

	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DealWithBlocker@DigitalBrain@@QAEXPAVSimBaseClass@@PAVObjectiveClass@@@Z ; DigitalBrain::DealWithBlocker

; 2175 : 				else

	jmp	SHORT $LN5@TakeOff
$LN6@TakeOff:

; 2176 : 					desiredSpeed = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+336], xmm0
$LN5@TakeOff:

; 2177 : 			}
; 2178 : 			else

	jmp	SHORT $LN4@TakeOff
$LN7@TakeOff:

; 2179 : 			{
; 2180 : 				//default speed
; 2181 : 				CalculateTaxiSpeed(MoveAlong);

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateTaxiSpeed@DigitalBrain@@QAEMM@Z ; DigitalBrain::CalculateTaxiSpeed
	fstp	ST(0)
$LN4@TakeOff:

; 2182 : 			}
; 2183 : 		}
; 2184 : 		else {

	jmp	SHORT $LN3@TakeOff
$LN9@TakeOff:

; 2185 : 			ChooseNextPoint(Airbase);

	mov	eax, DWORD PTR _Airbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChooseNextPoint@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::ChooseNextPoint
$LN3@TakeOff:

; 2186 : 		}
; 2187 : 
; 2188 : 		SimpleGroundTrack(desiredSpeed);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 2189 : 		break;

	jmp	SHORT $LN118@TakeOff
$LN2@TakeOff:

; 2190 : 
; 2191 : 	//////////////////////////////////////////////////////////////////////////////////////
; 2192 : 	case tTaxiBack:
; 2193 : 		//this will cause them to taxi back, will only occur if ordered by ATC
; 2194 : 		TaxiBack(Airbase);

	mov	edx, DWORD PTR _Airbase$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaxiBack@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ; DigitalBrain::TaxiBack
$LN1@TakeOff:
$LN118@TakeOff:

; 2195 : 		break;
; 2196 : 
; 2197 : 	default:
; 2198 : 		break;
; 2199 : 	}
; 2200 : 	// COBRA - RED - Apply few randomnes to AI
; 2201 : 	RandomStuff(inTheWay);

	mov	eax, DWORD PTR _inTheWay$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RandomStuff@DigitalBrain@@IAEXPAVSimBaseClass@@@Z ; DigitalBrain::RandomStuff
$LN162@TakeOff:

; 2202 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN175@TakeOff:
	DD	$LN124@TakeOff
	DD	$LN125@TakeOff
	DD	$LN123@TakeOff
	DD	$LN127@TakeOff
	DD	$LN126@TakeOff
	DD	$LN121@TakeOff
	DD	$LN122@TakeOff
	DD	$LN128@TakeOff
$LN171@TakeOff:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	6
	npad	1
$LN176@TakeOff:
	DD	$LN117@TakeOff
	DD	$LN99@TakeOff
	DD	$LN16@TakeOff
	DD	$LN86@TakeOff
	DD	$LN95@TakeOff
	DD	$LN76@TakeOff
	DD	$LN73@TakeOff
	DD	$LN57@TakeOff
	DD	$LN50@TakeOff
	DD	$LN2@TakeOff
	DD	$LN1@TakeOff
$LN172@TakeOff:
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	10					; 0000000aH
	DB	6
	DB	7
	DB	8
	DB	9
	npad	2
$LN177@TakeOff:
	DD	$LN105@TakeOff
	DD	$LN109@TakeOff
	DD	$LN111@TakeOff
	DD	$LN101@TakeOff
$LN173@TakeOff:
	DB	0
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?TakeOff@DigitalBrain@@IAEXXZ$0:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?TakeOff@DigitalBrain@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TakeOff@DigitalBrain@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?TakeOff@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::TakeOff
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
$T2 = -1288						; size = 8
$T3 = -1280						; size = 8
tv4602 = -1272						; size = 8
tv4411 = -1264						; size = 8
tv4238 = -1256						; size = 8
tv4593 = -1248						; size = 8
_cit$4 = -1240						; size = 12
_Trig$ = -1228						; size = 8
_abXs$5 = -1220						; size = 4
_tx$6 = -1216						; size = 4
tv3909 = -1212						; size = 4
tv3284 = -1208						; size = 4
tv5302 = -1204						; size = 4
tv3482 = -1200						; size = 4
tv5294 = -1196						; size = 4
tv4052 = -1192						; size = 4
tv3651 = -1188						; size = 4
tv3278 = -1184						; size = 4
_tz$7 = -1180						; size = 4
tv3798 = -1176						; size = 4
_tx$8 = -1172						; size = 4
_tz$9 = -1168						; size = 4
_ty$10 = -1164						; size = 4
tv3612 = -1160						; size = 4
_tx$11 = -1156						; size = 4
tv3522 = -1152						; size = 4
_ty$12 = -1148						; size = 4
tv5172 = -1144						; size = 4
tv5131 = -1140						; size = 4
tv4133 = -1136						; size = 4
_tx$13 = -1132						; size = 4
tv4026 = -1128						; size = 4
_ty$14 = -1124						; size = 4
tv3934 = -1120						; size = 4
_tz$15 = -1116						; size = 4
_ty$16 = -1112						; size = 4
tv2797 = -1108						; size = 4
tv3819 = -1104						; size = 4
tv5063 = -1100						; size = 4
_ty$17 = -1096						; size = 4
tv5043 = -1092						; size = 4
tv3736 = -1088						; size = 4
tv5011 = -1084						; size = 4
tv3678 = -1080						; size = 4
tv4988 = -1076						; size = 4
tv3627 = -1072						; size = 4
tv4982 = -1068						; size = 4
tv3587 = -1064						; size = 4
tv4973 = -1060						; size = 4
tv3532 = -1056						; size = 4
tv4967 = -1052						; size = 4
tv3497 = -1048						; size = 4
tv5328 = -1044						; size = 4
tv3373 = -1040						; size = 4
tv4948 = -1036						; size = 4
tv3324 = -1032						; size = 4
tv4943 = -1028						; size = 4
tv5314 = -1024						; size = 4
tv5326 = -1020						; size = 4
tv4067 = -1016						; size = 4
tv4932 = -1012						; size = 4
tv5310 = -1008						; size = 4
tv4927 = -1004						; size = 4
_ty$18 = -1000						; size = 4
tv5324 = -996						; size = 4
_tz$19 = -992						; size = 4
tv4918 = -988						; size = 4
tv5306 = -984						; size = 4
tv4913 = -980						; size = 4
tv3893 = -976						; size = 4
tv5322 = -972						; size = 4
tv3881 = -968						; size = 4
tv4905 = -964						; size = 4
tv3833 = -960						; size = 4
tv4900 = -956						; size = 4
tv5300 = -952						; size = 4
tv4886 = -948						; size = 4
tv3794 = -944						; size = 4
_heading$ = -940					; size = 4
tv3783 = -936						; size = 4
tv4859 = -932						; size = 4
tv3744 = -928						; size = 4
tv4852 = -924						; size = 4
_tx$20 = -920						; size = 4
tv4846 = -916						; size = 4
tv3682 = -912						; size = 4
_tx$21 = -908						; size = 4
tv5288 = -904						; size = 4
_ty$22 = -900						; size = 4
tv3631 = -896						; size = 4
_tz$23 = -892						; size = 4
tv5284 = -888						; size = 4
tv4797 = -884						; size = 4
tv3595 = -880						; size = 4
_tx$24 = -876						; size = 4
_tx$25 = -872						; size = 4
_ty$26 = -868						; size = 4
tv5280 = -864						; size = 4
_tz$27 = -860						; size = 4
tv3528 = -856						; size = 4
tv4774 = -852						; size = 4
tv3501 = -848						; size = 4
_rx$28 = -844						; size = 4
tv5176 = -840						; size = 4
_tx$29 = -836						; size = 4
_tx$30 = -832						; size = 4
_ty$31 = -828						; size = 4
tv3368 = -824						; size = 4
_tz$32 = -820						; size = 4
_mini$ = -816						; size = 4
_fp$33 = -812						; size = 4
tv3307 = -808						; size = 4
tv4712 = -804						; size = 4
tv4150 = -800						; size = 4
_finalZ$ = -796						; size = 4
tv4139 = -792						; size = 4
tv4625 = -788						; size = 4
tv4075 = -784						; size = 4
tv4586 = -780						; size = 4
tv5312 = -776						; size = 4
tv4569 = -772						; size = 4
tv4046 = -768						; size = 4
tv4562 = -764						; size = 4
tv4032 = -760						; size = 4
_tx$34 = -756						; size = 4
_tx$35 = -752						; size = 4
_ty$36 = -748						; size = 4
_tz$37 = -744						; size = 4
tv4544 = -740						; size = 4
_ty$38 = -736						; size = 4
_tx$39 = -732						; size = 4
tv5308 = -728						; size = 4
_ty$40 = -724						; size = 4
tv3928 = -720						; size = 4
_tz$41 = -716						; size = 4
tv3915 = -712						; size = 4
_fp$42 = -708						; size = 4
tv3899 = -704						; size = 4
tv4505 = -700						; size = 4
_tx$43 = -696						; size = 4
tv4499 = -692						; size = 4
_abYs$44 = -688						; size = 4
tv4492 = -684						; size = 4
tv3875 = -680						; size = 4
tv4486 = -676						; size = 4
tv3839 = -672						; size = 4
tv4479 = -668						; size = 4
tv3825 = -664						; size = 4
tv4473 = -660						; size = 4
tv3807 = -656						; size = 4
tv4468 = -652						; size = 4
tv3803 = -648						; size = 4
tv4462 = -644						; size = 4
tv5298 = -640						; size = 4
tv4456 = -636						; size = 4
_tx$45 = -632						; size = 4
tv4450 = -628						; size = 4
tv5296 = -624						; size = 4
tv4445 = -620						; size = 4
tv3777 = -616						; size = 4
tv4439 = -612						; size = 4
tv3750 = -608						; size = 4
tv4432 = -604						; size = 4
tv5292 = -600						; size = 4
tv4426 = -596						; size = 4
tv3730 = -592						; size = 4
tv4421 = -588						; size = 4
_ty$46 = -584						; size = 4
_tx$47 = -580						; size = 4
tv3695 = -576						; size = 4
_ty$48 = -572						; size = 4
tv5290 = -568						; size = 4
_tz$49 = -564						; size = 4
tv3673 = -560						; size = 4
tv4371 = -556						; size = 4
tv3669 = -552						; size = 4
tv5320 = -548						; size = 4
tv3645 = -544						; size = 4
tv4350 = -540						; size = 4
tv5286 = -536						; size = 4
tv4344 = -532						; size = 4
tv3622 = -528						; size = 4
tv4332 = -524						; size = 4
tv3618 = -520						; size = 4
tv4326 = -516						; size = 4
tv3601 = -512						; size = 4
tv4319 = -508						; size = 4
tv5282 = -504						; size = 4
tv4313 = -500						; size = 4
tv3581 = -496						; size = 4
tv4306 = -492						; size = 4
_ty$50 = -488						; size = 4
tv4300 = -484						; size = 4
tv3541 = -480						; size = 4
tv4295 = -476						; size = 4
tv3537 = -472						; size = 4
tv4289 = -468						; size = 4
tv5182 = -464						; size = 4
tv4283 = -460						; size = 4
tv5180 = -456						; size = 4
tv4277 = -452						; size = 4
tv3516 = -448						; size = 4
tv4272 = -444						; size = 4
tv5178 = -440						; size = 4
tv4266 = -436						; size = 4
tv3492 = -432						; size = 4
tv4259 = -428						; size = 4
tv3488 = -424						; size = 4
tv4253 = -420						; size = 4
tv3476 = -416						; size = 4
tv4248 = -412						; size = 4
_ty$51 = -408						; size = 4
tv5318 = -404						; size = 4
tv5174 = -400						; size = 4
tv4226 = -396						; size = 4
tv3363 = -392						; size = 4
tv4220 = -388						; size = 4
tv3358 = -384						; size = 4
tv4190 = -380						; size = 4
tv3330 = -376						; size = 4
tv4182 = -372						; size = 4
tv3318 = -368						; size = 4
tv5316 = -364						; size = 4
tv3299 = -360						; size = 4
tv4167 = -356						; size = 4
tv4161 = -352						; size = 4
tv5304 = -348						; size = 4
_distland$ = -344					; size = 4
tv1672 = -340						; size = 4
tv367 = -336						; size = 4
tv1857 = -332						; size = 4
tv2846 = -328						; size = 4
_tz$52 = -324						; size = 4
tv2779 = -320						; size = 4
tv327 = -316						; size = 4
tv2688 = -312						; size = 4
tv4235 = -308						; size = 4
tv2574 = -304						; size = 4
tv1858 = -300						; size = 4
tv2556 = -296						; size = 4
tv1824 = -292						; size = 4
tv2094 = -288						; size = 4
tv1673 = -284						; size = 4
tv2091 = -280						; size = 4
tv1639 = -276						; size = 4
tv2078 = -272						; size = 4
_tz$53 = -268						; size = 4
tv4598 = -264						; size = 4
tv4589 = -260						; size = 4
tv4408 = -256						; size = 4
_abXg$54 = -252						; size = 2
_gx$55 = -248						; size = 2
_gy$56 = -244						; size = 2
_abYg$57 = -240						; size = 2
_x$ = -236						; size = 4
_maxi$ = -232						; size = 4
_y$ = -228						; size = 4
_baseX$ = -224						; size = 4
_baseY$ = -220						; size = 4
tv2328 = -216						; size = 4
_component$ = -212					; size = 4
_rely$ = -208						; size = 4
_z$ = -204						; size = 4
_cosAngle$ = -200					; size = 4
_relx$ = -196						; size = 4
_testDist$ = -192					; size = 4
_leader$ = -188						; size = 4
_finalY$ = -184						; size = 4
_deltaTime$ = -180					; size = 4
_finalX$ = -176						; size = 4
_sinHdg$ = -172						; size = 4
_cosHdg$ = -168						; size = 4
_dist$ = -164						; size = 4
_minSpeed$ = -160					; size = 4
_inTheWay$ = -156					; size = 4
_speed$ = -152						; size = 4
_minZ$ = -148						; size = 4
_gAvoidZ$ = -144					; size = 4
_dx$ = -140						; size = 4
_dy$ = -136						; size = 4
_abObj$ = -132						; size = 4
_this$ = -128						; size = 4
_pos$58 = -124						; size = 12
_label$59 = -112					; size = 96
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Land@DigitalBrain@@IAEXXZ PROC				; DigitalBrain::Land
; _this$ = ecx

; 341  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Land@DigitalBrain@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1276				; 000004fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 342  : 	SimBaseClass *inTheWay = NULL;

	mov	DWORD PTR _inTheWay$[ebp], 0

; 343  : 	ObjectiveClass *abObj = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	mov	edx, DWORD PTR [eax+308]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _abObj$[ebp], eax

; 344  : 	AircraftClass *leader = NULL;

	mov	DWORD PTR _leader$[ebp], 0

; 345  : 	AircraftClass *component = NULL;

	mov	DWORD PTR _component$[ebp], 0

; 346  : 	float cosAngle, heading, deltaTime, testDist, distland;
; 347  : 	ulong mini, maxi;
; 348  : 	float baseX, baseY, finalX, finalY, finalZ, x, y, z, dx, 
; 349  : 		dy, dist, speed, minSpeed, relx, rely, cosHdg, sinHdg;
; 350  : 	mlTrig	Trig;
; 351  : 	
; 352  : 	if (!abObj){

	cmp	DWORD PTR _abObj$[ebp], 0
	jne	SHORT $LN179@Land

; 353  : 		//need to find something or we don't know where to go
; 354  : 		if ( self->af->GetSimpleMode()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetSimpleMode@AirframeClass@@QAEHXZ	; AirframeClass::GetSimpleMode
	test	eax, eax
	je	SHORT $LN178@Land

; 355  : 			SimpleGoToCurrentWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGoToCurrentWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::SimpleGoToCurrentWaypoint

; 356  : 		}
; 357  : 		else {

	jmp	SHORT $LN177@Land
$LN178@Land:

; 358  : 			GoToCurrentWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoToCurrentWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::GoToCurrentWaypoint
$LN177@Land:

; 359  : 		}
; 360  : 		return;

	jmp	$LN180@Land
	jmp	$LN175@Land
$LN179@Land:

; 361  : 	}
; 362  : 
; 363  : 	// RV - Biker - If we're about to land on carrier set new track point
; 364  : 	else if (!abObj->IsObjective() || !abObj->brain){

	mov	edx, DWORD PTR _abObj$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	edx, DWORD PTR [eax+236]
	call	edx
	test	eax, eax
	je	SHORT $LN174@Land
	mov	eax, DWORD PTR _abObj$[ebp]
	cmp	DWORD PTR [eax+240], 0
	jne	$LN175@Land
$LN174@Land:

; 365  : 		if ((self->curWaypoint->GetWPAction() == WP_LAND) && !self->IsPlayer()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+728]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	$LN171@Land
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	$LN171@Land

; 366  : 			if (self->curWaypoint->GetPrevWP() != NULL) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+728]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	test	eax, eax
	je	SHORT $LN172@Land

; 367  : 				GridIndex abXg, abYg;
; 368  : 				float abXs, abYs;
; 369  : 				abObj->GetLocation(&abXg, &abYg);

	lea	eax, DWORD PTR _abYg$57[ebp]
	push	eax
	lea	ecx, DWORD PTR _abXg$54[ebp]
	push	ecx
	mov	ecx, DWORD PTR _abObj$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 370  : 				abXs = GridToSim(abXg);

	movzx	edx, WORD PTR _abXg$54[ebp]
	push	edx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR _abXs$5[ebp]

; 371  : 				abYs = GridToSim(abYg);

	movzx	eax, WORD PTR _abYg$57[ebp]
	push	eax
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	fstp	DWORD PTR _abYs$44[ebp]

; 372  : 
; 373  : 				SetTrackPoint(abXs, abYs, self->ZPos());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _abYs$44[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _abXs$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint
$LN172@Land:

; 374  : 			}
; 375  : 
; 376  : 			dx = self->XPos() - trackX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3278[ebp]
	movss	xmm0, DWORD PTR tv3278[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 377  : 			dy = self->YPos() - trackY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3284[ebp]
	movss	xmm0, DWORD PTR tv3284[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 378  : 			if (dx*dx + dy*dy < 3000.0F*3000.0F){

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@4b095440
	comiss	xmm1, xmm0
	jbe	SHORT $LN171@Land

; 379  : 				//for carriers we just disappear when we get close enough
; 380  : 				//do carrier landings for F-18
; 381  : 				RegroupAircraft (self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4

; 382  : 				return;

	jmp	$LN180@Land
$LN171@Land:

; 383  : 			}
; 384  : 		}
; 385  : 
; 386  : 		if ( self->af->GetSimpleMode()){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetSimpleMode@AirframeClass@@QAEHXZ	; AirframeClass::GetSimpleMode
	test	eax, eax
	je	SHORT $LN170@Land

; 387  : 			SimpleGoToCurrentWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGoToCurrentWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::SimpleGoToCurrentWaypoint

; 388  : 		}
; 389  : 		else {

	jmp	SHORT $LN169@Land
$LN170@Land:

; 390  : 			GoToCurrentWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoToCurrentWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::GoToCurrentWaypoint
$LN169@Land:

; 391  : 		}
; 392  : 		return;

	jmp	$LN180@Land
$LN175@Land:

; 393  : 	}
; 394  : 
; 395  : 	if (self->IsSetFlag(ON_GROUND) && (af->Fuel() <= 0.0F) && (self->GetVt() < 5.0F)){

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN167@Land
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv3299[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv3299[ebp]
	jb	SHORT $LN167@Land
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv3307[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR tv3307[ebp]
	jbe	SHORT $LN167@Land

; 396  : 		if(!self->IsPlayer()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN167@Land

; 397  : 			RegroupAircraft(self); //no gas get him out of the way

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4

; 398  : 			// sfr: isnt this enough to return
; 399  : 			// added return
; 400  : 			return;

	jmp	$LN180@Land
$LN167@Land:

; 401  : 		}
; 402  : 	}
; 403  : 
; 404  : 	SetDebugLabel(abObj);

	mov	eax, DWORD PTR _abObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDebugLabel@DigitalBrain@@QAEXPAVObjectiveClass@@@Z ; DigitalBrain::SetDebugLabel

; 405  : 
; 406  : 	dx = self->XPos() - trackX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3318[ebp]
	movss	xmm0, DWORD PTR tv3318[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [edx+148]
	movss	DWORD PTR _dx$[ebp], xmm0

; 407  : 	dy = self->YPos() - trackY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3324[ebp]
	movss	xmm0, DWORD PTR tv3324[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [ecx+152]
	movss	DWORD PTR _dy$[ebp], xmm0

; 408  : 	speed = af->MinVcas() * KNOTS_TO_FTPSEC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv3330[ebp]
	movss	xmm0, DWORD PTR tv3330[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _speed$[ebp], xmm0

; 409  : 
; 410  : 	if (rwIndex > 0){ 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+304], 0
	jle	SHORT $LN166@Land

; 411  : 		// jpo - only valid if we have a runway.
; 412  : 		cosAngle = abObj->brain->DetermineAngle(self, rwIndex, atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 413  : 		abObj->brain->CalculateMinMaxTime(self, rwIndex, atcstatus, &mini, &maxi, cosAngle);

	push	ecx
	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _maxi$[ebp]
	push	edx
	lea	eax, DWORD PTR _mini$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ; ATCBrain::CalculateMinMaxTime

; 414  : 	}
; 415  : 	else {

	jmp	SHORT $LN165@Land
$LN166@Land:

; 416  : 		cosAngle = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cosAngle$[ebp], xmm0

; 417  : 		mini = maxi = 0;

	mov	DWORD PTR _maxi$[ebp], 0
	mov	edx, DWORD PTR _maxi$[ebp]
	mov	DWORD PTR _mini$[ebp], edx
$LN165@Land:

; 418  : 	}
; 419  : 	// edg: project out 1 sec to get alt for possible ground avoid
; 420  :     float gAvoidZ = OTWDriver.GetGroundLevel( self->XPos() + self->XDelta(),
; 421  : 	   								  self->YPos() + self->YDelta() );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3358[ebp]
	movss	xmm0, DWORD PTR tv3358[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv5172[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv3363[ebp]
	movss	xmm0, DWORD PTR tv5172[ebp]
	addss	xmm0, DWORD PTR tv3363[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3368[ebp]
	movss	xmm0, DWORD PTR tv3368[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv5174[ebp], xmm0
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv3373[ebp]
	movss	xmm0, DWORD PTR tv5174[ebp]
	addss	xmm0, DWORD PTR tv3373[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _gAvoidZ$[ebp]

; 422  : 	float minZ = abObj->brain->GetAltitude(self, atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _minZ$[ebp]

; 423  : 
; 424  : 	switch(atcstatus)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR tv327[ebp], ecx
	cmp	DWORD PTR tv327[ebp], 17		; 00000011H
	ja	$LN1@Land
	mov	edx, DWORD PTR tv327[ebp]
	jmp	DWORD PTR $LN211@Land[edx*4]
$LN162@Land:

; 425  : 	{
; 426  : 		case noATC:
; 427  : 			// sfr: massive change here, we only process if we have a valid runway
; 428  : 			rwIndex = abObj->brain->FindBestLandingRunway(self, TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 429  : 			if(rwIndex == 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+304], 0
	jne	$LN158@Land

; 430  : 				// no runway (rwIndex == 0), try divert
; 431  : 				airbase = self->DivertAirbase();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?DivertAirbase@AircraftClass@@QAE?AVVU_ID@@XZ ; AircraftClass::DivertAirbase
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], edx
	mov	DWORD PTR [ecx+312], eax

; 432  : 				abObj = static_cast<ObjectiveClass*>(vuDatabase->Find(airbase));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+312]
	push	eax
	mov	ecx, DWORD PTR [edx+308]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _abObj$[ebp], eax

; 433  : 				rwIndex = (abObj == NULL) ? 0 : abObj->brain->FindBestLandingRunway(self, TRUE);

	cmp	DWORD PTR _abObj$[ebp], 0
	jne	SHORT $LN182@Land
	mov	DWORD PTR tv367[ebp], 0
	jmp	SHORT $LN183@Land
$LN182@Land:
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	DWORD PTR tv367[ebp], eax
$LN183@Land:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv367[ebp]
	mov	DWORD PTR [edx+304], eax

; 434  : 				if(rwIndex == 0){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+304], 0
	jne	$LN158@Land

; 435  : 					// divert too was out of order, try a nearby one
; 436  : 					// sfr: fixing xy order
; 437  : 					GridIndex gx, gy;
; 438  : 					//gx = SimToGrid(self->YPos());
; 439  : 					//gy = SimToGrid(self->XPos());
; 440  : 					::vector pos = { self->XPos(), self->YPos() };

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _pos$58[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _pos$58[ebp+4]
	xor	ecx, ecx
	mov	DWORD PTR _pos$58[ebp+8], ecx

; 441  : 					ConvertSimToGrid(&pos, &gx, &gy);

	lea	edx, DWORD PTR _gy$56[ebp]
	push	edx
	lea	eax, DWORD PTR _gx$55[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$58[ebp]
	push	ecx
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH

; 442  : 					abObj = FindNearestFriendlyRunway(self->GetTeam(), gx, gy);

	movzx	edx, WORD PTR _gy$56[ebp]
	push	edx
	movzx	eax, WORD PTR _gx$55[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?FindNearestFriendlyRunway@@YAPAVObjectiveClass@@EFF@Z ; FindNearestFriendlyRunway
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _abObj$[ebp], eax

; 443  : 					if(abObj){

	cmp	DWORD PTR _abObj$[ebp], 0
	je	SHORT $LN159@Land

; 444  : 						airbase = abObj->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _abObj$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+308], ecx
	mov	DWORD PTR [eax+312], edx

; 445  : 						rwIndex = abObj->brain->FindBestLandingRunway(self, TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax
$LN159@Land:

; 446  : 					}
; 447  : 					if (rwIndex == 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+304], 0
	jne	SHORT $LN158@Land

; 448  : 						// even then failed... navigate to waypoint then...
; 449  : 						if ( af->GetSimpleMode()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetSimpleMode@AirframeClass@@QAEHXZ	; AirframeClass::GetSimpleMode
	test	eax, eax
	je	SHORT $LN157@Land

; 450  : 							SimpleGoToCurrentWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGoToCurrentWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::SimpleGoToCurrentWaypoint

; 451  : 						}
; 452  : 						else {

	jmp	SHORT $LN156@Land
$LN157@Land:

; 453  : 							GoToCurrentWaypoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoToCurrentWaypoint@DigitalBrain@@IAEXXZ ; DigitalBrain::GoToCurrentWaypoint
$LN156@Land:

; 454  : 						}
; 455  : 						return;

	jmp	$LN180@Land
$LN158@Land:

; 456  : 					}
; 457  : 				}
; 458  : 			}
; 459  : 
; 460  : 			// if got here, rwIndex must be valid
; 461  : 			float tx, ty;
; 462  : 			abObj->brain->FindFinalPt(self, rwIndex, &tx, &ty);

	lea	ecx, DWORD PTR _ty$51[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$30[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 463  : 			SetTrackPoint(tx, ty);

	push	ecx
	movss	xmm0, DWORD PTR _ty$51[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$30[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 464  : 			trackZ = abObj->brain->GetAltitude(self, atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+156]

; 465  : 			CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 466  : 			waittimer = SimLibElapsedTime + 2 * TAKEOFF_TIME_DELTA;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 20000				; 00004e20H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx

; 467  : 			TrackPointLanding( af->CalcTASfromCAS(af->MinVcas() * 1.2F) * KNOTS_TO_FTPSEC);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv3476[ebp]
	movss	xmm0, DWORD PTR tv3476[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3482[ebp]
	movss	xmm0, DWORD PTR tv3482[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 468  : 			dx = self->XPos() - abObj->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3488[ebp]
	movss	xmm0, DWORD PTR tv3488[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5176[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3492[ebp]
	movss	xmm0, DWORD PTR tv5176[ebp]
	subss	xmm0, DWORD PTR tv3492[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 469  : 			dy = self->YPos() - abObj->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3497[ebp]
	movss	xmm0, DWORD PTR tv3497[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5178[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3501[ebp]
	movss	xmm0, DWORD PTR tv5178[ebp]
	subss	xmm0, DWORD PTR tv3501[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 470  : 			//me123
; 471  : 			if (
; 472  : 				curMode != LandingMode &&
; 473  : 				curMode != TakeoffMode &&
; 474  : 				curMode != WaypointMode &&
; 475  : 				curMode != RTBMode
; 476  : 			){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 5
	je	SHORT $LN155@Land
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 0
	je	SHORT $LN155@Land
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 22			; 00000016H
	je	SHORT $LN155@Land
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 19			; 00000013H
	je	SHORT $LN155@Land

; 477  : 				break;

	jmp	$LN163@Land
$LN155@Land:

; 478  : 			}
; 479  : 
; 480  : 			if(dx*dx + dy*dy < APPROACH_RANGE * NM_TO_FT * NM_TO_FT * 0.95F){

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@50eb3111
	comiss	xmm1, xmm0
	jbe	SHORT $LN154@Land

; 481  : 				atcstatus = lReqClearance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 1

; 482  : 				if( !isWing )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN153@Land

; 483  : 					SendATCMsg(lReqClearance);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN153@Land:

; 484  : 			}
; 485  : 			else {

	jmp	SHORT $LN152@Land
$LN154@Land:

; 486  : 				atcstatus = lIngressing;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 3

; 487  : 				SendATCMsg(lIngressing);

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN152@Land:

; 488  : 			}
; 489  : 		
; 490  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3516[ebp]
	movss	xmm0, DWORD PTR tv3516[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN151@Land

; 491  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv5180[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3522[ebp]
	movss	xmm0, DWORD PTR tv3522[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5180[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm1
$LN151@Land:

; 492  : 			}
; 493  : 		break;

	jmp	$LN163@Land
$LN150@Land:

; 494  : 
; 495  : 		//////////////////////////////////////////////////////////////////////////////////////
; 496  : 		case lIngressing:
; 497  : 			dx = self->XPos() - abObj->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3528[ebp]
	movss	xmm0, DWORD PTR tv3528[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5182[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3532[ebp]
	movss	xmm0, DWORD PTR tv5182[ebp]
	subss	xmm0, DWORD PTR tv3532[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 498  : 			dy = self->YPos() - abObj->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3537[ebp]
	movss	xmm0, DWORD PTR tv3537[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5280[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3541[ebp]
	movss	xmm0, DWORD PTR tv5280[ebp]
	subss	xmm0, DWORD PTR tv3541[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 499  : 			distland = sqrtf(dx*dx+dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _distland$[ebp]

; 500  : 
; 501  : 			if(distland < 30.0f * NM_TO_FT){

	movss	xmm0, DWORD PTR __real@48320395
	comiss	xmm0, DWORD PTR _distland$[ebp]
	jbe	$LN149@Land

; 502  : 				float tx, ty, tz;
; 503  : 				rwIndex = abObj->brain->FindBestLandingRunway(self, TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 504  : 				abObj->brain->FindFinalPt(self, rwIndex, &tx, &ty);

	lea	eax, DWORD PTR _ty$50[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$25[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 505  : 				tz = abObj->brain->GetAltitude(self, atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$7[ebp]

; 506  : 				SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$7[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$50[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$25[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 507  : 				CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 508  : 				atcstatus = lReqClearance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 1

; 509  : 				if( !isWing )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN148@Land

; 510  : 					SendATCMsg(lReqClearance);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN148@Land:

; 511  : 				waittimer = SimLibElapsedTime + LAND_TIME_DELTA;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx
$LN149@Land:

; 512  : 			}
; 513  : 
; 514  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3581[ebp]
	movss	xmm0, DWORD PTR tv3581[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN147@Land

; 515  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5282[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3587[ebp]
	movss	xmm0, DWORD PTR tv3587[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5282[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN147@Land:

; 516  : 			}
; 517  : 
; 518  : 			//Cobra
; 519  : 			if (distland * FT_TO_NM < 15.0F){

	movss	xmm0, DWORD PTR _distland$[ebp]
	mulss	xmm0, DWORD PTR __real@392c987a
	movss	xmm1, DWORD PTR __real@41700000
	comiss	xmm1, xmm0
	jbe	SHORT $LN146@Land

; 520  : 				TrackPointLanding( af->CalcTASfromCAS(af->MinVcas() * 1.2F)*KNOTS_TO_FTPSEC);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv3595[ebp]
	movss	xmm0, DWORD PTR tv3595[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3601[ebp]
	movss	xmm0, DWORD PTR tv3601[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 521  : 			}
; 522  : 			else {

	jmp	SHORT $LN145@Land
$LN146@Land:

; 523  : 				TrackPointLanding( af->CalcTASfromCAS(af->CornerVcas())*KNOTS_TO_FTPSEC);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CornerVcas@AirframeClass@@QAEMXZ	; AirframeClass::CornerVcas
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3612[ebp]
	movss	xmm0, DWORD PTR tv3612[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)
$LN145@Land:

; 524  : 			}
; 525  : 
; 526  : 
; 527  : 		break;

	jmp	$LN163@Land
$LN144@Land:

; 528  : 
; 529  : 		//////////////////////////////////////////////////////////////////////////////////////
; 530  : 		case lTakingPosition:
; 531  : 			//need to drag out formation
; 532  : 			//the atc will clear us when we get within range
; 533  : 			dx = self->XPos() - abObj->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3618[ebp]
	movss	xmm0, DWORD PTR tv3618[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5284[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3622[ebp]
	movss	xmm0, DWORD PTR tv5284[ebp]
	subss	xmm0, DWORD PTR tv3622[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 534  : 			dy = self->YPos() - abObj->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3627[ebp]
	movss	xmm0, DWORD PTR tv3627[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5286[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3631[ebp]
	movss	xmm0, DWORD PTR tv5286[ebp]
	subss	xmm0, DWORD PTR tv3631[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 535  : 			if(dx*dx + dy*dy < TOWER_RANGE * NM_TO_FT * NM_TO_FT * 0.5F && waittimer < SimLibElapsedTime)

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@502bec79
	comiss	xmm1, xmm0
	jbe	SHORT $LN143@Land
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN143@Land

; 536  : 			{
; 537  : 				atcstatus = lReqClearance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 1

; 538  : 				if( !isWing )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN142@Land

; 539  : 					SendATCMsg(lReqClearance);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN142@Land:

; 540  : 				waittimer = SimLibElapsedTime + LAND_TIME_DELTA;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx
$LN143@Land:

; 541  : 			}
; 542  : 			speed = af->CalcTASfromCAS(af->MinVcas() * 1.2F)*KNOTS_TO_FTPSEC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv3645[ebp]
	movss	xmm0, DWORD PTR tv3645[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3651[ebp]
	movss	xmm0, DWORD PTR tv3651[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _speed$[ebp], xmm0

; 543  : 
; 544  : 			if(((Unit)self->GetCampaignObject())->GetTotalVehicles() > 1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	eax, 1
	jle	$LN136@Land

; 545  : 			{
; 546  : 				{
; 547  : 					VuListIterator	cit(self->GetCampaignObject()->GetComponents());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _cit$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 548  : 					component = (AircraftClass*)cit.GetFirst();

	lea	ecx, DWORD PTR _cit$4[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _component$[ebp], eax
$LN140@Land:

; 549  : 					while(component && component->vehicleInUnit != self->vehicleInUnit){

	cmp	DWORD PTR _component$[ebp], 0
	je	SHORT $LN139@Land
	mov	edx, DWORD PTR _component$[ebp]
	movzx	eax, BYTE PTR [edx+664]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movzx	ecx, BYTE PTR [edx+664]
	cmp	eax, ecx
	je	SHORT $LN139@Land

; 550  : 						leader = component;

	mov	edx, DWORD PTR _component$[ebp]
	mov	DWORD PTR _leader$[ebp], edx

; 551  : 						component = (AircraftClass*)cit.GetNext();

	lea	ecx, DWORD PTR _cit$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _component$[ebp], eax

; 552  : 					}

	jmp	SHORT $LN140@Land
$LN139@Land:

; 553  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 554  : 
; 555  : 				if(leader && !mpActionFlags[AI_RTB]) // JB 010527 (from MN)

	cmp	DWORD PTR _leader$[ebp], 0
	je	$LN138@Land
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+760], 0
	jne	$LN138@Land

; 556  : 				{
; 557  : 					dx = self->XPos() - leader->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3669[ebp]
	movss	xmm0, DWORD PTR tv3669[ebp]
	mov	ecx, DWORD PTR _leader$[ebp]
	movss	DWORD PTR tv5288[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3673[ebp]
	movss	xmm0, DWORD PTR tv5288[ebp]
	subss	xmm0, DWORD PTR tv3673[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 558  : 					dy = self->YPos() - leader->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3678[ebp]
	movss	xmm0, DWORD PTR tv3678[ebp]
	mov	ecx, DWORD PTR _leader$[ebp]
	movss	DWORD PTR tv5290[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3682[ebp]
	movss	xmm0, DWORD PTR tv5290[ebp]
	subss	xmm0, DWORD PTR tv3682[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 559  : 					dist = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 560  : 
; 561  : 					if(dist < NM_TO_FT * NM_TO_FT)

	movss	xmm0, DWORD PTR __real@4c0cd705
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN137@Land

; 562  : 						speed = af->CalcTASfromCAS(af->MinVcas())*KNOTS_TO_FTPSEC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3695[ebp]
	movss	xmm0, DWORD PTR tv3695[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _speed$[ebp], xmm0
$LN137@Land:

; 563  : 
; 564  : 					SetTrackPoint(leader->XPos(), leader->YPos(), leader->ZPos());

	mov	ecx, DWORD PTR _leader$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _leader$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 565  : 				}
; 566  : 				else {

	jmp	$LN136@Land
$LN138@Land:

; 567  : 					float tx, ty, tz;
; 568  : 					abObj->brain->FindFinalPt(self, rwIndex, &tx, &ty);

	lea	eax, DWORD PTR _ty$46[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$20[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 569  : 					tz = abObj->brain->GetAltitude(self, lTakingPosition);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$9[ebp]

; 570  : 					SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$9[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$46[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$20[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint
$LN136@Land:

; 571  : 				}
; 572  : 			}
; 573  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3730[ebp]
	movss	xmm0, DWORD PTR tv3730[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN135@Land

; 574  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5292[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3736[ebp]
	movss	xmm0, DWORD PTR tv3736[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5292[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN135@Land:

; 575  : 			}
; 576  : 			TrackPointLanding(speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 577  : 		break;

	jmp	$LN163@Land
$LN134@Land:

; 578  : 
; 579  : 		//////////////////////////////////////////////////////////////////////////////////////
; 580  : 		case lReqClearance:
; 581  : 		case lReqEmerClearance:
; 582  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3744[ebp]
	movss	xmm0, DWORD PTR tv3744[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN133@Land

; 583  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5294[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3750[ebp]
	movss	xmm0, DWORD PTR tv3750[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5294[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN133@Land:

; 584  : 			}
; 585  : 			if(SimLibElapsedTime > waittimer){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	edx, DWORD PTR [ecx+344]
	jbe	$LN129@Land

; 586  : 				//we've been waiting too long, call again
; 587  : 				float tx, ty, tz;
; 588  : 				rwIndex = abObj->brain->FindBestLandingRunway(self, TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 589  : 				abObj->brain->FindFinalPt(self, rwIndex, &tx, &ty);

	lea	edx, DWORD PTR _ty$17[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$45[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 590  : 				tz = abObj->brain->GetAltitude(self, atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$52[ebp]

; 591  : 				if ( self->ZPos() - gAvoidZ > minZ ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3777[ebp]
	movss	xmm0, DWORD PTR tv3777[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN131@Land

; 592  : 					tz = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv5296[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3783[ebp]
	movss	xmm0, DWORD PTR tv3783[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5296[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _tz$52[ebp], xmm1
$LN131@Land:

; 593  : 				}
; 594  : 				SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$52[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$17[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$45[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 595  : 				CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 596  : 
; 597  : 				// JB 010802 RTBing AI aircraft won't land.
; 598  : 				dx = self->XPos() - abObj->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3794[ebp]
	movss	xmm0, DWORD PTR tv3794[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5298[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv3798[ebp]
	movss	xmm0, DWORD PTR tv5298[ebp]
	subss	xmm0, DWORD PTR tv3798[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 599  : 				dy = self->YPos() - abObj->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3803[ebp]
	movss	xmm0, DWORD PTR tv3803[ebp]
	mov	ecx, DWORD PTR _abObj$[ebp]
	movss	DWORD PTR tv5300[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv3807[ebp]
	movss	xmm0, DWORD PTR tv5300[ebp]
	subss	xmm0, DWORD PTR tv3807[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 600  : 				if(dx*dx + dy*dy < (TOWER_RANGE + 100) * NM_TO_FT * NM_TO_FT * 0.95F){

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@50bd75c0
	comiss	xmm1, xmm0
	jbe	SHORT $LN130@Land

; 601  : 					waittimer = SimLibElapsedTime + LAND_TIME_DELTA;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 60000				; 0000ea60H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 602  : 					SendATCMsg(lReqClearance);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 603  : 				}
; 604  : 				else {

	jmp	SHORT $LN129@Land
$LN130@Land:

; 605  : 					waittimer = SimLibElapsedTime + LAND_TIME_DELTA / 2;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx
$LN129@Land:

; 606  : 				}
; 607  : 			}
; 608  : 			//we're waiting to get a response back
; 609  : 			TrackPointLanding( af->CalcTASfromCAS(af->MinVcas() * 1.2F)*KNOTS_TO_FTPSEC);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv3819[ebp]
	movss	xmm0, DWORD PTR tv3819[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3825[ebp]
	movss	xmm0, DWORD PTR tv3825[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 610  : 			af->gearHandle = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0

; 611  : 		break;

	jmp	$LN163@Land
$LN128@Land:

; 612  : 
; 613  : 		//////////////////////////////////////////////////////////////////////////////////////
; 614  : 		case lAborted:
; 615  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3833[ebp]
	movss	xmm0, DWORD PTR tv3833[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN127@Land

; 616  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv5302[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3839[ebp]
	movss	xmm0, DWORD PTR tv3839[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5302[ebp]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+156], xmm1
$LN127@Land:

; 617  : 			}
; 618  : 
; 619  : 			if(dx*dx + dy*dy < 0.25F*NM_TO_FT*NM_TO_FT){

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@4b0cd705
	comiss	xmm1, xmm0
	jbe	$LN126@Land

; 620  : 				float tx, ty, tz;
; 621  : 				waittimer = SimLibElapsedTime + LAND_TIME_DELTA;			

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx

; 622  : 				rwIndex = abObj->brain->FindBestLandingRunway(self, TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 623  : 				abObj->brain->FindFinalPt(self, rwIndex, &tx, &ty);

	lea	edx, DWORD PTR _ty$16[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$43[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 624  : 				tz = abObj->brain->GetAltitude(self, lReqClearance);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$53[ebp]

; 625  : 				z = TheMap.GetMEA(trackX, trackY);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+152]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+148]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	fstp	DWORD PTR _z$[ebp]

; 626  : 				if ( self->ZPos() - gAvoidZ > minZ ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3875[ebp]
	movss	xmm0, DWORD PTR tv3875[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN125@Land

; 627  : 					tz = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv5304[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3881[ebp]
	movss	xmm0, DWORD PTR tv3881[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5304[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _tz$53[ebp], xmm1
$LN125@Land:

; 628  : 				}
; 629  : 				SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$53[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$16[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$43[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 630  : 				atcstatus = lReqClearance;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 1

; 631  : 				SendATCMsg(lReqClearance);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN126@Land:

; 632  : 			}
; 633  : 
; 634  : 			TrackPoint( 0.0F, af->CalcTASfromCAS(af->MinVcas() * 1.2F)*KNOTS_TO_FTPSEC);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv3893[ebp]
	movss	xmm0, DWORD PTR tv3893[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv3899[ebp]
	movss	xmm0, DWORD PTR tv3899[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)

; 635  : 			af->gearHandle = -1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+1556], xmm0

; 636  : 		break;

	jmp	$LN163@Land
$LN124@Land:

; 637  : 
; 638  : 		//////////////////////////////////////////////////////////////////////////////////////
; 639  : 		case lEmerHold:
; 640  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3909[ebp]
	movss	xmm0, DWORD PTR tv3909[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN123@Land

; 641  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv5306[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3915[ebp]
	movss	xmm0, DWORD PTR tv3915[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5306[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm1
$LN123@Land:

; 642  : 			}
; 643  : 
; 644  : 			if(waittimer < SimLibElapsedTime){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN122@Land

; 645  : 				atcstatus = lEmerHold;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 6

; 646  : 				SendATCMsg(lEmerHold);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 647  : 				waittimer = SimLibElapsedTime + LAND_TIME_DELTA;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 60000				; 0000ea60H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
$LN122@Land:

; 648  : 			}
; 649  : 			Loiter();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Loiter@DigitalBrain@@IAEXXZ		; DigitalBrain::Loiter

; 650  : 			af->gearHandle = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1556], xmm0

; 651  : 		break;

	jmp	$LN163@Land
$LN121@Land:

; 652  : 		//////////////////////////////////////////////////////////////////////////////////////
; 653  : 		case lHolding:
; 654  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3928[ebp]
	movss	xmm0, DWORD PTR tv3928[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN120@Land

; 655  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5308[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv3934[ebp]
	movss	xmm0, DWORD PTR tv3934[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5308[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN120@Land:

; 656  : 			}
; 657  : 
; 658  : 			if(rwtime < SimLibElapsedTime + maxi - CampaignSeconds * 5 ){

	mov	ecx, DWORD PTR _maxi$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	lea	eax, DWORD PTR [edx+ecx-5000]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+316], eax
	jae	$LN119@Land

; 659  : 				abObj->brain->FindFinalPt(self, rwIndex, &finalX, &finalY);

	lea	edx, DWORD PTR _finalY$[ebp]
	push	edx
	lea	eax, DWORD PTR _finalX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 660  : 				waittimer = rwtime + CampaignSeconds * 15; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	add	ecx, 15000				; 00003a98H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], ecx

; 661  : 				
; 662  : 				if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	$LN118@Land

; 663  : 				{
; 664  : 					abObj->brain->FindBasePt(self, rwIndex, finalX, finalY, &baseX, &baseY);

	lea	eax, DWORD PTR _baseY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _baseX$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 665  : 					float tx, ty, tz;
; 666  : 					atcstatus = abObj->brain->FindFirstLegPt(self, rwIndex, rwtime, baseX, baseY, TRUE, &tx, &ty);

	lea	ecx, DWORD PTR _ty$38[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$6[ebp]
	push	edx
	push	1
	push	ecx
	movss	xmm0, DWORD PTR _baseY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 667  : 					tz = abObj->brain->GetAltitude(self, atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$19[ebp]

; 668  : 					SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$19[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$38[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$6[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 669  : 					if(atcstatus != lHolding){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 7
	je	SHORT $LN117@Land

; 670  : 						SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN117@Land:

; 671  : 					}
; 672  : 					CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 673  : 				}
; 674  : 				else {

	jmp	$LN116@Land
$LN118@Land:

; 675  : 					float tx, ty, tz;
; 676  : 					atcstatus = abObj->brain->FindFirstLegPt(
; 677  : 						self, rwIndex, rwtime, finalX, finalY, FALSE, &tx, &ty
; 678  : 					);

	lea	ecx, DWORD PTR _ty$18[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$35[ebp]
	push	edx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 679  : 					tz = abObj->brain->GetAltitude(self, atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$37[ebp]

; 680  : 					SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$37[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$18[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$35[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 681  : 					if(atcstatus != lHolding){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 7
	je	SHORT $LN115@Land

; 682  : 						SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg
$LN115@Land:

; 683  : 					}
; 684  : 					CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)
$LN116@Land:

; 685  : 				}
; 686  : 				if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4026[ebp]
	movss	xmm0, DWORD PTR tv4026[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN114@Land

; 687  : 					trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5310[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4032[ebp]
	movss	xmm0, DWORD PTR tv4032[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5310[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN114@Land:

; 688  : 				}
; 689  : 
; 690  : 				if(atcstatus == lHolding){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 7
	jne	SHORT $LN113@Land

; 691  : 					Loiter();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Loiter@DigitalBrain@@IAEXXZ		; DigitalBrain::Loiter
$LN113@Land:

; 692  : 				}
; 693  : 			}
; 694  : 			else {

	jmp	SHORT $LN112@Land
$LN119@Land:

; 695  : 				Loiter();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Loiter@DigitalBrain@@IAEXXZ		; DigitalBrain::Loiter
$LN112@Land:

; 696  : 			}
; 697  : 			af->gearHandle = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1556], xmm0

; 698  : 		break;

	jmp	$LN163@Land
$LN111@Land:

; 699  : 
; 700  : 		//////////////////////////////////////////////////////////////////////////////////////
; 701  : 		case lFirstLeg:
; 702  : 			if(self->pctStrength < 0.4F){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [edx+292]
	jbe	SHORT $LN110@Land

; 703  : 				abObj->brain->RequestEmerClearance(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestEmerClearance
$LN110@Land:

; 704  : 			}
; 705  : 
; 706  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4046[ebp]
	movss	xmm0, DWORD PTR tv4046[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN109@Land

; 707  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv5312[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4052[ebp]
	movss	xmm0, DWORD PTR tv4052[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5312[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm1
$LN109@Land:

; 708  : 			}
; 709  : 
; 710  : 			cosHdg = self->platformAngles.cossig;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR [ecx+376]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 711  : 			sinHdg = self->platformAngles.sinsig;	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR [eax+372]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 712  : 
; 713  : 			relx = (  cosHdg*dx + sinHdg*dy);

	movss	xmm0, DWORD PTR _cosHdg$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _sinHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 714  : 			rely = ( -sinHdg*dx + cosHdg*dy);

	movss	xmm0, DWORD PTR _sinHdg$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _cosHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rely$[ebp], xmm0

; 715  : 
; 716  : 			if(fabs(relx) < turnDist && fabs(rely) < turnDist*3.0F){

	push	ecx
	movss	xmm0, DWORD PTR _relx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4067[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+340]
	comiss	xmm0, DWORD PTR tv4067[ebp]
	jbe	$LN105@Land
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4075[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+340]
	mulss	xmm0, DWORD PTR __real@40400000
	comiss	xmm0, DWORD PTR tv4075[ebp]
	jbe	$LN105@Land

; 717  : 				abObj->brain->FindFinalPt(self, rwIndex, &finalX, &finalY);

	lea	eax, DWORD PTR _finalY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _finalX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 718  : 				if(cosAngle < 0.0F) {

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	$LN107@Land

; 719  : 					atcstatus = lToBase;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 9

; 720  : 					abObj->brain->FindBasePt(self, rwIndex, finalX, finalY, &baseX, &baseY);

	lea	edx, DWORD PTR _baseY$[ebp]
	push	edx
	lea	eax, DWORD PTR _baseX$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 721  : 					SetTrackPoint(baseX, baseY, abObj->brain->GetAltitude(self, atcstatus));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _baseY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 722  : 					SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 723  : 					CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 724  : 				}
; 725  : 				else {

	jmp	SHORT $LN106@Land
$LN107@Land:

; 726  : 					atcstatus = lToFinal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 10			; 0000000aH

; 727  : 					SetTrackPoint(finalX, finalY, abObj->brain->GetAltitude(self, atcstatus));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 728  : 					SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 729  : 					CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)
$LN106@Land:

; 730  : 				}
; 731  : 				if ( self->ZPos() - gAvoidZ > minZ ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4133[ebp]
	movss	xmm0, DWORD PTR tv4133[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN105@Land

; 732  : 					trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv5314[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4139[ebp]
	movss	xmm0, DWORD PTR tv4139[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5314[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm1
$LN105@Land:

; 733  : 				}
; 734  : 			}
; 735  : 			
; 736  : 			TrackPointLanding( af->CalcTASfromCAS(af->MinVcas())*KNOTS_TO_FTPSEC);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4150[ebp]
	movss	xmm0, DWORD PTR tv4150[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 737  : 		break;

	jmp	$LN163@Land
$LN104@Land:

; 738  : 		//////////////////////////////////////////////////////////////////////////////////////
; 739  : 		case lToBase:
; 740  : 			if(self->pctStrength < 0.4F){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [eax+292]
	jbe	SHORT $LN103@Land

; 741  : 				abObj->brain->RequestEmerClearance(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestEmerClearance
$LN103@Land:

; 742  : 			}
; 743  : 		case lEmergencyToBase:
; 744  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4161[ebp]
	movss	xmm0, DWORD PTR tv4161[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN101@Land

; 745  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5316[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4167[ebp]
	movss	xmm0, DWORD PTR tv4167[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5316[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN101@Land:

; 746  : 			}
; 747  : 
; 748  : 			//if(dx*dx + dy*dy < turnDist*turnDist)
; 749  : 			cosHdg = self->platformAngles.cossig;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm0, DWORD PTR [edx+376]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 750  : 			sinHdg = self->platformAngles.sinsig;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR [ecx+372]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 751  : 
; 752  : 			relx = (  cosHdg*dx + sinHdg*dy);

	movss	xmm0, DWORD PTR _cosHdg$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _sinHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 753  : 			rely = ( -sinHdg*dx + cosHdg*dy);

	movss	xmm0, DWORD PTR _sinHdg$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _cosHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rely$[ebp], xmm0

; 754  : 
; 755  : 			if (fabs(relx) < turnDist && fabs(rely) < turnDist*3.0F){

	push	ecx
	movss	xmm0, DWORD PTR _relx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4182[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+340]
	comiss	xmm0, DWORD PTR tv4182[ebp]
	jbe	$LN100@Land
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4190[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+340]
	mulss	xmm0, DWORD PTR __real@40400000
	comiss	xmm0, DWORD PTR tv4190[ebp]
	jbe	$LN100@Land

; 756  : 				abObj->brain->FindFinalPt(self, rwIndex, &finalX, &finalY);

	lea	ecx, DWORD PTR _finalY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _finalX$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 757  : 				if(atcstatus == lEmergencyToBase){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+328], 15			; 0000000fH
	jne	SHORT $LN99@Land

; 758  : 					atcstatus = lEmergencyToFinal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 16			; 00000010H

; 759  : 				}
; 760  : 				else{

	jmp	SHORT $LN98@Land
$LN99@Land:

; 761  : 					atcstatus = lToFinal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 10			; 0000000aH
$LN98@Land:

; 762  : 				}
; 763  : 				SetTrackPoint(finalX, finalY, abObj->brain->GetAltitude(self, atcstatus));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 764  : 				if ( self->ZPos() - gAvoidZ > minZ ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4220[ebp]
	movss	xmm0, DWORD PTR tv4220[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN97@Land

; 765  : 					trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv5318[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4226[ebp]
	movss	xmm0, DWORD PTR tv4226[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5318[ebp]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm1
$LN97@Land:

; 766  : 				}
; 767  : 				SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 768  : 				CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)
$LN100@Land:

; 769  : 			}
; 770  : 			
; 771  : 			if (rwtime > SimLibElapsedTime + FINAL_TIME + BASE_TIME){

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+316], eax
	jbe	$LN96@Land

; 772  : 				deltaTime = (rwtime - SimLibElapsedTime - FINAL_TIME - BASE_TIME)/(float)CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+316]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, 180000				; 0002bf20H
	mov	DWORD PTR tv4235[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv4235[ebp]
	mov	ecx, DWORD PTR tv4235[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv4238[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv4238[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 773  : 				speed = (float)sqrt(dx*dx + dy*dy)/deltaTime;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv4248[ebp]
	movss	xmm0, DWORD PTR tv4248[ebp]
	divss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0

; 774  : 				speed = min(af->CalcTASfromCAS(af->MaxVcas() * 0.8F)*KNOTS_TO_FTPSEC, 
; 775  : 								max(speed, af->CalcTASfromCAS(af->MinVcas() * 0.8F)*KNOTS_TO_FTPSEC));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4253[ebp]
	movss	xmm0, DWORD PTR tv4253[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4259[ebp]
	movss	xmm0, DWORD PTR tv4259[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	xmm1, DWORD PTR _speed$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN184@Land
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv1639[ebp], xmm0
	jmp	SHORT $LN185@Land
$LN184@Land:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4266[ebp]
	movss	xmm0, DWORD PTR tv4266[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4272[ebp]
	movss	xmm0, DWORD PTR tv4272[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR tv1639[ebp], xmm0
$LN185@Land:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv4277[ebp]
	movss	xmm0, DWORD PTR tv4277[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4283[ebp]
	movss	xmm0, DWORD PTR tv4283[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	xmm1, DWORD PTR tv1639[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN188@Land
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv4289[ebp]
	movss	xmm0, DWORD PTR tv4289[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4295[ebp]
	movss	xmm0, DWORD PTR tv4295[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR tv1673[ebp], xmm0
	jmp	$LN189@Land
$LN188@Land:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4300[ebp]
	movss	xmm0, DWORD PTR tv4300[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4306[ebp]
	movss	xmm0, DWORD PTR tv4306[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	xmm1, DWORD PTR _speed$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN186@Land
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv1672[ebp], xmm0
	jmp	SHORT $LN187@Land
$LN186@Land:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4313[ebp]
	movss	xmm0, DWORD PTR tv4313[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4319[ebp]
	movss	xmm0, DWORD PTR tv4319[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR tv1672[ebp], xmm0
$LN187@Land:
	movss	xmm0, DWORD PTR tv1672[ebp]
	movss	DWORD PTR tv1673[ebp], xmm0
$LN189@Land:
	movss	xmm0, DWORD PTR tv1673[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0

; 776  : 			}
; 777  : 			else {

	jmp	SHORT $LN95@Land
$LN96@Land:

; 778  : 				speed = af->CalcTASfromCAS(af->MaxVcas() * 0.8F)*KNOTS_TO_FTPSEC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv4326[ebp]
	movss	xmm0, DWORD PTR tv4326[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4332[ebp]
	movss	xmm0, DWORD PTR tv4332[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _speed$[ebp], xmm0
$LN95@Land:

; 779  : 			}
; 780  : 			
; 781  : 			TrackPointLanding(speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 782  : 		break;

	jmp	$LN163@Land
$LN94@Land:

; 783  : 		//////////////////////////////////////////////////////////////////////////////////////
; 784  : 		case lToFinal:
; 785  : 			if(self->pctStrength < 0.4F){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR [edx+292]
	jbe	SHORT $LN93@Land

; 786  : 				abObj->brain->RequestEmerClearance(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestEmerClearance
$LN93@Land:

; 787  : 			}
; 788  : 		case lEmergencyToFinal:
; 789  : 			if ( self->ZPos() - gAvoidZ > minZ ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4344[ebp]
	movss	xmm0, DWORD PTR tv4344[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	comiss	xmm0, DWORD PTR _minZ$[ebp]
	jbe	SHORT $LN91@Land

; 790  : 				trackZ = gAvoidZ + minZ - ( self->ZPos() - gAvoidZ - minZ ) * 2.0f;

	movss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	addss	xmm0, DWORD PTR _minZ$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv5320[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4350[ebp]
	movss	xmm0, DWORD PTR tv4350[ebp]
	subss	xmm0, DWORD PTR _gAvoidZ$[ebp]
	subss	xmm0, DWORD PTR _minZ$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR tv5320[ebp]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm1
$LN91@Land:

; 791  : 			}
; 792  : 			cosHdg = PtHeaderDataTable[rwIndex].cosHeading;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 793  : 			sinHdg = PtHeaderDataTable[rwIndex].sinHeading;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+304]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+12]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 794  : 			relx = (  cosHdg*dx + sinHdg*dy);

	movss	xmm0, DWORD PTR _cosHdg$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _sinHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 795  : 			rely = ( -sinHdg*dx + cosHdg*dy);

	movss	xmm0, DWORD PTR _sinHdg$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _cosHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rely$[ebp], xmm0

; 796  : 			if(relx < 3.0F*NM_TO_FT && relx > -1.0F*NM_TO_FT && fabs(rely) < turnDist){

	movss	xmm0, DWORD PTR __real@468e6944
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	$LN90@Land
	movss	xmm0, DWORD PTR _relx$[ebp]
	comiss	xmm0, DWORD PTR __real@c5bde1b0
	jbe	$LN90@Land
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv4371[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+340]
	comiss	xmm0, DWORD PTR tv4371[ebp]
	jbe	$LN90@Land

; 797  : 				SetTaxiPoint(GetFirstPt(rwIndex));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 798  : 				float tx, ty, tz;
; 799  : 				TranslatePointData (abObj, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$48[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$47[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 800  : 				atcstatus = lOnFinal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 11			; 0000000bH

; 801  : 				if(atcstatus == lEmergencyToFinal){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 16			; 00000010H
	jne	SHORT $LN89@Land

; 802  : 					atcstatus = lEmergencyOnFinal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 17			; 00000011H

; 803  : 				}
; 804  : 				else{

	jmp	SHORT $LN88@Land
$LN89@Land:

; 805  : 					atcstatus = lOnFinal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 11			; 0000000bH
$LN88@Land:

; 806  : 				}
; 807  : 				tz = abObj->brain->GetAltitude(self, atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$49[ebp]

; 808  : 				SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$49[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$48[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$47[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 809  : 				SendATCMsg(atcstatus);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+328]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 810  : 				af->gearHandle = 1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+1556], xmm0
$LN90@Land:

; 811  : 			}
; 812  : 
; 813  : 			if(rwtime > SimLibElapsedTime + FINAL_TIME){

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+316], eax
	jbe	$LN87@Land

; 814  : 				deltaTime = (rwtime - SimLibElapsedTime - FINAL_TIME)/(float)CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+316]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, 120000				; 0001d4c0H
	mov	DWORD PTR tv4408[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv4408[ebp]
	mov	ecx, DWORD PTR tv4408[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv4411[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv4411[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 815  : 				speed = (float)sqrt(dx*dx + dy*dy)/deltaTime;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv4421[ebp]
	movss	xmm0, DWORD PTR tv4421[ebp]
	divss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0

; 816  : 				speed = min(af->CalcTASfromCAS(af->MaxVcas() * 0.8F)*KNOTS_TO_FTPSEC, 
; 817  : 									max(speed, af->CalcTASfromCAS(af->MinVcas() * 0.8F)*KNOTS_TO_FTPSEC));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4426[ebp]
	movss	xmm0, DWORD PTR tv4426[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4432[ebp]
	movss	xmm0, DWORD PTR tv4432[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	xmm1, DWORD PTR _speed$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN190@Land
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv1824[ebp], xmm0
	jmp	SHORT $LN191@Land
$LN190@Land:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4439[ebp]
	movss	xmm0, DWORD PTR tv4439[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4445[ebp]
	movss	xmm0, DWORD PTR tv4445[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR tv1824[ebp], xmm0
$LN191@Land:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv4450[ebp]
	movss	xmm0, DWORD PTR tv4450[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4456[ebp]
	movss	xmm0, DWORD PTR tv4456[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	xmm1, DWORD PTR tv1824[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN194@Land
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv4462[ebp]
	movss	xmm0, DWORD PTR tv4462[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4468[ebp]
	movss	xmm0, DWORD PTR tv4468[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR tv1858[ebp], xmm0
	jmp	$LN195@Land
$LN194@Land:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4473[ebp]
	movss	xmm0, DWORD PTR tv4473[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4479[ebp]
	movss	xmm0, DWORD PTR tv4479[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	xmm1, DWORD PTR _speed$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN192@Land
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv1857[ebp], xmm0
	jmp	SHORT $LN193@Land
$LN192@Land:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4486[ebp]
	movss	xmm0, DWORD PTR tv4486[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4492[ebp]
	movss	xmm0, DWORD PTR tv4492[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR tv1857[ebp], xmm0
$LN193@Land:
	movss	xmm0, DWORD PTR tv1857[ebp]
	movss	DWORD PTR tv1858[ebp], xmm0
$LN195@Land:
	movss	xmm0, DWORD PTR tv1858[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0

; 818  : 			}
; 819  : 			else {

	jmp	SHORT $LN86@Land
$LN87@Land:

; 820  : 				speed = af->CalcTASfromCAS(af->MaxVcas() * 0.8F)*KNOTS_TO_FTPSEC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv4499[ebp]
	movss	xmm0, DWORD PTR tv4499[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4505[ebp]
	movss	xmm0, DWORD PTR tv4505[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _speed$[ebp], xmm0
$LN86@Land:

; 821  : 			}
; 822  : 			
; 823  : 			TrackPointLanding(speed);

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 824  : 			break;

	jmp	$LN163@Land
$LN85@Land:

; 825  : 
; 826  : 		//////////////////////////////////////////////////////////////////////////////////////
; 827  : 		case lEmergencyOnFinal:
; 828  : 		case lOnFinal:
; 829  : 			// now we just wait until touchdown
; 830  : 			if ( self->IsSetFlag( ON_GROUND ) ){

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN84@Land

; 831  : 				atcstatus = lLanded;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 13			; 0000000dH

; 832  : 				SendATCMsg(atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 833  : 				ClearATCFlag(RequestTakeoff);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 834  : 				SetATCFlag(Landed);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 835  : 				int fp = GetFirstPt(rwIndex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _fp$42[ebp], eax

; 836  : 				SetTaxiPoint(GetNextPtLoop(fp));

	mov	ecx, DWORD PTR _fp$42[ebp]
	push	ecx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 837  : 				float tx, ty, tz;
; 838  : 				TranslatePointData(abObj, curTaxiPoint, &tx, &ty);

	lea	edx, DWORD PTR _ty$40[ebp]
	push	edx
	lea	eax, DWORD PTR _tx$39[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 839  : 				tz = af->groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1272]
	movss	DWORD PTR _tz$41[ebp], xmm0

; 840  : 				SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$41[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$40[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$39[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 841  : 				SimpleGroundTrack( 100.0F * KNOTS_TO_FTPSEC );

	push	ecx
	movss	xmm0, DWORD PTR __real@4328c89a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 842  : 				break;

	jmp	$LN163@Land
$LN84@Land:

; 843  : 			}
; 844  : 
; 845  : 			//don't do ground avoidance
; 846  : 			groundAvoidNeeded = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0

; 847  : 			//TJL 02/21/04 
; 848  : 			/*if(af->vt < af->CalcTASfromCAS(af->MinVcas() + 30.0F)*KNOTS_TO_FTPSEC ||
; 849  : 				(af->gearPos > 0.0F && af->vt < af->CalcTASfromCAS(af->MinVcas() + 10.0F)*KNOTS_TO_FTPSEC))*/
; 850  : 			if (af->vcas < 270.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@43870000
	comiss	xmm0, DWORD PTR [edx+1124]
	jbe	SHORT $LN83@Land

; 851  : 				af->gearHandle = 1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1556], xmm0
$LN83@Land:

; 852  : 			}
; 853  : 
; 854  : 			if(cosAngle > 0.0F && af->groundZ - self->ZPos() > 50.0F){

	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN82@Land
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4544[ebp]
	movss	xmm0, DWORD PTR [esi+1272]
	subss	xmm0, DWORD PTR tv4544[ebp]
	comiss	xmm0, DWORD PTR __real@42480000
	jbe	$LN82@Land

; 855  : 				SetTaxiPoint(GetFirstPt(rwIndex));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 856  : 				float tx, ty;
; 857  : 				TranslatePointData (abObj, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$36[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$34[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 858  : 				SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$36[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$34[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 859  : 
; 860  : 				//until chris moves the landing points
; 861  : 				//trackX -= 500.0F * PtHeaderDataTable[rwIndex].cosHeading;
; 862  : 				//trackY -= 500.0F * PtHeaderDataTable[rwIndex].sinHeading;
; 863  : 
; 864  : 				dx = trackX - self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv4562[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR tv4562[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 865  : 				dy = trackY - self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv4569[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+152]
	subss	xmm0, DWORD PTR tv4569[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 866  : 				dist = (float)sqrt(dx*dx + dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 867  : 
; 868  : 				//decelerate as we approach
; 869  : 				minSpeed = af->CalcTASfromCAS(af->MinVcas())*KNOTS_TO_FTPSEC;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?CalcTASfromCAS@AirframeClass@@QAEMM@Z	; AirframeClass::CalcTASfromCAS
	fstp	DWORD PTR tv4586[ebp]
	movss	xmm0, DWORD PTR tv4586[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _minSpeed$[ebp], xmm0

; 870  : 
; 871  : 				deltaTime = ((float)rwtime - (float)SimLibElapsedTime)/CampaignSeconds;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+316]
	mov	DWORD PTR tv4589[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv4589[ebp]
	mov	ecx, DWORD PTR tv4589[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv4593[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv4593[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv4598[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv4598[ebp]
	mov	eax, DWORD PTR tv4598[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv4602[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv4602[ebp]
	subss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 872  : 				testDist = (minSpeed*0.2F/(FINAL_TIME/CampaignSeconds)*deltaTime + minSpeed*0.6F)*deltaTime;			

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	divss	xmm0, DWORD PTR __real@42f00000
	mulss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	xmm1, DWORD PTR _minSpeed$[ebp]
	mulss	xmm1, DWORD PTR __real@3f19999a
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	DWORD PTR _testDist$[ebp], xmm0

; 873  : 				desiredSpeed = (minSpeed*0.4F/(FINAL_TIME/CampaignSeconds)*deltaTime + minSpeed*0.6F);

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	divss	xmm0, DWORD PTR __real@42f00000
	mulss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	xmm1, DWORD PTR _minSpeed$[ebp]
	mulss	xmm1, DWORD PTR __real@3f19999a
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+336], xmm0

; 874  : 
; 875  : 				if (dist > minSpeed*19.5F){

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@419c0000
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN81@Land

; 876  : 					desiredSpeed += (dist - testDist)/(testDist * 0.8F) * desiredSpeed;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _testDist$[ebp]
	movss	xmm1, DWORD PTR _testDist$[ebp]
	mulss	xmm1, DWORD PTR __real@3f4ccccd
	divss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+336]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+336]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+336], xmm0
	jmp	SHORT $LN79@Land
$LN81@Land:

; 877  : 				}
; 878  : 				else if(desiredSpeed > self->GetVt()){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv4625[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR tv4625[ebp]
	jbe	SHORT $LN79@Land

; 879  : 					desiredSpeed = self->GetVt();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+336]
$LN79@Land:

; 880  : 				}
; 881  : 				
; 882  : 				desiredSpeed = max(min(minSpeed*1.2F, desiredSpeed), minSpeed*0.6F);

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+336]
	comiss	xmm1, xmm0
	jbe	SHORT $LN196@Land
	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR tv2078[ebp], xmm0
	jmp	SHORT $LN197@Land
$LN196@Land:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+336]
	movss	DWORD PTR tv2078[ebp], xmm0
$LN197@Land:
	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f19999a
	movss	xmm1, DWORD PTR tv2078[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN200@Land
	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+336]
	comiss	xmm1, xmm0
	jbe	SHORT $LN198@Land
	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR tv2091[ebp], xmm0
	jmp	SHORT $LN199@Land
$LN198@Land:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv2091[ebp], xmm0
$LN199@Land:
	movss	xmm0, DWORD PTR tv2091[ebp]
	movss	DWORD PTR tv2094[ebp], xmm0
	jmp	SHORT $LN201@Land
$LN200@Land:
	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv2094[ebp], xmm0
$LN201@Land:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv2094[ebp]
	movss	DWORD PTR [eax+336], xmm0

; 883  : 				finalZ = abObj->brain->GetAltitude(self, lOnFinal);

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _finalZ$[ebp]

; 884  : 				trackZ = finalZ - dist*TAN_THREE_DEG_GLIDE;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3d56a98a
	movss	xmm1, DWORD PTR _finalZ$[ebp]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+156], xmm1

; 885  : 
; 886  : 				//recalculate track point to help line up better
; 887  : 				trackX += dist * 0.8F * PtHeaderDataTable[rwIndex].cosHeading;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mulss	xmm0, DWORD PTR [ecx+eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+148]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+148], xmm0

; 888  : 				trackY += dist * 0.8F * PtHeaderDataTable[rwIndex].sinHeading;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mulss	xmm0, DWORD PTR [eax+edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+152]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+152], xmm0

; 889  : 
; 890  : 				testDist = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _testDist$[ebp], xmm0

; 891  : 				x = self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _x$[ebp]

; 892  : 				y = self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _y$[ebp]
$LN78@Land:

; 893  : 
; 894  : 				while(testDist < dist * 0.2F && dist > 3000.0F){			

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	comiss	xmm0, DWORD PTR _testDist$[ebp]
	jbe	$LN77@Land
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN77@Land

; 895  : 					x -= 200.0F * PtHeaderDataTable[rwIndex].cosHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR __real@43480000
	mulss	xmm0, DWORD PTR [ecx+eax+16]
	movss	xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _x$[ebp], xmm1

; 896  : 					y -= 200.0F * PtHeaderDataTable[rwIndex].sinHeading;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR __real@43480000
	mulss	xmm0, DWORD PTR [ecx+eax+12]
	movss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _y$[ebp], xmm1

; 897  : 
; 898  : 					z = OTWDriver.GetGroundLevel(x, y);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _z$[ebp]

; 899  : 					if(dist < 6000.0F){

	movss	xmm0, DWORD PTR __real@45bb8000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN76@Land

; 900  : 						if(z - 100.0F < trackZ){

	movss	xmm0, DWORD PTR _z$[ebp]
	subss	xmm0, DWORD PTR __real@42c80000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+156]
	comiss	xmm1, xmm0
	jbe	SHORT $LN75@Land

; 901  : 							trackZ = z - 100.0F;

	movss	xmm0, DWORD PTR _z$[ebp]
	subss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+156], xmm0
$LN75@Land:

; 902  : 						}
; 903  : 					}
; 904  : 					else {

	jmp	SHORT $LN73@Land
$LN76@Land:

; 905  : 						if(z - 200.0F < trackZ){

	movss	xmm0, DWORD PTR _z$[ebp]
	subss	xmm0, DWORD PTR __real@43480000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+156]
	comiss	xmm1, xmm0
	jbe	SHORT $LN73@Land

; 906  : 							trackZ = z - 200.0F;

	movss	xmm0, DWORD PTR _z$[ebp]
	subss	xmm0, DWORD PTR __real@43480000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm0
$LN73@Land:

; 907  : 						}
; 908  : 					}
; 909  : 					
; 910  : 					testDist += 200.0F;

	movss	xmm0, DWORD PTR _testDist$[ebp]
	addss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR _testDist$[ebp], xmm0

; 911  : 				}

	jmp	$LN78@Land
$LN77@Land:

; 912  : 				if(af->groundZ - self->ZPos() > 200.0F){

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv4712[ebp]
	movss	xmm0, DWORD PTR [esi+1272]
	subss	xmm0, DWORD PTR tv4712[ebp]
	comiss	xmm0, DWORD PTR __real@43480000
	jbe	SHORT $LN72@Land

; 913  : 					TrackPointLanding(desiredSpeed);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 914  : 				}
; 915  : 				else {

	jmp	SHORT $LN71@Land
$LN72@Land:

; 916  : 					TrackPointLanding(af->GetLandingAoASpd());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetLandingAoASpd@AirframeClass@@QAEMXZ	; AirframeClass::GetLandingAoASpd
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)
$LN71@Land:

; 917  : 				}
; 918  : 			}
; 919  : 			else {

	jmp	$LN70@Land
$LN82@Land:

; 920  : 				float tx, ty, tz;
; 921  : 				//flare at the last minute so we hit softly
; 922  : 				int fp = GetFirstPt(rwIndex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _fp$33[ebp], eax

; 923  : 				SetTaxiPoint(GetNextPt(fp));

	mov	eax, DWORD PTR _fp$33[ebp]
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 924  : 				TranslatePointData (abObj, curTaxiPoint, &tx, &ty);

	lea	ecx, DWORD PTR _ty$31[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$29[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 925  : 				tz = abObj->brain->GetAltitude(self, atcstatus);	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _tz$32[ebp]

; 926  : 				SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$32[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$31[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$29[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 927  : 				TrackPointLanding(af->GetLandingAoASpd());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetLandingAoASpd@AirframeClass@@QAEMXZ	; AirframeClass::GetLandingAoASpd
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 928  : 				pStick = - 0.01685393258427F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bc8a1142
	movss	DWORD PTR [eax+28], xmm0
$LN70@Land:

; 929  : 			}
; 930  : 		break;

	jmp	$LN163@Land
$LN69@Land:

; 931  : 
; 932  : 		//////////////////////////////////////////////////////////////////////////////////////
; 933  : 		case lLanded:
; 934  : 			// edg: If we're not on the ground, we're fucked (which has
; 935  : 			// been seen).  We can't stay in this state.  Go to aborted.
; 936  : 			if ( !self->OnGround() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN68@Land

; 937  : 			{
; 938  : 				ShiWarning("Please show this to Dave P (x4373)");
; 939  : 
; 940  : 				float rx	= self->dmx[0][0] * dx + self->dmx[0][1] * dy;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$28[ebp], xmm0

; 941  : 
; 942  : 				if(rx > 3000.0F && af->IsSet(AirframeClass::OverRunway))

	movss	xmm0, DWORD PTR _rx$28[ebp]
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN67@Land
	push	8388608					; 00800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN67@Land

; 943  : 				{
; 944  : 					atcstatus = lOnFinal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 11			; 0000000bH

; 945  : 					SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 946  : 					ClearATCFlag(Landed);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 947  : 					TrackPointLanding(af->MinVcas()* KNOTS_TO_FTPSEC*0.6F);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4774[ebp]
	movss	xmm0, DWORD PTR tv4774[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@3f19999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPointLanding@DigitalBrain@@IAEMM@Z ; DigitalBrain::TrackPointLanding
	fstp	ST(0)

; 948  : 					pStick = - 0.01685393258427F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bc8a1142
	movss	DWORD PTR [ecx+28], xmm0

; 949  : 				}
; 950  : 				else

	jmp	$LN66@Land
$LN67@Land:

; 951  : 				{
; 952  : 					atcstatus = lAborted;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 5

; 953  : 					SendATCMsg(atcstatus);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 954  : 					float tx, ty, tz;
; 955  : 					abObj->brain->FindAbortPt(self, &tx, &ty, &tz);

	lea	edx, DWORD PTR _tz$27[ebp]
	push	edx
	lea	eax, DWORD PTR _ty$26[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$24[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?FindAbortPt@ATCBrain@@QAEXPAVAircraftClass@@PAM11@Z ; ATCBrain::FindAbortPt

; 956  : 					SetTrackPoint(tx, ty, tz);

	push	ecx
	movss	xmm0, DWORD PTR _tz$27[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$26[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$24[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 957  : 					TrackPoint( 0.0F, af->MinVcas() * 1.2F * KNOTS_TO_FTPSEC);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4797[ebp]
	movss	xmm0, DWORD PTR tv4797[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackPoint@DigitalBrain@@IAEMMM@Z	; DigitalBrain::TrackPoint
	fstp	ST(0)

; 958  : 					af->gearHandle = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0
$LN66@Land:

; 959  : 				}
; 960  : 				break;

	jmp	$LN163@Land
$LN68@Land:

; 961  : 			}
; 962  : 
; 963  : 			trackZ = af->groundZ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1272]
	mov	DWORD PTR [ecx+156], edx

; 964  : 			if (CloseToTrackPoint() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseToTrackPoint@DigitalBrain@@IAE_NXZ ; DigitalBrain::CloseToTrackPoint
	movzx	eax, al
	test	eax, eax
	je	$LN65@Land

; 965  : 			{
; 966  : 				// Are we there yet?
; 967  : 				switch(PtDataTable[GetNextPtLoop(curTaxiPoint)].type)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	mov	DWORD PTR tv2328[ebp], edx
	mov	eax, DWORD PTR tv2328[ebp]
	sub	eax, 1
	mov	DWORD PTR tv2328[ebp], eax
	cmp	DWORD PTR tv2328[ebp], 14		; 0000000eH
	ja	$LN63@Land
	mov	ecx, DWORD PTR tv2328[ebp]
	movzx	edx, BYTE PTR $LN209@Land[ecx]
	jmp	DWORD PTR $LN212@Land[edx*4]
$LN62@Land:

; 968  : 				{
; 969  : 				case TaxiPt:
; 970  : 					SetTaxiPoint(GetNextPtLoop(curTaxiPoint));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 971  : 					atcstatus = lTaxiOff;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 14			; 0000000eH

; 972  : 					waittimer = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0

; 973  : 					SendATCMsg(atcstatus);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 974  : 					break;

	jmp	SHORT $LN63@Land
$LN61@Land:

; 975  : 
; 976  : 				case TakeRunwayPt:
; 977  : 				case TakeoffPt:
; 978  : 					SetTaxiPoint(GetNextPtLoop(curTaxiPoint));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 979  : 					break;

	jmp	SHORT $LN63@Land
$LN60@Land:

; 980  : 
; 981  : 				case RunwayPt:
; 982  : 					//we shouldn't be here
; 983  : 					SetTaxiPoint(GetNextPtLoop(curTaxiPoint));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint
$LN63@Land:

; 984  : 					break;
; 985  : 				}
; 986  : 
; 987  : 				float tx, ty, tz = af->groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1272]
	movss	DWORD PTR _tz$23[ebp], xmm0

; 988  : 				TranslatePointData(abObj, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$22[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$21[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 989  : 				SetTrackPoint(tx, ty, tz);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tz$23[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$22[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$21[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint
$LN65@Land:

; 990  : 			}
; 991  : 
; 992  : 			inTheWay = CheckTaxiTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	mov	DWORD PTR _inTheWay$[ebp], eax

; 993  : 			if ( inTheWay && inTheWay->GetVt() < 10.0F)

	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	$LN59@Land
	mov	edx, DWORD PTR _inTheWay$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv4846[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR tv4846[ebp]
	jbe	$LN59@Land

; 994  : 			{
; 995  : 				heading = (float)atan2(trackX - self->XPos(), trackY - self->YPos() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv4852[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR tv4852[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv4859[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+148]
	subss	xmm0, DWORD PTR tv4859[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _heading$[ebp]

; 996  : 				mlSinCos(&Trig, heading);

	push	ecx
	movss	xmm0, DWORD PTR _heading$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _Trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 997  : 
; 998  : 				trackX += TAXI_CHECK_DIST * Trig.cos;

	movss	xmm0, DWORD PTR __real@42700000
	mulss	xmm0, DWORD PTR _Trig$[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+148]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+148], xmm0

; 999  : 				trackY += TAXI_CHECK_DIST * Trig.sin;

	movss	xmm0, DWORD PTR __real@42700000
	mulss	xmm0, DWORD PTR _Trig$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+152]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+152], xmm0
$LN59@Land:

; 1000 : 			}
; 1001 : 
; 1002 : 			// JPO pop the chute
; 1003 : 			if (af->HasDragChute() && 
; 1004 : 				af->dragChute == AirframeClass::DRAGC_STOWED &&
; 1005 : 				af->vcas < af->DragChuteMaxSpeed()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?HasDragChute@AirframeClass@@QAE_NXZ	; AirframeClass::HasDragChute
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN58@Land
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	cmp	DWORD PTR [eax+1584], 0
	jne	SHORT $LN58@Land
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?DragChuteMaxSpeed@AirframeClass@@QAEMXZ ; AirframeClass::DragChuteMaxSpeed
	fstp	DWORD PTR tv4886[ebp]
	movss	xmm0, DWORD PTR tv4886[ebp]
	comiss	xmm0, DWORD PTR [esi+1124]
	jbe	SHORT $LN58@Land

; 1006 : 				af->dragChute = AirframeClass::DRAGC_DEPLOYED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [ecx+1584], 1
$LN58@Land:

; 1007 : 			}
; 1008 : 			// Thrust reverser
; 1009 : 			if ((af->HasThrRev()) && (af->thrustReverse < 2))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?HasThrRev@AirframeClass@@QAEHXZ	; AirframeClass::HasThrRev
	test	eax, eax
	je	SHORT $LN57@Land
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	cmp	DWORD PTR [ecx+1592], 2
	jge	SHORT $LN57@Land

; 1010 : 				af->thrustReverse = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [eax+1592], 2
$LN57@Land:

; 1011 : 			// Retract reverse thruster
; 1012 : 			if ((af->HasThrRev()) && (self->GetVt() < af->MinVcas() * 0.3F))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?HasThrRev@AirframeClass@@QAEHXZ	; AirframeClass::HasThrRev
	test	eax, eax
	je	SHORT $LN56@Land
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv4900[ebp]
	movss	xmm0, DWORD PTR tv4900[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	movss	DWORD PTR tv5322[ebp], xmm0
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4905[ebp]
	movss	xmm0, DWORD PTR tv4905[ebp]
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	xmm1, DWORD PTR tv5322[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN56@Land

; 1013 : 				af->thrustReverse = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [eax+1592], 0
$LN56@Land:

; 1014 : 
; 1015 : 			if(self->GetVt() < af->MinVcas() * 0.4F) { // was 0.6f

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv4913[ebp]
	movss	xmm0, DWORD PTR tv4913[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	movss	DWORD PTR tv5324[ebp], xmm0
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4918[ebp]
	movss	xmm0, DWORD PTR tv4918[ebp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	movss	xmm1, DWORD PTR tv5324[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN54@Land

; 1016 : 				if (af->dragChute == AirframeClass::DRAGC_DEPLOYED)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	cmp	DWORD PTR [eax+1584], 1
	jne	SHORT $LN54@Land

; 1017 : 					af->dragChute = AirframeClass::DRAGC_JETTISONNED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [edx+1584], 4
$LN54@Land:

; 1018 : 			}
; 1019 : 			if(self->GetVt() < af->MinVcas() * 0.55F) { // clean up

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv4927[ebp]
	movss	xmm0, DWORD PTR tv4927[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	DWORD PTR tv5326[ebp], xmm0
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4932[ebp]
	movss	xmm0, DWORD PTR tv4932[ebp]
	mulss	xmm0, DWORD PTR __real@3f0ccccd
	movss	xmm1, DWORD PTR tv5326[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN52@Land

; 1020 : 				if (af->speedBrake > -1.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1560]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN52@Land

; 1021 : 					af->speedBrake = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1560], xmm0
$LN52@Land:

; 1022 : 			}
; 1023 : 			if(self->GetVt() < af->MinVcas() * 0.5F) { // THW 2003-11-23 more clean up (this one a bit later)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv4943[ebp]
	movss	xmm0, DWORD PTR tv4943[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	movss	DWORD PTR tv5328[ebp], xmm0
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4948[ebp]
	movss	xmm0, DWORD PTR tv4948[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR tv5328[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN49@Land

; 1024 : 				if (af->tefPos > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [eax+1580]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN50@Land

; 1025 : 					af->TEFClose();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?TEFClose@AirframeClass@@QAEXXZ		; AirframeClass::TEFClose
$LN50@Land:

; 1026 : 				if (af->lefPos > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [eax+1576]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN49@Land

; 1027 : 					af->LEFClose();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?LEFClose@AirframeClass@@QAEXXZ		; AirframeClass::LEFClose
$LN49@Land:

; 1028 : 			}
; 1029 : 
; 1030 : 			dx = trackX - af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+148]
	subss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1031 : 			dy = trackY - af->y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1032 : 			if (dx*dx + dy*dy > 1500.0F * 1500.0F )

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@4a095440
	jbe	$LN48@Land

; 1033 : 			{
; 1034 : 				SimpleGroundTrack(min(60.0F * KNOTS_TO_FTPSEC,af->MinVcas()*0.4F)); //THW 2003-11-23 No hurry...no need to re-accelerate

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4967[ebp]
	movss	xmm0, DWORD PTR tv4967[ebp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR __real@42ca8a53
	jbe	SHORT $LN202@Land
	movss	xmm0, DWORD PTR __real@42ca8a53
	movss	DWORD PTR tv2556[ebp], xmm0
	jmp	SHORT $LN203@Land
$LN202@Land:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4973[ebp]
	movss	xmm0, DWORD PTR tv4973[ebp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR tv2556[ebp], xmm0
$LN203@Land:
	push	ecx
	movss	xmm0, DWORD PTR tv2556[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack
	jmp	$LN43@Land
$LN48@Land:

; 1035 : 			}
; 1036 : 			else if (dx*dx + dy*dy > 500.0F * 500.0F )	//THW 2003-11-23 Slow down

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@48742400
	jbe	SHORT $LN46@Land

; 1037 : 			{
; 1038 : 				SimpleGroundTrack(min(50.0F * KNOTS_TO_FTPSEC,af->MinVcas()*0.3F));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4982[ebp]
	movss	xmm0, DWORD PTR tv4982[ebp]
	mulss	xmm0, DWORD PTR __real@3e99999a
	comiss	xmm0, DWORD PTR __real@42a8c89a
	jbe	SHORT $LN204@Land
	movss	xmm0, DWORD PTR __real@42a8c89a
	movss	DWORD PTR tv2574[ebp], xmm0
	jmp	SHORT $LN205@Land
$LN204@Land:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv4988[ebp]
	movss	xmm0, DWORD PTR tv4988[ebp]
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR tv2574[ebp], xmm0
$LN205@Land:
	push	ecx
	movss	xmm0, DWORD PTR tv2574[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack
	jmp	SHORT $LN43@Land
$LN46@Land:

; 1039 : 			}
; 1040 : 			else if (dx*dx + dy*dy > 200.0F * 200.0F ) //THW 2003-11-23 Slow down

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@471c4000
	jbe	SHORT $LN44@Land

; 1041 : 			{
; 1042 : 				SimpleGroundTrack(35.0F * KNOTS_TO_FTPSEC);

	push	ecx
	movss	xmm0, DWORD PTR __real@426c4c0b
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack

; 1043 : 			}
; 1044 : 			else

	jmp	SHORT $LN43@Land
$LN44@Land:

; 1045 : 			{
; 1046 : 				SimpleGroundTrack( 20.0F * KNOTS_TO_FTPSEC);

	push	ecx
	movss	xmm0, DWORD PTR __real@420706e2
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack
$LN43@Land:

; 1047 : 			}
; 1048 : 
; 1049 : 			if (g_nShowDebugLabels)	//THW 2003-11-23 Some debug stuff to observe landing deccelaration behaviour

	cmp	DWORD PTR ?g_nShowDebugLabels@@3HA, 0	; g_nShowDebugLabels
	je	$LN41@Land

; 1050 : 			{
; 1051 : 				char label [96];
; 1052 : 				sprintf(label,"Speed: %d kts, PointDist: %d ft",FloatToInt32(self->GetVt()/KNOTS_TO_FTPSEC),FloatToInt32(sqrt(dx*dx + dy*dy)));

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv5011[ebp]
	movss	xmm0, DWORD PTR tv5011[ebp]
	divss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CA@GLBKACGL@Speed?3?5?$CFd?5kts?0?5PointDist?3?5?$CFd?5ft?$AA@
	lea	eax, DWORD PTR _label$59[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1053 : 				if (self->drawPointer)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN41@Land

; 1054 : 					((DrawableBSP*)self->drawPointer)->SetLabel(label,((DrawableBSP*)self->drawPointer)->LabelColor());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+332]
	call	?LabelColor@DrawableBSP@@QAEKXZ		; DrawableBSP::LabelColor
	push	eax
	lea	edx, DWORD PTR _label$59[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+332]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+332]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN41@Land:

; 1055 : 			}
; 1056 : 		break;

	jmp	$LN163@Land
$LN40@Land:

; 1057 : 
; 1058 : 		//////////////////////////////////////////////////////////////////////////////////////
; 1059 : 		case lTaxiOff:
; 1060 : 			// JPO - only halt when we really get there, so the above condition continues to fire.
; 1061 : 			if(AtFinalTaxiPoint()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AtFinalTaxiPoint@DigitalBrain@@IAE_NXZ	; DigitalBrain::AtFinalTaxiPoint
	movzx	ecx, al
	test	ecx, ecx
	je	$LN39@Land

; 1062 : 				if (waittimer == 0){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+344], 0
	jne	SHORT $LN38@Land

; 1063 : 					waittimer = SimLibElapsedTime + g_nReagTimer * CampaignMinutes;

	mov	eax, DWORD PTR ?g_nReagTimer@@3HA	; g_nReagTimer
	imul	eax, 60000				; 0000ea60H
	add	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax
$LN38@Land:

; 1064 : 				}
; 1065 : 				dx = trackX - af->x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+148]
	subss	xmm0, DWORD PTR [eax+1108]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1066 : 				dy = trackY - af->y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+152]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1067 : 				if (dx*dx + dy * dy < 10 * 10){

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@42c80000
	comiss	xmm1, xmm0
	jbe	SHORT $LN37@Land

; 1068 : 					desiredSpeed = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+336], xmm0

; 1069 : 				}
; 1070 : 				else {

	jmp	SHORT $LN36@Land
$LN37@Land:

; 1071 : 					desiredSpeed = 20.0F * KNOTS_TO_FTPSEC * (float)sqrt(dx*dx + dy* dy) / TAXI_CHECK_DIST;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv5043[ebp]
	movss	xmm0, DWORD PTR tv5043[ebp]
	mulss	xmm0, DWORD PTR __real@420706e2
	divss	xmm0, DWORD PTR __real@42700000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+336], xmm0
$LN36@Land:

; 1072 : 				}
; 1073 : 				desiredSpeed = min(20.0F * KNOTS_TO_FTPSEC, desiredSpeed);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+336]
	comiss	xmm0, DWORD PTR __real@420706e2
	jbe	SHORT $LN206@Land
	movss	xmm0, DWORD PTR __real@420706e2
	movss	DWORD PTR tv2688[ebp], xmm0
	jmp	SHORT $LN207@Land
$LN206@Land:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR tv2688[ebp], xmm0
$LN207@Land:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv2688[ebp]
	movss	DWORD PTR [eax+336], xmm0

; 1074 : 				if (waittimer < SimLibElapsedTime || (desiredSpeed == 0 && self->GetVt() < 0.1f)){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jb	SHORT $LN34@Land
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+336]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN25@Land
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv5063[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR tv5063[ebp]
	jbe	$LN25@Land
$LN34@Land:

; 1075 : 					//TJL 03/01/04 Reorder this. Canopy up later.
; 1076 : 					// then clean up
; 1077 : 					if (!af->IsSet(AirframeClass::EngineStopped)){

	push	134217728				; 08000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN33@Land

; 1078 : 						af->SetFlag(AirframeClass::EngineStopped);

	push	134217728				; 08000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
	jmp	$LN25@Land
$LN33@Land:

; 1079 : 					}
; 1080 : 					//TJL 03/01/04 Dual Engine off
; 1081 : 					else if (af->GetNumberEngines() == 2 && !af->IsEngineFlag(AirframeClass::EngineStopped2)){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetNumberEngines@AirframeClass@@QAEHXZ	; AirframeClass::GetNumberEngines
	cmp	eax, 2
	jne	SHORT $LN31@Land
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?IsEngineFlag@AirframeClass@@QAEHW4EngineFlags@1@@Z ; AirframeClass::IsEngineFlag
	test	eax, eax
	jne	SHORT $LN31@Land

; 1082 : 						af->SetEngineFlag(AirframeClass::EngineStopped2);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?SetEngineFlag@AirframeClass@@QAEXW4EngineFlags@1@@Z ; AirframeClass::SetEngineFlag
	jmp	$LN25@Land
$LN31@Land:

; 1083 : 					}
; 1084 : 					else if (!af->canopyState){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movzx	edx, BYTE PTR [ecx+1588]
	test	edx, edx
	jne	SHORT $LN29@Land

; 1085 : 						af->CanopyToggle();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CanopyToggle@AirframeClass@@QAEXXZ	; AirframeClass::CanopyToggle

; 1086 : 					}
; 1087 : 					else if (

	jmp	$LN25@Land
$LN29@Land:

; 1088 : 						af->rpm < 0.05f &&
; 1089 : 						self->MainPower() != AircraftClass::MainPowerOff
; 1090 : 					){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	SHORT $LN27@Land
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?MainPower@AircraftClass@@QAE?AW4MainPowerType@1@XZ ; AircraftClass::MainPower
	test	eax, eax
	je	SHORT $LN27@Land

; 1091 : 						self->DecMainPower();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?DecMainPower@AircraftClass@@QAEXXZ	; AircraftClass::DecMainPower

; 1092 : 					}
; 1093 : 					else if (

	jmp	SHORT $LN25@Land
$LN27@Land:

; 1094 : 						self != SimDriver.GetPlayerEntity() && 
; 1095 : 						(g_nReagTimer <= 0 || waittimer < SimLibElapsedTime)
; 1096 : 					){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], eax
	je	SHORT $LN25@Land
	cmp	DWORD PTR ?g_nReagTimer@@3HA, 0		; g_nReagTimer
	jle	SHORT $LN24@Land
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN25@Land
$LN24@Land:

; 1097 : 						// 02JAN04 - FRB - Make parking spot available for others
; 1098 : 						PtDataTable[curTaxiPoint].flags &= ~PT_OCCUPIED;	

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	BYTE PTR [eax+ecx+9], dl

; 1099 : 						RegroupAircraft(self); //end of the line, time to pull you

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4
$LN25@Land:

; 1100 : 					}
; 1101 : 				}
; 1102 : 			}

	jmp	$LN11@Land
$LN39@Land:

; 1103 : 			else if (CloseToTrackPoint()) // time to step along

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseToTrackPoint@DigitalBrain@@IAE_NXZ ; DigitalBrain::CloseToTrackPoint
	movzx	eax, al
	test	eax, eax
	je	$LN22@Land

; 1104 : 			{
; 1105 : 				switch(PtDataTable[GetNextPtLoop(curTaxiPoint)].type) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	dl, BYTE PTR [ecx+eax+8]
	mov	BYTE PTR tv2779[ebp], dl
	cmp	BYTE PTR tv2779[ebp], 11		; 0000000bH
	jb	SHORT $LN19@Land
	cmp	BYTE PTR tv2779[ebp], 12		; 0000000cH
	jbe	SHORT $LN18@Land
$LN19@Land:

; 1106 : 				{
; 1107 : 					case TaxiPt: // nothing special
; 1108 : 					default:
; 1109 : 						SetTaxiPoint(GetNextPtLoop(curTaxiPoint));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 1110 : 						break;

	jmp	SHORT $LN20@Land
$LN18@Land:

; 1111 : 					case SmallParkPt:
; 1112 : 					case LargeParkPt: // possible parking spot
; 1113 : 						FindParkingSpot(abObj);

	mov	edx, DWORD PTR _abObj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindParkingSpot@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ; DigitalBrain::FindParkingSpot
$LN20@Land:

; 1114 : 						break;
; 1115 : 				}
; 1116 : 				// Are we there yet?
; 1117 : 				switch(PtDataTable[curTaxiPoint].flags)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	al, BYTE PTR [edx+ecx+9]
	mov	BYTE PTR tv2797[ebp], al
	cmp	BYTE PTR tv2797[ebp], 2
	je	SHORT $LN13@Land
	jmp	SHORT $LN16@Land

; 1118 : 				{
; 1119 : 					//this taxi point is in middle of list
; 1120 : 					case 0:
; 1121 : 						break;

	jmp	SHORT $LN16@Land

; 1122 : 
; 1123 : 					//this should be the runway pt, we shouldn't be here
; 1124 : 					case PT_FIRST:
; 1125 : 						break;

	jmp	SHORT $LN16@Land
$LN13@Land:

; 1126 : 
; 1127 : 					case PT_LAST:	 // if at last PD, a/c should reagg...no parking spots available
; 1128 : 												//....looks bad to have bunch of a/c out in the fields
; 1129 : 						if(self != SimDriver.GetPlayerEntity())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], eax
	je	SHORT $LN12@Land

; 1130 : 							RegroupAircraft (self); //end of the line, time to pull you

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4
$LN12@Land:
$LN16@Land:

; 1131 : 						break;
; 1132 : 				}
; 1133 : 
; 1134 : 				float tx, ty, tz = af->groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1272]
	movss	DWORD PTR _tz$15[ebp], xmm0

; 1135 : 				TranslatePointData(abObj, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1136 : 				SetTrackPoint(tx, ty, tz);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tz$15[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ty$14[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$13[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 1137 : 				desiredSpeed = 20.0F * KNOTS_TO_FTPSEC;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@420706e2
	movss	DWORD PTR [edx+336], xmm0

; 1138 : 			}
; 1139 : 			else {

	jmp	SHORT $LN11@Land
$LN22@Land:

; 1140 : 				desiredSpeed = 20.0F * KNOTS_TO_FTPSEC;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@420706e2
	movss	DWORD PTR [eax+336], xmm0
$LN11@Land:

; 1141 : 			}
; 1142 : 			inTheWay = CheckTaxiTrackPoint();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTaxiTrackPoint@DigitalBrain@@IAEPAVSimBaseClass@@XZ ; DigitalBrain::CheckTaxiTrackPoint
	mov	DWORD PTR _inTheWay$[ebp], eax

; 1143 : 			if ( inTheWay && inTheWay->GetVt() < 10.0F) 

	cmp	DWORD PTR _inTheWay$[ebp], 0
	je	$LN8@Land
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv5131[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR tv5131[ebp]
	jbe	$LN8@Land

; 1144 : 			{
; 1145 : 				switch (PtDataTable[curTaxiPoint].type ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	mov	cl, BYTE PTR [eax+edx+8]
	mov	BYTE PTR tv2846[ebp], cl
	cmp	BYTE PTR tv2846[ebp], 11		; 0000000bH
	jb	$LN6@Land
	cmp	BYTE PTR tv2846[ebp], 12		; 0000000cH
	jbe	SHORT $LN7@Land
	jmp	SHORT $LN6@Land
$LN7@Land:

; 1146 : 				{
; 1147 : 					case SmallParkPt: //was a possible parking spot, alas no more.
; 1148 : 					case LargeParkPt: // someone beat us to it.
; 1149 : 						if (PtDataTable[curTaxiPoint].flags != PT_LAST) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+9]
	cmp	edx, 2
	je	SHORT $LN6@Land

; 1150 : 						{
; 1151 : 							FindParkingSpot(abObj); // try again

	mov	eax, DWORD PTR _abObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindParkingSpot@DigitalBrain@@IAEXPAVObjectiveClass@@@Z ; DigitalBrain::FindParkingSpot

; 1152 : 							float tx, ty;
; 1153 : 							TranslatePointData(abObj, curTaxiPoint, &tx, &ty);

	lea	ecx, DWORD PTR _ty$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$11[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	push	ecx
	mov	edx, DWORD PTR _abObj$[ebp]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1154 : 							SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$12[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$11[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1155 : 							break;

	jmp	$LN8@Land
$LN6@Land:

; 1156 : 						}
; 1157 : 						// else fall
; 1158 : 					default:
; 1159 : 						// Cobra - Skip a/c on parking spots
; 1160 : 						if (
; 1161 : 							(((AircraftClass*)inTheWay)->DBrain())&&
; 1162 : 							((PtDataTable[((AircraftClass*)inTheWay)->DBrain()->GetTaxiPoint()].type == LargeParkPt ||
; 1163 : 							(PtDataTable[((AircraftClass*)inTheWay)->DBrain()->GetTaxiPoint()].type == SmallParkPt)))
; 1164 : 						){

	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	test	eax, eax
	je	$LN4@Land
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?GetTaxiPoint@DigitalBrain@@QAEHXZ	; DigitalBrain::GetTaxiPoint
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 12					; 0000000cH
	je	SHORT $LN3@Land
	mov	ecx, DWORD PTR _inTheWay$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?GetTaxiPoint@DigitalBrain@@QAEHXZ	; DigitalBrain::GetTaxiPoint
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?PtDataTable@@3PAUPtDataType@@A ; PtDataTable
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 11					; 0000000bH
	jne	SHORT $LN4@Land
$LN3@Land:

; 1165 : 							float tx, ty;
; 1166 : 							TranslatePointData(abObj, curTaxiPoint, &tx, &ty);

	lea	eax, DWORD PTR _ty$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	push	eax
	mov	ecx, DWORD PTR _abObj$[ebp]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 1167 : 							SetTrackPoint(tx, ty);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _ty$10[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tx$8[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint

; 1168 : 						}
; 1169 : 						else{

	jmp	SHORT $LN2@Land
$LN4@Land:

; 1170 : 							OffsetTrackPoint(TAXI_CHECK_DIST, offRight); // JPO from offRight

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OffsetTrackPoint@DigitalBrain@@QAEXMH@Z ; DigitalBrain::OffsetTrackPoint
$LN2@Land:
$LN8@Land:

; 1171 : 						}
; 1172 : 						break;
; 1173 : 				}
; 1174 : 			}
; 1175 : 		
; 1176 : 			SimpleGroundTrack(desiredSpeed);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+336]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleGroundTrack@DigitalBrain@@IAEHM@Z ; DigitalBrain::SimpleGroundTrack
$LN1@Land:
$LN163@Land:

; 1177 : 		break;
; 1178 : 		default:
; 1179 : 		break;
; 1180 : 	}
; 1181 : 	// COBRA - RED - Apply few randomnes to AI
; 1182 : 	RandomStuff(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RandomStuff@DigitalBrain@@IAEXPAVSimBaseClass@@@Z ; DigitalBrain::RandomStuff
$LN180@Land:

; 1183 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN211@Land:
	DD	$LN162@Land
	DD	$LN134@Land
	DD	$LN134@Land
	DD	$LN150@Land
	DD	$LN144@Land
	DD	$LN128@Land
	DD	$LN124@Land
	DD	$LN121@Land
	DD	$LN111@Land
	DD	$LN104@Land
	DD	$LN94@Land
	DD	$LN85@Land
	DD	$LN1@Land
	DD	$LN69@Land
	DD	$LN40@Land
	DD	$LN103@Land
	DD	$LN93@Land
	DD	$LN85@Land
$LN212@Land:
	DD	$LN60@Land
	DD	$LN61@Land
	DD	$LN62@Land
	DD	$LN63@Land
$LN209@Land:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Land@DigitalBrain@@IAEXXZ$0:
	lea	ecx, DWORD PTR _cit$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?Land@DigitalBrain@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Land@DigitalBrain@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Land@DigitalBrain@@IAEXXZ ENDP				; DigitalBrain::Land
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\landme.cpp
_TEXT	SEGMENT
_Airbase$ = -16						; size = 4
_w$ = -12						; size = 4
_flight$ = -8						; size = 4
_this$ = -4						; size = 4
?IsAtFirstTaxipoint@DigitalBrain@@QAEHXZ PROC		; DigitalBrain::IsAtFirstTaxipoint
; _this$ = ecx

; 4094 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4095 :     ShiAssert(self != NULL);
; 4096 :     Flight flight = (Flight)self->GetCampaignObject();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$[ebp], eax

; 4097 :     ShiAssert(flight != NULL);
; 4098 :     WayPoint	w = flight->GetFirstUnitWP(); // this is takeoff time

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetFirstUnitWP@UnitClass@@QAEPAVWayPointClass@@XZ ; UnitClass::GetFirstUnitWP
	mov	DWORD PTR _w$[ebp], eax

; 4099 :     ObjectiveClass *Airbase = (ObjectiveClass *)vuDatabase->Find(airbase);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+312]
	push	edx
	mov	eax, DWORD PTR [ecx+308]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _Airbase$[ebp], eax

; 4100 :     ShiAssert(Airbase);
; 4101 :     // so takeoff time, - deag time (taxi point time) - if we're past that - we're ready.
; 4102 :     if (SimLibElapsedTime > w->GetWPDepartureTime() - Airbase->brain->MinDeagTime()) {

	mov	ecx, DWORD PTR _w$[ebp]
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	esi, eax
	mov	ecx, DWORD PTR _Airbase$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?MinDeagTime@ATCBrain@@QAEKXZ		; ATCBrain::MinDeagTime
	sub	esi, eax
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, esi	; SimLibElapsedTime
	jbe	SHORT $LN2@IsAtFirstT

; 4103 : 	return 0;

	xor	eax, eax
	jmp	SHORT $LN3@IsAtFirstT

; 4104 :     }
; 4105 :     else

	jmp	SHORT $LN3@IsAtFirstT
$LN2@IsAtFirstT:

; 4106 : 	return 1;

	mov	eax, 1
$LN3@IsAtFirstT:

; 4107 : 
; 4108 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAtFirstTaxipoint@DigitalBrain@@QAEHXZ ENDP		; DigitalBrain::IsAtFirstTaxipoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\atcbrain.h
;	COMDAT ?MinDeagTime@ATCBrain@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinDeagTime@ATCBrain@@QAEKXZ PROC			; ATCBrain::MinDeagTime, COMDAT
; _this$ = ecx

; 185  : 	ulong				MinDeagTime(void)				{return minDeagTime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?MinDeagTime@ATCBrain@@QAEKXZ ENDP			; ATCBrain::MinDeagTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\atcbrain.h
;	COMDAT ?GetRunwayStats@ATCBrain@@QAEPAUrunwayStatsStruct@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRunwayStats@ATCBrain@@QAEPAUrunwayStatsStruct@@XZ PROC ; ATCBrain::GetRunwayStats, COMDAT
; _this$ = ecx

; 179  : 	runwayStatsStruct*	GetRunwayStats(void)				{return runwayStats;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRunwayStats@ATCBrain@@QAEPAUrunwayStatsStruct@@XZ ENDP ; ATCBrain::GetRunwayStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::OwnerId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID OwnerId() const     { return share_.ownerId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::OwnerId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
