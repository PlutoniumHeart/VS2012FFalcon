; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\Separate.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_asinf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?asin@@YAMM@Z					; asin
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?FuelCheck@DigitalBrain@@IAEXXZ			; DigitalBrain::FuelCheck
PUBLIC	?SeparateCheck@DigitalBrain@@IAEXXZ		; DigitalBrain::SeparateCheck
PUBLIC	?SetATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::SetATCFlag
PUBLIC	?IsSetATC@DigitalBrain@@QAEHH@Z			; DigitalBrain::IsSetATC
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?Fuel@AirframeClass@@QAEMXZ			; AirframeClass::Fuel
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?RunningTactical@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningTactical
PUBLIC	?RangeAtTailChase@@YAMPAVAircraftClass@@PAVSimObjectType@@@Z ; RangeAtTailChase
PUBLIC	?TailChaseRMaxNe@@YAMPAVAircraftClass@@PAVSimObjectType@@H@Z ; TailChaseRMaxNe
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3ff921fb24000000
PUBLIC	__real@4016cbe3
PUBLIC	__real@40490fd9
PUBLIC	__real@4200b53f
PUBLIC	__real@4320e28f
PUBLIC	__real@45bb8000
PUBLIC	__real@463de1b0
PUBLIC	__real@470e6944
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_asin:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z:PROC	; DigitalBrain::AddMode
EXTRN	?SetWaypointSpecificStuff@DigitalBrain@@IAEXXZ:PROC ; DigitalBrain::SetWaypointSpecificStuff
EXTRN	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z:PROC ; DigitalBrain::SetGroundTarget
EXTRN	?GetJoker@AirframeClass@@QAEMXZ:PROC		; AirframeClass::GetJoker
EXTRN	?GetBingo@AirframeClass@@QAEMXZ:PROC		; AirframeClass::GetBingo
EXTRN	?GetFumes@AirframeClass@@QAEMXZ:PROC		; AirframeClass::GetFumes
EXTRN	?SustainedGs@AirframeClass@@QAEMH@Z:PROC	; AirframeClass::SustainedGs
EXTRN	?PsubS@AirframeClass@@QAEMH@Z:PROC		; AirframeClass::PsubS
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z:PROC ; AiMakeRadioResponse
EXTRN	?AiSendCommand@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z:PROC ; AiSendCommand
EXTRN	?get_type@tactical_mission@@QAE?AW4tactical_type@@XZ:PROC ; tactical_mission::get_type
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?current_tactical_mission@@3PAVtactical_mission@@A:DWORD ; current_tactical_mission
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@470e6944
CONST	SEGMENT
__real@470e6944 DD 0470e6944r			; 36457.3
CONST	ENDS
;	COMDAT __real@463de1b0
CONST	SEGMENT
__real@463de1b0 DD 0463de1b0r			; 12152.4
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@4320e28f
CONST	SEGMENT
__real@4320e28f DD 04320e28fr			; 160.885
CONST	ENDS
;	COMDAT __real@4200b53f
CONST	SEGMENT
__real@4200b53f DD 04200b53fr			; 32.177
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@4016cbe3
CONST	SEGMENT
__real@4016cbe3 DD 04016cbe3r			; 2.35619
CONST	ENDS
;	COMDAT __real@3ff921fb24000000
CONST	SEGMENT
__real@3ff921fb24000000 DQ 03ff921fb24000000r	; 1.5708
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\separate.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
_missiletype$ = 16					; size = 4
?TailChaseRMaxNe@@YAMPAVAircraftClass@@PAVSimObjectType@@H@Z PROC ; TailChaseRMaxNe

; 380  : {

	push	ebp
	mov	ebp, esp

; 381  :    return 6.0F * NM_TO_FT;

	fld	DWORD PTR __real@470e6944

; 382  : }

	pop	ebp
	ret	0
?TailChaseRMaxNe@@YAMPAVAircraftClass@@PAVSimObjectType@@H@Z ENDP ; TailChaseRMaxNe
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\separate.cpp
_TEXT	SEGMENT
_finalRange$ = -364					; size = 4
tv864 = -360						; size = 4
tv884 = -356						; size = 4
_pSubSLaunch$ = -352					; size = 4
tv849 = -348						; size = 4
tv751 = -344						; size = 4
tv841 = -340						; size = 4
tv660 = -336						; size = 4
tv882 = -332						; size = 4
tv862 = -328						; size = 4
tv834 = -324						; size = 4
tv744 = -320						; size = 4
tv826 = -316						; size = 4
tv868 = -312						; size = 4
tv880 = -308						; size = 4
tv652 = -304						; size = 4
tv819 = -300						; size = 4
tv595 = -296						; size = 4
tv811 = -292						; size = 4
tv759 = -288						; size = 4
tv878 = -284						; size = 4
tv870 = -280						; size = 4
tv804 = -276						; size = 4
tv736 = -272						; size = 4
tv796 = -268						; size = 4
tv675 = -264						; size = 4
tv876 = -260						; size = 4
tv666 = -256						; size = 4
tv789 = -252						; size = 4
tv580 = -248						; size = 4
tv781 = -244						; size = 4
tv611 = -240						; size = 4
tv874 = -236						; size = 4
tv602 = -232						; size = 4
tv774 = -228						; size = 4
tv589 = -224						; size = 4
tv766 = -220						; size = 4
tv860 = -216						; size = 4
tv872 = -212						; size = 4
tv866 = -208						; size = 4
_pSubSTarget$ = -204					; size = 4
tv210 = -200						; size = 4
tv318 = -196						; size = 4
_thetac1$ = -192					; size = 4
_rateTarget$ = -188					; size = 4
tv268 = -184						; size = 4
_rateLaunch$ = -180					; size = 4
tv222 = -176						; size = 4
_thetac2$ = -172					; size = 4
tv197 = -168						; size = 4
tv69 = -164						; size = 4
_initialRange$ = -160					; size = 4
tv304 = -156						; size = 4
_gammac1$ = -152					; size = 4
tv303 = -148						; size = 4
tv221 = -144						; size = 4
tv292 = -140						; size = 4
tv198 = -136						; size = 4
tv280 = -132						; size = 4
tv186 = -128						; size = 4
tv279 = -124						; size = 4
_gammac2$ = -120					; size = 4
_yTarget$ = -116					; size = 4
_xLaunch2$ = -112					; size = 4
_yLaunch$ = -108					; size = 4
_left$ = -104						; size = 4
_xTarget$ = -100					; size = 4
_xTarget1$ = -96					; size = 4
_xLaunch$ = -92						; size = 4
_xTarget2$ = -88					; size = 4
_xLaunch1$ = -84					; size = 4
_speedTarget$ = -80					; size = 4
_vLaunch$ = -76						; size = 4
_speedLaunch$ = -72					; size = 4
_vTarget$ = -68						; size = 4
_thetaTarget2$ = -64					; size = 4
_thetaTarget1$ = -60					; size = 4
_thetaLaunch1$ = -56					; size = 4
_tMax$ = -52						; size = 4
_timeTarget$ = -48					; size = 4
_timeLaunch$ = -44					; size = 4
_yLaunch1$ = -40					; size = 4
_yLaunch2$ = -36					; size = 4
_thetaLaunch2$ = -32					; size = 4
_yTarget2$ = -28					; size = 4
_yTarget1$ = -24					; size = 4
_aspectTarget$ = -20					; size = 4
_aspectLaunch$ = -16					; size = 4
_radiusLaunch$ = -12					; size = 4
_rc$ = -8						; size = 4
_radiusTarget$ = -4					; size = 4
_target$ = 8						; size = 4
_launcher$ = 12						; size = 4
?RangeAtTailChase@@YAMPAVAircraftClass@@PAVSimObjectType@@@Z PROC ; RangeAtTailChase

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH

; 249  : float initialRange, finalRange;
; 250  : float vLaunch, vTarget;
; 251  : float aspectLaunch, aspectTarget;
; 252  : float pSubSLaunch, pSubSTarget;
; 253  : float radiusLaunch, radiusTarget;
; 254  : float rateLaunch, rateTarget;
; 255  : float xLaunch, xTarget; 
; 256  : float xLaunch1, xTarget1;
; 257  : float xLaunch2, xTarget2;
; 258  : float yLaunch, yTarget; 
; 259  : float yLaunch1, yTarget1;
; 260  : float yLaunch2, yTarget2;
; 261  : float thetaLaunch1, thetaTarget1;
; 262  : float thetaLaunch2, thetaTarget2;
; 263  : float timeLaunch, timeTarget;
; 264  : float speedLaunch, speedTarget;
; 265  : float rc;
; 266  : float thetac1, thetac2;
; 267  : float gammac1, gammac2;
; 268  : float tMax;
; 269  : int left = FALSE;

	mov	DWORD PTR _left$[ebp], 0

; 270  : 
; 271  :    // Initializations
; 272  :    initialRange = launcher->localData->range;

	mov	eax, DWORD PTR _launcher$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _initialRange$[ebp], xmm0

; 273  :    vLaunch = launcher->BaseData()->GetVt();

	mov	ecx, DWORD PTR _launcher$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv69[ebp], eax
	mov	edx, DWORD PTR tv69[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv69[ebp]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR _vLaunch$[ebp]

; 274  :    vTarget = target->GetVt();

	mov	eax, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR _vTarget$[ebp]

; 275  : 
; 276  :    // Current aspect
; 277  :    if (launcher->localData->az > 0.0F)

	mov	ecx, DWORD PTR _launcher$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@RangeAtTai

; 278  :       aspectTarget = (180.0F * DTR) - launcher->localData->ata;

	mov	eax, DWORD PTR _launcher$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR __real@40490fd9
	subss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _aspectTarget$[ebp], xmm0

; 279  :    else

	jmp	SHORT $LN9@RangeAtTai
$LN10@RangeAtTai:

; 280  :       aspectTarget = launcher->localData->ata - (180.0F * DTR);

	mov	edx, DWORD PTR _launcher$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR _aspectTarget$[ebp], xmm0
$LN9@RangeAtTai:

; 281  : 
; 282  :    if (launcher->localData->azFrom > 0.0F)

	mov	ecx, DWORD PTR _launcher$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+20]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@RangeAtTai

; 283  :       aspectLaunch = (180.0F * DTR) - launcher->localData->ataFrom;

	mov	eax, DWORD PTR _launcher$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR __real@40490fd9
	subss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR _aspectLaunch$[ebp], xmm0

; 284  :    else

	jmp	SHORT $LN7@RangeAtTai
$LN8@RangeAtTai:

; 285  :       aspectLaunch = launcher->localData->ataFrom - (180.0F * DTR);

	mov	edx, DWORD PTR _launcher$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR __real@40490fd9
	movss	DWORD PTR _aspectLaunch$[ebp], xmm0
$LN7@RangeAtTai:

; 286  : 
; 287  :    // Excess energy. Assume he's in better shape than me
; 288  :    pSubSTarget = target->af->PsubS(TRUE);

	push	1
	mov	ecx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?PsubS@AirframeClass@@QAEMH@Z		; AirframeClass::PsubS
	fstp	DWORD PTR _pSubSTarget$[ebp]

; 289  :    pSubSLaunch = 1.2F * pSubSTarget;

	movss	xmm0, DWORD PTR __real@3f99999a
	mulss	xmm0, DWORD PTR _pSubSTarget$[ebp]
	movss	DWORD PTR _pSubSLaunch$[ebp], xmm0

; 290  : 
; 291  :    // Turn Radii (assume 5g turn)
; 292  :    radiusLaunch = vLaunch*vLaunch / (5.0F * GRAVITY);

	movss	xmm0, DWORD PTR _vLaunch$[ebp]
	mulss	xmm0, DWORD PTR _vLaunch$[ebp]
	divss	xmm0, DWORD PTR __real@4320e28f
	movss	DWORD PTR _radiusLaunch$[ebp], xmm0

; 293  :    radiusTarget = vTarget*vTarget / (target->af->SustainedGs(TRUE) * GRAVITY);

	movss	xmm0, DWORD PTR _vTarget$[ebp]
	mulss	xmm0, DWORD PTR _vTarget$[ebp]
	push	1
	mov	edx, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	movss	DWORD PTR tv860[ebp], xmm0
	call	?SustainedGs@AirframeClass@@QAEMH@Z	; AirframeClass::SustainedGs
	fstp	DWORD PTR tv580[ebp]
	movss	xmm0, DWORD PTR tv580[ebp]
	mulss	xmm0, DWORD PTR __real@4200b53f
	movss	xmm1, DWORD PTR tv860[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _radiusTarget$[ebp], xmm1

; 294  : 
; 295  :    // Turn rate
; 296  :    rateLaunch = vLaunch / radiusLaunch;

	movss	xmm0, DWORD PTR _vLaunch$[ebp]
	divss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	movss	DWORD PTR _rateLaunch$[ebp], xmm0

; 297  :    rateTarget = vTarget / radiusTarget;

	movss	xmm0, DWORD PTR _vTarget$[ebp]
	divss	xmm0, DWORD PTR _radiusTarget$[ebp]
	movss	DWORD PTR _rateTarget$[ebp], xmm0

; 298  : 
; 299  :    // Go Left
; 300  :    xLaunch1 = -radiusLaunch*(float)sin(aspectLaunch);

	movss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _aspectLaunch$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv862[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv589[ebp]
	movss	xmm0, DWORD PTR tv862[ebp]
	mulss	xmm0, DWORD PTR tv589[ebp]
	movss	DWORD PTR _xLaunch1$[ebp], xmm0

; 301  :    yLaunch1 =  radiusLaunch*(float)cos(aspectLaunch);

	push	ecx
	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv595[ebp]
	movss	xmm0, DWORD PTR tv595[ebp]
	mulss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	movss	DWORD PTR _yLaunch1$[ebp], xmm0

; 302  : 
; 303  :    xTarget1 =  initialRange + radiusTarget*(float)sin(aspectTarget);

	push	ecx
	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv602[ebp]
	movss	xmm0, DWORD PTR tv602[ebp]
	mulss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _initialRange$[ebp]
	movss	DWORD PTR _xTarget1$[ebp], xmm0

; 304  :    yTarget1 = -radiusTarget*(float)cos(aspectTarget);

	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _aspectTarget$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv864[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv611[ebp]
	movss	xmm0, DWORD PTR tv864[ebp]
	mulss	xmm0, DWORD PTR tv611[ebp]
	movss	DWORD PTR _yTarget1$[ebp], xmm0

; 305  : 
; 306  :    rc = (float)sqrt ((xLaunch1-xTarget1)*(xLaunch1-xTarget1) +(yLaunch1-yTarget1)*(yLaunch1-yTarget1));

	movss	xmm0, DWORD PTR _xLaunch1$[ebp]
	subss	xmm0, DWORD PTR _xTarget1$[ebp]
	movss	xmm1, DWORD PTR _xLaunch1$[ebp]
	subss	xmm1, DWORD PTR _xTarget1$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _yLaunch1$[ebp]
	subss	xmm1, DWORD PTR _yTarget1$[ebp]
	movss	xmm2, DWORD PTR _yLaunch1$[ebp]
	subss	xmm2, DWORD PTR _yTarget1$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _rc$[ebp]

; 307  :    thetac1 = (float)asin (max (-1.0F, min (1.0F, (radiusTarget + radiusLaunch)/rc)));

	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN13@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv186[ebp], xmm0
	jmp	SHORT $LN14@RangeAtTai
$LN13@RangeAtTai:
	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv186[ebp], xmm0
$LN14@RangeAtTai:
	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR tv186[ebp]
	jbe	SHORT $LN17@RangeAtTai
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv198[ebp], xmm0
	jmp	SHORT $LN18@RangeAtTai
$LN17@RangeAtTai:
	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN15@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv197[ebp], xmm0
	jmp	SHORT $LN16@RangeAtTai
$LN15@RangeAtTai:
	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv197[ebp], xmm0
$LN16@RangeAtTai:
	movss	xmm0, DWORD PTR tv197[ebp]
	movss	DWORD PTR tv198[ebp], xmm0
$LN18@RangeAtTai:
	push	ecx
	movss	xmm0, DWORD PTR tv198[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	fstp	DWORD PTR _thetac1$[ebp]

; 308  :    gammac1 = (float)asin (max (-1.0F, min (1.0F, (yTarget1 - yLaunch1)/rc)));

	movss	xmm0, DWORD PTR _yTarget1$[ebp]
	subss	xmm0, DWORD PTR _yLaunch1$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN19@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv210[ebp], xmm0
	jmp	SHORT $LN20@RangeAtTai
$LN19@RangeAtTai:
	movss	xmm0, DWORD PTR _yTarget1$[ebp]
	subss	xmm0, DWORD PTR _yLaunch1$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv210[ebp], xmm0
$LN20@RangeAtTai:
	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR tv210[ebp]
	jbe	SHORT $LN23@RangeAtTai
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv222[ebp], xmm0
	jmp	SHORT $LN24@RangeAtTai
$LN23@RangeAtTai:
	movss	xmm0, DWORD PTR _yTarget1$[ebp]
	subss	xmm0, DWORD PTR _yLaunch1$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN21@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv221[ebp], xmm0
	jmp	SHORT $LN22@RangeAtTai
$LN21@RangeAtTai:
	movss	xmm0, DWORD PTR _yTarget1$[ebp]
	subss	xmm0, DWORD PTR _yLaunch1$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv221[ebp], xmm0
$LN22@RangeAtTai:
	movss	xmm0, DWORD PTR tv221[ebp]
	movss	DWORD PTR tv222[ebp], xmm0
$LN24@RangeAtTai:
	push	ecx
	movss	xmm0, DWORD PTR tv222[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	fstp	DWORD PTR _gammac1$[ebp]

; 309  : 
; 310  :    thetaLaunch1 = -(aspectLaunch - gammac1 - thetac1);

	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	subss	xmm0, DWORD PTR _gammac1$[ebp]
	subss	xmm0, DWORD PTR _thetac1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _thetaLaunch1$[ebp], xmm0

; 311  :    thetaTarget1 = aspectTarget - gammac1 - thetac1;

	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _gammac1$[ebp]
	subss	xmm0, DWORD PTR _thetac1$[ebp]
	movss	DWORD PTR _thetaTarget1$[ebp], xmm0

; 312  : 
; 313  :    // Go Right
; 314  :    xLaunch2 =  radiusLaunch*(float)sin(aspectLaunch);

	push	ecx
	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv652[ebp]
	movss	xmm0, DWORD PTR tv652[ebp]
	mulss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	movss	DWORD PTR _xLaunch2$[ebp], xmm0

; 315  :    yLaunch2 = -radiusLaunch*(float)cos(aspectLaunch);

	movss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _aspectLaunch$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv866[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv660[ebp]
	movss	xmm0, DWORD PTR tv866[ebp]
	mulss	xmm0, DWORD PTR tv660[ebp]
	movss	DWORD PTR _yLaunch2$[ebp], xmm0

; 316  : 
; 317  :    xTarget2 =  initialRange + radiusTarget*(float)sin(aspectTarget);

	push	ecx
	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv666[ebp]
	movss	xmm0, DWORD PTR tv666[ebp]
	mulss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _initialRange$[ebp]
	movss	DWORD PTR _xTarget2$[ebp], xmm0

; 318  :    yTarget2 = -radiusTarget*(float)cos(aspectTarget);

	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	xmm1, DWORD PTR _aspectTarget$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv868[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv675[ebp]
	movss	xmm0, DWORD PTR tv868[ebp]
	mulss	xmm0, DWORD PTR tv675[ebp]
	movss	DWORD PTR _yTarget2$[ebp], xmm0

; 319  : 
; 320  :    rc = (float)sqrt ((xLaunch2-xTarget2)*(xLaunch2-xTarget2) +(yLaunch2-yTarget2)*(yLaunch2-yTarget2));

	movss	xmm0, DWORD PTR _xLaunch2$[ebp]
	subss	xmm0, DWORD PTR _xTarget2$[ebp]
	movss	xmm1, DWORD PTR _xLaunch2$[ebp]
	subss	xmm1, DWORD PTR _xTarget2$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _yLaunch2$[ebp]
	subss	xmm1, DWORD PTR _yTarget2$[ebp]
	movss	xmm2, DWORD PTR _yLaunch2$[ebp]
	subss	xmm2, DWORD PTR _yTarget2$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _rc$[ebp]

; 321  :    thetac2 = (float)asin (max (-1.0F, min (1.0F, (radiusTarget - radiusLaunch)/rc)));

	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	subss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN25@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN26@RangeAtTai
$LN25@RangeAtTai:
	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	subss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv268[ebp], xmm0
$LN26@RangeAtTai:
	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR tv268[ebp]
	jbe	SHORT $LN29@RangeAtTai
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv280[ebp], xmm0
	jmp	SHORT $LN30@RangeAtTai
$LN29@RangeAtTai:
	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	subss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN27@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv279[ebp], xmm0
	jmp	SHORT $LN28@RangeAtTai
$LN27@RangeAtTai:
	movss	xmm0, DWORD PTR _radiusTarget$[ebp]
	subss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv279[ebp], xmm0
$LN28@RangeAtTai:
	movss	xmm0, DWORD PTR tv279[ebp]
	movss	DWORD PTR tv280[ebp], xmm0
$LN30@RangeAtTai:
	push	ecx
	movss	xmm0, DWORD PTR tv280[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	fstp	DWORD PTR _thetac2$[ebp]

; 322  :    gammac2 = (float)asin (max (-1.0F, min (1.0F, (yTarget2 - yLaunch2)/rc)));

	movss	xmm0, DWORD PTR _yTarget2$[ebp]
	subss	xmm0, DWORD PTR _yLaunch2$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN31@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv292[ebp], xmm0
	jmp	SHORT $LN32@RangeAtTai
$LN31@RangeAtTai:
	movss	xmm0, DWORD PTR _yTarget2$[ebp]
	subss	xmm0, DWORD PTR _yLaunch2$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv292[ebp], xmm0
$LN32@RangeAtTai:
	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR tv292[ebp]
	jbe	SHORT $LN35@RangeAtTai
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv304[ebp], xmm0
	jmp	SHORT $LN36@RangeAtTai
$LN35@RangeAtTai:
	movss	xmm0, DWORD PTR _yTarget2$[ebp]
	subss	xmm0, DWORD PTR _yLaunch2$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN33@RangeAtTai
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv303[ebp], xmm0
	jmp	SHORT $LN34@RangeAtTai
$LN33@RangeAtTai:
	movss	xmm0, DWORD PTR _yTarget2$[ebp]
	subss	xmm0, DWORD PTR _yLaunch2$[ebp]
	divss	xmm0, DWORD PTR _rc$[ebp]
	movss	DWORD PTR tv303[ebp], xmm0
$LN34@RangeAtTai:
	movss	xmm0, DWORD PTR tv303[ebp]
	movss	DWORD PTR tv304[ebp], xmm0
$LN36@RangeAtTai:
	push	ecx
	movss	xmm0, DWORD PTR tv304[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?asin@@YAMM@Z				; asin
	add	esp, 4
	fstp	DWORD PTR _gammac2$[ebp]

; 323  : 
; 324  :    thetaLaunch2 = aspectLaunch - gammac2 - thetac2;

	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	subss	xmm0, DWORD PTR _gammac2$[ebp]
	subss	xmm0, DWORD PTR _thetac2$[ebp]
	movss	DWORD PTR _thetaLaunch2$[ebp], xmm0

; 325  :    thetaTarget2 = aspectTarget - gammac2 - thetac2;

	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _gammac2$[ebp]
	subss	xmm0, DWORD PTR _thetac2$[ebp]
	movss	DWORD PTR _thetaTarget2$[ebp], xmm0

; 326  : 
; 327  :    // Choose between left and right
; 328  :    if (thetaLaunch2 < 0.0F || thetaLaunch1 > thetaLaunch2)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _thetaLaunch2$[ebp]
	ja	SHORT $LN5@RangeAtTai
	movss	xmm0, DWORD PTR _thetaLaunch1$[ebp]
	comiss	xmm0, DWORD PTR _thetaLaunch2$[ebp]
	jbe	SHORT $LN6@RangeAtTai
$LN5@RangeAtTai:

; 329  :       left = TRUE;

	mov	DWORD PTR _left$[ebp], 1
$LN6@RangeAtTai:

; 330  : 
; 331  :    // if left use the 1 case, otherwise use the 2 case
; 332  :    if (left)

	cmp	DWORD PTR _left$[ebp], 0
	je	SHORT $LN4@RangeAtTai

; 333  :    {
; 334  :       timeLaunch = thetaLaunch1 / rateLaunch;

	movss	xmm0, DWORD PTR _thetaLaunch1$[ebp]
	divss	xmm0, DWORD PTR _rateLaunch$[ebp]
	movss	DWORD PTR _timeLaunch$[ebp], xmm0

; 335  :       timeTarget = thetaTarget1 / rateTarget;

	movss	xmm0, DWORD PTR _thetaTarget1$[ebp]
	divss	xmm0, DWORD PTR _rateTarget$[ebp]
	movss	DWORD PTR _timeTarget$[ebp], xmm0

; 336  :    }
; 337  :    else

	jmp	SHORT $LN3@RangeAtTai
$LN4@RangeAtTai:

; 338  :    {
; 339  :       timeLaunch = thetaLaunch2 / rateLaunch;

	movss	xmm0, DWORD PTR _thetaLaunch2$[ebp]
	divss	xmm0, DWORD PTR _rateLaunch$[ebp]
	movss	DWORD PTR _timeLaunch$[ebp], xmm0

; 340  :       timeTarget = thetaTarget2 / rateTarget;

	movss	xmm0, DWORD PTR _thetaTarget2$[ebp]
	divss	xmm0, DWORD PTR _rateTarget$[ebp]
	movss	DWORD PTR _timeTarget$[ebp], xmm0
$LN3@RangeAtTai:

; 341  :    }
; 342  :    tMax = max (timeLaunch, timeTarget);

	movss	xmm0, DWORD PTR _timeLaunch$[ebp]
	comiss	xmm0, DWORD PTR _timeTarget$[ebp]
	jbe	SHORT $LN37@RangeAtTai
	movss	xmm0, DWORD PTR _timeLaunch$[ebp]
	movss	DWORD PTR tv318[ebp], xmm0
	jmp	SHORT $LN38@RangeAtTai
$LN37@RangeAtTai:
	movss	xmm0, DWORD PTR _timeTarget$[ebp]
	movss	DWORD PTR tv318[ebp], xmm0
$LN38@RangeAtTai:
	movss	xmm0, DWORD PTR tv318[ebp]
	movss	DWORD PTR _tMax$[ebp], xmm0

; 343  : 
; 344  :    speedLaunch = vLaunch*(tMax - timeLaunch) +
; 345  :       pSubSLaunch*GRAVITY * 0.5F * (tMax - timeLaunch) * (tMax - timeLaunch);

	movss	xmm0, DWORD PTR _tMax$[ebp]
	subss	xmm0, DWORD PTR _timeLaunch$[ebp]
	mulss	xmm0, DWORD PTR _vLaunch$[ebp]
	movss	xmm1, DWORD PTR _pSubSLaunch$[ebp]
	mulss	xmm1, DWORD PTR __real@4200b53f
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR _tMax$[ebp]
	subss	xmm2, DWORD PTR _timeLaunch$[ebp]
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR _tMax$[ebp]
	subss	xmm2, DWORD PTR _timeLaunch$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	movss	DWORD PTR _speedLaunch$[ebp], xmm0

; 346  :    speedTarget = vTarget*(tMax - timeTarget) +
; 347  :       pSubSTarget*GRAVITY * 0.5F * (tMax - timeTarget) * (tMax - timeTarget);

	movss	xmm0, DWORD PTR _tMax$[ebp]
	subss	xmm0, DWORD PTR _timeTarget$[ebp]
	mulss	xmm0, DWORD PTR _vTarget$[ebp]
	movss	xmm1, DWORD PTR _pSubSTarget$[ebp]
	mulss	xmm1, DWORD PTR __real@4200b53f
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR _tMax$[ebp]
	subss	xmm2, DWORD PTR _timeTarget$[ebp]
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR _tMax$[ebp]
	subss	xmm2, DWORD PTR _timeTarget$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	movss	DWORD PTR _speedTarget$[ebp], xmm0

; 348  : 
; 349  : 
; 350  :    // Find range when stern chase begins
; 351  :    if (left)

	cmp	DWORD PTR _left$[ebp], 0
	je	$LN2@RangeAtTai

; 352  :    {
; 353  :       xLaunch = xLaunch1 + radiusLaunch * (float)sin(aspectLaunch + thetaLaunch1) +
; 354  :                 speedLaunch * (float)cos(aspectLaunch + thetaLaunch1);

	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	addss	xmm0, DWORD PTR _thetaLaunch1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv736[ebp]
	movss	xmm0, DWORD PTR tv736[ebp]
	mulss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	addss	xmm0, DWORD PTR _xLaunch1$[ebp]
	movss	xmm1, DWORD PTR _aspectLaunch$[ebp]
	addss	xmm1, DWORD PTR _thetaLaunch1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv870[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv744[ebp]
	movss	xmm0, DWORD PTR tv744[ebp]
	mulss	xmm0, DWORD PTR _speedLaunch$[ebp]
	movss	xmm1, DWORD PTR tv870[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _xLaunch$[ebp], xmm1

; 355  :       yLaunch = yLaunch1 - radiusLaunch * (float)cos(aspectLaunch + thetaLaunch1) +
; 356  :                 speedLaunch * (float)sin(aspectLaunch + thetaLaunch1);

	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	addss	xmm0, DWORD PTR _thetaLaunch1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv751[ebp]
	movss	xmm0, DWORD PTR tv751[ebp]
	mulss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	movss	xmm1, DWORD PTR _yLaunch1$[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	addss	xmm0, DWORD PTR _thetaLaunch1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	DWORD PTR tv872[ebp], xmm1
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv759[ebp]
	movss	xmm0, DWORD PTR tv759[ebp]
	mulss	xmm0, DWORD PTR _speedLaunch$[ebp]
	movss	xmm1, DWORD PTR tv872[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _yLaunch$[ebp], xmm1

; 357  :       xTarget = xTarget1 - radiusTarget * (float)sin(aspectTarget - thetaTarget1) +
; 358  :                 speedTarget * (float)cos(aspectTarget - thetaTarget1);

	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _thetaTarget1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv766[ebp]
	movss	xmm0, DWORD PTR tv766[ebp]
	mulss	xmm0, DWORD PTR _radiusTarget$[ebp]
	movss	xmm1, DWORD PTR _xTarget1$[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _thetaTarget1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	DWORD PTR tv874[ebp], xmm1
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv774[ebp]
	movss	xmm0, DWORD PTR tv774[ebp]
	mulss	xmm0, DWORD PTR _speedTarget$[ebp]
	movss	xmm1, DWORD PTR tv874[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _xTarget$[ebp], xmm1

; 359  :       yTarget = yTarget1 + radiusTarget * (float)cos(aspectTarget - thetaTarget1) +
; 360  :                 speedTarget * (float)sin(aspectTarget - thetaTarget1);

	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _thetaTarget1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv781[ebp]
	movss	xmm0, DWORD PTR tv781[ebp]
	mulss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _yTarget1$[ebp]
	movss	xmm1, DWORD PTR _aspectTarget$[ebp]
	subss	xmm1, DWORD PTR _thetaTarget1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv876[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv789[ebp]
	movss	xmm0, DWORD PTR tv789[ebp]
	mulss	xmm0, DWORD PTR _speedTarget$[ebp]
	movss	xmm1, DWORD PTR tv876[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _yTarget$[ebp], xmm1

; 361  :    }
; 362  :    else

	jmp	$LN1@RangeAtTai
$LN2@RangeAtTai:

; 363  :    {
; 364  :       xLaunch = xLaunch2 - radiusLaunch * (float)sin(aspectLaunch - thetaLaunch2) +
; 365  :                 speedLaunch * (float)cos(aspectLaunch - thetaLaunch2);

	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	subss	xmm0, DWORD PTR _thetaLaunch2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv796[ebp]
	movss	xmm0, DWORD PTR tv796[ebp]
	mulss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	movss	xmm1, DWORD PTR _xLaunch2$[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	subss	xmm0, DWORD PTR _thetaLaunch2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	DWORD PTR tv878[ebp], xmm1
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv804[ebp]
	movss	xmm0, DWORD PTR tv804[ebp]
	mulss	xmm0, DWORD PTR _speedLaunch$[ebp]
	movss	xmm1, DWORD PTR tv878[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _xLaunch$[ebp], xmm1

; 366  :       yLaunch = yLaunch2 + radiusLaunch * (float)cos(aspectLaunch - thetaLaunch2) +
; 367  :                 speedLaunch * (float)sin(aspectLaunch - thetaLaunch2);

	movss	xmm0, DWORD PTR _aspectLaunch$[ebp]
	subss	xmm0, DWORD PTR _thetaLaunch2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv811[ebp]
	movss	xmm0, DWORD PTR tv811[ebp]
	mulss	xmm0, DWORD PTR _radiusLaunch$[ebp]
	addss	xmm0, DWORD PTR _yLaunch2$[ebp]
	movss	xmm1, DWORD PTR _aspectLaunch$[ebp]
	subss	xmm1, DWORD PTR _thetaLaunch2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv880[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv819[ebp]
	movss	xmm0, DWORD PTR tv819[ebp]
	mulss	xmm0, DWORD PTR _speedLaunch$[ebp]
	movss	xmm1, DWORD PTR tv880[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _yLaunch$[ebp], xmm1

; 368  :       xTarget = xTarget2 - radiusTarget * (float)sin(aspectTarget - thetaTarget2) +
; 369  :                 speedTarget * (float)cos(aspectTarget - thetaTarget2);

	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _thetaTarget2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv826[ebp]
	movss	xmm0, DWORD PTR tv826[ebp]
	mulss	xmm0, DWORD PTR _radiusTarget$[ebp]
	movss	xmm1, DWORD PTR _xTarget2$[ebp]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _thetaTarget2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	DWORD PTR tv882[ebp], xmm1
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv834[ebp]
	movss	xmm0, DWORD PTR tv834[ebp]
	mulss	xmm0, DWORD PTR _speedTarget$[ebp]
	movss	xmm1, DWORD PTR tv882[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _xTarget$[ebp], xmm1

; 370  :       yTarget = yTarget2 + radiusTarget * (float)cos(aspectTarget - thetaTarget2) +
; 371  :                 speedTarget * (float)sin(aspectTarget - thetaTarget2);

	movss	xmm0, DWORD PTR _aspectTarget$[ebp]
	subss	xmm0, DWORD PTR _thetaTarget2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv841[ebp]
	movss	xmm0, DWORD PTR tv841[ebp]
	mulss	xmm0, DWORD PTR _radiusTarget$[ebp]
	addss	xmm0, DWORD PTR _yTarget2$[ebp]
	movss	xmm1, DWORD PTR _aspectTarget$[ebp]
	subss	xmm1, DWORD PTR _thetaTarget2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv884[ebp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv849[ebp]
	movss	xmm0, DWORD PTR tv849[ebp]
	mulss	xmm0, DWORD PTR _speedTarget$[ebp]
	movss	xmm1, DWORD PTR tv884[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _yTarget$[ebp], xmm1
$LN1@RangeAtTai:

; 372  :    }
; 373  : 
; 374  :    finalRange = (float)sqrt((xLaunch-xTarget)*(xLaunch-xTarget) + (yLaunch-yTarget)*(yLaunch-yTarget));

	movss	xmm0, DWORD PTR _xLaunch$[ebp]
	subss	xmm0, DWORD PTR _xTarget$[ebp]
	movss	xmm1, DWORD PTR _xLaunch$[ebp]
	subss	xmm1, DWORD PTR _xTarget$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _yLaunch$[ebp]
	subss	xmm1, DWORD PTR _yTarget$[ebp]
	movss	xmm2, DWORD PTR _yLaunch$[ebp]
	subss	xmm2, DWORD PTR _yTarget$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _finalRange$[ebp]

; 375  : 
; 376  :    return finalRange;

	fld	DWORD PTR _finalRange$[ebp]

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RangeAtTailChase@@YAMPAVAircraftClass@@PAVSimObjectType@@@Z ENDP ; RangeAtTailChase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningTactical@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningTactical, COMDAT
; _this$ = ecx

; 57   : 	bool RunningTactical() const             { return FalconLocalGame->GetGameType() == game_TacticalEngagement; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningTac
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningTac
$LN3@RunningTac:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningTac:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN5@RunningTac
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningTac
$LN5@RunningTac:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningTac:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningTactical@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Fuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Fuel@AirframeClass@@QAEMXZ PROC			; AirframeClass::Fuel, COMDAT
; _this$ = ecx

; 1183 : 	float Fuel (void) {return fuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?Fuel@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Fuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?IsSetATC@DigitalBrain@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetATC@DigitalBrain@@QAEHH@Z PROC			; DigitalBrain::IsSetATC, COMDAT
; _this$ = ecx

; 709  : 	int		IsSetATC(int flag)								{return (atcFlags & flag) && TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetATC
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@IsSetATC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetATC
$LN3@IsSetATC:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetATC:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetATC@DigitalBrain@@QAEHH@Z ENDP			; DigitalBrain::IsSetATC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetATCFlag@DigitalBrain@@QAEXH@Z PROC			; DigitalBrain::SetATCFlag, COMDAT
; _this$ = ecx

; 707  : 	void	SetATCFlag(int flag)							{atcFlags |= flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetATCFlag@DigitalBrain@@QAEXH@Z ENDP			; DigitalBrain::SetATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\separate.cpp
_TEXT	SEGMENT
tv613 = -84						; size = 4
_sepRange$ = -80					; size = 4
_turnRadius$ = -76					; size = 4
tv620 = -72						; size = 4
tv654 = -68						; size = 4
tv626 = -64						; size = 4
tv652 = -60						; size = 4
tv82 = -56						; size = 4
_rMaxNe$ = -52						; size = 4
tv488 = -48						; size = 4
_gs$ = -44						; size = 4
_inTraining$ = -38					; size = 1
_aaAbort$ = -37						; size = 1
_tmpWaypoint$ = -36					; size = 4
_agAbort$ = -31						; size = 1
_campAbort$ = -30					; size = 1
_damageAbort$ = -29					; size = 1
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?SeparateCheck@DigitalBrain@@IAEXXZ PROC		; DigitalBrain::SeparateCheck
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 26   : float turnRadius, rMaxNe, sepRange;
; 27   : float gs;
; 28   : WayPointClass* tmpWaypoint = self->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], edx

; 29   : short edata[10];
; 30   : char inTraining = FALSE;

	mov	BYTE PTR _inTraining$[ebp], 0

; 31   : char aaAbort = FALSE;

	mov	BYTE PTR _aaAbort$[ebp], 0

; 32   : char agAbort = FALSE;

	mov	BYTE PTR _agAbort$[ebp], 0

; 33   : char campAbort = FALSE;

	mov	BYTE PTR _campAbort$[ebp], 0

; 34   : char damageAbort = FALSE;

	mov	BYTE PTR _damageAbort$[ebp], 0

; 35   : 
; 36   : 
; 37   : 
; 38   : //Cobra test we want to stop AI from aborting in fictional dogfight scenario
; 39   : if (FalconLocalGame->GetGameType() == game_Dogfight)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN51@SeparateCh
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN52@SeparateCh
$LN51@SeparateCh:
	mov	DWORD PTR tv82[ebp], 0
$LN52@SeparateCh:
	mov	ecx, DWORD PTR tv82[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	SHORT $LN48@SeparateCh

; 40   : return;

	jmp	$LN49@SeparateCh
$LN48@SeparateCh:

; 41   : 
; 42   :    // Check for RTB
; 43   :    if (((SimDriver.RunningTactical() && current_tactical_mission &&
; 44   : 		   current_tactical_mission->get_type() == tt_training)))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningTactical
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN47@SeparateCh
	cmp	DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A, 0 ; current_tactical_mission
	je	SHORT $LN47@SeparateCh
	mov	ecx, DWORD PTR ?current_tactical_mission@@3PAVtactical_mission@@A ; current_tactical_mission
	call	?get_type@tactical_mission@@QAE?AW4tactical_type@@XZ ; tactical_mission::get_type
	cmp	eax, 3
	jne	SHORT $LN47@SeparateCh

; 45   :    {
; 46   :       inTraining = TRUE;

	mov	BYTE PTR _inTraining$[ebp], 1
$LN47@SeparateCh:

; 47   :    }
; 48   : // 2001-08-31 BROUGHT BACK TO LIKE IT IS WAS ORIGINALLY (ALSO LIKE IN RP4/5)
; 49   :    if (missionClass == AAMission && !IsSetATC(AceGunsEngage))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+288], 1
	jne	SHORT $LN46@SeparateCh
	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN46@SeparateCh

; 50   :       aaAbort = FALSE;

	mov	BYTE PTR _aaAbort$[ebp], 0
$LN46@SeparateCh:

; 51   : // 2002-02-12 added by MN - Aircraftclass checks for target being occupied and sets AWACSsaidAbort
; 52   : // Do an agAbort here if so
; 53   :    if (self->AWACSsaidAbort)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movzx	edx, BYTE PTR [ecx+1832]
	test	edx, edx
	je	SHORT $LN45@SeparateCh

; 54   :    {
; 55   : 	   SetGroundTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z ; DigitalBrain::SetGroundTarget

; 56   : 	   agAbort = TRUE;

	mov	BYTE PTR _agAbort$[ebp], 1
$LN45@SeparateCh:

; 57   :    }
; 58   :    
; 59   : // 2001-12-28 MN this prevents FAC aircraft from aborting missions in 3D (they have no weapons..)
; 60   :   /* if (missionClass == AGMission && !IsSetATC(HasAGWeapon) && missionType != AMIS_FAC)
; 61   :    {
; 62   :       if ((missionType != AMIS_BDA && missionType != AMIS_RECON) || !hasCamera)
; 63   : // 2001-05-12 ADDED BY S.G. ABORT ONLY WHEN THE MISSION IS NOT COMPLETED OR WE ARE AT THE ATTACK WAYPOINT, OTHERWISE FOLLOW WAYPOINTS HOME
; 64   : // 2001-06-21 MODIFIED BY S.G. BROUGHT BACK TO WHAT IS RELEASED
; 65   : //		   if (!missionComplete || !self->curWaypoint || self->curWaypoint->GetWPFlags() & WPF_TARGET)
; 66   : 		   if (!missionComplete)
; 67   : // END OF ADDED SECTION
; 68   : 	         agAbort = TRUE;
; 69   :    }*/
; 70   : 
; 71   :    if (missionType == AMIS_ABORT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+284], 39			; 00000027H
	jne	SHORT $LN44@SeparateCh

; 72   :       campAbort = TRUE;

	mov	BYTE PTR _campAbort$[ebp], 1
$LN44@SeparateCh:

; 73   : 
; 74   :   
; 75   : 
; 76   :    if (self->pctStrength < 0.50F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [edx+292]
	jbe	SHORT $LN43@SeparateCh

; 77   :       damageAbort = TRUE;

	mov	BYTE PTR _damageAbort$[ebp], 1
$LN43@SeparateCh:

; 78   : 
; 79   :    if ((aaAbort || agAbort || campAbort || damageAbort) && !inTraining)

	movsx	eax, BYTE PTR _aaAbort$[ebp]
	test	eax, eax
	jne	SHORT $LN41@SeparateCh
	movsx	ecx, BYTE PTR _agAbort$[ebp]
	test	ecx, ecx
	jne	SHORT $LN41@SeparateCh
	movsx	edx, BYTE PTR _campAbort$[ebp]
	test	edx, edx
	jne	SHORT $LN41@SeparateCh
	movsx	eax, BYTE PTR _damageAbort$[ebp]
	test	eax, eax
	je	$LN26@SeparateCh
$LN41@SeparateCh:
	movsx	ecx, BYTE PTR _inTraining$[ebp]
	test	ecx, ecx
	jne	$LN26@SeparateCh

; 80   :    {
; 81   :       // If pre IP go to landing, else step past target
; 82   :       if (curMode != RTBMode && curMode != LandingMode && curMode != TakeoffMode)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 19			; 00000013H
	je	$LN27@SeparateCh
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 5
	je	$LN27@SeparateCh
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	$LN27@SeparateCh

; 83   :       {
; 84   :          // Drop ground target if any
; 85   :          if (groundTargetPtr)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+224], 0
	je	SHORT $LN39@SeparateCh

; 86   :          {
; 87   :             SetGroundTarget (NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z ; DigitalBrain::SetGroundTarget
$LN39@SeparateCh:

; 88   :          }
; 89   : 
; 90   : // 2001-05-13 MODIFIED BY S.G. TO MAKE IT SIMILAR TO THE ABOVE agAbort CODE
; 91   : // 2001-06-21 RESTATED BY S.G. BROUGHT BACK TO WHAT IS RELEASED
; 92   :          if (!IsSetATC(ReachedIP))

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	$LN38@SeparateCh
$LN37@SeparateCh:

; 93   : //	     if (!missionComplete || !self->curWaypoint || self->curWaypoint->GetWPFlags() & WPF_TARGET)
; 94   :          {
; 95   : 			 // Find the landing waypoint, and make it the current one
; 96   : 			 while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN36@SeparateCh

; 97   : 			 {
; 98   : 				 if (tmpWaypoint->GetWPAction() == WP_LAND)

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN35@SeparateCh

; 99   : 				 {
; 100  : 					 break;

	jmp	SHORT $LN36@SeparateCh
$LN35@SeparateCh:

; 101  : 				 }
; 102  : 				 tmpWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 103  : 			 }

	jmp	SHORT $LN37@SeparateCh
$LN36@SeparateCh:

; 104  : 			 
; 105  : 			 if (tmpWaypoint && !isWing)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN34@SeparateCh
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN34@SeparateCh

; 106  : 			 {
; 107  : 				 self->curWaypoint = tmpWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _tmpWaypoint$[ebp]
	mov	DWORD PTR [edx+728], eax

; 108  : 				 SetWaypointSpecificStuff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWaypointSpecificStuff@DigitalBrain@@IAEXXZ ; DigitalBrain::SetWaypointSpecificStuff
$LN34@SeparateCh:

; 109  : 			 }
; 110  : 			 
; 111  : 			 if(!IsSetATC(SaidRTB))

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN33@SeparateCh

; 112  : 			 {
; 113  : 				 SetATCFlag(SaidRTB);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 114  : 				 // Call going home
; 115  : 				 edata[0] = isWing;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+24]
	mov	WORD PTR _edata$[ebp+ecx], ax

; 116  : 				 AiMakeRadioResponse( self, rcIMADOT, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	97					; 00000061H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN33@SeparateCh:

; 117  : 			 }
; 118  :          }
; 119  :          else

	jmp	$LN27@SeparateCh
$LN38@SeparateCh:

; 120  :          {
; 121  : 					// Find the waypoint after the target, and make it the current one if
; 122  : 					// we haven't gotten there yet
; 123  : 					tmpWaypoint = self->curWaypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+728]
	mov	DWORD PTR _tmpWaypoint$[ebp], eax
$LN31@SeparateCh:

; 124  : 					while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN30@SeparateCh

; 125  : 					{
; 126  : 						// 2001-05-13 MODIFIED BY S.G. WPF_TARGET IS A FLAG WITHIN MANY, DON'T TEST FOR EQUALITY!
; 127  : 						//				 if (tmpWaypoint->GetWPFlags() == WPF_TARGET)
; 128  : 						if (tmpWaypoint->GetWPFlags() & WPF_TARGET)

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN29@SeparateCh

; 129  : 						{
; 130  : 							tmpWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 131  : 							break;

	jmp	SHORT $LN30@SeparateCh
$LN29@SeparateCh:

; 132  : 						}
; 133  : 						tmpWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 134  : 					}

	jmp	SHORT $LN31@SeparateCh
$LN30@SeparateCh:

; 135  : 					 
; 136  : 					if (tmpWaypoint && !isWing)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN28@SeparateCh
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN28@SeparateCh

; 137  : 					{
; 138  : 						self->curWaypoint = tmpWaypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	mov	DWORD PTR [eax+728], ecx

; 139  : 						SetWaypointSpecificStuff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWaypointSpecificStuff@DigitalBrain@@IAEXXZ ; DigitalBrain::SetWaypointSpecificStuff
$LN28@SeparateCh:

; 140  : 					}
; 141  : 					 
; 142  : 					if(!IsSetATC(SaidRTB))

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN27@SeparateCh

; 143  : 					{
; 144  : 						SetATCFlag(SaidRTB);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 145  : 						// Call going home
; 146  : 						edata[0] = isWing;

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+24]
	mov	WORD PTR _edata$[ebp+edx], cx

; 147  : 						AiMakeRadioResponse( self, rcIMADOT, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	97					; 00000061H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN27@SeparateCh:

; 148  : 					}
; 149  :          }
; 150  :       }
; 151  : 	  if (!isWing) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN26@SeparateCh

; 152  : 		  AddMode (RTBMode);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN26@SeparateCh:

; 153  : 	  }
; 154  :    }
; 155  : 
; 156  :    if ((!isWing || IsSetATC(SaidBingo) )&& curMode == RTBMode)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN24@SeparateCh
	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN25@SeparateCh
$LN24@SeparateCh:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 19			; 00000013H
	jne	SHORT $LN25@SeparateCh

; 157  :       AddMode (RTBMode);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN25@SeparateCh:

; 158  : 
; 159  :    if (isWing && mpActionFlags[AI_RTB])

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN23@SeparateCh
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+760], 0
	je	SHORT $LN23@SeparateCh

; 160  :       AddMode (RTBMode);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN23@SeparateCh:

; 161  : 
; 162  :    if (!targetPtr)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN22@SeparateCh

; 163  :       return;

	jmp	$LN49@SeparateCh
$LN22@SeparateCh:

; 164  : 
; 165  :    // If you can't be offensive, and you have a target/threat, run away
; 166  : /*   if (targetPtr->localData->range < 10.0F * targetData->ataFrom / (180.0F * DTR))
; 167  :       AddMode (BugoutMode);
; 168  : *///me123
; 169  :  
; 170  :   
; 171  : 
; 172  :    // go no further unless separation is desired
; 173  :    if (IsSetATC(SaidBingo)  ||
; 174  : 		curMode == WVREngageMode &&(aaAbort || agAbort || campAbort || damageAbort))

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN19@SeparateCh
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 15			; 0000000fH
	jne	$LN8@SeparateCh
	movsx	ecx, BYTE PTR _aaAbort$[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@SeparateCh
	movsx	edx, BYTE PTR _agAbort$[ebp]
	test	edx, edx
	jne	SHORT $LN19@SeparateCh
	movsx	eax, BYTE PTR _campAbort$[ebp]
	test	eax, eax
	jne	SHORT $LN19@SeparateCh
	movsx	ecx, BYTE PTR _damageAbort$[ebp]
	test	ecx, ecx
	je	$LN8@SeparateCh
$LN19@SeparateCh:

; 175  :    {
; 176  :       // Entry
; 177  :       if (curMode != SeparateMode && targetData->range < 2.0f * NM_TO_FT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 8
	je	$LN18@SeparateCh
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR __real@463de1b0
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	$LN18@SeparateCh

; 178  :       {
; 179  :          // Find range where tail chase would begin
; 180  :          sepRange = RangeAtTailChase(self, targetPtr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?RangeAtTailChase@@YAMPAVAircraftClass@@PAVSimObjectType@@@Z ; RangeAtTailChase
	add	esp, 8
	fstp	DWORD PTR _sepRange$[ebp]

; 181  : 
; 182  :          // Find missile Rmax for a tail chase
; 183  :          // Final flag True = MRM, False = SRM
; 184  :          // Skip the check if target has no missiles
; 185  :          if (targetPtr->BaseData()->IsSim() &&
; 186  :              (((SimBaseClass*)targetPtr->BaseData())->IsSetFlag(HAS_MISSILES) || targetPtr->localData->range > 2.0F * NM_TO_FT))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN17@SeparateCh
	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN16@SeparateCh
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR __real@463de1b0
	jbe	SHORT $LN17@SeparateCh
$LN16@SeparateCh:

; 187  :             rMaxNe = TailChaseRMaxNe (self, targetPtr, FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?TailChaseRMaxNe@@YAMPAVAircraftClass@@PAVSimObjectType@@H@Z ; TailChaseRMaxNe
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _rMaxNe$[ebp]

; 188  :          else

	jmp	SHORT $LN15@SeparateCh
$LN17@SeparateCh:

; 189  :             rMaxNe = 6000.0F;

	movss	xmm0, DWORD PTR __real@45bb8000
	movss	DWORD PTR _rMaxNe$[ebp], xmm0
$LN15@SeparateCh:

; 190  : 
; 191  :          // Enter if separation range > rne
; 192  :          if (rMaxNe < sepRange && IsSetATC(SaidJoker))

	movss	xmm0, DWORD PTR _sepRange$[ebp]
	comiss	xmm0, DWORD PTR _rMaxNe$[ebp]
	jbe	$LN10@SeparateCh
	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN10@SeparateCh

; 193  :          {
; 194  :             // If inside one turn radius threat needs to be ahead of 3/9 line
; 195  :             // else behind 3/9 line
; 196  :             gs = af->SustainedGs(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SustainedGs@AirframeClass@@QAEMH@Z	; AirframeClass::SustainedGs
	fstp	DWORD PTR _gs$[ebp]

; 197  :             turnRadius = self->GetVt()*self->GetVt() / ((float)sqrt(gs*gs - 1.0F) * GRAVITY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv613[ebp]
	movss	xmm0, DWORD PTR tv613[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	movss	DWORD PTR tv652[ebp], xmm0
	call	eax
	fstp	DWORD PTR tv620[ebp]
	movss	xmm0, DWORD PTR tv652[ebp]
	mulss	xmm0, DWORD PTR tv620[ebp]
	movss	xmm1, DWORD PTR _gs$[ebp]
	mulss	xmm1, DWORD PTR _gs$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv654[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv626[ebp]
	movss	xmm0, DWORD PTR tv626[ebp]
	mulss	xmm0, DWORD PTR __real@4200b53f
	movss	xmm1, DWORD PTR tv654[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _turnRadius$[ebp], xmm1

; 198  : 
; 199  :             if (targetData->range < turnRadius)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR _turnRadius$[ebp]
	comiss	xmm0, DWORD PTR [edx+44]
	jbe	SHORT $LN13@SeparateCh

; 200  :             {
; 201  :                if (targetData->ata < 90.0*DTR) AddMode(SeparateMode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cvtss2sd xmm0, DWORD PTR [ecx]
	movsd	xmm1, QWORD PTR __real@3ff921fb24000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN12@SeparateCh
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN12@SeparateCh:

; 202  :             }
; 203  :             else

	jmp	SHORT $LN10@SeparateCh
$LN13@SeparateCh:

; 204  :             {
; 205  :                if (targetData->ata > 90.0*DTR) AddMode(SeparateMode);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cvtss2sd xmm0, DWORD PTR [eax]
	comisd	xmm0, QWORD PTR __real@3ff921fb24000000
	jbe	SHORT $LN10@SeparateCh
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN10@SeparateCh:

; 206  :             }
; 207  :          }
; 208  :       }
; 209  : 		else if (targetData->range < 6.0f * NM_TO_FT && 

	jmp	SHORT $LN8@SeparateCh
$LN18@SeparateCh:

; 210  : 			targetPtr->localData->rangedot > 0.0f || 
; 211  : 			targetData->range > 6000)// last mode was seperate

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR __real@470e6944
	comiss	xmm0, DWORD PTR [edx+44]
	jbe	SHORT $LN6@SeparateCh
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+48]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN7@SeparateCh
$LN6@SeparateCh:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR __real@45bb8000
	jbe	SHORT $LN8@SeparateCh
$LN7@SeparateCh:

; 212  : 		{
; 213  : 		  AddMode(SeparateMode);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN8@SeparateCh:

; 214  : 		}
; 215  : 
; 216  : 
; 217  :    }
; 218  : 
; 219  : 	//TJL 11/08/03 Bugout code courtesy of Jam/Mike
; 220  :    // Is the AI deep six? ataFrom is from target nose.
; 221  : 	if (targetData->ataFrom > 135.0F *DTR && FalconLocalGame->GetGameType() != game_Dogfight)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR __real@4016cbe3
	jbe	SHORT $LN5@SeparateCh
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN53@SeparateCh
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv488[ebp], eax
	jmp	SHORT $LN54@SeparateCh
$LN53@SeparateCh:
	mov	DWORD PTR tv488[ebp], 0
$LN54@SeparateCh:
	mov	ecx, DWORD PTR tv488[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	je	SHORT $LN5@SeparateCh

; 222  : 	{
; 223  : 		if(!bugoutTimer)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+532], 0
	jne	SHORT $LN4@SeparateCh

; 224  : 		{
; 225  : 			//Set 90 second timer
; 226  : 			bugoutTimer = SimLibElapsedTime + 90000;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 90000				; 00015f90H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+532], eax
$LN4@SeparateCh:

; 227  : 		}
; 228  : 		//If not 90 seoncds, do nothing
; 229  : 			if (bugoutTimer > SimLibElapsedTime)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+532]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jbe	SHORT $LN3@SeparateCh

; 230  : 			{
; 231  : 				return;

	jmp	SHORT $LN49@SeparateCh

; 232  : 			}
; 233  : 			else

	jmp	SHORT $LN2@SeparateCh
$LN3@SeparateCh:

; 234  : 			{
; 235  : 			//If deep six > 90 seconds, disengage.
; 236  : 			AddMode (BugoutMode);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN2@SeparateCh:

; 237  : 			}
; 238  : 	}
; 239  : 	else

	jmp	SHORT $LN1@SeparateCh
$LN5@SeparateCh:

; 240  : 		{
; 241  : 		//reset our timer
; 242  : 			bugoutTimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+532], 0
$LN1@SeparateCh:
$LN49@SeparateCh:

; 243  : 		}
; 244  : 
; 245  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?SeparateCheck@DigitalBrain@@IAEXXZ ENDP		; DigitalBrain::SeparateCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\separate.cpp
_TEXT	SEGMENT
tv240 = -24						; size = 4
tv228 = -20						; size = 4
tv216 = -16						; size = 4
tv204 = -12						; size = 4
_fuelRemain$ = -8					; size = 4
_this$ = -4						; size = 4
?FuelCheck@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::FuelCheck
; _this$ = ecx

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 386  : //Cobra no need for all this ... ;)
; 387  : 
; 388  : //WayPointClass* tmpWaypoint = self->waypoint;
; 389  : //float xPos, yPos, zPos, dist;
; 390  : //float ps, fuelNeeded, fuelRemain, fuelBurn;
; 391  : float fuelRemain = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fuelRemain$[ebp], xmm0

; 392  : 
; 393  : //we don't care if we need fuel on the ground :)
; 394  : 	if(self->OnGround())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN10@FuelCheck

; 395  : 		return;

	jmp	$LN11@FuelCheck
$LN10@FuelCheck:

; 396  : 
; 397  :    // Find airbase
; 398  : 	/*while (tmpWaypoint)
; 399  : 	{
; 400  : 		if (tmpWaypoint->GetWPAction() == WP_LAND)
; 401  : 		{
; 402  : 			break;
; 403  : 		}
; 404  : 		tmpWaypoint = tmpWaypoint->GetNextWP();
; 405  : 	}
; 406  : 
; 407  :    if (!tmpWaypoint)
; 408  :       tmpWaypoint = self->waypoint;
; 409  : 
; 410  :    if (tmpWaypoint)
; 411  :    {
; 412  :       // Find fuel needed
; 413  :    	tmpWaypoint->GetLocation (&xPos, &yPos, &zPos);
; 414  :       dist = (float)sqrt ((self->XPos()-xPos)*(self->XPos()-xPos) + (self->YPos()-yPos)*(self->YPos()-yPos));
; 415  :       fuelBurn = af->FuelBurn(FALSE);
; 416  :       ps = af->PsubS(FALSE);
; 417  :       // Acceleration = G*Ps/vt
; 418  :       fuelNeeded = dist / (self->GetVt() + 2.0F * GRAVITY * ps/self->GetVt()) * fuelBurn / 3600.0F;
; 419  : 
; 420  :       // Fuel left at home
; 421  :       fuelRemain = af->Fuel() - fuelNeeded;
; 422  : 	  */ //End of removed code
; 423  : 		
; 424  : 	  //me123 arhh we don't want the wingmen to think :), just say the prebrefed fuelstate joker, bingo
; 425  : 	  fuelRemain = af->Fuel();//me123 hack addet

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR _fuelRemain$[ebp]

; 426  : 
; 427  :       // Check fuel state
; 428  :       if (fuelRemain < af->GetJoker())//me123 from 1000

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetJoker@AirframeClass@@QAEMXZ		; AirframeClass::GetJoker
	fstp	DWORD PTR tv204[ebp]
	movss	xmm0, DWORD PTR tv204[ebp]
	comiss	xmm0, DWORD PTR _fuelRemain$[ebp]
	jbe	$LN1@FuelCheck

; 429  :       {
; 430  :          if (!IsSetATC(SaidJoker))

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN8@FuelCheck

; 431  :          {
; 432  :             // Say Joker
; 433  : //            MonoPrint ("Digi joker fuel\n");
; 434  :             SetATCFlag(SaidJoker);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 435  :             AiSendCommand (self, FalconWingmanMsg::WMJokerFuel, AiAllButSender);

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	eax
	push	5
	push	51					; 00000033H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiSendCommand@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z ; AiSendCommand
	add	esp, 20					; 00000014H
	jmp	$LN1@FuelCheck
$LN8@FuelCheck:

; 436  :          }
; 437  :          else if (fuelRemain < af->GetBingo())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetBingo@AirframeClass@@QAEMXZ		; AirframeClass::GetBingo
	fstp	DWORD PTR tv216[ebp]
	movss	xmm0, DWORD PTR tv216[ebp]
	comiss	xmm0, DWORD PTR _fuelRemain$[ebp]
	jbe	$LN1@FuelCheck

; 438  :          {
; 439  :             if (!IsSetATC(SaidBingo))

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN5@FuelCheck

; 440  :             {
; 441  :                // Say Bingo
; 442  : //               MonoPrint ("Digi bingo fuel\n");
; 443  :                SetATCFlag(SaidBingo);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 444  :                AiSendCommand (self, FalconWingmanMsg::WMBingoFuel, AiAllButSender);

	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	push	5
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiSendCommand@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z ; AiSendCommand
	add	esp, 20					; 00000014H
	jmp	$LN1@FuelCheck
$LN5@FuelCheck:

; 445  :             }
; 446  :             else if (fuelRemain < af->GetFumes() && !IsSetATC(SaidFumes))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetFumes@AirframeClass@@QAEMXZ		; AirframeClass::GetFumes
	fstp	DWORD PTR tv228[ebp]
	movss	xmm0, DWORD PTR tv228[ebp]
	comiss	xmm0, DWORD PTR _fuelRemain$[ebp]
	jbe	SHORT $LN3@FuelCheck
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN3@FuelCheck

; 447  :             {
; 448  :                // Say Fumes
; 449  : //               MonoPrint ("Digi fumes fuel\n");
; 450  :                SetATCFlag(SaidFumes);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 451  :                AiSendCommand (self, FalconWingmanMsg::WMFumes, AiAllButSender);

	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	ecx
	push	5
	push	53					; 00000035H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiSendCommand@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z ; AiSendCommand
	add	esp, 20					; 00000014H
	jmp	SHORT $LN1@FuelCheck
$LN3@FuelCheck:

; 452  :             }
; 453  :             else if (af->Fuel() == 0.0F && !IsSetATC(SaidFlameout))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv240[ebp]
	movss	xmm0, DWORD PTR tv240[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@FuelCheck
	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN1@FuelCheck

; 454  :             {
; 455  :                // Say Flameout
; 456  : //               MonoPrint ("Digi flameout\n");
; 457  :                SetATCFlag(SaidFlameout);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 458  :                AiSendCommand (self, FalconWingmanMsg::WMFlameout, AiAllButSender);

	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	eax
	push	5
	push	54					; 00000036H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiSendCommand@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z ; AiSendCommand
	add	esp, 20					; 00000014H
$LN1@FuelCheck:
$LN11@FuelCheck:

; 459  :             }
; 460  :          }
; 461  :       }
; 462  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FuelCheck@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::FuelCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?asin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?asin@@YAMM@Z PROC					; asin, COMDAT

; 503  :         {return (asinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_asinf
	add	esp, 4
	pop	ebp
	ret	0
?asin@@YAMM@Z ENDP					; asin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _asinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_asinf	PROC						; COMDAT

; 402  :         {return ((float)asin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_asin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_asinf	ENDP
_TEXT	ENDS
END
