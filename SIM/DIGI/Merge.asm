; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\Merge.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	?AccelManeuver@DigitalBrain@@IAEXXZ		; DigitalBrain::AccelManeuver
PUBLIC	?MergeCheck@DigitalBrain@@IAEXXZ		; DigitalBrain::MergeCheck
PUBLIC	?AccelCheck@DigitalBrain@@IAEXXZ		; DigitalBrain::AccelCheck
PUBLIC	?MergeManeuver@DigitalBrain@@IAEXXZ		; DigitalBrain::MergeManeuver
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	__real@00000000
PUBLIC	__real@3eb33333
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ee4dd2f
PUBLIC	__real@3f333333
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f5f66f1
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3fe6666666666666
PUBLIC	__real@3ff3333333333333
PUBLIC	__real@40000000
PUBLIC	__real@4016cbe3
PUBLIC	__real@403de44d
PUBLIC	__real@40490fd9
PUBLIC	__real@40800000
PUBLIC	__real@41200000
PUBLIC	__real@42652ee1
PUBLIC	__real@432a0000
PUBLIC	__real@447a0000
PUBLIC	__real@453b8000
PUBLIC	__real@bfc90fd9
PUBLIC	__real@c016cbe3
PUBLIC	__real@c03de44d
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_fabs:PROC
EXTRN	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z:PROC	; DigitalBrain::AddMode
EXTRN	?MachHold@DigitalBrain@@IAEHMMH@Z:PROC		; DigitalBrain::MachHold
EXTRN	?SetPstick@DigitalBrain@@IAEMMMH@Z:PROC		; DigitalBrain::SetPstick
EXTRN	?SetRstick@DigitalBrain@@IAEMM@Z:PROC		; DigitalBrain::SetRstick
EXTRN	?SetYpedal@DigitalBrain@@IAEMM@Z:PROC		; DigitalBrain::SetYpedal
EXTRN	?SetMaxRoll@DigitalBrain@@IAEXM@Z:PROC		; DigitalBrain::SetMaxRoll
EXTRN	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z:PROC	; DigitalBrain::SetMaxRollDelta
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?maneuverClassData@DigitalBrain@@2PAUManeuverClassData@1@A:BYTE ; DigitalBrain::maneuverClassData
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c03de44d
CONST	SEGMENT
__real@c03de44d DD 0c03de44dr			; -2.96706
CONST	ENDS
;	COMDAT __real@c016cbe3
CONST	SEGMENT
__real@c016cbe3 DD 0c016cbe3r			; -2.35619
CONST	ENDS
;	COMDAT __real@bfc90fd9
CONST	SEGMENT
__real@bfc90fd9 DD 0bfc90fd9r			; -1.5708
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@432a0000
CONST	SEGMENT
__real@432a0000 DD 0432a0000r			; 170
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@403de44d
CONST	SEGMENT
__real@403de44d DD 0403de44dr			; 2.96706
CONST	ENDS
;	COMDAT __real@4016cbe3
CONST	SEGMENT
__real@4016cbe3 DD 04016cbe3r			; 2.35619
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff3333333333333
CONST	SEGMENT
__real@3ff3333333333333 DQ 03ff3333333333333r	; 1.2
CONST	ENDS
;	COMDAT __real@3fe6666666666666
CONST	SEGMENT
__real@3fe6666666666666 DQ 03fe6666666666666r	; 0.7
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f5f66f1
CONST	SEGMENT
__real@3f5f66f1 DD 03f5f66f1r			; 0.872665
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3ee4dd2f
CONST	SEGMENT
__real@3ee4dd2f DD 03ee4dd2fr			; 0.447
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\merge.cpp
_TEXT	SEGMENT
tv1243 = -112						; size = 4
tv1192 = -108						; size = 4
tv1183 = -104						; size = 4
tv1143 = -100						; size = 4
tv1137 = -96						; size = 4
tv1093 = -92						; size = 4
tv1086 = -88						; size = 4
tv1033 = -84						; size = 4
tv1024 = -80						; size = 4
tv958 = -76						; size = 4
tv950 = -72						; size = 4
tv944 = -68						; size = 4
tv866 = -64						; size = 4
_eDroll$ = -60						; size = 4
tv715 = -56						; size = 4
tv688 = -52						; size = 4
tv629 = -48						; size = 4
tv602 = -44						; size = 4
tv452 = -40						; size = 4
tv425 = -36						; size = 4
tv329 = -32						; size = 4
tv302 = -28						; size = 4
tv182 = -24						; size = 4
tv156 = -20						; size = 4
_curRoll$ = -16						; size = 4
tv131 = -12						; size = 4
_mnverFlags$ = -8					; size = 4
_this$ = -4						; size = 4
?MergeManeuver@DigitalBrain@@IAEXXZ PROC		; DigitalBrain::MergeManeuver
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 56   : int mnverFlags;
; 57   : float eDroll;
; 58   : float curRoll = self->Roll();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR _curRoll$[ebp]

; 59   : 
; 60   :    /*-----------*/
; 61   :    /* no target */
; 62   :    /*-----------*/
; 63   :    if (targetPtr == NULL) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN37@MergeManeu

; 64   :    {
; 65   :       return;

	jmp	$LN38@MergeManeu
$LN37@MergeManeu:

; 66   :    }
; 67   : 
; 68   :    // Pick bank angle on first pass
; 69   :    if (lastMode != MergeMode)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+140], 10			; 0000000aH
	je	$LN34@MergeManeu

; 70   :    {
; 71   :       // Mil power except for Vertical;
; 72   : 
; 73   :       mergeTimer = SimLibElapsedTime + 3 * SEC_TO_MSEC;//me123 from 5

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 3000				; 00000bb8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+544], eax

; 74   :       mnverFlags = maneuverClassData[self->CombatClass()].flags;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+144]
	call	eax
	mov	ecx, DWORD PTR ?maneuverClassData@DigitalBrain@@2PAUManeuverClassData@1@A[eax*4]
	mov	DWORD PTR _mnverFlags$[ebp], ecx

; 75   :       switch (mnverFlags & (CanLevelTurn | CanSlice | CanUseVertical))

	mov	edx, DWORD PTR _mnverFlags$[ebp]
	and	edx, 7
	mov	DWORD PTR tv131[ebp], edx
	mov	eax, DWORD PTR tv131[ebp]
	sub	eax, 1
	mov	DWORD PTR tv131[ebp], eax
	cmp	DWORD PTR tv131[ebp], 6
	ja	$LN34@MergeManeu
	mov	ecx, DWORD PTR tv131[ebp]
	jmp	DWORD PTR $LN60@MergeManeu[ecx*4]
$LN33@MergeManeu:

; 76   :       {
; 77   :          case CanLevelTurn:
; 78   :             if ((mnverFlags & CanOneCircle) && (self->GetKias() < cornerSpeed))//me123

	mov	edx, DWORD PTR _mnverFlags$[ebp]
	and	edx, 16					; 00000010H
	je	$LN32@MergeManeu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv866[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	comiss	xmm0, DWORD PTR tv866[ebp]
	jbe	SHORT $LN32@MergeManeu

; 79   :             {
; 80   :                // One Circle, turn away from the target
; 81   :                newroll = (targetData->az > 0.0F ? -90.0F * DTR : 90.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN40@MergeManeu
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv156[ebp], xmm0
	jmp	SHORT $LN41@MergeManeu
$LN40@MergeManeu:
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv156[ebp], xmm0
$LN41@MergeManeu:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv156[ebp]
	movss	DWORD PTR [eax+512], xmm0

; 82   : 			   MachHold (cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 83   :             }
; 84   :             else

	jmp	SHORT $LN31@MergeManeu
$LN32@MergeManeu:

; 85   :             {
; 86   :                // Two Circle, turn towards the target
; 87   :                newroll = (targetData->az > 0.0F ? 90.0F * DTR : -90.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN42@MergeManeu
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv182[ebp], xmm0
	jmp	SHORT $LN43@MergeManeu
$LN42@MergeManeu:
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv182[ebp], xmm0
$LN43@MergeManeu:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv182[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 88   : 			      MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN31@MergeManeu:

; 89   :             }
; 90   :          break;

	jmp	$LN34@MergeManeu
$LN30@MergeManeu:

; 91   : 
; 92   :          case CanSlice:
; 93   :             if (curRoll > 0.0F)

	movss	xmm0, DWORD PTR _curRoll$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN29@MergeManeu

; 94   : 			{
; 95   :                newroll = 135.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4016cbe3
	movss	DWORD PTR [edx+512], xmm0

; 96   : 		      MachHold (cornerSpeed, self->GetKias(), FALSE);//me123

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 97   : 			}
; 98   :             else

	jmp	SHORT $LN28@MergeManeu
$LN29@MergeManeu:

; 99   : 			{
; 100  :                newroll = -135.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c016cbe3
	movss	DWORD PTR [ecx+512], xmm0

; 101  : 		      MachHold (cornerSpeed, self->GetKias(), FALSE);//me123

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN28@MergeManeu:

; 102  : 			}
; 103  :          break;

	jmp	$LN34@MergeManeu
$LN27@MergeManeu:

; 104  : 
; 105  :          case CanUseVertical:
; 106  :             newroll = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+512], xmm0

; 107  : 			MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 108  :             // Full burner for the pull
; 109  :          break;

	jmp	$LN34@MergeManeu
$LN26@MergeManeu:

; 110  : 
; 111  :          case CanLevelTurn | CanSlice:
; 112  :             // level turn or slice?
; 113  :             if ((self->GetKias() > cornerSpeed) && -self->ZPos() >3000.0f )//me123

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv944[ebp]
	movss	xmm0, DWORD PTR tv944[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+100]
	jbe	$LN25@MergeManeu
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv950[ebp]
	movss	xmm0, DWORD PTR tv950[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN25@MergeManeu

; 114  :             {
; 115  :                // Level Turn
; 116  :                if ((mnverFlags & CanOneCircle) && (self->GetKias() < cornerSpeed))

	mov	eax, DWORD PTR _mnverFlags$[ebp]
	and	eax, 16					; 00000010H
	je	$LN24@MergeManeu
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv958[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	comiss	xmm0, DWORD PTR tv958[ebp]
	jbe	SHORT $LN24@MergeManeu

; 117  :                {
; 118  :                   // One Circle, turn away from the target
; 119  :                   newroll = (targetData->az > 0.0F ? -90.0F * DTR : 90.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN44@MergeManeu
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv302[ebp], xmm0
	jmp	SHORT $LN45@MergeManeu
$LN44@MergeManeu:
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv302[ebp], xmm0
$LN45@MergeManeu:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv302[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 120  :   			      MachHold (0.7f* cornerSpeed, self->GetKias(), FALSE);//me123 addet *0.4

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR [ecx+100]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 121  :                }
; 122  :                else

	jmp	SHORT $LN23@MergeManeu
$LN24@MergeManeu:

; 123  :                {
; 124  :                   // Two Circle, turn towards the target
; 125  :                   newroll = (targetData->az > 0.0F ? 90.0F * DTR : -90.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN46@MergeManeu
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv329[ebp], xmm0
	jmp	SHORT $LN47@MergeManeu
$LN46@MergeManeu:
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv329[ebp], xmm0
$LN47@MergeManeu:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv329[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 126  : 				  MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN23@MergeManeu:

; 127  :                }
; 128  :             }
; 129  :             else

	jmp	$LN20@MergeManeu
$LN25@MergeManeu:

; 130  :             {
; 131  :                if (curRoll > 0.0F)

	movss	xmm0, DWORD PTR _curRoll$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN21@MergeManeu

; 132  : 			   {
; 133  :                   newroll = 135.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4016cbe3
	movss	DWORD PTR [edx+512], xmm0

; 134  : 				  MachHold (cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 135  : 			   }
; 136  :                else

	jmp	SHORT $LN20@MergeManeu
$LN21@MergeManeu:

; 137  : 			   {
; 138  :                   newroll = -135.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c016cbe3
	movss	DWORD PTR [ecx+512], xmm0

; 139  : 				  MachHold (cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN20@MergeManeu:

; 140  : 			   }
; 141  :             }
; 142  :          break;

	jmp	$LN34@MergeManeu
$LN19@MergeManeu:

; 143  : 
; 144  :          case CanLevelTurn | CanUseVertical:
; 145  :             // level turn or vertical?
; 146  :             if (self->GetKias() < cornerSpeed* 1.2)//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv1024[ebp]
	movss	xmm0, DWORD PTR tv1024[ebp]
	cvtss2sd xmm0, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm1, DWORD PTR [ecx+100]
	mulsd	xmm1, QWORD PTR __real@3ff3333333333333
	comisd	xmm1, xmm0
	jbe	$LN18@MergeManeu

; 147  :             {
; 148  :                // Level Turn
; 149  :                if ((mnverFlags & CanOneCircle) && (self->GetKias() < cornerSpeed))

	mov	edx, DWORD PTR _mnverFlags$[ebp]
	and	edx, 16					; 00000010H
	je	$LN17@MergeManeu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv1033[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	comiss	xmm0, DWORD PTR tv1033[ebp]
	jbe	SHORT $LN17@MergeManeu

; 150  :                {
; 151  :                   // One Circle, turn away from the target
; 152  :                   newroll = (targetData->az > 0.0F ? -90.0F * DTR : 90.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN48@MergeManeu
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv425[ebp], xmm0
	jmp	SHORT $LN49@MergeManeu
$LN48@MergeManeu:
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv425[ebp], xmm0
$LN49@MergeManeu:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv425[ebp]
	movss	DWORD PTR [eax+512], xmm0

; 153  : 				  MachHold (0.7f*cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR [ecx+100]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 154  :                }
; 155  :                else

	jmp	SHORT $LN16@MergeManeu
$LN17@MergeManeu:

; 156  :                {
; 157  :                   // Two Circle, turn towards the target
; 158  :                   newroll = (targetData->az > 0.0F ? 90.0F * DTR : -90.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN50@MergeManeu
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv452[ebp], xmm0
	jmp	SHORT $LN51@MergeManeu
$LN50@MergeManeu:
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv452[ebp], xmm0
$LN51@MergeManeu:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv452[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 159  : 				  MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN16@MergeManeu:

; 160  :                }
; 161  :             }
; 162  :             else

	jmp	SHORT $LN15@MergeManeu
$LN18@MergeManeu:

; 163  :             {
; 164  :                newroll = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+512], xmm0

; 165  : 			   MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN15@MergeManeu:

; 166  :                // Full burner for the pull
; 167  :             }
; 168  :          break;

	jmp	$LN34@MergeManeu
$LN14@MergeManeu:

; 169  : 
; 170  :          case CanSlice | CanUseVertical:
; 171  :             // slice or vertical?
; 172  :             if ((self->GetKias() < cornerSpeed) && -self->ZPos() >3000.0f)//me123

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv1086[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	comiss	xmm0, DWORD PTR tv1086[ebp]
	jbe	$LN13@MergeManeu
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1093[ebp]
	movss	xmm0, DWORD PTR tv1093[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN13@MergeManeu

; 173  :             {
; 174  :                if (curRoll > 0.0F)

	movss	xmm0, DWORD PTR _curRoll$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN12@MergeManeu

; 175  : 			   {
; 176  :                   newroll = 135.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@4016cbe3
	movss	DWORD PTR [eax+512], xmm0

; 177  : 				  MachHold (cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 178  : 			   }
; 179  :                else

	jmp	SHORT $LN11@MergeManeu
$LN12@MergeManeu:

; 180  : 			   {
; 181  :                   newroll = -135.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c016cbe3
	movss	DWORD PTR [edx+512], xmm0

; 182  : 				  MachHold (cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN11@MergeManeu:

; 183  : 			   }
; 184  :             }
; 185  :             else

	jmp	SHORT $LN10@MergeManeu
$LN13@MergeManeu:

; 186  :             {
; 187  :                newroll = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+512], xmm0

; 188  : 			   MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN10@MergeManeu:

; 189  :                // Full burner for the pull
; 190  :             }
; 191  :          break;

	jmp	$LN34@MergeManeu
$LN9@MergeManeu:

; 192  : 
; 193  :          case CanLevelTurn | CanSlice | CanUseVertical:
; 194  :             // slice, level turn, or vertical?
; 195  :             if ((self->GetKias() < cornerSpeed*0.7)&& -self->ZPos() >3000.0f)//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv1137[ebp]
	movss	xmm0, DWORD PTR tv1137[ebp]
	cvtss2sd xmm0, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm1, DWORD PTR [ecx+100]
	mulsd	xmm1, QWORD PTR __real@3fe6666666666666
	comisd	xmm1, xmm0
	jbe	$LN8@MergeManeu
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1143[ebp]
	movss	xmm0, DWORD PTR tv1143[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN8@MergeManeu

; 196  :             {
; 197  :                if ((mnverFlags & CanOneCircle))

	mov	eax, DWORD PTR _mnverFlags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN7@MergeManeu

; 198  : 			   {
; 199  :                   // One Circle, turn away from the target
; 200  :                   newroll = (targetData->az > 0.0F ? -135.0F * DTR : 135.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN52@MergeManeu
	movss	xmm0, DWORD PTR __real@c016cbe3
	movss	DWORD PTR tv602[ebp], xmm0
	jmp	SHORT $LN53@MergeManeu
$LN52@MergeManeu:
	movss	xmm0, DWORD PTR __real@4016cbe3
	movss	DWORD PTR tv602[ebp], xmm0
$LN53@MergeManeu:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv602[ebp]
	movss	DWORD PTR [eax+512], xmm0

; 201  : 				  MachHold (0.7f*cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR [ecx+100]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 202  : 			   }
; 203  :                else

	jmp	SHORT $LN6@MergeManeu
$LN7@MergeManeu:

; 204  : 			   {
; 205  :                   // Two Circle, turn towards the target
; 206  :                   newroll = (targetData->az > 0.0F ? 135.0F * DTR : -135.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN54@MergeManeu
	movss	xmm0, DWORD PTR __real@4016cbe3
	movss	DWORD PTR tv629[ebp], xmm0
	jmp	SHORT $LN55@MergeManeu
$LN54@MergeManeu:
	movss	xmm0, DWORD PTR __real@c016cbe3
	movss	DWORD PTR tv629[ebp], xmm0
$LN55@MergeManeu:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv629[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 207  : 				  MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN6@MergeManeu:

; 208  : 			   }

	jmp	$LN1@MergeManeu
$LN8@MergeManeu:

; 209  :             }
; 210  :             else if ((self->GetKias() < cornerSpeed * 1.2))//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv1183[ebp]
	movss	xmm0, DWORD PTR tv1183[ebp]
	cvtss2sd xmm0, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm1, DWORD PTR [ecx+100]
	mulsd	xmm1, QWORD PTR __real@3ff3333333333333
	comisd	xmm1, xmm0
	jbe	$LN4@MergeManeu

; 211  :             {
; 212  :                // Level Turn
; 213  :                if ((mnverFlags & CanOneCircle) && (self->GetKias() < cornerSpeed))

	mov	edx, DWORD PTR _mnverFlags$[ebp]
	and	edx, 16					; 00000010H
	je	$LN3@MergeManeu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv1192[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	comiss	xmm0, DWORD PTR tv1192[ebp]
	jbe	SHORT $LN3@MergeManeu

; 214  :                {
; 215  :                   // One Circle, turn away from the target
; 216  :                   newroll = (targetData->az > 0.0F ? -90.0F * DTR : 90.0F * DTR);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN56@MergeManeu
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv688[ebp], xmm0
	jmp	SHORT $LN57@MergeManeu
$LN56@MergeManeu:
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv688[ebp], xmm0
$LN57@MergeManeu:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv688[ebp]
	movss	DWORD PTR [eax+512], xmm0

; 217  : 				  MachHold (0.7f*cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f333333
	mulss	xmm0, DWORD PTR [ecx+100]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 218  :                }
; 219  :                else

	jmp	SHORT $LN2@MergeManeu
$LN3@MergeManeu:

; 220  :                {
; 221  :                   // Two Circle, turn towards the target
; 222  :                   newroll = (targetData->az > 0.0F ? 90.0F * DTR : -90.0F * DTR);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN58@MergeManeu
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR tv715[ebp], xmm0
	jmp	SHORT $LN59@MergeManeu
$LN58@MergeManeu:
	movss	xmm0, DWORD PTR __real@bfc90fd9
	movss	DWORD PTR tv715[ebp], xmm0
$LN59@MergeManeu:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv715[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 223  : 				  MachHold (cornerSpeed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN2@MergeManeu:

; 224  :                }
; 225  :             }
; 226  :             else

	jmp	SHORT $LN1@MergeManeu
$LN4@MergeManeu:

; 227  :             {
; 228  :                newroll = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+512], xmm0

; 229  : 			   MachHold (cornerSpeed* 1.2f, self->GetKias(), TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN1@MergeManeu:
$LN34@MergeManeu:

; 230  :                // Full burner for the pull
; 231  :             }
; 232  :          break;
; 233  :       }
; 234  :    }
; 235  : 
; 236  :    eDroll = newroll - self->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv1243[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+512]
	subss	xmm0, DWORD PTR tv1243[ebp]
	movss	DWORD PTR _eDroll$[ebp], xmm0

; 237  :    SetYpedal( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 238  :    SetRstick( eDroll * 2.0F * RTD);

	movss	xmm0, DWORD PTR _eDroll$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 239  :    SetPstick(maxGs, maxGs, AirframeClass::GCommand);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+96]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 240  :    SetMaxRoll (newroll * RTD);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+512]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 241  :    SetMaxRollDelta (eDroll*RTD);

	movss	xmm0, DWORD PTR _eDroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta
$LN38@MergeManeu:

; 242  : 
; 243  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN60@MergeManeu:
	DD	$LN33@MergeManeu
	DD	$LN30@MergeManeu
	DD	$LN26@MergeManeu
	DD	$LN27@MergeManeu
	DD	$LN19@MergeManeu
	DD	$LN14@MergeManeu
	DD	$LN9@MergeManeu
?MergeManeuver@DigitalBrain@@IAEXXZ ENDP		; DigitalBrain::MergeManeuver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\merge.cpp
_TEXT	SEGMENT
tv252 = -32						; size = 4
tv245 = -28						; size = 4
tv238 = -24						; size = 4
tv228 = -20						; size = 4
tv221 = -16						; size = 4
tv214 = -12						; size = 4
tv207 = -8						; size = 4
_this$ = -4						; size = 4
?AccelCheck@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::AccelCheck
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	//Leon, if you are in waypoint mode, or loiter mode, it may be desired to fly at less than corner speed
; 248  : 	//this is only important in combat
; 249  : 	if(nextMode >= MergeMode && nextMode <= BVREngageMode && nextMode != GroundAvoidMode)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 10			; 0000000aH
	jl	$LN1@AccelCheck
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 16			; 00000010H
	jg	$LN1@AccelCheck
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 1
	je	$LN1@AccelCheck

; 250  : 	{
; 251  : 	   if ((self->Pitch() > 50.0F * DTR && self->GetKias() < cornerSpeed * 0.4F) ||//me123 150kias
; 252  : 		  (self->Pitch() > 0.0F * DTR && self->GetKias() < cornerSpeed * 0.35F))//me123 100 GetKias

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv207[ebp]
	movss	xmm0, DWORD PTR tv207[ebp]
	comiss	xmm0, DWORD PTR __real@3f5f66f1
	jbe	SHORT $LN3@AccelCheck
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv214[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	comiss	xmm0, DWORD PTR tv214[ebp]
	ja	SHORT $LN4@AccelCheck
$LN3@AccelCheck:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv221[ebp]
	movss	xmm0, DWORD PTR tv221[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@AccelCheck
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv228[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+100]
	mulss	xmm0, DWORD PTR __real@3eb33333
	comiss	xmm0, DWORD PTR tv228[ebp]
	jbe	SHORT $LN5@AccelCheck
$LN4@AccelCheck:

; 253  : 	   {
; 254  : 		  AddMode (AccelMode);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode

; 255  : 	   }
; 256  : 	   else if (curMode == AccelMode && self->GetKias() < cornerSpeed * 0.447F && 

	jmp	$LN1@AccelCheck
$LN5@AccelCheck:

; 257  : 		   self->Pitch() > 0.0F * DTR && self->GetKias())//me123 180kias

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 9
	jne	$LN1@AccelCheck
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv238[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	mulss	xmm0, DWORD PTR __real@3ee4dd2f
	comiss	xmm0, DWORD PTR tv238[ebp]
	jbe	SHORT $LN1@AccelCheck
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv245[ebp]
	movss	xmm0, DWORD PTR tv245[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@AccelCheck
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv252[ebp]
	movss	xmm0, DWORD PTR tv252[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1@AccelCheck

; 258  : 	   {
; 259  : 		  AddMode (AccelMode);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN1@AccelCheck:

; 260  : 	   }
; 261  : 	}
; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AccelCheck@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::AccelCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\merge.cpp
_TEXT	SEGMENT
tv344 = -68						; size = 4
_breakRange$ = -64					; size = 4
tv327 = -60						; size = 4
tv354 = -56						; size = 4
tv320 = -52						; size = 4
tv312 = -48						; size = 4
tv352 = -44						; size = 4
tv307 = -40						; size = 4
tv301 = -36						; size = 4
tv350 = -32						; size = 4
tv296 = -28						; size = 4
tv289 = -24						; size = 4
tv276 = -20						; size = 4
_dy$1 = -16						; size = 4
_dx$2 = -12						; size = 4
tv187 = -8						; size = 4
_this$ = -4						; size = 4
?MergeCheck@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::MergeCheck
; _this$ = ecx

; 10   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 11   : float breakRange;
; 12   : 
; 13   :    /*-----------*/
; 14   :    /* no target */
; 15   :    /*-----------*/
; 16   :    if (targetPtr == NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN8@MergeCheck

; 17   :    {
; 18   :       return;

	jmp	$LN9@MergeCheck
$LN8@MergeCheck:

; 19   :    }
; 20   : 
; 21   :    /*-------*/
; 22   :    /* entry */
; 23   :    /*-------*/
; 24   :    if (curMode != MergeMode)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 10			; 0000000aH
	je	$LN7@MergeCheck

; 25   :    {
; 26   :       if (-self->ZPos() > 3000 && targetData->range <= (1000) && targetData->ata < 45.0f * DTR && fabs(self->Pitch()) < 45.0F*DTR)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv276[ebp]
	movss	xmm0, DWORD PTR tv276[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	$LN5@MergeCheck
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR __real@447a0000
	comiss	xmm0, DWORD PTR [ecx+44]
	jb	$LN5@MergeCheck
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR [eax]
	jbe	$LN5@MergeCheck
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv289[ebp]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR tv289[ebp]
	jbe	$LN5@MergeCheck

; 27   :       {
; 28   :       float dx, dy;
; 29   : 
; 30   :          dx = targetPtr->BaseData()->XPos() - self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv296[ebp]
	movss	xmm0, DWORD PTR tv296[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv350[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv301[ebp]
	movss	xmm0, DWORD PTR tv350[ebp]
	subss	xmm0, DWORD PTR tv301[ebp]
	movss	DWORD PTR _dx$2[ebp], xmm0

; 31   :          dy = targetPtr->BaseData()->YPos() - self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv307[ebp]
	movss	xmm0, DWORD PTR tv307[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv352[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv312[ebp]
	movss	xmm0, DWORD PTR tv352[ebp]
	subss	xmm0, DWORD PTR tv312[ebp]
	movss	DWORD PTR _dy$1[ebp], xmm0

; 32   : 
; 33   :          // Max range when on target nose, 0 if a stern chase
; 34   :          breakRange = ((targetPtr->BaseData()->GetKias() * self->GetKias())) * //me123 
; 35   :             (1.0F - targetData->ataFrom / (180.0F * DTR)) *
; 36   :             (1.0F - targetData->ataFrom / (180.0F * DTR));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv187[ebp], eax
	mov	ecx, DWORD PTR tv187[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv187[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv320[ebp]
	movss	xmm0, DWORD PTR tv320[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+224]
	movss	DWORD PTR tv354[ebp], xmm0
	call	eax
	fstp	DWORD PTR tv327[ebp]
	movss	xmm0, DWORD PTR tv354[ebp]
	mulss	xmm0, DWORD PTR tv327[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm1, DWORD PTR [edx+4]
	divss	xmm1, DWORD PTR __real@40490fd9
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm1, DWORD PTR [ecx+4]
	divss	xmm1, DWORD PTR __real@40490fd9
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	movss	DWORD PTR _breakRange$[ebp], xmm0

; 37   : 
; 38   :          if (dx*dx + dy*dy < breakRange && targetData->ataFrom < 45.0F * DTR)

	movss	xmm0, DWORD PTR _dx$2[ebp]
	mulss	xmm0, DWORD PTR _dx$2[ebp]
	movss	xmm1, DWORD PTR _dy$1[ebp]
	mulss	xmm1, DWORD PTR _dy$1[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _breakRange$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@MergeCheck
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN5@MergeCheck

; 39   :             AddMode(MergeMode);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN5@MergeCheck:

; 40   :       }
; 41   :    }

	jmp	SHORT $LN1@MergeCheck
$LN7@MergeCheck:

; 42   :    /*------*/
; 43   :    /* exit */
; 44   :    /*------*/
; 45   :    else if (curMode == MergeMode)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 10			; 0000000aH
	jne	SHORT $LN1@MergeCheck

; 46   :    {
; 47   :       if (-self->ZPos() > 3000 && SimLibElapsedTime < mergeTimer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv344[ebp]
	movss	xmm0, DWORD PTR tv344[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR __real@453b8000
	jbe	SHORT $LN2@MergeCheck
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	ecx, DWORD PTR [eax+544]
	jae	SHORT $LN2@MergeCheck

; 48   :          AddMode(MergeMode);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode

; 49   :       else

	jmp	SHORT $LN1@MergeCheck
$LN2@MergeCheck:

; 50   :          mergeTimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+544], 0
$LN1@MergeCheck:
$LN9@MergeCheck:

; 51   :    }
; 52   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MergeCheck@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::MergeCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\merge.cpp
_TEXT	SEGMENT
tv188 = -24						; size = 4
tv167 = -20						; size = 4
tv160 = -16						; size = 4
_eDroll$ = -12						; size = 4
_tmp$ = -8						; size = 4
_this$ = -4						; size = 4
?AccelManeuver@DigitalBrain@@IAEXXZ PROC		; DigitalBrain::AccelManeuver
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 266  : float eDroll;
; 267  : float tmp;
; 268  : //MonoPrint ("Accelmaneuver");
; 269  :    // Choose plane?
; 270  :    if ((self->Roll()) >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv160[ebp]
	movss	xmm0, DWORD PTR tv160[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN4@AccelManeu

; 271  : 	{tmp = 170.0F * DTR;

	movss	xmm0, DWORD PTR __real@403de44d
	movss	DWORD PTR _tmp$[ebp], xmm0

; 272  : //   MonoPrint (">0");
; 273  : 	}
; 274  :    else

	jmp	SHORT $LN3@AccelManeu
$LN4@AccelManeu:

; 275  :    {tmp = -170.0F * DTR;

	movss	xmm0, DWORD PTR __real@c03de44d
	movss	DWORD PTR _tmp$[ebp], xmm0
$LN3@AccelManeu:

; 276  : //   MonoPrint ("<0");
; 277  : 	}
; 278  : 
; 279  :    eDroll = tmp - self->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv167[ebp]
	movss	xmm0, DWORD PTR _tmp$[ebp]
	subss	xmm0, DWORD PTR tv167[ebp]
	movss	DWORD PTR _eDroll$[ebp], xmm0

; 280  :    SetYpedal( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 281  :    SetRstick( eDroll *2 * RTD);

	movss	xmm0, DWORD PTR _eDroll$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 282  :    MachHold (cornerSpeed, self->GetKias(), FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold

; 283  :    if (fabs(eDroll* RTD) > 10.0F )

	movss	xmm0, DWORD PTR _eDroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv188[ebp]
	movss	xmm0, DWORD PTR tv188[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jbe	SHORT $LN2@AccelManeu

; 284  :    SetPstick(0.0F, maxGs, AirframeClass::GCommand);

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 285  :    else

	jmp	SHORT $LN1@AccelManeu
$LN2@AccelManeu:

; 286  :    SetPstick(4.0F, maxGs, AirframeClass::GCommand);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)
$LN1@AccelManeu:

; 287  :    SetMaxRoll (170.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@432a0000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 288  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AccelManeuver@DigitalBrain@@IAEXXZ ENDP		; DigitalBrain::AccelManeuver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
