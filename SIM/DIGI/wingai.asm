; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\wingai.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?SkillLevel@BaseBrain@@QAEHXZ			; BaseBrain::SkillLevel
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPFlags@WayPointClass@@QAEKXZ		; WayPointClass::GetWPFlags
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetPrevWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetPrevWP
PUBLIC	?SetTrackPoint@DigitalBrain@@QAEXMM@Z		; DigitalBrain::SetTrackPoint
PUBLIC	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z		; DigitalBrain::SetTrackPoint
PUBLIC	?SetATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::SetATCFlag
PUBLIC	?ClearATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::ClearATCFlag
PUBLIC	?IsSetATC@DigitalBrain@@QAEHH@Z			; DigitalBrain::IsSetATC
PUBLIC	?AiSaveWeaponState@DigitalBrain@@AAEXXZ		; DigitalBrain::AiSaveWeaponState
PUBLIC	?AiRestoreWeaponState@DigitalBrain@@AAEXXZ	; DigitalBrain::AiRestoreWeaponState
PUBLIC	?AiSaveSetSearchDomain@DigitalBrain@@AAEXD@Z	; DigitalBrain::AiSaveSetSearchDomain
PUBLIC	?AiRestoreSearchDomain@DigitalBrain@@AAEXXZ	; DigitalBrain::AiRestoreSearchDomain
PUBLIC	?AiSetManeuver@DigitalBrain@@AAEXH@Z		; DigitalBrain::AiSetManeuver
PUBLIC	?AiClearManeuver@DigitalBrain@@AAEXXZ		; DigitalBrain::AiClearManeuver
PUBLIC	?AiClearLeadersSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiClearLeadersSix
PUBLIC	?AiCheckOwnSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiCheckOwnSix
PUBLIC	?AiEngageThreatAtSix@DigitalBrain@@AAEXVVU_ID@@@Z ; DigitalBrain::AiEngageThreatAtSix
PUBLIC	?AiBreakLeft@DigitalBrain@@AAEXXZ		; DigitalBrain::AiBreakLeft
PUBLIC	?AiBreakRight@DigitalBrain@@AAEXXZ		; DigitalBrain::AiBreakRight
PUBLIC	?AiGoShooter@DigitalBrain@@AAEXXZ		; DigitalBrain::AiGoShooter
PUBLIC	?AiGoCover@DigitalBrain@@AAEXXZ			; DigitalBrain::AiGoCover
PUBLIC	?AiSearchForTargets@DigitalBrain@@AAEXD@Z	; DigitalBrain::AiSearchForTargets
PUBLIC	?AiResumeFlightPlan@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiResumeFlightPlan
PUBLIC	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z ; DigitalBrain::AiRejoin
PUBLIC	?AiSetRadarActive@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetRadarActive
PUBLIC	?AiSetRadarStby@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetRadarStby
PUBLIC	?AiBuddySpikeReact@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiBuddySpikeReact
PUBLIC	?AiRaygun@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiRaygun
PUBLIC	?AiRTB@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiRTB
PUBLIC	?AiDesignateTarget@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDesignateTarget
PUBLIC	?AiDesignateGroup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDesignateGroup
PUBLIC	?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z ; DigitalBrain::AiSetWeaponsAction
PUBLIC	?AiSetFormation@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSetFormation
PUBLIC	?AiKickout@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiKickout
PUBLIC	?AiCloseup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiCloseup
PUBLIC	?AiToggleSide@DigitalBrain@@AAEXXZ		; DigitalBrain::AiToggleSide
PUBLIC	?AiIncreaseRelativeAltitude@DigitalBrain@@AAEXXZ ; DigitalBrain::AiIncreaseRelativeAltitude
PUBLIC	?AiDecreaseRelativeAltitude@DigitalBrain@@AAEXXZ ; DigitalBrain::AiDecreaseRelativeAltitude
PUBLIC	?AiGiveBra@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveBra
PUBLIC	?AiGiveStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveStatus
PUBLIC	?AiGiveDamageReport@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveDamageReport
PUBLIC	?AiGiveFuelStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiGiveFuelStatus
PUBLIC	?AiGiveWeaponsStatus@DigitalBrain@@AAEXXZ	; DigitalBrain::AiGiveWeaponsStatus
PUBLIC	?AiPromote@DigitalBrain@@AAEXXZ			; DigitalBrain::AiPromote
PUBLIC	?AiCheckInPositionCall@DigitalBrain@@AAEXMMM@Z	; DigitalBrain::AiCheckInPositionCall
PUBLIC	?AiCheckPosition@DigitalBrain@@AAEXXZ		; DigitalBrain::AiCheckPosition
PUBLIC	?AiCheckFormStrip@DigitalBrain@@AAEXXZ		; DigitalBrain::AiCheckFormStrip
PUBLIC	?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSmokeOn
PUBLIC	?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiSmokeOff
PUBLIC	?AiGlueWing@DigitalBrain@@AAEXXZ		; DigitalBrain::AiGlueWing
PUBLIC	?AiSplitWing@DigitalBrain@@AAEXXZ		; DigitalBrain::AiSplitWing
PUBLIC	?AiDropStores@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiDropStores
PUBLIC	?AiECMOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiECMOn
PUBLIC	?AiECMOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiECMOff
PUBLIC	?AiInitSSOffset@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiInitSSOffset
PUBLIC	?AiInitPince@DigitalBrain@@AAEXPAVFalconWingmanMsg@@H@Z ; DigitalBrain::AiInitPince
PUBLIC	?AiInitFlex@DigitalBrain@@AAEXXZ		; DigitalBrain::AiInitFlex
PUBLIC	?AiInitChainsaw@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiInitChainsaw
PUBLIC	?AiInitPosthole@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ; DigitalBrain::AiInitPosthole
PUBLIC	?AiInitTrig@DigitalBrain@@AAEXPAUmlTrig@@0@Z	; DigitalBrain::AiInitTrig
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	?IsDigital@AircraftClass@@QAEHXZ		; AircraftClass::IsDigital
PUBLIC	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ	; AircraftClass::DBrain
PUBLIC	?GetFaultCount@FaultClass@@QAEHXZ		; FaultClass::GetFaultCount
PUBLIC	?GetFFaultCount@FackClass@@QAEHXZ		; FackClass::GetFFaultCount
PUBLIC	?Fuel@AirframeClass@@QAEMXZ			; AirframeClass::Fuel
PUBLIC	?ExternalFuel@AirframeClass@@QAEMXZ		; AirframeClass::ExternalFuel
PUBLIC	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
PUBLIC	?BullseyeOn@PlayerOptionsClass@@QAEHXZ		; PlayerOptionsClass::BullseyeOn
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?NumHardpoints@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumHardpoints
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0BB@GFNLAJJG@?7in?5AiBreakLeft?6?$AA@	; `string'
PUBLIC	??_C@_0BC@NKAFKGNH@?7in?5AiBreakRight?6?$AA@	; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3d800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@40066666
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40490fd9
PUBLIC	__real@40c90fd9
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@42652ee1
PUBLIC	__real@437a0000
PUBLIC	__real@43960000
PUBLIC	__real@43fa0000
PUBLIC	__real@447a0000
PUBLIC	__real@44fa0000
PUBLIC	__real@457a0000
PUBLIC	__real@45bde1b0
PUBLIC	__real@46fffe00
PUBLIC	__real@47742400
PUBLIC	__real@4c0cd705
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0490fd9
PUBLIC	__real@c2c80000
PUBLIC	__real@c3960000
PUBLIC	__real@c3fa0000
PUBLIC	__real@c47a0000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetAz
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?FindFormation@ACFormationData@@QAEHH@Z:PROC	; ACFormationData::FindFormation
EXTRN	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z:PROC ; DigitalBrain::SetGroundTarget
EXTRN	?SelectGroundTarget@DigitalBrain@@IAEXH@Z:PROC	; DigitalBrain::SelectGroundTarget
EXTRN	?SetupAGMode@DigitalBrain@@IAEXPAVWayPointClass@@0@Z:PROC ; DigitalBrain::SetupAGMode
EXTRN	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z:PROC ; DigitalBrain::SendATCMsg
EXTRN	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z:PROC ; DigitalBrain::AiSplitFlight
EXTRN	?AiGlueFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z:PROC ; DigitalBrain::AiGlueFlight
EXTRN	?AiRunTargetSelection@DigitalBrain@@AAEXXZ:PROC	; DigitalBrain::AiRunTargetSelection
EXTRN	?AiSearchTargetList@DigitalBrain@@AAEXPAVVuEntity@@@Z:PROC ; DigitalBrain::AiSearchTargetList
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?SetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::SetFlag
EXTRN	?UnSetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::UnSetFlag
EXTRN	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z:PROC ; CampBaseClass::GetComponentIndex
EXTRN	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentEntity
EXTRN	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentNumber
EXTRN	?NumberOfComponents@CampBaseClass@@QAEHXZ:PROC	; CampBaseClass::NumberOfComponents
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?SimToGrid@@YAFM@Z:PROC				; SimToGrid
EXTRN	?AiIsFullResponse@@YAHHH@Z:PROC			; AiIsFullResponse
EXTRN	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z:PROC ; AiMakeRadioResponse
EXTRN	?AiMakeCommandMsg@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z:PROC ; AiMakeCommandMsg
EXTRN	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z:PROC ; AiRespondShortCallSign
EXTRN	?AiCheckForThreat@@YA?AVVU_ID@@PAVAircraftClass@@DHPAM@Z:PROC ; AiCheckForThreat
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?ConvertRadtoNav@@YAMM@Z:PROC			; ConvertRadtoNav
EXTRN	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconTrackMessage::FalconTrackMessage
EXTRN	??0FalconTankerMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconTankerMessage::FalconTankerMessage
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z:PROC ; FireControlComputer::SetMasterMode
EXTRN	?EmergencyJettison@SMSClass@@QAEXXZ:PROC	; SMSClass::EmergencyJettison
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?acFormationData@@3PAVACFormationData@@A:DWORD	; acFormationData
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?g_bPitchLimiterForAI@@3_NA:BYTE		; g_bPitchLimiterForAI
EXTRN	?g_fSSoffsetManeuverPoints1a@@3MA:DWORD		; g_fSSoffsetManeuverPoints1a
EXTRN	?g_fSSoffsetManeuverPoints1b@@3MA:DWORD		; g_fSSoffsetManeuverPoints1b
EXTRN	?g_fSSoffsetManeuverPoints2a@@3MA:DWORD		; g_fSSoffsetManeuverPoints2a
EXTRN	?g_fSSoffsetManeuverPoints2b@@3MA:DWORD		; g_fSSoffsetManeuverPoints2b
EXTRN	?g_fPinceManeuverPoints1a@@3MA:DWORD		; g_fPinceManeuverPoints1a
EXTRN	?g_fPinceManeuverPoints1b@@3MA:DWORD		; g_fPinceManeuverPoints1b
EXTRN	?g_fPinceManeuverPoints2a@@3MA:DWORD		; g_fPinceManeuverPoints2a
EXTRN	?g_fPinceManeuverPoints2b@@3MA:DWORD		; g_fPinceManeuverPoints2b
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c47a0000
CONST	SEGMENT
__real@c47a0000 DD 0c47a0000r			; -1000
CONST	ENDS
;	COMDAT __real@c3fa0000
CONST	SEGMENT
__real@c3fa0000 DD 0c3fa0000r			; -500
CONST	ENDS
;	COMDAT __real@c3960000
CONST	SEGMENT
__real@c3960000 DD 0c3960000r			; -300
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c0490fd9
CONST	SEGMENT
__real@c0490fd9 DD 0c0490fd9r			; -3.14159
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@4c0cd705
CONST	SEGMENT
__real@4c0cd705 DD 04c0cd705r			; 3.69203e+007
CONST	ENDS
;	COMDAT __real@47742400
CONST	SEGMENT
__real@47742400 DD 047742400r			; 62500
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@457a0000
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40066666
CONST	SEGMENT
__real@40066666 DD 040066666r			; 2.1
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKAFKGNH@?7in?5AiBreakRight?6?$AA@
CONST	SEGMENT
??_C@_0BC@NKAFKGNH@?7in?5AiBreakRight?6?$AA@ DB 09H, 'in AiBreakRight', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFNLAJJG@?7in?5AiBreakLeft?6?$AA@
CONST	SEGMENT
??_C@_0BB@GFNLAJJG@?7in?5AiBreakLeft?6?$AA@ DB 09H, 'in AiBreakLeft', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z$0
__unwindtable$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z$0
__unwindtable$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z$1
__ehfuncinfo$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumHardpoints@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumHardpoints@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumHardpoints, COMDAT
; _this$ = ecx

; 87   : 	int NumHardpoints (void) {return numHardpoints;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumHardpoints@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumHardpoints
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?BullseyeOn@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?BullseyeOn@PlayerOptionsClass@@QAEHXZ PROC		; PlayerOptionsClass::BullseyeOn, COMDAT
; _this$ = ecx

; 157  : 	int BullseyeOn (void)									{ return (SimFlags & SIM_BULLSEYE_CALLS) && TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 256				; 00000100H
	je	SHORT $LN3@BullseyeOn
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@BullseyeOn
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@BullseyeOn
$LN3@BullseyeOn:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BullseyeOn:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?BullseyeOn@PlayerOptionsClass@@QAEHXZ ENDP		; PlayerOptionsClass::BullseyeOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ PROC ; SimulationDriver::GetPlayerEntity, COMDAT
; _this$ = ecx

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ENDP ; SimulationDriver::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ExternalFuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ExternalFuel@AirframeClass@@QAEMXZ PROC		; AirframeClass::ExternalFuel, COMDAT
; _this$ = ecx

; 1184 : 	float ExternalFuel (void) {return externalFuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?ExternalFuel@AirframeClass@@QAEMXZ ENDP		; AirframeClass::ExternalFuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Fuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Fuel@AirframeClass@@QAEMXZ PROC			; AirframeClass::Fuel, COMDAT
; _this$ = ecx

; 1183 : 	float Fuel (void) {return fuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?Fuel@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Fuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?GetFFaultCount@FackClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFFaultCount@FackClass@@QAEHXZ PROC			; FackClass::GetFFaultCount, COMDAT
; _this$ = ecx

; 47   :     int		GetFFaultCount(void) {return mFaults.GetFaultCount();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetFaultCount@FaultClass@@QAEHXZ	; FaultClass::GetFaultCount
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFFaultCount@FackClass@@QAEHXZ ENDP			; FackClass::GetFFaultCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fault.h
;	COMDAT ?GetFaultCount@FaultClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFaultCount@FaultClass@@QAEHXZ PROC			; FaultClass::GetFaultCount, COMDAT
; _this$ = ecx

; 180  :        int	GetFaultCount(void) {return mFaultCount;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+256]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFaultCount@FaultClass@@QAEHXZ ENDP			; FaultClass::GetFaultCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ PROC	; AircraftClass::DBrain, COMDAT
; _this$ = ecx

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]
	mov	esp, ebp
	pop	ebp
	ret	0
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ENDP	; AircraftClass::DBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsDigital@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDigital@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsDigital, COMDAT
; _this$ = ecx

; 385  : 	int IsDigital() { return isDigital; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+948]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDigital@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsDigital
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv188 = -20						; size = 4
tv218 = -16						; size = 4
tv180 = -12						; size = 4
_trigYaw$ = -8						; size = 4
_this$ = -4						; size = 4
_firstTrig$ = 8						; size = 4
_secondTrig$ = 12					; size = 4
?AiInitTrig@DigitalBrain@@AAEXPAUmlTrig@@0@Z PROC	; DigitalBrain::AiInitTrig
; _this$ = ecx

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 829  : float trigYaw;
; 830  : 
; 831  :    // Find maneuver Axis
; 832  :    // Start w/ bearing to target/threat,
; 833  :    // if none use then lead's heading, else
; 834  :    // use ownship heading
; 835  :    if (targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN7@AiInitTrig

; 836  :    {
; 837  :       trigYaw = self->Yaw() + TargetAz (self, targetPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv180[ebp]
	movss	xmm0, DWORD PTR tv180[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	movss	DWORD PTR tv218[ebp], xmm0
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 8
	fstp	DWORD PTR tv188[ebp]
	movss	xmm0, DWORD PTR tv218[ebp]
	addss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR _trigYaw$[ebp], xmm0
	jmp	SHORT $LN4@AiInitTrig
$LN7@AiInitTrig:

; 838  :    }
; 839  :    else if (flightLead)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN5@AiInitTrig

; 840  :    {
; 841  :       trigYaw = flightLead->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _trigYaw$[ebp]

; 842  :    }
; 843  :    else

	jmp	SHORT $LN4@AiInitTrig
$LN5@AiInitTrig:

; 844  :    {
; 845  :       trigYaw = self->Yaw();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _trigYaw$[ebp]
$LN4@AiInitTrig:

; 846  :    }
; 847  : 
; 848  :    // Get the angles
; 849  :    mlSinCos(firstTrig, trigYaw);

	push	ecx
	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _firstTrig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 850  : 
; 851  : 	trigYaw += 90.0F * DTR;

	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR _trigYaw$[ebp], xmm0

; 852  : 
; 853  : 	if(trigYaw > 180.0F * DTR)

	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN3@AiInitTrig

; 854  :    {
; 855  : 		trigYaw -= (360.0F * DTR);

	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	subss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _trigYaw$[ebp], xmm0
$LN3@AiInitTrig:

; 856  : 	}
; 857  :    mlSinCos(secondTrig, trigYaw);

	push	ecx
	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _secondTrig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 858  : 
; 859  :    // Go left/right based on position in flight and
; 860  :    // number of people in flight.
; 861  :    // For a 2 ship 0 goes right, 1 goes left
; 862  :    // In a 4 ship 0 & 1 go right, 2 & 3 go left
; 863  : 
; 864  :    if (isWing >= 2 || (isWing == 1 && self->GetCampaignObject()->NumberOfComponents() < 3))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 2
	jge	SHORT $LN1@AiInitTrig
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN2@AiInitTrig
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	cmp	eax, 3
	jge	SHORT $LN2@AiInitTrig
$LN1@AiInitTrig:

; 865  :    {
; 866  : 		firstTrig->cos			= -firstTrig->cos;

	mov	edx, DWORD PTR _firstTrig$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _firstTrig$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 867  : 		firstTrig->sin			= -firstTrig->sin;

	mov	ecx, DWORD PTR _firstTrig$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _firstTrig$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN2@AiInitTrig:

; 868  : 	}
; 869  : 
; 870  : #if 0
; 871  : float		dx, dy, dz;
; 872  : float		ry;
; 873  : float		YawSelf;
; 874  : 
; 875  : 	dx			= flightLead->XPos() - XSelf;
; 876  : 	dy			= flightLead->YPos() - YSelf;
; 877  : 	dz			= flightLead->ZPos() - ZSelf;
; 878  : 
; 879  :    ry			= self->dmx[1][0] * dx + self->dmx[1][1] * dy + self->dmx[1][2] * dz;
; 880  : 
; 881  : 	YawSelf	= self->Yaw();
; 882  : 
; 883  :    mlSinCos(firstTrig, YawSelf);
; 884  : 
; 885  : 	YawSelf += 90.0F * DTR;
; 886  : 
; 887  : 	if(YawSelf > 180.0F * DTR) {
; 888  : 		YawSelf -= (360.0F * DTR);
; 889  : 	}
; 890  : 
; 891  :    mlSinCos(secondTrig, YawSelf);
; 892  : 
; 893  : 	if(ry > 0.0F) {		// Break left
; 894  : 		firstTrig->cos			= -firstTrig->cos;
; 895  : 		firstTrig->sin			= -firstTrig->sin;
; 896  : 	}
; 897  : #endif
; 898  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AiInitTrig@DigitalBrain@@AAEXPAUmlTrig@@0@Z ENDP	; DigitalBrain::AiInitTrig
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv310 = -36						; size = 4
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiInitPosthole@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiInitPosthole
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	int		flightIdx;
; 629  : 	short		edata[10];
; 630  : 
; 631  :    // Find the target given
; 632  :    if (vuDatabase->Find(msg->dataBlock.newTarget))

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+66]
	push	ecx
	mov	edx, DWORD PTR [eax+62]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	test	eax, eax
	je	$LN7@AiInitPost

; 633  :    {
; 634  : 		mDesignatedObject = msg->dataBlock.newTarget;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+62]
	mov	edx, DWORD PTR [eax+66]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], ecx
	mov	DWORD PTR [eax+804], edx

; 635  : 		mpActionFlags[AI_ENGAGE_TARGET]		= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 1

; 636  : 		mWeaponsAction                      = AI_WEAPONS_FREE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 1

; 637  : 		mpSearchFlags[AI_FIXATE_ON_TARGET]	= TRUE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 1

; 638  : 		AiSetManeuver(FalconWingmanMsg::WMPosthole);

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 639  : 		AiRunTargetSelection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRunTargetSelection@DigitalBrain@@AAEXXZ ; DigitalBrain::AiRunTargetSelection

; 640  : 		mpActionFlags[AI_USE_COMPLEX]       = TRUE;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 1

; 641  : 		mSpeedOrdered = cornerSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+852], ecx

; 642  : 		SetTrackPoint(self->XPos(), self->YPos(), OTWDriver.GetGroundLevel (trackX, trackY) - 4000.0F);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+152]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+148]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv310[ebp]
	movss	xmm0, DWORD PTR tv310[ebp]
	subss	xmm0, DWORD PTR __real@457a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 643  : 		mPointCounter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+856], 0

; 644  : 
; 645  : 		flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 646  : 		AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR [edx+48]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight

; 647  : 
; 648  : 		if(msg == NULL) {

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN6@AiInitPost

; 649  : 		   AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4

; 650  : 		}
; 651  : 		else {

	jmp	SHORT $LN3@AiInitPost
$LN6@AiInitPost:

; 652  : 		   if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@AiInitPost

; 653  : 				edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 654  : 				edata[1] = 5;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 5
	mov	WORD PTR _edata$[ebp+edx], ax

; 655  : 				AiMakeRadioResponse( self, rcEXECUTERESPONSE, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 656  : 				AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 657  : 		   }
; 658  : 		   else {

	jmp	SHORT $LN3@AiInitPost
$LN4@AiInitPost:

; 659  : 				AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 660  : 				AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN3@AiInitPost:

; 661  : 		   }
; 662  : 	   }
; 663  : 	   // 2002-03-15 ADDED BY S.G.
; 664  : 	   if (mpActionFlags[AI_EXECUTE_MANEUVER])

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+760], 0
	je	SHORT $LN2@AiInitPost

; 665  : 		   mpActionFlags[AI_EXECUTE_MANEUVER] = TRUE + 1;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 2
$LN2@AiInitPost:

; 666  :    }
; 667  :    else

	jmp	$LN1@AiInitPost
$LN7@AiInitPost:

; 668  :    {
; 669  : 		mDesignatedObject = FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+800], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+804], eax

; 670  : 		mpActionFlags[AI_ENGAGE_TARGET]		= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 671  : 		mWeaponsAction                      = AI_WEAPONS_HOLD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 0

; 672  : 		mpSearchFlags[AI_FIXATE_ON_TARGET]	= FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 0

; 673  : 		AiClearManeuver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearManeuver@DigitalBrain@@AAEXXZ	; DigitalBrain::AiClearManeuver

; 674  : 		edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 675  : 		edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 +
; 676  : 		self->GetCampaignObject()->GetComponentIndex(self) + 1;		

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	ecx, DWORD PTR [eax+esi*4-3]
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 677  : 		edata[2] = -1;

	mov	eax, 2
	shl	eax, 1
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 678  : 		edata[3] = -1;

	mov	edx, 2
	imul	edx, 3
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 679  : 		edata[4] = 1;

	mov	ecx, 2
	shl	ecx, 2
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 680  : 		AiMakeRadioResponse( self, rcUNABLE, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	219					; 000000dbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN1@AiInitPost:

; 681  :    }
; 682  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiInitPosthole@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiInitPosthole
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiInitChainsaw@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiInitChainsaw
; _this$ = ecx

; 905  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 906  : int		flightIdx;
; 907  : short		edata[10];
; 908  : 
; 909  :    // Find the target given
; 910  : 
; 911  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 912  : 
; 913  :    if (vuDatabase->Find(msg->dataBlock.newTarget))

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+66]
	push	ecx
	mov	edx, DWORD PTR [eax+62]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	test	eax, eax
	je	$LN5@AiInitChai

; 914  :    {
; 915  : 		mDesignatedObject = msg->dataBlock.newTarget;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+62]
	mov	edx, DWORD PTR [eax+66]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], ecx
	mov	DWORD PTR [eax+804], edx

; 916  : 		mpActionFlags[AI_ENGAGE_TARGET]		= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 1

; 917  : 		mWeaponsAction                      = AI_WEAPONS_FREE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 1

; 918  : 		mpSearchFlags[AI_FIXATE_ON_TARGET]	= TRUE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 1

; 919  : 		AiSetManeuver(FalconWingmanMsg::WMChainsaw);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 920  : 		AiRunTargetSelection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRunTargetSelection@DigitalBrain@@AAEXXZ ; DigitalBrain::AiRunTargetSelection

; 921  : 		mpActionFlags[AI_USE_COMPLEX]       = TRUE;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 1

; 922  : 		AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight

; 923  : 		// 2002-03-15 ADDED BY S.G.
; 924  : 		if (mpActionFlags[AI_EXECUTE_MANEUVER])

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+760], 0
	je	SHORT $LN4@AiInitChai

; 925  : 			mpActionFlags[AI_EXECUTE_MANEUVER] = TRUE + 1;

	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 2
$LN4@AiInitChai:

; 926  :    }
; 927  :    else

	jmp	SHORT $LN3@AiInitChai
$LN5@AiInitChai:

; 928  :    {
; 929  : 		mDesignatedObject = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+800], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+804], edx

; 930  : 		mpActionFlags[AI_ENGAGE_TARGET]		= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 931  : 		mWeaponsAction                      = AI_WEAPONS_HOLD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+828], 0

; 932  : 		mpSearchFlags[AI_FIXATE_ON_TARGET]	= FALSE;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+784], 0

; 933  : 		AiClearManeuver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearManeuver@DigitalBrain@@AAEXXZ	; DigitalBrain::AiClearManeuver
$LN3@AiInitChai:

; 934  :    }
; 935  : 
; 936  : 
; 937  : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiInitChai

; 938  : 		edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 939  : 		edata[1] = 6;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 6
	mov	WORD PTR _edata$[ebp+ecx], dx

; 940  : 		AiMakeRadioResponse( self, rcEXECUTERESPONSE, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 941  : 		AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 942  : 	}
; 943  : 	else {

	jmp	SHORT $LN6@AiInitChai
$LN2@AiInitChai:

; 944  : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN6@AiInitChai:

; 945  : 	}
; 946  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiInitChainsaw@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiInitChainsaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_firstTrig$ = -40					; size = 8
_secondTrig$ = -32					; size = 8
_ZSelf$ = -24						; size = 4
tv244 = -20						; size = 4
_YSelf$ = -16						; size = 4
_XSelf$ = -12						; size = 4
_spacing$ = -8						; size = 4
_this$ = -4						; size = 4
?AiInitFlex@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiInitFlex
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	mlTrig	firstTrig;
; 796  : 	mlTrig	secondTrig;
; 797  : 	float		XSelf;
; 798  : 	float		YSelf;
; 799  : 	float		ZSelf;
; 800  : 	float		spacing = NM_TO_FT;

	movss	xmm0, DWORD PTR __real@45bde1b0
	movss	DWORD PTR _spacing$[ebp], xmm0

; 801  : 
; 802  : 	AiSetManeuver(FalconWingmanMsg::WMPince);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 803  : 
; 804  : 	XSelf	= self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _XSelf$[ebp]

; 805  : 	YSelf	= self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _YSelf$[ebp]

; 806  : 	ZSelf	= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _ZSelf$[ebp]

; 807  : 
; 808  : 	AiInitTrig(&firstTrig, &secondTrig);

	lea	eax, DWORD PTR _secondTrig$[ebp]
	push	eax
	lea	ecx, DWORD PTR _firstTrig$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiInitTrig@DigitalBrain@@AAEXPAUmlTrig@@0@Z ; DigitalBrain::AiInitTrig

; 809  : 	
; 810  : 	mpManeuverPoints[0][0]	= XSelf + secondTrig.cos * spacing;

	movss	xmm0, DWORD PTR _secondTrig$[ebp+4]
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	addss	xmm0, DWORD PTR _XSelf$[ebp]
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+860]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 811  : 	mpManeuverPoints[0][1]	= YSelf + firstTrig.sin * spacing;

	movss	xmm0, DWORD PTR _firstTrig$[ebp]
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	addss	xmm0, DWORD PTR _YSelf$[ebp]
	mov	eax, 8
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 812  : 	mpManeuverPoints[1][0]	= XSelf - secondTrig.cos * 2.0F * spacing;

	movss	xmm0, DWORD PTR _secondTrig$[ebp+4]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	movss	xmm1, DWORD PTR _XSelf$[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm1

; 813  : 	mpManeuverPoints[1][1]	= YSelf - secondTrig.sin * 2.0F * spacing;

	movss	xmm0, DWORD PTR _secondTrig$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	movss	xmm1, DWORD PTR _YSelf$[ebp]
	subss	xmm1, xmm0
	mov	edx, 8
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+860]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm1

; 814  : 	mpManeuverPoints[2][0]	= XSelf - secondTrig.cos * 2.1F * spacing;

	movss	xmm0, DWORD PTR _secondTrig$[ebp+4]
	mulss	xmm0, DWORD PTR __real@40066666
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	movss	xmm1, DWORD PTR _XSelf$[ebp]
	subss	xmm1, xmm0
	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 815  : 	mpManeuverPoints[2][1]	= YSelf - secondTrig.sin * 2.1F * spacing;

	movss	xmm0, DWORD PTR _secondTrig$[ebp]
	mulss	xmm0, DWORD PTR __real@40066666
	mulss	xmm0, DWORD PTR _spacing$[ebp]
	movss	xmm1, DWORD PTR _YSelf$[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm1

; 816  : 
; 817  : 	mAltitudeOrdered			= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]

; 818  : 	mSpeedOrdered				= self->GetVt() * FTPSEC_TO_KNOTS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv244[ebp]
	movss	xmm0, DWORD PTR tv244[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 819  : 	mPointCounter				= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+856], 0

; 820  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiInitFlex@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiInitFlex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_ZSelf$ = -84						; size = 4
tv395 = -80						; size = 4
tv403 = -76						; size = 4
tv426 = -72						; size = 4
tv410 = -68						; size = 4
tv441 = -64						; size = 4
tv509 = -60						; size = 4
_YSelf$ = -56						; size = 4
_XSelf$ = -52						; size = 4
_trigYaw$ = -48						; size = 4
_firstTrig$ = -44					; size = 8
_flightIdx$ = -36					; size = 4
_side$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_doSplit$ = 12						; size = 4
?AiInitPince@DigitalBrain@@AAEXPAVFalconWingmanMsg@@H@Z PROC ; DigitalBrain::AiInitPince
; _this$ = ecx

; 689  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 690  : float trigYaw;
; 691  : float		XSelf;
; 692  : float		YSelf;
; 693  : float		ZSelf;
; 694  : mlTrig	firstTrig;
; 695  : int		flightIdx;
; 696  : short		edata[10];
; 697  : float side;
; 698  : 
; 699  : 	AiSetManeuver(FalconWingmanMsg::WMPince);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 700  : 
; 701  : 	XSelf	= self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _XSelf$[ebp]

; 702  : 	YSelf	= self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _YSelf$[ebp]

; 703  : 	ZSelf	= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _ZSelf$[ebp]

; 704  : 
; 705  : 	// 2002-04-07 ADDED BY S.G. Since Pince is available on the menu while we have something bugged, why not use it?
; 706  : 	if (vuDatabase->Find(msg->dataBlock.newTarget))

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+66]
	push	ecx
	mov	edx, DWORD PTR [eax+62]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	test	eax, eax
	je	SHORT $LN12@AiInitPinc

; 707  : 	{
; 708  : 		mDesignatedObject = msg->dataBlock.newTarget;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+62]
	mov	edx, DWORD PTR [eax+66]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], ecx
	mov	DWORD PTR [eax+804], edx

; 709  : 		mpActionFlags[AI_ENGAGE_TARGET]		= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 1

; 710  : 		mWeaponsAction                      = AI_WEAPONS_FREE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 1

; 711  : 		mpSearchFlags[AI_FIXATE_ON_TARGET]	= TRUE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 1

; 712  : 		AiRunTargetSelection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRunTargetSelection@DigitalBrain@@AAEXXZ ; DigitalBrain::AiRunTargetSelection
$LN12@AiInitPinc:

; 713  : //		mpActionFlags[AI_USE_COMPLEX]       = TRUE;
; 714  : //		if (mpActionFlags[AI_EXECUTE_MANEUVER])
; 715  : //			mpActionFlags[AI_EXECUTE_MANEUVER] = TRUE + 1;
; 716  : 	}
; 717  : 	// END OF ADDED SECTION
; 718  : 
; 719  :    // Find maneuver Axis
; 720  :    // Start w/ bearing to target/threat,
; 721  :    // if none use then lead's heading, else
; 722  :    // use ownship heading
; 723  :    //LRKLUDGE Need to check passed target here as well
; 724  :    if (targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN11@AiInitPinc

; 725  :    {
; 726  : 		trigYaw = self->Yaw() + TargetAz (self, targetPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv395[ebp]
	movss	xmm0, DWORD PTR tv395[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	movss	DWORD PTR tv509[ebp], xmm0
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 8
	fstp	DWORD PTR tv403[ebp]
	movss	xmm0, DWORD PTR tv509[ebp]
	addss	xmm0, DWORD PTR tv403[ebp]
	movss	DWORD PTR _trigYaw$[ebp], xmm0

; 727  : 		mSpeedOrdered    = self->GetVt() * FTPSEC_TO_KNOTS; // Cobra - convert to kts.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv410[ebp]
	movss	xmm0, DWORD PTR tv410[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+852], xmm0

; 728  : 		mAltitudeOrdered = self->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+848]
	jmp	$LN8@AiInitPinc
$LN11@AiInitPinc:

; 729  :    }
; 730  :    else if (flightLead)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN9@AiInitPinc

; 731  :    {
; 732  : 		trigYaw = flightLead->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _trigYaw$[ebp]

; 733  : 		mSpeedOrdered    = flightLead->GetVt() * FTPSEC_TO_KNOTS; // Cobra - convert to kts.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+708]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv426[ebp]
	movss	xmm0, DWORD PTR tv426[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 734  : 		mAltitudeOrdered = flightLead->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+708]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]

; 735  :    }
; 736  :    else

	jmp	SHORT $LN8@AiInitPinc
$LN9@AiInitPinc:

; 737  :    {
; 738  : 		trigYaw = self->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _trigYaw$[ebp]

; 739  : 		mSpeedOrdered    = self->GetVt() * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv441[ebp]
	movss	xmm0, DWORD PTR tv441[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 740  : 		mAltitudeOrdered = self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]
$LN8@AiInitPinc:

; 741  :    }
; 742  : 
; 743  :    // Get the angles
; 744  :    mlSinCos(&firstTrig, trigYaw);

	push	ecx
	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _firstTrig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 745  : 
; 746  : // S.G. isWing has the index position of the plane in the flight. It is ALWAYS less than the number of planes
; 747  : // if (doSplit && isWing > self->GetCampaignObject()->NumberOfComponents())
; 748  : // Instead, odd plane number (wingmen) have the 1.0F side. Leaders (flight and element) have the -1.0F side
; 749  :    if (doSplit && (isWing & 1))

	cmp	DWORD PTR _doSplit$[ebp], 0
	je	SHORT $LN7@AiInitPinc
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	je	SHORT $LN7@AiInitPinc

; 750  :       side = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _side$[ebp], xmm0

; 751  :    else

	jmp	SHORT $LN6@AiInitPinc
$LN7@AiInitPinc:

; 752  :       side = -1.0F;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _side$[ebp], xmm0
$LN6@AiInitPinc:

; 753  : 
; 754  :     // 2002-04-07 MODIFIED BY S.G. Replaced the constant by FalconSP.cfg vars
; 755  : 	mpManeuverPoints[0][0]	= XSelf + firstTrig.cos *  g_fPinceManeuverPoints1a * NM_TO_FT - firstTrig.sin * g_fPinceManeuverPoints1b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm0, DWORD PTR ?g_fPinceManeuverPoints1a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _XSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp]
	mulss	xmm1, DWORD PTR ?g_fPinceManeuverPoints1b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	subss	xmm0, xmm1
	mov	ecx, 8
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 756  : 	mpManeuverPoints[0][1]	= YSelf + firstTrig.sin *  g_fPinceManeuverPoints1a * NM_TO_FT + firstTrig.cos * g_fPinceManeuverPoints1b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp]
	mulss	xmm0, DWORD PTR ?g_fPinceManeuverPoints1a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _YSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm1, DWORD PTR ?g_fPinceManeuverPoints1b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	addss	xmm0, xmm1
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+860]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 757  : // S.G. SECOND LEG IS JUST 4 NM, NOT 20 NM
; 758  : //	mpManeuverPoints[1][0]	= XSelf + firstTrig.cos * 20.0F * NM_TO_FT - firstTrig.sin * 5.0F * NM_TO_FT * side;
; 759  : //	mpManeuverPoints[1][1]	= YSelf + firstTrig.sin * 20.0F * NM_TO_FT + firstTrig.cos * 5.0F * NM_TO_FT * side;
; 760  : 	mpManeuverPoints[1][0]	= XSelf + firstTrig.cos *  g_fPinceManeuverPoints2a * NM_TO_FT - firstTrig.sin * g_fPinceManeuverPoints2b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm0, DWORD PTR ?g_fPinceManeuverPoints2a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _XSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp]
	mulss	xmm1, DWORD PTR ?g_fPinceManeuverPoints2b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	subss	xmm0, xmm1
	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 761  : 	mpManeuverPoints[1][1]	= YSelf + firstTrig.sin *  g_fPinceManeuverPoints2a * NM_TO_FT + firstTrig.cos * g_fPinceManeuverPoints2b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp]
	mulss	xmm0, DWORD PTR ?g_fPinceManeuverPoints2a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _YSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm1, DWORD PTR ?g_fPinceManeuverPoints2b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 762  : 
; 763  : 	mPointCounter				= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+856], 0

; 764  : 
; 765  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 766  : 	if(flightIdx && msg) {

	cmp	DWORD PTR _flightIdx$[ebp], 0
	je	SHORT $LN5@AiInitPinc
	cmp	DWORD PTR _msg$[ebp], 0
	je	SHORT $LN5@AiInitPinc

; 767  : 		AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx); // this has nothing to do witht he doSplit variable

	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight
$LN5@AiInitPinc:

; 768  : 	}
; 769  : 
; 770  : 
; 771  : 	if(msg == NULL) {

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN4@AiInitPinc

; 772  : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4

; 773  : 	}
; 774  : 	else {

	jmp	SHORT $LN1@AiInitPinc
$LN4@AiInitPinc:

; 775  : 		if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiInitPinc

; 776  : 			edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 777  : 			edata[1] = 4;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	mov	WORD PTR _edata$[ebp+ecx], dx

; 778  :    		AiMakeRadioResponse( self, rcEXECUTERESPONSE, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 779  : 			AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 780  : 		}
; 781  : 		else {

	jmp	SHORT $LN1@AiInitPinc
$LN2@AiInitPinc:

; 782  : 			AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN1@AiInitPinc:

; 783  : 		}
; 784  : 	}
; 785  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?AiInitPince@DigitalBrain@@AAEXPAVFalconWingmanMsg@@H@Z ENDP ; DigitalBrain::AiInitPince
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_ZSelf$ = -84						; size = 4
tv394 = -80						; size = 4
tv402 = -76						; size = 4
tv425 = -72						; size = 4
tv409 = -68						; size = 4
tv440 = -64						; size = 4
tv508 = -60						; size = 4
_YSelf$ = -56						; size = 4
_XSelf$ = -52						; size = 4
_trigYaw$ = -48						; size = 4
_firstTrig$ = -44					; size = 8
_flightIdx$ = -36					; size = 4
_side$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiInitSSOffset@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiInitSSOffset
; _this$ = ecx

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 522  : float trigYaw;
; 523  : float		XSelf;
; 524  : float		YSelf;
; 525  : float		ZSelf;
; 526  : mlTrig	firstTrig;
; 527  : int		flightIdx;
; 528  : short		edata[10];
; 529  : float side;
; 530  : 
; 531  : 	AiSetManeuver(FalconWingmanMsg::WMPince);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 532  : 
; 533  : 	XSelf	= self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _XSelf$[ebp]

; 534  : 	YSelf	= self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _YSelf$[ebp]

; 535  : 	ZSelf	= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _ZSelf$[ebp]

; 536  : 
; 537  : 	// 2002-04-07 ADDED BY S.G. Since SSOffset is available on the menu while we have something bugged, why not use it?
; 538  : 	if (vuDatabase->Find(msg->dataBlock.newTarget))

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+66]
	push	ecx
	mov	edx, DWORD PTR [eax+62]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	test	eax, eax
	je	SHORT $LN12@AiInitSSOf

; 539  : 	{
; 540  : 		mDesignatedObject = msg->dataBlock.newTarget;

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+62]
	mov	edx, DWORD PTR [eax+66]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], ecx
	mov	DWORD PTR [eax+804], edx

; 541  : 		mpActionFlags[AI_ENGAGE_TARGET]		= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 1

; 542  : 		mWeaponsAction                      = AI_WEAPONS_FREE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 1

; 543  : 		mpSearchFlags[AI_FIXATE_ON_TARGET]	= TRUE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 1

; 544  : 		AiRunTargetSelection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRunTargetSelection@DigitalBrain@@AAEXXZ ; DigitalBrain::AiRunTargetSelection
$LN12@AiInitSSOf:

; 545  : //		mpActionFlags[AI_USE_COMPLEX]       = TRUE;
; 546  : //		if (mpActionFlags[AI_EXECUTE_MANEUVER])
; 547  : //			mpActionFlags[AI_EXECUTE_MANEUVER] = TRUE + 1;
; 548  : 	}
; 549  : 
; 550  : 	// END OF ADDED SECTION
; 551  :    // Find maneuver Axis
; 552  :    // Start w/ bearing to target/threat,
; 553  :    // if none use then lead's heading, else
; 554  :    // use ownship heading
; 555  :    //LRKLUDGE Need to check passed target here as well
; 556  :    if (targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN11@AiInitSSOf

; 557  :    {
; 558  : 		trigYaw = self->Yaw() + TargetAz (self, targetPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv394[ebp]
	movss	xmm0, DWORD PTR tv394[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	movss	DWORD PTR tv508[ebp], xmm0
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 8
	fstp	DWORD PTR tv402[ebp]
	movss	xmm0, DWORD PTR tv508[ebp]
	addss	xmm0, DWORD PTR tv402[ebp]
	movss	DWORD PTR _trigYaw$[ebp], xmm0

; 559  : 		mSpeedOrdered    = self->GetVt() * FTPSEC_TO_KNOTS; // Cobra - convert to kts.

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv409[ebp]
	movss	xmm0, DWORD PTR tv409[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+852], xmm0

; 560  : 		mAltitudeOrdered = self->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+848]
	jmp	$LN8@AiInitSSOf
$LN11@AiInitSSOf:

; 561  :    }
; 562  :    else if (flightLead)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN9@AiInitSSOf

; 563  :    {
; 564  : 		trigYaw = flightLead->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _trigYaw$[ebp]

; 565  : 		mSpeedOrdered    = flightLead->GetVt() * FTPSEC_TO_KNOTS; // Cobra - convert to kts.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+708]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv425[ebp]
	movss	xmm0, DWORD PTR tv425[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 566  : 		mAltitudeOrdered = flightLead->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+708]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]

; 567  :    }
; 568  :    else

	jmp	SHORT $LN8@AiInitSSOf
$LN9@AiInitSSOf:

; 569  :    {
; 570  : 		trigYaw = self->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _trigYaw$[ebp]

; 571  : 		mSpeedOrdered    = self->GetVt() * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv440[ebp]
	movss	xmm0, DWORD PTR tv440[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 572  : 		mAltitudeOrdered = self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]
$LN8@AiInitSSOf:

; 573  :    }
; 574  : 
; 575  :    // Get the angles
; 576  :    mlSinCos(&firstTrig, trigYaw);

	push	ecx
	movss	xmm0, DWORD PTR _trigYaw$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _firstTrig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 577  : 
; 578  : // S.G. isWing has the index position of the plane in the flight. It is ALWAYS less than the number of planes
; 579  : // if (isWing > self->GetCampaignObject()->NumberOfComponents())
; 580  : // Instead, odd plane number (wingmen) have the 1.0F side. Leaders (flight and element) have the -1.0F side
; 581  : // if (isWing & 1)
; 582  : // 2001-8-03 BUT INSTEAD, I'LL REVERSE IT SO THE WINGS GO TO THE LEFT
; 583  :    if (!(isWing & 1))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	jne	SHORT $LN7@AiInitSSOf

; 584  :       side = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _side$[ebp], xmm0

; 585  :    else

	jmp	SHORT $LN6@AiInitSSOf
$LN7@AiInitSSOf:

; 586  :       side = -1.0F;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _side$[ebp], xmm0
$LN6@AiInitSSOf:

; 587  : 
; 588  :     // 2002-04-07 MODIFIED BY S.G. Replaced the constant by FalconSP.cfg vars
; 589  : 	mpManeuverPoints[0][0]	= XSelf + firstTrig.cos *  g_fSSoffsetManeuverPoints1a * NM_TO_FT - firstTrig.sin * g_fSSoffsetManeuverPoints1b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm0, DWORD PTR ?g_fSSoffsetManeuverPoints1a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _XSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp]
	mulss	xmm1, DWORD PTR ?g_fSSoffsetManeuverPoints1b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	subss	xmm0, xmm1
	mov	ecx, 8
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 590  : 	mpManeuverPoints[0][1]	= YSelf + firstTrig.sin *  g_fSSoffsetManeuverPoints1a * NM_TO_FT + firstTrig.cos * g_fSSoffsetManeuverPoints1b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp]
	mulss	xmm0, DWORD PTR ?g_fSSoffsetManeuverPoints1a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _YSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm1, DWORD PTR ?g_fSSoffsetManeuverPoints1b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	addss	xmm0, xmm1
	mov	edx, 8
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+860]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 591  : // S.G. SECOND LEG IS JUST 4 NM, NOT 20 NM
; 592  : //	mpManeuverPoints[1][0]	= XSelf + firstTrig.cos * 20.0F * NM_TO_FT - firstTrig.sin * 5.0F * NM_TO_FT * side;
; 593  : //	mpManeuverPoints[1][1]	= YSelf + firstTrig.sin * 20.0F * NM_TO_FT + firstTrig.cos * 5.0F * NM_TO_FT * side;
; 594  : 	mpManeuverPoints[1][0]	= XSelf + firstTrig.cos *  g_fSSoffsetManeuverPoints2a * NM_TO_FT - firstTrig.sin * g_fSSoffsetManeuverPoints2b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm0, DWORD PTR ?g_fSSoffsetManeuverPoints2a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _XSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp]
	mulss	xmm1, DWORD PTR ?g_fSSoffsetManeuverPoints2b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	subss	xmm0, xmm1
	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+860]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 595  : 	mpManeuverPoints[1][1]	= YSelf + firstTrig.sin *  g_fSSoffsetManeuverPoints2a * NM_TO_FT + firstTrig.cos * g_fSSoffsetManeuverPoints2b * NM_TO_FT * side;

	movss	xmm0, DWORD PTR _firstTrig$[ebp]
	mulss	xmm0, DWORD PTR ?g_fSSoffsetManeuverPoints2a@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	addss	xmm0, DWORD PTR _YSelf$[ebp]
	movss	xmm1, DWORD PTR _firstTrig$[ebp+4]
	mulss	xmm1, DWORD PTR ?g_fSSoffsetManeuverPoints2b@@3MA
	mulss	xmm1, DWORD PTR __real@45bde1b0
	mulss	xmm1, DWORD PTR _side$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+860]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 596  : 
; 597  : 	mPointCounter				= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+856], 0

; 598  : 
; 599  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 600  : 	if(flightIdx && msg) {

	cmp	DWORD PTR _flightIdx$[ebp], 0
	je	SHORT $LN5@AiInitSSOf
	cmp	DWORD PTR _msg$[ebp], 0
	je	SHORT $LN5@AiInitSSOf

; 601  : 		AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx); // this has nothing to do witht he doSplit variable

	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight
$LN5@AiInitSSOf:

; 602  : 	}
; 603  : 
; 604  : 
; 605  : 	if(msg == NULL) {

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN4@AiInitSSOf

; 606  : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4

; 607  : 	}
; 608  : 	else {

	jmp	SHORT $LN1@AiInitSSOf
$LN4@AiInitSSOf:

; 609  : 		if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiInitSSOf

; 610  : 			edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 611  : 			edata[1] = 9;	// fixed from "bracketing"

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 9
	mov	WORD PTR _edata$[ebp+ecx], dx

; 612  :    		AiMakeRadioResponse( self, rcEXECUTERESPONSE, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 613  : 			AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 614  : 		}
; 615  : 		else {

	jmp	SHORT $LN1@AiInitSSOf
$LN2@AiInitSSOf:

; 616  : 			AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN1@AiInitSSOf:

; 617  : 		}
; 618  : 	}
; 619  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiInitSSOffset@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiInitSSOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 4
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiECMOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiECMOff
; _this$ = ecx

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 	short	edata[10];
; 215  : 	int	flightIdx;
; 216  : 
; 217  : 	// turn ECM off
; 218  : 	self->UnSetFlag(ECM_ON);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?UnSetFlag@SimBaseClass@@QAEXH@Z	; SimBaseClass::UnSetFlag

; 219  : 	// set a radar flag here
; 220  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 221  : 
; 222  : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiECMOff

; 223  : 		edata[0] = flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 224  : 		edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN5@AiECMOff
	jmp	SHORT $LN6@AiECMOff
$LN5@AiECMOff:
	call	___report_rangecheckfailure
$LN6@AiECMOff:
	xor	eax, eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+ecx], ax

; 225  :    		AiMakeRadioResponse( self, rcECMOFF, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 226  : 	}
; 227  : 	else {

	jmp	SHORT $LN4@AiECMOff
$LN2@AiECMOff:

; 228  : 		AiRespondShortCallSign(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN4@AiECMOff:

; 229  : 	}
; 230  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiECMOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiECMOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 4
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiECMOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC	; DigitalBrain::AiECMOn
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	short	edata[10];
; 189  : 	int	flightIdx;
; 190  : 
; 191  : 
; 192  : 	// set a radar flag here
; 193  : 	self->SetFlag(ECM_ON);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag

; 194  : 
; 195  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 196  : 
; 197  : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiECMOn

; 198  : 		edata[0] = flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 199  : 		edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN5@AiECMOn
	jmp	SHORT $LN6@AiECMOn
$LN5@AiECMOn:
	call	___report_rangecheckfailure
$LN6@AiECMOn:
	xor	eax, eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+ecx], ax

; 200  : 	   	AiMakeRadioResponse( self, rcECMON, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	53					; 00000035H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 201  : 	}
; 202  : 	else {

	jmp	SHORT $LN4@AiECMOn
$LN2@AiECMOn:

; 203  : 		AiRespondShortCallSign(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN4@AiECMOn:

; 204  : 	}
; 205  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiECMOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP	; DigitalBrain::AiECMOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiDropStores@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiDropStores
; _this$ = ecx

; 2611 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2612 : 	short	edata[10];
; 2613 : 	int	flightIdx;
; 2614 : 
; 2615 : 	self->Sms->EmergencyJettison();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+940]
	call	?EmergencyJettison@SMSClass@@QAEXXZ	; SMSClass::EmergencyJettison

; 2616 : 
; 2617 : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2618 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) 

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiDropStor

; 2619 : 	{
; 2620 : 		edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 2621 : 		edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2622 :    		AiMakeRadioResponse( self, rcROGER, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	179					; 000000b3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2623 : 	}
; 2624 : 	else 

	jmp	SHORT $LN3@AiDropStor
$LN2@AiDropStor:

; 2625 : 	{
; 2626 : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN3@AiDropStor:

; 2627 : 	}
; 2628 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiDropStores@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiDropStores
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiSplitWing@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiSplitWing
; _this$ = ecx

; 2601 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2602 : 	mSplitFlight = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+892], 1

; 2603 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiSplitWing@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiSplitWing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiGlueWing@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiGlueWing
; _this$ = ecx

; 2591 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2592 : 	mSplitFlight = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+892], 0

; 2593 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiGlueWing@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiGlueWing
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T2 = -80						; size = 8
$T3 = -72						; size = 8
$T4 = -64						; size = 4
tv90 = -60						; size = 4
$T5 = -56						; size = 4
_flightIdx$ = -52					; size = 4
tv136 = -48						; size = 4
_trackMsg$6 = -44					; size = 4
_this$ = -40						; size = 4
_edata$ = -36						; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_msg$ = 8						; size = 4
?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiSmokeOff
; _this$ = ecx

; 155  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 	short	edata[10];
; 157  : 	int	flightIdx;
; 158  : 
; 159  : 	if (SimDriver.GetPlayerEntity())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	test	eax, eax
	je	$LN3@AiSmokeOff

; 160  : 	{
; 161  : 		FalconTrackMessage* trackMsg = new FalconTrackMessage( 1,SimDriver.GetPlayerEntity()->Id(), FalconLocalGame );

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@AiSmokeOff
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@AiSmokeOff
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@AiSmokeOff
$LN6@AiSmokeOff:
	mov	DWORD PTR tv90[ebp], 0
$LN7@AiSmokeOff:
	push	1
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTrackMessage::FalconTrackMessage
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN9@AiSmokeOff
$LN8@AiSmokeOff:
	mov	DWORD PTR tv136[ebp], 0
$LN9@AiSmokeOff:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _trackMsg$6[ebp], ecx

; 162  : 		ShiAssert( trackMsg );
; 163  : 		trackMsg->dataBlock.trackType	= Track_SmokeOff;

	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -65536				; ffff0000H
	or	eax, 7
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [ecx+48], eax

; 164  : 		trackMsg->dataBlock.id			= self->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], edx

; 165  : 
; 166  : 		FalconSendMessage (trackMsg, TRUE);

	push	1
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN3@AiSmokeOff:

; 167  : 	}
; 168  : 
; 169  : 	// set a radar flag here
; 170  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 171  : 
; 172  : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiSmokeOff

; 173  : 		edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 174  : 		edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 175  :    	AiMakeRadioResponse( self, rcROGER, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	179					; 000000b3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 176  : 	}
; 177  : 	else {

	jmp	SHORT $LN4@AiSmokeOff
$LN2@AiSmokeOff:

; 178  : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN4@AiSmokeOff:

; 179  : 	}
; 180  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AiSmokeOff@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiSmokeOff
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T2 = -80						; size = 8
$T3 = -72						; size = 8
$T4 = -64						; size = 4
tv90 = -60						; size = 4
$T5 = -56						; size = 4
_flightIdx$ = -52					; size = 4
tv136 = -48						; size = 4
_trackMsg$6 = -44					; size = 4
_this$ = -40						; size = 4
_edata$ = -36						; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_msg$ = 8						; size = 4
?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiSmokeOn
; _this$ = ecx

; 121  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 	short	edata[10];
; 123  : 	int	flightIdx;
; 124  : 
; 125  : 	if (SimDriver.GetPlayerEntity())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	test	eax, eax
	je	$LN3@AiSmokeOn

; 126  : 	{
; 127  : 		FalconTrackMessage* trackMsg = new FalconTrackMessage(1, SimDriver.GetPlayerEntity()->Id(), FalconLocalGame );

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@AiSmokeOn
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@AiSmokeOn
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN7@AiSmokeOn
$LN6@AiSmokeOn:
	mov	DWORD PTR tv90[ebp], 0
$LN7@AiSmokeOn:
	push	1
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0FalconTrackMessage@@QAE@HVVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTrackMessage::FalconTrackMessage
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN9@AiSmokeOn
$LN8@AiSmokeOn:
	mov	DWORD PTR tv136[ebp], 0
$LN9@AiSmokeOn:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _trackMsg$6[ebp], ecx

; 128  : 		ShiAssert( trackMsg );
; 129  : 		trackMsg->dataBlock.trackType	= Track_SmokeOn;

	mov	edx, DWORD PTR _trackMsg$6[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -65536				; ffff0000H
	or	eax, 6
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [ecx+48], eax

; 130  : 		trackMsg->dataBlock.id			= self->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _trackMsg$6[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], edx

; 131  : 
; 132  : 		FalconSendMessage (trackMsg, TRUE);

	push	1
	mov	ecx, DWORD PTR _trackMsg$6[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN3@AiSmokeOn:

; 133  : 	}
; 134  : 
; 135  : 
; 136  : 	// set a radar flag here
; 137  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 138  : 
; 139  : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiSmokeOn

; 140  : 		edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 141  : 		edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 142  :    	AiMakeRadioResponse( self, rcROGER, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	179					; 000000b3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 143  : 	}
; 144  : 	else {

	jmp	SHORT $LN4@AiSmokeOn
$LN2@AiSmokeOn:

; 145  : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN4@AiSmokeOn:

; 146  : 	}
; 147  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AiSmokeOn@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiSmokeOn
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?AiCheckFormStrip@DigitalBrain@@AAEXXZ PROC		; DigitalBrain::AiCheckFormStrip
; _this$ = ecx

; 2575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2576 : 	short edata[10];
; 2577 : 
; 2578 : 	if(mpActionFlags[AI_FOLLOW_FORMATION] == TRUE && mInPositionFlag) {

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+760], 1
	jne	SHORT $LN2@AiCheckFor
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+840], 0
	je	SHORT $LN2@AiCheckFor

; 2579 : 		mInPositionFlag = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+840], 0

; 2580 : 		edata[0] = self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	ecx, 2
	imul	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 2581 : 		AiMakeRadioResponse( self, rcSTRIPING, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	200					; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN2@AiCheckFor:

; 2582 : 	}
; 2583 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AiCheckFormStrip@DigitalBrain@@AAEXXZ ENDP		; DigitalBrain::AiCheckFormStrip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv403 = -76						; size = 4
_zdiff$ = -72						; size = 4
tv395 = -68						; size = 4
tv389 = -64						; size = 4
tv383 = -60						; size = 4
tv375 = -56						; size = 4
tv362 = -52						; size = 4
tv351 = -48						; size = 4
_vehInFlight$ = -44					; size = 4
_ydiff$ = -40						; size = 4
_xdiff$ = -36						; size = 4
_trY$ = -32						; size = 4
_trX$ = -28						; size = 4
_rangeFactor$ = -24					; size = 4
_flightIdx$ = -20					; size = 4
_trZ$ = -16						; size = 4
_curPosition$ = -12					; size = 4
_paircraft$ = -8					; size = 4
_this$ = -4						; size = 4
?AiCheckPosition@DigitalBrain@@AAEXXZ PROC		; DigitalBrain::AiCheckPosition
; _this$ = ecx

; 2505 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 2506 : float xdiff, ydiff, zdiff;
; 2507 : float trX, trY, trZ, rangeFactor;
; 2508 : ACFormationData::PositionData *curPosition;
; 2509 : AircraftClass* paircraft;
; 2510 : int vehInFlight, flightIdx;
; 2511 : 
; 2512 :    if (flightLead && flightLead != self)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	$LN1@AiCheckPos
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+708]
	cmp	eax, DWORD PTR [edx+56]
	je	$LN1@AiCheckPos

; 2513 : 	{
; 2514 : 		// Get wingman slot position relative to the leader
; 2515 : 		vehInFlight		= ((FlightClass*)self->GetCampaignObject())->GetTotalVehicles();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _vehInFlight$[ebp], eax

; 2516 : 		flightIdx		= ((FlightClass*)self->GetCampaignObject())->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2517 : 
; 2518 : 		if(flightIdx == AiFirstWing && vehInFlight == 2)  {

	cmp	DWORD PTR _flightIdx$[ebp], 1
	jne	SHORT $LN10@AiCheckPos
	cmp	DWORD PTR _vehInFlight$[ebp], 2
	jne	SHORT $LN10@AiCheckPos

; 2519 : 			curPosition	= &(acFormationData->twoposData[mFormation]);	// The four ship #2 slot position is copied in to the 2 ship formation array.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	shl	eax, 4
	mov	ecx, DWORD PTR ?acFormationData@@3PAVACFormationData@@A ; acFormationData
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _curPosition$[ebp], eax

; 2520 : 			paircraft	= (AircraftClass*) flightLead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	mov	DWORD PTR _paircraft$[ebp], eax
	jmp	SHORT $LN7@AiCheckPos
$LN10@AiCheckPos:

; 2521 : 		}
; 2522 : 		else if(flightIdx == AiSecondWing && mSplitFlight) {

	cmp	DWORD PTR _flightIdx$[ebp], 3
	jne	SHORT $LN8@AiCheckPos
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+892], 0
	je	SHORT $LN8@AiCheckPos

; 2523 : 	      curPosition = &(acFormationData->twoposData[mFormation]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+808]
	shl	eax, 4
	mov	ecx, DWORD PTR ?acFormationData@@3PAVACFormationData@@A ; acFormationData
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _curPosition$[ebp], eax

; 2524 : 			paircraft	= (AircraftClass*) ((FlightClass*)self->GetCampaignObject())->GetComponentEntity(AiElementLead);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _paircraft$[ebp], eax

; 2525 : 		}
; 2526 : 		else {

	jmp	SHORT $LN7@AiCheckPos
$LN8@AiCheckPos:

; 2527 : 			curPosition = &(acFormationData->positionData[mFormation][flightIdx - 1]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	edx, DWORD PTR ?acFormationData@@3PAVACFormationData@@A ; acFormationData
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _flightIdx$[ebp]
	sub	edx, 1
	shl	edx, 4
	add	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _curPosition$[ebp], edx

; 2528 : 			paircraft	= (AircraftClass*) flightLead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	mov	DWORD PTR _paircraft$[ebp], ecx
$LN7@AiCheckPos:

; 2529 : 		}
; 2530 : 
; 2531 : 	   rangeFactor		= curPosition->range * (2.0F * mFormLateralSpaceFactor);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [edx+904]
	mov	eax, DWORD PTR _curPosition$[ebp]
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _rangeFactor$[ebp], xmm0

; 2532 : 
; 2533 : 		// Get my leader's position
; 2534 : 		ShiAssert(paircraft)
; 2535 : 		if (paircraft)

	cmp	DWORD PTR _paircraft$[ebp], 0
	je	$LN6@AiCheckPos

; 2536 : 		{
; 2537 :       trX	= paircraft->XPos();

	mov	ecx, DWORD PTR _paircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _trX$[ebp]

; 2538 :       trY	= paircraft->YPos();

	mov	ecx, DWORD PTR _paircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _trY$[ebp]

; 2539 :       trZ	= paircraft->ZPos();

	mov	ecx, DWORD PTR _paircraft$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _trZ$[ebp]

; 2540 : 
; 2541 : 			// Calculate position relative to the leader
; 2542 : 			trX	+= rangeFactor * (float)cos(curPosition->relAz * mFormSide + paircraft->af->sigma);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+900]
	mov	edx, DWORD PTR _curPosition$[ebp]
	mulss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _paircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	addss	xmm0, DWORD PTR [ecx+1176]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv351[ebp]
	movss	xmm0, DWORD PTR tv351[ebp]
	mulss	xmm0, DWORD PTR _rangeFactor$[ebp]
	addss	xmm0, DWORD PTR _trX$[ebp]
	movss	DWORD PTR _trX$[ebp], xmm0

; 2543 : 			trY	+= rangeFactor * (float)sin(curPosition->relAz * mFormSide + paircraft->af->sigma);		

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+900]
	mov	eax, DWORD PTR _curPosition$[ebp]
	mulss	xmm0, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _paircraft$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	addss	xmm0, DWORD PTR [edx+1176]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv362[ebp]
	movss	xmm0, DWORD PTR tv362[ebp]
	mulss	xmm0, DWORD PTR _rangeFactor$[ebp]
	addss	xmm0, DWORD PTR _trY$[ebp]
	movss	DWORD PTR _trY$[ebp], xmm0
$LN6@AiCheckPos:

; 2544 : 		}
; 2545 : 
; 2546 : 		if(curPosition->relEl)

	mov	eax, DWORD PTR _curPosition$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@AiCheckPos

; 2547 : 		{
; 2548 : 			trZ	+= rangeFactor * (float)sin(-curPosition->relEl);

	mov	ecx, DWORD PTR _curPosition$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv375[ebp]
	movss	xmm0, DWORD PTR tv375[ebp]
	mulss	xmm0, DWORD PTR _rangeFactor$[ebp]
	addss	xmm0, DWORD PTR _trZ$[ebp]
	movss	DWORD PTR _trZ$[ebp], xmm0

; 2549 : 		}
; 2550 : 		else

	jmp	SHORT $LN4@AiCheckPos
$LN5@AiCheckPos:

; 2551 : 		{
; 2552 : 			trZ += (flightIdx * -100.0F);

	cvtsi2ss xmm0, DWORD PTR _flightIdx$[ebp]
	mulss	xmm0, DWORD PTR __real@c2c80000
	addss	xmm0, DWORD PTR _trZ$[ebp]
	movss	DWORD PTR _trZ$[ebp], xmm0
$LN4@AiCheckPos:

; 2553 : 		}
; 2554 : 
; 2555 : 		xdiff = trX - self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv383[ebp]
	movss	xmm0, DWORD PTR _trX$[ebp]
	subss	xmm0, DWORD PTR tv383[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 2556 : 		ydiff = trY - self->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv389[ebp]
	movss	xmm0, DWORD PTR _trY$[ebp]
	subss	xmm0, DWORD PTR tv389[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 2557 : 		zdiff = trZ - self->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv395[ebp]
	movss	xmm0, DWORD PTR _trZ$[ebp]
	subss	xmm0, DWORD PTR tv395[ebp]
	movss	DWORD PTR _zdiff$[ebp], xmm0

; 2558 : 
; 2559 : 		if((xdiff * xdiff + ydiff + ydiff >  250.0F * 250.0F) || fabs(zdiff) < 250.0F)

	movss	xmm0, DWORD PTR _xdiff$[ebp]
	mulss	xmm0, DWORD PTR _xdiff$[ebp]
	addss	xmm0, DWORD PTR _ydiff$[ebp]
	addss	xmm0, DWORD PTR _ydiff$[ebp]
	comiss	xmm0, DWORD PTR __real@47742400
	ja	SHORT $LN2@AiCheckPos
	push	ecx
	movss	xmm0, DWORD PTR _zdiff$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv403[ebp]
	movss	xmm0, DWORD PTR __real@437a0000
	comiss	xmm0, DWORD PTR tv403[ebp]
	jbe	SHORT $LN3@AiCheckPos
$LN2@AiCheckPos:

; 2560 : 		{
; 2561 : 			mInPositionFlag = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+840], 0

; 2562 : 		}
; 2563 : 		else

	jmp	SHORT $LN1@AiCheckPos
$LN3@AiCheckPos:

; 2564 : 		{
; 2565 : 			mInPositionFlag = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+840], 1
$LN1@AiCheckPos:

; 2566 : 		}
; 2567 : 	}
; 2568 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiCheckPosition@DigitalBrain@@AAEXXZ ENDP		; DigitalBrain::AiCheckPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv323 = -80						; size = 4
tv284 = -76						; size = 4
_vehInFlight$ = -72					; size = 4
tv258 = -68						; size = 4
_flightIdx$ = -64					; size = 4
tv278 = -60						; size = 4
tv294 = -56						; size = 4
tv265 = -52						; size = 4
_zdiff$ = -48						; size = 4
tv272 = -44						; size = 4
_xdiff$ = -40						; size = 4
_maxZDiff$1 = -36					; size = 4
_ydiff$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_trX$ = 8						; size = 4
_trY$ = 12						; size = 4
_trZ$ = 16						; size = 4
?AiCheckInPositionCall@DigitalBrain@@AAEXMMM@Z PROC	; DigitalBrain::AiCheckInPositionCall
; _this$ = ecx

; 2468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2469 : 	short edata[10];
; 2470 : 	float xdiff, ydiff, zdiff;
; 2471 : 	int vehInFlight;
; 2472 : 	int flightIdx;
; 2473 : 
; 2474 : 
; 2475 : 	if(mInPositionFlag == FALSE) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+840], 0
	jne	$LN1@AiCheckInP

; 2476 : 		// 2002-02-12 ADDED BY S.G. If the lead is climbing (or is the player since I can't tell what altitude he wants), be more relax about z
; 2477 : 		float maxZDiff;
; 2478 : 
; 2479 : 		if (g_bPitchLimiterForAI && flightLead && (flightLead->IsSetFlag(MOTION_OWNSHIP) || (((AircraftClass*)flightLead)->DBrain() && fabs(flightLead->ZPos() - ((AircraftClass*)flightLead)->DBrain()->trackZ) > 2000.0f)))

	movzx	ecx, BYTE PTR ?g_bPitchLimiterForAI@@3_NA ; g_bPitchLimiterForAI
	test	ecx, ecx
	je	$LN5@AiCheckInP
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+708], 0
	je	$LN5@AiCheckInP
	push	65536					; 00010000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN4@AiCheckInP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	test	eax, eax
	je	SHORT $LN5@AiCheckInP
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+708]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv258[ebp]
	movss	xmm0, DWORD PTR tv258[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	movss	DWORD PTR tv323[ebp], xmm0
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	movss	xmm0, DWORD PTR tv323[ebp]
	subss	xmm0, DWORD PTR [eax+156]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv265[ebp]
	movss	xmm0, DWORD PTR tv265[ebp]
	comiss	xmm0, DWORD PTR __real@44fa0000
	jbe	SHORT $LN5@AiCheckInP
$LN4@AiCheckInP:

; 2480 : 			maxZDiff = 2000.0f;

	movss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR _maxZDiff$1[ebp], xmm0

; 2481 : 		else

	jmp	SHORT $LN3@AiCheckInP
$LN5@AiCheckInP:

; 2482 : 			maxZDiff = 250.0f;

	movss	xmm0, DWORD PTR __real@437a0000
	movss	DWORD PTR _maxZDiff$1[ebp], xmm0
$LN3@AiCheckInP:

; 2483 : 		// END OF ADDED SECTION 2002-02-12
; 2484 : 
; 2485 : 		xdiff = trX - self->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv272[ebp]
	movss	xmm0, DWORD PTR _trX$[ebp]
	subss	xmm0, DWORD PTR tv272[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 2486 : 		ydiff = trY - self->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv278[ebp]
	movss	xmm0, DWORD PTR _trY$[ebp]
	subss	xmm0, DWORD PTR tv278[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 2487 : 		zdiff = trZ - self->ZPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv284[ebp]
	movss	xmm0, DWORD PTR _trZ$[ebp]
	subss	xmm0, DWORD PTR tv284[ebp]
	movss	DWORD PTR _zdiff$[ebp], xmm0

; 2488 : 			
; 2489 : 		if((xdiff * xdiff + ydiff * ydiff <  250.0F * 250.0F) && fabs(zdiff) < maxZDiff) { // 2002-02-12 MODIFIED BY S.G. It's "ydiff * ydiff" not "ydiff + ydiff"! plus replaced 250.0f for maxZDiff

	movss	xmm0, DWORD PTR _xdiff$[ebp]
	mulss	xmm0, DWORD PTR _xdiff$[ebp]
	movss	xmm1, DWORD PTR _ydiff$[ebp]
	mulss	xmm1, DWORD PTR _ydiff$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@47742400
	comiss	xmm1, xmm0
	jbe	$LN1@AiCheckInP
	push	ecx
	movss	xmm0, DWORD PTR _zdiff$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv294[ebp]
	movss	xmm0, DWORD PTR _maxZDiff$1[ebp]
	comiss	xmm0, DWORD PTR tv294[ebp]
	jbe	$LN1@AiCheckInP

; 2490 : 			mInPositionFlag = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+840], 1

; 2491 : 			edata[0] = self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], ax

; 2492 : 			AiMakeRadioResponse( self, rcINPOSITION, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	99					; 00000063H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2493 : 
; 2494 : 			vehInFlight		= ((FlightClass*)self->GetCampaignObject())->GetTotalVehicles();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	DWORD PTR _vehInFlight$[ebp], eax

; 2495 : 			flightIdx		= ((FlightClass*)self->GetCampaignObject())->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2496 : 			if(flightIdx == AiElementLead && vehInFlight == 4)  {

	cmp	DWORD PTR _flightIdx$[ebp], 2
	jne	SHORT $LN1@AiCheckInP
	cmp	DWORD PTR _vehInFlight$[ebp], 4
	jne	SHORT $LN1@AiCheckInP

; 2497 : 				AiMakeCommandMsg( (SimBaseClass*) self, FalconWingmanMsg::WMGlue, AiWingman, FalconNullId);		

	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	push	0
	push	56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeCommandMsg@@YAXPAVSimBaseClass@@HHVVU_ID@@@Z ; AiMakeCommandMsg
	add	esp, 20					; 00000014H
$LN1@AiCheckInP:

; 2498 : 			}
; 2499 : 		}
; 2500 : 	}
; 2501 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AiCheckInPositionCall@DigitalBrain@@AAEXMMM@Z ENDP	; DigitalBrain::AiCheckInPositionCall
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_response$ = -36					; size = 4
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?AiPromote@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiPromote
; _this$ = ecx

; 2277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2278 : 	//MI for radio response
; 2279 : 	short	edata[10];
; 2280 : 	int	response;
; 2281 : 	int	flightIdx;
; 2282 : 
; 2283 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2284 : 
; 2285 :    if( isWing > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jle	SHORT $LN4@AiPromote

; 2286 :    {
; 2287 :       isWing --;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], edx

; 2288 : 
; 2289 :       if (!isWing)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN2@AiPromote

; 2290 :       {
; 2291 :          SetLead(TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 2292 :       }
; 2293 :       else

	jmp	SHORT $LN1@AiPromote
$LN2@AiPromote:

; 2294 :       {
; 2295 :          SetLead(FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN1@AiPromote:

; 2296 :       }
; 2297 : 	  //MI for radio response
; 2298 : 	  response = rcEXECUTERESPONSE;

	mov	DWORD PTR _response$[ebp], 68		; 00000044H

; 2299 : 	  edata[0]	= flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2300 : 	  edata[1] = 11;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 11					; 0000000bH
	mov	WORD PTR _edata$[ebp+eax], cx

; 2301 : 	  AiMakeRadioResponse( self, response, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN4@AiPromote:

; 2302 :    }
; 2303 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AiPromote@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiPromote
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv1009 = -104						; size = 4
_flightIdx$ = -100					; size = 4
tv1024 = -96						; size = 4
tv1035 = -92						; size = 4
tv1019 = -88						; size = 4
_response$ = -84					; size = 4
_hasWeapons$ = -80					; size = 4
$T1 = -76						; size = 4
_e0$ = -72						; size = 2
_e1$ = -68						; size = 2
_hasHeat$ = -64						; size = 4
_hasAGM$ = -60						; size = 4
_hasHARM$ = -56						; size = 4
_hasLGB$ = -52						; size = 4
_hasRockets$ = -48					; size = 4
_hasRadar$ = -44					; size = 4
_hasBomb$ = -40						; size = 4
_this$ = -36						; size = 4
_sms$ = -32						; size = 4
_hp$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?AiGiveWeaponsStatus@DigitalBrain@@AAEXXZ PROC		; DigitalBrain::AiGiveWeaponsStatus
; _this$ = ecx

; 2121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2122 : 	// what happens if i have multiple weapon types?
; 2123 : 	short	edata[10];
; 2124 : 	int hp;
; 2125 : 	int flightIdx;
; 2126 : 
; 2127 : 	int hasRadar = 0;

	mov	DWORD PTR _hasRadar$[ebp], 0

; 2128 : 	int hasHeat = 0;

	mov	DWORD PTR _hasHeat$[ebp], 0

; 2129 : 	int hasBomb = 0;

	mov	DWORD PTR _hasBomb$[ebp], 0

; 2130 : 	int hasHARM = 0;

	mov	DWORD PTR _hasHARM$[ebp], 0

; 2131 : 	int hasAGM = 0;

	mov	DWORD PTR _hasAGM$[ebp], 0

; 2132 : 	int hasLGB = 0;

	mov	DWORD PTR _hasLGB$[ebp], 0

; 2133 : 	int hasRockets = 0;

	mov	DWORD PTR _hasRockets$[ebp], 0

; 2134 : 	int hasWeapons = 0;

	mov	DWORD PTR _hasWeapons$[ebp], 0

; 2135 : 	int	response;
; 2136 : 
; 2137 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2138 : 
; 2139 : 	short e0 = ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	WORD PTR _e0$[ebp], cx

; 2140 : 	short e1 = (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + flightIdx + 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	eax, BYTE PTR [eax+426]
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4-3]
	mov	WORD PTR _e1$[ebp], dx

; 2141 : 
; 2142 : 
; 2143 : 	// 2001-10-16 M.N. only one time the full callsign
; 2144 : 	edata[0]	= e0;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _e0$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 2145 : 	edata[1]	= e1;

	mov	edx, 2
	shl	edx, 0
	mov	ax, WORD PTR _e1$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 2146 : 	edata[2]	= -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2147 : 	AiMakeRadioResponse( self, rcEXECUTE, edata);

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	67					; 00000043H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2148 : 
; 2149 : 
; 2150 : 	// Do a search for Heaters and Radars
; 2151 : 	SMSClass *sms = (SMSClass*) self->GetSMS();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+464]
	call	edx
	mov	DWORD PTR _sms$[ebp], eax

; 2152 : 
; 2153 : 	if (sms)

	cmp	DWORD PTR _sms$[ebp], 0
	je	$LN26@AiGiveWeap

; 2154 : 	{
; 2155 : 		for (hp=1; hp<sms->NumHardpoints(); hp++)

	mov	DWORD PTR _hp$[ebp], 1
	jmp	SHORT $LN28@AiGiveWeap
$LN27@AiGiveWeap:
	mov	eax, DWORD PTR _hp$[ebp]
	add	eax, 1
	mov	DWORD PTR _hp$[ebp], eax
$LN28@AiGiveWeap:
	mov	ecx, DWORD PTR _sms$[ebp]
	call	?NumHardpoints@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumHardpoints
	cmp	DWORD PTR _hp$[ebp], eax
	jge	$LN26@AiGiveWeap

; 2156 : 		{
; 2157 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtAim120)

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN25@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@AiGiveWeap
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	cmp	eax, 2
	jne	SHORT $LN25@AiGiveWeap

; 2158 : 				hasRadar += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasRadar$[ebp]
	mov	DWORD PTR _hasRadar$[ebp], edx
$LN25@AiGiveWeap:

; 2159 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtAim9)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN24@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN24@AiGiveWeap

; 2160 : 				hasHeat += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasHeat$[ebp]
	mov	DWORD PTR _hasHeat$[ebp], edx
$LN24@AiGiveWeap:

; 2161 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtAgm88)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN23@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 3
	jne	SHORT $LN23@AiGiveWeap

; 2162 : 				hasHARM += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasHARM$[ebp]
	mov	DWORD PTR _hasHARM$[ebp], edx
$LN23@AiGiveWeap:

; 2163 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtAgm65)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN22@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 4
	jne	SHORT $LN22@AiGiveWeap

; 2164 : 				hasAGM += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasAGM$[ebp]
	mov	DWORD PTR _hasAGM$[ebp], edx
$LN22@AiGiveWeap:

; 2165 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtMk82)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN21@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 5
	jne	SHORT $LN21@AiGiveWeap

; 2166 : 				hasBomb += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasBomb$[ebp]
	mov	DWORD PTR _hasBomb$[ebp], edx
$LN21@AiGiveWeap:

; 2167 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtMk84)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN20@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 6
	jne	SHORT $LN20@AiGiveWeap

; 2168 : 				hasBomb += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasBomb$[ebp]
	mov	DWORD PTR _hasBomb$[ebp], edx
$LN20@AiGiveWeap:

; 2169 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtGBU)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN19@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 7
	jne	SHORT $LN19@AiGiveWeap

; 2170 : 				hasLGB += sms->hardPoint[hp]->weaponCount;

	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [ecx+10]
	add	edx, DWORD PTR _hasLGB$[ebp]
	mov	DWORD PTR _hasLGB$[ebp], edx
$LN19@AiGiveWeap:

; 2171 : 			if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtLAU && sms->hardPoint[hp]->GetWeaponClass() == wcRocketWpn)

	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN18@AiGiveWeap
	mov	eax, DWORD PTR _sms$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, 12					; 0000000cH
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+156]
	call	eax
	cmp	eax, 9
	jne	SHORT $LN18@AiGiveWeap
	mov	ecx, DWORD PTR _sms$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _sms$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+164]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN18@AiGiveWeap

; 2172 : 				// hasRockets += sms->hardPoint[hp]->weaponCount;
; 2173 : 				hasRockets++;

	mov	ecx, DWORD PTR _hasRockets$[ebp]
	add	ecx, 1
	mov	DWORD PTR _hasRockets$[ebp], ecx
$LN18@AiGiveWeap:

; 2174 : 			//if (sms->hardPoint[hp] && sms->hardPoint[hp]->weaponPointer && sms->hardPoint[hp]->GetWeaponType() == wtGuns)
; 2175 : 			//	hasGuns = 1;
; 2176 : 		}

	jmp	$LN27@AiGiveWeap
$LN26@AiGiveWeap:

; 2177 : 	}
; 2178 : 	if (hasRadar > 24)

	cmp	DWORD PTR _hasRadar$[ebp], 24		; 00000018H
	jle	SHORT $LN17@AiGiveWeap

; 2179 : 		hasRadar = 24;

	mov	DWORD PTR _hasRadar$[ebp], 24		; 00000018H
$LN17@AiGiveWeap:

; 2180 : 	if (hasHARM > 24)

	cmp	DWORD PTR _hasHARM$[ebp], 24		; 00000018H
	jle	SHORT $LN16@AiGiveWeap

; 2181 : 		hasHARM = 24;

	mov	DWORD PTR _hasHARM$[ebp], 24		; 00000018H
$LN16@AiGiveWeap:

; 2182 : 	if (hasHeat > 24)

	cmp	DWORD PTR _hasHeat$[ebp], 24		; 00000018H
	jle	SHORT $LN15@AiGiveWeap

; 2183 : 		hasHeat = 24;

	mov	DWORD PTR _hasHeat$[ebp], 24		; 00000018H
$LN15@AiGiveWeap:

; 2184 : 	if (hasAGM > 24)

	cmp	DWORD PTR _hasAGM$[ebp], 24		; 00000018H
	jle	SHORT $LN14@AiGiveWeap

; 2185 : 		hasAGM = 24;

	mov	DWORD PTR _hasAGM$[ebp], 24		; 00000018H
$LN14@AiGiveWeap:

; 2186 : 	if (hasBomb > 24)

	cmp	DWORD PTR _hasBomb$[ebp], 24		; 00000018H
	jle	SHORT $LN13@AiGiveWeap

; 2187 : 		hasBomb = 24;

	mov	DWORD PTR _hasBomb$[ebp], 24		; 00000018H
$LN13@AiGiveWeap:

; 2188 : 	if (hasLGB > 24)

	cmp	DWORD PTR _hasLGB$[ebp], 24		; 00000018H
	jle	SHORT $LN12@AiGiveWeap

; 2189 : 		hasLGB = 24;

	mov	DWORD PTR _hasLGB$[ebp], 24		; 00000018H
$LN12@AiGiveWeap:

; 2190 : 	if (hasRockets > 24)

	cmp	DWORD PTR _hasRockets$[ebp], 24		; 00000018H
	jle	SHORT $LN11@AiGiveWeap

; 2191 : 		hasRockets = 24;

	mov	DWORD PTR _hasRockets$[ebp], 24		; 00000018H
$LN11@AiGiveWeap:

; 2192 : 
; 2193 : 	hasWeapons = hasRadar + hasHARM + hasHeat + hasAGM + hasBomb + hasLGB + hasRockets;

	mov	edx, DWORD PTR _hasRadar$[ebp]
	add	edx, DWORD PTR _hasHARM$[ebp]
	add	edx, DWORD PTR _hasHeat$[ebp]
	add	edx, DWORD PTR _hasAGM$[ebp]
	add	edx, DWORD PTR _hasBomb$[ebp]
	add	edx, DWORD PTR _hasLGB$[ebp]
	add	edx, DWORD PTR _hasRockets$[ebp]
	mov	DWORD PTR _hasWeapons$[ebp], edx

; 2194 : 
; 2195 : 	if (hasAGM)

	cmp	DWORD PTR _hasAGM$[ebp], 0
	je	SHORT $LN10@AiGiveWeap

; 2196 : 	{
; 2197 : 		edata[0] = (short)hasAGM--;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _hasAGM$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx
	mov	edx, DWORD PTR _hasAGM$[ebp]
	sub	edx, 1
	mov	DWORD PTR _hasAGM$[ebp], edx

; 2198 : 		edata[1] = 242;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 242				; 000000f2H
	mov	WORD PTR _edata$[ebp+eax], cx

; 2199 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);	// Commsequence changed 01-11-15

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	231					; 000000e7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN10@AiGiveWeap:

; 2200 : 	}
; 2201 : 	
; 2202 : 	if (hasHARM)

	cmp	DWORD PTR _hasHARM$[ebp], 0
	je	SHORT $LN9@AiGiveWeap

; 2203 : 	{
; 2204 : 		edata[0] = (short)hasHARM--;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _hasHARM$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax
	mov	ecx, DWORD PTR _hasHARM$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _hasHARM$[ebp], ecx

; 2205 : 		edata[1] = 245;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 245				; 000000f5H
	mov	WORD PTR _edata$[ebp+edx], ax

; 2206 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	231					; 000000e7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN9@AiGiveWeap:

; 2207 : 	}
; 2208 : 
; 2209 : 	if (hasLGB)

	cmp	DWORD PTR _hasLGB$[ebp], 0
	je	SHORT $LN8@AiGiveWeap

; 2210 : 	{
; 2211 : 		edata[0] = (short)hasLGB--;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _hasLGB$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx
	mov	eax, DWORD PTR _hasLGB$[ebp]
	sub	eax, 1
	mov	DWORD PTR _hasLGB$[ebp], eax

; 2212 : 		edata[1] = 838;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 838				; 00000346H
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2213 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	231					; 000000e7H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN8@AiGiveWeap:

; 2214 : 	}
; 2215 : 
; 2216 : 	if (hasBomb)

	cmp	DWORD PTR _hasBomb$[ebp], 0
	je	SHORT $LN7@AiGiveWeap

; 2217 : 	{
; 2218 : 		edata[0] = (short)hasBomb--;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _hasBomb$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx
	mov	edx, DWORD PTR _hasBomb$[ebp]
	sub	edx, 1
	mov	DWORD PTR _hasBomb$[ebp], edx

; 2219 : 		edata[1] = 914;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 914				; 00000392H
	mov	WORD PTR _edata$[ebp+eax], cx

; 2220 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	231					; 000000e7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN7@AiGiveWeap:

; 2221 : 	}
; 2222 : 
; 2223 : 	if (hasRockets)

	cmp	DWORD PTR _hasRockets$[ebp], 0
	je	SHORT $LN6@AiGiveWeap

; 2224 : 	{
; 2225 : 		edata[0] = (short)hasRockets--;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _hasRockets$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax
	mov	ecx, DWORD PTR _hasRockets$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _hasRockets$[ebp], ecx

; 2226 : 		edata[1] = 887;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 887				; 00000377H
	mov	WORD PTR _edata$[ebp+edx], ax

; 2227 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	231					; 000000e7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN6@AiGiveWeap:

; 2228 : 	}
; 2229 : 
; 2230 : 	if (hasRadar)

	cmp	DWORD PTR _hasRadar$[ebp], 0
	je	SHORT $LN5@AiGiveWeap

; 2231 : 	{
; 2232 : 		edata[0] = (short)hasRadar--;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _hasRadar$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx
	mov	eax, DWORD PTR _hasRadar$[ebp]
	sub	eax, 1
	mov	DWORD PTR _hasRadar$[ebp], eax

; 2233 : 		edata[1] = 231;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 231				; 000000e7H
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2234 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	231					; 000000e7H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN5@AiGiveWeap:

; 2235 : 	}
; 2236 : 
; 2237 : 	if (hasHeat)

	cmp	DWORD PTR _hasHeat$[ebp], 0
	je	SHORT $LN4@AiGiveWeap

; 2238 : 	{
; 2239 : 		edata[0] = (short)hasHeat--;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _hasHeat$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx
	mov	edx, DWORD PTR _hasHeat$[ebp]
	sub	edx, 1
	mov	DWORD PTR _hasHeat$[ebp], edx

; 2240 : 		edata[1] = 233;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 233				; 000000e9H
	mov	WORD PTR _edata$[ebp+eax], cx

; 2241 : 		AiMakeRadioResponse( self, rcWEAPONSCHECKRSP, edata);

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	231					; 000000e7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN4@AiGiveWeap:

; 2242 : 	}	
; 2243 : 
; 2244 : 	if (!hasWeapons)

	cmp	DWORD PTR _hasWeapons$[ebp], 0
	jne	SHORT $LN3@AiGiveWeap

; 2245 : 	{
; 2246 : 		edata[0] = -1;

	mov	edx, 2
	imul	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 2247 : 		edata[1] = 0;	// Winchester

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN32@AiGiveWeap
	jmp	SHORT $LN33@AiGiveWeap
$LN32@AiGiveWeap:
	call	___report_rangecheckfailure
$LN33@AiGiveWeap:
	xor	ecx, ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+edx], cx

; 2248 : 		AiMakeRadioResponse( self, rcWEAPONSLOW, edata);

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	246					; 000000f6H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN3@AiGiveWeap:

; 2249 : 	}
; 2250 : 
; 2251 : 	// Finally say fuel
; 2252 : 
; 2253 : 	edata[0]	= -1;	// Turn off flight position

	mov	eax, 2
	imul	eax, 0
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 2254 : 
; 2255 : 	if(self->af->Fuel() <= self->bingoFuel) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv1009[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm0, DWORD PTR [edx+984]
	comiss	xmm0, DWORD PTR tv1009[ebp]
	jb	SHORT $LN2@AiGiveWeap

; 2256 : 		response = rcGENERALRESPONSEC;

	mov	DWORD PTR _response$[ebp], 83		; 00000053H

; 2257 : 		edata[1] = 4;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	mov	WORD PTR _edata$[ebp+eax], cx

; 2258 : 	}
; 2259 : 	else {

	jmp	SHORT $LN1@AiGiveWeap
$LN2@AiGiveWeap:

; 2260 : 		response = rcFUELCHECKRSP;

	mov	DWORD PTR _response$[ebp], 81		; 00000051H

; 2261 : 		edata[1] = (FloatToInt32(self->af->Fuel() + self->af->ExternalFuel()));// / 1000;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv1019[ebp]
	movss	xmm0, DWORD PTR tv1019[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	movss	DWORD PTR tv1035[ebp], xmm0
	call	?ExternalFuel@AirframeClass@@QAEMXZ	; AirframeClass::ExternalFuel
	fstp	DWORD PTR tv1024[ebp]
	movss	xmm0, DWORD PTR tv1035[ebp]
	addss	xmm0, DWORD PTR tv1024[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax
$LN1@AiGiveWeap:

; 2262 : 	}
; 2263 :   
; 2264 : 	AiMakeRadioResponse( self, response, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN30@AiGiveWeap:

; 2265 : 
; 2266 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AiGiveWeaponsStatus@DigitalBrain@@AAEXXZ ENDP		; DigitalBrain::AiGiveWeaponsStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv162 = -48						; size = 4
tv188 = -44						; size = 4
tv177 = -40						; size = 4
tv172 = -36						; size = 4
_response$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiGiveFuelStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiGiveFuelStatus
; _this$ = ecx

; 2098 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2099 : 	short	edata[10];
; 2100 : 	int	response;
; 2101 : 
; 2102 : 	edata[0]	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	ecx, 2
	imul	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 2103 : 
; 2104 : 	if(self->af->Fuel() <= self->bingoFuel) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv162[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm0, DWORD PTR [edx+984]
	comiss	xmm0, DWORD PTR tv162[ebp]
	jb	SHORT $LN2@AiGiveFuel

; 2105 : 		response = rcGENERALRESPONSEC;

	mov	DWORD PTR _response$[ebp], 83		; 00000053H

; 2106 : 		edata[1] = 4;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	mov	WORD PTR _edata$[ebp+eax], cx

; 2107 : 	}
; 2108 : 	else {

	jmp	SHORT $LN1@AiGiveFuel
$LN2@AiGiveFuel:

; 2109 : 		response = rcFUELCHECKRSP;

	mov	DWORD PTR _response$[ebp], 81		; 00000051H

; 2110 : 		edata[1] = (FloatToInt32(self->af->Fuel() + self->af->ExternalFuel()));// / 1000;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv172[ebp]
	movss	xmm0, DWORD PTR tv172[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+932]
	movss	DWORD PTR tv188[ebp], xmm0
	call	?ExternalFuel@AirframeClass@@QAEMXZ	; AirframeClass::ExternalFuel
	fstp	DWORD PTR tv177[ebp]
	movss	xmm0, DWORD PTR tv188[ebp]
	addss	xmm0, DWORD PTR tv177[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax
$LN1@AiGiveFuel:

; 2111 : 	}
; 2112 :   
; 2113 : 	AiMakeRadioResponse( self, response, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2114 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiGiveFuelStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiGiveFuelStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -120						; size = 4
$T2 = -116						; size = 4
_count$ = -112						; size = 4
_i$ = -108						; size = 4
_this$ = -104						; size = 4
_lastFault$ = -100					; size = 4
_pFaultList$ = -96					; size = 72
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiGiveDamageReport@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiGiveDamageReport
; _this$ = ecx

; 1957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1958 : 	short	edata[10];
; 1959 : 	int	lastFault = 0;

	mov	DWORD PTR _lastFault$[ebp], 0

; 1960 : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1961 : 	int	i;
; 1962 : 	typedef struct {
; 1963 : 				FaultClass::type_FSubSystem	subSystem;
; 1964 : 				int									status;
; 1965 : 				} DamageEntry;
; 1966 : 
; 1967 : 	DamageEntry	pFaultList[DAMAGELIST] = {{FaultClass::eng_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp], 8
	mov	DWORD PTR _pFaultList$[ebp+4], 0

; 1968 : 									{FaultClass::fcr_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+8], 12	; 0000000cH
	mov	DWORD PTR _pFaultList$[ebp+12], 0

; 1969 : 									{FaultClass::flcs_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+16], 13	; 0000000dH
	mov	DWORD PTR _pFaultList$[ebp+20], 0

; 1970 : 									{FaultClass::sms_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+24], 26	; 0000001aH
	mov	DWORD PTR _pFaultList$[ebp+28], 0

; 1971 : 									{FaultClass::ins_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+32], 20	; 00000014H
	mov	DWORD PTR _pFaultList$[ebp+36], 0

; 1972 : 									{FaultClass::rwr_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+40], 25	; 00000019H
	mov	DWORD PTR _pFaultList$[ebp+44], 0

; 1973 : 									{FaultClass::tcn_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+48], 27	; 0000001bH
	mov	DWORD PTR _pFaultList$[ebp+52], 0

; 1974 : 									{FaultClass::ufc_fault, FALSE},

	mov	DWORD PTR _pFaultList$[ebp+56], 28	; 0000001cH
	mov	DWORD PTR _pFaultList$[ebp+60], 0

; 1975 : 									{FaultClass::amux_fault, FALSE}};

	mov	DWORD PTR _pFaultList$[ebp+64], 0
	mov	DWORD PTR _pFaultList$[ebp+68], 0

; 1976 : 
; 1977 : 	edata[0]		= self->GetCampaignObject()->GetComponentIndex(self);			// Get my slot in the flight

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	ecx, 2
	imul	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1978 : 	count			= ((AircraftClass*) self)->mFaults->GetFFaultCount();			// Check how many faults are set

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFFaultCount@FackClass@@QAEHXZ	; FackClass::GetFFaultCount
	mov	DWORD PTR _count$[ebp], eax

; 1979 : 
; 1980 : 	if(count == 0) {																			// If is no damage, say a-okay

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN45@AiGiveDama

; 1981 : 		edata[1] = 3;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 3
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1982 : 		AiMakeRadioResponse( self, rcGENERALRESPONSEC, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	83					; 00000053H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1983 : 		return;

	jmp	$LN47@AiGiveDama
$LN45@AiGiveDama:

; 1984 : 	}
; 1985 : 
; 1986 : 	i = count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _i$[ebp], eax
$LN44@AiGiveDama:

; 1987 : 
; 1988 : 	while(lastFault < DAMAGELIST) {

	cmp	DWORD PTR _lastFault$[ebp], 9
	jge	$LN43@AiGiveDama

; 1989 : 
; 1990 : 		if(((AircraftClass*) self)->mFaults->GetFault(pFaultList[lastFault].subSystem) == TRUE) {

	mov	ecx, DWORD PTR _lastFault$[ebp]
	mov	edx, DWORD PTR _pFaultList$[ebp+ecx*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	cmp	eax, 1
	jne	$LN42@AiGiveDama

; 1991 : 
; 1992 : 			pFaultList[lastFault].status = TRUE;

	mov	edx, DWORD PTR _lastFault$[ebp]
	mov	DWORD PTR _pFaultList$[ebp+edx*8+4], 1

; 1993 : 
; 1994 : 			if(pFaultList[lastFault].subSystem == FaultClass::eng_fault) {	// Evaluate each system

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8], 8
	jne	SHORT $LN41@AiGiveDama

; 1995 : 				edata[1] = 0;

	mov	DWORD PTR $T2[ebp], 2
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN48@AiGiveDama
	jmp	SHORT $LN49@AiGiveDama
$LN48@AiGiveDama:
	call	___report_rangecheckfailure
$LN49@AiGiveDama:
	xor	ecx, ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+edx], cx

; 1996 : 				edata[2] = 4;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 4
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	$LN40@AiGiveDama
$LN41@AiGiveDama:

; 1997 : 			}
; 1998 : 			else if(pFaultList[lastFault].subSystem == FaultClass::fcr_fault) {

	mov	edx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+edx*8], 12	; 0000000cH
	jne	SHORT $LN39@AiGiveDama

; 1999 : 				edata[1] = 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx

; 2000 : 				edata[2] = 1;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax
	jmp	$LN40@AiGiveDama
$LN39@AiGiveDama:

; 2001 : 			}
; 2002 : 			else if(pFaultList[lastFault].subSystem == FaultClass::flcs_fault) {

	mov	ecx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+ecx*8], 13	; 0000000dH
	jne	SHORT $LN37@AiGiveDama

; 2003 : 				edata[1] = 2;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax

; 2004 : 				edata[2] = 2;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	$LN40@AiGiveDama
$LN37@AiGiveDama:

; 2005 : 			}
; 2006 : 			else if(pFaultList[lastFault].subSystem == FaultClass::sms_fault) {

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8], 26	; 0000001aH
	jne	SHORT $LN35@AiGiveDama

; 2007 : 				edata[1] = 3;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 3
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2008 : 				edata[2] = 2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	$LN40@AiGiveDama
$LN35@AiGiveDama:

; 2009 : 			}
; 2010 : 			else if(pFaultList[lastFault].subSystem == FaultClass::ins_fault) {

	mov	edx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+edx*8], 20	; 00000014H
	jne	SHORT $LN33@AiGiveDama

; 2011 : 				edata[1] = 4;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	mov	WORD PTR _edata$[ebp+eax], cx

; 2012 : 				edata[2] = 1;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax
	jmp	$LN40@AiGiveDama
$LN33@AiGiveDama:

; 2013 : 			}
; 2014 : 			else if(pFaultList[lastFault].subSystem == FaultClass::rwr_fault) {

	mov	ecx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+ecx*8], 25	; 00000019H
	jne	SHORT $LN31@AiGiveDama

; 2015 : 				edata[1] = 5;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 5
	mov	WORD PTR _edata$[ebp+edx], ax

; 2016 : 				edata[2] = 2;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	$LN40@AiGiveDama
$LN31@AiGiveDama:

; 2017 : 			}
; 2018 : 			else if(pFaultList[lastFault].subSystem == FaultClass::tcn_fault) {

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8], 27	; 0000001bH
	jne	SHORT $LN29@AiGiveDama

; 2019 : 				edata[1] = 6;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 6
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2020 : 				edata[2] = 1;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	SHORT $LN40@AiGiveDama
$LN29@AiGiveDama:

; 2021 : 			}
; 2022 : 			else if(pFaultList[lastFault].subSystem == FaultClass::ufc_fault) {

	mov	edx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+edx*8], 28	; 0000001cH
	jne	SHORT $LN27@AiGiveDama

; 2023 : 				edata[1] = 7;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 7
	mov	WORD PTR _edata$[ebp+eax], cx

; 2024 : 				edata[2] = 2;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax
	jmp	SHORT $LN40@AiGiveDama
$LN27@AiGiveDama:

; 2025 : 			}
; 2026 : 			else if(pFaultList[lastFault].subSystem == FaultClass::amux_fault) {

	mov	ecx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+ecx*8], 0
	jne	SHORT $LN40@AiGiveDama

; 2027 : 				edata[1] = 8;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 8
	mov	WORD PTR _edata$[ebp+edx], ax

; 2028 : 				edata[2] = 1;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx
$LN40@AiGiveDama:

; 2029 : 			}
; 2030 : 
; 2031 : 			if(i != count) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	je	SHORT $LN24@AiGiveDama

; 2032 : 				edata[0] = -1;

	mov	ecx, 2
	imul	ecx, 0
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx
$LN24@AiGiveDama:

; 2033 : 			}
; 2034 : 
; 2035 : 			AiMakeRadioResponse( self, rcDAMREPORT, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2036 : 			i--;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN42@AiGiveDama:

; 2037 : 		}
; 2038 : 		lastFault++;

	mov	ecx, DWORD PTR _lastFault$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lastFault$[ebp], ecx

; 2039 : 	}

	jmp	$LN44@AiGiveDama
$LN43@AiGiveDama:

; 2040 : 
; 2041 : 	edata[0] = -1;

	mov	edx, 2
	imul	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 2042 : 	
; 2043 : 	if(i > 0) {

	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN47@AiGiveDama

; 2044 : 		for(lastFault = 0; lastFault < DAMAGELIST; lastFault++, i--) {

	mov	DWORD PTR _lastFault$[ebp], 0
	jmp	SHORT $LN22@AiGiveDama
$LN21@AiGiveDama:
	mov	ecx, DWORD PTR _lastFault$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lastFault$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN22@AiGiveDama:
	cmp	DWORD PTR _lastFault$[ebp], 9
	jge	$LN47@AiGiveDama

; 2045 : 
; 2046 : 			if(pFaultList[lastFault].status == FALSE) {

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8+4], 0
	jne	$LN19@AiGiveDama

; 2047 : 
; 2048 : 				if(pFaultList[lastFault].subSystem == FaultClass::eng_fault) {	// Evaluate each system

	mov	ecx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+ecx*8], 8
	jne	SHORT $LN18@AiGiveDama

; 2049 : 					edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN50@AiGiveDama
	jmp	SHORT $LN51@AiGiveDama
$LN50@AiGiveDama:
	call	___report_rangecheckfailure
$LN51@AiGiveDama:
	xor	edx, edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx

; 2050 : 					edata[2] = 4;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 4
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	$LN19@AiGiveDama
$LN18@AiGiveDama:

; 2051 : 				}
; 2052 : 				else if(pFaultList[lastFault].subSystem == FaultClass::fcr_fault) {

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8], 12	; 0000000cH
	jne	SHORT $LN16@AiGiveDama

; 2053 : 					edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2054 : 					edata[2] = 1;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	$LN19@AiGiveDama
$LN16@AiGiveDama:

; 2055 : 				}
; 2056 : 				else if(pFaultList[lastFault].subSystem == FaultClass::flcs_fault) {

	mov	edx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+edx*8], 13	; 0000000dH
	jne	SHORT $LN14@AiGiveDama

; 2057 : 					edata[1] = 2;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx

; 2058 : 					edata[2] = 2;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax
	jmp	$LN19@AiGiveDama
$LN14@AiGiveDama:

; 2059 : 				}
; 2060 : 				else if(pFaultList[lastFault].subSystem == FaultClass::sms_fault) {

	mov	ecx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+ecx*8], 26	; 0000001aH
	jne	SHORT $LN12@AiGiveDama

; 2061 : 					edata[1] = 3;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 3
	mov	WORD PTR _edata$[ebp+edx], ax

; 2062 : 					edata[2] = 2;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	$LN19@AiGiveDama
$LN12@AiGiveDama:

; 2063 : 				}
; 2064 : 				else if(pFaultList[lastFault].subSystem == FaultClass::ins_fault) {

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8], 20	; 00000014H
	jne	SHORT $LN10@AiGiveDama

; 2065 : 					edata[1] = 4;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2066 : 					edata[2] = 1;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	$LN19@AiGiveDama
$LN10@AiGiveDama:

; 2067 : 				}
; 2068 : 				else if(pFaultList[lastFault].subSystem == FaultClass::rwr_fault) {

	mov	edx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+edx*8], 25	; 00000019H
	jne	SHORT $LN8@AiGiveDama

; 2069 : 					edata[1] = 5;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 5
	mov	WORD PTR _edata$[ebp+eax], cx

; 2070 : 					edata[2] = 2;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax
	jmp	$LN19@AiGiveDama
$LN8@AiGiveDama:

; 2071 : 				}
; 2072 : 				else if(pFaultList[lastFault].subSystem == FaultClass::tcn_fault) {

	mov	ecx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+ecx*8], 27	; 0000001bH
	jne	SHORT $LN6@AiGiveDama

; 2073 : 					edata[1] = 6;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 6
	mov	WORD PTR _edata$[ebp+edx], ax

; 2074 : 					edata[2] = 1;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	SHORT $LN19@AiGiveDama
$LN6@AiGiveDama:

; 2075 : 				}
; 2076 : 				else if(pFaultList[lastFault].subSystem == FaultClass::ufc_fault) {

	mov	eax, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+eax*8], 28	; 0000001cH
	jne	SHORT $LN4@AiGiveDama

; 2077 : 					edata[1] = 7;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 7
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2078 : 					edata[2] = 2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	SHORT $LN19@AiGiveDama
$LN4@AiGiveDama:

; 2079 : 				}
; 2080 : 				else if(pFaultList[lastFault].subSystem == FaultClass::amux_fault) {

	mov	edx, DWORD PTR _lastFault$[ebp]
	cmp	DWORD PTR _pFaultList$[ebp+edx*8], 0
	jne	SHORT $LN19@AiGiveDama

; 2081 : 					edata[1] = 8;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 8
	mov	WORD PTR _edata$[ebp+eax], cx

; 2082 : 					edata[2] = 1;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax
$LN19@AiGiveDama:

; 2083 : 				}
; 2084 : 			}
; 2085 : 
; 2086 : 			if(i > 0) {

	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN1@AiGiveDama

; 2087 : 				AiMakeRadioResponse( self, rcDAMREPORT, edata );	

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	46					; 0000002eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN1@AiGiveDama:

; 2088 : 			}
; 2089 : 		}

	jmp	$LN21@AiGiveDama
$LN47@AiGiveDama:

; 2090 : 	}
; 2091 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiGiveDamageReport@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiGiveDamageReport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv919 = -168						; size = 4
tv779 = -164						; size = 4
_random$ = -160						; size = 4
tv925 = -156						; size = 4
tv881 = -152						; size = 4
tv660 = -148						; size = 4
tv931 = -144						; size = 4
tv783 = -140						; size = 4
tv877 = -136						; size = 4
tv921 = -132						; size = 4
tv857 = -128						; size = 4
tv792 = -124						; size = 4
tv848 = -120						; size = 4
tv788 = -116						; size = 4
tv929 = -112						; size = 4
tv923 = -108						; size = 4
tv844 = -104						; size = 4
tv656 = -100						; size = 4
tv840 = -96						; size = 4
tv665 = -92						; size = 4
tv927 = -88						; size = 4
tv836 = -84						; size = 4
tv669 = -80						; size = 4
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_angle$ = -68						; size = 4
tv342 = -64						; size = 4
_pfrom$ = -60						; size = 4
_navangle$ = -56					; size = 4
_rz$ = -52						; size = 4
_flightIdx$ = -48					; size = 4
_xdiff$ = -44						; size = 4
_ydiff$ = -40						; size = 4
_response$ = -36					; size = 4
_this$ = -32						; size = 4
_pmytarget$ = -28					; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiGiveStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiGiveStatus
; _this$ = ecx

; 1790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1791 : 	short edata[10];
; 1792 : 	int	response;
; 1793 : 	int	random;
; 1794 : 	float	xdiff;
; 1795 : 	float ydiff;
; 1796 : 	float rz;
; 1797 : 	int	flightIdx;
; 1798 : 	FalconEntity* pmytarget = NULL;

	mov	DWORD PTR _pmytarget$[ebp], 0

; 1799 : 	AircraftClass* pfrom;
; 1800 : 	float	angle;
; 1801 : 	int	navangle;
; 1802 : 
; 1803 : 	if(targetPtr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN39@AiGiveStat

; 1804 : 		pmytarget = targetPtr->BaseData();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR _pmytarget$[ebp], eax
$LN39@AiGiveStat:

; 1805 : 	}
; 1806 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1807 : 
; 1808 : 	if((curMode == GunsJinkMode || curMode == MissileDefeatMode) && pmytarget && (pmytarget->IsAirplane() || pmytarget->IsHelicopter())) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 3
	je	SHORT $LN37@AiGiveStat
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 4
	jne	$LN38@AiGiveStat
$LN37@AiGiveStat:
	cmp	DWORD PTR _pmytarget$[ebp], 0
	je	$LN38@AiGiveStat
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	jne	SHORT $LN36@AiGiveStat
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	test	eax, eax
	je	$LN38@AiGiveStat
$LN36@AiGiveStat:

; 1809 : 		
; 1810 : 		xdiff = self->XPos() - pmytarget->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv656[ebp]
	movss	xmm0, DWORD PTR tv656[ebp]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	movss	DWORD PTR tv919[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv660[ebp]
	movss	xmm0, DWORD PTR tv919[ebp]
	subss	xmm0, DWORD PTR tv660[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 1811 : 		ydiff = self->YPos() - pmytarget->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv665[ebp]
	movss	xmm0, DWORD PTR tv665[ebp]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	movss	DWORD PTR tv921[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv669[ebp]
	movss	xmm0, DWORD PTR tv921[ebp]
	subss	xmm0, DWORD PTR tv669[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 1812 : 
; 1813 : 		if(xdiff * xdiff + ydiff * ydiff > NM_TO_FT * NM_TO_FT) {

	movss	xmm0, DWORD PTR _xdiff$[ebp]
	mulss	xmm0, DWORD PTR _xdiff$[ebp]
	movss	xmm1, DWORD PTR _ydiff$[ebp]
	mulss	xmm1, DWORD PTR _ydiff$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@4c0cd705
	jbe	$LN35@AiGiveStat

; 1814 : 			if(PlayerOptions.BullseyeOn()) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?BullseyeOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::BullseyeOn
	test	eax, eax
	je	SHORT $LN34@AiGiveStat

; 1815 : 				response = rcENGDEFENSIVEA;

	mov	DWORD PTR _response$[ebp], 64		; 00000040H

; 1816 : 			}
; 1817 : 			else {

	jmp	SHORT $LN33@AiGiveStat
$LN34@AiGiveStat:

; 1818 : 				response = rcENGDEFENSIVEB;

	mov	DWORD PTR _response$[ebp], 65		; 00000041H
$LN33@AiGiveStat:

; 1819 : 			}
; 1820 : 			edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1821 : 			edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + flightIdx + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	ecx, BYTE PTR [eax+426]
	mov	edx, DWORD PTR _flightIdx$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4-3]
	mov	ecx, 2
	shl	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1822 : 			edata[2] = (short) SimToGrid(pmytarget->YPos());

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	edx, 2
	shl	edx, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1823 : 			edata[3] = (short) SimToGrid(pmytarget->XPos());

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	ecx, 2
	imul	ecx, 3
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1824 : 			edata[4] = (short) pmytarget->ZPos();

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	call	__ftol2_sse
	mov	edx, 2
	shl	edx, 2
	mov	WORD PTR _edata$[ebp+edx], ax

; 1825 : 		}
; 1826 : 		else {

	jmp	SHORT $LN32@AiGiveStat
$LN35@AiGiveStat:

; 1827 : 			edata[0]	= flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 1828 : 			response = rcENGDEFENSIVEC;

	mov	DWORD PTR _response$[ebp], 66		; 00000042H
$LN32@AiGiveStat:

; 1829 : 		}

	jmp	$LN1@AiGiveStat
$LN38@AiGiveStat:

; 1830 : 	}
; 1831 : 	else if(pmytarget && (pmytarget->IsAirplane() || pmytarget->IsHelicopter())) {

	cmp	DWORD PTR _pmytarget$[ebp], 0
	je	$LN30@AiGiveStat
	mov	edx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	jne	SHORT $LN29@AiGiveStat
	mov	eax, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	test	eax, eax
	je	$LN30@AiGiveStat
$LN29@AiGiveStat:

; 1832 : 
; 1833 : 		edata[0]	= -1;

	mov	ecx, 2
	imul	ecx, 0
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1834 : 		edata[1]	= -1;

	mov	eax, 2
	shl	eax, 0
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1835 : 		edata[2]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	ax, BYTE PTR [eax+425]
	mov	ecx, 2
	shl	ecx, 1
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1836 : 		edata[3]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + flightIdx + 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	eax, BYTE PTR [eax+426]
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4-3]
	mov	eax, 2
	imul	eax, 3
	mov	WORD PTR _edata$[ebp+eax], dx

; 1837 : 		edata[4] = (short) SimToGrid(pmytarget->YPos());

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 2
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1838 : 		edata[5] = (short) SimToGrid(pmytarget->XPos());

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	edx, 2
	imul	edx, 5
	mov	WORD PTR _edata$[ebp+edx], ax

; 1839 : 		edata[6] = (short) pmytarget->ZPos();

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	call	__ftol2_sse
	mov	ecx, 2
	imul	ecx, 6
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1840 : 			
; 1841 : 		response = rcAIRTARGETBRA;

	mov	DWORD PTR _response$[ebp], 13		; 0000000dH
	jmp	$LN1@AiGiveStat
$LN30@AiGiveStat:

; 1842 : 
; 1843 : 		// rcBANDIT
; 1844 : 	}
; 1845 : 	else if(mpActionFlags[AI_EXECUTE_MANEUVER]/* == TRUE *//* 2002-03-15 REMOVED BY S.G. Can be TRUE or TRUE+1 now */) {

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+760], 0
	je	$LN27@AiGiveStat

; 1846 : 
; 1847 : 		edata[0] = self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	ecx, 2
	imul	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1848 : 		
; 1849 : 		switch(mCurrentManeuver) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+796]
	mov	DWORD PTR tv342[ebp], eax
	mov	ecx, DWORD PTR tv342[ebp]
	sub	ecx, 19					; 00000013H
	mov	DWORD PTR tv342[ebp], ecx
	cmp	DWORD PTR tv342[ebp], 25		; 00000019H
	ja	SHORT $LN25@AiGiveStat
	mov	edx, DWORD PTR tv342[ebp]
	movzx	eax, BYTE PTR $LN46@AiGiveStat[edx]
	jmp	DWORD PTR $LN47@AiGiveStat[eax*4]
$LN24@AiGiveStat:

; 1850 : 
; 1851 : 		case FalconWingmanMsg::WMChainsaw:
; 1852 : 			edata[1] = 6;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 6
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1853 : 			break;

	jmp	SHORT $LN25@AiGiveStat
$LN23@AiGiveStat:

; 1854 : 
; 1855 : 		case FalconWingmanMsg::WMPince:
; 1856 : 			edata[1] = 4;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	mov	WORD PTR _edata$[ebp+eax], cx

; 1857 : 			break;

	jmp	SHORT $LN25@AiGiveStat
$LN22@AiGiveStat:

; 1858 : 
; 1859 : 		case FalconWingmanMsg::WMPosthole:
; 1860 : 			edata[1] = 5;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 5
	mov	WORD PTR _edata$[ebp+edx], ax

; 1861 : 			break;

	jmp	SHORT $LN25@AiGiveStat
$LN21@AiGiveStat:

; 1862 : 
; 1863 : 		case FalconWingmanMsg::WMFlex:
; 1864 : 		case FalconWingmanMsg::WMSkate:
; 1865 : 		case FalconWingmanMsg::WMSSOffset:
; 1866 : 			edata[1] = 8;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 8
	mov	WORD PTR _edata$[ebp+ecx], dx
$LN25@AiGiveStat:

; 1867 : 			break;
; 1868 : 		}
; 1869 : 		// status = performing maneuver
; 1870 : 		response = rcEXECUTERESPONSE;

	mov	DWORD PTR _response$[ebp], 68		; 00000044H

; 1871 : 	}
; 1872 : 	else if((curMode == GunsEngageMode || 

	jmp	$LN1@AiGiveStat
$LN27@AiGiveStat:

; 1873 :            curMode == MissileEngageMode || 
; 1874 :            curMode == WVREngageMode ||
; 1875 :            curMode == BVREngageMode) && pmytarget && (pmytarget->IsAirplane() || pmytarget->IsHelicopter()))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 12			; 0000000cH
	je	SHORT $LN18@AiGiveStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN18@AiGiveStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 15			; 0000000fH
	je	SHORT $LN18@AiGiveStat
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 16			; 00000010H
	jne	$LN19@AiGiveStat
$LN18@AiGiveStat:
	cmp	DWORD PTR _pmytarget$[ebp], 0
	je	$LN19@AiGiveStat
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	jne	SHORT $LN17@AiGiveStat
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	test	eax, eax
	je	$LN19@AiGiveStat
$LN17@AiGiveStat:

; 1876 : 	{
; 1877 : 		xdiff = self->XPos() - pmytarget->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv779[ebp]
	movss	xmm0, DWORD PTR tv779[ebp]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	movss	DWORD PTR tv923[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv783[ebp]
	movss	xmm0, DWORD PTR tv923[ebp]
	subss	xmm0, DWORD PTR tv783[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 1878 : 		ydiff = self->YPos() - pmytarget->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv788[ebp]
	movss	xmm0, DWORD PTR tv788[ebp]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	movss	DWORD PTR tv925[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv792[ebp]
	movss	xmm0, DWORD PTR tv925[ebp]
	subss	xmm0, DWORD PTR tv792[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 1879 : 
; 1880 : 		if(xdiff * xdiff + ydiff * ydiff > NM_TO_FT * NM_TO_FT) {

	movss	xmm0, DWORD PTR _xdiff$[ebp]
	mulss	xmm0, DWORD PTR _xdiff$[ebp]
	movss	xmm1, DWORD PTR _ydiff$[ebp]
	mulss	xmm1, DWORD PTR _ydiff$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@4c0cd705
	jbe	$LN16@AiGiveStat

; 1881 : 			if(PlayerOptions.BullseyeOn()) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?BullseyeOn@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::BullseyeOn
	test	eax, eax
	je	SHORT $LN15@AiGiveStat

; 1882 : 				response = rcENGAGINGA;

	mov	DWORD PTR _response$[ebp], 61		; 0000003dH

; 1883 : 			}
; 1884 : 			else {

	jmp	SHORT $LN14@AiGiveStat
$LN15@AiGiveStat:

; 1885 : 				response = rcENGAGINGB;

	mov	DWORD PTR _response$[ebp], 62		; 0000003eH
$LN14@AiGiveStat:

; 1886 : 			}
; 1887 : 			edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1888 : 			edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + flightIdx + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	ecx, BYTE PTR [eax+426]
	mov	edx, DWORD PTR _flightIdx$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4-3]
	mov	ecx, 2
	shl	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1889 : 			edata[2] = 2 * (pmytarget->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	edx, ax
	lea	eax, DWORD PTR [edx+edx-200]
	mov	ecx, 2
	shl	ecx, 1
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1890 : 			edata[3] = (short) SimToGrid(pmytarget->YPos());

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	edx, 2
	imul	edx, 3
	mov	WORD PTR _edata$[ebp+edx], ax

; 1891 : 			edata[4] = (short) SimToGrid(pmytarget->XPos());

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 2
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1892 : 			edata[5] = (short) pmytarget->ZPos();

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	call	__ftol2_sse
	mov	edx, 2
	imul	edx, 5
	mov	WORD PTR _edata$[ebp+edx], ax

; 1893 : 		}
; 1894 : 		else {

	jmp	$LN13@AiGiveStat
$LN16@AiGiveStat:

; 1895 : 			pfrom		= (AircraftClass*) vuDatabase->Find(msg->dataBlock.from);

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _pfrom$[ebp], eax

; 1896 : 			edata[0]	= 2 * (pmytarget->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	lea	ecx, DWORD PTR [eax+eax-200]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1897 : 
; 1898 : 			xdiff = pmytarget->XPos() - pfrom->XPos();

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv836[ebp]
	movss	xmm0, DWORD PTR tv836[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv927[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv840[ebp]
	movss	xmm0, DWORD PTR tv927[ebp]
	subss	xmm0, DWORD PTR tv840[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 1899 : 			ydiff = pmytarget->YPos() - pfrom->YPos();

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv844[ebp]
	movss	xmm0, DWORD PTR tv844[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv929[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv848[ebp]
	movss	xmm0, DWORD PTR tv929[ebp]
	subss	xmm0, DWORD PTR tv848[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 1900 : 
; 1901 : 			angle = (float)atan2(ydiff, xdiff);

	cvtss2sd xmm0, DWORD PTR _xdiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ydiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _angle$[ebp]

; 1902 : 			angle = angle - pfrom->Yaw();

	mov	ecx, DWORD PTR _pfrom$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv857[ebp]
	movss	xmm0, DWORD PTR _angle$[ebp]
	subss	xmm0, DWORD PTR tv857[ebp]
	movss	DWORD PTR _angle$[ebp], xmm0

; 1903 : 			navangle	=  FloatToInt32 (RTD * angle);

	movss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR _angle$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _navangle$[ebp], eax

; 1904 : 			if(navangle < 0) {

	cmp	DWORD PTR _navangle$[ebp], 0
	jge	SHORT $LN12@AiGiveStat

; 1905 : 				navangle = 360 + navangle;

	mov	eax, DWORD PTR _navangle$[ebp]
	add	eax, 360				; 00000168H
	mov	DWORD PTR _navangle$[ebp], eax
$LN12@AiGiveStat:

; 1906 : 			}
; 1907 : 
; 1908 : 			edata[1] = navangle / 30;									// scale compass angle for radio eData

	mov	eax, DWORD PTR _navangle$[ebp]
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], ax

; 1909 : 			if(edata[1] >= 12) {

	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR _edata$[ebp+eax]
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LN11@AiGiveStat

; 1910 : 				edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN42@AiGiveStat
	jmp	SHORT $LN43@AiGiveStat
$LN42@AiGiveStat:
	call	___report_rangecheckfailure
$LN43@AiGiveStat:
	xor	edx, edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN11@AiGiveStat:

; 1911 : 			}
; 1912 : 
; 1913 : 			rz = pmytarget->ZPos() - pfrom->ZPos();

	mov	ecx, DWORD PTR _pmytarget$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv877[ebp]
	movss	xmm0, DWORD PTR tv877[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv931[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv881[ebp]
	movss	xmm0, DWORD PTR tv931[ebp]
	subss	xmm0, DWORD PTR tv881[ebp]
	movss	DWORD PTR _rz$[ebp], xmm0

; 1914 : 
; 1915 : 			if(rz < 300.0F && rz > -300.0F) {							// check relative alt and select correct frag

	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN10@AiGiveStat
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c3960000
	jbe	SHORT $LN10@AiGiveStat

; 1916 : 				edata[2] = 1;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	SHORT $LN5@AiGiveStat
$LN10@AiGiveStat:

; 1917 : 			}
; 1918 : 			else if(rz < -300.0F && rz > -1000.0F) {

	movss	xmm0, DWORD PTR __real@c3960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN8@AiGiveStat
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c47a0000
	jbe	SHORT $LN8@AiGiveStat

; 1919 : 				edata[2] = 2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	SHORT $LN5@AiGiveStat
$LN8@AiGiveStat:

; 1920 : 			}	
; 1921 : 			else if(rz < -1000.0F) {

	movss	xmm0, DWORD PTR __real@c47a0000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN6@AiGiveStat

; 1922 : 				edata[2] = 3;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 3
	mov	WORD PTR _edata$[ebp+edx], ax

; 1923 : 			}
; 1924 : 			else {

	jmp	SHORT $LN5@AiGiveStat
$LN6@AiGiveStat:

; 1925 : 				edata[2] = 0;

	mov	ecx, 2
	shl	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN44@AiGiveStat
	jmp	SHORT $LN45@AiGiveStat
$LN44@AiGiveStat:
	call	___report_rangecheckfailure
$LN45@AiGiveStat:
	xor	edx, edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN5@AiGiveStat:

; 1926 : 			}
; 1927 : 			response = rcENGAGINGC;

	mov	DWORD PTR _response$[ebp], 63		; 0000003fH
$LN13@AiGiveStat:

; 1928 : 		}		

	jmp	$LN1@AiGiveStat
$LN19@AiGiveStat:

; 1929 : 	}
; 1930 : 	else if(pmytarget && (pmytarget->IsAirplane() || pmytarget->IsHelicopter())) {

	cmp	DWORD PTR _pmytarget$[ebp], 0
	je	SHORT $LN3@AiGiveStat
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@AiGiveStat
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pmytarget$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	test	eax, eax
	je	SHORT $LN3@AiGiveStat
$LN2@AiGiveStat:

; 1931 : 		// and i am spiked
; 1932 : 		response =  rcSPIKE;

	mov	DWORD PTR _response$[ebp], 192		; 000000c0H

; 1933 : 	}
; 1934 : //	else if(have stuff on radar) {
; 1935 : //		response = rcPICTUREBRA;
; 1936 : //	}
; 1937 : 	else {

	jmp	SHORT $LN1@AiGiveStat
$LN3@AiGiveStat:

; 1938 : 		// status = clean, clear & naked
; 1939 : 		random = 4 * (FloatToInt32 ((float) rand() / (float) RAND_MAX));

	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	shl	eax, 2
	mov	DWORD PTR _random$[ebp], eax

; 1940 : 
; 1941 : 		edata[0] = flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1942 : 		edata[1] = random;

	mov	eax, 2
	shl	eax, 0
	mov	cx, WORD PTR _random$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 1943 : 
; 1944 : 		response = rcGENERALRESPONSEC;

	mov	DWORD PTR _response$[ebp], 83		; 00000053H
$LN1@AiGiveStat:

; 1945 : 	}
; 1946 : 
; 1947 : 	AiMakeRadioResponse( self, response, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN40@AiGiveStat:

; 1948 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN47@AiGiveStat:
	DD	$LN23@AiGiveStat
	DD	$LN22@AiGiveStat
	DD	$LN24@AiGiveStat
	DD	$LN21@AiGiveStat
	DD	$LN25@AiGiveStat
$LN46@AiGiveStat:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	3
?AiGiveStatus@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiGiveStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv560 = -148						; size = 4
tv562 = -144						; size = 4
tv550 = -140						; size = 4
tv430 = -136						; size = 4
tv479 = -132						; size = 4
_dsq$ = -128						; size = 4
_ydiff$ = -124						; size = 4
tv426 = -120						; size = 4
_xdiff$ = -116						; size = 4
tv412 = -112						; size = 4
tv470 = -108						; size = 4
tv436 = -104						; size = 4
tv568 = -100						; size = 4
tv564 = -96						; size = 4
tv466 = -92						; size = 4
tv408 = -88						; size = 4
tv461 = -84						; size = 4
tv417 = -80						; size = 4
tv566 = -76						; size = 4
tv457 = -72						; size = 4
tv421 = -68						; size = 4
$T1 = -64						; size = 4
_response$ = -60					; size = 4
$T2 = -56						; size = 4
_angle$ = -52						; size = 4
_rx$ = -48						; size = 4
_ry$ = -44						; size = 4
_rz$ = -40						; size = 4
_navangle$ = -36					; size = 4
_psender$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiGiveBra@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiGiveBra
; _this$ = ecx

; 1707 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1708 : 	short edata[10];
; 1709 : 	float	rx, ry, rz;
; 1710 : 	float dsq;
; 1711 : 	int	response;
; 1712 : 	float	xdiff, ydiff;
; 1713 : 	float angle;
; 1714 : 	int	navangle;
; 1715 : 
; 1716 : 	AircraftClass* psender;
; 1717 : 
; 1718 : 	psender	= (AircraftClass*) vuDatabase->Find(msg->dataBlock.from);

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _psender$[ebp], eax

; 1719 : 
; 1720 : 
; 1721 : 	rx			= self->XPos() - psender->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv408[ebp]
	movss	xmm0, DWORD PTR tv408[ebp]
	mov	ecx, DWORD PTR _psender$[ebp]
	movss	DWORD PTR tv560[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv412[ebp]
	movss	xmm0, DWORD PTR tv560[ebp]
	subss	xmm0, DWORD PTR tv412[ebp]
	movss	DWORD PTR _rx$[ebp], xmm0

; 1722 : 	ry			= self->YPos() - psender->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv417[ebp]
	movss	xmm0, DWORD PTR tv417[ebp]
	mov	ecx, DWORD PTR _psender$[ebp]
	movss	DWORD PTR tv562[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv421[ebp]
	movss	xmm0, DWORD PTR tv562[ebp]
	subss	xmm0, DWORD PTR tv421[ebp]
	movss	DWORD PTR _ry$[ebp], xmm0

; 1723 : 	rz			= self->ZPos() - psender->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv426[ebp]
	movss	xmm0, DWORD PTR tv426[ebp]
	mov	ecx, DWORD PTR _psender$[ebp]
	movss	DWORD PTR tv564[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv430[ebp]
	movss	xmm0, DWORD PTR tv564[ebp]
	subss	xmm0, DWORD PTR tv430[ebp]
	movss	DWORD PTR _rz$[ebp], xmm0

; 1724 : 
; 1725 : 	navangle = FloatToInt32( ConvertRadtoNav((float)atan2(ry, rx)));		// convert to compass angle

	cvtss2sd xmm0, DWORD PTR _rx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv436[ebp]
	fld	DWORD PTR tv436[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?ConvertRadtoNav@@YAMM@Z		; ConvertRadtoNav
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _navangle$[ebp], eax

; 1726 : 
; 1727 : 	dsq = rx * rx + ry * ry;

	movss	xmm0, DWORD PTR _rx$[ebp]
	mulss	xmm0, DWORD PTR _rx$[ebp]
	movss	xmm1, DWORD PTR _ry$[ebp]
	mulss	xmm1, DWORD PTR _ry$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dsq$[ebp], xmm0

; 1728 : 
; 1729 : 	if(dsq < NM_TO_FT * NM_TO_FT) {

	movss	xmm0, DWORD PTR __real@4c0cd705
	comiss	xmm0, DWORD PTR _dsq$[ebp]
	jbe	$LN10@AiGiveBra

; 1730 : 		
; 1731 : 		edata[0] = self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	ecx, 2
	imul	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1732 : 		
; 1733 : 		xdiff = self->XPos() - psender->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv457[ebp]
	movss	xmm0, DWORD PTR tv457[ebp]
	mov	ecx, DWORD PTR _psender$[ebp]
	movss	DWORD PTR tv566[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv461[ebp]
	movss	xmm0, DWORD PTR tv566[ebp]
	subss	xmm0, DWORD PTR tv461[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 1734 : 		ydiff = self->YPos() - psender->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv466[ebp]
	movss	xmm0, DWORD PTR tv466[ebp]
	mov	ecx, DWORD PTR _psender$[ebp]
	movss	DWORD PTR tv568[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv470[ebp]
	movss	xmm0, DWORD PTR tv568[ebp]
	subss	xmm0, DWORD PTR tv470[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 1735 : 
; 1736 : 		angle = (float)atan2(ydiff, xdiff);

	cvtss2sd xmm0, DWORD PTR _xdiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ydiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _angle$[ebp]

; 1737 : 		angle = angle - psender->Yaw();

	mov	ecx, DWORD PTR _psender$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv479[ebp]
	movss	xmm0, DWORD PTR _angle$[ebp]
	subss	xmm0, DWORD PTR tv479[ebp]
	movss	DWORD PTR _angle$[ebp], xmm0

; 1738 : 		navangle	=  FloatToInt32 (RTD * angle);

	movss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR _angle$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _navangle$[ebp], eax

; 1739 : 		if(navangle < 0) {

	cmp	DWORD PTR _navangle$[ebp], 0
	jge	SHORT $LN9@AiGiveBra

; 1740 : 			navangle = 360 + navangle;

	mov	ecx, DWORD PTR _navangle$[ebp]
	add	ecx, 360				; 00000168H
	mov	DWORD PTR _navangle$[ebp], ecx
$LN9@AiGiveBra:

; 1741 : 		}
; 1742 : 
; 1743 : 		edata[1] = navangle / 30;									// scale compass angle for radio eData

	mov	eax, DWORD PTR _navangle$[ebp]
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], ax

; 1744 : 		if(edata[1] >= 12) {

	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR _edata$[ebp+eax]
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LN8@AiGiveBra

; 1745 : 			edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN13@AiGiveBra
	jmp	SHORT $LN14@AiGiveBra
$LN13@AiGiveBra:
	call	___report_rangecheckfailure
$LN14@AiGiveBra:
	xor	edx, edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN8@AiGiveBra:

; 1746 : 		}
; 1747 : 
; 1748 : /*
; 1749 : 		edata[1] = navangle / 30;									// scale compass angle for radio eData
; 1750 : 		if(edata[1] >= 12) {
; 1751 : 			edata[1] = 0;
; 1752 : 		}
; 1753 : */
; 1754 : 		if(rz < 300.0F && rz > -300.0F) {							// check relative alt and select correct frag

	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN7@AiGiveBra
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c3960000
	jbe	SHORT $LN7@AiGiveBra

; 1755 : 			edata[2] = 1;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	SHORT $LN2@AiGiveBra
$LN7@AiGiveBra:

; 1756 : 		}
; 1757 : 		else if(rz < -300.0F && rz > -1000.0F) {

	movss	xmm0, DWORD PTR __real@c3960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN5@AiGiveBra
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c47a0000
	jbe	SHORT $LN5@AiGiveBra

; 1758 : 			edata[2] = 2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	SHORT $LN2@AiGiveBra
$LN5@AiGiveBra:

; 1759 : 		}	
; 1760 : 		else if(rz < -1000.0F) {

	movss	xmm0, DWORD PTR __real@c47a0000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN3@AiGiveBra

; 1761 : 			edata[2] = 3;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 3
	mov	WORD PTR _edata$[ebp+edx], ax

; 1762 : 		}
; 1763 : 		else {

	jmp	SHORT $LN2@AiGiveBra
$LN3@AiGiveBra:

; 1764 : 			edata[2] = 0;

	mov	ecx, 2
	shl	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN15@AiGiveBra
	jmp	SHORT $LN16@AiGiveBra
$LN15@AiGiveBra:
	call	___report_rangecheckfailure
$LN16@AiGiveBra:
	xor	edx, edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN2@AiGiveBra:

; 1765 : 		}
; 1766 : 
; 1767 : 		response = rcPOSITIONRESPONSEB;

	mov	DWORD PTR _response$[ebp], 152		; 00000098H

; 1768 : 	}
; 1769 : 	else {

	jmp	$LN1@AiGiveBra
$LN10@AiGiveBra:

; 1770 : 		edata[0]	= ((FlightClass*)psender->GetCampaignObject())->callsign_id;

	mov	ecx, DWORD PTR _psender$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1771 : 		edata[1]	= (((FlightClass*)psender->GetCampaignObject())->callsign_num - 1) * 4 + psender->GetCampaignObject()->GetComponentIndex(psender) + 1;

	mov	ecx, DWORD PTR _psender$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	eax, DWORD PTR _psender$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psender$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	ecx, DWORD PTR [eax+esi*4-3]
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1772 : 		edata[2]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	shl	edx, 1
	mov	WORD PTR _edata$[ebp+edx], cx

; 1773 : 		edata[3]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + self->GetCampaignObject()->GetComponentIndex(self) + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	ecx, DWORD PTR [eax+esi*4-3]
	mov	edx, 2
	imul	edx, 3
	mov	WORD PTR _edata$[ebp+edx], cx

; 1774 : 		edata[4] = (short) SimToGrid(self->YPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 2
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1775 : 		edata[5] = (short) SimToGrid(self->XPos());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	ecx, 2
	imul	ecx, 5
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1776 : 		edata[6] = (short) -self->ZPos() ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv550[ebp]
	movss	xmm0, DWORD PTR tv550[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvttss2si eax, xmm0
	mov	ecx, 2
	imul	ecx, 6
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1777 : 
; 1778 : 		response = rcPOSITIONRESPONSEA;

	mov	DWORD PTR _response$[ebp], 151		; 00000097H
$LN1@AiGiveBra:

; 1779 : 
; 1780 : 	}
; 1781 : 
; 1782 : 	AiMakeRadioResponse( self, response, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN11@AiGiveBra:

; 1783 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiGiveBra@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiGiveBra
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?AiDecreaseRelativeAltitude@DigitalBrain@@AAEXXZ PROC	; DigitalBrain::AiDecreaseRelativeAltitude
; _this$ = ecx

; 1670 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1671 : 	mFormRelativeAltitude += 1000.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+896]
	addss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+896], xmm0

; 1672 : 	// do radio response here
; 1673 : 	//MI making reply
; 1674 : 	short edata[10];
; 1675 : 	int flightIdx = self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1676 : 	edata[1]	= -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1677 : 	edata[2]	= -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1678 : 	edata[3]	= -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1679 : 	edata[4]	= -1;

	mov	edx, 2
	shl	edx, 2
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1680 : 	edata[5]	= -1;

	mov	ecx, 2
	imul	ecx, 5
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1681 : 	edata[6]	= -1;

	mov	eax, 2
	imul	eax, 6
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1682 : 	edata[7]	= -1;

	mov	edx, 2
	imul	edx, 7
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1683 : 	edata[8]	= -1;

	mov	ecx, 2
	shl	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1684 : 	edata[9]	= -1;

	mov	eax, 2
	imul	eax, 9
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1685 : 
; 1686 : 	edata[0]	= flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 1687 : 	edata[1] = 1;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1688 : 
; 1689 :    	AiMakeRadioResponse( self, rcFORMRESPONSEA, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	78					; 0000004eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1690 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AiDecreaseRelativeAltitude@DigitalBrain@@AAEXXZ ENDP	; DigitalBrain::AiDecreaseRelativeAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -36					; size = 4
$T1 = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
?AiIncreaseRelativeAltitude@DigitalBrain@@AAEXXZ PROC	; DigitalBrain::AiIncreaseRelativeAltitude
; _this$ = ecx

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1647 : 	mFormRelativeAltitude -= 1000.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+896]
	subss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+896], xmm0

; 1648 : 	// do radio response here
; 1649 : 	//MI making reply
; 1650 : 	short edata[10];
; 1651 : 	int flightIdx = self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1652 : 	edata[1]	= -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1653 : 	edata[2]	= -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1654 : 	edata[3]	= -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1655 : 	edata[4]	= -1;

	mov	edx, 2
	shl	edx, 2
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1656 : 	edata[5]	= -1;

	mov	ecx, 2
	imul	ecx, 5
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1657 : 	edata[6]	= -1;

	mov	eax, 2
	imul	eax, 6
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1658 : 	edata[7]	= -1;

	mov	edx, 2
	imul	edx, 7
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1659 : 	edata[8]	= -1;

	mov	ecx, 2
	shl	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1660 : 	edata[9]	= -1;

	mov	eax, 2
	imul	eax, 9
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1661 : 
; 1662 : 	edata[0]	= flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 1663 : 	edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN3@AiIncrease
	jmp	SHORT $LN4@AiIncrease
$LN3@AiIncrease:
	call	___report_rangecheckfailure
$LN4@AiIncrease:
	xor	ecx, ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+edx], cx

; 1664 : 
; 1665 :    	AiMakeRadioResponse( self, rcFORMRESPONSEA, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	78					; 0000004eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN1@AiIncrease:

; 1666 : 
; 1667 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?AiIncreaseRelativeAltitude@DigitalBrain@@AAEXXZ ENDP	; DigitalBrain::AiIncreaseRelativeAltitude
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiToggleSide@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiToggleSide
; _this$ = ecx

; 1640 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1641 : 	mFormSide *= -1;	// +1 normal formation, -1 is mirrored formation

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	imul	ecx, -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+900], ecx

; 1642 : 	AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4

; 1643 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiToggleSide@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiToggleSide
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiCloseup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiCloseup
; _this$ = ecx

; 1585 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1586 : 
; 1587 : 	short	edata[10];
; 1588 : 	int	flightIdx;
; 1589 : 	
; 1590 : //	mInPositionFlag = FALSE;
; 1591 : 	AiCheckPosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckPosition@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckPosition

; 1592 : 
; 1593 : 	mFormLateralSpaceFactor	*= 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+904]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+904], xmm0

; 1594 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1595 : 
; 1596 : 	//MI give us a negative if we can't get closer
; 1597 : 	if(mFormLateralSpaceFactor < 0.0625F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3d800000
	comiss	xmm0, DWORD PTR [edx+904]
	jbe	$LN4@AiCloseup

; 1598 : 	{
; 1599 : 		edata[2]	= -1;

	mov	eax, 2
	shl	eax, 1
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1600 : 		edata[3]	= -1;

	mov	edx, 2
	imul	edx, 3
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1601 : 		edata[4]	= -1;

	mov	ecx, 2
	shl	ecx, 2
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1602 : 		edata[5]	= -1;

	mov	eax, 2
	imul	eax, 5
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1603 : 		edata[6]	= -1;

	mov	edx, 2
	imul	edx, 6
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1604 : 		edata[7]	= -1;

	mov	ecx, 2
	imul	ecx, 7
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1605 : 		edata[8]	= -1;

	mov	eax, 2
	shl	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1606 : 		edata[9]	= -1;

	mov	edx, 2
	imul	edx, 9
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1607 : 
; 1608 : 		edata[0]	= flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1609 : 		edata[1] = 5;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 5
	mov	WORD PTR _edata$[ebp+eax], cx

; 1610 : 
; 1611 : 		AiMakeRadioResponse( self, rcFORMRESPONSEA, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	78					; 0000004eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1612 : 	}
; 1613 : 	else

	jmp	$LN1@AiCloseup
$LN4@AiCloseup:

; 1614 : 	{
; 1615 : 		if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	$LN2@AiCloseup

; 1616 : 
; 1617 : 			edata[1]	= -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1618 : 			edata[2]	= -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1619 : 			edata[3]	= -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1620 : 			edata[4]	= -1;

	mov	edx, 2
	shl	edx, 2
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1621 : 			edata[5]	= -1;

	mov	ecx, 2
	imul	ecx, 5
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1622 : 			edata[6]	= -1;

	mov	eax, 2
	imul	eax, 6
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1623 : 			edata[7]	= -1;

	mov	edx, 2
	imul	edx, 7
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1624 : 			edata[8]	= -1;

	mov	ecx, 2
	shl	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1625 : 			edata[9]	= -1;

	mov	eax, 2
	imul	eax, 9
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1626 : 
; 1627 : 			edata[0]	= flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 1628 : 			edata[1] = 3;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 3
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1629 : 
; 1630 :    		AiMakeRadioResponse( self, rcFORMRESPONSEA, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	78					; 0000004eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1631 : 		}
; 1632 : 		else {

	jmp	SHORT $LN1@AiCloseup
$LN2@AiCloseup:

; 1633 : 			AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN1@AiCloseup:

; 1634 : 		}
; 1635 : 	}
; 1636 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiCloseup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiCloseup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiKickout@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiKickout
; _this$ = ecx

; 1550 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1551 : 
; 1552 : 	short	edata[10];
; 1553 : 	int	flightIdx;
; 1554 : 
; 1555 : //	mInPositionFlag = FALSE;
; 1556 : 	AiCheckPosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckPosition@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckPosition

; 1557 : 
; 1558 : 	mFormLateralSpaceFactor	*= 2.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+904]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+904], xmm0

; 1559 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1560 : 
; 1561 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	$LN2@AiKickout

; 1562 : 
; 1563 : 		edata[1]	= -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1564 : 		edata[2]	= -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1565 : 		edata[3]	= -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1566 : 		edata[4]	= -1;

	mov	edx, 2
	shl	edx, 2
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1567 : 		edata[5]	= -1;

	mov	ecx, 2
	imul	ecx, 5
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1568 : 		edata[6]	= -1;

	mov	eax, 2
	imul	eax, 6
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1569 : 		edata[7]	= -1;

	mov	edx, 2
	imul	edx, 7
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1570 : 		edata[8]	= -1;

	mov	ecx, 2
	shl	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1571 : 		edata[9]	= -1;

	mov	eax, 2
	imul	eax, 9
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1572 : 
; 1573 : 		edata[0]	= flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 1574 : 		edata[1] = 2;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1575 : 
; 1576 :    	AiMakeRadioResponse( self, rcFORMRESPONSEA, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	78					; 0000004eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1577 : 	}
; 1578 : 	else {

	jmp	SHORT $LN1@AiKickout
$LN2@AiKickout:

; 1579 : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN1@AiKickout:

; 1580 : 	}
; 1581 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiKickout@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiKickout
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv179 = -40						; size = 4
_flightIdx$ = -36					; size = 4
_radioform$1 = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiSetFormation@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiSetFormation
; _this$ = ecx

; 1446 : void DigitalBrain::AiSetFormation(FalconWingmanMsg* msg) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 
; 1448 : 	short	edata[10];
; 1449 : 	int	flightIdx;
; 1450 : 
; 1451 : 	//we can't fly in formation if we're on the ground still!
; 1452 : 	if(self->OnGround() || atcstatus >= lOnFinal)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN22@AiSetForma
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 11			; 0000000bH
	jl	SHORT $LN23@AiSetForma
$LN22@AiSetForma:

; 1453 : 		return;

	jmp	$LN24@AiSetForma
$LN23@AiSetForma:

; 1454 : 
; 1455 : //	mInPositionFlag = FALSE;
; 1456 : 	AiCheckPosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckPosition@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckPosition

; 1457 : 
; 1458 : //	mFormLateralSpaceFactor	= 1.0F;
; 1459 : 
; 1460 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1461 : 	mFormation		= acFormationData->FindFormation(msg->dataBlock.command);

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+58]
	push	edx
	mov	ecx, DWORD PTR ?acFormationData@@3PAVACFormationData@@A ; acFormationData
	call	?FindFormation@ACFormationData@@QAEHH@Z	; ACFormationData::FindFormation
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+808], eax

; 1462 : 	mpActionFlags[AI_FOLLOW_FORMATION] = TRUE;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 1

; 1463 : 	SendATCMsg(noATC);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 1464 : 	atcstatus = noATC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 0

; 1465 : 	// cancel atc here
; 1466 : 
; 1467 : 	AiGlueFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGlueFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiGlueFlight

; 1468 : 
; 1469 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	$LN21@AiSetForma

; 1470 : 
; 1471 : 		edata[1]	= -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1472 : 		edata[2]	= -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1473 : 		edata[3]	= -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1474 : 		edata[4]	= -1;

	mov	edx, 2
	shl	edx, 2
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1475 : 		edata[5]	= -1;

	mov	ecx, 2
	imul	ecx, 5
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1476 : 		edata[6]	= -1;

	mov	eax, 2
	imul	eax, 6
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1477 : 		edata[7]	= -1;

	mov	edx, 2
	imul	edx, 7
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1478 : 		edata[8]	= -1;

	mov	ecx, 2
	shl	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1479 : 		edata[9]	= -1;

	mov	eax, 2
	imul	eax, 9
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1480 : 
; 1481 : 		edata[0]	= flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 1482 : 
; 1483 : 
; 1484 : 		int radioform = mFormation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	DWORD PTR _radioform$1[ebp], edx

; 1485 : 		
; 1486 : // M.N. hack the next formation message indexes (currently 59,60,61)
; 1487 : 		if (radioform > 8)

	cmp	DWORD PTR _radioform$1[ebp], 8
	jle	SHORT $LN20@AiSetForma

; 1488 : 			radioform = mFormation + 50;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	add	ecx, 50					; 00000032H
	mov	DWORD PTR _radioform$1[ebp], ecx
$LN20@AiSetForma:

; 1489 : 
; 1490 : 		switch(radioform) {

	mov	edx, DWORD PTR _radioform$1[ebp]
	mov	DWORD PTR tv179[ebp], edx
	cmp	DWORD PTR tv179[ebp], 65		; 00000041H
	ja	$LN18@AiSetForma
	mov	eax, DWORD PTR tv179[ebp]
	movzx	ecx, BYTE PTR $LN26@AiSetForma[eax]
	jmp	DWORD PTR $LN27@AiSetForma[ecx*4]
$LN17@AiSetForma:

; 1491 : 		case FalconWingmanMsg::WMSpread:
; 1492 : 			edata[1] = 1;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1493 : 			break;

	jmp	$LN18@AiSetForma
$LN16@AiSetForma:

; 1494 : 		case FalconWingmanMsg::WMWedge:
; 1495 : 			edata[1] = 2;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1496 : 			break;

	jmp	$LN18@AiSetForma
$LN15@AiSetForma:

; 1497 : 		case FalconWingmanMsg::WMTrail:
; 1498 : 			edata[1] = 3;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 3
	mov	WORD PTR _edata$[ebp+eax], cx

; 1499 : 			break;

	jmp	$LN18@AiSetForma
$LN14@AiSetForma:

; 1500 : 		case FalconWingmanMsg::WMLadder:
; 1501 : 			edata[1] = 4;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 4
	mov	WORD PTR _edata$[ebp+edx], ax

; 1502 : 			break;

	jmp	$LN18@AiSetForma
$LN13@AiSetForma:

; 1503 : 		case FalconWingmanMsg::WMStack:
; 1504 : 			edata[1] = 5;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 5
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1505 : 			break;

	jmp	$LN18@AiSetForma
$LN12@AiSetForma:

; 1506 : 		case FalconWingmanMsg::WMResCell:
; 1507 : 			edata[1] = 6;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 6
	mov	WORD PTR _edata$[ebp+eax], cx

; 1508 : 			break;

	jmp	$LN18@AiSetForma
$LN11@AiSetForma:

; 1509 : 		case FalconWingmanMsg::WMBox:
; 1510 : 			edata[1] = 7;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 7
	mov	WORD PTR _edata$[ebp+edx], ax

; 1511 : 			break;

	jmp	$LN18@AiSetForma
$LN10@AiSetForma:

; 1512 : 		case FalconWingmanMsg::WMArrowHead:
; 1513 : 			edata[1] = 8;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 8
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1514 : 			break;

	jmp	$LN18@AiSetForma
$LN9@AiSetForma:

; 1515 : 		case FalconWingmanMsg::WMFluidFour:
; 1516 : 			edata[1] = 14;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 14					; 0000000eH
	mov	WORD PTR _edata$[ebp+eax], cx

; 1517 : 			break;

	jmp	$LN18@AiSetForma
$LN8@AiSetForma:

; 1518 : 		case FalconWingmanMsg::WMVic:
; 1519 : 			edata[1] = 10;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 10					; 0000000aH
	mov	WORD PTR _edata$[ebp+edx], ax

; 1520 : 			break;

	jmp	SHORT $LN18@AiSetForma
$LN7@AiSetForma:

; 1521 : 		case FalconWingmanMsg::WMEchelon:
; 1522 : 			edata[1] = 11;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 11					; 0000000bH
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1523 : 			break;

	jmp	SHORT $LN18@AiSetForma
$LN6@AiSetForma:

; 1524 : 		case FalconWingmanMsg::WMFinger4:
; 1525 : 			edata[1] = 13;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 13					; 0000000dH
	mov	WORD PTR _edata$[ebp+eax], cx

; 1526 : 			break;

	jmp	SHORT $LN18@AiSetForma
$LN5@AiSetForma:

; 1527 : 		case FalconWingmanMsg::WMForm1:
; 1528 : 			edata[1] = 15;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 15					; 0000000fH
	mov	WORD PTR _edata$[ebp+edx], ax

; 1529 : 			break;

	jmp	SHORT $LN18@AiSetForma
$LN4@AiSetForma:

; 1530 : 		case FalconWingmanMsg::WMForm2:
; 1531 : 			edata[1] = 16;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1532 : 			break;

	jmp	SHORT $LN18@AiSetForma
$LN3@AiSetForma:

; 1533 : 		case FalconWingmanMsg::WMForm3:
; 1534 : 			edata[1] = 17;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 17					; 00000011H
	mov	WORD PTR _edata$[ebp+eax], cx

; 1535 : 			break;

	jmp	SHORT $LN18@AiSetForma
$LN2@AiSetForma:

; 1536 : 		case FalconWingmanMsg::WMForm4:
; 1537 : 			edata[1] = 18;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 18					; 00000012H
	mov	WORD PTR _edata$[ebp+edx], ax
$LN18@AiSetForma:

; 1538 : 			break;
; 1539 : 		}
; 1540 : 
; 1541 :    	AiMakeRadioResponse( self, rcFORMRESPONSEB, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	79					; 0000004fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1542 : 	}
; 1543 : 	else {

	jmp	SHORT $LN24@AiSetForma
$LN21@AiSetForma:

; 1544 : 		AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN24@AiSetForma:

; 1545 : 	}
; 1546 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN27@AiSetForma:
	DD	$LN17@AiSetForma
	DD	$LN16@AiSetForma
	DD	$LN15@AiSetForma
	DD	$LN14@AiSetForma
	DD	$LN13@AiSetForma
	DD	$LN12@AiSetForma
	DD	$LN11@AiSetForma
	DD	$LN10@AiSetForma
	DD	$LN9@AiSetForma
	DD	$LN8@AiSetForma
	DD	$LN6@AiSetForma
	DD	$LN7@AiSetForma
	DD	$LN5@AiSetForma
	DD	$LN4@AiSetForma
	DD	$LN3@AiSetForma
	DD	$LN2@AiSetForma
	DD	$LN18@AiSetForma
$LN26@AiSetForma:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
?AiSetFormation@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiSetFormation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -48						; size = 8
$T2 = -40						; size = 4
_flightIdx$ = -36					; size = 4
_tmpWaypoint$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_action$ = 12						; size = 4
?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z PROC ; DigitalBrain::AiSetWeaponsAction
; _this$ = ecx

; 1337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1338 : WayPointClass* tmpWaypoint = self->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _tmpWaypoint$[ebp], edx

; 1339 : int	flightIdx;
; 1340 : short edata[10];
; 1341 : 
; 1342 : 	mWeaponsAction = action;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _action$[ebp]
	mov	DWORD PTR [eax+828], ecx

; 1343 : 
; 1344 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1345 : 
; 1346 : 	// 2000-09-28 ADDED BY S.G. IF ASKED TO GO WEAPON HOLD, SET 'missileShotTimer' AT 2 HOURS FROM NOW
; 1347 : 	if (action == AI_WEAPONS_HOLD)

	cmp	DWORD PTR _action$[ebp], 0
	jne	SHORT $LN14@AiSetWeapo

; 1348 : 	{
; 1349 : 		missileShotTimer = SimLibElapsedTime + 2 * 60 * 60 * SEC_TO_MSEC;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 7200000				; 006ddd00H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+472], edx

; 1350 : 		AiRejoin(NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z ; DigitalBrain::AiRejoin
$LN14@AiSetWeapo:

; 1351 : 
; 1352 : 	}
; 1353 : 	//Cobra TJL let's remove the WaitingPermission.  If I give weaponsfree I'm expecting the AI
; 1354 : 	//to get its game on and find targets!
; 1355 : 	if (action == AI_WEAPONS_FREE && missionClass == AGMission /*&& IsSetATC(WaitingPermission)*/)

	cmp	DWORD PTR _action$[ebp], 1
	jne	$LN13@AiSetWeapo
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	jne	$LN13@AiSetWeapo

; 1356 : 	{
; 1357 : 		missileShotTimer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+472], 0
$LN12@AiSetWeapo:

; 1358 : 		// Find the IP waypoint
; 1359 : 		while (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN11@AiSetWeapo

; 1360 : 		{
; 1361 : 			// 2000-09-28 MODIFIED BY S.G. WHAT IF WE DON'T HAVE AN IP? 
; 1362 : 			// IN THAT CASE, CHECK IF TARGET, IF SUCH, GO BACK ONE WAYPOINT AND BREAK
; 1363 : 			if (tmpWaypoint->GetWPFlags() & WPF_TARGET) {

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 1
	je	SHORT $LN10@AiSetWeapo

; 1364 : 				tmpWaypoint = tmpWaypoint->GetPrevWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 1365 : 				break;

	jmp	SHORT $LN11@AiSetWeapo
$LN10@AiSetWeapo:

; 1366 : 			}
; 1367 : 			if (tmpWaypoint->GetWPFlags() & WPF_IP)

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetWPFlags@WayPointClass@@QAEKXZ	; WayPointClass::GetWPFlags
	and	eax, 8
	je	SHORT $LN9@AiSetWeapo

; 1368 : 				break;

	jmp	SHORT $LN11@AiSetWeapo
$LN9@AiSetWeapo:

; 1369 : 			tmpWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _tmpWaypoint$[ebp], eax

; 1370 : 		}

	jmp	SHORT $LN12@AiSetWeapo
$LN11@AiSetWeapo:

; 1371 : 
; 1372 :       // Have an IP
; 1373 : 		if (tmpWaypoint)

	cmp	DWORD PTR _tmpWaypoint$[ebp], 0
	je	SHORT $LN8@AiSetWeapo

; 1374 : 			self->curWaypoint = tmpWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _tmpWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [edx+728], eax
$LN8@AiSetWeapo:

; 1375 : 
; 1376 : // 2000-09-28 MODIFIED BY S.G. WE SAVE THE CURRENT GROUND TARGET, CLEAR IT, CALL THE ROUTINE AND IF IT CAN'T FIND ONE, RESTORE IT
; 1377 : //		SelectGroundTarget (TARGET_ANYTHING);
; 1378 : 		//Cobra... this gets called when  you give weapons free and retargets??? why?
; 1379 : 		//Will this allow a retargeting?
; 1380 : 		/*SimObjectType*	tmpGroundTargetPtr = groundTargetPtr;
; 1381 : 		groundTargetPtr = 0;
; 1382 : 		SelectGroundTarget (TARGET_ANYTHING);
; 1383 : 		if (groundTargetPtr == NULL)
; 1384 : 			groundTargetPtr = tmpGroundTargetPtr;*/
; 1385 : 		groundTargetPtr = NULL;//Ok, let's force a reevaluation each command.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+224], 0

; 1386 : 		if (groundTargetPtr == NULL)//cobra 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+224], 0
	jne	SHORT $LN7@AiSetWeapo

; 1387 : 			SelectGroundTarget (TARGET_ANYTHING);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SelectGroundTarget@DigitalBrain@@IAEXH@Z ; DigitalBrain::SelectGroundTarget
$LN7@AiSetWeapo:

; 1388 : 
; 1389 : 		SetupAGMode( NULL, NULL );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupAGMode@DigitalBrain@@IAEXPAVWayPointClass@@0@Z ; DigitalBrain::SetupAGMode

; 1390 : 
; 1391 : 		if(groundTargetPtr == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+224], 0
	jne	$LN6@AiSetWeapo

; 1392 : 		{
; 1393 : 			mDesignatedObject = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+800], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+804], edx

; 1394 : 			mpActionFlags[AI_ENGAGE_TARGET]	= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 1395 : 
; 1396 : 			edata[0] = ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	ax, BYTE PTR [eax+425]
	mov	ecx, 2
	imul	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1397 : 			edata[1] = (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 +
; 1398 : 			self->GetCampaignObject()->GetComponentIndex(self) + 1;		

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	eax, DWORD PTR [eax+esi*4-3]
	mov	ecx, 2
	shl	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1399 : 			edata[2] = -1;

	mov	edx, 2
	shl	edx, 1
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1400 : 			edata[3] = -1;

	mov	ecx, 2
	imul	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1401 : 			edata[4] = 0;

	mov	eax, 2
	shl	eax, 2
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN17@AiSetWeapo
	jmp	SHORT $LN18@AiSetWeapo
$LN17@AiSetWeapo:
	call	___report_rangecheckfailure
$LN18@AiSetWeapo:
	xor	ecx, ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+edx], cx

; 1402 : 			AiMakeRadioResponse( self, rcUNABLE, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	219					; 000000dbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1403 : 		}
; 1404 : 		else

	jmp	$LN5@AiSetWeapo
$LN6@AiSetWeapo:

; 1405 : 		{
; 1406 : // 2000-09-27 ADDED BY S.G. WE'LL CLEAR THE FLAG *ONLY* IF WE HAVE A TARGET
; 1407 : 			ClearATCFlag(WaitingPermission);

	push	67108864				; 04000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1408 : 
; 1409 : 			mDesignatedObject = groundTargetPtr->BaseData()->Id();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+224]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+800], edx
	mov	DWORD PTR [ecx+804], eax

; 1410 : 			mpActionFlags[AI_ENGAGE_TARGET]		= AI_GROUND_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 2

; 1411 : 			mpActionFlags[AI_RTB]               = FALSE;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 1412 : 			edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 1413 : 			edata[1] = 2;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax

; 1414 : 			AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN5@AiSetWeapo:

; 1415 : 		}
; 1416 : 	}
; 1417 : 	else

	jmp	$LN16@AiSetWeapo
$LN13@AiSetWeapo:

; 1418 : 	{
; 1419 : 		// RV - Biker - Allow them to fire missiles
; 1420 : 		if (action == AI_WEAPONS_FREE)

	cmp	DWORD PTR _action$[ebp], 1
	jne	SHORT $LN3@AiSetWeapo

; 1421 : 			missileShotTimer = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+472], 0
$LN3@AiSetWeapo:

; 1422 : 
; 1423 : 		mpActionFlags[AI_RTB]					= FALSE;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 1424 : 		if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiSetWeapo

; 1425 : 			edata[0] = flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1426 : 			edata[1] = 2;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx

; 1427 : 			AiMakeRadioResponse( self, rcROGER, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	179					; 000000b3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1428 : 		}
; 1429 : 		else {

	jmp	SHORT $LN16@AiSetWeapo
$LN2@AiSetWeapo:

; 1430 : 			AiRespondShortCallSign(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN16@AiSetWeapo:

; 1431 : 		}
; 1432 : 	}
; 1433 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?AiSetWeaponsAction@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiWeaponsAction@1@@Z ENDP ; DigitalBrain::AiSetWeaponsAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
?AiDesignateGroup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiDesignateGroup
; _this$ = ecx

; 1306 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1307 : #if 0
; 1308 : 	SimBaseClass*	psimBase;
; 1309 : 	SimBaseClass*	ptarget;
; 1310 : 
; 1311 : 	mDesignatedObject	= FalconNullId;
; 1312 : 
; 1313 : 
; 1314 : 	psimBase			= (SimBaseClass*) vuDatabase->Find(msg->dataBlock.newTarget);
; 1315 : 
; 1316 : 	// VWF caution	what about things that are not vehicles?
; 1317 : 	// if it is a vehicle
; 1318 : 	if(psimBase && psimBase->campaignObject->components) {		
; 1319 : 		VuListIterator		elementWalker(psimBase->campaignObject->components);
; 1320 : 		// pick the closest to my side of formation
; 1321 : 		ptarget				= (SimBaseClass*)elementWalker.GetFirst();					
; 1322 : 		//ptarget				= (SimBaseClass*)elementWalker.GetNext();
; 1323 : 		
; 1324 : 		SetTarget(ptarget);
; 1325 : 	}
; 1326 : 	else {
; 1327 : 		SetTarget(NULL);
; 1328 : 	}
; 1329 : #endif
; 1330 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AiDesignateGroup@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiDesignateGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -56						; size = 8
_myLead$2 = -48						; size = 4
$T3 = -44						; size = 4
_leadIsPlayer$4 = -40					; size = 4
_flightIdx$ = -36					; size = 4
_newTarg$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiDesignateTarget@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiDesignateTarget
; _this$ = ecx

; 1174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1175 : int	flightIdx;
; 1176 : short edata[10];
; 1177 : FalconEntity* newTarg = (FalconEntity*)vuDatabase->Find(msg->dataBlock.newTarget);

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+66]
	push	ecx
	mov	edx, DWORD PTR [eax+62]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _newTarg$[ebp], eax

; 1178 : 
; 1179 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1180 : 
; 1181 : 	if (newTarg)

	cmp	DWORD PTR _newTarg$[ebp], 0
	je	$LN23@AiDesignat

; 1182 : 	{
; 1183 : // 2001-07-17 ADDED BY S.G. WHEN TOLD TO DESIGNATE AND IT'S A PLAYER'S WING, LOOSE YOUR HISTORY BECAUSE YOU MIGHT HAVE CHOSEN SOMETHING TO HIT BY YOURSELF ALREADY
; 1184 : //            THE TARGET HERE WILL BE A CAMPAIGN OBJECT BUT ONCE THE HISTORY IS REMOVED, THE SAME SIM OBJECT CAN BE CHOSEN.
; 1185 : 		if (flightLead && flightLead->IsSetFlag(MOTION_OWNSHIP))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN22@AiDesignat
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN22@AiDesignat

; 1186 : 			gndTargetHistory[0] = NULL;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+452], 0
$LN22@AiDesignat:

; 1187 : // END OF ADDED SECTION
; 1188 : 
; 1189 : 		// Try not to attack friendlies
; 1190 : 		if (newTarg->GetTeam() != self->GetTeam() || (SkillLevel() < 2 && rand() % 10 > SkillLevel()+8))

	mov	ecx, DWORD PTR _newTarg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _newTarg$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	esi, al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	cmp	esi, ecx
	jne	SHORT $LN20@AiDesignat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	cmp	eax, 2
	jge	$LN21@AiDesignat
	call	_rand
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	esi, edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	add	eax, 8
	cmp	esi, eax
	jle	$LN21@AiDesignat
$LN20@AiDesignat:

; 1191 : 		{
; 1192 : 			mWeaponsAction								= AI_WEAPONS_FREE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+828], 1

; 1193 : // 2000-09-26 ADDED BY S.G. SO ASSIGN GROUP WORKS BY ASSIGNING TARGETS ACCORDING TO THEIR POSITION IN FLIGHT (LIKE FOR THE AI)
; 1194 : 			if ((FalconWingmanMsg::WingManCmd) msg->dataBlock.command == FalconWingmanMsg::WMAssignGroup) {

	mov	eax, DWORD PTR _msg$[ebp]
	cmp	DWORD PTR [eax+58], 10			; 0000000aH
	jne	SHORT $LN19@AiDesignat

; 1195 : 				// If it's a sim object, get the corresponding campaign object and assign it
; 1196 : 				if (((FalconEntity*)newTarg)->IsSim())

	mov	ecx, DWORD PTR _newTarg$[ebp]
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN18@AiDesignat

; 1197 : 					AiSearchTargetList(((SimBaseClass *)newTarg)->GetCampaignObject());

	mov	ecx, DWORD PTR _newTarg$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSearchTargetList@DigitalBrain@@AAEXPAVVuEntity@@@Z ; DigitalBrain::AiSearchTargetList

; 1198 : 				else

	jmp	SHORT $LN17@AiDesignat
$LN18@AiDesignat:

; 1199 : 					AiSearchTargetList(newTarg);

	mov	ecx, DWORD PTR _newTarg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSearchTargetList@DigitalBrain@@AAEXPAVVuEntity@@@Z ; DigitalBrain::AiSearchTargetList
$LN17@AiDesignat:

; 1200 : 
; 1201 : 				if (targetPtr)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN16@AiDesignat

; 1202 : 					mDesignatedObject							= targetPtr->BaseData()->Id();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+800], edx
	mov	DWORD PTR [ecx+804], eax
$LN16@AiDesignat:

; 1203 : 			}
; 1204 : 			else

	jmp	SHORT $LN15@AiDesignat
$LN19@AiDesignat:

; 1205 : // END OF ADDED SECTION (EXCEPT FOR INDENT OF THE NEXT LINE)
; 1206 : 				mDesignatedObject							= msg->dataBlock.newTarget;

	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+62]
	mov	ecx, DWORD PTR [edx+66]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+800], eax
	mov	DWORD PTR [edx+804], ecx
$LN15@AiDesignat:

; 1207 : 
; 1208 : //			mpActionFlags[AI_ENGAGE_TARGET]		= TRUE; // 2002-03-04 REMOVED BY S.G. Done within the "if (newTarg->OnGround())" test below now
; 1209 : 
; 1210 : 			mpActionFlags[AI_RTB]               = FALSE;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 1211 : 			mCurrentManeuver							= FalconWingmanMsg::WMTotalMsg;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+796], 57			; 00000039H

; 1212 : 
; 1213 : 
; 1214 : 			if (newTarg->OnGround()) {

	mov	eax, DWORD PTR _newTarg$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _newTarg$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN14@AiDesignat

; 1215 : 				mpActionFlags[AI_ENGAGE_TARGET]	= AI_GROUND_TARGET; // 2002-03-04 ADDED BY S.G. It's a ground target, say that's what we're engaging

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 2

; 1216 : // 2001-06-20 ADDED BY S.G. NEED TO TELL AI THERE AG MISSION IS NOT COMPLETE ANYMORE
; 1217 : 				missionComplete = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0

; 1218 : // END OF ADDED SECTION
; 1219 : 
; 1220 : 				SetGroundTarget( newTarg );

	mov	ecx, DWORD PTR _newTarg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z ; DigitalBrain::SetGroundTarget

; 1221 : 				if (self->AutopilotType() == AircraftClass::CombatAP)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	jne	$LN13@AiDesignat

; 1222 : 				{
; 1223 : 					SetupAGMode( NULL, NULL );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupAGMode@DigitalBrain@@IAEXPAVWayPointClass@@0@Z ; DigitalBrain::SetupAGMode

; 1224 : 
; 1225 : 					if(groundTargetPtr == NULL) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+224], 0
	jne	$LN12@AiDesignat

; 1226 : 						mDesignatedObject = FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+800], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+804], eax

; 1227 : 						mpActionFlags[AI_ENGAGE_TARGET]	= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 1228 : 
; 1229 : 						edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1230 : 						edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + self->GetCampaignObject()->GetComponentIndex(self) + 1;		

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	ecx, DWORD PTR [eax+esi*4-3]
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 1231 : 						edata[2] = -1;

	mov	eax, 2
	shl	eax, 1
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1232 : 						edata[3] = -1;

	mov	edx, 2
	imul	edx, 3
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1233 : 						edata[4] = 0;

	mov	ecx, 2
	shl	ecx, 2
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 20			; 00000014H
	jae	SHORT $LN26@AiDesignat
	jmp	SHORT $LN27@AiDesignat
$LN26@AiDesignat:
	call	___report_rangecheckfailure
$LN27@AiDesignat:
	xor	edx, edx
	mov	eax, DWORD PTR $T3[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx

; 1234 : 						AiMakeRadioResponse( self, rcUNABLE, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	219					; 000000dbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1235 : 					}
; 1236 : 					else {

	jmp	SHORT $LN11@AiDesignat
$LN12@AiDesignat:

; 1237 : 						edata[0] = flightIdx;

	mov	ecx, 2
	imul	ecx, 0
	mov	dx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1238 : 						edata[1] = 2;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx

; 1239 : 						AiMakeRadioResponse( self, rcROGER, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	179					; 000000b3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1240 : 						AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight
$LN11@AiDesignat:

; 1241 : 					}
; 1242 : 				}
; 1243 : 				else

	jmp	SHORT $LN10@AiDesignat
$LN13@AiDesignat:

; 1244 : 				{
; 1245 : 					agDoctrine = AGD_NEED_SETUP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+244], 3
$LN10@AiDesignat:

; 1246 : 				}
; 1247 : 			}
; 1248 : 			else {

	jmp	$LN9@AiDesignat
$LN14@AiDesignat:

; 1249 : // 2000-10-11 ADDED BY S.G. NEED TO SET agDoctrine TO AGD_NONE AND CLEAR OUT THE GROUND TARGET SO IT WON'T ATTACK GROUND TARGET INSTEAD OF THE DESIGNATED AIR ONE
; 1250 : 				// 2002-03-04 ADDED BY S.G. Only reset the agDoctrine and groundTargetPtr if it's comming from the player. That way, AI will not react too quickly to target change
; 1251 : 				// 2002-03-07 MODIFIED BY S.G. Make sure flightlead and myLead are non NULL before doing a ->IsPlayer on them...
; 1252 : 				int leadIsPlayer = FALSE;

	mov	DWORD PTR _leadIsPlayer$4[ebp], 0

; 1253 : 
; 1254 : 				if (flightLead && flightLead->IsPlayer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN8@AiDesignat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+708]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN8@AiDesignat

; 1255 : 					leadIsPlayer = TRUE;

	mov	DWORD PTR _leadIsPlayer$4[ebp], 1

; 1256 : 				else {

	jmp	SHORT $LN7@AiDesignat
$LN8@AiDesignat:

; 1257 : 					if (isWing == AiSecondWing) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 3
	jne	SHORT $LN7@AiDesignat

; 1258 : 						AircraftClass *myLead;
; 1259 : 						myLead = (AircraftClass *)self->GetCampaignObject()->GetComponentNumber(2);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _myLead$2[ebp], eax

; 1260 : 						if (myLead && myLead->IsPlayer())

	cmp	DWORD PTR _myLead$2[ebp], 0
	je	SHORT $LN7@AiDesignat
	mov	ecx, DWORD PTR _myLead$2[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN7@AiDesignat

; 1261 : 							leadIsPlayer = TRUE;

	mov	DWORD PTR _leadIsPlayer$4[ebp], 1
$LN7@AiDesignat:

; 1262 : 					}
; 1263 : 				}
; 1264 : 				if (leadIsPlayer)

	cmp	DWORD PTR _leadIsPlayer$4[ebp], 0
	je	SHORT $LN4@AiDesignat

; 1265 : 				// END OF ADDED SECTION 2002-03-04
; 1266 : 				{
; 1267 : 					agDoctrine = AGD_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], 0

; 1268 : 					SetGroundTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z ; DigitalBrain::SetGroundTarget
$LN4@AiDesignat:

; 1269 : 				}
; 1270 : // END OF ADDED SECTION 2000-10-11
; 1271 : 				// 2002-03-04 ADDED BY S.G. Prioritize ground target over air target but if needed be, it will attack anyway
; 1272 : 				if (mpActionFlags[AI_ENGAGE_TARGET]	== AI_NONE)

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx+760], 0
	jne	SHORT $LN3@AiDesignat

; 1273 : 					mpActionFlags[AI_ENGAGE_TARGET]	= AI_AIR_TARGET;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 1
$LN3@AiDesignat:

; 1274 : 				// END OF ADDED SECTION 2002-03-04
; 1275 : 				edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 1276 : 				edata[1] = 2;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 2
	mov	WORD PTR _edata$[ebp+edx], ax

; 1277 : 				AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1278 : 
; 1279 : 				AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR [edx+48]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight
$LN9@AiDesignat:

; 1280 : 			}
; 1281 : 		}
; 1282 : 		else

	jmp	$LN2@AiDesignat
$LN21@AiDesignat:

; 1283 : 		{
; 1284 : 			edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	dx, BYTE PTR [eax+425]
	mov	eax, 2
	imul	eax, 0
	mov	WORD PTR _edata$[ebp+eax], dx

; 1285 : 			edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 +
; 1286 : 			self->GetCampaignObject()->GetComponentIndex(self) + 1;		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	edx, DWORD PTR [eax+esi*4-3]
	mov	eax, 2
	shl	eax, 0
	mov	WORD PTR _edata$[ebp+eax], dx

; 1287 : 			edata[2] = -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1288 : 			edata[3] = -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 1289 : 			edata[4] = 1;

	mov	edx, 2
	shl	edx, 2
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1290 : 			AiMakeRadioResponse( self, rcUNABLE, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	219					; 000000dbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1291 : 			return;

	jmp	SHORT $LN25@AiDesignat
$LN2@AiDesignat:

; 1292 : 		}
; 1293 : 	}
; 1294 : 	else

	jmp	SHORT $LN25@AiDesignat
$LN23@AiDesignat:

; 1295 : 	{
; 1296 : 		mDesignatedObject = FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+800], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+804], eax

; 1297 : 		mpActionFlags[AI_ENGAGE_TARGET]	= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0
$LN25@AiDesignat:

; 1298 : 	}
; 1299 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiDesignateTarget@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiDesignateTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -40					; size = 4
_done$ = -36						; size = 4
_pWaypoint$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiRTB@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC	; DigitalBrain::AiRTB
; _this$ = ecx

; 2418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2419 : 	int	flightIdx;
; 2420 : 	short edata[10];
; 2421 : 	WayPointClass* pWaypoint = self->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _pWaypoint$[ebp], edx

; 2422 : 	BOOL	done = FALSE;

	mov	DWORD PTR _done$[ebp], 0

; 2423 : 
; 2424 : 	mpActionFlags[AI_ENGAGE_TARGET]		= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 2425 : 	mpActionFlags[AI_EXECUTE_MANEUVER]	= FALSE;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 2426 : 	mpActionFlags[AI_FOLLOW_FORMATION]	= FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 2427 : 	mpActionFlags[AI_RTB]					= TRUE;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 1
$LN9@AiRTB:

; 2428 : 
; 2429 : 	while(!done) {

	cmp	DWORD PTR _done$[ebp], 0
	jne	SHORT $LN8@AiRTB

; 2430 : 		if(pWaypoint) {

	cmp	DWORD PTR _pWaypoint$[ebp], 0
	je	SHORT $LN7@AiRTB

; 2431 : 			if(pWaypoint->GetWPAction() == WP_LAND) {

	mov	ecx, DWORD PTR _pWaypoint$[ebp]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 7
	jne	SHORT $LN6@AiRTB

; 2432 : 				// RV - Biker - When RTB go to WP before home base
; 2433 : 				self->curWaypoint = pWaypoint->GetPrevWP();

	mov	ecx, DWORD PTR _pWaypoint$[ebp]
	call	?GetPrevWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetPrevWP
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+728], eax

; 2434 : 				done = TRUE;

	mov	DWORD PTR _done$[ebp], 1

; 2435 : 			}
; 2436 : 			else {

	jmp	SHORT $LN5@AiRTB
$LN6@AiRTB:

; 2437 : 				pWaypoint = pWaypoint->GetNextWP();

	mov	ecx, DWORD PTR _pWaypoint$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _pWaypoint$[ebp], eax
$LN5@AiRTB:

; 2438 : 			}
; 2439 : 		}
; 2440 : 		else {

	jmp	SHORT $LN4@AiRTB
$LN7@AiRTB:

; 2441 : 			// unable
; 2442 : 			done = TRUE;

	mov	DWORD PTR _done$[ebp], 1
$LN4@AiRTB:

; 2443 : 		}
; 2444 : 	}

	jmp	SHORT $LN9@AiRTB
$LN8@AiRTB:

; 2445 : 
; 2446 : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2447 : 	AiSplitFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSplitFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiSplitFlight

; 2448 : 
; 2449 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@AiRTB

; 2450 : 		edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 2451 : 		if(!IsSetATC(SaidRTB))

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN2@AiRTB

; 2452 : 		{
; 2453 : 			SetATCFlag(SaidRTB);

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 2454 : 			AiMakeRadioResponse( self, rcIMADOT, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	97					; 00000061H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN2@AiRTB:

; 2455 : 		}
; 2456 : 		AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 2457 : 	}
; 2458 : 	else {

	jmp	SHORT $LN10@AiRTB
$LN3@AiRTB:

; 2459 : 		AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 2460 : 		AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN10@AiRTB:

; 2461 : 	}
; 2462 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiRTB@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP	; DigitalBrain::AiRTB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -40						; size = 8
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiRaygun@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiRaygun
; _this$ = ecx

; 2311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2312 : 	int	flightIdx;
; 2313 : 	short edata[10];
; 2314 :  
; 2315 : 	// set a radar flag here
; 2316 : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2317 : 
; 2318 : 	if(msg->dataBlock.newTarget == self->Id()) {	

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	add	ecx, 62					; 0000003eH
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@AiRaygun

; 2319 : 		edata[0] = -1;

	mov	eax, 2
	imul	eax, 0
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 2320 : 		edata[1] = flightIdx;

	mov	edx, 2
	shl	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 2321 :    	AiMakeRadioResponse( self, rcBUDDYSPIKE, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2322 : 	}
; 2323 : 	else  {

	jmp	SHORT $LN3@AiRaygun
$LN2@AiRaygun:

; 2324 : 		edata[0] = -1;

	mov	ecx, 2
	imul	ecx, 0
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2325 : 		edata[1] = CALLSIGN_NUM_OFFSET + flightIdx + 1;

	mov	eax, DWORD PTR _flightIdx$[ebp]
	add	eax, 37					; 00000025H
	mov	ecx, 2
	shl	ecx, 0
	mov	WORD PTR _edata$[ebp+ecx], ax

; 2326 : 		edata[2] = -1;

	mov	edx, 2
	shl	edx, 1
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 2327 : 		edata[3] = -1;

	mov	ecx, 2
	imul	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 2328 :   		edata[4] = 1;

	mov	eax, 2
	shl	eax, 2
	mov	ecx, 1
	mov	WORD PTR _edata$[ebp+eax], cx

; 2329 :  		AiMakeRadioResponse( self, rcUNABLE, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	219					; 000000dbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN3@AiRaygun:

; 2330 : 	}
; 2331 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiRaygun@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiRaygun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiBuddySpikeReact@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiBuddySpikeReact
; _this$ = ecx

; 2339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2340 : 	int	flightIdx;
; 2341 : 	short edata[10];
; 2342 :  
; 2343 : 	// set a radar flag here
; 2344 : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2345 : 
; 2346 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiBuddySpi

; 2347 : 		edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 2348 : 		edata[1] = 1;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 2349 :    	AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2350 : 	}
; 2351 : 	else {

	jmp	SHORT $LN3@AiBuddySpi
$LN2@AiBuddySpi:

; 2352 : 		AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN3@AiBuddySpi:

; 2353 : 	}
; 2354 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiBuddySpikeReact@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiBuddySpikeReact
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -36					; size = 4
_theRadar$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiSetRadarStby@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiSetRadarStby
; _this$ = ecx

; 2390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2391 : int	flightIdx;
; 2392 : short edata[10];
; 2393 : RadarClass* theRadar = (RadarClass*)FindSensor(self, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 2394 : 
; 2395 :    // Make sure the radar is off
; 2396 :    if (theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN3@AiSetRadar

; 2397 :    {
; 2398 :       theRadar->SetEmitting(FALSE);

	push	0
	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx
$LN3@AiSetRadar:

; 2399 :    }
; 2400 : 	
; 2401 : 	// clear a radar flag here
; 2402 : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2403 : 
; 2404 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiSetRadar

; 2405 : 		edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 2406 : 		edata[1] = 1;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 2407 :    	AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2408 : 	}
; 2409 : 	else {

	jmp	SHORT $LN4@AiSetRadar
$LN2@AiSetRadar:

; 2410 : 		AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN4@AiSetRadar:

; 2411 : 	}
; 2412 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiSetRadarStby@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiSetRadarStby
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -36					; size = 4
_theRadar$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiSetRadarActive@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiSetRadarActive
; _this$ = ecx

; 2362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2363 : int	flightIdx;
; 2364 : short edata[10];
; 2365 : RadarClass* theRadar = (RadarClass*)FindSensor(self, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 2366 : 
; 2367 :    // Make sure the radar is on
; 2368 :    if (theRadar)

	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN3@AiSetRadar

; 2369 :    {
; 2370 :       theRadar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _theRadar$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _theRadar$[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx
$LN3@AiSetRadar:

; 2371 :    }
; 2372 : 
; 2373 : 	// set a radar flag here
; 2374 : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 2375 : 
; 2376 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiSetRadar

; 2377 : 		edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 2378 : 		edata[1] = 1;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 2379 :    	AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 2380 : 	}
; 2381 : 	else {

	jmp	SHORT $LN4@AiSetRadar
$LN2@AiSetRadar:

; 2382 : 		AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN4@AiSetRadar:

; 2383 : 	}
; 2384 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiSetRadarActive@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiSetRadarActive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T2 = -128						; size = 8
$T3 = -120						; size = 8
$T4 = -112						; size = 4
$T5 = -108						; size = 4
_theTanker$6 = -104					; size = 4
$T7 = -100						; size = 4
tv248 = -96						; size = 4
tv278 = -92						; size = 4
tv282 = -88						; size = 4
$T8 = -84						; size = 4
tv255 = -80						; size = 4
_flightIdx$ = -76					; size = 4
_wlistUs$ = -72						; size = 4
_TankerMsg$9 = -68					; size = 4
_wlistLead$ = -64					; size = 4
_this$ = -60						; size = 4
_edata$ = -56						; size = 20
_edata$10 = -36						; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_msg$ = 8						; size = 4
_hint$ = 12						; size = 4
?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z PROC ; DigitalBrain::AiRejoin
; _this$ = ecx

; 1045 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1046 : 	short edata[10];
; 1047 : 	int	flightIdx;
; 1048 : 
; 1049 : 	//we can't rejoin if we're on the ground still!
; 1050 : 	if(self->OnGround() || atcstatus >= lOnFinal)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN13@AiRejoin
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+328], 11			; 0000000bH
	jl	SHORT $LN14@AiRejoin
$LN13@AiRejoin:

; 1051 : 		return;

	jmp	$LN15@AiRejoin
$LN14@AiRejoin:

; 1052 : 
; 1053 : 	AiCheckPosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckPosition@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckPosition

; 1054 : //	mInPositionFlag = FALSE;
; 1055 : 
; 1056 : 	mpActionFlags[AI_ENGAGE_TARGET]		= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 1057 : 	mpActionFlags[AI_EXECUTE_MANEUVER]	= FALSE;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 1058 : 	mpActionFlags[AI_FOLLOW_FORMATION]	= TRUE;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 1

; 1059 : 	mpActionFlags[AI_RTB]					= FALSE;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 1060 : 	mpActionFlags[AI_LANDING]				= FALSE;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 1061 : 
; 1062 : 	SendATCMsg(noATC);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendATCMsg@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SendATCMsg

; 1063 : 	atcstatus = noATC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 0

; 1064 : 	// cancel atc here
; 1065 : 
; 1066 : // 2001-07-11 ADDED BY S.G. NEED TO SET THE SAME WAYPOINT AS THE LEAD ONCE WE REJOIN...
; 1067 : 	WayPointClass* wlistUs   = self->waypoint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _wlistUs$[ebp], edx

; 1068 : 	WayPointClass* wlistLead = NULL;

	mov	DWORD PTR _wlistLead$[ebp], 0

; 1069 : 	if (flightLead)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN12@AiRejoin

; 1070 : 		wlistLead = ((AircraftClass *)flightLead)->waypoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+708]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR _wlistLead$[ebp], eax
$LN12@AiRejoin:

; 1071 : 
; 1072 : 	// This will set our current waypoint to the leads waypoint
; 1073 : // 2001-10-20 Modified by M.N. Added ->GetNextWP() to assure that we get a valid waypoint
; 1074 : 	while (wlistUs->GetNextWP() && wlistLead && wlistLead->GetNextWP() && wlistLead != ((AircraftClass *)flightLead)->curWaypoint) {

	mov	ecx, DWORD PTR _wlistUs$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN10@AiRejoin
	cmp	DWORD PTR _wlistLead$[ebp], 0
	je	SHORT $LN10@AiRejoin
	mov	ecx, DWORD PTR _wlistLead$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	test	eax, eax
	je	SHORT $LN10@AiRejoin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+708]
	mov	eax, DWORD PTR _wlistLead$[ebp]
	cmp	eax, DWORD PTR [edx+728]
	je	SHORT $LN10@AiRejoin

; 1075 : 		wlistUs   = wlistUs->GetNextWP();

	mov	ecx, DWORD PTR _wlistUs$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wlistUs$[ebp], eax

; 1076 : 		wlistLead = wlistLead->GetNextWP();

	mov	ecx, DWORD PTR _wlistLead$[ebp]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	DWORD PTR _wlistLead$[ebp], eax

; 1077 : 	}

	jmp	SHORT $LN12@AiRejoin
$LN10@AiRejoin:

; 1078 : 	self->curWaypoint = wlistUs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _wlistUs$[ebp]
	mov	DWORD PTR [edx+728], eax

; 1079 : // END OF ADDED SECTION
; 1080 : 
; 1081 : 	rwIndex										= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 0

; 1082 : 	self->af->gearHandle					= -1.0F; //up

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1556], xmm0

; 1083 : 
; 1084 : 	mpActionFlags[AI_USE_COMPLEX]       = FALSE;

	mov	edx, 4
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 1085 : 
; 1086 : 	mpSearchFlags[AI_FIXATE_ON_TARGET]	= FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 0

; 1087 : 
; 1088 : 	AiClearManeuver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearManeuver@DigitalBrain@@AAEXXZ	; DigitalBrain::AiClearManeuver

; 1089 : 
; 1090 : 	mFormLateralSpaceFactor = 1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+904], xmm0

; 1091 : 	mFormSide					= 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+900], 1

; 1092 : 	mFormRelativeAltitude	= 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+896], xmm0

; 1093 : 	mDesignatedObject			= FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+800], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+804], edx

; 1094 : 
; 1095 : // 2001-05-22 ADDED BY S.G. NEED TO TELL AI TO STOP THEIR GROUND ATTACK
; 1096 : 	agDoctrine = AGD_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+244], 0

; 1097 : 	SetGroundTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@DigitalBrain@@IAEXPAVFalconEntity@@@Z ; DigitalBrain::SetGroundTarget

; 1098 : // 2001-06-30 ADDED BY S.G. WHEN REJOINING, THE HasAGWeapon IS REFLECTED INTO HasCanUseAGWeapon SO IF THE LEAD WITH ONLY HARMS FIRED THEM AT A ENROUTE TARGET, WHEN SWITCHING TO THE ATTACK TARGET, HE DOESN'T ABORT THINKING NO ONE CAN FIRE ANYTHING...
; 1099 : // 2001-10-23 MODIFIED BY S.G. Only if the rejoin comes from the lead and not from yourself rejoining on your own so the lead doesn't think your HARMS can be used on the target you were bombing
; 1100 : 	if (hint == AI_REJOIN && IsSetATC(HasAGWeapon))

	cmp	DWORD PTR _hint$[ebp], 2
	jne	SHORT $LN9@AiRejoin
	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN9@AiRejoin

; 1101 : 		SetATCFlag(HasCanUseAGWeapon);

	push	536870912				; 20000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag
$LN9@AiRejoin:

; 1102 : // END OF ADDED SECTION
; 1103 : 
; 1104 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1105 : 
; 1106 : // 2002-03-10 MN when ordered AI to rejoin, rejoin immediately, not only when connected to the boom!
; 1107 : //	if(self->af->IsSet(Refueling)) {
; 1108 : 	if (refuelstatus != refNoTanker && refuelstatus !=refDone) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+348], 0
	je	$LN8@AiRejoin
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+348], 4
	je	$LN8@AiRejoin

; 1109 : 	{
; 1110 : 		VuEntity*				theTanker = vuDatabase->Find(tankerId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	push	ecx
	mov	edx, DWORD PTR [eax+352]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _theTanker$6[ebp], eax

; 1111 : 		FalconTankerMessage* TankerMsg;
; 1112 : 
; 1113 : 		if (theTanker)

	cmp	DWORD PTR _theTanker$6[ebp], 0
	je	$LN7@AiRejoin

; 1114 : 			TankerMsg	= new FalconTankerMessage (theTanker->Id(), FalconLocalGame);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN19@AiRejoin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@AiRejoin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv248[ebp], eax
	jmp	SHORT $LN18@AiRejoin
$LN17@AiRejoin:
	mov	DWORD PTR tv248[ebp], 0
$LN18@AiRejoin:
	push	1
	mov	ecx, DWORD PTR tv248[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _theTanker$6[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconTankerMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTankerMessage::FalconTankerMessage
	mov	DWORD PTR tv255[ebp], eax
	jmp	SHORT $LN20@AiRejoin
$LN19@AiRejoin:
	mov	DWORD PTR tv255[ebp], 0
$LN20@AiRejoin:
	mov	eax, DWORD PTR tv255[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _TankerMsg$9[ebp], ecx

; 1115 : 		else

	jmp	$LN6@AiRejoin
$LN7@AiRejoin:

; 1116 : 			TankerMsg	= new FalconTankerMessage (FalconNullId, FalconLocalGame);	

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN23@AiRejoin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@AiRejoin
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv278[ebp], eax
	jmp	SHORT $LN22@AiRejoin
$LN21@AiRejoin:
	mov	DWORD PTR tv278[ebp], 0
$LN22@AiRejoin:
	push	1
	mov	eax, DWORD PTR tv278[ebp]
	push	eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0FalconTankerMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconTankerMessage::FalconTankerMessage
	mov	DWORD PTR tv282[ebp], eax
	jmp	SHORT $LN24@AiRejoin
$LN23@AiRejoin:
	mov	DWORD PTR tv282[ebp], 0
$LN24@AiRejoin:
	mov	eax, DWORD PTR tv282[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _TankerMsg$9[ebp], ecx
$LN6@AiRejoin:

; 1117 : 	
; 1118 : 		TankerMsg->dataBlock.type		= FalconTankerMessage::DoneRefueling;

	mov	edx, DWORD PTR _TankerMsg$9[ebp]
	mov	DWORD PTR [edx+56], 2

; 1119 : 		TankerMsg->dataBlock.data1		= 1;

	mov	eax, DWORD PTR _TankerMsg$9[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+60], xmm0

; 1120 : 		TankerMsg->dataBlock.caller	= self->Id();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _TankerMsg$9[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 1121 : 		FalconSendMessage(TankerMsg);

	push	0
	mov	ecx, DWORD PTR _TankerMsg$9[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN8@AiRejoin:

; 1122 : 	}
; 1123 : 
; 1124 : 
; 1125 : 	// edg: can't msg be NULL?  It looks like some calls use it and I
; 1126 : 	// want to use this function to have the wingies return to formation
; 1127 : 	// after their AG attack is done.
; 1128 : 	if ( msg )

	cmp	DWORD PTR _msg$[ebp], 0
	je	SHORT $LN5@AiRejoin

; 1129 : 		AiGlueFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGlueFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiGlueFlight
$LN5@AiRejoin:

; 1130 : 
; 1131 : 	if(msg && AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	cmp	DWORD PTR _msg$[ebp], 0
	je	$LN4@AiRejoin
	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@AiRejoin

; 1132 : 		edata[0] = -1;

	mov	edx, 2
	imul	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1133 : 		edata[1] = -1;

	mov	ecx, 2
	shl	ecx, 0
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 1134 : 		edata[2]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	cx, BYTE PTR [eax+425]
	mov	edx, 2
	shl	edx, 1
	mov	WORD PTR _edata$[ebp+edx], cx

; 1135 : 		edata[3]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + flightIdx + 1;		

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	ecx, BYTE PTR [eax+426]
	mov	edx, DWORD PTR _flightIdx$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4-3]
	mov	ecx, 2
	imul	ecx, 3
	mov	WORD PTR _edata$[ebp+ecx], ax

; 1136 : 	 	AiMakeRadioResponse( self, rcONMYWAY, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
	jmp	$LN1@AiRejoin
$LN4@AiRejoin:

; 1137 : 	}
; 1138 : 	else if (hint == AI_TAKEOFF) { // JPO take the hint!

	cmp	DWORD PTR _hint$[ebp], 1
	jne	$LN2@AiRejoin

; 1139 : 	    short edata[10];
; 1140 : 	    
; 1141 : 	    edata[0] = ((FlightClass*) self->GetCampaignObject())->GetComponentIndex(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$10[ebp+edx], ax

; 1142 : 	    edata[1]	= -1;

	mov	eax, 2
	shl	eax, 0
	or	ecx, -1
	mov	WORD PTR _edata$10[ebp+eax], cx

; 1143 : 	    edata[2]	= -1;

	mov	edx, 2
	shl	edx, 1
	or	eax, -1
	mov	WORD PTR _edata$10[ebp+edx], ax

; 1144 : 	    edata[3]	= -1;

	mov	ecx, 2
	imul	ecx, 3
	or	edx, -1
	mov	WORD PTR _edata$10[ebp+ecx], dx

; 1145 : 	    edata[4]	= -1;

	mov	eax, 2
	shl	eax, 2
	or	ecx, -1
	mov	WORD PTR _edata$10[ebp+eax], cx

; 1146 : 	    edata[5]	= -1;

	mov	edx, 2
	imul	edx, 5
	or	eax, -1
	mov	WORD PTR _edata$10[ebp+edx], ax

; 1147 : 	    edata[6]	= -1;

	mov	ecx, 2
	imul	ecx, 6
	or	edx, -1
	mov	WORD PTR _edata$10[ebp+ecx], dx

; 1148 : 	    edata[7]	= -1;

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	WORD PTR _edata$10[ebp+eax], cx

; 1149 : 	    edata[8]	= -1;

	mov	edx, 2
	shl	edx, 3
	or	eax, -1
	mov	WORD PTR _edata$10[ebp+edx], ax

; 1150 : 	    edata[9]	= -1;	   

	mov	ecx, 2
	imul	ecx, 9
	or	edx, -1
	mov	WORD PTR _edata$10[ebp+ecx], dx

; 1151 : 	    AiMakeRadioResponse (self, rcLIFTOFF, edata);

	lea	eax, DWORD PTR _edata$10[ebp]
	push	eax
	push	109					; 0000006dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1152 : 	}
; 1153 : 	else {

	jmp	SHORT $LN1@AiRejoin
$LN2@AiRejoin:

; 1154 : 		AiRespondShortCallSign(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN1@AiRejoin:

; 1155 : 	}
; 1156 : // 2002-02-23 MN when ordered to rejoin, AI must make weapons safe
; 1157 : 	mWeaponsAction = AI_WEAPONS_HOLD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+828], 0
$LN15@AiRejoin:

; 1158 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z$1:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AiRejoin@DigitalBrain@@AAEXPAVFalconWingmanMsg@@W4AiHint@1@@Z ENDP ; DigitalBrain::AiRejoin
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_flightIdx$ = -32					; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiResumeFlightPlan@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiResumeFlightPlan
; _this$ = ecx

; 1011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1012 : 	int		flightIdx;
; 1013 : 	short		edata[10];
; 1014 : 	
; 1015 : 	mpActionFlags[AI_ENGAGE_TARGET]		= AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 1016 : 	mpActionFlags[AI_EXECUTE_MANEUVER]	= FALSE;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 1017 :    mpActionFlags[AI_RTB]               = FALSE;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 1018 : 
; 1019 : 	mpSearchFlags[AI_FIXATE_ON_TARGET]	= FALSE;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+784], 0

; 1020 : 	mpSearchFlags[AI_MONITOR_TARGET]		= FALSE;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+784], 0

; 1021 : 
; 1022 : 	mDesignatedType							= AI_NO_DESIGNATED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+820], 0

; 1023 : 	mWeaponsAction								= AI_WEAPONS_HOLD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+828], 0

; 1024 : 
; 1025 : 	AiClearManeuver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearManeuver@DigitalBrain@@AAEXXZ	; DigitalBrain::AiClearManeuver

; 1026 : 
; 1027 : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 1028 : 	AiGlueFlight(msg->dataBlock.to, msg->dataBlock.from, flightIdx);

	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiGlueFlight@DigitalBrain@@AAEXHVVU_ID@@H@Z ; DigitalBrain::AiGlueFlight

; 1029 : 
; 1030 : 	if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	eax, DWORD PTR _msg$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _flightIdx$[ebp]
	push	edx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@AiResumeFl

; 1031 : 		edata[0] = flightIdx;

	mov	eax, 2
	imul	eax, 0
	mov	cx, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+eax], cx

; 1032 : 		edata[1] = 1;

	mov	edx, 2
	shl	edx, 0
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax

; 1033 :    	AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 1034 : 	}
; 1035 : 	else {

	jmp	SHORT $LN3@AiResumeFl
$LN2@AiResumeFl:

; 1036 : 		AiRespondShortCallSign(self);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN3@AiResumeFl:

; 1037 : 	}
; 1038 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiResumeFlightPlan@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiResumeFlightPlan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_domain$ = 8						; size = 1
?AiSearchForTargets@DigitalBrain@@AAEXD@Z PROC		; DigitalBrain::AiSearchForTargets
; _this$ = ecx

; 998  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 999  : 	mSearchDomain = domain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _domain$[ebp]
	mov	BYTE PTR [eax+824], cl

; 1000 : // 2000-09-13 MODIFIED BY S.G. PRETTY USELESS LINE IF YOU ASK ME... NOT IN RP4
; 1001 : //	mpSearchFlags[AI_SEARCH_FOR_TARGET];
; 1002 : 	mpSearchFlags[AI_SEARCH_FOR_TARGET] = TRUE; // Cobra - try turning them loose

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+784], 1

; 1003 : 	mLastReportTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+884], 0

; 1004 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AiSearchForTargets@DigitalBrain@@AAEXD@Z ENDP		; DigitalBrain::AiSearchForTargets
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiGoCover@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiGoCover
; _this$ = ecx

; 974  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 975  : 
; 976  : 	mpActionFlags[AI_ENGAGE_TARGET]	  = AI_NONE; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 977  : 	mpActionFlags[AI_EXECUTE_MANEUVER] = FALSE;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 978  : 	mpActionFlags[AI_RTB]              = FALSE;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 979  :    mWeaponsAction                     = AI_WEAPONS_HOLD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 0

; 980  : 
; 981  : 	mpSearchFlags[AI_FIXATE_ON_TARGET] = FALSE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 0

; 982  : 	mpSearchFlags[AI_MONITOR_TARGET]	  = TRUE;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+784], 1

; 983  : 
; 984  : 	AiClearManeuver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearManeuver@DigitalBrain@@AAEXXZ	; DigitalBrain::AiClearManeuver

; 985  : // 2001-06-16 ADDED BY S.G. NEED TO GO BACK IN NAV MODE.
; 986  : 	if (self->AutopilotType() == AircraftClass::CombatAP || self->IsDigital()) // 2002-01-28 ADDED BY S.G But only if in CombatAP!!!

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN1@AiGoCover
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?IsDigital@AircraftClass@@QAEHXZ	; AircraftClass::IsDigital
	test	eax, eax
	je	SHORT $LN3@AiGoCover
$LN1@AiGoCover:

; 987  : 		self->FCC->SetMasterMode (FireControlComputer::Nav);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+936]
	call	?SetMasterMode@FireControlComputer@@QAEXW4FCCMasterMode@1@@Z ; FireControlComputer::SetMasterMode
$LN3@AiGoCover:

; 988  : // END OF ADDED SECTION
; 989  : 
; 990  : 	//MonoPrint("Going Cover\n");
; 991  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiGoCover@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiGoCover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiGoShooter@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiGoShooter
; _this$ = ecx

; 954  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 955  : 	if (mpActionFlags[AI_ENGAGE_TARGET] == AI_NONE) // 2002-03-04 ADDED BY S.G. Change it if not already set, assume an air target (can't tell)

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax+760], 0
	jne	SHORT $LN1@AiGoShoote

; 956  : 		mpActionFlags[AI_ENGAGE_TARGET]	= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 1
$LN1@AiGoShoote:

; 957  : 	mpActionFlags[AI_EXECUTE_MANEUVER]	= FALSE;

	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 958  : 	mWeaponsAction						= AI_WEAPONS_FREE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+828], 1

; 959  : 
; 960  : 	mpSearchFlags[AI_FIXATE_ON_TARGET]	= TRUE;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+784], 1

; 961  : 	mpSearchFlags[AI_MONITOR_TARGET]	= FALSE;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+784], 0

; 962  : 	mpActionFlags[AI_RTB]               = FALSE;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 963  : 
; 964  : 	AiClearManeuver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiClearManeuver@DigitalBrain@@AAEXXZ	; DigitalBrain::AiClearManeuver

; 965  : 
; 966  : 	//MonoPrint("Going Shooter\n");
; 967  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiGoShooter@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiGoShooter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv155 = -12						; size = 4
tv142 = -8						; size = 4
_this$ = -4						; size = 4
?AiBreakRight@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiBreakRight
; _this$ = ecx

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 502  : 	MonoPrint("\tin AiBreakRight\n");

	push	OFFSET ??_C@_0BC@NKAFKGNH@?7in?5AiBreakRight?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 503  : 
; 504  : 	AiSetManeuver(FalconWingmanMsg::WMBreakRight);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 505  : 	mHeadingOrdered	= self->Yaw() + 90.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv142[ebp]
	movss	xmm0, DWORD PTR tv142[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+844], xmm0

; 506  : 	if(mHeadingOrdered > 180.0F * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+844]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN1@AiBreakRig

; 507  : 		mHeadingOrdered -= 360.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+844]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+844], xmm0
$LN1@AiBreakRig:

; 508  : 	}
; 509  : 
; 510  : 	mSpeedOrdered		= self->GetVt() * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv155[ebp]
	movss	xmm0, DWORD PTR tv155[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 511  :    mAltitudeOrdered	= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]

; 512  : 	mnverTime			= 15.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [ecx+508], xmm0

; 513  : 
; 514  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiBreakRight@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiBreakRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv155 = -12						; size = 4
tv142 = -8						; size = 4
_this$ = -4						; size = 4
?AiBreakLeft@DigitalBrain@@AAEXXZ PROC			; DigitalBrain::AiBreakLeft
; _this$ = ecx

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 480  : 
; 481  : 	MonoPrint("\tin AiBreakLeft\n");

	push	OFFSET ??_C@_0BB@GFNLAJJG@?7in?5AiBreakLeft?6?$AA@
	call	_MonoPrint
	add	esp, 4

; 482  : 
; 483  : 	AiSetManeuver(FalconWingmanMsg::WMBreakLeft);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 484  : 	mHeadingOrdered	= self->Yaw() - 90.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv142[ebp]
	movss	xmm0, DWORD PTR tv142[ebp]
	subss	xmm0, DWORD PTR __real@3fc90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+844], xmm0

; 485  : 	if(mHeadingOrdered <= -180.0F * DTR) {

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [edx+844]
	jb	SHORT $LN1@AiBreakLef

; 486  : 		mHeadingOrdered += 360.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+844]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+844], xmm0
$LN1@AiBreakLef:

; 487  : 	}
; 488  : 
; 489  : 	mSpeedOrdered		= self->GetVt() * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv155[ebp]
	movss	xmm0, DWORD PTR tv155[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 490  :    mAltitudeOrdered	= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]

; 491  : 	mnverTime			= 15.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [ecx+508], xmm0

; 492  : 
; 493  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiBreakLeft@DigitalBrain@@AAEXXZ ENDP			; DigitalBrain::AiBreakLeft
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
tv315 = -100						; size = 4
tv251 = -96						; size = 4
tv291 = -92						; size = 4
tv256 = -88						; size = 4
tv319 = -84						; size = 4
_xdiff$ = -80						; size = 4
tv286 = -76						; size = 4
tv317 = -72						; size = 4
tv266 = -68						; size = 4
tv242 = -64						; size = 4
_ydiff$ = -60						; size = 4
tv247 = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -48						; size = 4
_angle$ = -44						; size = 4
_navangle$ = -40					; size = 4
_rz$ = -36						; size = 4
_ptgt$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_threat$ = 8						; size = 8
?AiEngageThreatAtSix@DigitalBrain@@AAEXVVU_ID@@@Z PROC	; DigitalBrain::AiEngageThreatAtSix
; _this$ = ecx

; 361  : void DigitalBrain::AiEngageThreatAtSix(VU_ID threat) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 
; 363  : 	short edata[10];
; 364  : 	AircraftClass*		ptgt;
; 365  : 	int					navangle;
; 366  : 	float					angle;
; 367  : 	float					xdiff, ydiff;
; 368  : 	float					rz;
; 369  : 
; 370  : 	mDesignatedObject							= threat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _threat$[ebp]
	mov	DWORD PTR [eax+800], ecx
	mov	edx, DWORD PTR _threat$[ebp+4]
	mov	DWORD PTR [eax+804], edx

; 371  :    mpActionFlags[AI_ENGAGE_TARGET]		= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 1

; 372  : 	AiSaveWeaponState();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSaveWeaponState@DigitalBrain@@AAEXXZ	; DigitalBrain::AiSaveWeaponState

; 373  : 	mWeaponsAction								= AI_WEAPONS_FREE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+828], 1

; 374  : 
; 375  : 	AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 376  : 
; 377  : 
; 378  : 	ptgt		= (AircraftClass*) vuDatabase->Find(mDesignatedObject);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	push	ecx
	mov	edx, DWORD PTR [eax+800]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ptgt$[ebp], eax

; 379  : 
; 380  : 	if (ptgt)

	cmp	DWORD PTR _ptgt$[ebp], 0
	je	$LN9@AiEngageTh

; 381  : 	{
; 382  : 		edata[0] = 2 * (ptgt->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	lea	ecx, DWORD PTR [eax+eax-200]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 383  : 
; 384  : 
; 385  : 		xdiff = ptgt->XPos() - self->XPos();

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv242[ebp]
	movss	xmm0, DWORD PTR tv242[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	DWORD PTR tv315[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv247[ebp]
	movss	xmm0, DWORD PTR tv315[ebp]
	subss	xmm0, DWORD PTR tv247[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 386  : 		ydiff = ptgt->YPos() - self->YPos();

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv251[ebp]
	movss	xmm0, DWORD PTR tv251[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv317[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv256[ebp]
	movss	xmm0, DWORD PTR tv317[ebp]
	subss	xmm0, DWORD PTR tv256[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 387  : 
; 388  : 		angle = (float)atan2(ydiff, xdiff);

	cvtss2sd xmm0, DWORD PTR _xdiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ydiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _angle$[ebp]

; 389  : 		angle = angle - self->Yaw();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv266[ebp]
	movss	xmm0, DWORD PTR _angle$[ebp]
	subss	xmm0, DWORD PTR tv266[ebp]
	movss	DWORD PTR _angle$[ebp], xmm0

; 390  : 		navangle	=  FloatToInt32 (RTD * angle);

	movss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR _angle$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _navangle$[ebp], eax

; 391  : 		if(navangle < 0) {

	cmp	DWORD PTR _navangle$[ebp], 0
	jge	SHORT $LN8@AiEngageTh

; 392  : 			navangle = 360 + navangle;

	mov	eax, DWORD PTR _navangle$[ebp]
	add	eax, 360				; 00000168H
	mov	DWORD PTR _navangle$[ebp], eax
$LN8@AiEngageTh:

; 393  : 		}
; 394  : 
; 395  : 		edata[1] = navangle / 30;									// scale compass angle for radio eData

	mov	eax, DWORD PTR _navangle$[ebp]
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], ax

; 396  : 		if(edata[1] >= 12) {

	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR _edata$[ebp+eax]
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LN7@AiEngageTh

; 397  : 			edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN12@AiEngageTh
	jmp	SHORT $LN13@AiEngageTh
$LN12@AiEngageTh:
	call	___report_rangecheckfailure
$LN13@AiEngageTh:
	xor	edx, edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN7@AiEngageTh:

; 398  : 		}
; 399  : 
; 400  : 		rz = ptgt->ZPos() - self->ZPos();

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv286[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	movss	DWORD PTR tv319[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv291[ebp]
	movss	xmm0, DWORD PTR tv319[ebp]
	subss	xmm0, DWORD PTR tv291[ebp]
	movss	DWORD PTR _rz$[ebp], xmm0

; 401  : 
; 402  : 		if(rz < 300.0F && rz > -300.0F) {							// check relative alt and select correct frag

	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN6@AiEngageTh
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c3960000
	jbe	SHORT $LN6@AiEngageTh

; 403  : 			edata[2] = 1;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 1
	mov	WORD PTR _edata$[ebp+edx], ax
	jmp	SHORT $LN1@AiEngageTh
$LN6@AiEngageTh:

; 404  : 		}
; 405  : 		else if(rz < -300.0F && rz > -1000.0F) {

	movss	xmm0, DWORD PTR __real@c3960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN4@AiEngageTh
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c47a0000
	jbe	SHORT $LN4@AiEngageTh

; 406  : 			edata[2] = 2;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	SHORT $LN1@AiEngageTh
$LN4@AiEngageTh:

; 407  : 		}	
; 408  : 		else if(rz < -1000.0F) {

	movss	xmm0, DWORD PTR __real@c47a0000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN2@AiEngageTh

; 409  : 			edata[2] = 3;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 3
	mov	WORD PTR _edata$[ebp+eax], cx

; 410  : 		}
; 411  : 		else {

	jmp	SHORT $LN1@AiEngageTh
$LN2@AiEngageTh:

; 412  : 			edata[2] = 0;

	mov	edx, 2
	shl	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN14@AiEngageTh
	jmp	SHORT $LN15@AiEngageTh
$LN14@AiEngageTh:
	call	___report_rangecheckfailure
$LN15@AiEngageTh:
	xor	eax, eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+ecx], ax
$LN1@AiEngageTh:

; 413  : 		}
; 414  : 
; 415  : 		AiMakeRadioResponse( self, rcENGAGINGC, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	63					; 0000003fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN9@AiEngageTh:
$LN10@AiEngageTh:

; 416  : 	}
; 417  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?AiEngageThreatAtSix@DigitalBrain@@AAEXVVU_ID@@@Z ENDP	; DigitalBrain::AiEngageThreatAtSix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
$T1 = -60						; size = 8
_az$ = -52						; size = 4
_pfrom$ = -48						; size = 4
_direction$ = -44					; size = 4
_flightIdx$ = -40					; size = 4
_threat$ = -36						; size = 8
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiCheckOwnSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiCheckOwnSix
; _this$ = ecx

; 427  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 428  : 
; 429  : 	int	flightIdx;
; 430  : 	short edata[10];
; 431  : 	float	az;
; 432  : 	VU_ID threat;

	lea	ecx, DWORD PTR _threat$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 433  : 	int	direction;
; 434  : 	AircraftClass*		pfrom;
; 435  : 
; 436  : 	flightIdx	= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 437  : 	pfrom			= (AircraftClass*) vuDatabase->Find(msg->dataBlock.from);

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _pfrom$[ebp], eax

; 438  : 
; 439  : 	AiSaveSetSearchDomain(DOMAIN_AIR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSaveSetSearchDomain@DigitalBrain@@AAEXD@Z ; DigitalBrain::AiSaveSetSearchDomain

; 440  : 	threat		= AiCheckForThreat(self, DOMAIN_AIR, 1, &az);

	lea	eax, DWORD PTR _az$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?AiCheckForThreat@@YA?AVVU_ID@@PAVAircraftClass@@DHPAM@Z ; AiCheckForThreat
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _threat$[ebp], ecx
	mov	DWORD PTR _threat$[ebp+4], edx

; 441  : 
; 442  : 	if(threat == FalconNullId) {

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	ecx, DWORD PTR _threat$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	$LN6@AiCheckOwn

; 443  : 
; 444  : 		direction = 2 * FloatToInt32((float)rand() / (float)RAND_MAX);

	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	shl	eax, 1
	mov	DWORD PTR _direction$[ebp], eax

; 445  : 		
; 446  : 		if(direction) {

	je	SHORT $LN5@AiCheckOwn

; 447  : 			AiSetManeuver(FalconWingmanMsg::WMBreakRight);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 448  : 		}
; 449  : 		else {

	jmp	SHORT $LN4@AiCheckOwn
$LN5@AiCheckOwn:

; 450  : 			AiSetManeuver(FalconWingmanMsg::WMBreakLeft);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver
$LN4@AiCheckOwn:

; 451  : 		}
; 452  : 
; 453  : 
; 454  : 		if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	ecx, DWORD PTR _msg$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _flightIdx$[ebp]
	push	eax
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	$LN3@AiCheckOwn

; 455  : 			edata[0]	= ((FlightClass*)self->GetCampaignObject())->callsign_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	dx, BYTE PTR [eax+425]
	mov	eax, 2
	imul	eax, 0
	mov	WORD PTR _edata$[ebp+eax], dx

; 456  : 			edata[1]	= (((FlightClass*)self->GetCampaignObject())->callsign_num - 1) * 4 + self->GetCampaignObject()->GetComponentIndex(self) + 1;		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	movzx	esi, BYTE PTR [eax+426]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	lea	edx, DWORD PTR [eax+esi*4-3]
	mov	eax, 2
	shl	eax, 0
	mov	WORD PTR _edata$[ebp+eax], dx

; 457  : 			edata[2] = -1;

	mov	ecx, 2
	shl	ecx, 1
	or	edx, -1
	mov	WORD PTR _edata$[ebp+ecx], dx

; 458  : 			edata[3] = -1;

	mov	eax, 2
	imul	eax, 3
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 459  :    		AiMakeRadioResponse( self, rcCOPY, edata );

	lea	edx, DWORD PTR _edata$[ebp]
	push	edx
	push	101					; 00000065H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 460  : 			AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 461  : 		}
; 462  : 		else {

	jmp	SHORT $LN2@AiCheckOwn
$LN3@AiCheckOwn:

; 463  : 			AiRespondShortCallSign(self);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiRespondShortCallSign@@YAXPAVAircraftClass@@@Z ; AiRespondShortCallSign
	add	esp, 4
$LN2@AiCheckOwn:

; 464  : 		}
; 465  : 	}
; 466  : 	else {

	jmp	SHORT $LN1@AiCheckOwn
$LN6@AiCheckOwn:

; 467  : 		AiEngageThreatAtSix(threat);

	mov	ecx, DWORD PTR _threat$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _threat$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiEngageThreatAtSix@DigitalBrain@@AAEXVVU_ID@@@Z ; DigitalBrain::AiEngageThreatAtSix
$LN1@AiCheckOwn:

; 468  : 	}
; 469  : 	
; 470  : 	AiRestoreSearchDomain();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiRestoreSearchDomain@DigitalBrain@@AAEXXZ ; DigitalBrain::AiRestoreSearchDomain

; 471  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiCheckOwnSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiCheckOwnSix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_trig$ = -176						; size = 8
tv544 = -168						; size = 4
tv458 = -164						; size = 4
tv573 = -160						; size = 4
tv618 = -156						; size = 4
tv484 = -152						; size = 4
tv650 = -148						; size = 4
tv548 = -144						; size = 4
tv614 = -140						; size = 4
tv453 = -136						; size = 4
tv594 = -132						; size = 4
tv464 = -128						; size = 4
_ydiff$ = -124						; size = 4
_random$ = -120						; size = 4
_xdiff$ = -116						; size = 4
tv644 = -112						; size = 4
tv585 = -108						; size = 4
tv536 = -104						; size = 4
tv648 = -100						; size = 4
tv532 = -96						; size = 4
tv581 = -92						; size = 4
tv470 = -88						; size = 4
tv577 = -84						; size = 4
tv646 = -80						; size = 4
tv642 = -76						; size = 4
_flightIdx$ = -72					; size = 4
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
_angle$ = -56						; size = 4
_ypos$ = -52						; size = 4
_xpos$ = -48						; size = 4
_navangle$ = -44					; size = 4
_rz$ = -40						; size = 4
_ptgt$ = -36						; size = 4
_pfrom$ = -32						; size = 4
_this$ = -28						; size = 4
_edata$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
?AiClearLeadersSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z PROC ; DigitalBrain::AiClearLeadersSix
; _this$ = ecx

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 
; 239  : 	int					flightIdx;
; 240  : 	short					edata[10];
; 241  : 	AircraftClass*		pfrom;
; 242  : 	AircraftClass*		ptgt;
; 243  : 	mlTrig				trig;
; 244  : 	float					xpos;
; 245  : 	float					ypos;
; 246  : 	float					rz;
; 247  : 	int					navangle;
; 248  : 	float					angle;
; 249  : 	float					xdiff, ydiff;
; 250  : 	int					random;
; 251  : 
; 252  : 	flightIdx		= self->GetCampaignObject()->GetComponentIndex(self);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	DWORD PTR _flightIdx$[ebp], eax

; 253  : 	pfrom				= (AircraftClass*) vuDatabase->Find(msg->dataBlock.from);

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _pfrom$[ebp], eax

; 254  : 
; 255  : 	if(msg->dataBlock.newTarget == FalconNullId) {

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _msg$[ebp]
	add	ecx, 62					; 0000003eH
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	$LN19@AiClearLea

; 256  : 
; 257  : 		// angles of the aircraft we are clearing
; 258  : 		mlSinCos(&trig, pfrom->Yaw());

	mov	ecx, DWORD PTR _pfrom$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 259  : 
; 260  : 		xpos	= pfrom->XPos() - trig.cos * 1000.0F;	// 1000 feet behind aircraft we are clearing

	mov	ecx, DWORD PTR _pfrom$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv453[ebp]
	movss	xmm0, DWORD PTR tv453[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR __real@447a0000
	subss	xmm0, xmm1
	movss	DWORD PTR _xpos$[ebp], xmm0

; 261  : 		ypos	= pfrom->YPos() - trig.sin * 1000.0F;

	mov	ecx, DWORD PTR _pfrom$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv458[ebp]
	movss	xmm0, DWORD PTR tv458[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR __real@447a0000
	subss	xmm0, xmm1
	movss	DWORD PTR _ypos$[ebp], xmm0

; 262  : 
; 263  : 		xpos	= xpos - self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv464[ebp]
	movss	xmm0, DWORD PTR _xpos$[ebp]
	subss	xmm0, DWORD PTR tv464[ebp]
	movss	DWORD PTR _xpos$[ebp], xmm0

; 264  : 		ypos	= ypos - self->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv470[ebp]
	movss	xmm0, DWORD PTR _ypos$[ebp]
	subss	xmm0, DWORD PTR tv470[ebp]
	movss	DWORD PTR _ypos$[ebp], xmm0

; 265  : 		
; 266  : 		mHeadingOrdered	= (float)atan2(xpos, ypos);

	cvtss2sd xmm0, DWORD PTR _ypos$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _xpos$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+844]

; 267  : 
; 268  : 		mSpeedOrdered		= self->GetVt() * FTPSEC_TO_KNOTS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv484[ebp]
	movss	xmm0, DWORD PTR tv484[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+852], xmm0

; 269  : 		mAltitudeOrdered	= self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+848]

; 270  : 		mnverTime			= 15.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [ecx+508], xmm0

; 271  : 
; 272  : 		AiSetManeuver(FalconWingmanMsg::WMClearSix);

	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSetManeuver@DigitalBrain@@AAEXH@Z	; DigitalBrain::AiSetManeuver

; 273  : 
; 274  : 		if(AiIsFullResponse(flightIdx, msg->dataBlock.to)) {

	mov	edx, DWORD PTR _msg$[ebp]
	movsx	eax, WORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _flightIdx$[ebp]
	push	ecx
	call	?AiIsFullResponse@@YAHHH@Z		; AiIsFullResponse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@AiClearLea

; 275  : 			edata[0] = flightIdx;

	mov	edx, 2
	imul	edx, 0
	mov	ax, WORD PTR _flightIdx$[ebp]
	mov	WORD PTR _edata$[ebp+edx], ax

; 276  : 			edata[1] = 2;

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 2
	mov	WORD PTR _edata$[ebp+ecx], dx

; 277  :    		AiMakeRadioResponse( self, rcROGER, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	179					; 000000b3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 278  : 			AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 279  : 		}
; 280  : 		else {

	jmp	SHORT $LN17@AiClearLea
$LN18@AiClearLea:

; 281  : 			edata[0] = -1;

	mov	eax, 2
	imul	eax, 0
	or	ecx, -1
	mov	WORD PTR _edata$[ebp+eax], cx

; 282  : 			edata[1] = -1;

	mov	edx, 2
	shl	edx, 0
	or	eax, -1
	mov	WORD PTR _edata$[ebp+edx], ax

; 283  :    		AiMakeRadioResponse( self, rcROGER, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	179					; 000000b3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 284  : 			AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip
$LN17@AiClearLea:

; 285  : 		}
; 286  : 
; 287  : 	}
; 288  : 	else {

	jmp	$LN15@AiClearLea
$LN19@AiClearLea:

; 289  : 
; 290  : 		AiCheckFormStrip();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiCheckFormStrip@DigitalBrain@@AAEXXZ	; DigitalBrain::AiCheckFormStrip

; 291  : 
; 292  : 	   mDesignatedObject							= msg->dataBlock.newTarget;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx+62]
	mov	eax, DWORD PTR [ecx+66]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+800], edx
	mov	DWORD PTR [ecx+804], eax

; 293  : 		ptgt		= (AircraftClass*) vuDatabase->Find(mDesignatedObject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+804]
	push	eax
	mov	ecx, DWORD PTR [edx+800]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _ptgt$[ebp], eax

; 294  : 
; 295  : 		if (ptgt && pfrom && !F4IsBadReadPtr(ptgt, sizeof(AircraftClass)) && !F4IsBadReadPtr(pfrom, sizeof(AircraftClass))) // JB 010318 CTD

	cmp	DWORD PTR _ptgt$[ebp], 0
	je	$LN15@AiClearLea
	cmp	DWORD PTR _pfrom$[ebp], 0
	je	$LN15@AiClearLea
	push	3624					; 00000e28H
	mov	edx, DWORD PTR _ptgt$[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	$LN15@AiClearLea
	push	3624					; 00000e28H
	mov	ecx, DWORD PTR _pfrom$[ebp]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	$LN15@AiClearLea

; 296  : 		{
; 297  : 			if(ptgt->ZPos() - pfrom->ZPos() < -500.0F) {

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv532[ebp]
	movss	xmm0, DWORD PTR tv532[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv642[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv536[ebp]
	movss	xmm0, DWORD PTR tv642[ebp]
	subss	xmm0, DWORD PTR tv536[ebp]
	movss	xmm1, DWORD PTR __real@c3fa0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@AiClearLea

; 298  : 				edata[0] = 7;	// break low

	mov	eax, 2
	imul	eax, 0
	mov	ecx, 7
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	$LN9@AiClearLea
$LN14@AiClearLea:

; 299  : 			}
; 300  : 			else if(ptgt->ZPos() - pfrom->ZPos() > 500.0F) {

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv544[ebp]
	movss	xmm0, DWORD PTR tv544[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv644[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv548[ebp]
	movss	xmm0, DWORD PTR tv644[ebp]
	subss	xmm0, DWORD PTR tv548[ebp]
	comiss	xmm0, DWORD PTR __real@43fa0000
	jbe	SHORT $LN12@AiClearLea

; 301  : 				edata[0] = 6; // break hi

	mov	edx, 2
	imul	edx, 0
	mov	eax, 6
	mov	WORD PTR _edata$[ebp+edx], ax

; 302  : 			}
; 303  : 			else {

	jmp	SHORT $LN9@AiClearLea
$LN12@AiClearLea:

; 304  : 				random = 2 * FloatToInt32((float)rand() / (float)RAND_MAX);

	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	shl	eax, 1
	mov	DWORD PTR _random$[ebp], eax

; 305  : 				if(random) {

	je	SHORT $LN10@AiClearLea

; 306  : 					edata[0] = 0; // break hi

	mov	ecx, 2
	imul	ecx, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 20			; 00000014H
	jae	SHORT $LN22@AiClearLea
	jmp	SHORT $LN23@AiClearLea
$LN22@AiClearLea:
	call	___report_rangecheckfailure
$LN23@AiClearLea:
	xor	edx, edx
	mov	eax, DWORD PTR $T3[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx

; 307  : 				}
; 308  : 				else {

	jmp	SHORT $LN9@AiClearLea
$LN10@AiClearLea:

; 309  : 					edata[0] = 3; // break hi

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, 3
	mov	WORD PTR _edata$[ebp+ecx], dx
$LN9@AiClearLea:

; 310  : 				}
; 311  : 			}
; 312  : 	  		AiMakeRadioResponse( self, rcBREAK, edata );

	lea	eax, DWORD PTR _edata$[ebp]
	push	eax
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH

; 313  : 
; 314  : 		
; 315  :    		mpActionFlags[AI_ENGAGE_TARGET]		= AI_AIR_TARGET; // 2002-03-04 MODIFIED BY S.G. Use new enum type

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 1

; 316  : 			AiSaveWeaponState();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AiSaveWeaponState@DigitalBrain@@AAEXXZ	; DigitalBrain::AiSaveWeaponState

; 317  : 			mWeaponsAction								= AI_WEAPONS_FREE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+828], 1

; 318  : 
; 319  : 
; 320  : 			edata[0] = 2 * (ptgt->Type() - VU_LAST_ENTITY_TYPE);

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	lea	ecx, DWORD PTR [eax+eax-200]
	mov	edx, 2
	imul	edx, 0
	mov	WORD PTR _edata$[ebp+edx], cx

; 321  : 
; 322  : 			// convert to compass angle
; 323  : 
; 324  : 			xdiff = ptgt->XPos() - pfrom->XPos();

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv573[ebp]
	movss	xmm0, DWORD PTR tv573[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv646[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv577[ebp]
	movss	xmm0, DWORD PTR tv646[ebp]
	subss	xmm0, DWORD PTR tv577[ebp]
	movss	DWORD PTR _xdiff$[ebp], xmm0

; 325  : 			ydiff = ptgt->YPos() - pfrom->YPos();

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv581[ebp]
	movss	xmm0, DWORD PTR tv581[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv648[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv585[ebp]
	movss	xmm0, DWORD PTR tv648[ebp]
	subss	xmm0, DWORD PTR tv585[ebp]
	movss	DWORD PTR _ydiff$[ebp], xmm0

; 326  : 
; 327  : 			angle = (float)atan2(ydiff, xdiff);

	cvtss2sd xmm0, DWORD PTR _xdiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ydiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _angle$[ebp]

; 328  : 			angle = angle - pfrom->Yaw();

	mov	ecx, DWORD PTR _pfrom$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv594[ebp]
	movss	xmm0, DWORD PTR _angle$[ebp]
	subss	xmm0, DWORD PTR tv594[ebp]
	movss	DWORD PTR _angle$[ebp], xmm0

; 329  : 			navangle	=  FloatToInt32 (RTD * angle);

	movss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR _angle$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _navangle$[ebp], eax

; 330  : 			if(navangle < 0) {

	cmp	DWORD PTR _navangle$[ebp], 0
	jge	SHORT $LN8@AiClearLea

; 331  : 				navangle = 360 + navangle;

	mov	eax, DWORD PTR _navangle$[ebp]
	add	eax, 360				; 00000168H
	mov	DWORD PTR _navangle$[ebp], eax
$LN8@AiClearLea:

; 332  : 			}
; 333  : 
; 334  : 			edata[1] = navangle / 30;									// scale compass angle for radio eData

	mov	eax, DWORD PTR _navangle$[ebp]
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	mov	edx, 2
	shl	edx, 0
	mov	WORD PTR _edata$[ebp+edx], ax

; 335  : 			if(edata[1] >= 12) {

	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR _edata$[ebp+eax]
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LN7@AiClearLea

; 336  : 				edata[1] = 0;

	mov	DWORD PTR $T1[ebp], 2
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN24@AiClearLea
	jmp	SHORT $LN25@AiClearLea
$LN24@AiClearLea:
	call	___report_rangecheckfailure
$LN25@AiClearLea:
	xor	edx, edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN7@AiClearLea:

; 337  : 			}
; 338  : 
; 339  : 			rz = ptgt->ZPos() - pfrom->ZPos();

	mov	ecx, DWORD PTR _ptgt$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv614[ebp]
	movss	xmm0, DWORD PTR tv614[ebp]
	mov	ecx, DWORD PTR _pfrom$[ebp]
	movss	DWORD PTR tv650[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv618[ebp]
	movss	xmm0, DWORD PTR tv650[ebp]
	subss	xmm0, DWORD PTR tv618[ebp]
	movss	DWORD PTR _rz$[ebp], xmm0

; 340  : 
; 341  : 			if(rz < 300.0F && rz > -300.0F) {							// check relative alt and select correct frag

	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN6@AiClearLea
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c3960000
	jbe	SHORT $LN6@AiClearLea

; 342  : 				edata[2] = 1;

	mov	ecx, 2
	shl	ecx, 1
	mov	edx, 1
	mov	WORD PTR _edata$[ebp+ecx], dx
	jmp	SHORT $LN1@AiClearLea
$LN6@AiClearLea:

; 343  : 			}
; 344  : 			else if(rz < -300.0F && rz > -1000.0F) {

	movss	xmm0, DWORD PTR __real@c3960000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN4@AiClearLea
	movss	xmm0, DWORD PTR _rz$[ebp]
	comiss	xmm0, DWORD PTR __real@c47a0000
	jbe	SHORT $LN4@AiClearLea

; 345  : 				edata[2] = 2;

	mov	eax, 2
	shl	eax, 1
	mov	ecx, 2
	mov	WORD PTR _edata$[ebp+eax], cx
	jmp	SHORT $LN1@AiClearLea
$LN4@AiClearLea:

; 346  : 			}	
; 347  : 			else if(rz < -1000.0F) {

	movss	xmm0, DWORD PTR __real@c47a0000
	comiss	xmm0, DWORD PTR _rz$[ebp]
	jbe	SHORT $LN2@AiClearLea

; 348  : 				edata[2] = 3;

	mov	edx, 2
	shl	edx, 1
	mov	eax, 3
	mov	WORD PTR _edata$[ebp+edx], ax

; 349  : 			}
; 350  : 			else {

	jmp	SHORT $LN1@AiClearLea
$LN2@AiClearLea:

; 351  : 				edata[2] = 0;

	mov	ecx, 2
	shl	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN26@AiClearLea
	jmp	SHORT $LN27@AiClearLea
$LN26@AiClearLea:
	call	___report_rangecheckfailure
$LN27@AiClearLea:
	xor	edx, edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	WORD PTR _edata$[ebp+eax], dx
$LN1@AiClearLea:

; 352  : 			}
; 353  : 
; 354  : 
; 355  : 	  		AiMakeRadioResponse( self, rcENGAGINGC, edata );

	lea	ecx, DWORD PTR _edata$[ebp]
	push	ecx
	push	63					; 0000003fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	?AiMakeRadioResponse@@YAXPAVSimBaseClass@@HPAF@Z ; AiMakeRadioResponse
	add	esp, 12					; 0000000cH
$LN15@AiClearLea:
$LN20@AiClearLea:

; 356  : 		}
; 357  : 	}
; 358  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?AiClearLeadersSix@DigitalBrain@@AAEXPAVFalconWingmanMsg@@@Z ENDP ; DigitalBrain::AiClearLeadersSix
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiClearManeuver@DigitalBrain@@AAEXXZ PROC		; DigitalBrain::AiClearManeuver
; _this$ = ecx

; 98   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 99   :    mpActionFlags[AI_USE_COMPLEX]      = FALSE;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 0

; 100  : 	mpActionFlags[AI_EXECUTE_MANEUVER] = FALSE;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 101  : 	mpActionFlags[AI_RTB]              = FALSE;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+760], 0

; 102  : 	mCurrentManeuver = FalconWingmanMsg::WMTotalMsg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+796], 57			; 00000039H

; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiClearManeuver@DigitalBrain@@AAEXXZ ENDP		; DigitalBrain::AiClearManeuver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maneuver$ = 8						; size = 4
?AiSetManeuver@DigitalBrain@@AAEXH@Z PROC		; DigitalBrain::AiSetManeuver
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 	mpActionFlags[AI_EXECUTE_MANEUVER] = TRUE;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+760], 1

; 86   : 	mpActionFlags[AI_RTB]              = FALSE;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+760], 0

; 87   : 	mCurrentManeuver = maneuver;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _maneuver$[ebp]
	mov	DWORD PTR [ecx+796], edx

; 88   : 	mnverTime		= 10.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+508], xmm0

; 89   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AiSetManeuver@DigitalBrain@@AAEXH@Z ENDP		; DigitalBrain::AiSetManeuver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiRestoreSearchDomain@DigitalBrain@@AAEXXZ PROC	; DigitalBrain::AiRestoreSearchDomain
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	mSearchDomain	= mSaveSearchDomain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+836]
	mov	BYTE PTR [eax+824], dl

; 75   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiRestoreSearchDomain@DigitalBrain@@AAEXXZ ENDP	; DigitalBrain::AiRestoreSearchDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_domain$ = 8						; size = 1
?AiSaveSetSearchDomain@DigitalBrain@@AAEXD@Z PROC	; DigitalBrain::AiSaveSetSearchDomain
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 
; 62   : 	mSaveSearchDomain = mSearchDomain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+824]
	mov	BYTE PTR [eax+836], dl

; 63   : 	mSearchDomain		= domain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _domain$[ebp]
	mov	BYTE PTR [eax+824], cl

; 64   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AiSaveSetSearchDomain@DigitalBrain@@AAEXD@Z ENDP	; DigitalBrain::AiSaveSetSearchDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiRestoreWeaponState@DigitalBrain@@AAEXXZ PROC		; DigitalBrain::AiRestoreWeaponState
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 	mWeaponsAction	= mSavedWeapons;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+832]
	mov	DWORD PTR [eax+828], edx

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiRestoreWeaponState@DigitalBrain@@AAEXXZ ENDP		; DigitalBrain::AiRestoreWeaponState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\wingai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AiSaveWeaponState@DigitalBrain@@AAEXXZ PROC		; DigitalBrain::AiSaveWeaponState
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 	mSavedWeapons = mWeaponsAction;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+828]
	mov	DWORD PTR [eax+832], edx

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AiSaveWeaponState@DigitalBrain@@AAEXXZ ENDP		; DigitalBrain::AiSaveWeaponState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?IsSetATC@DigitalBrain@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetATC@DigitalBrain@@QAEHH@Z PROC			; DigitalBrain::IsSetATC, COMDAT
; _this$ = ecx

; 709  : 	int		IsSetATC(int flag)								{return (atcFlags & flag) && TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetATC
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@IsSetATC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetATC
$LN3@IsSetATC:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetATC:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetATC@DigitalBrain@@QAEHH@Z ENDP			; DigitalBrain::IsSetATC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?ClearATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearATCFlag@DigitalBrain@@QAEXH@Z PROC		; DigitalBrain::ClearATCFlag, COMDAT
; _this$ = ecx

; 708  : 	void	ClearATCFlag(int flag)							{atcFlags &= ~flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+300]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearATCFlag@DigitalBrain@@QAEXH@Z ENDP		; DigitalBrain::ClearATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetATCFlag@DigitalBrain@@QAEXH@Z PROC			; DigitalBrain::SetATCFlag, COMDAT
; _this$ = ecx

; 707  : 	void	SetATCFlag(int flag)							{atcFlags |= flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetATCFlag@DigitalBrain@@QAEXH@Z ENDP			; DigitalBrain::SetATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTrackPoint@DigitalBrain@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetTrackPoint@DigitalBrain@@QAEXMMM@Z PROC		; DigitalBrain::SetTrackPoint, COMDAT
; _this$ = ecx

; 699  : 	void	SetTrackPoint(float x, float y, float z){ SetTrackPoint(x, y); trackZ = z; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+156], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTrackPoint@DigitalBrain@@QAEXMMM@Z ENDP		; DigitalBrain::SetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTrackPoint@DigitalBrain@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetTrackPoint@DigitalBrain@@QAEXMM@Z PROC		; DigitalBrain::SetTrackPoint, COMDAT
; _this$ = ecx

; 698  : 	void	SetTrackPoint(float x, float y){ trackX = x; trackY=y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+148], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+152], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTrackPoint@DigitalBrain@@QAEXMM@Z ENDP		; DigitalBrain::SetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetPrevWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrevWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetPrevWP, COMDAT
; _this$ = ecx

; 176  : 	WayPoint GetPrevWP (void)						{ return PrevWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrevWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetPrevWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPFlags@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPFlags@WayPointClass@@QAEKXZ PROC			; WayPointClass::GetWPFlags, COMDAT
; _this$ = ecx

; 173  : 	ulong GetWPFlags (void)							{ return (ulong)Flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPFlags@WayPointClass@@QAEKXZ ENDP			; WayPointClass::GetWPFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbrain.h
;	COMDAT ?SkillLevel@BaseBrain@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SkillLevel@BaseBrain@@QAEHXZ PROC			; BaseBrain::SkillLevel, COMDAT
; _this$ = ecx

; 40   :       int SkillLevel(void) {return skillLevel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?SkillLevel@BaseBrain@@QAEHXZ ENDP			; BaseBrain::SkillLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
