; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DIGI\Mnvers.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_acosf
PUBLIC	_atanf
PUBLIC	?acos@@YAMM@Z					; acos
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?SkillLevel@BaseBrain@@QAEHXZ			; BaseBrain::SkillLevel
PUBLIC	?MachHold@DigitalBrain@@IAEHMMH@Z		; DigitalBrain::MachHold
PUBLIC	?Loiter@DigitalBrain@@IAEXXZ			; DigitalBrain::Loiter
PUBLIC	?LevelTurn@DigitalBrain@@IAEXMMH@Z		; DigitalBrain::LevelTurn
PUBLIC	?GammaHold@DigitalBrain@@IAEXM@Z		; DigitalBrain::GammaHold
PUBLIC	?AltitudeHold@DigitalBrain@@IAEHM@Z		; DigitalBrain::AltitudeHold
PUBLIC	?HeadingAndAltitudeHold@DigitalBrain@@IAEHMM@Z	; DigitalBrain::HeadingAndAltitudeHold
PUBLIC	?RollOutOfPlane@DigitalBrain@@IAEXXZ		; DigitalBrain::RollOutOfPlane
PUBLIC	?OverBank@DigitalBrain@@IAEXM@Z			; DigitalBrain::OverBank
PUBLIC	?SetPstick@DigitalBrain@@IAEMMMH@Z		; DigitalBrain::SetPstick
PUBLIC	?SetRstick@DigitalBrain@@IAEMM@Z		; DigitalBrain::SetRstick
PUBLIC	?SetYpedal@DigitalBrain@@IAEMM@Z		; DigitalBrain::SetYpedal
PUBLIC	?SetMaxRoll@DigitalBrain@@IAEXM@Z		; DigitalBrain::SetMaxRoll
PUBLIC	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z		; DigitalBrain::SetMaxRollDelta
PUBLIC	?ResetMaxRoll@DigitalBrain@@IAEXXZ		; DigitalBrain::ResetMaxRoll
PUBLIC	?AutoTrack@DigitalBrain@@IAEMM@Z		; DigitalBrain::AutoTrack
PUBLIC	?TrackPoint@DigitalBrain@@IAEMMM@Z		; DigitalBrain::TrackPoint
PUBLIC	?TrackPointLanding@DigitalBrain@@IAEMM@Z	; DigitalBrain::TrackPointLanding
PUBLIC	?VectorTrack@DigitalBrain@@IAEMMH@Z		; DigitalBrain::VectorTrack
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?MaxRoll@AirframeClass@@QAEMXZ			; AirframeClass::MaxRoll
PUBLIC	?SetMaxRoll@AirframeClass@@QAEXM@Z		; AirframeClass::SetMaxRoll
PUBLIC	?SetMaxRollDelta@AirframeClass@@QAEXM@Z		; AirframeClass::SetMaxRollDelta
PUBLIC	?MaxGs@AirframeClass@@QAEMXZ			; AirframeClass::MaxGs
PUBLIC	?MinVcas@AirframeClass@@QAEMXZ			; AirframeClass::MinVcas
PUBLIC	?GsAvail@AirframeClass@@QAEMXZ			; AirframeClass::GsAvail
PUBLIC	?VtDot@AirframeClass@@QAEMXZ			; AirframeClass::VtDot
PUBLIC	?VehicleIndex@AirframeClass@@QAEHXZ		; AirframeClass::VehicleIndex
PUBLIC	?Qsom@AirframeClass@@QAEMXZ			; AirframeClass::Qsom
PUBLIC	?Cnalpha@AirframeClass@@QAEMXZ			; AirframeClass::Cnalpha
PUBLIC	?SetFlag@AirframeClass@@QAEXH@Z			; AirframeClass::SetFlag
PUBLIC	?ClearFlag@AirframeClass@@QAEXH@Z		; AirframeClass::ClearFlag
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?GetSimpleMode@AirframeClass@@QAEHXZ		; AirframeClass::GetSimpleMode
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ	; AircraftClass::DBrain
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?LabelColor@DrawableBSP@@QAEKXZ			; DrawableBSP::LabelColor
PUBLIC	?HoldCorner@@YAHHPAVSimObjectType@@@Z		; HoldCorner
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0DB@LAJHKOK@digi?4w?3?5?3?5BAD?5COMMAND?5MODE?5IN?5st@ ; `string'
PUBLIC	??_C@_0BO@PKCDECG@?$CF?40f?5?$CF?40f?5?$CF?40f?5?$CF?43f?5?$CF?42f?5?$CF?42f?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3b23d70a
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c4ccccd
PUBLIC	__real@3c75c28f
PUBLIC	__real@3c8efa34
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e19999a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f19999a
PUBLIC	__real@3f32b8c1
PUBLIC	__real@3f400000
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f59999a
PUBLIC	__real@3f666666
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3fa1df4680000000
PUBLIC	__real@3fb6571820000000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fc6571820000000
PUBLIC	__real@3fc66666
PUBLIC	__real@3fd80b03
PUBLIC	__real@3fe921fb24000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40200000
PUBLIC	__real@40278d35
PUBLIC	__real@40490fd9
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40b7bc3600000000
PUBLIC	__real@40c90fd9
PUBLIC	__real@40d00000
PUBLIC	__real@40ddab4380000000
PUBLIC	__real@40e7bc3600000000
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@41a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@43160000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@437a0000
PUBLIC	__real@438f3d4d
PUBLIC	__real@43960000
PUBLIC	__real@43af0000
PUBLIC	__real@43fa0000
PUBLIC	__real@447a0000
PUBLIC	__real@44fa0000
PUBLIC	__real@45bde1b0
PUBLIC	__real@461c4000
PUBLIC	__real@476d5a1c
PUBLIC	__real@8000000000000000
PUBLIC	__real@be99999a
PUBLIC	__real@bf000000
PUBLIC	__real@bf19999a
PUBLIC	__real@bf800000
PUBLIC	__real@bfc00000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0000000
PUBLIC	__real@c0278d35
PUBLIC	__real@c0490fd9
PUBLIC	__real@c0a00000
PUBLIC	__real@c1200000
PUBLIC	__real@c1f00000
PUBLIC	__real@c2480000
PUBLIC	__real@c2700000
PUBLIC	__real@c2c80000
PUBLIC	__real@c3480000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_sprintf:PROC
EXTRN	_acos:PROC
EXTRN	_atan:PROC
EXTRN	_fabs:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_MonoPrint:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z:PROC	; DigitalBrain::AddMode
EXTRN	?SimpleTrack@DigitalBrain@@IAEXW4SimpleTrackMode@1@M@Z:PROC ; DigitalBrain::SimpleTrack
EXTRN	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z:PROC ; DigitalBrain::SimpleTrackAzimuth
EXTRN	?SimpleTrackElevation@DigitalBrain@@IAEMMM@Z:PROC ; DigitalBrain::SimpleTrackElevation
EXTRN	?SimpleScaleThrottle@DigitalBrain@@IAEMM@Z:PROC	; DigitalBrain::SimpleScaleThrottle
EXTRN	?CalculateRelativePos@DigitalBrain@@IAEXPAM00000@Z:PROC ; DigitalBrain::CalculateRelativePos
EXTRN	?SetFlaps@AirframeClass@@QAEX_N@Z:PROC		; AirframeClass::SetFlaps
EXTRN	?CalcDesSpeed@AirframeClass@@QAEMM@Z:PROC	; AirframeClass::CalcDesSpeed
EXTRN	?ReSetMaxRoll@AirframeClass@@QAEXXZ:PROC	; AirframeClass::ReSetMaxRoll
EXTRN	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentEntity
EXTRN	?NumberOfComponents@CampBaseClass@@QAEHXZ:PROC	; CampBaseClass::NumberOfComponents
EXTRN	?GetMEA@TMap@@QAEMMM@Z:PROC			; TMap::GetMEA
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?maneuverData@DigitalBrain@@2PAY08UManeuverChoiceTable@1@A:BYTE ; DigitalBrain::maneuverData
EXTRN	?aeroDataset@@3PAVAeroDataSet@@A:DWORD		; aeroDataset
EXTRN	?TheMap@@3VTMap@@A:BYTE				; TheMap
EXTRN	?g_nShowDebugLabels@@3HA:DWORD			; g_nShowDebugLabels
EXTRN	?g_fFormationBurnerDistance@@3MA:DWORD		; g_fFormationBurnerDistance
EXTRN	?g_fFuelBaseProp@@3MA:DWORD			; g_fFuelBaseProp
EXTRN	?g_fFuelMultProp@@3MA:DWORD			; g_fFuelMultProp
EXTRN	?g_fFuelTimeStep@@3MA:DWORD			; g_fFuelTimeStep
EXTRN	?g_fFuelVtClip@@3MA:DWORD			; g_fFuelVtClip
EXTRN	?g_fFuelVtDotMult@@3MA:DWORD			; g_fFuelVtDotMult
EXTRN	?g_bFuelLimitBecauseVtDot@@3_NA:BYTE		; g_bFuelLimitBecauseVtDot
EXTRN	?g_fWaypointBurnerDelta@@3MA:DWORD		; g_fWaypointBurnerDelta
EXTRN	?g_fePropFactor@@3MA:DWORD			; g_fePropFactor
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c3480000
CONST	SEGMENT
__real@c3480000 DD 0c3480000r			; -200
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2700000
CONST	SEGMENT
__real@c2700000 DD 0c2700000r			; -60
CONST	ENDS
;	COMDAT __real@c2480000
CONST	SEGMENT
__real@c2480000 DD 0c2480000r			; -50
CONST	ENDS
;	COMDAT __real@c1f00000
CONST	SEGMENT
__real@c1f00000 DD 0c1f00000r			; -30
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@c0490fd9
CONST	SEGMENT
__real@c0490fd9 DD 0c0490fd9r			; -3.14159
CONST	ENDS
;	COMDAT __real@c0278d35
CONST	SEGMENT
__real@c0278d35 DD 0c0278d35r			; -2.61799
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bfc00000
CONST	SEGMENT
__real@bfc00000 DD 0bfc00000r			; -1.5
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf19999a
CONST	SEGMENT
__real@bf19999a DD 0bf19999ar			; -0.6
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@476d5a1c
CONST	SEGMENT
__real@476d5a1c DD 0476d5a1cr			; 60762.1
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43af0000
CONST	SEGMENT
__real@43af0000 DD 043af0000r			; 350
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@438f3d4d
CONST	SEGMENT
__real@438f3d4d DD 0438f3d4dr			; 286.479
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e7bc3600000000
CONST	SEGMENT
__real@40e7bc3600000000 DQ 040e7bc3600000000r	; 48609.7
CONST	ENDS
;	COMDAT __real@40ddab4380000000
CONST	SEGMENT
__real@40ddab4380000000 DQ 040ddab4380000000r	; 30381.1
CONST	ENDS
;	COMDAT __real@40d00000
CONST	SEGMENT
__real@40d00000 DD 040d00000r			; 6.5
CONST	ENDS
;	COMDAT __real@40c90fd9
CONST	SEGMENT
__real@40c90fd9 DD 040c90fd9r			; 6.28318
CONST	ENDS
;	COMDAT __real@40b7bc3600000000
CONST	SEGMENT
__real@40b7bc3600000000 DQ 040b7bc3600000000r	; 6076.21
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@40278d35
CONST	SEGMENT
__real@40278d35 DD 040278d35r			; 2.61799
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe921fb24000000
CONST	SEGMENT
__real@3fe921fb24000000 DQ 03fe921fb24000000r	; 0.785398
CONST	ENDS
;	COMDAT __real@3fd80b03
CONST	SEGMENT
__real@3fd80b03 DD 03fd80b03r			; 1.68784
CONST	ENDS
;	COMDAT __real@3fc66666
CONST	SEGMENT
__real@3fc66666 DD 03fc66666r			; 1.55
CONST	ENDS
;	COMDAT __real@3fc6571820000000
CONST	SEGMENT
__real@3fc6571820000000 DQ 03fc6571820000000r	; 0.174533
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb6571820000000
CONST	SEGMENT
__real@3fb6571820000000 DQ 03fb6571820000000r	; 0.0872665
CONST	ENDS
;	COMDAT __real@3fa1df4680000000
CONST	SEGMENT
__real@3fa1df4680000000 DQ 03fa1df4680000000r	; 0.0349066
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f32b8c1
CONST	SEGMENT
__real@3f32b8c1 DD 03f32b8c1r			; 0.698132
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c75c28f
CONST	SEGMENT
__real@3c75c28f DD 03c75c28fr			; 0.015
CONST	ENDS
;	COMDAT __real@3c4ccccd
CONST	SEGMENT
__real@3c4ccccd DD 03c4ccccdr			; 0.0125
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@3b23d70a
CONST	SEGMENT
__real@3b23d70a DD 03b23d70ar			; 0.0025
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PKCDECG@?$CF?40f?5?$CF?40f?5?$CF?40f?5?$CF?43f?5?$CF?42f?5?$CF?42f?$AA@
CONST	SEGMENT
??_C@_0BO@PKCDECG@?$CF?40f?5?$CF?40f?5?$CF?40f?5?$CF?43f?5?$CF?42f?5?$CF?42f?$AA@ DB '%'
	DB	'.0f %.0f %.0f %.3f %.2f %.2f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LAJHKOK@digi?4w?3?5?3?5BAD?5COMMAND?5MODE?5IN?5st@
CONST	SEGMENT
??_C@_0DB@LAJHKOK@digi?4w?3?5?3?5BAD?5COMMAND?5MODE?5IN?5st@ DB 'digi.w: '
	DB	': BAD COMMAND MODE IN stickCmd!!!!!!!!!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_hisCombatClass$ = -28					; size = 4
_retval$ = -24						; size = 4
_theIntercept$ = -20					; size = 4
tv83 = -16						; size = 4
tv75 = -12						; size = 4
tv67 = -8						; size = 4
_i$ = -4						; size = 4
_combatClass$ = 8					; size = 4
_targetPtr$ = 12					; size = 4
?HoldCorner@@YAHHPAVSimObjectType@@@Z PROC		; HoldCorner

; 917  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 918  : int i, hisCombatClass;
; 919  : DigitalBrain::ManeuverChoiceTable *theIntercept;
; 920  : int retval = TRUE; // Assume you can engage

	mov	DWORD PTR _retval$[ebp], 1

; 921  : return true ;

	mov	eax, 1
	jmp	$LN7@HoldCorner

; 922  : //me123 hack hack request from saint 
; 923  : //always alow corner hold until we fix the disengage stuff
; 924  : 
; 925  :    // Only check for A/C
; 926  : // if (targetPtr->BaseData()->IsSim() && targetPtr->BaseData()->IsAirplane())
; 927  :    if (targetPtr->BaseData()->IsAirplane() || targetPtr->BaseData()->IsFlight()) // 2002-02-26 MODIFIED BY S.G. airplane and fligth are ok in here

	mov	ecx, DWORD PTR _targetPtr$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv67[ebp], eax
	mov	eax, DWORD PTR tv67[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv67[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	jne	SHORT $LN5@HoldCorner
	mov	ecx, DWORD PTR _targetPtr$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx+248]
	call	eax
	test	eax, eax
	je	SHORT $LN6@HoldCorner
$LN5@HoldCorner:

; 928  :    {
; 929  :       // Find the data table for these two types of A/C
; 930  :       hisCombatClass = targetPtr->BaseData()->CombatClass(); // 2002-02-26 MODIFIED BY S.G. Removed the AircraftClass cast

	mov	ecx, DWORD PTR _targetPtr$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv83[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax
	mov	DWORD PTR _hisCombatClass$[ebp], eax

; 931  :       theIntercept = &(DigitalBrain::maneuverData[combatClass][hisCombatClass]);

	mov	ecx, DWORD PTR _combatClass$[ebp]
	imul	ecx, 144				; 00000090H
	mov	edx, DWORD PTR _hisCombatClass$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR ?maneuverData@DigitalBrain@@2PAY08UManeuverChoiceTable@1@A[ecx+edx]
	mov	DWORD PTR _theIntercept$[ebp], eax

; 932  : 
; 933  :       for (i=0; i<theIntercept->numMerges; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HoldCorner
$LN3@HoldCorner:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@HoldCorner:
	mov	edx, DWORD PTR _theIntercept$[ebp]
	movsx	eax, BYTE PTR [edx+13]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN6@HoldCorner

; 934  :       {
; 935  :          if (theIntercept->merge[0] == DigitalBrain::WvrMergeHitAndRun)

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _theIntercept$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN1@HoldCorner

; 936  :          {
; 937  :             retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0

; 938  :             break;

	jmp	SHORT $LN6@HoldCorner
$LN1@HoldCorner:

; 939  :          }
; 940  :       }

	jmp	SHORT $LN3@HoldCorner
$LN6@HoldCorner:

; 941  : //me123 don't blow corner for now, i wanna test them 
; 942  :  //     if (!retval)
; 943  :  //     {
; 944  :          // Chance of blowing corner speed is proportional to your number of choices
; 945  :  //        if ((float)rand()/(float)RAND_MAX > 1.0F / theIntercept->numMerges)
; 946  :  //           retval = TRUE;
; 947  :  //     }
; 948  :    }
; 949  : 
; 950  :    return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN7@HoldCorner:

; 951  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HoldCorner@@YAHHPAVSimObjectType@@@Z ENDP		; HoldCorner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?LabelColor@DrawableBSP@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LabelColor@DrawableBSP@@QAEKXZ PROC			; DrawableBSP::LabelColor, COMDAT
; _this$ = ecx

; 63   : 	DWORD LabelColor()										{ return labelColor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+164]
	mov	esp, ebp
	pop	ebp
	ret	0
?LabelColor@DrawableBSP@@QAEKXZ ENDP			; DrawableBSP::LabelColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ PROC	; AircraftClass::DBrain, COMDAT
; _this$ = ecx

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]
	mov	esp, ebp
	pop	ebp
	ret	0
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ENDP	; AircraftClass::DBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetSimpleMode@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSimpleMode@AirframeClass@@QAEHXZ PROC		; AirframeClass::GetSimpleMode, COMDAT
; _this$ = ecx

; 1224 : 	int  GetSimpleMode(void) {return simpleMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+824]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSimpleMode@AirframeClass@@QAEHXZ ENDP		; AirframeClass::GetSimpleMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?ClearFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::ClearFlag, COMDAT
; _this$ = ecx

; 1215 : 	void ClearFlag (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::ClearFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetFlag@AirframeClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlag@AirframeClass@@QAEXH@Z PROC			; AirframeClass::SetFlag, COMDAT
; _this$ = ecx

; 1214 : 	void SetFlag (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@AirframeClass@@QAEXH@Z ENDP			; AirframeClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Cnalpha@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cnalpha@AirframeClass@@QAEMXZ PROC			; AirframeClass::Cnalpha, COMDAT
; _this$ = ecx

; 1205 : 	float Cnalpha(void) {return cnalpha;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+140]
	mov	esp, ebp
	pop	ebp
	ret	0
?Cnalpha@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Cnalpha
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Qsom@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Qsom@AirframeClass@@QAEMXZ PROC			; AirframeClass::Qsom, COMDAT
; _this$ = ecx

; 1204 : 	float Qsom(void)	{return qsom;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+648]
	mov	esp, ebp
	pop	ebp
	ret	0
?Qsom@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Qsom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?VehicleIndex@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VehicleIndex@AirframeClass@@QAEHXZ PROC		; AirframeClass::VehicleIndex, COMDAT
; _this$ = ecx

; 1200 : 	int	VehicleIndex(void) {return vehicleIndex;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VehicleIndex@AirframeClass@@QAEHXZ ENDP		; AirframeClass::VehicleIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?VtDot@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VtDot@AirframeClass@@QAEMXZ PROC			; AirframeClass::VtDot, COMDAT
; _this$ = ecx

; 1198 : 	float VtDot(void) {return vtDot;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1208]
	mov	esp, ebp
	pop	ebp
	ret	0
?VtDot@AirframeClass@@QAEMXZ ENDP			; AirframeClass::VtDot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GsAvail@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GsAvail@AirframeClass@@QAEMXZ PROC			; AirframeClass::GsAvail, COMDAT
; _this$ = ecx

; 1179 : 	float GsAvail (void) {return gsAvail;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GsAvail@AirframeClass@@QAEMXZ ENDP			; AirframeClass::GsAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MinVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::MinVcas, COMDAT
; _this$ = ecx

; 1175 : 	float MinVcas(void) {return minVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	mov	esp, ebp
	pop	ebp
	ret	0
?MinVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MinVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxGs@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxGs@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxGs, COMDAT
; _this$ = ecx

; 1174 : 	float MaxGs (void) {return maxGs;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxGs@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxGs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetMaxRollDelta@AirframeClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newRoll$ = 8						; size = 4
?SetMaxRollDelta@AirframeClass@@QAEXM@Z PROC		; AirframeClass::SetMaxRollDelta, COMDAT
; _this$ = ecx

; 1172 : 	void  SetMaxRollDelta (float newRoll) {maxRollDelta = newRoll * DTR; startRoll = 0.0F;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movss	xmm0, DWORD PTR _newRoll$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+68], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+72], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxRollDelta@AirframeClass@@QAEXM@Z ENDP		; AirframeClass::SetMaxRollDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?SetMaxRoll@AirframeClass@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newRoll$ = 8						; size = 4
?SetMaxRoll@AirframeClass@@QAEXM@Z PROC			; AirframeClass::SetMaxRoll, COMDAT
; _this$ = ecx

; 1171 : 	void  SetMaxRoll (float newRoll) {maxRoll = newRoll * DTR;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movss	xmm0, DWORD PTR _newRoll$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+64], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxRoll@AirframeClass@@QAEXM@Z ENDP			; AirframeClass::SetMaxRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxRoll@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?MaxRoll@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxRoll, COMDAT
; _this$ = ecx

; 1170 : 	float MaxRoll (void) {return maxRoll * RTD;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxRoll@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maxMnvrGs$ = 8						; size = 4
_fineTrack$ = 12					; size = 4
?VectorTrack@DigitalBrain@@IAEMMH@Z PROC		; DigitalBrain::VectorTrack
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 126  : #if 0
; 127  : double xft,yft,zft, rx,ry,rz, range, xyRange;
; 128  : double azerr, elerr, ata, droll;
; 129  : 
; 130  :    /*-----------------------------*/
; 131  :    /* calculate relative position */
; 132  :    /*-----------------------------*/
; 133  :    
; 134  :    xft = trackX - af->x;
; 135  :    yft = trackY - af->y;
; 136  :    zft = trackZ - af->z;
; 137  :    rx = self->vmat[0][0]*xft + self->vmat[0][1]*yft + self->vmat[0][2]*zft;
; 138  :    ry = self->vmat[1][0]*xft + self->vmat[1][1]*yft + self->vmat[1][2]*zft;
; 139  :    rz = self->vmat[2][0]*xft + self->vmat[2][1]*yft + self->vmat[2][2]*zft;
; 140  : 
; 141  : 
; 142  :    /** MBR: If this code is turned back 'ON', it **/
; 143  :    /** should be modified....                    **/
; 144  : 
; 145  :    range = sqrt (rx*rx + ry*ry + rz*rz);
; 146  : 
; 147  :    /*--------------*/        
; 148  :    /* Sanity Check */
; 149  :    /*--------------*/        
; 150  :    if (range < 0.1F)
; 151  :       return (0.0F);
; 152  : 
; 153  :    rx = max ( min (rx, range), -range);        
; 154  :    ry = max ( min (ry, range), -range);        
; 155  :    rz = max ( min (rz, range), -range);        
; 156  : 
; 157  :    /*-------------------*/
; 158  :    /* relative geometry */
; 159  :    /*-------------------*/
; 160  :    if (rx != 0.0F)
; 161  :       ata      = (float)acos (rx/range) * RTD;
; 162  :    else
; 163  :       ata = 0.0F;     
; 164  :    droll    = atan2 (ry,-rz);
; 165  :    xyRange = sqrt (rx*rx + ry*ry);
; 166  :    azerr    = atan2 (ry,rx)*RTD;
; 167  :    elerr    = atan (-rz/xyRange) * RTD;
; 168  : 
; 169  :    /*---------------*/
; 170  :    /* roll and pull */
; 171  :    /*---------------*/
; 172  :    if (trackMode == 1)
; 173  :    {
; 174  :       /* alternative method for setting pstick allows for unloaded rolls...  */
; 175  :       SetPstick(elerr * 0.75F, maxMnvrGs, AirframeClass::ErrorCommand);
; 176  : 
; 177  :       /* set pstick this way for better return from a out of plane maneuver 
; 178  :       SetPstick( (float)ata, maxGs, AirframeClass::ErrorCommand);
; 179  :       */
; 180  : 
; 181  :       SetRstick(droll*RTD);
; 182  :       SetYpedal( 0.0F);
; 183  :       SetMaxRollDelta (droll*RTD);
; 184  : 
; 185  :       if (ata < 5.0) trackMode = 2;
; 186  :    }
; 187  :    /*----------------------------*/
; 188  :    /* pitch and yaw, wings level */
; 189  :    /*----------------------------*/
; 190  :    else
; 191  :    {
; 192  :       SetPstick( (float)elerr, maxMnvrGs, AirframeClass::ErrorCommand);
; 193  :       SetYpedal( (float)azerr/3.0F);
; 194  :             
; 195  :       if (ata > 8.0F) trackMode = 1;
; 196  :    }
; 197  : 
; 198  :    /*-------------------------*/
; 199  :    /* return nose angle error */
; 200  :    /*-------------------------*/
; 201  :    return ((float)ata);
; 202  : #else
; 203  :    return 0.0F;

	fldz

; 204  : #endif
; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?VectorTrack@DigitalBrain@@IAEMMH@Z ENDP		; DigitalBrain::VectorTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_zft$ = -104						; size = 4
_rz$ = -100						; size = 4
tv432 = -96						; size = 4
tv498 = -92						; size = 4
tv427 = -88						; size = 4
tv389 = -84						; size = 4
_rx$ = -80						; size = 4
_ry$ = -76						; size = 4
tv320 = -72						; size = 4
tv319 = -68						; size = 4
tv304 = -64						; size = 4
tv269 = -60						; size = 4
tv268 = -56						; size = 4
tv261 = -52						; size = 4
tv188 = -48						; size = 4
tv187 = -44						; size = 4
tv184 = -40						; size = 4
_yft$ = -36						; size = 4
_xft$ = -32						; size = 4
tv159 = -28						; size = 4
tv158 = -24						; size = 4
tv143 = -20						; size = 4
_minSpeed$ = -16					; size = 4
_elErr$ = -12						; size = 4
_eProp$ = -8						; size = 4
_this$ = -4						; size = 4
_speed$ = 8						; size = 4
?TrackPointLanding@DigitalBrain@@IAEMM@Z PROC		; DigitalBrain::TrackPointLanding
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	float xft, yft, zft, rx, ry, rz, elErr;
; 36   : 	float eProp, minSpeed;
; 37   : 
; 38   : 	CalculateRelativePos(&xft, &yft, &zft, &rx, &ry, &rz);  

	lea	eax, DWORD PTR _rz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ry$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rx$[ebp]
	push	edx
	lea	eax, DWORD PTR _zft$[ebp]
	push	eax
	lea	ecx, DWORD PTR _yft$[ebp]
	push	ecx
	lea	edx, DWORD PTR _xft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateRelativePos@DigitalBrain@@IAEXPAM00000@Z ; DigitalBrain::CalculateRelativePos

; 39   : 		
; 40   : 	rStick = SimpleTrackAzimuth(rx, ry, self->GetVt());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _ry$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackAzimuth@DigitalBrain@@IAEMMMM@Z ; DigitalBrain::SimpleTrackAzimuth
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+32]

; 41   : 
; 42   : 	//clamp yaw rate to 10 deg/s max
; 43   : 	//simple model uses a max yaw rate of 20 deg/s
; 44   : 	//TJL 02/21/04 Increase rstick to get proper bank angles for turn rate (was 0.15F)
; 45   : 	rStick = max(min(rStick, 0.6F), -0.6F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	comiss	xmm0, DWORD PTR [ecx+32]
	jbe	SHORT $LN12@TrackPoint
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN13@TrackPoint
$LN12@TrackPoint:
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv143[ebp], xmm0
$LN13@TrackPoint:
	movss	xmm0, DWORD PTR tv143[ebp]
	comiss	xmm0, DWORD PTR __real@bf19999a
	jbe	SHORT $LN16@TrackPoint
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f19999a
	comiss	xmm0, DWORD PTR [eax+32]
	jbe	SHORT $LN14@TrackPoint
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN15@TrackPoint
$LN14@TrackPoint:
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR tv158[ebp], xmm0
$LN15@TrackPoint:
	movss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR tv159[ebp], xmm0
	jmp	SHORT $LN17@TrackPoint
$LN16@TrackPoint:
	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR tv159[ebp], xmm0
$LN17@TrackPoint:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR [edx+32], xmm0

; 46   : 
; 47   : 	elErr = SimpleTrackElevation(trackZ - self->ZPos(), (float)sqrt(xft*xft + yft*yft));

	movss	xmm0, DWORD PTR _xft$[ebp]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	movss	xmm1, DWORD PTR _yft$[ebp]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv389[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+156]
	subss	xmm0, DWORD PTR tv389[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackElevation@DigitalBrain@@IAEMMM@Z ; DigitalBrain::SimpleTrackElevation
	fstp	DWORD PTR _elErr$[ebp]

; 48   : 	// keep stick at reasonable values.
; 49   : 	pStick = min( 0.2f, max(elErr, -0.3F) );

	movss	xmm0, DWORD PTR _elErr$[ebp]
	comiss	xmm0, DWORD PTR __real@be99999a
	jbe	SHORT $LN18@TrackPoint
	movss	xmm0, DWORD PTR _elErr$[ebp]
	movss	DWORD PTR tv184[ebp], xmm0
	jmp	SHORT $LN19@TrackPoint
$LN18@TrackPoint:
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR tv184[ebp], xmm0
$LN19@TrackPoint:
	movss	xmm0, DWORD PTR tv184[ebp]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jbe	SHORT $LN22@TrackPoint
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR tv188[ebp], xmm0
	jmp	SHORT $LN23@TrackPoint
$LN22@TrackPoint:
	movss	xmm0, DWORD PTR _elErr$[ebp]
	comiss	xmm0, DWORD PTR __real@be99999a
	jbe	SHORT $LN20@TrackPoint
	movss	xmm0, DWORD PTR _elErr$[ebp]
	movss	DWORD PTR tv187[ebp], xmm0
	jmp	SHORT $LN21@TrackPoint
$LN20@TrackPoint:
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR tv187[ebp], xmm0
$LN21@TrackPoint:
	movss	xmm0, DWORD PTR tv187[ebp]
	movss	DWORD PTR tv188[ebp], xmm0
$LN23@TrackPoint:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR [edx+28], xmm0

; 50   : 
; 51   : 	eProp = speed - af->vt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR _speed$[ebp]
	subss	xmm0, DWORD PTR [ecx+1120]
	movss	DWORD PTR _eProp$[ebp], xmm0

; 52   : 
; 53   : 	if(af->z - af->groundZ < -200.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [eax+1116]
	subss	xmm0, DWORD PTR [edx+1272]
	movss	xmm1, DWORD PTR __real@c3480000
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@TrackPoint

; 54   : 	{
; 55   : 		minSpeed = af->CalcDesSpeed(10.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?CalcDesSpeed@AirframeClass@@QAEMM@Z	; AirframeClass::CalcDesSpeed
	fstp	DWORD PTR _minSpeed$[ebp]

; 56   : 		if(speed < minSpeed)

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN8@TrackPoint

; 57   : 		{
; 58   : 			eProp = minSpeed - af->vt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	subss	xmm0, DWORD PTR [edx+1120]
	movss	DWORD PTR _eProp$[ebp], xmm0

; 59   : 			speed = minSpeed;

	movss	xmm0, DWORD PTR _minSpeed$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN8@TrackPoint:

; 60   : 		}
; 61   : 	}
; 62   : 
; 63   : 	//if we're going to stall out, hit the gas a bit
; 64   : 	if(af->Qsom()*af->Cnalpha() < 1.55F && eProp < 20.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?Qsom@AirframeClass@@QAEMXZ		; AirframeClass::Qsom
	fstp	DWORD PTR tv427[ebp]
	movss	xmm0, DWORD PTR tv427[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	movss	DWORD PTR tv498[ebp], xmm0
	call	?Cnalpha@AirframeClass@@QAEMXZ		; AirframeClass::Cnalpha
	fstp	DWORD PTR tv432[ebp]
	movss	xmm0, DWORD PTR tv498[ebp]
	mulss	xmm0, DWORD PTR tv432[ebp]
	movss	xmm1, DWORD PTR __real@3fc66666
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@TrackPoint
	movss	xmm0, DWORD PTR __real@41a00000
	comiss	xmm0, DWORD PTR _eProp$[ebp]
	jbe	SHORT $LN7@TrackPoint

; 65   : 	{
; 66   : 		eProp = 20.0F;

	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _eProp$[ebp], xmm0

; 67   : 		speed = af->vt + 20.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [eax+1120]
	addss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _speed$[ebp], xmm0
$LN7@TrackPoint:

; 68   : 	}	
; 69   : 	
; 70   : 	if (eProp >= 150.0F) 

	movss	xmm0, DWORD PTR _eProp$[ebp]
	comiss	xmm0, DWORD PTR __real@43160000
	jb	SHORT $LN6@TrackPoint

; 71   : 	{
; 72   : 		autoThrottle = 1.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [ecx+88], xmm0

; 73   : 		throtl = 1.5F;                        /* burner     */

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [edx+40], xmm0

; 74   : 		af->speedBrake = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1560], xmm0
	jmp	$LN3@TrackPoint
$LN6@TrackPoint:

; 75   : 	}
; 76   : 	else if (eProp < -100.0F)

	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR _eProp$[ebp]
	jbe	SHORT $LN4@TrackPoint

; 77   : 	{
; 78   : 		autoThrottle = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+88], xmm0

; 79   : 		throtl = 0.0F;                        /* idle and boards */

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 80   : 		af->speedBrake = 1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+1560], xmm0

; 81   : 	}
; 82   : 	else 

	jmp	$LN3@TrackPoint
$LN4@TrackPoint:

; 83   : 	{
; 84   : 		//if(atcstatus == lOnFinal || (throtl == 0.0F && af->vtDot > -5.0F && eProp < -10.0F))
; 85   : 		//TJL 02/20/04 Not just boards on final because of drag penalty.
; 86   : 		if (throtl == 0.0F && af->vtDot > -5.0F && eProp < -10.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@TrackPoint
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [edx+1208]
	comiss	xmm0, DWORD PTR __real@c0a00000
	jbe	SHORT $LN2@TrackPoint
	movss	xmm0, DWORD PTR __real@c1200000
	comiss	xmm0, DWORD PTR _eProp$[ebp]
	jbe	SHORT $LN2@TrackPoint

; 87   : 			//deploy speed brakes on final
; 88   : 			af->speedBrake = 1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+1560], xmm0

; 89   : 		else

	jmp	SHORT $LN1@TrackPoint
$LN2@TrackPoint:

; 90   : 			af->speedBrake = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1560], xmm0
$LN1@TrackPoint:

; 91   : 		autoThrottle += eProp * 0.01F * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _eProp$[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+88], xmm0

; 92   : 		autoThrottle = max(0.0F,min(1.5F, autoThrottle));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	comiss	xmm0, DWORD PTR __real@3fc00000
	jbe	SHORT $LN24@TrackPoint
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv261[ebp], xmm0
	jmp	SHORT $LN25@TrackPoint
$LN24@TrackPoint:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+88]
	movss	DWORD PTR tv261[ebp], xmm0
$LN25@TrackPoint:
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv261[ebp]
	jbe	SHORT $LN28@TrackPoint
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv269[ebp], xmm0
	jmp	SHORT $LN29@TrackPoint
$LN28@TrackPoint:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+88]
	comiss	xmm0, DWORD PTR __real@3fc00000
	jbe	SHORT $LN26@TrackPoint
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN27@TrackPoint
$LN26@TrackPoint:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	movss	DWORD PTR tv268[ebp], xmm0
$LN27@TrackPoint:
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR tv269[ebp], xmm0
$LN29@TrackPoint:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv269[ebp]
	movss	DWORD PTR [ecx+88], xmm0

; 93   : 		throtl = eProp*0.02F + autoThrottle - af->vtDot*SimLibMajorFrameTime*0.005F;

	movss	xmm0, DWORD PTR _eProp$[ebp]
	mulss	xmm0, DWORD PTR __real@3ca3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+88]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm1, DWORD PTR [ecx+1208]
	mulss	xmm1, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mulss	xmm1, DWORD PTR __real@3ba3d70a
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+40], xmm0
$LN3@TrackPoint:

; 94   : 	}
; 95   : 	af->SetFlaps(true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFlaps@AirframeClass@@QAEX_N@Z	; AirframeClass::SetFlaps

; 96   : 	//MonoPrint("Eprop:  %6.3f  autoTh: %6.3f  vtDot: %6.3f  throtl: %6.3f\n", eProp, autoThrottle, af->vtDot, throtl);
; 97   : 	throtl = min ( max (throtl, 0.0F), 1.5F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN30@TrackPoint
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR tv304[ebp], xmm0
	jmp	SHORT $LN31@TrackPoint
$LN30@TrackPoint:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv304[ebp], xmm0
$LN31@TrackPoint:
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR tv304[ebp]
	jbe	SHORT $LN34@TrackPoint
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN32@TrackPoint
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR tv319[ebp], xmm0
	jmp	SHORT $LN33@TrackPoint
$LN32@TrackPoint:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv319[ebp], xmm0
$LN33@TrackPoint:
	movss	xmm0, DWORD PTR tv319[ebp]
	movss	DWORD PTR tv320[ebp], xmm0
	jmp	SHORT $LN35@TrackPoint
$LN34@TrackPoint:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv320[ebp], xmm0
$LN35@TrackPoint:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv320[ebp]
	movss	DWORD PTR [edx+40], xmm0

; 98   : 
; 99   : 	return speed;

	fld	DWORD PTR _speed$[ebp]

; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TrackPointLanding@DigitalBrain@@IAEMM@Z ENDP		; DigitalBrain::TrackPointLanding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_retval$ = -8						; size = 4
_this$ = -4						; size = 4
_maxGs$ = 8						; size = 4
_speed$ = 12						; size = 4
?TrackPoint@DigitalBrain@@IAEMMM@Z PROC			; DigitalBrain::TrackPoint
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	float retval = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _retval$[ebp], xmm0

; 105  : 	
; 106  : 	//TJL 08/28/04 Other things besides ATC/LANDME use this.  A/A and A/G maneuvers too!  
; 107  : 	/*if (!self->OnGround())
; 108  : 	    af->SetFlaps(curMode == LandingMode);*/
; 109  : 	if(self->af->GetSimpleMode())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetSimpleMode@AirframeClass@@QAEHXZ	; AirframeClass::GetSimpleMode
	test	eax, eax
	je	SHORT $LN2@TrackPoint

; 110  : 	{
; 111  : 		// do simple flight model
; 112  : 		SimpleTrack(SimpleTrackSpd, speed); // speed = desired speed (ft/sec)

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrack@DigitalBrain@@IAEXW4SimpleTrackMode@1@M@Z ; DigitalBrain::SimpleTrack

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN1@TrackPoint
$LN2@TrackPoint:

; 115  : 	{
; 116  : 		retval = AutoTrack (maxGs);

	push	ecx
	movss	xmm0, DWORD PTR _maxGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AutoTrack@DigitalBrain@@IAEMM@Z	; DigitalBrain::AutoTrack
	fstp	DWORD PTR _retval$[ebp]

; 117  : 		//TJL 02/21/04 Removed * FTPSEC. Speed is passed in knots
; 118  : 		MachHold (speed, self->GetKias(), TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
$LN1@TrackPoint:

; 119  : 	}
; 120  : 	
; 121  : 	return retval;

	fld	DWORD PTR _retval$[ebp]

; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?TrackPoint@DigitalBrain@@IAEMMM@Z ENDP			; DigitalBrain::TrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv528 = -116						; size = 8
tv522 = -108						; size = 8
tv502 = -100						; size = 8
tv639 = -92						; size = 4
tv634 = -88						; size = 4
tv621 = -84						; size = 4
tv613 = -80						; size = 4
tv598 = -76						; size = 4
tv585 = -72						; size = 4
tv576 = -68						; size = 4
tv540 = -64						; size = 4
_azerr$ = -60						; size = 4
tv451 = -56						; size = 4
tv444 = -52						; size = 4
tv437 = -48						; size = 4
tv390 = -44						; size = 4
_elerr$ = -40						; size = 4
_zft$ = -36						; size = 4
_yft$ = -32						; size = 4
_xft$ = -28						; size = 4
_rx$ = -24						; size = 4
_rz$ = -20						; size = 4
_ry$ = -16						; size = 4
_ata$ = -12						; size = 4
_droll$ = -8						; size = 4
_this$ = -4						; size = 4
_maxMnvrGs$ = 8						; size = 4
?AutoTrack@DigitalBrain@@IAEMM@Z PROC			; DigitalBrain::AutoTrack
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 209  : float xft,yft,zft, rx,ry,rz;
; 210  : float elerr, ata, droll, azerr;
; 211  : 
; 212  :    /*-----------------------------*/
; 213  :    /* calculate relative position */
; 214  :    /*-----------------------------*/
; 215  :    
; 216  :    xft = trackX - self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv437[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+148]
	subss	xmm0, DWORD PTR tv437[ebp]
	movss	DWORD PTR _xft$[ebp], xmm0

; 217  :    yft = trackY - self->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv444[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+152]
	subss	xmm0, DWORD PTR tv444[ebp]
	movss	DWORD PTR _yft$[ebp], xmm0

; 218  :    zft = trackZ - self->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv451[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+156]
	subss	xmm0, DWORD PTR tv451[ebp]
	movss	DWORD PTR _zft$[ebp], xmm0

; 219  :    rx = self->dmx[0][0]*xft + self->dmx[0][1]*yft + self->dmx[0][2]*zft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	imul	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	imul	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	imul	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _zft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rx$[ebp], xmm0

; 220  :    ry = self->dmx[1][0]*xft + self->dmx[1][1]*yft + self->dmx[1][2]*zft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _zft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ry$[ebp], xmm0

; 221  :    rz = self->dmx[2][0]*xft + self->dmx[2][1]*yft + self->dmx[2][2]*zft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+296]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _xft$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+296]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _yft$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR [edx+eax+296]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _zft$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rz$[ebp], xmm0

; 222  : 
; 223  :    ata   = (float)atan2(sqrt(ry*ry+rz*rz), rx) * RTD;

	cvtss2sd xmm0, DWORD PTR _rx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ry$[ebp]
	mulss	xmm0, DWORD PTR _ry$[ebp]
	movss	xmm1, DWORD PTR _rz$[ebp]
	mulss	xmm1, DWORD PTR _rz$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, -4					; fffffffcH
	fstp	QWORD PTR [esp]
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv502[ebp]
	movsd	xmm0, QWORD PTR tv502[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _ata$[ebp], xmm0

; 224  : 
; 225  : 
; 226  :    /*---------------*/
; 227  :    /* roll and pull */
; 228  :    /*---------------*/
; 229  :    droll = (float)atan2 (ry,-rz);

	movss	xmm0, DWORD PTR _rz$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _droll$[ebp]

; 230  :    elerr = (float)atan2(-rz,sqrt(rx*rx+ry*ry)) * RTD;

	movss	xmm0, DWORD PTR _rx$[ebp]
	mulss	xmm0, DWORD PTR _rx$[ebp]
	movss	xmm1, DWORD PTR _ry$[ebp]
	mulss	xmm1, DWORD PTR _ry$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, -4					; fffffffcH
	fstp	QWORD PTR [esp]
	movss	xmm0, DWORD PTR _rz$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv522[ebp]
	movsd	xmm0, QWORD PTR tv522[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _elerr$[ebp], xmm0

; 231  :    azerr    = (float)atan2 (ry,rx)*RTD;

	cvtss2sd xmm0, DWORD PTR _rx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ry$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv528[ebp]
	movsd	xmm0, QWORD PTR tv528[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _azerr$[ebp], xmm0

; 232  : 
; 233  :    /* set pstick this way for better return from a out of plane maneuver 
; 234  :    SetPstick( (float)ata, maxMnvrGs, AirframeClass::ErrorCommand);
; 235  :    */
; 236  : 
; 237  :    if ( ata < 5.0F)

	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR _ata$[ebp]
	jbe	$LN10@AutoTrack

; 238  :    {
; 239  :       SetPstick( 1.5F * elerr, maxMnvrGs, AirframeClass::ErrorCommand);

	push	256					; 00000100H
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3fc00000
	mulss	xmm0, DWORD PTR _elerr$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 240  :       SetYpedal( azerr / 4.0F);

	movss	xmm0, DWORD PTR _azerr$[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 241  :       SetRstick(-self->Roll() * 5.0F);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv540[ebp]
	movss	xmm0, DWORD PTR tv540[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@40a00000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)
	jmp	$LN1@AutoTrack
$LN10@AutoTrack:

; 242  :    }
; 243  :    else if ( ata < 10.0f && curMode >= BVREngageMode)

	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR _ata$[ebp]
	jbe	$LN8@AutoTrack
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 16			; 00000010H
	jl	$LN8@AutoTrack

; 244  :    {
; 245  :       // edg note: what this does is to roll in the opposite direction
; 246  :       // and do a neg G push rather than roll all the way around and pull
; 247  :       // if our roll error is large ( in this case beyond 150deg ).   This
; 248  :       // will keep it from flip-flopping around as seen previously, plus
; 249  :       // I think it's the way a pilot would likely do things.
; 250  : 	   if ( droll > 150.0f * DTR && rStick < 0.5F)

	movss	xmm0, DWORD PTR _droll$[ebp]
	comiss	xmm0, DWORD PTR __real@40278d35
	jbe	SHORT $LN7@AutoTrack
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [edx+32]
	jbe	SHORT $LN7@AutoTrack

; 251  :       {
; 252  : 			SetRstick( droll*RTD - 180.0f );

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	subss	xmm0, DWORD PTR __real@43340000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 253  :          SetPstick( -ata, maxMnvrGs, AirframeClass::ErrorCommand);

	push	256					; 00000100H
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ata$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)
	jmp	$LN4@AutoTrack
$LN7@AutoTrack:

; 254  :       }
; 255  : 	   else if ( droll < -150.0f * DTR  && rStick > -0.5F)

	movss	xmm0, DWORD PTR __real@c0278d35
	comiss	xmm0, DWORD PTR _droll$[ebp]
	jbe	SHORT $LN5@AutoTrack
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	comiss	xmm0, DWORD PTR __real@bf000000
	jbe	SHORT $LN5@AutoTrack

; 256  :       {
; 257  : 			SetRstick( droll*RTD + 180.0f );

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	addss	xmm0, DWORD PTR __real@43340000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 258  :          SetPstick( -ata, maxMnvrGs, AirframeClass::ErrorCommand);

	push	256					; 00000100H
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ata$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 259  :       }
; 260  : 	   else

	jmp	SHORT $LN4@AutoTrack
$LN5@AutoTrack:

; 261  :       {
; 262  : 			SetRstick( droll*RTD );

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 263  :          SetPstick( ata*RTD, maxMnvrGs, AirframeClass::ErrorCommand);

	push	256					; 00000100H
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ata$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)
$LN4@AutoTrack:

; 264  :       }
; 265  :       SetYpedal( 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 266  :    }
; 267  :    else

	jmp	$LN1@AutoTrack
$LN8@AutoTrack:

; 268  :    {
; 269  :       // If we're stupid
; 270  :       if (SkillLevel() < 2 && fabs(ata) > 90.0F && fabs(self->Pitch()) < 45.0F*DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	cmp	eax, 2
	jge	$LN2@AutoTrack
	push	ecx
	movss	xmm0, DWORD PTR _ata$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv576[ebp]
	movss	xmm0, DWORD PTR tv576[ebp]
	comiss	xmm0, DWORD PTR __real@42b40000
	jbe	$LN2@AutoTrack
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv585[ebp]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR tv585[ebp]
	jbe	$LN2@AutoTrack

; 271  :       {
; 272  :          elerr = maxMnvrGs * 0.85F;

	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	mulss	xmm0, DWORD PTR __real@3f59999a
	movss	DWORD PTR _elerr$[ebp], xmm0

; 273  :          droll = (float)acos (1.0F / elerr);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _elerr$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?acos@@YAMM@Z				; acos
	add	esp, 4
	fstp	DWORD PTR _droll$[ebp]

; 274  :          SetMaxRoll (droll * RTD);

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 275  :          droll -= self->Roll();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv598[ebp]
	movss	xmm0, DWORD PTR _droll$[ebp]
	subss	xmm0, DWORD PTR tv598[ebp]
	movss	DWORD PTR _droll$[ebp], xmm0

; 276  :          SetRstick( droll*RTD );

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 277  :          SetPstick( maxMnvrGs, maxMnvrGs, AirframeClass::GCommand);

	push	128					; 00000080H
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 278  :       }
; 279  :       else

	jmp	$LN1@AutoTrack
$LN2@AutoTrack:

; 280  :       {
; 281  :          SetRstick( droll*RTD );

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 282  :          SetPstick( ata * min ((30.0F * DTR) / (float)fabs(droll), 1.0F), maxMnvrGs, AirframeClass::AlphaCommand);//me123 from errorcommand

	push	ecx
	movss	xmm0, DWORD PTR _droll$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv613[ebp]
	movss	xmm0, DWORD PTR __real@3f060a91
	divss	xmm0, DWORD PTR tv613[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN13@AutoTrack
	push	ecx
	movss	xmm0, DWORD PTR _droll$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv621[ebp]
	movss	xmm0, DWORD PTR __real@3f060a91
	divss	xmm0, DWORD PTR tv621[ebp]
	movss	DWORD PTR tv390[ebp], xmm0
	jmp	SHORT $LN14@AutoTrack
$LN13@AutoTrack:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv390[ebp], xmm0
$LN14@AutoTrack:
	push	1024					; 00000400H
	push	ecx
	movss	xmm0, DWORD PTR _maxMnvrGs$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ata$[ebp]
	mulss	xmm0, DWORD PTR tv390[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 283  :          SetYpedal( 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 284  :          SetMaxRoll ((float)fabs(self->Roll() + droll) * RTD);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv634[ebp]
	movss	xmm0, DWORD PTR tv634[ebp]
	addss	xmm0, DWORD PTR _droll$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv639[ebp]
	movss	xmm0, DWORD PTR tv639[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 285  :          SetMaxRollDelta (droll*RTD);

	movss	xmm0, DWORD PTR _droll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta
$LN1@AutoTrack:

; 286  :       }
; 287  :    }
; 288  : 
; 289  :    /*-------------------------*/
; 290  :    /* return nose angle error */
; 291  :    /*-------------------------*/
; 292  :    return (ata);

	fld	DWORD PTR _ata$[ebp]

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AutoTrack@DigitalBrain@@IAEMM@Z ENDP			; DigitalBrain::AutoTrack
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetMaxRoll@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::ResetMaxRoll
; _this$ = ecx

; 402  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  :    af->ReSetMaxRoll ();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?ReSetMaxRoll@AirframeClass@@QAEXXZ	; AirframeClass::ReSetMaxRoll

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetMaxRoll@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::ResetMaxRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maxRoll$ = 8						; size = 4
?SetMaxRollDelta@DigitalBrain@@IAEXM@Z PROC		; DigitalBrain::SetMaxRollDelta
; _this$ = ecx

; 397  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 398  :    af->SetMaxRollDelta (maxRoll);

	push	ecx
	movss	xmm0, DWORD PTR _maxRoll$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetMaxRollDelta@AirframeClass@@QAEXM@Z	; AirframeClass::SetMaxRollDelta

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxRollDelta@DigitalBrain@@IAEXM@Z ENDP		; DigitalBrain::SetMaxRollDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maxRoll$ = 8						; size = 4
?SetMaxRoll@DigitalBrain@@IAEXM@Z PROC			; DigitalBrain::SetMaxRoll
; _this$ = ecx

; 392  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 393  :    af->SetMaxRoll (maxRoll);

	push	ecx
	movss	xmm0, DWORD PTR _maxRoll$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetMaxRoll@AirframeClass@@QAEXM@Z	; AirframeClass::SetMaxRoll

; 394  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxRoll@DigitalBrain@@IAEXM@Z ENDP			; DigitalBrain::SetMaxRoll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yawError$ = 8						; size = 4
?SetYpedal@DigitalBrain@@IAEMM@Z PROC			; DigitalBrain::SetYpedal
; _this$ = ecx

; 385  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  :    yPedal = 0.2F * yPedal - 0.8F * yawError*RTD*0.0125F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR [eax+36]
	movss	xmm1, DWORD PTR __real@3f4ccccd
	mulss	xmm1, DWORD PTR _yawError$[ebp]
	mulss	xmm1, DWORD PTR __real@42652ee1
	mulss	xmm1, DWORD PTR __real@3c4ccccd
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+36], xmm0

; 387  : 
; 388  :    return yawError;

	fld	DWORD PTR _yawError$[ebp]

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetYpedal@DigitalBrain@@IAEMM@Z ENDP			; DigitalBrain::SetYpedal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
_stickCmd$ = -52					; size = 4
tv259 = -48						; size = 4
tv251 = -44						; size = 4
tv244 = -40						; size = 4
tv237 = -36						; size = 4
tv232 = -32						; size = 4
tv227 = -28						; size = 4
tv222 = -24						; size = 4
tv187 = -20						; size = 4
tv169 = -16						; size = 4
tv143 = -12						; size = 4
_maxRoll$ = -8						; size = 4
_this$ = -4						; size = 4
_rollError$ = 8						; size = 4
?SetRstick@DigitalBrain@@IAEMM@Z PROC			; DigitalBrain::SetRstick
; _this$ = ecx

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 359  : float maxRoll = af->MaxRoll();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MaxRoll@AirframeClass@@QAEMXZ		; AirframeClass::MaxRoll
	fstp	DWORD PTR _maxRoll$[ebp]

; 360  : float stickCmd;
; 361  : //TJL 09/26/04 Roll is in radians but maxRoll in degrees //Cobra 10/31/04 TJL
; 362  :    //if (fabs(self->Roll()) > maxRoll)
; 363  : 	if (fabs(self->Roll()*RTD) > maxRoll)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv222[ebp]
	movss	xmm0, DWORD PTR tv222[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv227[ebp]
	movss	xmm0, DWORD PTR tv227[ebp]
	comiss	xmm0, DWORD PTR _maxRoll$[ebp]
	jbe	$LN1@SetRstick

; 364  :    {
; 365  :       if (self->Roll() > 0.0F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@SetRstick

; 366  :       {
; 367  :          //rollError = min (rollError, (maxRoll - self->Roll()) * RTD);
; 368  : 		rollError = min (rollError, (maxRoll - (self->Roll()* RTD)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv237[ebp]
	movss	xmm0, DWORD PTR tv237[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _maxRoll$[ebp]
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR _rollError$[ebp]
	jbe	SHORT $LN6@SetRstick
	movss	xmm0, DWORD PTR _rollError$[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN7@SetRstick
$LN6@SetRstick:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv244[ebp]
	movss	xmm0, DWORD PTR tv244[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _maxRoll$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR tv143[ebp], xmm1
$LN7@SetRstick:
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR _rollError$[ebp], xmm0

; 369  :       }
; 370  :       else

	jmp	SHORT $LN1@SetRstick
$LN2@SetRstick:

; 371  :       {
; 372  :          //rollError = max (rollError, (maxRoll + self->Roll()) * RTD);
; 373  : 		rollError = max (rollError, (maxRoll + (self->Roll()* RTD)));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv251[ebp]
	movss	xmm0, DWORD PTR tv251[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	addss	xmm0, DWORD PTR _maxRoll$[ebp]
	movss	xmm1, DWORD PTR _rollError$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@SetRstick
	movss	xmm0, DWORD PTR _rollError$[ebp]
	movss	DWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN9@SetRstick
$LN8@SetRstick:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv259[ebp]
	movss	xmm0, DWORD PTR tv259[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	addss	xmm0, DWORD PTR _maxRoll$[ebp]
	movss	DWORD PTR tv169[ebp], xmm0
$LN9@SetRstick:
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR _rollError$[ebp], xmm0
$LN1@SetRstick:

; 374  :       }
; 375  :    }
; 376  : 
; 377  :    stickCmd = rollError*DTR*0.75F/ max ((af->kr01*af->tr01), 0.1F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [edx+1412]
	mulss	xmm0, DWORD PTR [ecx+1404]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN10@SetRstick
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR [eax+1412]
	mulss	xmm0, DWORD PTR [edx+1404]
	movss	DWORD PTR tv187[ebp], xmm0
	jmp	SHORT $LN11@SetRstick
$LN10@SetRstick:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv187[ebp], xmm0
$LN11@SetRstick:
	movss	xmm0, DWORD PTR _rollError$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mulss	xmm0, DWORD PTR __real@3f400000
	divss	xmm0, DWORD PTR tv187[ebp]
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 378  : 
; 379  :    rStick = 0.2F * rStick + 0.8F * stickCmd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR [eax+32]
	movss	xmm1, DWORD PTR __real@3f4ccccd
	mulss	xmm1, DWORD PTR _stickCmd$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+32], xmm0

; 380  : 
; 381  :    return rollError;

	fld	DWORD PTR _rollError$[ebp]

; 382  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRstick@DigitalBrain@@IAEMM@Z ENDP			; DigitalBrain::SetRstick
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv286 = -52						; size = 4
tv278 = -48						; size = 4
tv302 = -44						; size = 4
tv267 = -40						; size = 4
tv261 = -36						; size = 4
tv200 = -32						; size = 4
tv196 = -28						; size = 4
tv92 = -24						; size = 4
tv89 = -20						; size = 4
tv84 = -16						; size = 4
_stickFact$ = -12					; size = 4
_this$ = -8						; size = 4
_stickCmd$ = -4						; size = 4
_pitchError$ = 8					; size = 4
_gLimit$ = 12						; size = 4
_commandType$ = 16					; size = 4
?SetPstick@DigitalBrain@@IAEMMMH@Z PROC			; DigitalBrain::SetPstick
; _this$ = ecx

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 297  : float stickFact=0.0F, stickCmd=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _stickFact$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 298  : 
; 299  :    af->ClearFlag(AirframeClass::GCommand|AirframeClass::AlphaCommand|
; 300  :       AirframeClass::AutoCommand|AirframeClass::ErrorCommand);

	push	1472					; 000005c0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?ClearFlag@AirframeClass@@QAEXH@Z	; AirframeClass::ClearFlag

; 301  :    if (commandType == AirframeClass::ErrorCommand)

	cmp	DWORD PTR _commandType$[ebp], 256	; 00000100H
	jne	$LN14@SetPstick

; 302  :    {
; 303  :       if (pitchError > 30.0F)

	movss	xmm0, DWORD PTR _pitchError$[ebp]
	comiss	xmm0, DWORD PTR __real@41f00000
	jbe	SHORT $LN13@SetPstick

; 304  :          stickCmd = gLimit;

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	movss	DWORD PTR _stickCmd$[ebp], xmm0
	jmp	SHORT $LN8@SetPstick
$LN13@SetPstick:

; 305  :       else if (pitchError > 0.0F)

	movss	xmm0, DWORD PTR _pitchError$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@SetPstick

; 306  :          stickCmd = gLimit * pitchError / 30.0F + 1.0F;

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	mulss	xmm0, DWORD PTR _pitchError$[ebp]
	divss	xmm0, DWORD PTR __real@41f00000
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _stickCmd$[ebp], xmm0
	jmp	SHORT $LN8@SetPstick
$LN11@SetPstick:

; 307  :       else if (pitchError > -30.0F)

	movss	xmm0, DWORD PTR _pitchError$[ebp]
	comiss	xmm0, DWORD PTR __real@c1f00000
	jbe	SHORT $LN9@SetPstick

; 308  :          stickCmd = gLimit * 0.5F * pitchError / 30.0F;

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR _pitchError$[ebp]
	divss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 309  :       else

	jmp	SHORT $LN8@SetPstick
$LN9@SetPstick:

; 310  :          stickCmd = -gLimit * 0.5F;

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _stickCmd$[ebp], xmm0
$LN8@SetPstick:

; 311  :       af->SetFlag(AirframeClass::GCommand);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
	jmp	$LN3@SetPstick
$LN14@SetPstick:

; 312  :    }
; 313  :    else if (commandType == AirframeClass::GCommand)

	cmp	DWORD PTR _commandType$[ebp], 128	; 00000080H
	jne	$LN6@SetPstick

; 314  :    {
; 315  : 	 /*
; 316  : 		if (pitchError <= 1.0F)
; 317  :       	stickCmd = -(float)sqrt((1.0F - pitchError) / (4.0F + self->platformAngles.costhe));
; 318  : 		else
; 319  :       	stickCmd = (float)sqrt((pitchError - 1.0F) / (gLimit - self->platformAngles.costhe));
; 320  :       af->SetFlag(AirframeClass::GCommand);
; 321  : 	  */
; 322  :       stickCmd = max ( min (pitchError, gLimit), -gLimit);

	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR _pitchError$[ebp]
	jbe	SHORT $LN17@SetPstick
	movss	xmm0, DWORD PTR _pitchError$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN18@SetPstick
$LN17@SetPstick:
	movss	xmm0, DWORD PTR _gLimit$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
$LN18@SetPstick:
	movss	xmm0, DWORD PTR _gLimit$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR tv84[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN21@SetPstick
	movss	xmm0, DWORD PTR _gLimit$[ebp]
	comiss	xmm0, DWORD PTR _pitchError$[ebp]
	jbe	SHORT $LN19@SetPstick
	movss	xmm0, DWORD PTR _pitchError$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN20@SetPstick
$LN19@SetPstick:
	movss	xmm0, DWORD PTR _gLimit$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
$LN20@SetPstick:
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN22@SetPstick
$LN21@SetPstick:
	movss	xmm0, DWORD PTR _gLimit$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv92[ebp], xmm0
$LN22@SetPstick:
	movss	xmm0, DWORD PTR tv92[ebp]
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 323  :       af->SetFlag(AirframeClass::GCommand);

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag
	jmp	SHORT $LN3@SetPstick
$LN6@SetPstick:

; 324  :    }
; 325  :    else if (commandType == AirframeClass::AlphaCommand)

	cmp	DWORD PTR _commandType$[ebp], 1024	; 00000400H
	jne	SHORT $LN4@SetPstick

; 326  :    {
; 327  :       stickCmd = pitchError*0.75F;

	movss	xmm0, DWORD PTR _pitchError$[ebp]
	mulss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 328  :       af->SetFlag(AirframeClass::AlphaCommand);

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?SetFlag@AirframeClass@@QAEXH@Z		; AirframeClass::SetFlag

; 329  :    }
; 330  :    else

	jmp	SHORT $LN3@SetPstick
$LN4@SetPstick:

; 331  :    {
; 332  :       MonoPrint("digi.w: : BAD COMMAND MODE IN stickCmd!!!!!!!!!\n");

	push	OFFSET ??_C@_0DB@LAJHKOK@digi?4w?3?5?3?5BAD?5COMMAND?5MODE?5IN?5st@
	call	_MonoPrint
	add	esp, 4

; 333  : 		stickCmd = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _stickCmd$[ebp], xmm0
$LN3@SetPstick:

; 334  :    }
; 335  : 
; 336  : 	if (stickCmd <= 1.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _stickCmd$[ebp]
	jb	SHORT $LN2@SetPstick

; 337  :    {
; 338  :       stickCmd = -(float)sqrt((1.0F - stickCmd) / (4.0F + self->platformAngles.costhe));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _stickCmd$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	movss	xmm1, DWORD PTR __real@40800000
	addss	xmm1, DWORD PTR [edx+392]
	divss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv261[ebp]
	movss	xmm0, DWORD PTR tv261[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 339  :    }
; 340  : 	else

	jmp	SHORT $LN1@SetPstick
$LN2@SetPstick:

; 341  :    {
; 342  :       stickCmd = (float)sqrt((stickCmd - 1.0F) / (af->MaxGs() - self->platformAngles.costhe));

	movss	xmm0, DWORD PTR _stickCmd$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	DWORD PTR tv302[ebp], xmm0
	call	?MaxGs@AirframeClass@@QAEMXZ		; AirframeClass::MaxGs
	fstp	DWORD PTR tv267[ebp]
	movss	xmm0, DWORD PTR tv267[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	subss	xmm0, DWORD PTR [edx+392]
	movss	xmm1, DWORD PTR tv302[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _stickCmd$[ebp]
$LN1@SetPstick:

; 343  :    }
; 344  : 
; 345  :    // Limit stick for low airspeeds
; 346  : 
; 347  :    stickFact = min (150.0F, self->GetKias() - 150.0F);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv278[ebp]
	movss	xmm0, DWORD PTR tv278[ebp]
	subss	xmm0, DWORD PTR __real@43160000
	comiss	xmm0, DWORD PTR __real@43160000
	jbe	SHORT $LN23@SetPstick
	movss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR tv196[ebp], xmm0
	jmp	SHORT $LN24@SetPstick
$LN23@SetPstick:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [eax+224]
	call	edx
	fstp	DWORD PTR tv286[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	subss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR tv196[ebp], xmm0
$LN24@SetPstick:
	movss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR _stickFact$[ebp], xmm0

; 348  :    stickFact = 0.5F + stickFact / 300.0F;

	movss	xmm0, DWORD PTR _stickFact$[ebp]
	divss	xmm0, DWORD PTR __real@43960000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _stickFact$[ebp], xmm0

; 349  :    stickFact = max (0.0F, stickFact);

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _stickFact$[ebp]
	jbe	SHORT $LN25@SetPstick
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv200[ebp], xmm0
	jmp	SHORT $LN26@SetPstick
$LN25@SetPstick:
	movss	xmm0, DWORD PTR _stickFact$[ebp]
	movss	DWORD PTR tv200[ebp], xmm0
$LN26@SetPstick:
	movss	xmm0, DWORD PTR tv200[ebp]
	movss	DWORD PTR _stickFact$[ebp], xmm0

; 350  :    stickCmd *= stickFact;

	movss	xmm0, DWORD PTR _stickCmd$[ebp]
	mulss	xmm0, DWORD PTR _stickFact$[ebp]
	movss	DWORD PTR _stickCmd$[ebp], xmm0

; 351  : 
; 352  :    // Smooth the command
; 353  :    pStick = 0.2F * pStick + 0.8F * stickCmd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR [eax+28]
	movss	xmm1, DWORD PTR __real@3f4ccccd
	mulss	xmm1, DWORD PTR _stickCmd$[ebp]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+28], xmm0

; 354  :    return pitchError;

	fld	DWORD PTR _pitchError$[ebp]

; 355  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetPstick@DigitalBrain@@IAEMMMH@Z ENDP			; DigitalBrain::SetPstick
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv220 = -24						; size = 4
tv210 = -20						; size = 4
tv189 = -16						; size = 4
tv182 = -12						; size = 4
_eroll$ = -8						; size = 4
_this$ = -4						; size = 4
_delta$ = 8						; size = 4
?OverBank@DigitalBrain@@IAEXM@Z PROC			; DigitalBrain::OverBank
; _this$ = ecx

; 876  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 877  : float eroll = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _eroll$[ebp], xmm0

; 878  : 
; 879  :    if (targetData == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN9@OverBank

; 880  :       return;

	jmp	$LN10@OverBank
$LN9@OverBank:

; 881  : 
; 882  :    /*-------------------------*/
; 883  :    /* not in a vertical fight */
; 884  :    /*-------------------------*/
; 885  :    if (fabs(self->Pitch()) < 45.0*DTR)//me123 from 70

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv182[ebp]
	movss	xmm0, DWORD PTR tv182[ebp]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@3fe921fb24000000
	comisd	xmm1, xmm0
	jbe	$LN8@OverBank

; 886  :    {
; 887  :       /*-----------------------*/
; 888  :       /* Find a new roll angle */
; 889  :       /*-----------------------*/
; 890  :       if (lastMode != OverBMode)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+140], 14			; 0000000eH
	je	$LN2@OverBank

; 891  :       {
; 892  :          if (self->Roll() > 0.0F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv189[ebp]
	movss	xmm0, DWORD PTR tv189[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@OverBank

; 893  :             newroll = targetData->droll + delta;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx+40]
	addss	xmm0, DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0

; 894  :          else

	jmp	SHORT $LN5@OverBank
$LN6@OverBank:

; 895  :             newroll = targetData->droll - delta;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [edx+40]
	subss	xmm0, DWORD PTR _delta$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0
$LN5@OverBank:

; 896  : 
; 897  :          if (newroll > 180.0F * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+512]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN4@OverBank

; 898  :             newroll -= 360.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+512]
	subss	xmm0, DWORD PTR __real@40c90fd9
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0
	jmp	SHORT $LN2@OverBank
$LN4@OverBank:

; 899  :          else if (newroll < -180.0F * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR [ecx+512]
	jbe	SHORT $LN2@OverBank

; 900  :             newroll += 360.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+512]
	addss	xmm0, DWORD PTR __real@40c90fd9
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0
$LN2@OverBank:

; 901  :       }
; 902  : 
; 903  :       eroll = newroll - self->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv210[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+512]
	subss	xmm0, DWORD PTR tv210[ebp]
	movss	DWORD PTR _eroll$[ebp], xmm0

; 904  :       SetRstick(eroll * RTD);

	movss	xmm0, DWORD PTR _eroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)
$LN8@OverBank:

; 905  :    }
; 906  : 
; 907  :    /*------*/
; 908  :    /* exit */
; 909  :    /*------*/
; 910  :    if (fabs(eroll) > 1.0)

	push	ecx
	movss	xmm0, DWORD PTR _eroll$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv220[ebp]
	movss	xmm0, DWORD PTR tv220[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN1@OverBank

; 911  :    {
; 912  :       AddMode(OverBMode);

	push	14					; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN1@OverBank:
$LN10@OverBank:

; 913  :    }
; 914  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?OverBank@DigitalBrain@@IAEXM@Z ENDP			; DigitalBrain::OverBank
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv185 = -24						; size = 4
tv179 = -20						; size = 4
tv173 = -16						; size = 4
tv168 = -12						; size = 4
_eroll$ = -8						; size = 4
_this$ = -4						; size = 4
?RollOutOfPlane@DigitalBrain@@IAEXXZ PROC		; DigitalBrain::RollOutOfPlane
; _this$ = ecx

; 824  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 825  : float eroll;
; 826  : 
; 827  :    /*-----------------------*/
; 828  :    /* first pass, save roll */
; 829  :    /*-----------------------*/
; 830  :    if (lastMode != RoopMode)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+140], 13			; 0000000dH
	je	$LN5@RollOutOfP

; 831  :    {
; 832  :       mnverTime = 1.0F;//me123 from 4

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+508], xmm0

; 833  : 
; 834  :       /*----------------------------------------------------*/
; 835  :       /* want to roll toward the vertical but limit to keep */
; 836  :       /* droll < 45 degrees.                                */
; 837  :       /*----------------------------------------------------*/
; 838  :       if (self->Roll() >= 0.0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv168[ebp]
	movss	xmm0, DWORD PTR tv168[ebp]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN6@RollOutOfP

; 839  :       {
; 840  :          newroll = self->Roll() - 30.0F*DTR;//me123 don't do a fucking quarterplane :-) from 45

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv173[ebp]
	movss	xmm0, DWORD PTR tv173[ebp]
	subss	xmm0, DWORD PTR __real@3f060a91
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+512], xmm0

; 841  :       }
; 842  :       else 

	jmp	SHORT $LN5@RollOutOfP
$LN6@RollOutOfP:

; 843  :       {
; 844  :          newroll = self->Roll() + 30.0F*DTR;//me123 don't do a fucking quarterplane :-) from 45

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv179[ebp]
	movss	xmm0, DWORD PTR tv179[ebp]
	addss	xmm0, DWORD PTR __real@3f060a91
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+512], xmm0
$LN5@RollOutOfP:

; 845  :       }
; 846  :    }
; 847  :     
; 848  :    /*------------*/
; 849  :    /* roll error */
; 850  :    /*------------*/
; 851  :    eroll = newroll - self->Roll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv185[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+512]
	subss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR _eroll$[ebp], xmm0

; 852  : 
; 853  :    /*-----------------------------*/
; 854  :    /* roll the shortest direction */
; 855  :    /*-----------------------------*/
; 856  :    if (eroll < -180.0F*DTR)

	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR _eroll$[ebp]
	jbe	SHORT $LN4@RollOutOfP

; 857  :       eroll += 360.0F*DTR;

	movss	xmm0, DWORD PTR _eroll$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _eroll$[ebp], xmm0
	jmp	SHORT $LN2@RollOutOfP
$LN4@RollOutOfP:

; 858  :    else if (eroll > 180.0F*DTR)

	movss	xmm0, DWORD PTR _eroll$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN2@RollOutOfP

; 859  :       eroll -= 360.0F*DTR;

	movss	xmm0, DWORD PTR _eroll$[ebp]
	subss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _eroll$[ebp], xmm0
$LN2@RollOutOfP:

; 860  : 
; 861  :    SetPstick(af->GsAvail(), maxGs, AirframeClass::GCommand);

	push	128					; 00000080H
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+96]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GsAvail@AirframeClass@@QAEMXZ		; AirframeClass::GsAvail
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 862  :    SetRstick(eroll * RTD);

	movss	xmm0, DWORD PTR _eroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 863  : 
; 864  :    /*-----------*/
; 865  :    /* exit mode */
; 866  :    /*-----------*/
; 867  :    mnverTime -= SimLibMajorFrameTime;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+508]
	subss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+508], xmm0

; 868  : 
; 869  :    if (mnverTime > 0.0) 

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+508]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN1@RollOutOfP

; 870  :    {
; 871  :       AddMode(RoopMode);

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@DigitalBrain@@IAEXW4DigiMode@1@@Z ; DigitalBrain::AddMode
$LN1@RollOutOfP:

; 872  :    }
; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RollOutOfPlane@DigitalBrain@@IAEXXZ ENDP		; DigitalBrain::RollOutOfPlane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv225 = -52						; size = 4
tv219 = -48						; size = 4
tv212 = -44						; size = 4
tv206 = -40						; size = 4
tv198 = -36						; size = 4
tv192 = -32						; size = 4
tv179 = -28						; size = 4
_retval$ = -24						; size = 4
_turnDir$ = -20						; size = 4
_newTurn$ = -16						; size = 4
_altErr$ = -12						; size = 4
_psiErr$ = -8						; size = 4
_this$ = -4						; size = 4
_desPsi$ = 8						; size = 4
_desAlt$ = 12						; size = 4
?HeadingAndAltitudeHold@DigitalBrain@@IAEHMM@Z PROC	; DigitalBrain::HeadingAndAltitudeHold
; _this$ = ecx

; 748  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 749  : float altErr, psiErr;
; 750  : int retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0

; 751  : int newTurn;
; 752  : float turnDir;
; 753  : 
; 754  :    psiErr = desPsi - self->Yaw();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv179[ebp]
	movss	xmm0, DWORD PTR _desPsi$[ebp]
	subss	xmm0, DWORD PTR tv179[ebp]
	movss	DWORD PTR _psiErr$[ebp], xmm0

; 755  :    if (psiErr > 180.0F * DTR)

	movss	xmm0, DWORD PTR _psiErr$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fd9
	jbe	SHORT $LN10@HeadingAnd

; 756  :       psiErr -= 360.0F * DTR;

	movss	xmm0, DWORD PTR _psiErr$[ebp]
	subss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _psiErr$[ebp], xmm0
	jmp	SHORT $LN8@HeadingAnd
$LN10@HeadingAnd:

; 757  :    else if (psiErr < -180.0F * DTR)

	movss	xmm0, DWORD PTR __real@c0490fd9
	comiss	xmm0, DWORD PTR _psiErr$[ebp]
	jbe	SHORT $LN8@HeadingAnd

; 758  :       psiErr += 360.0F * DTR;

	movss	xmm0, DWORD PTR _psiErr$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fd9
	movss	DWORD PTR _psiErr$[ebp], xmm0
$LN8@HeadingAnd:

; 759  : 
; 760  :    SetYpedal( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 761  :    if (fabs (psiErr) < 5.0F * DTR)

	push	ecx
	movss	xmm0, DWORD PTR _psiErr$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv192[ebp]
	movss	xmm0, DWORD PTR __real@3db2b8c1
	comiss	xmm0, DWORD PTR tv192[ebp]
	jbe	$LN7@HeadingAnd

; 762  :    {
; 763  :       SetRstick( -self->Roll() * 2.0F * RTD);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv198[ebp]
	movss	xmm0, DWORD PTR tv198[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 764  :       SetMaxRoll (0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 765  :       SetMaxRollDelta (-self->Roll() * 2.0F * RTD);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv206[ebp]
	movss	xmm0, DWORD PTR tv206[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta

; 766  : 
; 767  : 
; 768  : 	   altErr = desAlt + self->ZPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv212[ebp]
	movss	xmm0, DWORD PTR tv212[ebp]
	addss	xmm0, DWORD PTR _desAlt$[ebp]
	movss	DWORD PTR _altErr$[ebp], xmm0

; 769  : 	   if (fabs (altErr) < 25.0F)

	push	ecx
	movss	xmm0, DWORD PTR _altErr$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv219[ebp]
	movss	xmm0, DWORD PTR __real@41c80000
	comiss	xmm0, DWORD PTR tv219[ebp]
	jbe	SHORT $LN6@HeadingAnd

; 770  : 	   {
; 771  : 		   retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN6@HeadingAnd:

; 772  : 	   }
; 773  : 	   altErr -= self->ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR tv225[ebp]
	movss	xmm0, DWORD PTR _altErr$[ebp]
	subss	xmm0, DWORD PTR tv225[ebp]
	movss	DWORD PTR _altErr$[ebp], xmm0

; 774  : 	   GammaHold (altErr * 0.015F);

	movss	xmm0, DWORD PTR _altErr$[ebp]
	mulss	xmm0, DWORD PTR __real@3c75c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GammaHold@DigitalBrain@@IAEXM@Z	; DigitalBrain::GammaHold

; 775  :    }
; 776  :    else

	jmp	SHORT $LN5@HeadingAnd
$LN7@HeadingAnd:

; 777  :    {
; 778  :       if (psiErr > 0.0F)

	movss	xmm0, DWORD PTR _psiErr$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@HeadingAnd

; 779  :          turnDir = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _turnDir$[ebp], xmm0

; 780  :       else

	jmp	SHORT $LN3@HeadingAnd
$LN4@HeadingAnd:

; 781  :          turnDir = -1.0F;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _turnDir$[ebp], xmm0
$LN3@HeadingAnd:

; 782  : 
; 783  :       if (wvrCurrTactic == wvrPrevTactic)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+564]
	cmp	ecx, DWORD PTR [eax+568]
	jne	SHORT $LN2@HeadingAnd

; 784  :          newTurn = FALSE;

	mov	DWORD PTR _newTurn$[ebp], 0

; 785  :       else

	jmp	SHORT $LN1@HeadingAnd
$LN2@HeadingAnd:

; 786  :          newTurn = TRUE;

	mov	DWORD PTR _newTurn$[ebp], 1
$LN1@HeadingAnd:

; 787  :       LevelTurn(2.0F, turnDir, newTurn);

	mov	edx, DWORD PTR _newTurn$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _turnDir$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LevelTurn@DigitalBrain@@IAEXMMH@Z	; DigitalBrain::LevelTurn
$LN5@HeadingAnd:

; 788  :    }
; 789  : 
; 790  : 	return (retval);

	mov	eax, DWORD PTR _retval$[ebp]

; 791  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HeadingAndAltitudeHold@DigitalBrain@@IAEHMM@Z ENDP	; DigitalBrain::HeadingAndAltitudeHold
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv164 = -28						; size = 4
tv158 = -24						; size = 4
tv151 = -20						; size = 4
tv143 = -16						; size = 4
_retval$ = -12						; size = 4
_alterr$ = -8						; size = 4
_this$ = -4						; size = 4
_desAlt$ = 8						; size = 4
?AltitudeHold@DigitalBrain@@IAEHM@Z PROC		; DigitalBrain::AltitudeHold
; _this$ = ecx

; 723  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 724  : float alterr;
; 725  : int retval;
; 726  : 
; 727  :    SetYpedal( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 728  :    SetRstick( -self->Roll() * 2.0F * RTD);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv143[ebp]
	movss	xmm0, DWORD PTR tv143[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 729  :    SetMaxRoll (0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 730  : 
; 731  : 
; 732  : 	alterr = desAlt + self->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv151[ebp]
	movss	xmm0, DWORD PTR tv151[ebp]
	addss	xmm0, DWORD PTR _desAlt$[ebp]
	movss	DWORD PTR _alterr$[ebp], xmm0

; 733  : 	if (fabs (alterr) < 25.0F)

	push	ecx
	movss	xmm0, DWORD PTR _alterr$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv158[ebp]
	movss	xmm0, DWORD PTR __real@41c80000
	comiss	xmm0, DWORD PTR tv158[ebp]
	jbe	SHORT $LN2@AltitudeHo

; 734  : 	{
; 735  : 		retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 736  : 	}
; 737  : 	else

	jmp	SHORT $LN1@AltitudeHo
$LN2@AltitudeHo:

; 738  : 	{
; 739  : 		retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
$LN1@AltitudeHo:

; 740  : 	}
; 741  : 	alterr -= self->ZDelta();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR tv164[ebp]
	movss	xmm0, DWORD PTR _alterr$[ebp]
	subss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _alterr$[ebp], xmm0

; 742  : 	GammaHold (alterr * 0.015F);

	movss	xmm0, DWORD PTR _alterr$[ebp]
	mulss	xmm0, DWORD PTR __real@3c75c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GammaHold@DigitalBrain@@IAEXM@Z	; DigitalBrain::GammaHold

; 743  : 
; 744  : 	return (retval);

	mov	eax, DWORD PTR _retval$[ebp]

; 745  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AltitudeHold@DigitalBrain@@IAEHM@Z ENDP		; DigitalBrain::AltitudeHold
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv211 = -44						; size = 4
tv202 = -40						; size = 4
tv170 = -36						; size = 4
tv169 = -32						; size = 4
tv166 = -28						; size = 4
tv69 = -24						; size = 4
tv68 = -20						; size = 4
tv65 = -16						; size = 4
_gammaCmd$ = -12					; size = 4
_elevCmd$ = -8						; size = 4
_this$ = -4						; size = 4
_desGamma$ = 8						; size = 4
?GammaHold@DigitalBrain@@IAEXM@Z PROC			; DigitalBrain::GammaHold
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	float elevCmd;
; 796  : 	float gammaCmd;
; 797  : 
; 798  : 	// MD -- 20031110: AP ATT HLD fixes.  Dash one says the pitch hold works for +/- 60 degrees not 30
; 799  : 	// desGamma = max ( min ( desGamma, 30.0F), -30.0F);
; 800  : 	desGamma = max ( min ( desGamma, 60.0F), -60.0F);

	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _desGamma$[ebp]
	jbe	SHORT $LN9@GammaHold
	movss	xmm0, DWORD PTR _desGamma$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN10@GammaHold
$LN9@GammaHold:
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR tv65[ebp], xmm0
$LN10@GammaHold:
	movss	xmm0, DWORD PTR tv65[ebp]
	comiss	xmm0, DWORD PTR __real@c2700000
	jbe	SHORT $LN13@GammaHold
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _desGamma$[ebp]
	jbe	SHORT $LN11@GammaHold
	movss	xmm0, DWORD PTR _desGamma$[ebp]
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN12@GammaHold
$LN11@GammaHold:
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR tv68[ebp], xmm0
$LN12@GammaHold:
	movss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN14@GammaHold
$LN13@GammaHold:
	movss	xmm0, DWORD PTR __real@c2700000
	movss	DWORD PTR tv69[ebp], xmm0
$LN14@GammaHold:
	movss	xmm0, DWORD PTR tv69[ebp]
	movss	DWORD PTR _desGamma$[ebp], xmm0

; 801  : 	elevCmd = desGamma - af->gmma * RTD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [ecx+1172]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _desGamma$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _elevCmd$[ebp], xmm1

; 802  : 
; 803  : 	elevCmd *= 0.25F * self->GetKias() / 350.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv202[ebp]
	movss	xmm0, DWORD PTR tv202[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	divss	xmm0, DWORD PTR __real@43af0000
	mulss	xmm0, DWORD PTR _elevCmd$[ebp]
	movss	DWORD PTR _elevCmd$[ebp], xmm0

; 804  : 
; 805  :    if (fabs (af->gmma) < (45.0F * DTR))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1172]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv211[ebp]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR tv211[ebp]
	jbe	SHORT $LN6@GammaHold

; 806  :       elevCmd /= self->platformAngles.cosphi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR _elevCmd$[ebp]
	divss	xmm0, DWORD PTR [ecx+400]
	movss	DWORD PTR _elevCmd$[ebp], xmm0
$LN6@GammaHold:

; 807  : 
; 808  :    if (elevCmd > 0.0F)

	movss	xmm0, DWORD PTR _elevCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@GammaHold

; 809  : 		elevCmd *= elevCmd;

	movss	xmm0, DWORD PTR _elevCmd$[ebp]
	mulss	xmm0, DWORD PTR _elevCmd$[ebp]
	movss	DWORD PTR _elevCmd$[ebp], xmm0

; 810  : 	else

	jmp	SHORT $LN4@GammaHold
$LN5@GammaHold:

; 811  : 		elevCmd *= -elevCmd;

	movss	xmm0, DWORD PTR _elevCmd$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _elevCmd$[ebp]
	movss	DWORD PTR _elevCmd$[ebp], xmm0
$LN4@GammaHold:

; 812  : 
; 813  :    gammaHoldIError += 0.0025F*elevCmd;

	movss	xmm0, DWORD PTR __real@3b23d70a
	mulss	xmm0, DWORD PTR _elevCmd$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+168]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+168], xmm0

; 814  :    if (gammaHoldIError > 1.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+168]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN3@GammaHold

; 815  :       gammaHoldIError = 1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+168], xmm0
	jmp	SHORT $LN1@GammaHold
$LN3@GammaHold:

; 816  :    else if (gammaHoldIError < -1.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	comiss	xmm0, DWORD PTR [eax+168]
	jbe	SHORT $LN1@GammaHold

; 817  :       gammaHoldIError = -1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+168], xmm0
$LN1@GammaHold:

; 818  : 
; 819  :    gammaCmd = gammaHoldIError + elevCmd + (1.0F/self->platformAngles.cosphi);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+168]
	addss	xmm0, DWORD PTR _elevCmd$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, DWORD PTR [ecx+400]
	addss	xmm0, xmm1
	movss	DWORD PTR _gammaCmd$[ebp], xmm0

; 820  : 	SetPstick (min( max (gammaCmd, -2.0F), 6.5F), maxGs, AirframeClass::GCommand);

	movss	xmm0, DWORD PTR _gammaCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@c0000000
	jbe	SHORT $LN15@GammaHold
	movss	xmm0, DWORD PTR _gammaCmd$[ebp]
	movss	DWORD PTR tv166[ebp], xmm0
	jmp	SHORT $LN16@GammaHold
$LN15@GammaHold:
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR tv166[ebp], xmm0
$LN16@GammaHold:
	movss	xmm0, DWORD PTR __real@40d00000
	comiss	xmm0, DWORD PTR tv166[ebp]
	jbe	SHORT $LN19@GammaHold
	movss	xmm0, DWORD PTR _gammaCmd$[ebp]
	comiss	xmm0, DWORD PTR __real@c0000000
	jbe	SHORT $LN17@GammaHold
	movss	xmm0, DWORD PTR _gammaCmd$[ebp]
	movss	DWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN18@GammaHold
$LN17@GammaHold:
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR tv169[ebp], xmm0
$LN18@GammaHold:
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN20@GammaHold
$LN19@GammaHold:
	movss	xmm0, DWORD PTR __real@40d00000
	movss	DWORD PTR tv170[ebp], xmm0
$LN20@GammaHold:
	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 821  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GammaHold@DigitalBrain@@IAEXM@Z ENDP			; DigitalBrain::GammaHold
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv280 = -44						; size = 4
tv270 = -40						; size = 4
_elerr$ = -36						; size = 4
tv252 = -32						; size = 4
_alterr$ = -28						; size = 4
tv240 = -24						; size = 4
tv287 = -20						; size = 4
tv233 = -16						; size = 4
tv226 = -12						; size = 4
_edroll$ = -8						; size = 4
_this$ = -4						; size = 4
_load_factor$ = 8					; size = 4
_turnDir$ = 12						; size = 4
_newTurn$ = 16						; size = 4
?LevelTurn@DigitalBrain@@IAEXMMH@Z PROC			; DigitalBrain::LevelTurn
; _this$ = ecx

; 679  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 680  : float  edroll,elerr, alterr;
; 681  : 
; 682  :    /*-------------------------------------------*/
; 683  :    /* if your not flying level, level out first */
; 684  :    /*-------------------------------------------*/
; 685  :    if (newTurn)

	cmp	DWORD PTR _newTurn$[ebp], 0
	je	SHORT $LN7@LevelTurn

; 686  :    {
; 687  :       gammaHoldIError = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+168], xmm0

; 688  :       trackMode = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
$LN7@LevelTurn:

; 689  :    }
; 690  : 
; 691  :    if (trackMode != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	$LN6@LevelTurn

; 692  :    {
; 693  :       edroll = (float)atan(sqrt(load_factor*load_factor-1));

	movss	xmm0, DWORD PTR _load_factor$[ebp]
	mulss	xmm0, DWORD PTR _load_factor$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	fstp	DWORD PTR [esp]
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR _edroll$[ebp]

; 694  :       ResetMaxRoll ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetMaxRoll@DigitalBrain@@IAEXXZ	; DigitalBrain::ResetMaxRoll

; 695  :       SetMaxRollDelta (edroll*RTD);

	movss	xmm0, DWORD PTR _edroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta

; 696  :       edroll *= turnDir - af->mu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR _turnDir$[ebp]
	subss	xmm0, DWORD PTR [ecx+1180]
	mulss	xmm0, DWORD PTR _edroll$[ebp]
	movss	DWORD PTR _edroll$[ebp], xmm0

; 697  : 
; 698  :       SetRstick( edroll * RTD * 2.50F);

	movss	xmm0, DWORD PTR _edroll$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR __real@40200000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 699  : 		if (fabs(edroll) < 5.0 * DTR || trackMode == 2)

	push	ecx
	movss	xmm0, DWORD PTR _edroll$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv226[ebp]
	movss	xmm0, DWORD PTR tv226[ebp]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@3fb6571820000000
	comisd	xmm1, xmm0
	ja	SHORT $LN4@LevelTurn
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 2
	jne	SHORT $LN5@LevelTurn
$LN4@LevelTurn:

; 700  : 		{
; 701  :          alterr = (holdAlt + self->ZPos() - self->ZDelta()) * 0.015F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv233[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv233[ebp]
	addss	xmm0, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	movss	DWORD PTR tv287[ebp], xmm0
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	fstp	DWORD PTR tv240[ebp]
	movss	xmm0, DWORD PTR tv287[ebp]
	subss	xmm0, DWORD PTR tv240[ebp]
	mulss	xmm0, DWORD PTR __real@3c75c28f
	movss	DWORD PTR _alterr$[ebp], xmm0

; 702  :          GammaHold (alterr);

	push	ecx
	movss	xmm0, DWORD PTR _alterr$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GammaHold@DigitalBrain@@IAEXM@Z	; DigitalBrain::GammaHold

; 703  : 			trackMode = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 2

; 704  : 		}
; 705  : 		else

	jmp	SHORT $LN3@LevelTurn
$LN5@LevelTurn:

; 706  :          SetPstick(0.0F, 5.0F, AirframeClass::GCommand);

	push	128					; 00000080H
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)
$LN3@LevelTurn:

; 707  :    }
; 708  :    else

	jmp	$LN1@LevelTurn
$LN6@LevelTurn:

; 709  :    {
; 710  :       SetRstick( -self->Roll() * RTD);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv252[ebp]
	movss	xmm0, DWORD PTR tv252[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRstick@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetRstick
	fstp	ST(0)

; 711  :       SetMaxRoll (0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRoll@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRoll

; 712  :       SetMaxRollDelta (5.0F*RTD);

	push	ecx
	movss	xmm0, DWORD PTR __real@438f3d4d
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRollDelta@DigitalBrain@@IAEXM@Z	; DigitalBrain::SetMaxRollDelta

; 713  :       elerr = -af->gmma;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [eax+1172]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _elerr$[ebp], xmm0

; 714  :       SetPstick( elerr * RTD, 2.5F, AirframeClass::ErrorCommand);

	push	256					; 00000100H
	push	ecx
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _elerr$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPstick@DigitalBrain@@IAEMMMH@Z	; DigitalBrain::SetPstick
	fstp	ST(0)

; 715  :       if (fabs(af->gmma) < 2.0 * DTR && fabs(self->Roll()) < 10.0 * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1172]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv270[ebp]
	movss	xmm0, DWORD PTR tv270[ebp]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@3fa1df4680000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN1@LevelTurn
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv280[ebp]
	movss	xmm0, DWORD PTR tv280[ebp]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@3fc6571820000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN1@LevelTurn

; 716  : 			trackMode = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 1
$LN1@LevelTurn:

; 717  :    }
; 718  : 
; 719  :    SetYpedal( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYpedal@DigitalBrain@@IAEMM@Z	; DigitalBrain::SetYpedal
	fstp	ST(0)

; 720  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LevelTurn@DigitalBrain@@IAEXMMH@Z ENDP			; DigitalBrain::LevelTurn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv306 = -32						; size = 4
tv276 = -28						; size = 4
tv267 = -24						; size = 4
tv259 = -20						; size = 4
tv186 = -16						; size = 4
tv185 = -12						; size = 4
tv170 = -8						; size = 4
_this$ = -4						; size = 4
?Loiter@DigitalBrain@@IAEXXZ PROC			; DigitalBrain::Loiter
; _this$ = ecx

; 636  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	//we don't want to loiter just above the ground
; 638  : //	trackZ = min(max(-20000.0F, trackZ), -5000.0F);
; 639  : 
; 640  : 	// Cobra - Use local max elevation to try and keep AI from lawndarting
; 641  : 	trackZ = -TheMap.GetMEA(((AircraftClass*) self)->XPos(), ((AircraftClass*) self)->YPos()) - 2000.0F; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?TheMap@@3VTMap@@A		; TheMap
	call	?GetMEA@TMap@@QAEMMM@Z			; TMap::GetMEA
	fstp	DWORD PTR tv259[ebp]
	movss	xmm0, DWORD PTR tv259[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR __real@44fa0000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+156], xmm0

; 642  : 
; 643  : 	if(((AircraftClass*) self)->af->GetSimpleMode()) {		// do simple flight model

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetSimpleMode@AirframeClass@@QAEHXZ	; AirframeClass::GetSimpleMode
	test	eax, eax
	je	$LN6@Loiter

; 644  : 
; 645  : 		throtl = SimpleScaleThrottle(af->MinVcas()*KNOTS_TO_FTPSEC);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv267[ebp]
	movss	xmm0, DWORD PTR tv267[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleScaleThrottle@DigitalBrain@@IAEMM@Z ; DigitalBrain::SimpleScaleThrottle
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+40]

; 646  : 		//pStick = 0.0F;		// level
; 647  : 		pStick = SimpleTrackElevation(trackZ - self->ZPos(), 10000.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv276[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+156]
	subss	xmm0, DWORD PTR tv276[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SimpleTrackElevation@DigitalBrain@@IAEMMM@Z ; DigitalBrain::SimpleTrackElevation
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 648  : 		pStick = min( 0.2f, max(pStick, -0.3F) );

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	comiss	xmm0, DWORD PTR __real@be99999a
	jbe	SHORT $LN9@Loiter
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN10@Loiter
$LN9@Loiter:
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR tv170[ebp], xmm0
$LN10@Loiter:
	movss	xmm0, DWORD PTR tv170[ebp]
	comiss	xmm0, DWORD PTR __real@3e4ccccd
	jbe	SHORT $LN13@Loiter
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR tv186[ebp], xmm0
	jmp	SHORT $LN14@Loiter
$LN13@Loiter:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+28]
	comiss	xmm0, DWORD PTR __real@be99999a
	jbe	SHORT $LN11@Loiter
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR tv185[ebp], xmm0
	jmp	SHORT $LN12@Loiter
$LN11@Loiter:
	movss	xmm0, DWORD PTR __real@be99999a
	movss	DWORD PTR tv185[ebp], xmm0
$LN12@Loiter:
	movss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR tv186[ebp], xmm0
$LN14@Loiter:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv186[ebp]
	movss	DWORD PTR [edx+28], xmm0

; 649  : 		rStick = 0.15F;	// 13.5 degree bank turn

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [eax+32], xmm0

; 650  : 	}
; 651  : 	else {

	jmp	$LN1@Loiter
$LN6@Loiter:

; 652  : 		/*-----------*/
; 653  : 		/* MACH HOLD */
; 654  : 		/*-----------*/
; 655  : 		if (curMode != lastMode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+136]
	cmp	eax, DWORD PTR [edx+140]
	je	SHORT $LN4@Loiter

; 656  : 		{
; 657  : 			onStation = Stabalizing;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+132], 2

; 658  : 			holdAlt = -self->ZPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv306[ebp]
	movss	xmm0, DWORD PTR tv306[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+160], xmm0
$LN4@Loiter:

; 659  : 		}
; 660  :    
; 661  :             
; 662  : 		if (onStation == Stabalizing)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+132], 2
	jne	$LN3@Loiter

; 663  : 		{
; 664  : 			if (MachHold(cornerSpeed, self->GetKias(), TRUE))

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+100]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MachHold@DigitalBrain@@IAEHMMH@Z	; DigitalBrain::MachHold
	test	eax, eax
	je	SHORT $LN2@Loiter

; 665  : 			{
; 666  : 				onStation = OnStation;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 3

; 667  : 				LevelTurn (2.0F, 1.0F, TRUE);

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LevelTurn@DigitalBrain@@IAEXMMH@Z	; DigitalBrain::LevelTurn
$LN2@Loiter:

; 668  : 			}
; 669  : 			AltitudeHold (holdAlt);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+160]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AltitudeHold@DigitalBrain@@IAEHM@Z	; DigitalBrain::AltitudeHold

; 670  : 		}
; 671  : 		else

	jmp	SHORT $LN1@Loiter
$LN3@Loiter:

; 672  : 		{
; 673  : 			LevelTurn(2.0F, 1.0F, FALSE);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LevelTurn@DigitalBrain@@IAEXMMH@Z	; DigitalBrain::LevelTurn
$LN1@Loiter:

; 674  : 		}
; 675  : 	}
; 676  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Loiter@DigitalBrain@@IAEXXZ ENDP			; DigitalBrain::Loiter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\digi\mnvers.cpp
_TEXT	SEGMENT
tv797 = -268						; size = 4
tv930 = -264						; size = 4
tv1038 = -260						; size = 4
tv804 = -256						; size = 4
tv969 = -252						; size = 4
tv760 = -248						; size = 4
tv439 = -244						; size = 4
tv547 = -240						; size = 4
tv389 = -236						; size = 4
tv209 = -232						; size = 4
tv344 = -228						; size = 4
tv201 = -224						; size = 4
tv158 = -220						; size = 4
tv346 = -216						; size = 4
tv628 = -212						; size = 4
tv342 = -208						; size = 4
tv627 = -204						; size = 4
_dist$ = -200						; size = 4
tv612 = -196						; size = 4
tv208 = -192						; size = 4
tv581 = -188						; size = 4
_size$1 = -184						; size = 4
_dx$ = -180						; size = 4
_flightMember$2 = -176					; size = 4
_dy$ = -172						; size = 4
_burnerDelta$ = -168					; size = 4
_i$3 = -164						; size = 4
_usedVtDot$4 = -160					; size = 4
_cornerDelta$ = -156					; size = 4
_maxDelta$ = -152					; size = 4
tv129 = -145						; size = 1
_eProp$ = -144						; size = 4
_thr$ = -140						; size = 4
_this$ = -136						; size = 4
_tmpchr$5 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_pitchStick$ = 16					; size = 4
?MachHold@DigitalBrain@@IAEHMMH@Z PROC			; DigitalBrain::MachHold
; _this$ = ecx

; 407  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 408  : float eProp=0.0F, thr=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _eProp$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _thr$[ebp], xmm0

; 409  : float maxDelta=0.0F, cornerDelta=0.0F, burnerDelta=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _maxDelta$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cornerDelta$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _burnerDelta$[ebp], xmm0

; 410  : float dx = 0,dy = 0,dist = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dist$[ebp], xmm0

; 411  : 
; 412  :    eProp  = m1 - m2;

	movss	xmm0, DWORD PTR _m1$[ebp]
	subss	xmm0, DWORD PTR _m2$[ebp]
	movss	DWORD PTR _eProp$[ebp], xmm0

; 413  : 
; 414  :    /*-----------------*/
; 415  :    /* knots indicated */
; 416  :    /*-----------------*/
; 417  : 
; 418  : // 2001-10-28 ADDED "* FTPSEC_TO_KNOTS" to MinVCas by M.N. this function needs knots 2002-03-14 REMOVED BY S.G. MinVcas is ALREADY in KNOTS and NOT in FTPSEC
; 419  : // Added it back in, Hehe... // JPG 2 Jan 04
; 420  :    //TJL 02/20/04 Took it back out ;)
; 421  :    if (m1 < (af->MinVcas()) && af->IsSet(AirframeClass::InAir))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv760[ebp]
	movss	xmm0, DWORD PTR tv760[ebp]
	comiss	xmm0, DWORD PTR _m1$[ebp]
	jbe	SHORT $LN61@MachHold
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN61@MachHold

; 422  :    {
; 423  :    //Cobra 10/31/04 TJL
; 424  :       m1 = af->MinVcas(); // * TJL 08/28/04 FTPSEC_TO_KNOTS; m1 is in KNOTS and MinVcas is in KNOTS

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR _m1$[ebp]

; 425  :       eProp = m1 - m2;

	movss	xmm0, DWORD PTR _m1$[ebp]
	subss	xmm0, DWORD PTR _m2$[ebp]
	movss	DWORD PTR _eProp$[ebp], xmm0
$LN61@MachHold:

; 426  :    }
; 427  : //me123 addet the max check. we don't wanna exceed the airframe max speed
; 428  :    if (m1 > af->curMaxStoreSpeed -20.0f && af->IsSet(AirframeClass::InAir))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [ecx+1612]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	xmm1, DWORD PTR _m1$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN60@MachHold
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	je	SHORT $LN60@MachHold

; 429  :    {
; 430  :       m1 = af->curMaxStoreSpeed -20.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [ecx+1612]
	subss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _m1$[ebp], xmm0

; 431  :       eProp = m1 - m2 - g_fePropFactor;

	movss	xmm0, DWORD PTR _m1$[ebp]
	subss	xmm0, DWORD PTR _m2$[ebp]
	subss	xmm0, DWORD PTR ?g_fePropFactor@@3MA
	movss	DWORD PTR _eProp$[ebp], xmm0
$LN60@MachHold:

; 432  :    }
; 433  : 
; 434  :    af->SetFlaps(curMode == LandingMode);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 5
	jne	SHORT $LN64@MachHold
	mov	BYTE PTR tv129[ebp], 1
	jmp	SHORT $LN65@MachHold
$LN64@MachHold:
	mov	BYTE PTR tv129[ebp], 0
$LN65@MachHold:
	movzx	eax, BYTE PTR tv129[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?SetFlaps@AirframeClass@@QAEX_N@Z	; AirframeClass::SetFlaps

; 435  :    if (eProp < -100.0F)

	movss	xmm0, DWORD PTR __real@c2c80000
	comiss	xmm0, DWORD PTR _eProp$[ebp]
	jbe	SHORT $LN59@MachHold

; 436  :    {
; 437  :       thr = 0.0F;                        /* idle and boards */

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _thr$[ebp], xmm0

; 438  :       if (curMode > DefensiveModes && curMode < LoiterMode)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 6
	jle	SHORT $LN58@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 17			; 00000011H
	jge	SHORT $LN58@MachHold

; 439  :          af->speedBrake = 1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+1560], xmm0

; 440  :       else

	jmp	SHORT $LN57@MachHold
$LN58@MachHold:

; 441  :          af->speedBrake = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+1560], xmm0
$LN57@MachHold:
	jmp	$LN15@MachHold
$LN59@MachHold:

; 442  :    }
; 443  :    else if (eProp < -50.0F)

	movss	xmm0, DWORD PTR __real@c2480000
	comiss	xmm0, DWORD PTR _eProp$[ebp]
	jbe	SHORT $LN55@MachHold

; 444  :    {
; 445  :       thr = 0.0F;                        /* idle  */

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _thr$[ebp], xmm0

; 446  :       af->speedBrake = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1560], xmm0

; 447  :    }
; 448  :    else

	jmp	$LN15@MachHold
$LN55@MachHold:

; 449  :    {
; 450  :       // If in combat take vtDot into account
; 451  :       // For waypoint stuff you need to be really slow to hit burner
; 452  :       if (curMode < LoiterMode && curMode != LandingMode) // 2002-02-12 MODIFIED BY S.G. And not in landing mode

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 17			; 00000011H
	jge	$LN53@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 5
	je	$LN53@MachHold

; 453  :       {
; 454  :          eProp -= min (2.0F * af->VtDot(), 0.0F);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?VtDot@AirframeClass@@QAEMXZ		; AirframeClass::VtDot
	fstp	DWORD PTR tv797[ebp]
	movss	xmm0, DWORD PTR tv797[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN66@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?VtDot@AirframeClass@@QAEMXZ		; AirframeClass::VtDot
	fstp	DWORD PTR tv804[ebp]
	movss	xmm0, DWORD PTR tv804[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv158[ebp], xmm0
	jmp	SHORT $LN67@MachHold
$LN66@MachHold:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv158[ebp], xmm0
$LN67@MachHold:
	movss	xmm0, DWORD PTR _eProp$[ebp]
	subss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR _eProp$[ebp], xmm0

; 455  :          burnerDelta = 100.0F;

	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _burnerDelta$[ebp], xmm0

; 456  :       }
; 457  :       else

	jmp	SHORT $LN51@MachHold
$LN53@MachHold:

; 458  :       {
; 459  :          burnerDelta = 500.0F;

	movss	xmm0, DWORD PTR __real@43fa0000
	movss	DWORD PTR _burnerDelta$[ebp], xmm0

; 460  : // 2002-03-26 MN make it harder to go into afterburner when in waypoint- or wingymode
; 461  : 		 if (curMode == WingyMode || curMode == WaypointMode)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 20			; 00000014H
	je	SHORT $LN50@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 22			; 00000016H
	jne	SHORT $LN51@MachHold
$LN50@MachHold:

; 462  : 			 burnerDelta = g_fWaypointBurnerDelta;

	movss	xmm0, DWORD PTR ?g_fWaypointBurnerDelta@@3MA
	movss	DWORD PTR _burnerDelta$[ebp], xmm0
$LN51@MachHold:

; 463  :       }
; 464  : 
; 465  :       if (eProp >= burnerDelta) 

	movss	xmm0, DWORD PTR _eProp$[ebp]
	comiss	xmm0, DWORD PTR _burnerDelta$[ebp]
	jb	SHORT $LN49@MachHold

; 466  :       {
; 467  :          thr = 1.5F;                        /* burner     */

	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR _thr$[ebp], xmm0

; 468  :          af->speedBrake = -1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+1560], xmm0

; 469  :       }
; 470  :       else 

	jmp	$LN48@MachHold
$LN49@MachHold:

; 471  :       {
; 472  : 		 // 2002-03-14 MODIFIED BY S.G. Lets fine tune this throttle thing
; 473  : //       thr = (eProp + 100.0F) * 0.008F;     /* linear in-between */
; 474  : //       autoThrottle += eProp * 0.001F * SimLibMajorFrameTime;
; 475  : //       autoThrottle += eProp * timeStep * SimLibMajorFrameTime;
; 476  : 		 // Here we take tVtDot in consideration but clip it at +-5 so it doesn't affect too much
; 477  : 		 float usedVtDot = af->VtDot();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?VtDot@AirframeClass@@QAEMXZ		; AirframeClass::VtDot
	fstp	DWORD PTR _usedVtDot$4[ebp]

; 478  : 		 if (usedVtDot > g_fFuelVtClip)

	movss	xmm0, DWORD PTR _usedVtDot$4[ebp]
	comiss	xmm0, DWORD PTR ?g_fFuelVtClip@@3MA
	jbe	SHORT $LN47@MachHold

; 479  : 			 usedVtDot = g_fFuelVtClip;

	movss	xmm0, DWORD PTR ?g_fFuelVtClip@@3MA
	movss	DWORD PTR _usedVtDot$4[ebp], xmm0
	jmp	SHORT $LN45@MachHold
$LN47@MachHold:

; 480  : 		 else if (usedVtDot < -g_fFuelVtClip)

	movss	xmm0, DWORD PTR ?g_fFuelVtClip@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _usedVtDot$4[ebp]
	jbe	SHORT $LN45@MachHold

; 481  : 			 usedVtDot = -g_fFuelVtClip;

	movss	xmm0, DWORD PTR ?g_fFuelVtClip@@3MA
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _usedVtDot$4[ebp], xmm0
$LN45@MachHold:

; 482  : 
; 483  :          thr = (eProp + g_fFuelBaseProp) * g_fFuelMultProp; /* linear in-between */

	movss	xmm0, DWORD PTR _eProp$[ebp]
	addss	xmm0, DWORD PTR ?g_fFuelBaseProp@@3MA
	mulss	xmm0, DWORD PTR ?g_fFuelMultProp@@3MA
	movss	DWORD PTR _thr$[ebp], xmm0

; 484  :          autoThrottle += (eProp - usedVtDot * g_fFuelVtDotMult) * g_fFuelTimeStep * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _usedVtDot$4[ebp]
	mulss	xmm0, DWORD PTR ?g_fFuelVtDotMult@@3MA
	movss	xmm1, DWORD PTR _eProp$[ebp]
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?g_fFuelTimeStep@@3MA
	mulss	xmm1, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm1, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+88], xmm1

; 485  : 
; 486  : 		 // Now see if we're asking to increase/cut the throtle because of speed difference too much (don't go the other direction)
; 487  : 		 if (g_bFuelLimitBecauseVtDot) {

	movzx	eax, BYTE PTR ?g_bFuelLimitBecauseVtDot@@3_NA ; g_bFuelLimitBecauseVtDot
	test	eax, eax
	je	SHORT $LN41@MachHold

; 488  : 			 if (eProp > 0.0f && autoThrottle < 0.0f)

	movss	xmm0, DWORD PTR _eProp$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN43@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+88]
	jbe	SHORT $LN43@MachHold

; 489  : 				 autoThrottle = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+88], xmm0
	jmp	SHORT $LN41@MachHold
$LN43@MachHold:

; 490  : 			 else if (eProp < 0.0f && autoThrottle > 0.0f)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _eProp$[ebp]
	jbe	SHORT $LN41@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN41@MachHold

; 491  : 				 autoThrottle = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+88], xmm0
$LN41@MachHold:

; 492  : 		 }
; 493  : 		 // END OF MODFIED SECTION 2002-03-14
; 494  : 		
; 495  :          autoThrottle = max ( min (autoThrottle, 1.5F), -1.5F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [edx+88]
	jbe	SHORT $LN68@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	movss	DWORD PTR tv201[ebp], xmm0
	jmp	SHORT $LN69@MachHold
$LN68@MachHold:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv201[ebp], xmm0
$LN69@MachHold:
	movss	xmm0, DWORD PTR tv201[ebp]
	comiss	xmm0, DWORD PTR __real@bfc00000
	jbe	SHORT $LN72@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [ecx+88]
	jbe	SHORT $LN70@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+88]
	movss	DWORD PTR tv208[ebp], xmm0
	jmp	SHORT $LN71@MachHold
$LN70@MachHold:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv208[ebp], xmm0
$LN71@MachHold:
	movss	xmm0, DWORD PTR tv208[ebp]
	movss	DWORD PTR tv209[ebp], xmm0
	jmp	SHORT $LN73@MachHold
$LN72@MachHold:
	movss	xmm0, DWORD PTR __real@bfc00000
	movss	DWORD PTR tv209[ebp], xmm0
$LN73@MachHold:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR [eax+88], xmm0

; 496  :          thr += autoThrottle;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _thr$[ebp]
	addss	xmm0, DWORD PTR [ecx+88]
	movss	DWORD PTR _thr$[ebp], xmm0

; 497  : 		 if (flightLead)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+708], 0
	je	$LN40@MachHold

; 498  : 		 {
; 499  : 			 dx = ((AircraftClass*)flightLead)->af->x - af->x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	movss	xmm0, DWORD PTR [edx+1108]
	subss	xmm0, DWORD PTR [ecx+1108]
	movss	DWORD PTR _dx$[ebp], xmm0

; 500  : 			 dy = ((AircraftClass*)flightLead)->af->y - af->y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR [ecx+1112]
	subss	xmm0, DWORD PTR [eax+1112]
	movss	DWORD PTR _dy$[ebp], xmm0

; 501  : 			 dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]
$LN40@MachHold:

; 502  : 		 }
; 503  :          // no burner unless in combat
; 504  :          if ((curMode >= LoiterMode || curMode == LandingMode) &&											// 2002-02-12 MODIFIED BY S.G. Don't go in AB if you're in landing mode either
; 505  : 					m2 > aeroDataset[self->af->VehicleIndex()].inputData[AeroDataSet::MinVcas] * 0.9f &&	// JB 011018 If we can't keep our speed up, use the buner 2002-02-12 MODIFIED BY S.G. Use a percentage of MinVcas instead.
; 506  : 					(!flightLead || flightLead && ((AircraftClass*)flightLead)->af) && 
; 507  : 					(!flightLead || (((AircraftClass*)flightLead)->af == af || ((((AircraftClass*)flightLead)->af->rpm < 1.0F)) &&										// JB 011025 If the lead is using his burner, we can use ours 2002-02-12 MODIFIED BY S.G. Don't look at lead's burner or g_fFormationBurnerDistance if we're RTBing...
; 508  : 					dist < g_fFormationBurnerDistance * NM_TO_FT) || curMode == RTBMode) ||					// allow usage of burner if lead is more than defined distance away
; 509  : 					self->OnGround())																		// never use AB on ground

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 17			; 00000011H
	jge	SHORT $LN36@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 5
	jne	$LN37@MachHold
$LN36@MachHold:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [ecx+932]
	call	?VehicleIndex@AirframeClass@@QAEHXZ	; AirframeClass::VehicleIndex
	imul	eax, 220				; 000000dcH
	add	eax, DWORD PTR ?aeroDataset@@3PAVAeroDataSet@@A ; aeroDataset
	mov	edx, 4
	imul	edx, 9
	movss	xmm0, DWORD PTR [eax+edx+16]
	mulss	xmm0, DWORD PTR __real@3f666666
	movss	xmm1, DWORD PTR _m2$[ebp]
	comiss	xmm1, xmm0
	jbe	$LN37@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+708], 0
	je	SHORT $LN35@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+708], 0
	je	$LN37@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $LN37@MachHold
$LN35@MachHold:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+708], 0
	je	$LN38@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+708]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+932]
	cmp	edx, DWORD PTR [ecx+60]
	je	SHORT $LN38@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+708]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [edx+1212]
	jbe	SHORT $LN34@MachHold
	movss	xmm0, DWORD PTR ?g_fFormationBurnerDistance@@3MA
	mulss	xmm0, DWORD PTR __real@45bde1b0
	comiss	xmm0, DWORD PTR _dist$[ebp]
	ja	SHORT $LN38@MachHold
$LN34@MachHold:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 19			; 00000013H
	je	SHORT $LN38@MachHold
$LN37@MachHold:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN26@MachHold
$LN38@MachHold:

; 510  :          {
; 511  :             // Flight lead goes even slower so wingies can catch up
; 512  : /* 2002-02-12 MODIFIED BY S.G. Take the wings 'mInPositionFlag' flag before limiting ourself
; 513  :             if (!isWing)
; 514  :                thr = min (thr, 0.9F);
; 515  :             else
; 516  :                thr = min (thr, 0.975F); */
; 517  : 			if (!isWing) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN33@MachHold

; 518  : 				// The lead will look at everybody else's position and push faster if everyone is in position.
; 519  : 				int size = self->GetCampaignObject()->NumberOfComponents();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	mov	DWORD PTR _size$1[ebp], eax

; 520  : 				int i;
; 521  : 				for (i = 1; i < size; i++) {

	mov	DWORD PTR _i$3[ebp], 1
	jmp	SHORT $LN32@MachHold
$LN31@MachHold:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN32@MachHold:
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR _size$1[ebp]
	jge	SHORT $LN30@MachHold

; 522  : 					AircraftClass *flightMember = (AircraftClass *)self->GetCampaignObject()->GetComponentEntity(i);

	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _flightMember$2[ebp], eax

; 523  : 					// This code is assuming the lead and the AI are on the same PC... Should be no problem unless another player is in Combat AP...
; 524  : 					if (flightMember && flightMember->DBrain() && !flightMember->DBrain()->mInPositionFlag)

	cmp	DWORD PTR _flightMember$2[ebp], 0
	je	SHORT $LN29@MachHold
	mov	ecx, DWORD PTR _flightMember$2[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	test	eax, eax
	je	SHORT $LN29@MachHold
	mov	ecx, DWORD PTR _flightMember$2[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	cmp	DWORD PTR [eax+840], 0
	jne	SHORT $LN29@MachHold

; 525  : 						break;

	jmp	SHORT $LN30@MachHold
$LN29@MachHold:

; 526  : 				}

	jmp	SHORT $LN31@MachHold
$LN30@MachHold:

; 527  : 				if (i == size)

	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR _size$1[ebp]
	jne	SHORT $LN28@MachHold

; 528  : 					thr = min (thr, 0.99F);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _thr$[ebp]
	jbe	SHORT $LN74@MachHold
	movss	xmm0, DWORD PTR _thr$[ebp]
	movss	DWORD PTR tv342[ebp], xmm0
	jmp	SHORT $LN75@MachHold
$LN74@MachHold:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv342[ebp], xmm0
$LN75@MachHold:
	movss	xmm0, DWORD PTR tv342[ebp]
	movss	DWORD PTR _thr$[ebp], xmm0

; 529  : 				else

	jmp	SHORT $LN27@MachHold
$LN28@MachHold:

; 530  : 					thr = min (thr, 0.9F);

	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR _thr$[ebp]
	jbe	SHORT $LN76@MachHold
	movss	xmm0, DWORD PTR _thr$[ebp]
	movss	DWORD PTR tv344[ebp], xmm0
	jmp	SHORT $LN77@MachHold
$LN76@MachHold:
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv344[ebp], xmm0
$LN77@MachHold:
	movss	xmm0, DWORD PTR tv344[ebp]
	movss	DWORD PTR _thr$[ebp], xmm0
$LN27@MachHold:

; 531  : 			}
; 532  : 			else {

	jmp	SHORT $LN26@MachHold
$LN33@MachHold:

; 533  : 				// While wingmen unlike look after themself...
; 534  : // 2002-04-07 MN limit wingmen only not to use afterburner, but they may catch up with full MIL power
; 535  : //				if (mInPositionFlag)
; 536  : 					thr = min (thr, 0.99F);

	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _thr$[ebp]
	jbe	SHORT $LN78@MachHold
	movss	xmm0, DWORD PTR _thr$[ebp]
	movss	DWORD PTR tv346[ebp], xmm0
	jmp	SHORT $LN79@MachHold
$LN78@MachHold:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv346[ebp], xmm0
$LN79@MachHold:
	movss	xmm0, DWORD PTR tv346[ebp]
	movss	DWORD PTR _thr$[ebp], xmm0
$LN26@MachHold:

; 537  : //				else
; 538  : //					thr = min (thr, 0.975F); 
; 539  : 			}
; 540  : 
; 541  :          }
; 542  :          af->speedBrake = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+1560], xmm0
$LN48@MachHold:

; 543  :       }
; 544  : 	  
; 545  :       // Scale pStick if way off
; 546  :       if (targetPtr && HoldCorner (self->CombatClass(), targetPtr))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN15@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [edx+144]
	call	eax
	push	eax
	call	?HoldCorner@@YAHHPAVSimObjectType@@@Z	; HoldCorner
	add	esp, 8
	test	eax, eax
	je	$LN15@MachHold

; 547  :       {
; 548  :          cornerDelta = cornerSpeed - m2;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+100]
	subss	xmm0, DWORD PTR _m2$[ebp]
	movss	DWORD PTR _cornerDelta$[ebp], xmm0

; 549  :          cornerDelta -= 2.0F * af->VtDot();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?VtDot@AirframeClass@@QAEMXZ		; AirframeClass::VtDot
	fstp	DWORD PTR tv930[ebp]
	movss	xmm0, DWORD PTR tv930[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _cornerDelta$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _cornerDelta$[ebp], xmm1

; 550  :          switch (SkillLevel())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	mov	DWORD PTR tv389[ebp], eax
	cmp	DWORD PTR tv389[ebp], 3
	ja	SHORT $LN18@MachHold
	mov	eax, DWORD PTR tv389[ebp]
	jmp	DWORD PTR $LN92@MachHold[eax*4]
$LN22@MachHold:

; 551  :          {
; 552  :             case 0:  // Recruit, pull till you drop
; 553  :                maxDelta = 1000.0F;

	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _maxDelta$[ebp], xmm0

; 554  :             break;

	jmp	SHORT $LN23@MachHold
$LN21@MachHold:

; 555  : 
; 556  :             case 1:  // Rookie, pull almost till you drop
; 557  :                maxDelta = 250.0F;

	movss	xmm0, DWORD PTR __real@437a0000
	movss	DWORD PTR _maxDelta$[ebp], xmm0

; 558  :             break;

	jmp	SHORT $LN23@MachHold
$LN20@MachHold:

; 559  : 
; 560  :             case 2:  // Average, pull too far
; 561  :                maxDelta = 200.0F;

	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR _maxDelta$[ebp], xmm0

; 562  :             break;

	jmp	SHORT $LN23@MachHold
$LN19@MachHold:

; 563  : 
; 564  :             case 3:  // Good, pull a little to far
; 565  :                maxDelta = 100.0F;

	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _maxDelta$[ebp], xmm0

; 566  :             break;

	jmp	SHORT $LN23@MachHold
$LN18@MachHold:

; 567  : 
; 568  :             case 4:  // Ace, back off and hold desired speed
; 569  : 			default:
; 570  :                maxDelta = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _maxDelta$[ebp], xmm0
$LN23@MachHold:

; 571  :             break;
; 572  :          }
; 573  : if (pStick > 1.0f) pStick = 1.0f;//me123

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN17@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+28], xmm0
$LN17@MachHold:

; 574  : 
; 575  : if (!af->IsSet(AirframeClass::IsDigital)) maxDelta = 0.0F;

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN16@MachHold
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _maxDelta$[ebp], xmm0
$LN16@MachHold:

; 576  : 
; 577  :          if (pitchStick && cornerDelta > maxDelta && pStick > 0.0F)// && fabs(self->Roll()) < 110.0F * DTR)

	cmp	DWORD PTR _pitchStick$[ebp], 0
	je	$LN15@MachHold
	movss	xmm0, DWORD PTR _cornerDelta$[ebp]
	comiss	xmm0, DWORD PTR _maxDelta$[ebp]
	jbe	$LN15@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN15@MachHold

; 578  :          {
; 579  :             pStick *= max (0.55F, (1.0F - (cornerDelta - maxDelta) / (cornerSpeed * 0.75F)));//me123 0.55 from 0.25

	movss	xmm0, DWORD PTR _cornerDelta$[ebp]
	subss	xmm0, DWORD PTR _maxDelta$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+100]
	mulss	xmm1, DWORD PTR __real@3f400000
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f0ccccd
	comiss	xmm0, xmm1
	jbe	SHORT $LN80@MachHold
	movss	xmm0, DWORD PTR __real@3f0ccccd
	movss	DWORD PTR tv439[ebp], xmm0
	jmp	SHORT $LN81@MachHold
$LN80@MachHold:
	movss	xmm0, DWORD PTR _cornerDelta$[ebp]
	subss	xmm0, DWORD PTR _maxDelta$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+100]
	mulss	xmm1, DWORD PTR __real@3f400000
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR tv439[ebp], xmm1
$LN81@MachHold:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, DWORD PTR tv439[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+28], xmm0
$LN15@MachHold:

; 580  :          }
; 581  :       }
; 582  :    }
; 583  : 
; 584  :    /*-----------------------------*/
; 585  :    /* add pitch stick interaction */
; 586  :    /*-----------------------------*/
; 587  :    if (pitchStick)

	cmp	DWORD PTR _pitchStick$[ebp], 0
	je	SHORT $LN14@MachHold

; 588  :         throtl = thr + ((float)fabs(pStick) / 15.0F); 

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv969[ebp]
	movss	xmm0, DWORD PTR tv969[ebp]
	divss	xmm0, DWORD PTR __real@41700000
	addss	xmm0, DWORD PTR _thr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+40], xmm0

; 589  :    else

	jmp	SHORT $LN13@MachHold
$LN14@MachHold:

; 590  :         throtl = thr;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _thr$[ebp]
	movss	DWORD PTR [edx+40], xmm0
$LN13@MachHold:

; 591  : //me123 status test. IRCM STUFF.
; 592  : 
; 593  :    if (curMode == MissileEngageMode || curMode == GunsEngageMode || curMode == WVREngageMode)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 11			; 0000000bH
	je	SHORT $LN11@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 12			; 0000000cH
	je	SHORT $LN11@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 15			; 0000000fH
	jne	$LN5@MachHold
$LN11@MachHold:

; 594  :    {   //me123 status test. we are inside 6nm, somebody is pointing at us and we are head on.
; 595  : 
; 596  : 		if (
; 597  : 			targetData && !F4IsBadReadPtr(targetData, sizeof(SimObjectLocalData)) && // JB 010318 CTD
; 598  : 			targetData->ataFrom <40.0f *DTR &&
; 599  : 			targetData->ata <40.0f *DTR &&
; 600  : 			targetData->range < 10.0f * NM_TO_FT && 
; 601  : 			targetData->range > 1.0* NM_TO_FT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN5@MachHold
	push	232					; 000000e8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	$LN5@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR __real@3f32b8c1
	comiss	xmm0, DWORD PTR [edx+4]
	jbe	$LN5@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR __real@3f32b8c1
	comiss	xmm0, DWORD PTR [ecx]
	jbe	$LN5@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR __real@476d5a1c
	comiss	xmm0, DWORD PTR [eax+44]
	jbe	$LN5@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cvtss2sd xmm0, DWORD PTR [edx+44]
	comisd	xmm0, QWORD PTR __real@40b7bc3600000000
	jbe	$LN5@MachHold

; 602  : 		{
; 603  : 			if (SkillLevel() >=1 && targetData->range > 8.0* NM_TO_FT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	cmp	eax, 1
	jl	SHORT $LN9@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cvtss2sd xmm0, DWORD PTR [ecx+44]
	comisd	xmm0, QWORD PTR __real@40e7bc3600000000
	jbe	SHORT $LN9@MachHold

; 604  : 			{
; 605  : 				throtl = min (0.99f, throtl);// let's cancel burner inside 10nm

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN82@MachHold
	movss	xmm0, DWORD PTR __real@3f7d70a4
	movss	DWORD PTR tv547[ebp], xmm0
	jmp	SHORT $LN83@MachHold
$LN82@MachHold:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR tv547[ebp], xmm0
$LN83@MachHold:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv547[ebp]
	movss	DWORD PTR [ecx+40], xmm0
	jmp	$LN5@MachHold
$LN9@MachHold:

; 606  : 			}
; 607  : 			else if (SkillLevel() >=3 &&targetData->range > 5.0* NM_TO_FT )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	cmp	eax, 3
	jl	SHORT $LN7@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cvtss2sd xmm0, DWORD PTR [eax+44]
	comisd	xmm0, QWORD PTR __real@40ddab4380000000
	jbe	SHORT $LN7@MachHold

; 608  : 			{
; 609  : 				throtl = min (0.40f, throtl);// let's go midrange inside 8 

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@3ecccccd
	jbe	SHORT $LN84@MachHold
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR tv581[ebp], xmm0
	jmp	SHORT $LN85@MachHold
$LN84@MachHold:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR tv581[ebp], xmm0
$LN85@MachHold:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv581[ebp]
	movss	DWORD PTR [eax+40], xmm0
	jmp	SHORT $LN5@MachHold
$LN7@MachHold:

; 610  : 			}
; 611  : 			else if (SkillLevel() >=2)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkillLevel@BaseBrain@@QAEHXZ		; BaseBrain::SkillLevel
	cmp	eax, 2
	jl	SHORT $LN5@MachHold

; 612  : 			throtl = 0.0f;// let's go idle between 4 and 1nm

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0
$LN5@MachHold:

; 613  : 		}
; 614  :    }
; 615  :    /*-------------------*/
; 616  :    /* limit 0.0 ... 1.5 */
; 617  :    /*-------------------*/
; 618  :    throtl = min ( max (throtl, 0.0F), 1.5F);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN86@MachHold
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR tv612[ebp], xmm0
	jmp	SHORT $LN87@MachHold
$LN86@MachHold:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv612[ebp], xmm0
$LN87@MachHold:
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR tv612[ebp]
	jbe	SHORT $LN90@MachHold
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN88@MachHold
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR tv627[ebp], xmm0
	jmp	SHORT $LN89@MachHold
$LN88@MachHold:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv627[ebp], xmm0
$LN89@MachHold:
	movss	xmm0, DWORD PTR tv627[ebp]
	movss	DWORD PTR tv628[ebp], xmm0
	jmp	SHORT $LN91@MachHold
$LN90@MachHold:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv628[ebp], xmm0
$LN91@MachHold:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv628[ebp]
	movss	DWORD PTR [eax+40], xmm0

; 619  : #ifdef MANEUVER_DEBUG
; 620  : if (g_nShowDebugLabels & 0x10000)

	mov	ecx, DWORD PTR ?g_nShowDebugLabels@@3HA	; g_nShowDebugLabels
	and	ecx, 65536				; 00010000H
	je	$LN3@MachHold

; 621  : {
; 622  : 	char tmpchr[128];
; 623  : 	sprintf(tmpchr, "%.0f %.0f %.0f %.3f %.2f %.2f", m1, m2, eProp, thr, autoThrottle, throtl);

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+40]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+88]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _thr$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _eProp$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _m2$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _m1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BO@PKCDECG@?$CF?40f?5?$CF?40f?5?$CF?40f?5?$CF?43f?5?$CF?42f?5?$CF?42f?$AA@
	lea	ecx, DWORD PTR _tmpchr$5[ebp]
	push	ecx
	call	_sprintf
	add	esp, 56					; 00000038H

; 624  : 	if ( self->drawPointer )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN3@MachHold

; 625  : 		((DrawableBSP*)self->drawPointer)->SetLabel (tmpchr, ((DrawableBSP*)self->drawPointer)->LabelColor());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [edx+332]
	call	?LabelColor@DrawableBSP@@QAEKXZ		; DrawableBSP::LabelColor
	push	eax
	lea	eax, DWORD PTR _tmpchr$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [edx+332]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+332]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN3@MachHold:

; 626  : }
; 627  : #endif 
; 628  : 
; 629  :    if (fabs(eProp) < 0.1F * m1)

	push	ecx
	movss	xmm0, DWORD PTR _eProp$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1038[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _m1$[ebp]
	comiss	xmm0, DWORD PTR tv1038[ebp]
	jbe	SHORT $LN2@MachHold

; 630  :       return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@MachHold

; 631  :    else

	jmp	SHORT $LN1@MachHold
$LN2@MachHold:

; 632  :       return (FALSE);

	xor	eax, eax
$LN1@MachHold:

; 633  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN92@MachHold:
	DD	$LN22@MachHold
	DD	$LN21@MachHold
	DD	$LN20@MachHold
	DD	$LN19@MachHold
?MachHold@DigitalBrain@@IAEHMMH@Z ENDP			; DigitalBrain::MachHold
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbrain.h
;	COMDAT ?SkillLevel@BaseBrain@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SkillLevel@BaseBrain@@QAEHXZ PROC			; BaseBrain::SkillLevel, COMDAT
; _this$ = ecx

; 40   :       int SkillLevel(void) {return skillLevel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?SkillLevel@BaseBrain@@QAEHXZ ENDP			; BaseBrain::SkillLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?acos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?acos@@YAMM@Z PROC					; acos, COMDAT

; 501  :         {return (acosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_acosf
	add	esp, 4
	pop	ebp
	ret	0
?acos@@YAMM@Z ENDP					; acos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 400  :         {return ((float)acos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_acosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
