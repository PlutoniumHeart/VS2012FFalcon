; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\hdigi\h_Dlogic.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?IsAwake@SimBaseClass@@QBEHXZ			; SimBaseClass::IsAwake
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?ResolveModeConflicts@HeliBrain@@QAEXXZ		; HeliBrain::ResolveModeConflicts
PUBLIC	?AddMode@HeliBrain@@QAEXW4DigiMode@1@@Z		; HeliBrain::AddMode
PUBLIC	?PrtMode@HeliBrain@@QAEXXZ			; HeliBrain::PrtMode
PUBLIC	?PrintOnline@HeliBrain@@QAEXPAD@Z		; HeliBrain::PrintOnline
PUBLIC	?DecisionLogic@HeliBrain@@QAEXXZ		; HeliBrain::DecisionLogic
PUBLIC	?RunDecisionRoutines@HeliBrain@@QAEXXZ		; HeliBrain::RunDecisionRoutines
PUBLIC	?TargetSelection@HeliBrain@@QAEXXZ		; HeliBrain::TargetSelection
PUBLIC	?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z ; HeliBrain::SetTargetEntity
PUBLIC	?FindSimGroundTarget@HeliBrain@@QAEPAVSimBaseClass@@PAVCampBaseClass@@HH@Z ; HeliBrain::FindSimGroundTarget
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?UnsetChecked@CampBaseClass@@QAEXXZ		; CampBaseClass::UnsetChecked
PUBLIC	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ	; UnitClass::GetTarget
PUBLIC	?GetUnitTactic@UnitClass@@QBEHXZ		; UnitClass::GetUnitTactic
PUBLIC	??_C@_0N@CJCDHIEP@DIGI?5RTBMode?$AA@		; `string'
PUBLIC	??_C@_0N@BIHFENCI@DIGI?5WINGMAN?$AA@		; `string'
PUBLIC	??_C@_0BC@JAEFJOCB@DIGI?5WaypointMode?$AA@	; `string'
PUBLIC	??_C@_0BB@ILDJCOFH@DIGI?5GUNS?5ENGAGE?$AA@	; `string'
PUBLIC	??_C@_0BA@NOOCIIAO@DIGI?5BVR?5ENGAGE?$AA@	; `string'
PUBLIC	??_C@_0BA@BEDOAIH@DIGI?5WVR?5ENGAGE?$AA@	; `string'
PUBLIC	??_C@_0BE@DBHADILF@DIGI?5MISSILE?5DEFEAT?$AA@	; `string'
PUBLIC	??_C@_0BC@BMHHMHEC@DIGI?5MSSLE?5ENGAGE?$AA@	; `string'
PUBLIC	??_C@_0P@JMBPCAIK@DIGI?5GUNS?5JINK?$AA@		; `string'
PUBLIC	??_C@_0BC@JCCMCFGE@DIGI?5GROUND?5AVOID?$AA@	; `string'
PUBLIC	??_C@_0BA@HMKNELDE@DIGI?5LoiterMode?$AA@	; `string'
PUBLIC	??_C@_0P@EAOEDDJH@DIGI?5DISENGAGE?$AA@		; `string'
PUBLIC	??_C@_0BD@FELPCLPO@DIGI?5OvershootMode?$AA@	; `string'
PUBLIC	??_C@_0P@EBBHJGFG@DIGI?5COLLISION?$AA@		; `string'
PUBLIC	??_C@_0BE@JDBEHEKI@DIGI?5AccelerateMode?$AA@	; `string'
PUBLIC	??_C@_0BC@GFJFLHLG@DIGI?5SeparateMode?$AA@	; `string'
PUBLIC	??_C@_0O@FNCLHCMN@DIGI?5RoopMode?$AA@		; `string'
PUBLIC	??_C@_0O@EHOPNIJE@DIGI?5OVERBANK?$AA@		; `string'
PUBLIC	__real@00000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_rand:PROC
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?GunsEngageCheck@HeliBrain@@QAEXXZ:PROC		; HeliBrain::GunsEngageCheck
EXTRN	?GunsJinkCheck@HeliBrain@@QAEXXZ:PROC		; HeliBrain::GunsJinkCheck
EXTRN	?CollisionCheck@HeliBrain@@QAEXXZ:PROC		; HeliBrain::CollisionCheck
EXTRN	?ClearTarget@HeliBrain@@QAEXXZ:PROC		; HeliBrain::ClearTarget
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	??0SimObjectType@@QAE@PAVFalconEntity@@@Z:PROC	; SimObjectType::SimObjectType
EXTRN	?Reference@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Reference
EXTRN	?Release@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Release
EXTRN	??0AirAIModeMsg@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; AirAIModeMsg::AirAIModeMsg
EXTRN	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentEntity
EXTRN	?NumberOfComponents@CampBaseClass@@QAEHXZ:PROC	; CampBaseClass::NumberOfComponents
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0O@EHOPNIJE@DIGI?5OVERBANK?$AA@
CONST	SEGMENT
??_C@_0O@EHOPNIJE@DIGI?5OVERBANK?$AA@ DB 'DIGI OVERBANK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNCLHCMN@DIGI?5RoopMode?$AA@
CONST	SEGMENT
??_C@_0O@FNCLHCMN@DIGI?5RoopMode?$AA@ DB 'DIGI RoopMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GFJFLHLG@DIGI?5SeparateMode?$AA@
CONST	SEGMENT
??_C@_0BC@GFJFLHLG@DIGI?5SeparateMode?$AA@ DB 'DIGI SeparateMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JDBEHEKI@DIGI?5AccelerateMode?$AA@
CONST	SEGMENT
??_C@_0BE@JDBEHEKI@DIGI?5AccelerateMode?$AA@ DB 'DIGI AccelerateMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EBBHJGFG@DIGI?5COLLISION?$AA@
CONST	SEGMENT
??_C@_0P@EBBHJGFG@DIGI?5COLLISION?$AA@ DB 'DIGI COLLISION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FELPCLPO@DIGI?5OvershootMode?$AA@
CONST	SEGMENT
??_C@_0BD@FELPCLPO@DIGI?5OvershootMode?$AA@ DB 'DIGI OvershootMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EAOEDDJH@DIGI?5DISENGAGE?$AA@
CONST	SEGMENT
??_C@_0P@EAOEDDJH@DIGI?5DISENGAGE?$AA@ DB 'DIGI DISENGAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HMKNELDE@DIGI?5LoiterMode?$AA@
CONST	SEGMENT
??_C@_0BA@HMKNELDE@DIGI?5LoiterMode?$AA@ DB 'DIGI LoiterMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JCCMCFGE@DIGI?5GROUND?5AVOID?$AA@
CONST	SEGMENT
??_C@_0BC@JCCMCFGE@DIGI?5GROUND?5AVOID?$AA@ DB 'DIGI GROUND AVOID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMBPCAIK@DIGI?5GUNS?5JINK?$AA@
CONST	SEGMENT
??_C@_0P@JMBPCAIK@DIGI?5GUNS?5JINK?$AA@ DB 'DIGI GUNS JINK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BMHHMHEC@DIGI?5MSSLE?5ENGAGE?$AA@
CONST	SEGMENT
??_C@_0BC@BMHHMHEC@DIGI?5MSSLE?5ENGAGE?$AA@ DB 'DIGI MSSLE ENGAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DBHADILF@DIGI?5MISSILE?5DEFEAT?$AA@
CONST	SEGMENT
??_C@_0BE@DBHADILF@DIGI?5MISSILE?5DEFEAT?$AA@ DB 'DIGI MISSILE DEFEAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BEDOAIH@DIGI?5WVR?5ENGAGE?$AA@
CONST	SEGMENT
??_C@_0BA@BEDOAIH@DIGI?5WVR?5ENGAGE?$AA@ DB 'DIGI WVR ENGAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NOOCIIAO@DIGI?5BVR?5ENGAGE?$AA@
CONST	SEGMENT
??_C@_0BA@NOOCIIAO@DIGI?5BVR?5ENGAGE?$AA@ DB 'DIGI BVR ENGAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILDJCOFH@DIGI?5GUNS?5ENGAGE?$AA@
CONST	SEGMENT
??_C@_0BB@ILDJCOFH@DIGI?5GUNS?5ENGAGE?$AA@ DB 'DIGI GUNS ENGAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JAEFJOCB@DIGI?5WaypointMode?$AA@
CONST	SEGMENT
??_C@_0BC@JAEFJOCB@DIGI?5WaypointMode?$AA@ DB 'DIGI WaypointMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIHFENCI@DIGI?5WINGMAN?$AA@
CONST	SEGMENT
??_C@_0N@BIHFENCI@DIGI?5WINGMAN?$AA@ DB 'DIGI WINGMAN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJCDHIEP@DIGI?5RTBMode?$AA@
CONST	SEGMENT
??_C@_0N@CJCDHIEP@DIGI?5RTBMode?$AA@ DB 'DIGI RTBMode', 00H ; `string'
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z$0
__unwindtable$?PrtMode@HeliBrain@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrtMode@HeliBrain@@QAEXXZ$0
__ehfuncinfo$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?PrtMode@HeliBrain@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PrtMode@HeliBrain@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitTactic@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitTactic@UnitClass@@QBEHXZ PROC			; UnitClass::GetUnitTactic, COMDAT
; _this$ = ecx

; 375  : 	int GetUnitTactic() const						{ return tactic; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+222]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitTactic@UnitClass@@QBEHXZ ENDP			; UnitClass::GetUnitTactic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ PROC	; UnitClass::GetTarget, COMDAT
; _this$ = ecx

; 366  : 	FalconEntity* GetTarget (void)					{ return (FalconEntity*) vuDatabase->Find(target_id); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR [eax+212]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?UnsetChecked@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnsetChecked@CampBaseClass@@QAEXXZ PROC		; CampBaseClass::UnsetChecked, COMDAT
; _this$ = ecx

; 307  : 	void UnsetChecked (void)					{	local_flags &= ~CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetChecked@CampBaseClass@@QAEXXZ ENDP		; CampBaseClass::UnsetChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
_flightMember$ = -44					; size = 16
tv165 = -28						; size = 4
_usComponents$ = -24					; size = 4
_this$ = -20						; size = 4
_firstSimTarg$ = -16					; size = 4
_simTarg$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_targetGroup$ = 8					; size = 4
_targetNumComponents$ = 12				; size = 4
_startPos$ = 16						; size = 4
?FindSimGroundTarget@HeliBrain@@QAEPAVSimBaseClass@@PAVCampBaseClass@@HH@Z PROC ; HeliBrain::FindSimGroundTarget
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 	int i = 0, j = 0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0

; 180  : 	int usComponents = self->GetCampaignObject()->NumberOfComponents();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	mov	DWORD PTR _usComponents$[ebp], eax

; 181  : 	SimBaseClass *simTarg = NULL;

	mov	DWORD PTR _simTarg$[ebp], 0

; 182  : 	SimBaseClass *firstSimTarg = NULL;

	mov	DWORD PTR _firstSimTarg$[ebp], 0

; 183  : 	HelicopterClass *flightMember[4] =  { 0 }; // Maximum of 4 planes per flight with no target as default

	mov	DWORD PTR _flightMember$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _flightMember$[ebp+4], ecx
	mov	DWORD PTR _flightMember$[ebp+8], ecx
	mov	DWORD PTR _flightMember$[ebp+12], ecx

; 184  : 
; 185  : 	// Get the flight helis (once per call instead of once per target querried)
; 186  : 	for (i = 0; i < usComponents; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@FindSimGro
$LN24@FindSimGro:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN25@FindSimGro:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _usComponents$[ebp]
	jge	SHORT $LN23@FindSimGro

; 187  : 		// I onced tried to get the player's current target so it could be skipped by the AI but
; 188  : 		// all the player's are not on the same PC as the AI so this is not valid.
; 189  : 		// Therefore, only get this from digital planes, or the player if he is local
; 190  : 		if (((HeliMMClass *)self->GetCampaignObject()->GetComponentEntity(i))->isDigital || ((HelicopterClass *)self->GetCampaignObject()->GetComponentEntity(i))->IsLocal()) {

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	cmp	DWORD PTR [eax+1084], 0
	jne	SHORT $LN21@FindSimGro
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	ecx, eax
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@FindSimGro
$LN21@FindSimGro:

; 191  : 			flightMember[i] = (HelicopterClass *)self->GetCampaignObject()->GetComponentEntity(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _flightMember$[ebp+edx*4], eax

; 192  : 			// Sanity check
; 193  : 			if (!flightMember[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _flightMember$[ebp+eax*4], 0
	jne	SHORT $LN20@FindSimGro

; 194  : 				continue;

	jmp	SHORT $LN24@FindSimGro
$LN20@FindSimGro:

; 195  : 		}
; 196  : 	}

	jmp	SHORT $LN24@FindSimGro
$LN23@FindSimGro:

; 197  : 
; 198  : 	// Check each sim entity in the campaign entity in succession, starting at startPos.
; 199  : 	// When incrementing i, use 0 if we had a 'startPos' but it wasn't valid
; 200  : 
; 201  : 	for (i = startPos; i < targetNumComponents; i = startPos ? 0 : i + 1, startPos = 0 ) {

	mov	ecx, DWORD PTR _startPos$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN19@FindSimGro
$LN18@FindSimGro:
	cmp	DWORD PTR _startPos$[ebp], 0
	je	SHORT $LN28@FindSimGro
	mov	DWORD PTR tv165[ebp], 0
	jmp	SHORT $LN29@FindSimGro
$LN28@FindSimGro:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR tv165[ebp], edx
$LN29@FindSimGro:
	mov	eax, DWORD PTR tv165[ebp]
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _startPos$[ebp], 0
$LN19@FindSimGro:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _targetNumComponents$[ebp]
	jge	$LN17@FindSimGro

; 202  : 		// Get the sim object associated to this entity number
; 203  : 		simTarg = targetGroup->GetComponentEntity(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _targetGroup$[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _simTarg$[ebp], eax

; 204  : 
; 205  : 		if (!simTarg) //sanity check

	cmp	DWORD PTR _simTarg$[ebp], 0
	jne	SHORT $LN16@FindSimGro

; 206  : 			continue;

	jmp	SHORT $LN18@FindSimGro
$LN16@FindSimGro:

; 207  : 
; 208  : 		// Is it alive?
; 209  : 		if (simTarg->IsExploding() || simTarg->IsDead() || simTarg->pctStrength <= 0.0f )

	mov	eax, DWORD PTR _simTarg$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN14@FindSimGro
	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	SHORT $LN14@FindSimGro
	mov	ecx, DWORD PTR _simTarg$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+292]
	jb	SHORT $LN15@FindSimGro
$LN14@FindSimGro:

; 210  : 			continue; // Dead thing, ignore it.

	jmp	$LN18@FindSimGro
$LN15@FindSimGro:

; 211  : 
; 212  : 		// Are flight members already using it (was using it) as a target?
; 213  : 		for (j = 0; j < usComponents; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@FindSimGro
$LN12@FindSimGro:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN13@FindSimGro:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _usComponents$[ebp]
	jge	$LN11@FindSimGro

; 214  : 			if (flightMember[j] 
; 215  : 				&& flightMember[j]->hBrain 
; 216  : 				&& ((flightMember[j]->hBrain->targetPtr 
; 217  : 					&& flightMember[j]->hBrain->targetPtr->BaseData() == simTarg) 
; 218  : 					|| flightMember[j]->hBrain->targetHistory[0] == simTarg 
; 219  : 					|| flightMember[j]->hBrain->targetHistory[1] == simTarg))

	mov	ecx, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _flightMember$[ebp+ecx*4], 0
	je	$LN10@FindSimGro
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _flightMember$[ebp+edx*4]
	cmp	DWORD PTR [eax+808], 0
	je	SHORT $LN10@FindSimGro
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _flightMember$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+808]
	cmp	DWORD PTR [eax+192], 0
	je	SHORT $LN8@FindSimGro
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _flightMember$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, DWORD PTR [eax+192]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	eax, DWORD PTR _simTarg$[ebp]
	je	SHORT $LN9@FindSimGro
$LN8@FindSimGro:
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _flightMember$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+808]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+228]
	cmp	edx, DWORD PTR _simTarg$[ebp]
	je	SHORT $LN9@FindSimGro
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _flightMember$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+808]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+eax+228]
	cmp	ecx, DWORD PTR _simTarg$[ebp]
	jne	SHORT $LN10@FindSimGro
$LN9@FindSimGro:

; 220  : 				break;  // Yes, ignore it.

	jmp	SHORT $LN11@FindSimGro
$LN10@FindSimGro:

; 221  : 
; 222  : 		// If we didn't reach the end, someone else is using it so skip it.
; 223  : 		if (j != usComponents)

	jmp	$LN12@FindSimGro
$LN11@FindSimGro:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _usComponents$[ebp]
	je	SHORT $LN7@FindSimGro

; 224  : 			continue;

	jmp	$LN18@FindSimGro
$LN7@FindSimGro:

; 225  : 
; 226  : 		// Mark this sim entity as the first target with a match (in case no emitting targets are left standing, or it's a feature)
; 227  : 		if (!firstSimTarg)

	cmp	DWORD PTR _firstSimTarg$[ebp], 0
	jne	SHORT $LN6@FindSimGro

; 228  : 			firstSimTarg = simTarg;

	mov	eax, DWORD PTR _simTarg$[ebp]
	mov	DWORD PTR _firstSimTarg$[ebp], eax
$LN6@FindSimGro:

; 229  : 
; 230  : 		// Is it an objective, break out
; 231  : 		if (targetGroup->IsObjective())

	mov	ecx, DWORD PTR _targetGroup$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _targetGroup$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	SHORT $LN5@FindSimGro

; 232  : 			break;

	jmp	SHORT $LN17@FindSimGro
$LN5@FindSimGro:

; 233  : 
; 234  : 		// Look for the next one...
; 235  : 	}

	jmp	$LN18@FindSimGro
$LN17@FindSimGro:

; 236  : 	if (startPos < targetNumComponents) {

	mov	ecx, DWORD PTR _startPos$[ebp]
	cmp	ecx, DWORD PTR _targetNumComponents$[ebp]
	jge	SHORT $LN4@FindSimGro

; 237  : 		// Keep track of the last two targets but only if we have one, otherwise, leave our previous targets alone
; 238  : 		if (firstSimTarg) {

	cmp	DWORD PTR _firstSimTarg$[ebp], 0
	je	SHORT $LN3@FindSimGro

; 239  : 			targetHistory[1] = targetHistory[0];

	mov	edx, 4
	imul	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+228]
	mov	DWORD PTR [ecx+eax+228], edx

; 240  : 			targetHistory[0] = firstSimTarg;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _firstSimTarg$[ebp]
	mov	DWORD PTR [ecx+eax+228], edx
$LN3@FindSimGro:

; 241  : 		}
; 242  : 	}
; 243  : 	else

	jmp	SHORT $LN2@FindSimGro
$LN4@FindSimGro:

; 244  : 		firstSimTarg = 0;

	mov	DWORD PTR _firstSimTarg$[ebp], 0
$LN2@FindSimGro:

; 245  : 
; 246  : 	// JB 011017 from Schumi if targetNumComponents is less than usComponents, then of course there is no target anymore for the wingmen to bomb, and firstSimTarg is NULL.
; 247  : 	if (firstSimTarg == NULL && targetNumComponents && targetNumComponents < usComponents)

	cmp	DWORD PTR _firstSimTarg$[ebp], 0
	jne	SHORT $LN1@FindSimGro
	cmp	DWORD PTR _targetNumComponents$[ebp], 0
	je	SHORT $LN1@FindSimGro
	mov	eax, DWORD PTR _targetNumComponents$[ebp]
	cmp	eax, DWORD PTR _usComponents$[ebp]
	jge	SHORT $LN1@FindSimGro

; 248  : 		firstSimTarg = targetGroup->GetComponentEntity (rand() % targetNumComponents);

	call	_rand
	cdq
	idiv	DWORD PTR _targetNumComponents$[ebp]
	push	edx
	mov	ecx, DWORD PTR _targetGroup$[ebp]
	call	?GetComponentEntity@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentEntity
	mov	DWORD PTR _firstSimTarg$[ebp], eax
$LN1@FindSimGro:

; 249  : 
; 250  : 	return firstSimTarg;

	mov	eax, DWORD PTR _firstSimTarg$[ebp]

; 251  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FindSimGroundTarget@HeliBrain@@QAEPAVSimBaseClass@@PAVCampBaseClass@@HH@Z ENDP ; HeliBrain::FindSimGroundTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv84 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_obj$ = 8						; size = 4
?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z PROC ; HeliBrain::SetTargetEntity
; _this$ = ecx

; 262  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 	if ( obj != NULL )

	cmp	DWORD PTR _obj$[ebp], 0
	je	$LN6@SetTargetE

; 264  : 	{
; 265  : 		if ( targetPtr != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+192], 0
	je	SHORT $LN5@SetTargetE

; 266  : 		{
; 267  : 			// release existing target data if different object
; 268  : 			if ( targetPtr->BaseData() != obj )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+192]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	eax, DWORD PTR _obj$[ebp]
	je	SHORT $LN4@SetTargetE

; 269  : 			{
; 270  : 				targetPtr->Release(  );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+192]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release

; 271  : 				targetPtr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+192], 0

; 272  : 				targetData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+200], 0

; 273  : 			}
; 274  : 			else

	jmp	SHORT $LN5@SetTargetE
$LN4@SetTargetE:

; 275  : 			{
; 276  : 				// already targeting this object
; 277  : 				return;

	jmp	$LN7@SetTargetE
$LN5@SetTargetE:

; 278  : 			}
; 279  : 		}
; 280  : 
; 281  : 		// create new target data and reference it
; 282  : 		#ifdef DEBUG
; 283  : 		//targetPtr = new SimObjectType( OBJ_TAG, self, obj );
; 284  : 		#else
; 285  : 		targetPtr = new SimObjectType( obj );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN9@SetTargetE
	mov	edx, DWORD PTR _obj$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0SimObjectType@@QAE@PAVFalconEntity@@@Z ; SimObjectType::SimObjectType
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN10@SetTargetE
$LN9@SetTargetE:
	mov	DWORD PTR tv84[ebp], 0
$LN10@SetTargetE:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+192], edx

; 286  : 		#endif
; 287  : 		targetPtr->Reference(  );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference

; 288  : 		targetData = targetPtr->localData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+200], ecx

; 289  : 		// SetTarget( targetPtr );
; 290  : 	}
; 291  : 	else // obj is null

	jmp	SHORT $LN7@SetTargetE
$LN6@SetTargetE:

; 292  : 	{
; 293  : 		if ( targetPtr != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+192], 0
	je	SHORT $LN7@SetTargetE

; 294  : 		{
; 295  : 			targetPtr->Release(  );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release

; 296  : 			targetPtr = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+192], 0

; 297  : 			targetData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+200], 0
$LN7@SetTargetE:

; 298  : 		}
; 299  : 	}
; 300  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z ENDP ; HeliBrain::SetTargetEntity
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
tv88 = -24						; size = 4
_campTactic$ = -20					; size = 4
_simTarg$ = -16						; size = 4
_campUnit$ = -12					; size = 4
_target$ = -8						; size = 4
_this$ = -4						; size = 4
?TargetSelection@HeliBrain@@QAEXXZ PROC			; HeliBrain::TargetSelection
; _this$ = ecx

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 	UnitClass *campUnit = (UnitClass *)self->GetCampaignObject();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _campUnit$[ebp], eax

; 63   : 	FalconEntity *target;
; 64   : 	SimBaseClass *simTarg;
; 65   : 	int campTactic;
; 66   : 
; 67   : 	// sanity check
; 68   : 	if ( !campUnit )

	cmp	DWORD PTR _campUnit$[ebp], 0
	jne	SHORT $LN10@TargetSele

; 69   : 		return;

	jmp	$LN11@TargetSele
$LN10@TargetSele:

; 70   : 
; 71   : 	// check to see if our current ground target is a sim and exploding or
; 72   : 	// dead, if so let's get a new target from the campaign
; 73   : 	if ( targetPtr &&
; 74   : 		 targetPtr->BaseData()->IsSim() &&
; 75   : 		 ( targetPtr->BaseData()->IsExploding() || !((SimBaseClass *)targetPtr->BaseData())->IsAwake() ) )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+192], 0
	je	SHORT $LN9@TargetSele
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+192]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN9@TargetSele
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv88[ebp], eax
	mov	ecx, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@TargetSele
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+192]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN9@TargetSele
$LN8@TargetSele:

; 76   : 	{
; 77   : 		ClearTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTarget@HeliBrain@@QAEXXZ		; HeliBrain::ClearTarget
$LN9@TargetSele:

; 78   : 	}
; 79   : 
; 80   : 	// see if we've already got a target
; 81   : /*	if ( targetPtr )
; 82   : 	{
; 83   : 		target = targetPtr->BaseData();
; 84   : 
; 85   : 		// is it a campaign object? if not we can return....
; 86   : 		if (target->IsSim() )
; 87   : 		{
; 88   : 			return;
; 89   : 		}
; 90   : 
; 91   : 		// itsa campaign object.  Check to see if its deagg'd
; 92   : 		if (((CampBaseClass*)target)->IsAggregate() )
; 93   : 		{
; 94   : 			// still aggregated, return
; 95   : 			return;
; 96   : 		}
; 97   : 
; 98   : 		// the campaign object is now deaggregated, choose a sim entity
; 99   : 		// to target on it
; 100  : 
; 101  : 		// M.N. use S.G.'s FindSimGroundTarget function to choose a sim entity
; 102  : 
; 103  : 		simTarg = FindSimGroundTarget((CampBaseClass*)target, ((CampBaseClass*)target)->NumberOfComponents(), 0);
; 104  : 
; 105  : 		if (!simTarg)	// another sanity check
; 106  : 			return;
; 107  : 
; 108  : 		if (!simTarg->IsExploding() && !simTarg->IsDead() && simTarg->pctStrength > 0.0f) // still alive?
; 109  : 				SetTargetEntity( simTarg );
; 110  : 
; 111  : 		return;
; 112  : 
; 113  : 	} // end if already targetPtr
; 114  : */
; 115  : 
; 116  : 	// at this point we have no target, we're going to ask the campaign
; 117  : 	// to find out what we're supposed to hit
; 118  : 
; 119  : 	// tell unit we haven't done any checking on it yet
; 120  : 	campUnit->UnsetChecked();

	mov	ecx, DWORD PTR _campUnit$[ebp]
	call	?UnsetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetChecked

; 121  : 
; 122  : 	// choose target.  I assume if this returns 0, no target....
; 123  : 	if ( !campUnit->ChooseTarget() )

	mov	edx, DWORD PTR _campUnit$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _campUnit$[ebp]
	mov	edx, DWORD PTR [eax+524]
	call	edx
	test	eax, eax
	jne	SHORT $LN7@TargetSele

; 124  : 	{
; 125  : 		ClearTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTarget@HeliBrain@@QAEXXZ		; HeliBrain::ClearTarget

; 126  : 		// alternately try and choose the waypoint's target
; 127  : 		// SettargetPtr( self->curWaypoint->GetWPTarget() );
; 128  : 		return;

	jmp	$LN11@TargetSele
$LN7@TargetSele:

; 129  : 	}
; 130  : 
; 131  : 	// get the target
; 132  : 	target = campUnit->GetTarget();

	mov	ecx, DWORD PTR _campUnit$[ebp]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _target$[ebp], eax

; 133  : 
; 134  : 	// get tactic -- not doing anything with it now
; 135  : 	campUnit->ChooseTactic();

	mov	eax, DWORD PTR _campUnit$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _campUnit$[ebp]
	mov	eax, DWORD PTR [edx+496]
	call	eax

; 136  : 	campTactic = campUnit->GetUnitTactic();

	mov	ecx, DWORD PTR _campUnit$[ebp]
	call	?GetUnitTactic@UnitClass@@QBEHXZ	; UnitClass::GetUnitTactic
	mov	DWORD PTR _campTactic$[ebp], eax

; 137  : 
; 138  : 	// sanity check and make sure its on ground, what to do if not?!...
; 139  : 	if ( !target ||
; 140  : 		  campTactic == ATACTIC_RETROGRADE ||
; 141  : 		  campTactic == ATACTIC_IGNORE ||
; 142  : 		  campTactic == ATACTIC_AVOID ||
; 143  : 		  campTactic == ATACTIC_ABORT ||
; 144  : 		  campTactic == ATACTIC_REFUEL  )

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN5@TargetSele
	cmp	DWORD PTR _campTactic$[ebp], 7
	je	SHORT $LN5@TargetSele
	cmp	DWORD PTR _campTactic$[ebp], 9
	je	SHORT $LN5@TargetSele
	cmp	DWORD PTR _campTactic$[ebp], 10		; 0000000aH
	je	SHORT $LN5@TargetSele
	cmp	DWORD PTR _campTactic$[ebp], 12		; 0000000cH
	je	SHORT $LN5@TargetSele
	cmp	DWORD PTR _campTactic$[ebp], 11		; 0000000bH
	jne	SHORT $LN6@TargetSele
$LN5@TargetSele:

; 145  : 	{
; 146  : 		ClearTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTarget@HeliBrain@@QAEXXZ		; HeliBrain::ClearTarget

; 147  : 		return;

	jmp	$LN11@TargetSele
$LN6@TargetSele:

; 148  : 	}
; 149  : 
; 150  : 	if (((CampBaseClass*)target)->IsAggregate() )

	mov	ecx, DWORD PTR _target$[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	SHORT $LN4@TargetSele

; 151  : 	{
; 152  : 		// still aggregated, return
; 153  : 		SetTargetEntity( target );

	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z ; HeliBrain::SetTargetEntity

; 154  : 		return;

	jmp	$LN11@TargetSele
$LN4@TargetSele:

; 155  : 	}
; 156  : 
; 157  : 	// we've a SIM target, go get a component
; 158  : 
; 159  : 	// M.N. use S.G.'s FindSimGroundTarget function to choose a sim entity
; 160  : 	if (target->IsSim() && target->OnGround())

	mov	ecx, DWORD PTR _target$[ebp]
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	$LN3@TargetSele
	mov	edx, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _target$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN3@TargetSele

; 161  : 	{
; 162  : 		simTarg = FindSimGroundTarget((CampBaseClass*)target, ((CampBaseClass*)target)->NumberOfComponents(), 0);

	push	0
	mov	ecx, DWORD PTR _target$[ebp]
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	push	eax
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindSimGroundTarget@HeliBrain@@QAEPAVSimBaseClass@@PAVCampBaseClass@@HH@Z ; HeliBrain::FindSimGroundTarget
	mov	DWORD PTR _simTarg$[ebp], eax

; 163  : 
; 164  : 		if (!simTarg)	// another sanity check

	cmp	DWORD PTR _simTarg$[ebp], 0
	jne	SHORT $LN2@TargetSele

; 165  : 			return;

	jmp	SHORT $LN11@TargetSele
$LN2@TargetSele:

; 166  : 
; 167  : 		// set it as our target
; 168  : 		if (!simTarg->IsExploding() && !simTarg->IsDead() && simTarg->pctStrength > 0.0f) // still alive?

	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@TargetSele
	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _simTarg$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@TargetSele
	mov	ecx, DWORD PTR _simTarg$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@TargetSele

; 169  : 				SetTargetEntity( simTarg );

	mov	edx, DWORD PTR _simTarg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z ; HeliBrain::SetTargetEntity
$LN1@TargetSele:

; 170  : 		return;

	jmp	SHORT $LN11@TargetSele
$LN3@TargetSele:

; 171  : 	}
; 172  : 	SetTargetEntity( target );

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetEntity@HeliBrain@@QAEXPAVFalconEntity@@@Z ; HeliBrain::SetTargetEntity
$LN11@TargetSele:

; 173  : 
; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TargetSelection@HeliBrain@@QAEXXZ ENDP			; HeliBrain::TargetSelection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RunDecisionRoutines@HeliBrain@@QAEXXZ PROC		; HeliBrain::RunDecisionRoutines
; _this$ = ecx

; 421  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 422  :    /*-----------------------*/
; 423  :    /* collision avoid check */
; 424  :    /*-----------------------*/
; 425  :    CollisionCheck();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CollisionCheck@HeliBrain@@QAEXXZ	; HeliBrain::CollisionCheck

; 426  : 
; 427  :    /*-----------*/
; 428  :    /* Guns Jink */
; 429  :    /*-----------*/
; 430  :    GunsJinkCheck();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GunsJinkCheck@HeliBrain@@QAEXXZ	; HeliBrain::GunsJinkCheck

; 431  : 	// checks for missiles too
; 432  :    GunsEngageCheck();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GunsEngageCheck@HeliBrain@@QAEXXZ	; HeliBrain::GunsEngageCheck

; 433  : 
; 434  :    /* Special cases for close in combat logic.                 */
; 435  :    /* These maneuvers are started from within other maneuvers, */
; 436  :    /* eg. "rollAndPull" and are self-terminating.            */
; 437  : 
; 438  :    /*------------------*/
; 439  :    /* default behavior */
; 440  :    /*------------------*/
; 441  :    // if (isWing)
; 442  :    //    AddMode (WingyMode);
; 443  :    AddMode(WaypointMode);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMode@HeliBrain@@QAEXW4DigiMode@1@@Z	; HeliBrain::AddMode

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RunDecisionRoutines@HeliBrain@@QAEXXZ ENDP		; HeliBrain::RunDecisionRoutines
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecisionLogic@HeliBrain@@QAEXXZ PROC			; HeliBrain::DecisionLogic
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   :    /*--------------------*/
; 21   :    /* ground avoid check */
; 22   :    /*--------------------*/
; 23   :    // GroundCheck();
; 24   : 
; 25   :    // if (self->flightLead == self)
; 26   :    {
; 27   :       RunDecisionRoutines();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunDecisionRoutines@HeliBrain@@QAEXXZ	; HeliBrain::RunDecisionRoutines

; 28   :    }
; 29   :    /*
; 30   :    else
; 31   :    {
; 32   :       CheckOrders();
; 33   :    }
; 34   :    */
; 35   : 
; 36   :    /*------------------------*/
; 37   :    /* resolve mode conflicts */
; 38   :    /*------------------------*/
; 39   :    ResolveModeConflicts();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResolveModeConflicts@HeliBrain@@QAEXXZ	; HeliBrain::ResolveModeConflicts

; 40   : 
; 41   :    /*----------------------------------*/
; 42   :    /* print mode changes as they occur */
; 43   :    /*----------------------------------*/
; 44   :    // PrtMode();
; 45   : 
; 46   :    /*------------------*/
; 47   :    /* weapon selection */ 
; 48   :    /*------------------*/
; 49   :    // if (targetPtr)
; 50   :    //     WeaponSelection();
; 51   : 
; 52   :    /*--------------*/
; 53   :    /* fire control */
; 54   :    /*--------------*/
; 55   :    // if (targetPtr && shooting)
; 56   :    //     FireControl();
; 57   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecisionLogic@HeliBrain@@QAEXXZ ENDP			; HeliBrain::DecisionLogic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?PrintOnline@HeliBrain@@QAEXPAD@Z PROC			; HeliBrain::PrintOnline
; _this$ = ecx

; 518  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PrintOnline@HeliBrain@@QAEXPAD@Z ENDP			; HeliBrain::PrintOnline
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
$T2 = -56						; size = 8
$T3 = -48						; size = 8
$T4 = -40						; size = 4
tv173 = -36						; size = 4
$T5 = -32						; size = 4
tv161 = -28						; size = 4
tv68 = -24						; size = 4
_modeMsg$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?PrtMode@HeliBrain@@QAEXXZ PROC				; HeliBrain::PrtMode
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PrtMode@HeliBrain@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 448  : AirAIModeMsg* modeMsg;
; 449  : 
; 450  :    if (curMode != lastMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [ecx+44]
	je	$LN22@PrtMode

; 451  :    {
; 452  :       switch(curMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 22			; 00000016H
	ja	$LN19@PrtMode
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN30@PrtMode[edx*4]
$LN18@PrtMode:

; 453  :       {
; 454  :          case RTBMode:          
; 455  :             PrintOnline("DIGI RTBMode");

	push	OFFSET ??_C@_0N@CJCDHIEP@DIGI?5RTBMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 456  :          break;

	jmp	$LN19@PrtMode
$LN17@PrtMode:

; 457  :          case WingyMode:       
; 458  :             PrintOnline("DIGI WINGMAN");

	push	OFFSET ??_C@_0N@BIHFENCI@DIGI?5WINGMAN?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 459  :          break;

	jmp	$LN19@PrtMode
$LN16@PrtMode:

; 460  :          case WaypointMode:    
; 461  :             PrintOnline("DIGI WaypointMode");

	push	OFFSET ??_C@_0BC@JAEFJOCB@DIGI?5WaypointMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 462  :          break;

	jmp	$LN19@PrtMode
$LN15@PrtMode:

; 463  :          case GunsEngageMode:   
; 464  :             PrintOnline("DIGI GUNS ENGAGE");

	push	OFFSET ??_C@_0BB@ILDJCOFH@DIGI?5GUNS?5ENGAGE?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 465  :          break;

	jmp	$LN19@PrtMode
$LN14@PrtMode:

; 466  :          case BVREngageMode:  
; 467  :             PrintOnline("DIGI BVR ENGAGE");

	push	OFFSET ??_C@_0BA@NOOCIIAO@DIGI?5BVR?5ENGAGE?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 468  :          break;

	jmp	$LN19@PrtMode
$LN13@PrtMode:

; 469  :          case WVREngageMode:  
; 470  :             PrintOnline("DIGI WVR ENGAGE");

	push	OFFSET ??_C@_0BA@BEDOAIH@DIGI?5WVR?5ENGAGE?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 471  :          break;

	jmp	$LN19@PrtMode
$LN12@PrtMode:

; 472  :          case MissileDefeatMode:
; 473  :             PrintOnline("DIGI MISSILE DEFEAT");

	push	OFFSET ??_C@_0BE@DBHADILF@DIGI?5MISSILE?5DEFEAT?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 474  :          break;

	jmp	$LN19@PrtMode
$LN11@PrtMode:

; 475  :          case MissileEngageMode:  
; 476  :             PrintOnline("DIGI MSSLE ENGAGE");

	push	OFFSET ??_C@_0BC@BMHHMHEC@DIGI?5MSSLE?5ENGAGE?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 477  :          break;

	jmp	$LN19@PrtMode
$LN10@PrtMode:

; 478  :          case GunsJinkMode:   
; 479  :             PrintOnline("DIGI GUNS JINK");

	push	OFFSET ??_C@_0P@JMBPCAIK@DIGI?5GUNS?5JINK?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 480  :          break;

	jmp	$LN19@PrtMode
$LN9@PrtMode:

; 481  :          case GroundAvoidMode:
; 482  :             PrintOnline("DIGI GROUND AVOID");

	push	OFFSET ??_C@_0BC@JCCMCFGE@DIGI?5GROUND?5AVOID?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 483  :          break;

	jmp	SHORT $LN19@PrtMode
$LN8@PrtMode:

; 484  :          case LoiterMode:       
; 485  :             PrintOnline("DIGI LoiterMode");

	push	OFFSET ??_C@_0BA@HMKNELDE@DIGI?5LoiterMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 486  :          break;

	jmp	SHORT $LN19@PrtMode
$LN7@PrtMode:

; 487  :          case RunAwayMode:    
; 488  :             PrintOnline("DIGI DISENGAGE");

	push	OFFSET ??_C@_0P@EAOEDDJH@DIGI?5DISENGAGE?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 489  :          break;

	jmp	SHORT $LN19@PrtMode
$LN6@PrtMode:

; 490  :          case OvershootMode:    
; 491  :             PrintOnline("DIGI OvershootMode");

	push	OFFSET ??_C@_0BD@FELPCLPO@DIGI?5OvershootMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 492  :          break;

	jmp	SHORT $LN19@PrtMode
$LN5@PrtMode:

; 493  :          case CollisionAvoidMode:    
; 494  :             PrintOnline("DIGI COLLISION");

	push	OFFSET ??_C@_0P@EBBHJGFG@DIGI?5COLLISION?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 495  :          break;

	jmp	SHORT $LN19@PrtMode
$LN4@PrtMode:

; 496  :          case AccelerateMode:    
; 497  :             PrintOnline("DIGI AccelerateMode");

	push	OFFSET ??_C@_0BE@JDBEHEKI@DIGI?5AccelerateMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 498  :          break;

	jmp	SHORT $LN19@PrtMode
$LN3@PrtMode:

; 499  :          case SeparateMode:    
; 500  :             PrintOnline("DIGI SeparateMode");

	push	OFFSET ??_C@_0BC@GFJFLHLG@DIGI?5SeparateMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 501  :          break;

	jmp	SHORT $LN19@PrtMode
$LN2@PrtMode:

; 502  :          case RoopMode:    
; 503  :             PrintOnline("DIGI RoopMode");

	push	OFFSET ??_C@_0O@FNCLHCMN@DIGI?5RoopMode?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline

; 504  :          break;

	jmp	SHORT $LN19@PrtMode
$LN1@PrtMode:

; 505  :          case OverBMode:    
; 506  :             PrintOnline("DIGI OVERBANK");

	push	OFFSET ??_C@_0O@EHOPNIJE@DIGI?5OVERBANK?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintOnline@HeliBrain@@QAEXPAD@Z	; HeliBrain::PrintOnline
$LN19@PrtMode:

; 507  :          break;
; 508  :       }
; 509  : 
; 510  :       modeMsg = new AirAIModeMsg (self->Id(), FalconLocalGame);

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN26@PrtMode
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@PrtMode
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN25@PrtMode
$LN24@PrtMode:
	mov	DWORD PTR tv161[ebp], 0
$LN25@PrtMode:
	push	1
	mov	ecx, DWORD PTR tv161[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0AirAIModeMsg@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; AirAIModeMsg::AirAIModeMsg
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN27@PrtMode
$LN26@PrtMode:
	mov	DWORD PTR tv173[ebp], 0
$LN27@PrtMode:
	mov	eax, DWORD PTR tv173[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _modeMsg$[ebp], ecx

; 511  :       modeMsg->dataBlock.whoDidIt = self->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _modeMsg$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 512  :       modeMsg->dataBlock.newMode = curMode;

	mov	ecx, DWORD PTR _modeMsg$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+56], eax

; 513  :       FalconSendMessage (modeMsg,FALSE);

	push	0
	mov	ecx, DWORD PTR _modeMsg$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN22@PrtMode:

; 514  :    }
; 515  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN30@PrtMode:
	DD	$LN9@PrtMode
	DD	$LN5@PrtMode
	DD	$LN10@PrtMode
	DD	$LN12@PrtMode
	DD	$LN19@PrtMode
	DD	$LN19@PrtMode
	DD	$LN19@PrtMode
	DD	$LN19@PrtMode
	DD	$LN15@PrtMode
	DD	$LN11@PrtMode
	DD	$LN2@PrtMode
	DD	$LN1@PrtMode
	DD	$LN13@PrtMode
	DD	$LN14@PrtMode
	DD	$LN4@PrtMode
	DD	$LN6@PrtMode
	DD	$LN7@PrtMode
	DD	$LN8@PrtMode
	DD	$LN3@PrtMode
	DD	$LN18@PrtMode
	DD	$LN19@PrtMode
	DD	$LN17@PrtMode
	DD	$LN16@PrtMode
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PrtMode@HeliBrain@@QAEXXZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?PrtMode@HeliBrain@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PrtMode@HeliBrain@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PrtMode@HeliBrain@@QAEXXZ ENDP				; HeliBrain::PrtMode
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newMode$ = 8						; size = 4
?AddMode@HeliBrain@@QAEXW4DigiMode@1@@Z PROC		; HeliBrain::AddMode
; _this$ = ecx

; 522  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 523  :    if (newMode < nextMode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newMode$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jge	SHORT $LN2@AddMode

; 524  :       nextMode = newMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newMode$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN2@AddMode:

; 525  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddMode@HeliBrain@@QAEXW4DigiMode@1@@Z ENDP		; HeliBrain::AddMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\hdigi\h_dlogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResolveModeConflicts@HeliBrain@@QAEXXZ PROC		; HeliBrain::ResolveModeConflicts
; _this$ = ecx

; 528  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 529  :    /*--------------------*/
; 530  :    /* What were we doing */
; 531  :    /*--------------------*/
; 532  :    lastMode = curMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+44], edx

; 533  :    curMode  = nextMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+36], edx

; 534  :    nextMode = NoMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 26			; 0000001aH

; 535  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResolveModeConflicts@HeliBrain@@QAEXXZ ENDP		; HeliBrain::ResolveModeConflicts
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsAwake@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 177  : 	int IsAwake() const { return localFlags & OBJ_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
END
