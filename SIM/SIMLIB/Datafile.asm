; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\SIMLIB\Datafile.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	??0FileReader@@QAE@PBUInputDataDesc@@@Z		; FileReader::FileReader
PUBLIC	?Initialise@FileReader@@UAEXPAX@Z		; FileReader::Initialise
PUBLIC	?ParseField@FileReader@@UAE_NPAXPBD@Z		; FileReader::ParseField
PUBLIC	?AssignField@FileReader@@QAE_NPBUInputDataDesc@@PAXPBD@Z ; FileReader::AssignField
PUBLIC	?AssignField@@YA_NPBUInputDataDesc@@PAXPBD@Z	; AssignField
PUBLIC	?FindField@@YAPBUInputDataDesc@@PBU1@PBD@Z	; FindField
PUBLIC	?ParseField@@YA_NPAXPBDPBUInputDataDesc@@@Z	; ParseField
PUBLIC	?Initialise@@YAXPAXPBUInputDataDesc@@@Z		; Initialise
PUBLIC	?ParseSimlibFile@@YA_NPAXPBUInputDataDesc@@PAVSimlibFileClass@@@Z ; ParseSimlibFile
PUBLIC	??_7FileReader@@6B@				; FileReader::`vftable'
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg?$AA@	; `string'
PUBLIC	??_C@_0L@PFHGFMOH@?$CFg?0?5?$CFg?0?5?$CFg?$AA@	; `string'
PUBLIC	??_R4FileReader@@6B@				; FileReader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileReader@@@8				; FileReader `RTTI Type Descriptor'
PUBLIC	??_R3FileReader@@8				; FileReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileReader@@8				; FileReader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileReader@@8			; FileReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_sscanf:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_strcmpi:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	?ReadLine@SimlibFileClass@@QAEHPADH@Z:PROC	; SimlibFileClass::ReadLine
EXTRN	?Parse@TwoDimensionTable@@QAEXPAD@Z:PROC	; TwoDimensionTable::Parse
EXTRN	?TokenF@@YAMPADM@Z:PROC				; TokenF
EXTRN	?TokenI@@YAHPADH@Z:PROC				; TokenI
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@FileReader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileReader@@8 DD FLAT:??_R0?AVFileReader@@@8 ; FileReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileReader@@8
rdata$r	ENDS
;	COMDAT ??_R2FileReader@@8
rdata$r	SEGMENT
??_R2FileReader@@8 DD FLAT:??_R1A@?0A@EA@FileReader@@8	; FileReader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3FileReader@@8
rdata$r	SEGMENT
??_R3FileReader@@8 DD 00H				; FileReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2FileReader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileReader@@@8
_DATA	SEGMENT
??_R0?AVFileReader@@@8 DD FLAT:??_7type_info@@6B@	; FileReader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileReader@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileReader@@6B@
rdata$r	SEGMENT
??_R4FileReader@@6B@ DD 00H				; FileReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileReader@@@8
	DD	FLAT:??_R3FileReader@@8
rdata$r	ENDS
;	COMDAT ??_C@_0L@PFHGFMOH@?$CFg?0?5?$CFg?0?5?$CFg?$AA@
CONST	SEGMENT
??_C@_0L@PFHGFMOH@?$CFg?0?5?$CFg?0?5?$CFg?$AA@ DB '%g, %g, %g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg?$AA@
CONST	SEGMENT
??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg?$AA@ DB '%g %g %g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7FileReader@@6B@
CONST	SEGMENT
??_7FileReader@@6B@ DD FLAT:??_R4FileReader@@6B@	; FileReader::`vftable'
	DD	FLAT:?Initialise@FileReader@@UAEXPAX@Z
	DD	FLAT:?ParseField@FileReader@@UAE_NPAXPBD@Z
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_fr$ = -272						; size = 8
_buffer$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_dataPtr$ = 8						; size = 4
_desc$ = 12						; size = 4
_inputFile$ = 16					; size = 4
?ParseSimlibFile@@YA_NPAXPBUInputDataDesc@@PAVSimlibFileClass@@@Z PROC ; ParseSimlibFile

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 184  :     FileReader fr(desc);

	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fr$[ebp]
	call	??0FileReader@@QAE@PBUInputDataDesc@@@Z	; FileReader::FileReader

; 185  :     SimlibFileName buffer;
; 186  : 	
; 187  :     fr.Initialise(dataPtr);

	mov	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _fr$[ebp]
	call	?Initialise@FileReader@@UAEXPAX@Z	; FileReader::Initialise
$LN4@ParseSimli:

; 188  :     while (inputFile->ReadLine(buffer, sizeof buffer) == SIMLIB_OK) {

	push	260					; 00000104H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _inputFile$[ebp]
	call	?ReadLine@SimlibFileClass@@QAEHPADH@Z	; SimlibFileClass::ReadLine
	test	eax, eax
	jne	SHORT $LN3@ParseSimli

; 189  : 		if (buffer[0] == '#') continue;

	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 35					; 00000023H
	jne	SHORT $LN2@ParseSimli
	jmp	SHORT $LN4@ParseSimli
$LN2@ParseSimli:

; 190  : 		if (fr.ParseField(dataPtr, buffer) == false){

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fr$[ebp]
	call	?ParseField@FileReader@@UAE_NPAXPBD@Z	; FileReader::ParseField

; 191  : 			// MLR 12/16/2003 - 
; 192  : 			// Who cares if one line failed!  This breaks files that have obsolete/unsupported data in them.
; 193  : 			// return false; 
; 194  : 		}
; 195  :     }

	jmp	SHORT $LN4@ParseSimli
$LN3@ParseSimli:

; 196  :     return true;

	mov	al, 1

; 197  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ParseSimlibFile@@YA_NPAXPBUInputDataDesc@@PAVSimlibFileClass@@@Z ENDP ; ParseSimlibFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_dataPtr$ = 8						; size = 4
_desc$ = 12						; size = 4
?Initialise@@YAXPAXPBUInputDataDesc@@@Z PROC		; Initialise

; 153  : {

	push	ebp
	mov	ebp, esp

; 154  :     for(; desc->name; desc ++) {

	jmp	SHORT $LN3@Initialise
$LN2@Initialise:
	mov	eax, DWORD PTR _desc$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _desc$[ebp], eax
$LN3@Initialise:
	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@Initialise

; 155  : 	AssignField(desc, dataPtr, desc->defvalue);

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _desc$[ebp]
	push	edx
	call	?AssignField@@YA_NPBUInputDataDesc@@PAXPBD@Z ; AssignField
	add	esp, 12					; 0000000cH

; 156  :     }

	jmp	SHORT $LN2@Initialise
$LN4@Initialise:

; 157  : }

	pop	ebp
	ret	0
?Initialise@@YAXPAXPBUInputDataDesc@@@Z ENDP		; Initialise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_field$ = -1040						; size = 4
$T1 = -1036						; size = 4
_cp$ = -1032						; size = 4
_keybuf$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_dataPtr$ = 8						; size = 4
_line$ = 12						; size = 4
_desc$ = 16						; size = 4
?ParseField@@YA_NPAXPBDPBUInputDataDesc@@@Z PROC	; ParseField

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1040				; 00000410H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
$LN11@ParseField:

; 129  :     char keybuf[1024];
; 130  : 
; 131  :     while (isspace(*line)) // skip leanding white space

	mov	eax, DWORD PTR _line$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@ParseField

; 132  : 	line ++;

	mov	edx, DWORD PTR _line$[ebp]
	add	edx, 1
	mov	DWORD PTR _line$[ebp], edx
	jmp	SHORT $LN11@ParseField
$LN10@ParseField:

; 133  :     if (*line == '\0' || *line == '\n') return true; // just ignore blank lines

	mov	eax, DWORD PTR _line$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@ParseField
	mov	edx, DWORD PTR _line$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN9@ParseField
$LN8@ParseField:
	mov	al, 1
	jmp	$LN13@ParseField
$LN9@ParseField:

; 134  :     const char *cp = line;

	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR _cp$[ebp], ecx
$LN7@ParseField:

; 135  :     while (*cp && !isspace(*cp))

	mov	edx, DWORD PTR _cp$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@ParseField
	mov	ecx, DWORD PTR _cp$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	_isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@ParseField

; 136  : 	cp ++;

	mov	eax, DWORD PTR _cp$[ebp]
	add	eax, 1
	mov	DWORD PTR _cp$[ebp], eax
	jmp	SHORT $LN7@ParseField
$LN6@ParseField:

; 137  :     if (*cp == '\0') // bad data

	mov	ecx, DWORD PTR _cp$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@ParseField

; 138  : 	return false;

	xor	al, al
	jmp	$LN13@ParseField
$LN5@ParseField:

; 139  :     strncpy (keybuf, line, cp - line);

	mov	eax, DWORD PTR _cp$[ebp]
	sub	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	lea	edx, DWORD PTR _keybuf$[ebp]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 140  :     keybuf[cp-line] = '\0';

	mov	eax, DWORD PTR _cp$[ebp]
	sub	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN14@ParseField
	jmp	SHORT $LN15@ParseField
$LN14@ParseField:
	call	___report_rangecheckfailure
$LN15@ParseField:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _keybuf$[ebp+ecx], 0
$LN4@ParseField:

; 141  : 
; 142  :     while (isspace(*cp))

	mov	edx, DWORD PTR _cp$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@ParseField

; 143  : 	cp ++;

	mov	ecx, DWORD PTR _cp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cp$[ebp], ecx
	jmp	SHORT $LN4@ParseField
$LN3@ParseField:

; 144  :     // cp now at the start of the next bit
; 145  :     const InputDataDesc *field = FindField(desc, keybuf);

	lea	edx, DWORD PTR _keybuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	call	?FindField@@YAPBUInputDataDesc@@PBU1@PBD@Z ; FindField
	add	esp, 8
	mov	DWORD PTR _field$[ebp], eax

; 146  :     if (field)

	cmp	DWORD PTR _field$[ebp], 0
	je	SHORT $LN2@ParseField

; 147  : 	return AssignField(field, dataPtr, cp);

	mov	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _field$[ebp]
	push	eax
	call	?AssignField@@YA_NPBUInputDataDesc@@PAXPBD@Z ; AssignField
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@ParseField
	jmp	SHORT $LN13@ParseField
$LN2@ParseField:

; 148  :     else return false;

	xor	al, al
$LN13@ParseField:

; 149  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ParseField@@YA_NPAXPBDPBUInputDataDesc@@@Z ENDP	; ParseField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_desc$ = 8						; size = 4
_key$ = 12						; size = 4
?FindField@@YAPBUInputDataDesc@@PBU1@PBD@Z PROC		; FindField

; 117  : {

	push	ebp
	mov	ebp, esp
$LN3@FindField:

; 118  :     while (desc->name) {

	mov	eax, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FindField

; 119  : 	if (strcmpi(desc->name, key) == 0)

	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcmpi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@FindField

; 120  : 	    return desc;

	mov	eax, DWORD PTR _desc$[ebp]
	jmp	SHORT $LN4@FindField
$LN1@FindField:

; 121  : 	desc ++;

	mov	ecx, DWORD PTR _desc$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _desc$[ebp], ecx

; 122  :     }

	jmp	SHORT $LN3@FindField
$LN2@FindField:

; 123  :     return NULL;

	xor	eax, eax
$LN4@FindField:

; 124  : }

	pop	ebp
	ret	0
?FindField@@YAPBUInputDataDesc@@PBU1@PBD@Z ENDP		; FindField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_fp$1 = -4104						; size = 4
_count$2 = -4100					; size = 4
_n$3 = -4096						; size = 4
_fp$4 = -4092						; size = 4
_lut$5 = -4088						; size = 4
tv67 = -4084						; size = 4
_ip$6 = -4080						; size = 4
_vp$7 = -4076						; size = 4
_lut$8 = -4072						; size = 4
_l$9 = -4068						; size = 4
_l$10 = -4064						; size = 4
_tp$11 = -4060						; size = 4
_cp$ = -4056						; size = 4
_buffer$12 = -4052					; size = 2000
_buffer$13 = -2052					; size = 1024
_buffer$14 = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_field$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_value$ = 16						; size = 4
?AssignField@@YA_NPBUInputDataDesc@@PAXPBD@Z PROC	; AssignField

; 18   : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4104				; 00001008H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 19   :     char *cp = (char *)dataPtr + field->offset;

	mov	eax, DWORD PTR _field$[ebp]
	mov	ecx, DWORD PTR _dataPtr$[ebp]
	add	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cp$[ebp], ecx

; 20   : 
; 21   :     switch (field->type) {

	mov	edx, DWORD PTR _field$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN1@AssignFiel
	mov	ecx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN34@AssignFiel[ecx*4]
$LN29@AssignFiel:

; 22   :     case InputDataDesc::ID_INT:
; 23   : 	{
; 24   : 	    int *ip = (int *)cp;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _ip$6[ebp], edx

; 25   : 	    int n;
; 26   : 	    if (*value == '0' && (value[1] == 'x' || value[1] == 'X')) {

	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN28@AssignFiel
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 120				; 00000078H
	je	SHORT $LN27@AssignFiel
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 88					; 00000058H
	jne	SHORT $LN28@AssignFiel
$LN27@AssignFiel:

; 27   : 		if (sscanf(value+2, "%x", &n) == 1)

	lea	edx, DWORD PTR _n$3[ebp]
	push	edx
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	eax, DWORD PTR _value$[ebp]
	add	eax, 2
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN26@AssignFiel

; 28   : 		    *ip = n;

	mov	ecx, DWORD PTR _ip$6[ebp]
	mov	edx, DWORD PTR _n$3[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN25@AssignFiel
$LN26@AssignFiel:

; 29   : 		else return false;

	xor	al, al
	jmp	$LN32@AssignFiel
$LN25@AssignFiel:
	jmp	SHORT $LN21@AssignFiel
$LN28@AssignFiel:

; 30   : 	    }
; 31   : 	    else if (isdigit(*value) || *value=='-')

	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@AssignFiel
	mov	edx, DWORD PTR _value$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN23@AssignFiel
$LN22@AssignFiel:

; 32   : 		*ip = atoi(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _ip$6[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN21@AssignFiel
$LN23@AssignFiel:

; 33   : 	    else return false;

	xor	al, al
	jmp	$LN32@AssignFiel
$LN21@AssignFiel:

; 34   : 	}
; 35   : 	break;

	jmp	$LN30@AssignFiel
$LN20@AssignFiel:

; 36   :     case InputDataDesc::ID_FLOAT:
; 37   : 	{
; 38   : 	    float *fp = (float *)cp;

	mov	eax, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _fp$1[ebp], eax

; 39   : 	    if (isdigit(*value) || *value == '.' || *value == '-' || *value =='+')

	mov	ecx, DWORD PTR _value$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@AssignFiel
	mov	eax, DWORD PTR _value$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN18@AssignFiel
	mov	edx, DWORD PTR _value$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN18@AssignFiel
	mov	ecx, DWORD PTR _value$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN19@AssignFiel
$LN18@AssignFiel:

; 40   : 		*fp = (float)atof(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _fp$1[ebp]
	fstp	DWORD PTR [ecx]

; 41   : 	    else 

	jmp	SHORT $LN17@AssignFiel
$LN19@AssignFiel:

; 42   : 		return false;

	xor	al, al
	jmp	$LN32@AssignFiel
$LN17@AssignFiel:

; 43   : 	}
; 44   : 	break;

	jmp	$LN30@AssignFiel
$LN16@AssignFiel:

; 45   :     case InputDataDesc::ID_STRING:
; 46   : 	{
; 47   : 	    char **vp = (char **)cp;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _vp$7[ebp], edx

; 48   : 	    if (*vp) free (*vp);

	mov	eax, DWORD PTR _vp$7[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN15@AssignFiel
	mov	ecx, DWORD PTR _vp$7[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4
$LN15@AssignFiel:

; 49   : 	    *vp = (char *)malloc(strlen(value) + 1);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _vp$7[ebp]
	mov	DWORD PTR [ecx], eax

; 50   : 	    strcpy (*vp, value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _vp$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 51   : 	}
; 52   : 	break;

	jmp	$LN30@AssignFiel
$LN14@AssignFiel:

; 53   :     case InputDataDesc::ID_CHAR:
; 54   : 	{
; 55   : 	    *cp = *value;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 56   : 	}
; 57   : 	break;

	jmp	$LN30@AssignFiel
$LN13@AssignFiel:

; 58   :     case InputDataDesc::ID_VECTOR: // X, Y, Z
; 59   : 	{
; 60   : 	    Tpoint *tp = (Tpoint *)cp;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _tp$11[ebp], edx

; 61   : 	    if (sscanf(value, "%g %g %g", &tp->x, &tp->y, &tp->z) != 3)

	mov	eax, DWORD PTR _tp$11[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _tp$11[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _tp$11[ebp]
	push	edx
	push	OFFSET ??_C@_08MHIFFAO@?$CFg?5?$CFg?5?$CFg?$AA@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 3
	je	SHORT $LN11@AssignFiel

; 62   : 			if (sscanf(value, "%g, %g, %g", &tp->x, &tp->y, &tp->z) != 3) // MLR 12/4/2003 - Make the vector reading a little more flexible

	mov	ecx, DWORD PTR _tp$11[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _tp$11[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _tp$11[ebp]
	push	eax
	push	OFFSET ??_C@_0L@PFHGFMOH@?$CFg?0?5?$CFg?0?5?$CFg?$AA@
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 3
	je	SHORT $LN11@AssignFiel

; 63   : 			{
; 64   : 				return false;

	xor	al, al
	jmp	$LN32@AssignFiel
$LN11@AssignFiel:

; 65   : 
; 66   : 			}
; 67   : 	}
; 68   : 	break;

	jmp	$LN30@AssignFiel
$LN10@AssignFiel:

; 69   : 	case InputDataDesc::ID_FLOAT_ARRAY:
; 70   : 	{
; 71   : 		int count,l;
; 72   : 	    float *fp = (float *)cp;

	mov	edx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _fp$4[ebp], edx

; 73   : 		char buffer[1024];
; 74   : 		strcpy(buffer,value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$13[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 75   : 
; 76   : 		count=TokenI(buffer,0);

	push	0
	lea	edx, DWORD PTR _buffer$13[ebp]
	push	edx
	call	?TokenI@@YAHPADH@Z			; TokenI
	add	esp, 8
	mov	DWORD PTR _count$2[ebp], eax

; 77   : 		for(l=0;l<count;l++)

	mov	DWORD PTR _l$9[ebp], 0
	jmp	SHORT $LN9@AssignFiel
$LN8@AssignFiel:
	mov	eax, DWORD PTR _l$9[ebp]
	add	eax, 1
	mov	DWORD PTR _l$9[ebp], eax
$LN9@AssignFiel:
	mov	ecx, DWORD PTR _l$9[ebp]
	cmp	ecx, DWORD PTR _count$2[ebp]
	jge	SHORT $LN7@AssignFiel

; 78   : 		{
; 79   :           fp[l]=TokenF(0,0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	call	?TokenF@@YAMPADM@Z			; TokenF
	add	esp, 8
	mov	edx, DWORD PTR _l$9[ebp]
	mov	eax, DWORD PTR _fp$4[ebp]
	fstp	DWORD PTR [eax+edx*4]

; 80   : 		}

	jmp	SHORT $LN8@AssignFiel
$LN7@AssignFiel:

; 81   : 	}
; 82   : 	break;

	jmp	$LN30@AssignFiel
$LN6@AssignFiel:

; 83   : 	case InputDataDesc::ID_LOOKUPTABLE:
; 84   : 	{
; 85   : 		int l;
; 86   : 	    LookupTable *lut = (LookupTable *)cp;

	mov	ecx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _lut$8[ebp], ecx

; 87   : 		char buffer[1024];
; 88   : 		strcpy(buffer,value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$14[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 89   : 
; 90   : 		lut->pairs=TokenI(buffer,0);

	push	0
	lea	ecx, DWORD PTR _buffer$14[ebp]
	push	ecx
	call	?TokenI@@YAHPADH@Z			; TokenI
	add	esp, 8
	mov	edx, DWORD PTR _lut$8[ebp]
	mov	DWORD PTR [edx], eax

; 91   : 		for(l=0;l<lut->pairs;l++)

	mov	DWORD PTR _l$10[ebp], 0
	jmp	SHORT $LN5@AssignFiel
$LN4@AssignFiel:
	mov	eax, DWORD PTR _l$10[ebp]
	add	eax, 1
	mov	DWORD PTR _l$10[ebp], eax
$LN5@AssignFiel:
	mov	ecx, DWORD PTR _lut$8[ebp]
	mov	edx, DWORD PTR _l$10[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@AssignFiel

; 92   : 		{
; 93   : 			lut->table[l].input =TokenF(0,0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	call	?TokenF@@YAMPADM@Z			; TokenF
	add	esp, 8
	mov	eax, DWORD PTR _l$10[ebp]
	mov	ecx, DWORD PTR _lut$8[ebp]
	fstp	DWORD PTR [ecx+eax*8+4]

; 94   : 			lut->table[l].output=TokenF(0,0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	call	?TokenF@@YAMPADM@Z			; TokenF
	add	esp, 8
	mov	edx, DWORD PTR _l$10[ebp]
	mov	eax, DWORD PTR _lut$8[ebp]
	fstp	DWORD PTR [eax+edx*8+8]

; 95   : 		}

	jmp	SHORT $LN4@AssignFiel
$LN3@AssignFiel:

; 96   : 	}
; 97   : 	break;

	jmp	SHORT $LN30@AssignFiel
$LN2@AssignFiel:

; 98   : 	case InputDataDesc::ID_2DTABLE://Cobra 10/31/04 TJL
; 99   : 	{
; 100  : 	    TwoDimensionTable *lut = (TwoDimensionTable *)cp;

	mov	ecx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR _lut$5[ebp], ecx

; 101  : 		char buffer[2000];
; 102  : 		strcpy(buffer,value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	lea	eax, DWORD PTR _buffer$12[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 103  : 		lut->Parse(buffer);

	lea	ecx, DWORD PTR _buffer$12[ebp]
	push	ecx
	mov	ecx, DWORD PTR _lut$5[ebp]
	call	?Parse@TwoDimensionTable@@QAEXPAD@Z	; TwoDimensionTable::Parse

; 104  : 	}
; 105  : 	break;

	jmp	SHORT $LN30@AssignFiel
$LN1@AssignFiel:

; 106  : 
; 107  :     
; 108  : 	default:
; 109  : 	F4Assert(!"Bad format type");
; 110  : 	return false;

	xor	al, al
	jmp	SHORT $LN32@AssignFiel
$LN30@AssignFiel:

; 111  :     }
; 112  :     return true;

	mov	al, 1
$LN32@AssignFiel:

; 113  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN34@AssignFiel:
	DD	$LN29@AssignFiel
	DD	$LN20@AssignFiel
	DD	$LN16@AssignFiel
	DD	$LN14@AssignFiel
	DD	$LN13@AssignFiel
	DD	$LN10@AssignFiel
	DD	$LN6@AssignFiel
	DD	$LN2@AssignFiel
?AssignField@@YA_NPBUInputDataDesc@@PAXPBD@Z ENDP	; AssignField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
_dataPtr$ = 12						; size = 4
_value$ = 16						; size = 4
?AssignField@FileReader@@QAE_NPBUInputDataDesc@@PAXPBD@Z PROC ; FileReader::AssignField
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  :     return ::AssignField(desc, dataPtr, value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _desc$[ebp]
	push	edx
	call	?AssignField@@YA_NPBUInputDataDesc@@PAXPBD@Z ; AssignField
	add	esp, 12					; 0000000cH

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AssignField@FileReader@@QAE_NPBUInputDataDesc@@PAXPBD@Z ENDP ; FileReader::AssignField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dataPtr$ = 8						; size = 4
_line$ = 12						; size = 4
?ParseField@FileReader@@UAE_NPAXPBD@Z PROC		; FileReader::ParseField
; _this$ = ecx

; 174  : bool FileReader::ParseField(void *dataPtr, const char *line){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  :     return ::ParseField(dataPtr, line, m_desc);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	call	?ParseField@@YA_NPAXPBDPBUInputDataDesc@@@Z ; ParseField
	add	esp, 12					; 0000000cH

; 176  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ParseField@FileReader@@UAE_NPAXPBD@Z ENDP		; FileReader::ParseField
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\datafile.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_dp$ = -4						; size = 4
_dataPtr$ = 8						; size = 4
?Initialise@FileReader@@UAEXPAX@Z PROC			; FileReader::Initialise
; _this$ = ecx

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 162  :     const InputDataDesc *dp;
; 163  : 
; 164  :     for (dp = m_desc;dp->name; dp++) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dp$[ebp], ecx
	jmp	SHORT $LN3@Initialise
$LN2@Initialise:
	mov	edx, DWORD PTR _dp$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _dp$[ebp], edx
$LN3@Initialise:
	mov	eax, DWORD PTR _dp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Initialise

; 165  : 	AssignField(dp, dataPtr, dp->defvalue);

	mov	ecx, DWORD PTR _dp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignField@FileReader@@QAE_NPBUInputDataDesc@@PAXPBD@Z ; FileReader::AssignField
	jmp	SHORT $LN2@Initialise
$LN4@Initialise:

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Initialise@FileReader@@UAEXPAX@Z ENDP			; FileReader::Initialise
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\datafile.h
;	COMDAT ??0FileReader@@QAE@PBUInputDataDesc@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
??0FileReader@@QAE@PBUInputDataDesc@@@Z PROC		; FileReader::FileReader, COMDAT
; _this$ = ecx

; 18   : 	FileReader(const InputDataDesc *desc) : m_desc(desc) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7FileReader@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _desc$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FileReader@@QAE@PBUInputDataDesc@@@Z ENDP		; FileReader::FileReader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
