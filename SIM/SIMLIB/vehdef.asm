; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\SIMLIB\vehdef.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
PUBLIC	?NumSimMoverDefinitions@@3HA			; NumSimMoverDefinitions
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?moverDefinitionData@@3PAPAVSimMoverDefinition@@A DD 01H DUP (?) ; moverDefinitionData
?NumSimMoverDefinitions@@3HA DD 01H DUP (?)		; NumSimMoverDefinitions
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	??0SimMoverDefinition@@QAE@XZ			; SimMoverDefinition::SimMoverDefinition
PUBLIC	??1SimMoverDefinition@@UAE@XZ			; SimMoverDefinition::~SimMoverDefinition
PUBLIC	?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ ; SimMoverDefinition::ReadSimMoverDefinitionData
PUBLIC	?FreeSimMoverDefinitionData@SimMoverDefinition@@SAXXZ ; SimMoverDefinition::FreeSimMoverDefinitionData
PUBLIC	??_GSimMoverDefinition@@UAEPAXI@Z		; SimMoverDefinition::`scalar deleting destructor'
PUBLIC	??0SimACDefinition@@QAE@PAD@Z			; SimACDefinition::SimACDefinition
PUBLIC	??1SimACDefinition@@UAE@XZ			; SimACDefinition::~SimACDefinition
PUBLIC	??_GSimACDefinition@@UAEPAXI@Z			; SimACDefinition::`scalar deleting destructor'
PUBLIC	??0SimWpnDefinition@@QAE@PAD@Z			; SimWpnDefinition::SimWpnDefinition
PUBLIC	??1SimWpnDefinition@@UAE@XZ			; SimWpnDefinition::~SimWpnDefinition
PUBLIC	??_GSimWpnDefinition@@UAEPAXI@Z			; SimWpnDefinition::`scalar deleting destructor'
PUBLIC	??0SimHeloDefinition@@QAE@PAD@Z			; SimHeloDefinition::SimHeloDefinition
PUBLIC	??1SimHeloDefinition@@UAE@XZ			; SimHeloDefinition::~SimHeloDefinition
PUBLIC	??_GSimHeloDefinition@@UAEPAXI@Z		; SimHeloDefinition::`scalar deleting destructor'
PUBLIC	??0SimGroundDefinition@@QAE@PAD@Z		; SimGroundDefinition::SimGroundDefinition
PUBLIC	??1SimGroundDefinition@@UAE@XZ			; SimGroundDefinition::~SimGroundDefinition
PUBLIC	??_GSimGroundDefinition@@UAEPAXI@Z		; SimGroundDefinition::`scalar deleting destructor'
PUBLIC	??_7SimMoverDefinition@@6B@			; SimMoverDefinition::`vftable'
PUBLIC	??_7SimACDefinition@@6B@			; SimACDefinition::`vftable'
PUBLIC	??_7SimWpnDefinition@@6B@			; SimWpnDefinition::`vftable'
PUBLIC	??_7SimHeloDefinition@@6B@			; SimHeloDefinition::`vftable'
PUBLIC	??_7SimGroundDefinition@@6B@			; SimGroundDefinition::`vftable'
PUBLIC	??_C@_0BH@FEDHPIGL@sim?2vehdef?2vehicle?4lst?$AA@ ; `string'
PUBLIC	??_R4SimMoverDefinition@@6B@			; SimMoverDefinition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSimMoverDefinition@@@8			; SimMoverDefinition `RTTI Type Descriptor'
PUBLIC	??_R3SimMoverDefinition@@8			; SimMoverDefinition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimMoverDefinition@@8			; SimMoverDefinition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimMoverDefinition@@8		; SimMoverDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SimACDefinition@@6B@			; SimACDefinition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSimACDefinition@@@8			; SimACDefinition `RTTI Type Descriptor'
PUBLIC	??_R3SimACDefinition@@8				; SimACDefinition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimACDefinition@@8				; SimACDefinition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimACDefinition@@8		; SimACDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SimWpnDefinition@@6B@			; SimWpnDefinition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSimWpnDefinition@@@8			; SimWpnDefinition `RTTI Type Descriptor'
PUBLIC	??_R3SimWpnDefinition@@8			; SimWpnDefinition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimWpnDefinition@@8			; SimWpnDefinition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimWpnDefinition@@8		; SimWpnDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SimHeloDefinition@@6B@			; SimHeloDefinition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSimHeloDefinition@@@8			; SimHeloDefinition `RTTI Type Descriptor'
PUBLIC	??_R3SimHeloDefinition@@8			; SimHeloDefinition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimHeloDefinition@@8			; SimHeloDefinition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimHeloDefinition@@8		; SimHeloDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SimGroundDefinition@@6B@			; SimGroundDefinition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSimGroundDefinition@@@8			; SimGroundDefinition `RTTI Type Descriptor'
PUBLIC	??_R3SimGroundDefinition@@8			; SimGroundDefinition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimGroundDefinition@@8			; SimGroundDefinition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimGroundDefinition@@8		; SimGroundDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	_strcpy:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_ESimMoverDefinition@@UAEPAXI@Z:PROC		; SimMoverDefinition::`vector deleting destructor'
EXTRN	??_ESimACDefinition@@UAEPAXI@Z:PROC		; SimACDefinition::`vector deleting destructor'
EXTRN	??_ESimWpnDefinition@@UAEPAXI@Z:PROC		; SimWpnDefinition::`vector deleting destructor'
EXTRN	??_ESimHeloDefinition@@UAEPAXI@Z:PROC		; SimHeloDefinition::`vector deleting destructor'
EXTRN	??_ESimGroundDefinition@@UAEPAXI@Z:PROC		; SimGroundDefinition::`vector deleting destructor'
EXTRN	?Open@SimlibFileClass@@SAPAV1@PADH@Z:PROC	; SimlibFileClass::Open
EXTRN	?GetNext@SimlibFileClass@@QAEPADXZ:PROC		; SimlibFileClass::GetNext
EXTRN	?Close@SimlibFileClass@@QAEHXZ:PROC		; SimlibFileClass::Close
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@SimGroundDefinition@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimGroundDefinition@@8 DD FLAT:??_R0?AVSimGroundDefinition@@@8 ; SimGroundDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimGroundDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R2SimGroundDefinition@@8
rdata$r	SEGMENT
??_R2SimGroundDefinition@@8 DD FLAT:??_R1A@?0A@EA@SimGroundDefinition@@8 ; SimGroundDefinition::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R3SimGroundDefinition@@8
rdata$r	SEGMENT
??_R3SimGroundDefinition@@8 DD 00H			; SimGroundDefinition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SimGroundDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimGroundDefinition@@@8
_DATA	SEGMENT
??_R0?AVSimGroundDefinition@@@8 DD FLAT:??_7type_info@@6B@ ; SimGroundDefinition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimGroundDefinition@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SimGroundDefinition@@6B@
rdata$r	SEGMENT
??_R4SimGroundDefinition@@6B@ DD 00H			; SimGroundDefinition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimGroundDefinition@@@8
	DD	FLAT:??_R3SimGroundDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SimHeloDefinition@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimHeloDefinition@@8 DD FLAT:??_R0?AVSimHeloDefinition@@@8 ; SimHeloDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimHeloDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R2SimHeloDefinition@@8
rdata$r	SEGMENT
??_R2SimHeloDefinition@@8 DD FLAT:??_R1A@?0A@EA@SimHeloDefinition@@8 ; SimHeloDefinition::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R3SimHeloDefinition@@8
rdata$r	SEGMENT
??_R3SimHeloDefinition@@8 DD 00H			; SimHeloDefinition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SimHeloDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimHeloDefinition@@@8
_DATA	SEGMENT
??_R0?AVSimHeloDefinition@@@8 DD FLAT:??_7type_info@@6B@ ; SimHeloDefinition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimHeloDefinition@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SimHeloDefinition@@6B@
rdata$r	SEGMENT
??_R4SimHeloDefinition@@6B@ DD 00H			; SimHeloDefinition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimHeloDefinition@@@8
	DD	FLAT:??_R3SimHeloDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SimWpnDefinition@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimWpnDefinition@@8 DD FLAT:??_R0?AVSimWpnDefinition@@@8 ; SimWpnDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimWpnDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R2SimWpnDefinition@@8
rdata$r	SEGMENT
??_R2SimWpnDefinition@@8 DD FLAT:??_R1A@?0A@EA@SimWpnDefinition@@8 ; SimWpnDefinition::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R3SimWpnDefinition@@8
rdata$r	SEGMENT
??_R3SimWpnDefinition@@8 DD 00H				; SimWpnDefinition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SimWpnDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimWpnDefinition@@@8
_DATA	SEGMENT
??_R0?AVSimWpnDefinition@@@8 DD FLAT:??_7type_info@@6B@	; SimWpnDefinition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimWpnDefinition@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SimWpnDefinition@@6B@
rdata$r	SEGMENT
??_R4SimWpnDefinition@@6B@ DD 00H			; SimWpnDefinition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimWpnDefinition@@@8
	DD	FLAT:??_R3SimWpnDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SimACDefinition@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimACDefinition@@8 DD FLAT:??_R0?AVSimACDefinition@@@8 ; SimACDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimACDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R2SimACDefinition@@8
rdata$r	SEGMENT
??_R2SimACDefinition@@8 DD FLAT:??_R1A@?0A@EA@SimACDefinition@@8 ; SimACDefinition::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R3SimACDefinition@@8
rdata$r	SEGMENT
??_R3SimACDefinition@@8 DD 00H				; SimACDefinition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SimACDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimACDefinition@@@8
_DATA	SEGMENT
??_R0?AVSimACDefinition@@@8 DD FLAT:??_7type_info@@6B@	; SimACDefinition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimACDefinition@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SimACDefinition@@6B@
rdata$r	SEGMENT
??_R4SimACDefinition@@6B@ DD 00H			; SimACDefinition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimACDefinition@@@8
	DD	FLAT:??_R3SimACDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SimMoverDefinition@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimMoverDefinition@@8 DD FLAT:??_R0?AVSimMoverDefinition@@@8 ; SimMoverDefinition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R2SimMoverDefinition@@8
rdata$r	SEGMENT
??_R2SimMoverDefinition@@8 DD FLAT:??_R1A@?0A@EA@SimMoverDefinition@@8 ; SimMoverDefinition::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SimMoverDefinition@@8
rdata$r	SEGMENT
??_R3SimMoverDefinition@@8 DD 00H			; SimMoverDefinition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimMoverDefinition@@@8
_DATA	SEGMENT
??_R0?AVSimMoverDefinition@@@8 DD FLAT:??_7type_info@@6B@ ; SimMoverDefinition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimMoverDefinition@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SimMoverDefinition@@6B@
rdata$r	SEGMENT
??_R4SimMoverDefinition@@6B@ DD 00H			; SimMoverDefinition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimMoverDefinition@@@8
	DD	FLAT:??_R3SimMoverDefinition@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BH@FEDHPIGL@sim?2vehdef?2vehicle?4lst?$AA@
CONST	SEGMENT
??_C@_0BH@FEDHPIGL@sim?2vehdef?2vehicle?4lst?$AA@ DB 'sim\vehdef\vehicle.'
	DB	'lst', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7SimGroundDefinition@@6B@
CONST	SEGMENT
??_7SimGroundDefinition@@6B@ DD FLAT:??_R4SimGroundDefinition@@6B@ ; SimGroundDefinition::`vftable'
	DD	FLAT:??_ESimGroundDefinition@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SimHeloDefinition@@6B@
CONST	SEGMENT
??_7SimHeloDefinition@@6B@ DD FLAT:??_R4SimHeloDefinition@@6B@ ; SimHeloDefinition::`vftable'
	DD	FLAT:??_ESimHeloDefinition@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SimWpnDefinition@@6B@
CONST	SEGMENT
??_7SimWpnDefinition@@6B@ DD FLAT:??_R4SimWpnDefinition@@6B@ ; SimWpnDefinition::`vftable'
	DD	FLAT:??_ESimWpnDefinition@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SimACDefinition@@6B@
CONST	SEGMENT
??_7SimACDefinition@@6B@ DD FLAT:??_R4SimACDefinition@@6B@ ; SimACDefinition::`vftable'
	DD	FLAT:??_ESimACDefinition@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SimMoverDefinition@@6B@
CONST	SEGMENT
??_7SimMoverDefinition@@6B@ DD FLAT:??_R4SimMoverDefinition@@6B@ ; SimMoverDefinition::`vftable'
	DD	FLAT:??_ESimMoverDefinition@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0SimGroundDefinition@@QAE@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimGroundDefinition@@QAE@PAD@Z$0
__unwindtable$??0SimHeloDefinition@@QAE@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimHeloDefinition@@QAE@PAD@Z$0
__unwindtable$??0SimWpnDefinition@@QAE@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimWpnDefinition@@QAE@PAD@Z$0
__unwindtable$??0SimACDefinition@@QAE@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimACDefinition@@QAE@PAD@Z$0
__ehfuncinfo$??0SimGroundDefinition@@QAE@PAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SimGroundDefinition@@QAE@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SimHeloDefinition@@QAE@PAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SimHeloDefinition@@QAE@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SimWpnDefinition@@QAE@PAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SimWpnDefinition@@QAE@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0SimACDefinition@@QAE@PAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SimACDefinition@@QAE@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSimGroundDefinition@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSimGroundDefinition@@UAEPAXI@Z PROC			; SimGroundDefinition::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimGroundDefinition@@UAE@XZ		; SimGroundDefinition::~SimGroundDefinition
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSimGroundDefinition@@UAEPAXI@Z ENDP			; SimGroundDefinition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1SimGroundDefinition@@UAE@XZ PROC			; SimGroundDefinition::~SimGroundDefinition
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimGroundDefinition@@6B@

; 232  : 	#ifdef USE_SH_POOLS
; 233  : 	MemFreePtr( sensorData );
; 234  : 	#else
; 235  :    	delete [] sensorData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 236  : 	#endif
; 237  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
	mov	esp, ebp
	pop	ebp
	ret	0
??1SimGroundDefinition@@UAE@XZ ENDP			; SimGroundDefinition::~SimGroundDefinition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_gndFile$ = -24						; size = 4
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
??0SimGroundDefinition@@QAE@PAD@Z PROC			; SimGroundDefinition::SimGroundDefinition
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SimGroundDefinition@@QAE@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimMoverDefinition@@QAE@XZ		; SimMoverDefinition::SimMoverDefinition
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimGroundDefinition@@6B@

; 209  : int i;
; 210  : SimlibFileClass* gndFile;
; 211  : 
; 212  :    gndFile = SimlibFileClass::Open (fileName, SIMLIB_READ);

	push	4
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	?Open@SimlibFileClass@@SAPAV1@PADH@Z	; SimlibFileClass::Open
	add	esp, 8
	mov	DWORD PTR _gndFile$[ebp], eax

; 213  : 
; 214  :    numSensors  =  atoi(gndFile->GetNext());

	mov	ecx, DWORD PTR _gndFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 215  : 
; 216  : 	#ifdef USE_SH_POOLS
; 217  : 	sensorData = (int *)MemAllocPtr(gReadInMemPool, sizeof(int)*numSensors * 2,0);
; 218  : 	#else
; 219  :     sensorData = new int [numSensors * 2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+8], ecx

; 220  : 	#endif
; 221  :    for (i=0; i<numSensors; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SimGroundD
$LN2@SimGroundD:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@SimGroundD:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@SimGroundD

; 222  :    {
; 223  :       sensorData[i * 2]  =  atoi(gndFile->GetNext());

	mov	ecx, DWORD PTR _gndFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4], eax

; 224  :       sensorData[i * 2 + 1]  =  atoi(gndFile->GetNext());

	mov	ecx, DWORD PTR _gndFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 225  :    }

	jmp	SHORT $LN2@SimGroundD
$LN1@SimGroundD:

; 226  : 	gndFile->Close();

	mov	ecx, DWORD PTR _gndFile$[ebp]
	call	?Close@SimlibFileClass@@QAEHXZ		; SimlibFileClass::Close

; 227  :    delete gndFile;

	mov	edx, DWORD PTR _gndFile$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 228  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SimGroundDefinition@@QAE@PAD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
__ehhandler$??0SimGroundDefinition@@QAE@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SimGroundDefinition@@QAE@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SimGroundDefinition@@QAE@PAD@Z ENDP			; SimGroundDefinition::SimGroundDefinition
; Function compile flags: /Odtp
;	COMDAT ??_GSimHeloDefinition@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSimHeloDefinition@@UAEPAXI@Z PROC			; SimHeloDefinition::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimHeloDefinition@@UAE@XZ		; SimHeloDefinition::~SimHeloDefinition
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSimHeloDefinition@@UAEPAXI@Z ENDP			; SimHeloDefinition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1SimHeloDefinition@@UAE@XZ PROC			; SimHeloDefinition::~SimHeloDefinition
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimHeloDefinition@@6B@

; 200  : 	#ifdef USE_SH_POOLS
; 201  : 	MemFreePtr( sensorData );
; 202  : 	#else
; 203  :    	delete [] sensorData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 204  : 	#endif
; 205  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
	mov	esp, ebp
	pop	ebp
	ret	0
??1SimHeloDefinition@@UAE@XZ ENDP			; SimHeloDefinition::~SimHeloDefinition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_i$ = -24						; size = 4
_heloFile$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
??0SimHeloDefinition@@QAE@PAD@Z PROC			; SimHeloDefinition::SimHeloDefinition
; _this$ = ecx

; 175  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SimHeloDefinition@@QAE@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimMoverDefinition@@QAE@XZ		; SimMoverDefinition::SimMoverDefinition
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimHeloDefinition@@6B@

; 176  : int i;
; 177  : SimlibFileClass* heloFile;
; 178  : 
; 179  :    heloFile = SimlibFileClass::Open (fileName, SIMLIB_READ);

	push	4
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	?Open@SimlibFileClass@@SAPAV1@PADH@Z	; SimlibFileClass::Open
	add	esp, 8
	mov	DWORD PTR _heloFile$[ebp], eax

; 180  : 
; 181  :    airframeIndex = atoi(heloFile->GetNext());

	mov	ecx, DWORD PTR _heloFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 182  :    numSensors  =  atoi(heloFile->GetNext());

	mov	ecx, DWORD PTR _heloFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 183  : 
; 184  : 	#ifdef USE_SH_POOLS
; 185  : 	sensorData = (int *)MemAllocPtr(gReadInMemPool, sizeof(int)*numSensors * 2,0);
; 186  : 	#else
; 187  :     sensorData = new int [numSensors * 2];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+8], ecx

; 188  : 	#endif
; 189  :    for (i=0; i<numSensors; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SimHeloDef
$LN2@SimHeloDef:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@SimHeloDef:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@SimHeloDef

; 190  :    {
; 191  :       sensorData[i * 2]  =  atoi(heloFile->GetNext());

	mov	ecx, DWORD PTR _heloFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4], eax

; 192  :       sensorData[i * 2 + 1]  =  atoi(heloFile->GetNext());

	mov	ecx, DWORD PTR _heloFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 193  :    }

	jmp	SHORT $LN2@SimHeloDef
$LN1@SimHeloDef:

; 194  : 	heloFile->Close();

	mov	ecx, DWORD PTR _heloFile$[ebp]
	call	?Close@SimlibFileClass@@QAEHXZ		; SimlibFileClass::Close

; 195  :    delete heloFile;

	mov	edx, DWORD PTR _heloFile$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 196  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SimHeloDefinition@@QAE@PAD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
__ehhandler$??0SimHeloDefinition@@QAE@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SimHeloDefinition@@QAE@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SimHeloDefinition@@QAE@PAD@Z ENDP			; SimHeloDefinition::SimHeloDefinition
; Function compile flags: /Odtp
;	COMDAT ??_GSimWpnDefinition@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSimWpnDefinition@@UAEPAXI@Z PROC			; SimWpnDefinition::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimWpnDefinition@@UAE@XZ		; SimWpnDefinition::~SimWpnDefinition
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSimWpnDefinition@@UAEPAXI@Z ENDP			; SimWpnDefinition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SimWpnDefinition@@UAE@XZ PROC			; SimWpnDefinition::~SimWpnDefinition
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimWpnDefinition@@6B@

; 172  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
	mov	esp, ebp
	pop	ebp
	ret	0
??1SimWpnDefinition@@UAE@XZ ENDP			; SimWpnDefinition::~SimWpnDefinition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T2 = -24						; size = 4
_wpnFile$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
??0SimWpnDefinition@@QAE@PAD@Z PROC			; SimWpnDefinition::SimWpnDefinition
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SimWpnDefinition@@QAE@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimMoverDefinition@@QAE@XZ		; SimMoverDefinition::SimMoverDefinition
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimWpnDefinition@@6B@

; 149  : SimlibFileClass* wpnFile;
; 150  : 
; 151  :    wpnFile = SimlibFileClass::Open (fileName, SIMLIB_READ);

	push	4
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	?Open@SimlibFileClass@@SAPAV1@PADH@Z	; SimlibFileClass::Open
	add	esp, 8
	mov	DWORD PTR _wpnFile$[ebp], eax

; 152  : 
; 153  :    flags = atoi(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 154  :    cd  = (float)atof(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atof
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+16]

; 155  :    weight = (float)atof(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+20]

; 156  :    area  = (float)atof(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atof
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 157  :    xEjection  = (float)atof(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atof
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 158  :    yEjection  = (float)atof(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]

; 159  :    zEjection  = (float)atof(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atof
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+36]

; 160  :    strcpy (mnemonic, wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	_strcpy
	add	esp, 8

; 161  :    weaponClass  = atoi(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 162  :    domain  = atoi(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax

; 163  :    weaponType  = atoi(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 164  :    dataIdx  = atoi(wpnFile->GetNext());

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], eax

; 165  : 
; 166  :    wpnFile->Close();

	mov	ecx, DWORD PTR _wpnFile$[ebp]
	call	?Close@SimlibFileClass@@QAEHXZ		; SimlibFileClass::Close

; 167  :    delete wpnFile;

	mov	eax, DWORD PTR _wpnFile$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 168  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SimWpnDefinition@@QAE@PAD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
__ehhandler$??0SimWpnDefinition@@QAE@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SimWpnDefinition@@QAE@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SimWpnDefinition@@QAE@PAD@Z ENDP			; SimWpnDefinition::SimWpnDefinition
; Function compile flags: /Odtp
;	COMDAT ??_GSimACDefinition@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSimACDefinition@@UAEPAXI@Z PROC			; SimACDefinition::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimACDefinition@@UAE@XZ		; SimACDefinition::~SimACDefinition
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSimACDefinition@@UAEPAXI@Z ENDP			; SimACDefinition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1SimACDefinition@@UAE@XZ PROC				; SimACDefinition::~SimACDefinition
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimACDefinition@@6B@

; 138  : 	#ifdef USE_SH_POOLS
; 139  : 	MemFreePtr( sensorData );
; 140  : 	MemFreePtr( playerSensorData );
; 141  : 	#else
; 142  :    	delete [] sensorData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 143  :    	delete [] playerSensorData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 144  : 	#endif
; 145  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
	mov	esp, ebp
	pop	ebp
	ret	0
??1SimACDefinition@@UAE@XZ ENDP				; SimACDefinition::~SimACDefinition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
_acFile$ = -24						; size = 4
_i$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fileName$ = 8						; size = 4
??0SimACDefinition@@QAE@PAD@Z PROC			; SimACDefinition::SimACDefinition
; _this$ = ecx

; 96   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SimACDefinition@@QAE@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimMoverDefinition@@QAE@XZ		; SimMoverDefinition::SimMoverDefinition
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimACDefinition@@6B@

; 97   : int i;
; 98   : SimlibFileClass* acFile;
; 99   : 
; 100  :    acFile = SimlibFileClass::Open (fileName, SIMLIB_READ);

	push	4
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	?Open@SimlibFileClass@@SAPAV1@PADH@Z	; SimlibFileClass::Open
	add	esp, 8
	mov	DWORD PTR _acFile$[ebp], eax

; 101  : 
; 102  :    // What type of combat does it do?
; 103  :    combatClass = (CombatClass)atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 104  : 
; 105  :    airframeIndex = atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 106  :    numPlayerSensors  =  atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], eax

; 107  : 
; 108  : 	#ifdef USE_SH_POOLS
; 109  : 	playerSensorData = (int *)MemAllocPtr(gReadInMemPool, sizeof(int)*numPlayerSensors * 2,0);
; 110  : 	#else
; 111  :     playerSensorData = new int [numPlayerSensors * 2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [eax+24], ecx

; 112  : 	#endif
; 113  :    for (i=0; i<numPlayerSensors; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SimACDefin
$LN5@SimACDefin:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@SimACDefin:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	SHORT $LN4@SimACDefin

; 114  :    {
; 115  :       playerSensorData[i * 2]  =  atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+edx*4], eax

; 116  :       playerSensorData[i * 2 + 1]  =  atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 117  :    }

	jmp	SHORT $LN5@SimACDefin
$LN4@SimACDefin:

; 118  : 
; 119  :    numSensors  =  atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 120  : 
; 121  : 	#ifdef USE_SH_POOLS
; 122  : 	sensorData = (int *)MemAllocPtr(gReadInMemPool, sizeof(int)*numSensors * 2,0);
; 123  : 	#else
; 124  :     sensorData = new int [numSensors * 2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+8], ecx

; 125  : 	#endif
; 126  :    for (i=0; i<numSensors; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SimACDefin
$LN2@SimACDefin:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@SimACDefin:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@SimACDefin

; 127  :    {
; 128  :       sensorData[i * 2]  =  atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4], eax

; 129  :       sensorData[i * 2 + 1]  =  atoi(acFile->GetNext());

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 130  :    }

	jmp	SHORT $LN2@SimACDefin
$LN1@SimACDefin:

; 131  : 
; 132  : 	acFile->Close();

	mov	ecx, DWORD PTR _acFile$[ebp]
	call	?Close@SimlibFileClass@@QAEHXZ		; SimlibFileClass::Close

; 133  :    delete acFile;

	mov	edx, DWORD PTR _acFile$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 134  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SimACDefinition@@QAE@PAD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
__ehhandler$??0SimACDefinition@@QAE@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SimACDefinition@@QAE@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SimACDefinition@@QAE@PAD@Z ENDP			; SimACDefinition::SimACDefinition
; Function compile flags: /Odtp
;	COMDAT ??_GSimMoverDefinition@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSimMoverDefinition@@UAEPAXI@Z PROC			; SimMoverDefinition::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimMoverDefinition@@UAE@XZ		; SimMoverDefinition::~SimMoverDefinition
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSimMoverDefinition@@UAEPAXI@Z ENDP			; SimMoverDefinition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv74 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_i$ = -4						; size = 4
?FreeSimMoverDefinitionData@SimMoverDefinition@@SAXXZ PROC ; SimMoverDefinition::FreeSimMoverDefinitionData

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 81   : int i;
; 82   : 
; 83   : 	for (i=0; i<NumSimMoverDefinitions; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@FreeSimMov
$LN2@FreeSimMov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@FreeSimMov:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?NumSimMoverDefinitions@@3HA ; NumSimMoverDefinitions
	jge	SHORT $LN1@FreeSimMov

; 84   : 	{
; 85   :       delete moverDefinitionData[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@FreeSimMov
	push	1
	mov	eax, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN7@FreeSimMov
$LN6@FreeSimMov:
	mov	DWORD PTR tv74[ebp], 0
$LN7@FreeSimMov:

; 86   :    }

	jmp	SHORT $LN2@FreeSimMov
$LN1@FreeSimMov:

; 87   : 
; 88   : 	#ifdef USE_SH_POOLS
; 89   : 	MemFreePtr( moverDefinitionData );
; 90   : 	#else
; 91   :     delete [] moverDefinitionData;

	mov	ecx, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 92   : 	#endif
; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FreeSimMoverDefinitionData@SimMoverDefinition@@SAXXZ ENDP ; SimMoverDefinition::FreeSimMoverDefinitionData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
$T5 = -96						; size = 4
$T6 = -92						; size = 4
$T7 = -88						; size = 4
$T8 = -84						; size = 4
_vehicleType$ = -80					; size = 4
$T9 = -76						; size = 4
tv201 = -72						; size = 4
$T10 = -68						; size = 4
tv191 = -64						; size = 4
$T11 = -60						; size = 4
tv180 = -56						; size = 4
$T12 = -52						; size = 4
tv164 = -48						; size = 4
$T13 = -44						; size = 4
tv148 = -40						; size = 4
$T14 = -36						; size = 4
tv132 = -32						; size = 4
$T15 = -28						; size = 4
tv84 = -24						; size = 4
_i$ = -20						; size = 4
_vehList$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ PROC ; SimMoverDefinition::ReadSimMoverDefinitionData

; 29   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 30   : 	int i;
; 31   : 	SimlibFileClass* vehList;
; 32   : 	int vehicleType;
; 33   : 
; 34   : 	vehList = SimlibFileClass::Open(SIM_VEHICLE_DEFINITION_FILE, SIMLIB_READ);

	push	4
	push	OFFSET ??_C@_0BH@FEDHPIGL@sim?2vehdef?2vehicle?4lst?$AA@
	call	?Open@SimlibFileClass@@SAPAV1@PADH@Z	; SimlibFileClass::Open
	add	esp, 8
	mov	DWORD PTR _vehList$[ebp], eax

; 35   : 
; 36   : 	NumSimMoverDefinitions = atoi (vehList->GetNext());

	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR ?NumSimMoverDefinitions@@3HA, eax ; NumSimMoverDefinitions

; 37   : 	#ifdef USE_SH_POOLS
; 38   : 	moverDefinitionData = (SimMoverDefinition **)MemAllocPtr(gReadInMemPool, sizeof(SimMoverDefinition*)*NumSimMoverDefinitions,0);
; 39   : 	#else
; 40   : 	moverDefinitionData = new SimMoverDefinition*[NumSimMoverDefinitions];

	xor	ecx, ecx
	mov	eax, DWORD PTR ?NumSimMoverDefinitions@@3HA ; NumSimMoverDefinitions
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A, eax ; moverDefinitionData

; 41   : 	#endif
; 42   : 
; 43   : 	for (i=0; i<NumSimMoverDefinitions; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@ReadSimMov
$LN10@ReadSimMov:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN11@ReadSimMov:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR ?NumSimMoverDefinitions@@3HA ; NumSimMoverDefinitions
	jge	$LN9@ReadSimMov

; 44   : 	{
; 45   :       vehicleType = atoi (vehList->GetNext());

	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _vehicleType$[ebp], eax

; 46   :       switch (vehicleType)

	mov	eax, DWORD PTR _vehicleType$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	cmp	DWORD PTR tv84[ebp], 4
	ja	$LN1@ReadSimMov
	mov	ecx, DWORD PTR tv84[ebp]
	jmp	DWORD PTR $LN33@ReadSimMov[ecx*4]
$LN6@ReadSimMov:

; 47   :       {
; 48   :          case Aircraft:
; 49   :             moverDefinitionData[i] = new SimACDefinition (vehList->GetNext());

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN14@ReadSimMov
	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	mov	ecx, DWORD PTR $T15[ebp]
	call	??0SimACDefinition@@QAE@PAD@Z		; SimACDefinition::SimACDefinition
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN15@ReadSimMov
$LN14@ReadSimMov:
	mov	DWORD PTR tv132[ebp], 0
$LN15@ReadSimMov:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 50   :          break;

	jmp	$LN7@ReadSimMov
$LN5@ReadSimMov:

; 51   :          
; 52   :          case Ground:
; 53   :             moverDefinitionData[i] = new SimGroundDefinition(vehList->GetNext());

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN16@ReadSimMov
	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0SimGroundDefinition@@QAE@PAD@Z	; SimGroundDefinition::SimGroundDefinition
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $LN17@ReadSimMov
$LN16@ReadSimMov:
	mov	DWORD PTR tv148[ebp], 0
$LN17@ReadSimMov:
	mov	eax, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 54   :          break;

	jmp	$LN7@ReadSimMov
$LN4@ReadSimMov:

; 55   :          
; 56   :          case Helicopter:
; 57   :             moverDefinitionData[i] = new SimHeloDefinition(vehList->GetNext());

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN18@ReadSimMov
	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0SimHeloDefinition@@QAE@PAD@Z		; SimHeloDefinition::SimHeloDefinition
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN19@ReadSimMov
$LN18@ReadSimMov:
	mov	DWORD PTR tv164[ebp], 0
$LN19@ReadSimMov:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 58   :          break;

	jmp	$LN7@ReadSimMov
$LN3@ReadSimMov:

; 59   :          
; 60   :          case Weapon:
; 61   :             moverDefinitionData[i] = new SimWpnDefinition (vehList->GetNext());

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN20@ReadSimMov
	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext
	push	eax
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0SimWpnDefinition@@QAE@PAD@Z		; SimWpnDefinition::SimWpnDefinition
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN21@ReadSimMov
$LN20@ReadSimMov:
	mov	DWORD PTR tv180[ebp], 0
$LN21@ReadSimMov:
	mov	edx, DWORD PTR tv180[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 62   :          break;

	jmp	$LN7@ReadSimMov
$LN2@ReadSimMov:

; 63   :          
; 64   :          case Sea:
; 65   :             vehList->GetNext();

	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext

; 66   :             moverDefinitionData[i] = new SimMoverDefinition;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN22@ReadSimMov
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0SimMoverDefinition@@QAE@XZ		; SimMoverDefinition::SimMoverDefinition
	mov	DWORD PTR tv191[ebp], eax
	jmp	SHORT $LN23@ReadSimMov
$LN22@ReadSimMov:
	mov	DWORD PTR tv191[ebp], 0
$LN23@ReadSimMov:
	mov	eax, DWORD PTR tv191[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 67   :          break;

	jmp	SHORT $LN7@ReadSimMov
$LN1@ReadSimMov:

; 68   : 
; 69   :          default:
; 70   :             vehList->GetNext();

	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?GetNext@SimlibFileClass@@QAEPADXZ	; SimlibFileClass::GetNext

; 71   :             moverDefinitionData[i] = new SimMoverDefinition;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN24@ReadSimMov
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0SimMoverDefinition@@QAE@XZ		; SimMoverDefinition::SimMoverDefinition
	mov	DWORD PTR tv201[ebp], eax
	jmp	SHORT $LN25@ReadSimMov
$LN24@ReadSimMov:
	mov	DWORD PTR tv201[ebp], 0
$LN25@ReadSimMov:
	mov	ecx, DWORD PTR tv201[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?moverDefinitionData@@3PAPAVSimMoverDefinition@@A ; moverDefinitionData
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN7@ReadSimMov:

; 72   :          break;
; 73   :       }
; 74   : 	}

	jmp	$LN10@ReadSimMov
$LN9@ReadSimMov:

; 75   : 	vehList->Close();

	mov	ecx, DWORD PTR _vehList$[ebp]
	call	?Close@SimlibFileClass@@QAEHXZ		; SimlibFileClass::Close

; 76   :    delete vehList;

	mov	edx, DWORD PTR _vehList$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 77   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN33@ReadSimMov:
	DD	$LN6@ReadSimMov
	DD	$LN5@ReadSimMov
	DD	$LN4@ReadSimMov
	DD	$LN3@ReadSimMov
	DD	$LN2@ReadSimMov
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$0:
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$1:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$2:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$3:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$4:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ$5:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadSimMoverDefinitionData@SimMoverDefinition@@SAXXZ ENDP ; SimMoverDefinition::ReadSimMoverDefinitionData
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SimMoverDefinition@@UAE@XZ PROC			; SimMoverDefinition::~SimMoverDefinition
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimMoverDefinition@@6B@

; 26   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1SimMoverDefinition@@UAE@XZ ENDP			; SimMoverDefinition::~SimMoverDefinition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\vehdef.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SimMoverDefinition@@QAE@XZ PROC			; SimMoverDefinition::SimMoverDefinition
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SimMoverDefinition@@6B@

; 20   :    numSensors = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 21   :    sensorData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 22   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SimMoverDefinition@@QAE@XZ ENDP			; SimMoverDefinition::SimMoverDefinition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
