; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\SIMLIB\Math.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?Math@@3VSIMLIB_MATH_CLASS@@A			; Math
PUBLIC	?SimLibErrno@@3HA				; SimLibErrno
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?Math@@3VSIMLIB_MATH_CLASS@@A DB 01H DUP (?)		; Math
	ALIGN	4

?SimLibErrno@@3HA DD 01H DUP (?)			; SimLibErrno
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_cosf
PUBLIC	_expf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?exp@@YAMM@Z					; exp
PUBLIC	?Limit@SIMLIB_MATH_CLASS@@QAEFFFF@Z		; SIMLIB_MATH_CLASS::Limit
PUBLIC	?Limit@SIMLIB_MATH_CLASS@@QAEHHHH@Z		; SIMLIB_MATH_CLASS::Limit
PUBLIC	?Limit@SIMLIB_MATH_CLASS@@QAEJJJJ@Z		; SIMLIB_MATH_CLASS::Limit
PUBLIC	?Limit@SIMLIB_MATH_CLASS@@QAEMMMM@Z		; SIMLIB_MATH_CLASS::Limit
PUBLIC	?RateLimit@SIMLIB_MATH_CLASS@@QAEMMMMPAMM@Z	; SIMLIB_MATH_CLASS::RateLimit
PUBLIC	?DeadBand@SIMLIB_MATH_CLASS@@QAEMMMM@Z		; SIMLIB_MATH_CLASS::DeadBand
PUBLIC	?Resolve@SIMLIB_MATH_CLASS@@QAEMMM@Z		; SIMLIB_MATH_CLASS::Resolve
PUBLIC	?Resolve0@SIMLIB_MATH_CLASS@@QAEMMM@Z		; SIMLIB_MATH_CLASS::Resolve0
PUBLIC	?ResolveWrap@SIMLIB_MATH_CLASS@@QAEMMM@Z	; SIMLIB_MATH_CLASS::ResolveWrap
PUBLIC	?Limit@SIMLIB_MATH_CLASS@@QAENNNN@Z		; SIMLIB_MATH_CLASS::Limit
PUBLIC	?RateLimit@SIMLIB_MATH_CLASS@@QAENNNNPANN@Z	; SIMLIB_MATH_CLASS::RateLimit
PUBLIC	?DeadBand@SIMLIB_MATH_CLASS@@QAENNNN@Z		; SIMLIB_MATH_CLASS::DeadBand
PUBLIC	?Resolve@SIMLIB_MATH_CLASS@@QAENNN@Z		; SIMLIB_MATH_CLASS::Resolve
PUBLIC	?Resolve0@SIMLIB_MATH_CLASS@@QAENNN@Z		; SIMLIB_MATH_CLASS::Resolve0
PUBLIC	?ResolveWrap@SIMLIB_MATH_CLASS@@QAENNN@Z	; SIMLIB_MATH_CLASS::ResolveWrap
PUBLIC	?F1Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMMQAMPAH@Z	; SIMLIB_MATH_CLASS::F1Tust
PUBLIC	?F2Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAM@Z	; SIMLIB_MATH_CLASS::F2Tust
PUBLIC	?F3Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAM@Z	; SIMLIB_MATH_CLASS::F3Tust
PUBLIC	?F4Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z	; SIMLIB_MATH_CLASS::F4Tust
PUBLIC	?F5Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z	; SIMLIB_MATH_CLASS::F5Tust
PUBLIC	?F6Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAMPAH@Z	; SIMLIB_MATH_CLASS::F6Tust
PUBLIC	?F7Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z	; SIMLIB_MATH_CLASS::F7Tust
PUBLIC	?F8Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z	; SIMLIB_MATH_CLASS::F8Tust
PUBLIC	?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z		; SIMLIB_MATH_CLASS::FLTust
PUBLIC	?FLeadTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z	; SIMLIB_MATH_CLASS::FLeadTust
PUBLIC	?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z		; SIMLIB_MATH_CLASS::FITust
PUBLIC	?FWTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z		; SIMLIB_MATH_CLASS::FWTust
PUBLIC	?FIAdamsBash@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z	; SIMLIB_MATH_CLASS::FIAdamsBash
PUBLIC	?OnedInterp@SIMLIB_MATH_CLASS@@QAEMMPBM0HPAH@Z	; SIMLIB_MATH_CLASS::OnedInterp
PUBLIC	?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ; SIMLIB_MATH_CLASS::TwodInterp
PUBLIC	?ThreedInterp@SIMLIB_MATH_CLASS@@QAEMMMMPBM000HHHPAH11@Z ; SIMLIB_MATH_CLASS::ThreedInterp
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@bf000000
PUBLIC	__real@c0000000
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_cos:PROC
EXTRN	_exp:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -180						; size = 4
_ymax$ = -176						; size = 4
_interp$ = -172						; size = 4
tv86 = -168						; size = 4
_de$ = -164						; size = 4
tv92 = -160						; size = 4
_e2$ = -156						; size = 4
tv160 = -152						; size = 4
tv166 = -148						; size = 4
tv95 = -144						; size = 4
_zmax$ = -140						; size = 4
tv90 = -136						; size = 4
tv165 = -132						; size = 4
tv89 = -128						; size = 4
tv162 = -124						; size = 4
_xmax$ = -120						; size = 4
_e1$ = -116						; size = 4
_ymin$ = -112						; size = 4
_dz$ = -108						; size = 4
_index1$ = -104						; size = 4
_dd$ = -100						; size = 4
_xmin$ = -96						; size = 4
_d2$ = -92						; size = 4
_zmin$ = -88						; size = 4
_dd2$ = -84						; size = 4
_dd1$ = -80						; size = 4
_index3$ = -76						; size = 4
_dy$ = -72						; size = 4
_y2$ = -68						; size = 4
_z2$ = -64						; size = 4
_x2$ = -60						; size = 4
_index2$ = -56						; size = 4
_index4$ = -52						; size = 4
_d1$ = -48						; size = 4
_z1$ = -44						; size = 4
_y1$ = -40						; size = 4
_dx$ = -36						; size = 4
_x1$ = -32						; size = 4
_zinpt$ = -28						; size = 4
_iz$ = -24						; size = 4
_ix$ = -20						; size = 4
_yinpt$ = -16						; size = 4
_iy$ = -12						; size = 4
_xinpt$ = -8						; size = 4
_i$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_xarray$ = 20						; size = 4
_yarray$ = 24						; size = 4
_zarray$ = 28						; size = 4
_data$ = 32						; size = 4
_numx$ = 36						; size = 4
_numy$ = 40						; size = 4
_numz$ = 44						; size = 4
_lastx$ = 48						; size = 4
_lasty$ = 52						; size = 4
_lastz$ = 56						; size = 4
?ThreedInterp@SIMLIB_MATH_CLASS@@QAEMMMMPBM000HHHPAH11@Z PROC ; SIMLIB_MATH_CLASS::ThreedInterp
; _this$ = ecx

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1647 : float xmin,xmax, ymin,ymax, zmin,zmax;
; 1648 : float xinpt=0.0F, yinpt=0.0F, zinpt=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _xinpt$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _yinpt$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _zinpt$[ebp], xmm0

; 1649 : float d1=0.0F,d2=0.0F,dd1=0.0F,dd2=0.0F,dd=0.0F,de=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _d1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _d2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dd1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dd2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dd$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _de$[ebp], xmm0

; 1650 : float e1=0.0F,e2=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _e1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _e2$[ebp], xmm0

; 1651 : float x1=static_cast<float>(*lastx), x2=static_cast<float>(*lastx), dx=0.0F;

	mov	eax, DWORD PTR _lastx$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	movss	DWORD PTR _x1$[ebp], xmm0
	mov	ecx, DWORD PTR _lastx$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _x2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0

; 1652 : float y1=static_cast<float>(*lasty), y2=static_cast<float>(*lasty), dy=0.0F;

	mov	edx, DWORD PTR _lasty$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx]
	movss	DWORD PTR _y1$[ebp], xmm0
	mov	eax, DWORD PTR _lasty$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	movss	DWORD PTR _y2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 1653 : float z1=static_cast<float>(*lastz), z2=static_cast<float>(*lastz), dz=0.0F;

	mov	ecx, DWORD PTR _lastz$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	movss	DWORD PTR _z1$[ebp], xmm0
	mov	edx, DWORD PTR _lastz$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx]
	movss	DWORD PTR _z2$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dz$[ebp], xmm0

; 1654 : float interp=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _interp$[ebp], xmm0

; 1655 : int i=0, ix=0, iy=0, iz=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _ix$[ebp], 0
	mov	DWORD PTR _iy$[ebp], 0
	mov	DWORD PTR _iz$[ebp], 0

; 1656 : int index1=0, index2=0;

	mov	DWORD PTR _index1$[ebp], 0
	mov	DWORD PTR _index2$[ebp], 0

; 1657 : int index3=0, index4=0;

	mov	DWORD PTR _index3$[ebp], 0
	mov	DWORD PTR _index4$[ebp], 0

; 1658 : 
; 1659 :    xmax = xarray[numx - 1];

	mov	eax, DWORD PTR _numx$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	movss	DWORD PTR _xmax$[ebp], xmm0

; 1660 :    xmin = xarray[   0];

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _xmin$[ebp], xmm0

; 1661 :    ymax = yarray[numy - 1];

	mov	ecx, DWORD PTR _numy$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4-4]
	movss	DWORD PTR _ymax$[ebp], xmm0

; 1662 :    ymin = yarray[   0];

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _ymin$[ebp], xmm0

; 1663 :    zmax = zarray[numz - 1];

	mov	edx, DWORD PTR _numz$[ebp]
	mov	eax, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4-4]
	movss	DWORD PTR _zmax$[ebp], xmm0

; 1664 :    zmin = zarray[   0];

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _zmin$[ebp], xmm0

; 1665 : 
; 1666 :    /*-------------------------------------------------*/
; 1667 :    /* LIMIT INDEPENDENT VARIABLES TO TABLE BOUNDARIES */
; 1668 :    /*-------------------------------------------------*/
; 1669 : 	xinpt = min ( max (x, xmin), xmax);

	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR _xmin$[ebp]
	jbe	SHORT $LN60@ThreedInte
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN61@ThreedInte
$LN60@ThreedInte:
	movss	xmm0, DWORD PTR _xmin$[ebp]
	movss	DWORD PTR tv86[ebp], xmm0
$LN61@ThreedInte:
	movss	xmm0, DWORD PTR _xmax$[ebp]
	comiss	xmm0, DWORD PTR tv86[ebp]
	jbe	SHORT $LN64@ThreedInte
	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR _xmin$[ebp]
	jbe	SHORT $LN62@ThreedInte
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN63@ThreedInte
$LN62@ThreedInte:
	movss	xmm0, DWORD PTR _xmin$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
$LN63@ThreedInte:
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN65@ThreedInte
$LN64@ThreedInte:
	movss	xmm0, DWORD PTR _xmax$[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
$LN65@ThreedInte:
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _xinpt$[ebp], xmm0

; 1670 : 	yinpt = min ( max (y, ymin), ymax);

	movss	xmm0, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR _ymin$[ebp]
	jbe	SHORT $LN66@ThreedInte
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN67@ThreedInte
$LN66@ThreedInte:
	movss	xmm0, DWORD PTR _ymin$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
$LN67@ThreedInte:
	movss	xmm0, DWORD PTR _ymax$[ebp]
	comiss	xmm0, DWORD PTR tv92[ebp]
	jbe	SHORT $LN70@ThreedInte
	movss	xmm0, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR _ymin$[ebp]
	jbe	SHORT $LN68@ThreedInte
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN69@ThreedInte
$LN68@ThreedInte:
	movss	xmm0, DWORD PTR _ymin$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
$LN69@ThreedInte:
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR tv160[ebp], xmm0
	jmp	SHORT $LN71@ThreedInte
$LN70@ThreedInte:
	movss	xmm0, DWORD PTR _ymax$[ebp]
	movss	DWORD PTR tv160[ebp], xmm0
$LN71@ThreedInte:
	movss	xmm0, DWORD PTR tv160[ebp]
	movss	DWORD PTR _yinpt$[ebp], xmm0

; 1671 : 	zinpt = min ( max (z, zmin), zmax);

	movss	xmm0, DWORD PTR _z$[ebp]
	comiss	xmm0, DWORD PTR _zmin$[ebp]
	jbe	SHORT $LN72@ThreedInte
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN73@ThreedInte
$LN72@ThreedInte:
	movss	xmm0, DWORD PTR _zmin$[ebp]
	movss	DWORD PTR tv162[ebp], xmm0
$LN73@ThreedInte:
	movss	xmm0, DWORD PTR _zmax$[ebp]
	comiss	xmm0, DWORD PTR tv162[ebp]
	jbe	SHORT $LN76@ThreedInte
	movss	xmm0, DWORD PTR _z$[ebp]
	comiss	xmm0, DWORD PTR _zmin$[ebp]
	jbe	SHORT $LN74@ThreedInte
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN75@ThreedInte
$LN74@ThreedInte:
	movss	xmm0, DWORD PTR _zmin$[ebp]
	movss	DWORD PTR tv165[ebp], xmm0
$LN75@ThreedInte:
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR tv166[ebp], xmm0
	jmp	SHORT $LN77@ThreedInte
$LN76@ThreedInte:
	movss	xmm0, DWORD PTR _zmax$[ebp]
	movss	DWORD PTR tv166[ebp], xmm0
$LN77@ThreedInte:
	movss	xmm0, DWORD PTR tv166[ebp]
	movss	DWORD PTR _zinpt$[ebp], xmm0

; 1672 : 
; 1673 :    /*-------------------------------------------------*/
; 1674 :    /* If there is a last x use it as a starting point */
; 1675 :    /*-------------------------------------------------*/
; 1676 :    if (*lastx != 0)

	mov	eax, DWORD PTR _lastx$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN57@ThreedInte

; 1677 :    {
; 1678 :       if (xinpt >= xarray[*lastx] && xinpt <= xarray[*lastx + 1])

	mov	ecx, DWORD PTR _lastx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4]
	jb	SHORT $LN56@ThreedInte
	mov	ecx, DWORD PTR _lastx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN56@ThreedInte

; 1679 :       {
; 1680 :          ix = *lastx;

	mov	ecx, DWORD PTR _lastx$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ix$[ebp], edx

; 1681 :          x1 = xarray[*lastx];

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _x1$[ebp], xmm0

; 1682 :          x2 = xarray[*lastx+1];

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _x2$[ebp], xmm0
	jmp	$LN46@ThreedInte
$LN56@ThreedInte:

; 1683 :       }
; 1684 :       else if ( xinpt <= xarray[*lastx])

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN54@ThreedInte

; 1685 :       {
; 1686 :          /*-----------------------*/
; 1687 :          /* Look down in the data */
; 1688 :          /*-----------------------*/
; 1689 :          for (i= *lastx; i>0; i--)

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN53@ThreedInte
$LN52@ThreedInte:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN53@ThreedInte:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN51@ThreedInte

; 1690 :          {
; 1691 :             if (xinpt <= xarray[i] && xinpt >= xarray[i-1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN50@ThreedInte
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4-4]
	jb	SHORT $LN50@ThreedInte

; 1692 :             {
; 1693 :                *lastx = i-1;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _lastx$[ebp]
	mov	DWORD PTR [edx], ecx

; 1694 :                ix = i-1;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ix$[ebp], eax

; 1695 :                x1 = xarray[i-1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4-4]
	movss	DWORD PTR _x1$[ebp], xmm0

; 1696 :                x2 = xarray[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1697 :                break;

	jmp	SHORT $LN51@ThreedInte
$LN50@ThreedInte:

; 1698 :             }
; 1699 :          }

	jmp	SHORT $LN52@ThreedInte
$LN51@ThreedInte:

; 1700 :       }
; 1701 :       else

	jmp	SHORT $LN46@ThreedInte
$LN54@ThreedInte:

; 1702 :       {
; 1703 :          for (i= *lastx+1; i< numx-1; i++)

	mov	edx, DWORD PTR _lastx$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN48@ThreedInte
$LN47@ThreedInte:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN48@ThreedInte:
	mov	edx, DWORD PTR _numx$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN46@ThreedInte

; 1704 :          {
; 1705 :             if (xinpt >= xarray[i] && xinpt <= xarray[i+1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jb	SHORT $LN45@ThreedInte
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN45@ThreedInte

; 1706 :             {
; 1707 :                *lastx = i;

	mov	ecx, DWORD PTR _lastx$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx

; 1708 :                ix = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _ix$[ebp], eax

; 1709 :                x1 = xarray[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _x1$[ebp], xmm0

; 1710 :                x2 = xarray[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1711 :                break;

	jmp	SHORT $LN46@ThreedInte
$LN45@ThreedInte:

; 1712 :             }
; 1713 :          }

	jmp	SHORT $LN47@ThreedInte
$LN46@ThreedInte:

; 1714 :       }
; 1715 :    }
; 1716 :    else

	jmp	SHORT $LN41@ThreedInte
$LN57@ThreedInte:

; 1717 :    {
; 1718 :       /*--------------------------------------------*/
; 1719 :       /* No Previous value so start at the begining */
; 1720 :       /*--------------------------------------------*/
; 1721 :       for (i=0; i<numx - 1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN43@ThreedInte
$LN42@ThreedInte:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN43@ThreedInte:
	mov	eax, DWORD PTR _numx$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN41@ThreedInte

; 1722 :       {
; 1723 :          if (xinpt >= xarray[i] && xinpt <= xarray[i+1])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jb	SHORT $LN40@ThreedInte
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN40@ThreedInte

; 1724 :          {
; 1725 :             *lastx = i;

	mov	edx, DWORD PTR _lastx$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 1726 :             ix = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _ix$[ebp], ecx

; 1727 :             x1 = xarray[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _x1$[ebp], xmm0

; 1728 :             x2 = xarray[i+1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1729 :             break;

	jmp	SHORT $LN41@ThreedInte
$LN40@ThreedInte:

; 1730 :          }
; 1731 :       }

	jmp	SHORT $LN42@ThreedInte
$LN41@ThreedInte:

; 1732 : 
; 1733 :    }
; 1734 :    dx = x2 - x1;

	movss	xmm0, DWORD PTR _x2$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1735 :    if(!dx) dx =1;//me123 incase theres only one number in the dat file

	movss	xmm0, DWORD PTR _dx$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN39@ThreedInte
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dx$[ebp], xmm0
$LN39@ThreedInte:

; 1736 : 
; 1737 :    /*-------------------------------------------------*/
; 1738 :    /* If there is a last y use it as a starting point */
; 1739 :    /*-------------------------------------------------*/
; 1740 :    if (*lasty != 0)

	mov	eax, DWORD PTR _lasty$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN38@ThreedInte

; 1741 :    {
; 1742 :       if (yinpt >= yarray[*lasty] && yinpt <= yarray[*lasty + 1])

	mov	ecx, DWORD PTR _lasty$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4]
	jb	SHORT $LN37@ThreedInte
	mov	ecx, DWORD PTR _lasty$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jb	SHORT $LN37@ThreedInte

; 1743 :       {
; 1744 :          iy = *lasty;

	mov	ecx, DWORD PTR _lasty$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iy$[ebp], edx

; 1745 :          y1 = yarray[*lasty];

	mov	eax, DWORD PTR _lasty$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _y1$[ebp], xmm0

; 1746 :          y2 = yarray[*lasty+1];

	mov	eax, DWORD PTR _lasty$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _y2$[ebp], xmm0
	jmp	$LN27@ThreedInte
$LN37@ThreedInte:

; 1747 :       }
; 1748 :       else if ( yinpt <= yarray[*lasty])

	mov	eax, DWORD PTR _lasty$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jb	SHORT $LN35@ThreedInte

; 1749 :       {
; 1750 :          /*-----------------------*/
; 1751 :          /* Look down in the data */
; 1752 :          /*-----------------------*/
; 1753 :          for (i= *lasty; i>0; i--)

	mov	eax, DWORD PTR _lasty$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN34@ThreedInte
$LN33@ThreedInte:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN34@ThreedInte:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN32@ThreedInte

; 1754 :          {
; 1755 :             if (yinpt <= yarray[i] && yinpt >= yarray[i-1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jb	SHORT $LN31@ThreedInte
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4-4]
	jb	SHORT $LN31@ThreedInte

; 1756 :             {
; 1757 :                *lasty = i-1;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _lasty$[ebp]
	mov	DWORD PTR [edx], ecx

; 1758 :                iy = i-1;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iy$[ebp], eax

; 1759 :                y1 = yarray[i-1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4-4]
	movss	DWORD PTR _y1$[ebp], xmm0

; 1760 :                y2 = yarray[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1761 :                break;

	jmp	SHORT $LN32@ThreedInte
$LN31@ThreedInte:

; 1762 :             }
; 1763 :          }

	jmp	SHORT $LN33@ThreedInte
$LN32@ThreedInte:

; 1764 :       }
; 1765 :       else

	jmp	SHORT $LN27@ThreedInte
$LN35@ThreedInte:

; 1766 :       {
; 1767 :          for (i= *lasty+1; i< numy-1; i++)

	mov	edx, DWORD PTR _lasty$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN29@ThreedInte
$LN28@ThreedInte:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN29@ThreedInte:
	mov	edx, DWORD PTR _numy$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN27@ThreedInte

; 1768 :          {
; 1769 :             if (yinpt >= yarray[i] && yinpt <= yarray[i+1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jb	SHORT $LN26@ThreedInte
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jb	SHORT $LN26@ThreedInte

; 1770 :             {
; 1771 :                *lasty = i;

	mov	ecx, DWORD PTR _lasty$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx

; 1772 :                iy = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iy$[ebp], eax

; 1773 :                y1 = yarray[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _y1$[ebp], xmm0

; 1774 :                y2 = yarray[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1775 :                break;

	jmp	SHORT $LN27@ThreedInte
$LN26@ThreedInte:

; 1776 :             }
; 1777 :          }

	jmp	SHORT $LN28@ThreedInte
$LN27@ThreedInte:

; 1778 :       }
; 1779 :    }
; 1780 :    else

	jmp	SHORT $LN22@ThreedInte
$LN38@ThreedInte:

; 1781 :    {
; 1782 :       /*--------------------------------------------*/
; 1783 :       /* No Previous value so start at the begining */
; 1784 :       /*--------------------------------------------*/
; 1785 :       for (i=0; i<numy - 1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN24@ThreedInte
$LN23@ThreedInte:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN24@ThreedInte:
	mov	eax, DWORD PTR _numy$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN22@ThreedInte

; 1786 :       {
; 1787 :          if (yinpt >= yarray[i] && yinpt <= yarray[i+1])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jb	SHORT $LN21@ThreedInte
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jb	SHORT $LN21@ThreedInte

; 1788 :          {
; 1789 :             *lasty = i;

	mov	edx, DWORD PTR _lasty$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 1790 :             iy = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iy$[ebp], ecx

; 1791 :             y1 = yarray[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _y1$[ebp], xmm0

; 1792 :             y2 = yarray[i+1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1793 :             break;

	jmp	SHORT $LN22@ThreedInte
$LN21@ThreedInte:

; 1794 :          }
; 1795 :       }

	jmp	SHORT $LN23@ThreedInte
$LN22@ThreedInte:

; 1796 : 
; 1797 :    }
; 1798 :    dy = y2 - y1;

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1799 :    if(!dy) dy =1;//me123 incase theres only one number in the dat file

	movss	xmm0, DWORD PTR _dy$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@ThreedInte
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dy$[ebp], xmm0
$LN20@ThreedInte:

; 1800 :  
; 1801 :    /*-------------------------------------------------*/
; 1802 :    /* If there is a last z use it as a starting point */
; 1803 :    /*-------------------------------------------------*/
; 1804 :    if (*lastz != 0)

	mov	eax, DWORD PTR _lastz$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN19@ThreedInte

; 1805 :    {
; 1806 :       if (zinpt >= zarray[*lastz] && zinpt <= zarray[*lastz + 1])

	mov	ecx, DWORD PTR _lastz$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR _zinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4]
	jb	SHORT $LN18@ThreedInte
	mov	ecx, DWORD PTR _lastz$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _zinpt$[ebp]
	jb	SHORT $LN18@ThreedInte

; 1807 :       {
; 1808 :          iz = *lastz;

	mov	ecx, DWORD PTR _lastz$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iz$[ebp], edx

; 1809 :          z1 = zarray[*lastz];

	mov	eax, DWORD PTR _lastz$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _z1$[ebp], xmm0

; 1810 :          z2 = zarray[*lastz+1];

	mov	eax, DWORD PTR _lastz$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _z2$[ebp], xmm0
	jmp	$LN8@ThreedInte
$LN18@ThreedInte:

; 1811 :       }
; 1812 :       else if ( zinpt <= zarray[*lastz])

	mov	eax, DWORD PTR _lastz$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR _zinpt$[ebp]
	jb	SHORT $LN16@ThreedInte

; 1813 :       {
; 1814 :          /*-----------------------*/
; 1815 :          /* Look down in the data */
; 1816 :          /*-----------------------*/
; 1817 :          for (i= *lastz; i>0; i--)

	mov	eax, DWORD PTR _lastz$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN15@ThreedInte
$LN14@ThreedInte:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN15@ThreedInte:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN13@ThreedInte

; 1818 :          {
; 1819 :             if (zinpt <= zarray[i] && zinpt >= zarray[i-1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _zinpt$[ebp]
	jb	SHORT $LN12@ThreedInte
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR _zinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4-4]
	jb	SHORT $LN12@ThreedInte

; 1820 :             {
; 1821 :                *lastz = i-1;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _lastz$[ebp]
	mov	DWORD PTR [edx], ecx

; 1822 :                iz = i-1;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iz$[ebp], eax

; 1823 :                z1 = zarray[i-1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4-4]
	movss	DWORD PTR _z1$[ebp], xmm0

; 1824 :                z2 = zarray[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _z2$[ebp], xmm0

; 1825 :                break;

	jmp	SHORT $LN13@ThreedInte
$LN12@ThreedInte:

; 1826 :             }
; 1827 :          }

	jmp	SHORT $LN14@ThreedInte
$LN13@ThreedInte:

; 1828 :       }
; 1829 :       else

	jmp	SHORT $LN8@ThreedInte
$LN16@ThreedInte:

; 1830 :       {
; 1831 :          for (i= *lastz+1; i< numz-1; i++)

	mov	edx, DWORD PTR _lastz$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN10@ThreedInte
$LN9@ThreedInte:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@ThreedInte:
	mov	edx, DWORD PTR _numz$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $LN8@ThreedInte

; 1832 :          {
; 1833 :             if (zinpt >= zarray[i] && zinpt <= zarray[i+1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR _zinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jb	SHORT $LN7@ThreedInte
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _zinpt$[ebp]
	jb	SHORT $LN7@ThreedInte

; 1834 :             {
; 1835 :                *lastz = i;

	mov	ecx, DWORD PTR _lastz$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx

; 1836 :                iz = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iz$[ebp], eax

; 1837 :                z1 = zarray[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _z1$[ebp], xmm0

; 1838 :                z2 = zarray[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	movss	DWORD PTR _z2$[ebp], xmm0

; 1839 :                break;

	jmp	SHORT $LN8@ThreedInte
$LN7@ThreedInte:

; 1840 :             }
; 1841 :          }

	jmp	SHORT $LN9@ThreedInte
$LN8@ThreedInte:

; 1842 :       }
; 1843 :    }
; 1844 :    else

	jmp	SHORT $LN3@ThreedInte
$LN19@ThreedInte:

; 1845 :    {
; 1846 :       /*--------------------------------------------*/
; 1847 :       /* No Previous value so start at the begining */
; 1848 :       /*--------------------------------------------*/
; 1849 :       for (i=0; i<numz - 1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@ThreedInte
$LN4@ThreedInte:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@ThreedInte:
	mov	eax, DWORD PTR _numz$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@ThreedInte

; 1850 :       {
; 1851 :          if (zinpt >= zarray[i] && zinpt <= zarray[i+1])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR _zinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jb	SHORT $LN2@ThreedInte
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	comiss	xmm0, DWORD PTR _zinpt$[ebp]
	jb	SHORT $LN2@ThreedInte

; 1852 :          {
; 1853 :             *lastz = i;

	mov	edx, DWORD PTR _lastz$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 1854 :             iz = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iz$[ebp], ecx

; 1855 :             z1 = zarray[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _z1$[ebp], xmm0

; 1856 :             z2 = zarray[i+1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _zarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _z2$[ebp], xmm0

; 1857 :             break;

	jmp	SHORT $LN3@ThreedInte
$LN2@ThreedInte:

; 1858 :          }
; 1859 :       }

	jmp	SHORT $LN4@ThreedInte
$LN3@ThreedInte:

; 1860 : 
; 1861 :    }
; 1862 :    dz = z2 - z1;

	movss	xmm0, DWORD PTR _z2$[ebp]
	subss	xmm0, DWORD PTR _z1$[ebp]
	movss	DWORD PTR _dz$[ebp], xmm0

; 1863 :    if(!dz) dz =1;//me123 incase theres only one number in the dat file

	movss	xmm0, DWORD PTR _dz$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@ThreedInte
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dz$[ebp], xmm0
$LN1@ThreedInte:

; 1864 : 
; 1865 :    /*----------------------------------*/
; 1866 :    /* x INTERPOLATION AT z BREAKPOINT  */
; 1867 :    /*----------------------------------*/
; 1868 :    index1 = (ix+1)*numy*numz + iy*numz + iz;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _numy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	mov	ecx, DWORD PTR _iy$[ebp]
	imul	ecx, DWORD PTR _numz$[ebp]
	add	eax, DWORD PTR _iz$[ebp]
	add	ecx, eax
	mov	DWORD PTR _index1$[ebp], ecx

; 1869 :    index2 = ix*numy*numz + iy*numz + iz;

	mov	edx, DWORD PTR _ix$[ebp]
	imul	edx, DWORD PTR _numy$[ebp]
	imul	edx, DWORD PTR _numz$[ebp]
	mov	eax, DWORD PTR _iy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	add	edx, DWORD PTR _iz$[ebp]
	add	eax, edx
	mov	DWORD PTR _index2$[ebp], eax

; 1870 :    index3 = (ix+1)*numy*numz + (iy+1)*numz + iz;

	mov	ecx, DWORD PTR _ix$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _numy$[ebp]
	imul	ecx, DWORD PTR _numz$[ebp]
	mov	edx, DWORD PTR _iy$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _numz$[ebp]
	add	ecx, DWORD PTR _iz$[ebp]
	add	edx, ecx
	mov	DWORD PTR _index3$[ebp], edx

; 1871 :    index4 = ix*numy*numz + (iy+1)*numz + iz;

	mov	eax, DWORD PTR _ix$[ebp]
	imul	eax, DWORD PTR _numy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	mov	ecx, DWORD PTR _iy$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _numz$[ebp]
	add	eax, DWORD PTR _iz$[ebp]
	add	ecx, eax
	mov	DWORD PTR _index4$[ebp], ecx

; 1872 : 
; 1873 :    dd1 = data[index1] - data[index2];

	mov	edx, DWORD PTR _index1$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _index2$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	subss	xmm0, DWORD PTR [esi+ecx*4]
	movss	DWORD PTR _dd1$[ebp], xmm0

; 1874 : 
; 1875 :    dd2 = data[index3] - data[index4];

	mov	edx, DWORD PTR _index3$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _index4$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	subss	xmm0, DWORD PTR [esi+ecx*4]
	movss	DWORD PTR _dd2$[ebp], xmm0

; 1876 : 
; 1877 :    d1  = data[index2] + (xinpt - x1)*dd1/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _dd1$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _index2$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _d1$[ebp], xmm0

; 1878 : 
; 1879 :    d2  = data[index4] + (xinpt - x1)*dd2/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _dd2$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	ecx, DWORD PTR _index4$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _d2$[ebp], xmm0

; 1880 : 
; 1881 :    /*---------------------------------*/
; 1882 :    /* y INTERPOLATION AT z BREAKPOINT */
; 1883 :    /*---------------------------------*/
; 1884 :    dd  = d2 - d1;

	movss	xmm0, DWORD PTR _d2$[ebp]
	subss	xmm0, DWORD PTR _d1$[ebp]
	movss	DWORD PTR _dd$[ebp], xmm0

; 1885 :    e1  = d1 + (yinpt - y1)*dd/dy;

	movss	xmm0, DWORD PTR _yinpt$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	mulss	xmm0, DWORD PTR _dd$[ebp]
	divss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _d1$[ebp]
	movss	DWORD PTR _e1$[ebp], xmm0

; 1886 : 
; 1887 :    /*-----------------------------------*/
; 1888 :    /* x INTERPOLATION AT z+1 BREAKPOINT */
; 1889 :    /*-----------------------------------*/
; 1890 :    index1 = (ix+1)*numy*numz + iy*numz + iz + 1;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _numy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	mov	ecx, DWORD PTR _iy$[ebp]
	imul	ecx, DWORD PTR _numz$[ebp]
	add	eax, DWORD PTR _iz$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _index1$[ebp], edx

; 1891 :    index2 = ix*numy*numz + iy*numz + iz + 1;

	mov	eax, DWORD PTR _ix$[ebp]
	imul	eax, DWORD PTR _numy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	mov	ecx, DWORD PTR _iy$[ebp]
	imul	ecx, DWORD PTR _numz$[ebp]
	add	eax, DWORD PTR _iz$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _index2$[ebp], edx

; 1892 :    index3 = (ix+1)*numy*numz + (iy+1)*numz + iz + 1;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _numy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	mov	ecx, DWORD PTR _iy$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _numz$[ebp]
	add	eax, DWORD PTR _iz$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _index3$[ebp], edx

; 1893 :    index4 = ix*numy*numz + (iy+1)*numz + iz + 1;

	mov	eax, DWORD PTR _ix$[ebp]
	imul	eax, DWORD PTR _numy$[ebp]
	imul	eax, DWORD PTR _numz$[ebp]
	mov	ecx, DWORD PTR _iy$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _numz$[ebp]
	add	eax, DWORD PTR _iz$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _index4$[ebp], edx

; 1894 : 
; 1895 :    dd1 = data[index1] - data[index2];

	mov	eax, DWORD PTR _index1$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _index2$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4]
	movss	DWORD PTR _dd1$[ebp], xmm0

; 1896 : 
; 1897 :    dd2 = data[index3] - data[index4];

	mov	eax, DWORD PTR _index3$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _index4$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4]
	movss	DWORD PTR _dd2$[ebp], xmm0

; 1898 : 
; 1899 :    d1  = data[index2] + (xinpt - x1)*dd1/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _dd1$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _index2$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _d1$[ebp], xmm0

; 1900 : 
; 1901 :    d2  = data[index4] + (xinpt - x1)*dd2/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _dd2$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _index4$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _d2$[ebp], xmm0

; 1902 : 
; 1903 :    /*-----------------------------------*/
; 1904 :    /* y INTERPOLATION AT z+1 BREAKPOINT */
; 1905 :    /*-----------------------------------*/
; 1906 :    dd  = d2 - d1;

	movss	xmm0, DWORD PTR _d2$[ebp]
	subss	xmm0, DWORD PTR _d1$[ebp]
	movss	DWORD PTR _dd$[ebp], xmm0

; 1907 :    e2  = d1 + (yinpt - y1)*dd/dy;

	movss	xmm0, DWORD PTR _yinpt$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	mulss	xmm0, DWORD PTR _dd$[ebp]
	divss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _d1$[ebp]
	movss	DWORD PTR _e2$[ebp], xmm0

; 1908 : 
; 1909 :    /*-----------------*/
; 1910 :    /* z INTERPOLATION */
; 1911 :    /*-----------------*/
; 1912 :    de    = e2 - e1;

	movss	xmm0, DWORD PTR _e2$[ebp]
	subss	xmm0, DWORD PTR _e1$[ebp]
	movss	DWORD PTR _de$[ebp], xmm0

; 1913 :    interp = e1 + (zinpt - z1)*de/dz;

	movss	xmm0, DWORD PTR _zinpt$[ebp]
	subss	xmm0, DWORD PTR _z1$[ebp]
	mulss	xmm0, DWORD PTR _de$[ebp]
	divss	xmm0, DWORD PTR _dz$[ebp]
	addss	xmm0, DWORD PTR _e1$[ebp]
	movss	DWORD PTR _interp$[ebp], xmm0

; 1914 :    return (interp);

	fld	DWORD PTR _interp$[ebp]

; 1915 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
?ThreedInterp@SIMLIB_MATH_CLASS@@QAEMMMMPBM000HHHPAH11@Z ENDP ; SIMLIB_MATH_CLASS::ThreedInterp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -92						; size = 4
_interp$ = -88						; size = 4
_dy$ = -84						; size = 4
_ddata$ = -80						; size = 4
_data2$ = -76						; size = 4
_ddata2$ = -72						; size = 4
_ddata1$ = -68						; size = 4
_y2$ = -64						; size = 4
_x2$ = -60						; size = 4
_data1$ = -56						; size = 4
_y1$ = -52						; size = 4
_dx$ = -48						; size = 4
tv149 = -44						; size = 4
tv145 = -40						; size = 4
tv133 = -36						; size = 4
tv93 = -32						; size = 4
tv89 = -28						; size = 4
tv77 = -24						; size = 4
_x1$ = -20						; size = 4
_yinpt$ = -16						; size = 4
_xinpt$ = -12						; size = 4
_iy$ = -8						; size = 4
_ix$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xarray$ = 16						; size = 4
_yarray$ = 20						; size = 4
_data$ = 24						; size = 4
_numx$ = 28						; size = 4
_numy$ = 32						; size = 4
_lastx$ = 36						; size = 4
_lasty$ = 40						; size = 4
?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z PROC	; SIMLIB_MATH_CLASS::TwodInterp
; _this$ = ecx

; 1485 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1486 : float xinpt, yinpt;
; 1487 : float x1, x2, dx;
; 1488 : float y1, y2, dy;
; 1489 : float ddata, ddata1, ddata2, data1, data2;
; 1490 : float interp;
; 1491 : int   ix, iy;
; 1492 : 
; 1493 : ShiAssert(FALSE == F4IsBadReadPtr(xarray, sizeof *xarray * numx));
; 1494 : ShiAssert(FALSE == F4IsBadReadPtr(yarray, sizeof *yarray * numy))
; 1495 :    /*-------------------------------------------------*/
; 1496 :    /* limit independent variables to table boundaries */
; 1497 :    /*-------------------------------------------------*/
; 1498 : 	numx --;

	mov	eax, DWORD PTR _numx$[ebp]
	sub	eax, 1
	mov	DWORD PTR _numx$[ebp], eax

; 1499 : 	numy --;

	mov	ecx, DWORD PTR _numy$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _numy$[ebp], ecx

; 1500 : 	//if (numx >= 0 && numy >= 0) // JB 010220 CTD
; 1501 : 	if (numx >= 0 && numy >= 0 && 
; 1502 : 		xarray && //!F4IsBadReadPtr(xarray, sizeof(SIM_FLOAT)) && // (too much CPU)
; 1503 : 		yarray //!F4IsBadReadPtr(yarray, sizeof(SIM_FLOAT)) // JB 010318 CTD (too much CPU)
; 1504 : 		)

	cmp	DWORD PTR _numx$[ebp], 0
	jl	$LN25@TwodInterp
	cmp	DWORD PTR _numy$[ebp], 0
	jl	$LN25@TwodInterp
	cmp	DWORD PTR _xarray$[ebp], 0
	je	$LN25@TwodInterp
	cmp	DWORD PTR _yarray$[ebp], 0
	je	$LN25@TwodInterp

; 1505 : 	{
; 1506 : 		xinpt = min ( max (x, xarray[0]), xarray[numx]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN28@TwodInterp
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN29@TwodInterp
$LN28@TwodInterp:
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv77[ebp], xmm0
$LN29@TwodInterp:
	mov	eax, DWORD PTR _numx$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR tv77[ebp]
	jbe	SHORT $LN32@TwodInterp
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN30@TwodInterp
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	jmp	SHORT $LN31@TwodInterp
$LN30@TwodInterp:
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv89[ebp], xmm0
$LN31@TwodInterp:
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR tv93[ebp], xmm0
	jmp	SHORT $LN33@TwodInterp
$LN32@TwodInterp:
	mov	eax, DWORD PTR _numx$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv93[ebp], xmm0
$LN33@TwodInterp:
	movss	xmm0, DWORD PTR tv93[ebp]
	movss	DWORD PTR _xinpt$[ebp], xmm0

; 1507 : 		yinpt = min ( max (y, yarray[0]), yarray[numy]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN34@TwodInterp
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN35@TwodInterp
$LN34@TwodInterp:
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv133[ebp], xmm0
$LN35@TwodInterp:
	mov	eax, DWORD PTR _numy$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR tv133[ebp]
	jbe	SHORT $LN38@TwodInterp
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx]
	jbe	SHORT $LN36@TwodInterp
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR tv145[ebp], xmm0
	jmp	SHORT $LN37@TwodInterp
$LN36@TwodInterp:
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv145[ebp], xmm0
$LN37@TwodInterp:
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN39@TwodInterp
$LN38@TwodInterp:
	mov	eax, DWORD PTR _numy$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv149[ebp], xmm0
$LN39@TwodInterp:
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR _yinpt$[ebp], xmm0
$LN25@TwodInterp:

; 1508 : 	}
; 1509 : 
; 1510 :    /*-------------------------------------------------*/
; 1511 :    /* If there is a last x use it as a starting point */
; 1512 :    /*-------------------------------------------------*/
; 1513 : 	ix = *lastx;

	mov	edx, DWORD PTR _lastx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ix$[ebp], eax

; 1514 : 	ShiAssert(ix >= 0 && ix < numx); // JPO CTD 
; 1515 :    if (ix != 0)

	cmp	DWORD PTR _ix$[ebp], 0
	je	SHORT $LN24@TwodInterp

; 1516 :    {
; 1517 :       if ( xinpt <= xarray[ix])

	mov	ecx, DWORD PTR _ix$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN23@TwodInterp
$LN22@TwodInterp:

; 1518 :       {
; 1519 :          /*-----------------------*/
; 1520 :          /* Look down in the data */
; 1521 :          /*-----------------------*/
; 1522 : 			while ((ix > 0) && (xinpt < xarray[ix]))

	cmp	DWORD PTR _ix$[ebp], 0
	jle	SHORT $LN21@TwodInterp
	mov	eax, DWORD PTR _ix$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jbe	SHORT $LN21@TwodInterp

; 1523 : 				ix --;

	mov	edx, DWORD PTR _ix$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ix$[ebp], edx
	jmp	SHORT $LN22@TwodInterp
$LN21@TwodInterp:

; 1524 :       }
; 1525 :       else if (xinpt > xarray[ix + 1])

	jmp	SHORT $LN17@TwodInterp
$LN23@TwodInterp:
	mov	eax, DWORD PTR _ix$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4+4]
	jbe	SHORT $LN17@TwodInterp
$LN18@TwodInterp:

; 1526 :       {
; 1527 :          /*---------------------*/
; 1528 :          /* Look up in the data */
; 1529 :          /*---------------------*/
; 1530 : 			while ((ix < numx) && (xinpt > xarray[ix + 1]))

	mov	edx, DWORD PTR _ix$[ebp]
	cmp	edx, DWORD PTR _numx$[ebp]
	jge	SHORT $LN17@TwodInterp
	mov	eax, DWORD PTR _ix$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4+4]
	jbe	SHORT $LN17@TwodInterp

; 1531 : 				ix ++;

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 1
	mov	DWORD PTR _ix$[ebp], edx
	jmp	SHORT $LN18@TwodInterp
$LN17@TwodInterp:

; 1532 :       }
; 1533 :    }
; 1534 :    else

	jmp	SHORT $LN14@TwodInterp
$LN24@TwodInterp:

; 1535 :    {
; 1536 :       /*--------------------------------------------*/
; 1537 :       /* No Previous value so start at the begining */
; 1538 :       /*--------------------------------------------*/
; 1539 : 		while ((ix < numx) && (xinpt > xarray[ix + 1]))

	mov	eax, DWORD PTR _ix$[ebp]
	cmp	eax, DWORD PTR _numx$[ebp]
	jge	SHORT $LN14@TwodInterp
	mov	ecx, DWORD PTR _ix$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4+4]
	jbe	SHORT $LN14@TwodInterp

; 1540 : 			ix ++;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 1
	mov	DWORD PTR _ix$[ebp], eax
	jmp	SHORT $LN24@TwodInterp
$LN14@TwodInterp:

; 1541 :    }
; 1542 :    ShiAssert(ix >= 0 && ix < numx); // JPO CTD  check again
; 1543 : 	 if (ix < 0 || ix >= numx)

	cmp	DWORD PTR _ix$[ebp], 0
	jl	SHORT $LN12@TwodInterp
	mov	ecx, DWORD PTR _ix$[ebp]
	cmp	ecx, DWORD PTR _numx$[ebp]
	jl	SHORT $LN13@TwodInterp
$LN12@TwodInterp:

; 1544 : 		return 0.0f;

	fldz
	jmp	$LN26@TwodInterp
$LN13@TwodInterp:

; 1545 :    *lastx = ix;

	mov	edx, DWORD PTR _lastx$[ebp]
	mov	eax, DWORD PTR _ix$[ebp]
	mov	DWORD PTR [edx], eax

; 1546 :    x1 = xarray[ix];

	mov	ecx, DWORD PTR _ix$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _x1$[ebp], xmm0

; 1547 :    x2 = xarray[ix+1];

	mov	eax, DWORD PTR _ix$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	movss	DWORD PTR _x2$[ebp], xmm0

; 1548 :    dx = 1.0F/(x2 - x1);

	movss	xmm0, DWORD PTR _x2$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _dx$[ebp], xmm1

; 1549 : 
; 1550 :    /*-------------------------------------------------*/
; 1551 :    /* If there is a last y use it as a starting point */
; 1552 :    /*-------------------------------------------------*/
; 1553 : 	iy = *lasty;

	mov	edx, DWORD PTR _lasty$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iy$[ebp], eax

; 1554 : 	ShiAssert(iy >= 0 && iy < numy); // JPO CTD 
; 1555 :    if (iy != 0)

	cmp	DWORD PTR _iy$[ebp], 0
	je	SHORT $LN11@TwodInterp

; 1556 :    {
; 1557 :       if ( yinpt <= yarray[iy])

	mov	ecx, DWORD PTR _iy$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jb	SHORT $LN10@TwodInterp
$LN9@TwodInterp:

; 1558 :       {
; 1559 :          /*-----------------------*/
; 1560 :          /* Look down in the data */
; 1561 :          /*-----------------------*/
; 1562 : 			while ((iy > 0) && (yinpt < yarray[iy]))

	cmp	DWORD PTR _iy$[ebp], 0
	jle	SHORT $LN8@TwodInterp
	mov	eax, DWORD PTR _iy$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _yinpt$[ebp]
	jbe	SHORT $LN8@TwodInterp

; 1563 : 				iy --;

	mov	edx, DWORD PTR _iy$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iy$[ebp], edx
	jmp	SHORT $LN9@TwodInterp
$LN8@TwodInterp:

; 1564 :       }
; 1565 :       else if (yinpt > yarray[iy + 1])

	jmp	SHORT $LN4@TwodInterp
$LN10@TwodInterp:
	mov	eax, DWORD PTR _iy$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4+4]
	jbe	SHORT $LN4@TwodInterp
$LN5@TwodInterp:

; 1566 :       {
; 1567 :          /*---------------------*/
; 1568 :          /* Look up in the data */
; 1569 :          /*---------------------*/
; 1570 : 			while ((iy < numy) && (yinpt > yarray[iy + 1]))

	mov	edx, DWORD PTR _iy$[ebp]
	cmp	edx, DWORD PTR _numy$[ebp]
	jge	SHORT $LN4@TwodInterp
	mov	eax, DWORD PTR _iy$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4+4]
	jbe	SHORT $LN4@TwodInterp

; 1571 : 				iy ++;

	mov	edx, DWORD PTR _iy$[ebp]
	add	edx, 1
	mov	DWORD PTR _iy$[ebp], edx
	jmp	SHORT $LN5@TwodInterp
$LN4@TwodInterp:

; 1572 :       }
; 1573 :    }
; 1574 :    else

	jmp	SHORT $LN1@TwodInterp
$LN11@TwodInterp:

; 1575 :    {
; 1576 :       /*--------------------------------------------*/
; 1577 :       /* No Previous value so start at the begining */
; 1578 :       /*--------------------------------------------*/
; 1579 : 		while ((iy < numy) && (yinpt > yarray[iy + 1]))

	mov	eax, DWORD PTR _iy$[ebp]
	cmp	eax, DWORD PTR _numy$[ebp]
	jge	SHORT $LN1@TwodInterp
	mov	ecx, DWORD PTR _iy$[ebp]
	mov	edx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR _yinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4+4]
	jbe	SHORT $LN1@TwodInterp

; 1580 : 			iy ++;

	mov	eax, DWORD PTR _iy$[ebp]
	add	eax, 1
	mov	DWORD PTR _iy$[ebp], eax
	jmp	SHORT $LN11@TwodInterp
$LN1@TwodInterp:

; 1581 :    }
; 1582 :    ShiAssert(iy >= 0 && iy < numy); // JPO CTD  check again
; 1583 :    *lasty = iy;

	mov	ecx, DWORD PTR _lasty$[ebp]
	mov	edx, DWORD PTR _iy$[ebp]
	mov	DWORD PTR [ecx], edx

; 1584 :    y1 = yarray[iy];

	mov	eax, DWORD PTR _iy$[ebp]
	mov	ecx, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _y1$[ebp], xmm0

; 1585 :    y2 = yarray[iy+1];

	mov	edx, DWORD PTR _iy$[ebp]
	mov	eax, DWORD PTR _yarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	movss	DWORD PTR _y2$[ebp], xmm0

; 1586 :    dy = 1.0F / (y2 - y1);

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _dy$[ebp], xmm1

; 1587 : 
; 1588 :    /*----------------------*/
; 1589 :    /* xarray interpolation */
; 1590 :    /*----------------------*/
; 1591 : 	numy ++;

	mov	ecx, DWORD PTR _numy$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numy$[ebp], ecx

; 1592 :    ddata1 = data[(ix+1)*numy + iy]     - data[ix * numy + iy];

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _numy$[ebp]
	add	edx, DWORD PTR _iy$[ebp]
	mov	eax, DWORD PTR _ix$[ebp]
	imul	eax, DWORD PTR _numy$[ebp]
	add	eax, DWORD PTR _iy$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx*4]
	subss	xmm0, DWORD PTR [esi+eax*4]
	movss	DWORD PTR _ddata1$[ebp], xmm0

; 1593 :    ddata2 = data[(ix+1)*numy + iy + 1] - data[ix * numy + iy + 1];

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _numy$[ebp]
	add	edx, DWORD PTR _iy$[ebp]
	mov	eax, DWORD PTR _ix$[ebp]
	imul	eax, DWORD PTR _numy$[ebp]
	add	eax, DWORD PTR _iy$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx*4+4]
	subss	xmm0, DWORD PTR [esi+eax*4+4]
	movss	DWORD PTR _ddata2$[ebp], xmm0

; 1594 : 
; 1595 :    data1  = data[ix * numy + iy]     + (xinpt - x1)*ddata1*dx;

	mov	edx, DWORD PTR _ix$[ebp]
	imul	edx, DWORD PTR _numy$[ebp]
	add	edx, DWORD PTR _iy$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _ddata1$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _data1$[ebp], xmm0

; 1596 :    data2  = data[ix * numy + iy + 1] + (xinpt - x1)*ddata2*dx;

	mov	ecx, DWORD PTR _ix$[ebp]
	imul	ecx, DWORD PTR _numy$[ebp]
	add	ecx, DWORD PTR _iy$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _ddata2$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4+4]
	movss	DWORD PTR _data2$[ebp], xmm0

; 1597 : 
; 1598 :    /*----------------------*/
; 1599 :    /* yarray interpolation */
; 1600 :    /*----------------------*/
; 1601 :    ddata    = data2 - data1;

	movss	xmm0, DWORD PTR _data2$[ebp]
	subss	xmm0, DWORD PTR _data1$[ebp]
	movss	DWORD PTR _ddata$[ebp], xmm0

; 1602 : 
; 1603 :    interp = data1 + (yinpt - y1)*ddata*dy;

	movss	xmm0, DWORD PTR _yinpt$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	mulss	xmm0, DWORD PTR _ddata$[ebp]
	mulss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _data1$[ebp]
	movss	DWORD PTR _interp$[ebp], xmm0

; 1604 : 
; 1605 :    return (interp);

	fld	DWORD PTR _interp$[ebp]
$LN26@TwodInterp:

; 1606 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?TwodInterp@SIMLIB_MATH_CLASS@@QAEMMMPBM00HHPAH1@Z ENDP	; SIMLIB_MATH_CLASS::TwodInterp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -48						; size = 4
tv75 = -44						; size = 4
tv74 = -40						; size = 4
tv71 = -36						; size = 4
_xmax$ = -32						; size = 4
_final_val$ = -28					; size = 4
_xmin$ = -24						; size = 4
_dx$ = -20						; size = 4
_ddata$ = -16						; size = 4
_x0$ = -12						; size = 4
_xinpt$ = -8						; size = 4
_i$ = -4						; size = 4
_x$ = 8							; size = 4
_xarray$ = 12						; size = 4
_data$ = 16						; size = 4
_numx$ = 20						; size = 4
_lastx$ = 24						; size = 4
?OnedInterp@SIMLIB_MATH_CLASS@@QAEMMPBM0HPAH@Z PROC	; SIMLIB_MATH_CLASS::OnedInterp
; _this$ = ecx

; 1372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1373 : int i=0;

	mov	DWORD PTR _i$[ebp], 0

; 1374 : float x0=0.0F, dx=0.0F, ddata=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _x0$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ddata$[ebp], xmm0

; 1375 : float xinpt=0.0F, xmin=0.0F, xmax=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _xinpt$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _xmin$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _xmax$[ebp], xmm0

; 1376 : float final_val = static_cast<float>(*lastx);

	mov	eax, DWORD PTR _lastx$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	movss	DWORD PTR _final_val$[ebp], xmm0

; 1377 : 
; 1378 :    /*-----------------------*/
; 1379 :    /* limit to within table */
; 1380 :    /*-----------------------*/
; 1381 :    xmin = xarray[0];

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _xmin$[ebp], xmm0

; 1382 :    xmax = xarray[numx-1];

	mov	eax, DWORD PTR _numx$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	movss	DWORD PTR _xmax$[ebp], xmm0

; 1383 : 	xinpt = min ( max (x, xmin), xmax);

	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR _xmin$[ebp]
	jbe	SHORT $LN21@OnedInterp
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv71[ebp], xmm0
	jmp	SHORT $LN22@OnedInterp
$LN21@OnedInterp:
	movss	xmm0, DWORD PTR _xmin$[ebp]
	movss	DWORD PTR tv71[ebp], xmm0
$LN22@OnedInterp:
	movss	xmm0, DWORD PTR _xmax$[ebp]
	comiss	xmm0, DWORD PTR tv71[ebp]
	jbe	SHORT $LN25@OnedInterp
	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR _xmin$[ebp]
	jbe	SHORT $LN23@OnedInterp
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN24@OnedInterp
$LN23@OnedInterp:
	movss	xmm0, DWORD PTR _xmin$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
$LN24@OnedInterp:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN26@OnedInterp
$LN25@OnedInterp:
	movss	xmm0, DWORD PTR _xmax$[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
$LN26@OnedInterp:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _xinpt$[ebp], xmm0

; 1384 : 
; 1385 :    /*-------------------------------------------------*/
; 1386 :    /* If there is a last x use it as a starting point */
; 1387 :    /*-------------------------------------------------*/
; 1388 :    if (*lastx != 0)

	mov	edx, DWORD PTR _lastx$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN18@OnedInterp

; 1389 :    {
; 1390 :       if (xinpt >= xarray[*lastx] && xinpt <= xarray[*lastx + 1])

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jb	$LN17@OnedInterp
	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN17@OnedInterp

; 1391 :       {
; 1392 :          x0 = xarray[*lastx];

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _x0$[ebp], xmm0

; 1393 :          dx = xarray[*lastx+1] - x0;

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	subss	xmm0, DWORD PTR _x0$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1394 :          ddata = data[*lastx+1] - data[*lastx];

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lastx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _data$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	subss	xmm0, DWORD PTR [esi+eax*4]
	movss	DWORD PTR _ddata$[ebp], xmm0

; 1395 :          final_val =  data[*lastx] + (xinpt-x0) * ddata/dx;

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x0$[ebp]
	mulss	xmm0, DWORD PTR _ddata$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _final_val$[ebp], xmm0
	jmp	$LN7@OnedInterp
$LN17@OnedInterp:

; 1396 :       }
; 1397 :       else if ( xinpt <= xarray[*lastx])

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	$LN15@OnedInterp

; 1398 :       {
; 1399 :          /*-----------------------*/
; 1400 :          /* Look down in the data */
; 1401 :          /*-----------------------*/
; 1402 :          for (i= *lastx; i>0; i--)

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN14@OnedInterp
$LN13@OnedInterp:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN14@OnedInterp:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN12@OnedInterp

; 1403 :          {
; 1404 :             if (xinpt <= xarray[i] && xinpt >= xarray[i-1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	$LN11@OnedInterp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx*4-4]
	jb	SHORT $LN11@OnedInterp

; 1405 :             {
; 1406 :                *lastx = i-1;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _lastx$[ebp]
	mov	DWORD PTR [edx], ecx

; 1407 :                x0 = xarray[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	movss	DWORD PTR _x0$[ebp], xmm0

; 1408 :                dx = xarray[i] - x0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	subss	xmm0, DWORD PTR _x0$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1409 :                ddata = data[i] - data[i-1];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [esi+eax*4-4]
	movss	DWORD PTR _ddata$[ebp], xmm0

; 1410 :                final_val =  data[i-1] + (xinpt-x0) * ddata/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x0$[ebp]
	mulss	xmm0, DWORD PTR _ddata$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4-4]
	movss	DWORD PTR _final_val$[ebp], xmm0

; 1411 :                break;

	jmp	SHORT $LN12@OnedInterp
$LN11@OnedInterp:

; 1412 :             }
; 1413 :          }

	jmp	$LN13@OnedInterp
$LN12@OnedInterp:

; 1414 :       }
; 1415 :       else

	jmp	$LN7@OnedInterp
$LN15@OnedInterp:

; 1416 :       {
; 1417 :          for (i= *lastx+1; i< numx-1; i++)

	mov	eax, DWORD PTR _lastx$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN9@OnedInterp
$LN8@OnedInterp:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@OnedInterp:
	mov	eax, DWORD PTR _numx$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN7@OnedInterp

; 1418 :          {
; 1419 :             if (xinpt >= xarray[i] && xinpt <= xarray[i+1])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jb	$LN6@OnedInterp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN6@OnedInterp

; 1420 :             {
; 1421 :                *lastx = i;

	mov	edx, DWORD PTR _lastx$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax

; 1422 :                x0 = xarray[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _x0$[ebp], xmm0

; 1423 :                dx = xarray[i+1] - x0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+4]
	subss	xmm0, DWORD PTR _x0$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1424 :                ddata = data[i+1] - data[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	subss	xmm0, DWORD PTR [esi+ecx*4]
	movss	DWORD PTR _ddata$[ebp], xmm0

; 1425 :                final_val = data[i] + (xinpt-x0) * ddata/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x0$[ebp]
	mulss	xmm0, DWORD PTR _ddata$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR _final_val$[ebp], xmm0

; 1426 :                break;

	jmp	SHORT $LN7@OnedInterp
$LN6@OnedInterp:

; 1427 :             }
; 1428 :          }

	jmp	$LN8@OnedInterp
$LN7@OnedInterp:

; 1429 :       }
; 1430 :    }
; 1431 :    else

	jmp	$LN2@OnedInterp
$LN18@OnedInterp:

; 1432 :    {
; 1433 :       /*--------------------------------------------*/
; 1434 :       /* No Previous value so start at the begining */
; 1435 :       /*--------------------------------------------*/
; 1436 :       for (i=0; i<numx-1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@OnedInterp
$LN3@OnedInterp:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@OnedInterp:
	mov	edx, DWORD PTR _numx$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN2@OnedInterp

; 1437 :       {
; 1438 :          if (xinpt >= xarray[i] && xinpt <= xarray[i+1])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR _xinpt$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jb	$LN1@OnedInterp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	comiss	xmm0, DWORD PTR _xinpt$[ebp]
	jb	SHORT $LN1@OnedInterp

; 1439 :          {
; 1440 :             *lastx = i;

	mov	ecx, DWORD PTR _lastx$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx

; 1441 :             x0 = xarray[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _x0$[ebp], xmm0

; 1442 :             dx = xarray[i+1] - x0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xarray$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+4]
	subss	xmm0, DWORD PTR _x0$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1443 :             ddata = data[i+1] - data[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	subss	xmm0, DWORD PTR [esi+eax*4]
	movss	DWORD PTR _ddata$[ebp], xmm0

; 1444 :             final_val =  data[i] + (xinpt-x0) * ddata/dx;

	movss	xmm0, DWORD PTR _xinpt$[ebp]
	subss	xmm0, DWORD PTR _x0$[ebp]
	mulss	xmm0, DWORD PTR _ddata$[ebp]
	divss	xmm0, DWORD PTR _dx$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR _final_val$[ebp], xmm0

; 1445 :             break;

	jmp	SHORT $LN2@OnedInterp
$LN1@OnedInterp:

; 1446 :          }
; 1447 :       }

	jmp	$LN3@OnedInterp
$LN2@OnedInterp:

; 1448 :    }
; 1449 : 
; 1450 :    return (final_val);

	fld	DWORD PTR _final_val$[ebp]

; 1451 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?OnedInterp@SIMLIB_MATH_CLASS@@QAEMMPBM0HPAH@Z ENDP	; SIMLIB_MATH_CLASS::OnedInterp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv150 = -4						; size = 4
_in$ = 8						; size = 4
_delt$ = 12						; size = 4
_save$ = 16						; size = 4
?FIAdamsBash@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z PROC	; SIMLIB_MATH_CLASS::FIAdamsBash
; _this$ = ecx

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1279 :    /*----------------*/
; 1280 :    /* compute output */
; 1281 :    /*----------------*/
; 1282 :    save[3] = in;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1283 :    save[1] = save[1] + delt*(save[3]*3.0F - save[2]) * 0.5F;

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@40400000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	subss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1284 : 
; 1285 :    /*---------------------------------*/
; 1286 :    /* save values from the last frame */
; 1287 :    /*---------------------------------*/
; 1288 :    save[0]=save[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1289 :    save[2]=save[3];

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1290 : 
; 1291 :    return((SIM_FLOAT)save[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv150[ebp], xmm0
	fld	DWORD PTR tv150[ebp]

; 1292 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FIAdamsBash@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z ENDP	; SIMLIB_MATH_CLASS::FIAdamsBash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv161 = -12						; size = 4
_k2$ = -8						; size = 4
_k1$ = -4						; size = 4
_in$ = 8						; size = 4
_tau$ = 12						; size = 4
_delt$ = 16						; size = 4
_save$ = 20						; size = 4
?FWTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z PROC		; SIMLIB_MATH_CLASS::FWTust
; _this$ = ecx

; 1323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1324 : SIM_FLOAT k1,k2;
; 1325 : 
; 1326 :    /*-----------------------*/
; 1327 :    /* equation coefficients */
; 1328 :    /*-----------------------*/
; 1329 :    k1 = (float)exp(-delt/tau);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _k1$[ebp]

; 1330 :    k2 = (1+k1)/2.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _k1$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _k2$[ebp], xmm0

; 1331 : 
; 1332 :    /*----------------*/
; 1333 :    /* compute output */
; 1334 :    /*----------------*/
; 1335 :    save[3] = in;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1336 :    save[1] = save[0]*k1 + k2*(save[3] - save[2]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _k1$[ebp]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	subss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR _k2$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1337 : 
; 1338 :    /*---------------------------------*/
; 1339 :    /* save values from the last frame */
; 1340 :    /*---------------------------------*/
; 1341 :    save[0]=save[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1342 :    save[2]=save[3];

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1343 : 
; 1344 :    return((SIM_FLOAT)save[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv161[ebp], xmm0
	fld	DWORD PTR tv161[ebp]

; 1345 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FWTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z ENDP		; SIMLIB_MATH_CLASS::FWTust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv149 = -4						; size = 4
_in$ = 8						; size = 4
_delt$ = 12						; size = 4
_save$ = 16						; size = 4
?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z PROC		; SIMLIB_MATH_CLASS::FITust
; _this$ = ecx

; 1235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1236 :    /*----------------*/
; 1237 :    /* compute output */
; 1238 :    /*----------------*/
; 1239 :    save[3] = in;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1240 :    save[1] = save[0] + delt*(save[3] + save[2]) * 0.5F;

	mov	edx, 4
	imul	edx, 0
	mov	eax, 4
	imul	eax, 3
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _save$[ebp]
	mov	edi, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	addss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1241 : 
; 1242 :    /*---------------------------------*/
; 1243 :    /* save values from the last frame */
; 1244 :    /*---------------------------------*/
; 1245 :    save[0]=save[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1246 :    save[2]=save[3];

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1247 : 
; 1248 :    return((SIM_FLOAT)save[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv149[ebp], xmm0
	fld	DWORD PTR tv149[ebp]

; 1249 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FITust@SIMLIB_MATH_CLASS@@QAEMMMQAM@Z ENDP		; SIMLIB_MATH_CLASS::FITust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv162 = -12						; size = 4
_k2$ = -8						; size = 4
_k1$ = -4						; size = 4
_in$ = 8						; size = 4
_tau$ = 12						; size = 4
_delt$ = 16						; size = 4
_save$ = 20						; size = 4
?FLeadTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z PROC		; SIMLIB_MATH_CLASS::FLeadTust
; _this$ = ecx

; 1184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : SIM_FLOAT k1,k2;
; 1186 : 
; 1187 :    /*-----------------------*/
; 1188 :    /* equation coefficients */
; 1189 :    /*-----------------------*/
; 1190 :    k1 = (float)exp(-delt/tau);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _k1$[ebp]

; 1191 :    k2 = 2.0F / (1.0F-k1);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _k1$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	divss	xmm1, xmm0
	movss	DWORD PTR _k2$[ebp], xmm1

; 1192 : 
; 1193 :    /*----------------*/
; 1194 :    /* compute output */
; 1195 :    /*----------------*/
; 1196 :    save[3] = in;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1197 :    save[1] = save[0]*k1 + k2*(save[3] - save[2]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _k1$[ebp]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	subss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR _k2$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1198 : 
; 1199 :    /*---------------------------------*/
; 1200 :    /* save values from the last frame */
; 1201 :    /*---------------------------------*/
; 1202 :    save[0]=save[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1203 :    save[2]=save[3];

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1204 : 
; 1205 :    return((SIM_FLOAT)save[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv162[ebp], xmm0
	fld	DWORD PTR tv162[ebp]

; 1206 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FLeadTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z ENDP		; SIMLIB_MATH_CLASS::FLeadTust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv161 = -12						; size = 4
_k2$ = -8						; size = 4
_k1$ = -4						; size = 4
_in$ = 8						; size = 4
_tau$ = 12						; size = 4
_delt$ = 16						; size = 4
_save$ = 20						; size = 4
?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z PROC		; SIMLIB_MATH_CLASS::FLTust
; _this$ = ecx

; 1131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1132 : SIM_FLOAT k1,k2;
; 1133 : 
; 1134 :    /*-----------------------*/
; 1135 :    /* equation coefficients */
; 1136 :    /*-----------------------*/
; 1137 :    k1 = (float)exp(-delt/tau);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _k1$[ebp]

; 1138 :    k2 = (1-k1)/2.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _k1$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _k2$[ebp], xmm0

; 1139 : 
; 1140 :    /*----------------*/
; 1141 :    /* compute output */
; 1142 :    /*----------------*/
; 1143 :    save[3] = in;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1144 :    save[1] = save[0]*k1 + k2*(save[3] + save[2]);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _k1$[ebp]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR _k2$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1145 : 
; 1146 :    /*---------------------------------*/
; 1147 :    /* save values from the last frame */
; 1148 :    /*---------------------------------*/
; 1149 :    save[0]=save[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1150 :    save[2]=save[3];

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1151 : 
; 1152 :    return((SIM_FLOAT)save[1]);

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv161[ebp], xmm0
	fld	DWORD PTR tv161[ebp]

; 1153 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FLTust@SIMLIB_MATH_CLASS@@QAEMMMMQAM@Z ENDP		; SIMLIB_MATH_CLASS::FLTust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
tv267 = -40						; size = 4
_k$ = -36						; size = 4
tv210 = -32						; size = 4
tv198 = -28						; size = 4
tv271 = -24						; size = 4
tv192 = -20						; size = 4
_b$ = -16						; size = 4
_a$ = -12						; size = 4
_d$ = -8						; size = 4
_c$ = -4						; size = 4
_in$ = 8						; size = 4
_tau1$ = 12						; size = 4
_tau2$ = 16						; size = 4
_tau3$ = 20						; size = 4
_delt$ = 24						; size = 4
_save$ = 28						; size = 4
_jstart$ = 32						; size = 4
?F8Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z PROC	; SIMLIB_MATH_CLASS::F8Tust
; _this$ = ecx

; 1062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : SIM_FLOAT a,b,c,d,k;
; 1064 : 
; 1065 :    /*----------------------------------*/
; 1066 :    /* compute z-transform coefficients */
; 1067 :    /*----------------------------------*/
; 1068 :    a = -((SIM_FLOAT)exp(-delt/tau2) + (SIM_FLOAT)exp(-delt/tau3));

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv192[ebp]
	movss	xmm0, DWORD PTR tv192[ebp]
	movss	xmm1, DWORD PTR _delt$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm1, DWORD PTR _tau3$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv271[ebp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv198[ebp]
	movss	xmm0, DWORD PTR tv271[ebp]
	addss	xmm0, DWORD PTR tv198[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _a$[ebp], xmm0

; 1069 :    b =   (SIM_FLOAT)exp(-delt*(1/tau2 + 1/tau3));

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, DWORD PTR _tau2$[ebp]
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, DWORD PTR _tau3$[ebp]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _b$[ebp]

; 1070 :    c = -(1 + (SIM_FLOAT)exp(-delt/tau1));

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv210[ebp]
	movss	xmm0, DWORD PTR tv210[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _c$[ebp], xmm0

; 1071 :    d =   (SIM_FLOAT)exp(-delt/tau1);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _d$[ebp]

; 1072 :    k =  (1 - a + b)/(1 - c + d)*tau1/(tau2*tau3);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _a$[ebp]
	addss	xmm0, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _c$[ebp]
	addss	xmm1, DWORD PTR _d$[ebp]
	divss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _tau1$[ebp]
	movss	xmm1, DWORD PTR _tau2$[ebp]
	mulss	xmm1, DWORD PTR _tau3$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _k$[ebp], xmm0

; 1073 : 
; 1074 :    /*----------------*/
; 1075 :    /* compute output */
; 1076 :    /*----------------*/
; 1077 :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1078 :    save[2] = k*(save[5] + c*save[4] + d*save[3]) -  a*save[1] - b*save[0];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _c$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _d$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _k$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _a$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm0, xmm1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _b$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1079 : 
; 1080 :    /*----------------------------------*/
; 1081 :    /* save values from past two frames */
; 1082 :    /*----------------------------------*/
; 1083 :    if(*jstart >= 2)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@F8Tust

; 1084 :    {
; 1085 :       save[0]=save[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1086 :       save[3]=save[4];

	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN2@F8Tust:

; 1087 :    }
; 1088 : 
; 1089 :    /*---------------------------------*/
; 1090 :    /* save values from the last frame */
; 1091 :    /*---------------------------------*/
; 1092 :    if(*jstart >= 1)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN1@F8Tust

; 1093 :    {
; 1094 :       save[1]=save[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1095 :       save[4]=save[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN1@F8Tust:

; 1096 :    }
; 1097 : 
; 1098 :    *jstart = *jstart + 1;

	mov	eax, DWORD PTR _jstart$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _jstart$[ebp]
	mov	DWORD PTR [edx], ecx

; 1099 :    return((SIM_FLOAT)save[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv267[ebp], xmm0
	fld	DWORD PTR tv267[ebp]

; 1100 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?F8Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z ENDP	; SIMLIB_MATH_CLASS::F8Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -48						; size = 4
tv271 = -44						; size = 4
tv216 = -40						; size = 4
tv209 = -36						; size = 4
tv197 = -32						; size = 4
tv275 = -28						; size = 4
tv191 = -24						; size = 4
_b$ = -20						; size = 4
_a$ = -16						; size = 4
_k$ = -12						; size = 4
_d$ = -8						; size = 4
_c$ = -4						; size = 4
_in$ = 8						; size = 4
_tau1$ = 12						; size = 4
_tau2$ = 16						; size = 4
_tau3$ = 20						; size = 4
_delt$ = 24						; size = 4
_save$ = 28						; size = 4
_jstart$ = 32						; size = 4
?F7Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z PROC	; SIMLIB_MATH_CLASS::F7Tust
; _this$ = ecx

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 987  : SIM_FLOAT a,b,c,d,k;
; 988  : 
; 989  :    /*----------------------------------*/
; 990  :    /* compute z-transform coefficients */
; 991  :    /*----------------------------------*/
; 992  :    a = -((SIM_FLOAT)exp(-delt/tau2) + (SIM_FLOAT)exp(-delt/tau3));

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv191[ebp]
	movss	xmm0, DWORD PTR tv191[ebp]
	movss	xmm1, DWORD PTR _delt$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm1, DWORD PTR _tau3$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv275[ebp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv197[ebp]
	movss	xmm0, DWORD PTR tv275[ebp]
	addss	xmm0, DWORD PTR tv197[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _a$[ebp], xmm0

; 993  :    b =   (SIM_FLOAT)exp(-delt*(1/tau2 + 1/tau3));

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, DWORD PTR _tau2$[ebp]
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, DWORD PTR _tau3$[ebp]
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _b$[ebp]

; 994  :    c =   1.0F - (SIM_FLOAT)exp(-delt/tau1);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv209[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 995  :    d =  -(SIM_FLOAT)exp(-delt/tau1);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv216[ebp]
	movss	xmm0, DWORD PTR tv216[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _d$[ebp], xmm0

; 996  :    if ( 1.0F+c+d == 0.0F) 

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _c$[ebp]
	addss	xmm0, DWORD PTR _d$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@F7Tust

; 997  : 	   k = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _k$[ebp], xmm0

; 998  :    else

	jmp	SHORT $LN3@F7Tust
$LN4@F7Tust:

; 999  : 	   k =  (1.0F + a + b)/(1.0F + c + d);

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _a$[ebp]
	addss	xmm0, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	addss	xmm1, DWORD PTR _c$[ebp]
	addss	xmm1, DWORD PTR _d$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _k$[ebp], xmm0
$LN3@F7Tust:

; 1000 :    
; 1001 : 
; 1002 :    /*----------------*/
; 1003 :    /* compute output */
; 1004 :    /*----------------*/
; 1005 :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1006 :    save[2] = k*(save[5] + c*save[4] + d*save[3]) -  a*save[1] - b*save[0];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _c$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _d$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _k$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _a$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm0, xmm1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _b$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1007 : 
; 1008 :    /*----------------------------------*/
; 1009 :    /* save values from past two frames */
; 1010 :    /*----------------------------------*/
; 1011 :    if(*jstart >= 2)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@F7Tust

; 1012 :    {
; 1013 :       save[0]=save[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1014 :       save[3]=save[4];

	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN2@F7Tust:

; 1015 :    }
; 1016 : 
; 1017 :    /*---------------------------------*/
; 1018 :    /* save values from the last frame */
; 1019 :    /*---------------------------------*/
; 1020 :    if(*jstart >= 1)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN1@F7Tust

; 1021 :    {
; 1022 :       save[1]=save[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 1023 :       save[4]=save[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN1@F7Tust:

; 1024 :    }
; 1025 : 
; 1026 :    *jstart = *jstart + 1;

	mov	eax, DWORD PTR _jstart$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _jstart$[ebp]
	mov	DWORD PTR [edx], ecx

; 1027 :     return((SIM_FLOAT)save[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv271[ebp], xmm0
	fld	DWORD PTR tv271[ebp]

; 1028 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?F7Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z ENDP	; SIMLIB_MATH_CLASS::F7Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
tv239 = -40						; size = 4
_b$ = -36						; size = 4
_a$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_e1$ = -20						; size = 4
_d1$ = -16						; size = 4
_c1$ = -12						; size = 4
_b1$ = -8						; size = 4
_a1$ = -4						; size = 4
_in$ = 8						; size = 4
_zeta$ = 12						; size = 4
_omega$ = 16						; size = 4
_delt$ = 20						; size = 4
_save$ = 24						; size = 4
_jstart$ = 28						; size = 4
?F6Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAMPAH@Z PROC	; SIMLIB_MATH_CLASS::F6Tust
; _this$ = ecx

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 911  : SIM_FLOAT a1,b1,c1,d1,e1,a,b,c,d;
; 912  : 
; 913  :    /*----------------------------------*/
; 914  :    /* compute z-transform coefficients */
; 915  :    /*----------------------------------*/
; 916  :    a1 =  1.0F + delt*zeta*omega + 0.25F*(omega*delt)*(omega*delt);

	movss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR _omega$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	mulss	xmm1, DWORD PTR __real@3e800000
	movss	xmm2, DWORD PTR _omega$[ebp]
	mulss	xmm2, DWORD PTR _delt$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	movss	DWORD PTR _a1$[ebp], xmm0

; 917  :    b1 = -2.0F + 0.5F*(omega*delt)*(omega*delt);

	movss	xmm0, DWORD PTR _omega$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _omega$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _b1$[ebp], xmm0

; 918  :    c1 =  1.0F - delt*zeta*omega + 0.25F*(omega*delt)*(omega*delt);

	movss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _omega$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	xmm2, DWORD PTR _omega$[ebp]
	mulss	xmm2, DWORD PTR _delt$[ebp]
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	DWORD PTR _c1$[ebp], xmm1

; 919  :    d1 =  0.5F*delt*omega*omega;

	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _d1$[ebp], xmm0

; 920  :    e1 = -0.5F*delt*omega*omega;

	movss	xmm0, DWORD PTR __real@bf000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _e1$[ebp], xmm0

; 921  :    a  = b1/a1;

	movss	xmm0, DWORD PTR _b1$[ebp]
	divss	xmm0, DWORD PTR _a1$[ebp]
	movss	DWORD PTR _a$[ebp], xmm0

; 922  :    b  = c1/a1;

	movss	xmm0, DWORD PTR _c1$[ebp]
	divss	xmm0, DWORD PTR _a1$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 923  :    c  = d1/a1;

	movss	xmm0, DWORD PTR _d1$[ebp]
	divss	xmm0, DWORD PTR _a1$[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 924  :    d  = e1/a1;

	movss	xmm0, DWORD PTR _e1$[ebp]
	divss	xmm0, DWORD PTR _a1$[ebp]
	movss	DWORD PTR _d$[ebp], xmm0

; 925  : 
; 926  :    /*----------------*/
; 927  :    /* compute output */
; 928  :    /*----------------*/
; 929  :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 930  :    save[2] = c*save[5] + d*save[3] - a*save[1] - b*save[0];

	mov	edx, 4
	imul	edx, 5
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _c$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _d$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _a$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm0, xmm1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _b$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 931  : 
; 932  :    /*----------------------------------*/
; 933  :    /* save values from past two frames */
; 934  :    /*----------------------------------*/
; 935  :    if(*jstart >= 2)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@F6Tust

; 936  :    {
; 937  :       save[0]=save[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 938  :       save[3]=save[4];

	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN2@F6Tust:

; 939  :    }
; 940  : 
; 941  :    /*---------------------------------*/
; 942  :    /* save values from the last frame */
; 943  :    /*---------------------------------*/
; 944  :    if(*jstart >= 1)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN1@F6Tust

; 945  :    {
; 946  :       save[1]=save[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 947  :       save[4]=save[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN1@F6Tust:

; 948  :    }
; 949  : 
; 950  :    *jstart = *jstart + 1;

	mov	eax, DWORD PTR _jstart$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _jstart$[ebp]
	mov	DWORD PTR [edx], ecx

; 951  :    return((SIM_FLOAT)save[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv239[ebp], xmm0
	fld	DWORD PTR tv239[ebp]

; 952  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?F6Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAMPAH@Z ENDP	; SIMLIB_MATH_CLASS::F6Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -48						; size = 4
tv260 = -44						; size = 4
_k$ = -40						; size = 4
tv200 = -36						; size = 4
tv264 = -32						; size = 4
_b$ = -28						; size = 4
tv193 = -24						; size = 4
tv186 = -20						; size = 4
_d$ = -16						; size = 4
_c$ = -12						; size = 4
_a$ = -8						; size = 4
_e$ = -4						; size = 4
_in$ = 8						; size = 4
_tau$ = 12						; size = 4
_zeta$ = 16						; size = 4
_omega$ = 20						; size = 4
_delt$ = 24						; size = 4
_save$ = 28						; size = 4
_jstart$ = 32						; size = 4
?F5Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z PROC	; SIMLIB_MATH_CLASS::F5Tust
; _this$ = ecx

; 837  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 838  : SIM_FLOAT a,b,c,d,e,k;
; 839  : 
; 840  :    /*----------------------------------*/
; 841  :    /* compute z-transform coefficients */
; 842  :    /*----------------------------------*/
; 843  :    a = zeta*omega;

	movss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _a$[ebp], xmm0

; 844  :    b = omega*(SIM_FLOAT)sqrt(1-zeta*zeta);

	movss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _zeta$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv186[ebp]
	movss	xmm0, DWORD PTR tv186[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 845  :    c = 2*(SIM_FLOAT)exp(-a*delt)*(SIM_FLOAT)cos(b*delt);

	movss	xmm0, DWORD PTR _a$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv193[ebp]
	movss	xmm0, DWORD PTR tv193[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _b$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv264[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv200[ebp]
	movss	xmm0, DWORD PTR tv264[ebp]
	mulss	xmm0, DWORD PTR tv200[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 846  :    d = (SIM_FLOAT)exp(-2*a*delt);

	movss	xmm0, DWORD PTR __real@c0000000
	mulss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _d$[ebp]

; 847  :    e = (SIM_FLOAT)exp(-delt/tau);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _e$[ebp]

; 848  :    k  = (1+c+d)/(2.0F*(1+e));

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _c$[ebp]
	addss	xmm0, DWORD PTR _d$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	addss	xmm1, DWORD PTR _e$[ebp]
	mulss	xmm1, DWORD PTR __real@40000000
	divss	xmm0, xmm1
	movss	DWORD PTR _k$[ebp], xmm0

; 849  : 
; 850  :    /*----------------*/
; 851  :    /* compute output */
; 852  :    /*----------------*/
; 853  :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 854  :    save[2] = k*(save[5] - (1+e)*save[4] + e*save[1]) + c*save[1] - d*save[0];

	mov	edx, 4
	imul	edx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _e$[ebp]
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _e$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm1, xmm0
	mulss	xmm1, DWORD PTR _k$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _c$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm1

; 855  : 
; 856  :    /*----------------------------------*/
; 857  :    /* save values from past two frames */
; 858  :    /*----------------------------------*/
; 859  :    if(*jstart >= 2)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@F5Tust

; 860  :    {
; 861  :       save[0]=save[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 862  :       save[3]=save[4];

	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN2@F5Tust:

; 863  :    }
; 864  : 
; 865  :    /*---------------------------------*/
; 866  :    /* save values from the last frame */
; 867  :    /*---------------------------------*/
; 868  :    if(*jstart >= 1)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN1@F5Tust

; 869  :    {
; 870  :       save[1]=save[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 871  :       save[4]=save[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN1@F5Tust:

; 872  :    }
; 873  : 
; 874  :    *jstart = *jstart + 1;

	mov	eax, DWORD PTR _jstart$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _jstart$[ebp]
	mov	DWORD PTR [edx], ecx

; 875  :    return((SIM_FLOAT)save[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv260[ebp], xmm0
	fld	DWORD PTR tv260[ebp]

; 876  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?F5Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z ENDP	; SIMLIB_MATH_CLASS::F5Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -48						; size = 4
tv260 = -44						; size = 4
_k$ = -40						; size = 4
tv200 = -36						; size = 4
tv264 = -32						; size = 4
_b$ = -28						; size = 4
tv193 = -24						; size = 4
tv186 = -20						; size = 4
_d$ = -16						; size = 4
_c$ = -12						; size = 4
_a$ = -8						; size = 4
_e$ = -4						; size = 4
_in$ = 8						; size = 4
_tau$ = 12						; size = 4
_zeta$ = 16						; size = 4
_omega$ = 20						; size = 4
_delt$ = 24						; size = 4
_save$ = 28						; size = 4
_jstart$ = 32						; size = 4
?F4Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z PROC	; SIMLIB_MATH_CLASS::F4Tust
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 764  : SIM_FLOAT a,b,c,d,e,k;
; 765  : 
; 766  :    /*----------------------------------*/
; 767  :    /* compute z-transform coefficients */
; 768  :    /*----------------------------------*/
; 769  :    a = zeta*omega;

	movss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _a$[ebp], xmm0

; 770  :    b = omega*(SIM_FLOAT)sqrt(1-zeta*zeta);

	movss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _zeta$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv186[ebp]
	movss	xmm0, DWORD PTR tv186[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 771  :    c = 2*(SIM_FLOAT)exp(-a*delt)*(SIM_FLOAT)cos(b*delt);

	movss	xmm0, DWORD PTR _a$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv193[ebp]
	movss	xmm0, DWORD PTR tv193[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _b$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv264[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv200[ebp]
	movss	xmm0, DWORD PTR tv264[ebp]
	mulss	xmm0, DWORD PTR tv200[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 772  :    d = (SIM_FLOAT)exp(-2*a*delt);

	movss	xmm0, DWORD PTR __real@c0000000
	mulss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _d$[ebp]

; 773  :    e = (SIM_FLOAT)exp(-delt/tau);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _e$[ebp]

; 774  :    k  = (1-c+d)/(2.0F*(1-e));

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _c$[ebp]
	addss	xmm0, DWORD PTR _d$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _e$[ebp]
	mulss	xmm1, DWORD PTR __real@40000000
	divss	xmm0, xmm1
	movss	DWORD PTR _k$[ebp], xmm0

; 775  : 
; 776  :    /*----------------*/
; 777  :    /* compute output */
; 778  :    /*----------------*/
; 779  :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 780  :    save[2] = k*(save[5] + (1-e)*save[4] - e*save[3]) + c*save[1] - d*save[0];

	mov	edx, 4
	imul	edx, 5
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _e$[ebp]
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _e$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _k$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _c$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _d$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 781  : 
; 782  :    /*----------------------------------*/
; 783  :    /* save values from past two frames */
; 784  :    /*----------------------------------*/
; 785  :    if(*jstart >= 2)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@F4Tust

; 786  :    {
; 787  :       save[0]=save[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 788  :       save[3]=save[4];

	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN2@F4Tust:

; 789  :    }
; 790  : 
; 791  :    /*---------------------------------*/
; 792  :    /* save values from the last frame */
; 793  :    /*---------------------------------*/
; 794  :    if(*jstart >= 1)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN1@F4Tust

; 795  :    {
; 796  :       save[1]=save[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 797  :       save[4]=save[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN1@F4Tust:

; 798  :    }
; 799  : 
; 800  :    *jstart = *jstart + 1;

	mov	eax, DWORD PTR _jstart$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _jstart$[ebp]
	mov	DWORD PTR [edx], ecx

; 801  :    return((SIM_FLOAT)save[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv260[ebp], xmm0
	fld	DWORD PTR tv260[ebp]

; 802  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?F4Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMQAMPAH@Z ENDP	; SIMLIB_MATH_CLASS::F4Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
tv234 = -40						; size = 4
_k$ = -36						; size = 4
tv185 = -32						; size = 4
tv238 = -28						; size = 4
_b$ = -24						; size = 4
tv178 = -20						; size = 4
tv171 = -16						; size = 4
_d$ = -12						; size = 4
_c$ = -8						; size = 4
_a$ = -4						; size = 4
_in$ = 8						; size = 4
_zeta$ = 12						; size = 4
_omega$ = 16						; size = 4
_delt$ = 20						; size = 4
_save$ = 24						; size = 4
?F3Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAM@Z PROC		; SIMLIB_MATH_CLASS::F3Tust
; _this$ = ecx

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 698  : SIM_FLOAT a,b,c,d,k;
; 699  : 
; 700  :    /*----------------------------------*/
; 701  :    /* compute z-transform coefficients */
; 702  :    /*----------------------------------*/
; 703  :    a = zeta*omega;

	movss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _a$[ebp], xmm0

; 704  :    b = omega*(SIM_FLOAT)sqrt(1-zeta*zeta);

	movss	xmm0, DWORD PTR _zeta$[ebp]
	mulss	xmm0, DWORD PTR _zeta$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv171[ebp]
	movss	xmm0, DWORD PTR tv171[ebp]
	mulss	xmm0, DWORD PTR _omega$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 705  :    c = 2*(SIM_FLOAT)exp(-a*delt)*(SIM_FLOAT)cos(b*delt);

	movss	xmm0, DWORD PTR _a$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv178[ebp]
	movss	xmm0, DWORD PTR tv178[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _b$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv238[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv185[ebp]
	movss	xmm0, DWORD PTR tv238[ebp]
	mulss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR _c$[ebp], xmm0

; 706  :    d = (SIM_FLOAT)exp(-2*a*delt);

	movss	xmm0, DWORD PTR __real@c0000000
	mulss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _d$[ebp]

; 707  :    k  = (1-c+d)/4.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _c$[ebp]
	addss	xmm0, DWORD PTR _d$[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR _k$[ebp], xmm0

; 708  : 
; 709  :    /*----------------*/
; 710  :    /* compute output */
; 711  :    /*----------------*/
; 712  :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 713  :    save[2] = k*(save[5] + 2.0F*save[4] + save[3]) + c*save[1] - d*save[0]; 

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _save$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _k$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _c$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR _d$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx]
	subss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 714  : 
; 715  :    /*----------------------------------*/
; 716  :    /* save values from past two frames */
; 717  :    /*----------------------------------*/
; 718  :    save[0]=save[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 719  :    save[3]=save[4];

	mov	ecx, 4
	shl	ecx, 2
	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 720  : 
; 721  :    /*---------------------------------*/
; 722  :    /* save values from the last frame */
; 723  :    /*---------------------------------*/
; 724  :    save[1]=save[2];

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx

; 725  :    save[4]=save[5];

	mov	eax, 4
	imul	eax, 5
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 726  : 
; 727  :    return((SIM_FLOAT)save[2]);

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv234[ebp], xmm0
	fld	DWORD PTR tv234[ebp]

; 728  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?F3Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAM@Z ENDP		; SIMLIB_MATH_CLASS::F3Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv174 = -16						; size = 4
_k$ = -12						; size = 4
_k1$ = -8						; size = 4
_k2$ = -4						; size = 4
_in$ = 8						; size = 4
_tau1$ = 12						; size = 4
_tau2$ = 16						; size = 4
_delt$ = 20						; size = 4
_save$ = 24						; size = 4
?F2Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAM@Z PROC		; SIMLIB_MATH_CLASS::F2Tust
; _this$ = ecx

; 642  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 643  : SIM_FLOAT k1,k2,k;
; 644  : 
; 645  :    /*-----------------------*/
; 646  :    /* equation coefficients */
; 647  :    /*-----------------------*/
; 648  :    k1 = (SIM_FLOAT)exp(-delt/tau1);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _k1$[ebp]

; 649  :    k2 = (SIM_FLOAT)exp(-delt/tau2);

	movss	xmm0, DWORD PTR _delt$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm0, DWORD PTR _tau2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _k2$[ebp]

; 650  :    k  = (1-k2)/(1-k1);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _k2$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _k1$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _k$[ebp], xmm0

; 651  : 
; 652  :    /*----------------*/
; 653  :    /* compute output */
; 654  :    /*----------------*/
; 655  :    save[3] = in;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 656  :    save[1] = save[0]*k2 + k*(save[3] - save[2]*k1);

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _k2$[ebp]
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _k1$[ebp]
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm2, DWORD PTR [edx+ecx]
	subss	xmm2, xmm1
	mulss	xmm2, DWORD PTR _k$[ebp]
	addss	xmm0, xmm2
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 657  : 
; 658  :    /*---------------------------------*/
; 659  :    /* save values from the last frame */
; 660  :    /*---------------------------------*/
; 661  :    save[0]=save[1];

	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx

; 662  :    save[2]=save[3];

	mov	eax, 4
	imul	eax, 3
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 663  : 
; 664  :    return((SIM_FLOAT)save[1]);

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv174[ebp], xmm0
	fld	DWORD PTR tv174[ebp]

; 665  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?F2Tust@SIMLIB_MATH_CLASS@@QAEMMMMMQAM@Z ENDP		; SIMLIB_MATH_CLASS::F2Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -76						; size = 4
tv336 = -72						; size = 4
_k$ = -68						; size = 4
tv275 = -64						; size = 4
tv342 = -60						; size = 4
_y2$ = -56						; size = 4
tv268 = -52						; size = 4
tv262 = -48						; size = 4
tv340 = -44						; size = 4
_y1$ = -40						; size = 4
tv223 = -36						; size = 4
tv216 = -32						; size = 4
tv208 = -28						; size = 4
_b2$ = -24						; size = 4
_a2$ = -20						; size = 4
_b1$ = -16						; size = 4
_a1$ = -12						; size = 4
_x2$ = -8						; size = 4
_x1$ = -4						; size = 4
_in$ = 8						; size = 4
_zeta1$ = 12						; size = 4
_omega1$ = 16						; size = 4
_zeta2$ = 20						; size = 4
_omega2$ = 24						; size = 4
_delt$ = 28						; size = 4
_save$ = 32						; size = 4
_jstart$ = 36						; size = 4
?F1Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMMQAMPAH@Z PROC	; SIMLIB_MATH_CLASS::F1Tust
; _this$ = ecx

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 567  : SIM_FLOAT x1,x2,y1,y2,a1,a2,b1,b2,k;
; 568  : 
; 569  :    /*----------------------------------*/
; 570  :    /* compute z-transform coefficients */
; 571  :    /*----------------------------------*/
; 572  :    x1 = zeta1*omega1;

	movss	xmm0, DWORD PTR _zeta1$[ebp]
	mulss	xmm0, DWORD PTR _omega1$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 573  :    x2 = zeta2*omega2;

	movss	xmm0, DWORD PTR _zeta2$[ebp]
	mulss	xmm0, DWORD PTR _omega2$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 574  :    y1 = omega1*(SIM_FLOAT)sqrt(1-zeta1*zeta1);

	movss	xmm0, DWORD PTR _zeta1$[ebp]
	mulss	xmm0, DWORD PTR _zeta1$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv208[ebp]
	movss	xmm0, DWORD PTR tv208[ebp]
	mulss	xmm0, DWORD PTR _omega1$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 575  :    y2 = omega2*(SIM_FLOAT)sqrt(1-zeta2*zeta2);

	movss	xmm0, DWORD PTR _zeta2$[ebp]
	mulss	xmm0, DWORD PTR _zeta2$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv216[ebp]
	movss	xmm0, DWORD PTR tv216[ebp]
	mulss	xmm0, DWORD PTR _omega2$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 576  : 
; 577  :    a1 = 2*(SIM_FLOAT)exp(-x1*delt)*(SIM_FLOAT)cos(y1*delt);

	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv223[ebp]
	movss	xmm0, DWORD PTR tv223[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _y1$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv340[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv262[ebp]
	movss	xmm0, DWORD PTR tv340[ebp]
	mulss	xmm0, DWORD PTR tv262[ebp]
	movss	DWORD PTR _a1$[ebp], xmm0

; 578  :    a2 = 2*(SIM_FLOAT)exp(-x2*delt)*(SIM_FLOAT)cos(y2*delt);

	movss	xmm0, DWORD PTR _x2$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR tv268[ebp]
	movss	xmm0, DWORD PTR tv268[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _y2$[ebp]
	mulss	xmm1, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv342[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv275[ebp]
	movss	xmm0, DWORD PTR tv342[ebp]
	mulss	xmm0, DWORD PTR tv275[ebp]
	movss	DWORD PTR _a2$[ebp], xmm0

; 579  :    b1 = (SIM_FLOAT)exp(-2*x1*delt);

	movss	xmm0, DWORD PTR __real@c0000000
	mulss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _b1$[ebp]

; 580  :    b2 = (SIM_FLOAT)exp(-2*x2*delt);

	movss	xmm0, DWORD PTR __real@c0000000
	mulss	xmm0, DWORD PTR _x2$[ebp]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?exp@@YAMM@Z				; exp
	add	esp, 4
	fstp	DWORD PTR _b2$[ebp]

; 581  :    k  = (1-a2+b2)/(1-a1+b1)*(omega1/omega2)*(omega1/omega2);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _a2$[ebp]
	addss	xmm0, DWORD PTR _b2$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _a1$[ebp]
	addss	xmm1, DWORD PTR _b1$[ebp]
	divss	xmm0, xmm1
	movss	xmm1, DWORD PTR _omega1$[ebp]
	divss	xmm1, DWORD PTR _omega2$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _omega1$[ebp]
	divss	xmm1, DWORD PTR _omega2$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _k$[ebp], xmm0

; 582  : 
; 583  :    /*----------------*/
; 584  :    /* compute output */
; 585  :    /*----------------*/
; 586  :    save[5] = in;

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 587  :    save[4] = k*(save[5] - a1*save[4] + b1*save[3]) + a2*save[1] - b2*save[0];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _a1$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	subss	xmm1, xmm0
	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _b1$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm1, xmm0
	mulss	xmm1, DWORD PTR _k$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _a2$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR _b2$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _save$[ebp]
	movss	DWORD PTR [edx+ecx], xmm1

; 588  : 
; 589  :    /*----------------------------------*/
; 590  :    /* save values from past two frames */
; 591  :    /*----------------------------------*/
; 592  :    if(*jstart >=2)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@F1Tust

; 593  :    {
; 594  :       save[0]=save[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 595  :       save[3]=save[4];

	mov	edx, 4
	shl	edx, 2
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN2@F1Tust:

; 596  :    }
; 597  : 
; 598  :    /*---------------------------------*/
; 599  :    /* save values from the last frame */
; 600  :    /*---------------------------------*/
; 601  :    if(*jstart >=1)

	mov	eax, DWORD PTR _jstart$[ebp]
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN1@F1Tust

; 602  :    {
; 603  :       save[1]=save[2];

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 604  :       save[4]=save[5];

	mov	edx, 4
	imul	edx, 5
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _save$[ebp]
	mov	esi, DWORD PTR _save$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
$LN1@F1Tust:

; 605  :    }
; 606  : 
; 607  :    *jstart = *jstart + 1;

	mov	eax, DWORD PTR _jstart$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _jstart$[ebp]
	mov	DWORD PTR [edx], ecx

; 608  : 
; 609  :    return((SIM_FLOAT)save[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _save$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv336[ebp], xmm0
	fld	DWORD PTR tv336[ebp]

; 610  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?F1Tust@SIMLIB_MATH_CLASS@@QAEMMMMMMMQAMPAH@Z ENDP	; SIMLIB_MATH_CLASS::F1Tust
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 8
_max_angle$ = 16					; size = 8
?ResolveWrap@SIMLIB_MATH_CLASS@@QAENNN@Z PROC		; SIMLIB_MATH_CLASS::ResolveWrap
; _this$ = ecx

; 522  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 523  :         input = Resolve (input, 2.0 * max_angle);

	movsd	xmm0, QWORD PTR __real@4000000000000000
	mulsd	xmm0, QWORD PTR _max_angle$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _input$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Resolve@SIMLIB_MATH_CLASS@@QAENNN@Z	; SIMLIB_MATH_CLASS::Resolve
	fstp	QWORD PTR _input$[ebp]

; 524  : 
; 525  :         if (input > max_angle)

	movsd	xmm0, QWORD PTR _input$[ebp]
	comisd	xmm0, QWORD PTR _max_angle$[ebp]
	jbe	SHORT $LN3@ResolveWra

; 526  :                 input -= max_angle;

	movsd	xmm0, QWORD PTR _input$[ebp]
	subsd	xmm0, QWORD PTR _max_angle$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN1@ResolveWra
$LN3@ResolveWra:

; 527  :         else if (input < -max_angle)

	movsd	xmm0, QWORD PTR _max_angle$[ebp]
	xorpd	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	comisd	xmm0, QWORD PTR _input$[ebp]
	jbe	SHORT $LN1@ResolveWra

; 528  :                 input += max_angle;

	movsd	xmm0, QWORD PTR _input$[ebp]
	addsd	xmm0, QWORD PTR _max_angle$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
$LN1@ResolveWra:

; 529  : 
; 530  :         return (input);

	fld	QWORD PTR _input$[ebp]

; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ResolveWrap@SIMLIB_MATH_CLASS@@QAENNN@Z ENDP		; SIMLIB_MATH_CLASS::ResolveWrap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 8
_max_angle$ = 16					; size = 8
?Resolve0@SIMLIB_MATH_CLASS@@QAENNN@Z PROC		; SIMLIB_MATH_CLASS::Resolve0
; _this$ = ecx

; 453  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@Resolve0:

; 454  :         while (input >= max_angle)

	movsd	xmm0, QWORD PTR _input$[ebp]
	comisd	xmm0, QWORD PTR _max_angle$[ebp]
	jb	SHORT $LN3@Resolve0

; 455  :                 input -= max_angle;

	movsd	xmm0, QWORD PTR _input$[ebp]
	subsd	xmm0, QWORD PTR _max_angle$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN4@Resolve0
$LN3@Resolve0:

; 456  : 
; 457  :         while (input < 0.0F)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _input$[ebp]
	jbe	SHORT $LN1@Resolve0

; 458  :                 input += max_angle;

	movsd	xmm0, QWORD PTR _input$[ebp]
	addsd	xmm0, QWORD PTR _max_angle$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN3@Resolve0
$LN1@Resolve0:

; 459  : 
; 460  :         return (input);

	fld	QWORD PTR _input$[ebp]

; 461  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Resolve0@SIMLIB_MATH_CLASS@@QAENNN@Z ENDP		; SIMLIB_MATH_CLASS::Resolve0
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_delta$ = -12						; size = 8
_this$ = -4						; size = 4
_input$ = 8						; size = 8
_max_angle$ = 16					; size = 8
?Resolve@SIMLIB_MATH_CLASS@@QAENNN@Z PROC		; SIMLIB_MATH_CLASS::Resolve
; _this$ = ecx

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 385  : register SIM_DOUBLE delta;
; 386  : 
; 387  :         delta = 2.0F * max_angle;

	movsd	xmm0, QWORD PTR __real@4000000000000000
	mulsd	xmm0, QWORD PTR _max_angle$[ebp]
	movsd	QWORD PTR _delta$[ebp], xmm0
$LN4@Resolve:

; 388  :         while (input >= max_angle)

	movsd	xmm0, QWORD PTR _input$[ebp]
	comisd	xmm0, QWORD PTR _max_angle$[ebp]
	jb	SHORT $LN3@Resolve

; 389  :                 input -= delta;

	movsd	xmm0, QWORD PTR _input$[ebp]
	subsd	xmm0, QWORD PTR _delta$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN4@Resolve
$LN3@Resolve:

; 390  : 
; 391  :         while (input < -max_angle)

	movsd	xmm0, QWORD PTR _max_angle$[ebp]
	xorpd	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	comisd	xmm0, QWORD PTR _input$[ebp]
	jbe	SHORT $LN1@Resolve

; 392  :                 input += delta;

	movsd	xmm0, QWORD PTR _input$[ebp]
	addsd	xmm0, QWORD PTR _delta$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN3@Resolve
$LN1@Resolve:

; 393  : 
; 394  :         return (input);

	fld	QWORD PTR _input$[ebp]

; 395  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Resolve@SIMLIB_MATH_CLASS@@QAENNN@Z ENDP		; SIMLIB_MATH_CLASS::Resolve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 8
_min_breakout$ = 16					; size = 8
_max_breakout$ = 24					; size = 8
?DeadBand@SIMLIB_MATH_CLASS@@QAENNNN@Z PROC		; SIMLIB_MATH_CLASS::DeadBand
; _this$ = ecx

; 314  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  :         if (input > max_breakout)

	movsd	xmm0, QWORD PTR _input$[ebp]
	comisd	xmm0, QWORD PTR _max_breakout$[ebp]
	jbe	SHORT $LN4@DeadBand

; 316  :                 input -= max_breakout;

	movsd	xmm0, QWORD PTR _input$[ebp]
	subsd	xmm0, QWORD PTR _max_breakout$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN1@DeadBand
$LN4@DeadBand:

; 317  :         else if (input < min_breakout)

	movsd	xmm0, QWORD PTR _min_breakout$[ebp]
	comisd	xmm0, QWORD PTR _input$[ebp]
	jbe	SHORT $LN2@DeadBand

; 318  :                 input -= min_breakout;

	movsd	xmm0, QWORD PTR _input$[ebp]
	subsd	xmm0, QWORD PTR _min_breakout$[ebp]
	movsd	QWORD PTR _input$[ebp], xmm0

; 319  :         else

	jmp	SHORT $LN1@DeadBand
$LN2@DeadBand:

; 320  :                 input = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _input$[ebp], xmm0
$LN1@DeadBand:

; 321  : 
; 322  :         return (input);

	fld	QWORD PTR _input$[ebp]

; 323  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DeadBand@SIMLIB_MATH_CLASS@@QAENNNN@Z ENDP		; SIMLIB_MATH_CLASS::DeadBand
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
tv92 = -12						; size = 8
_this$ = -4						; size = 4
_input$ = 8						; size = 8
_cur$ = 16						; size = 8
_max_rate$ = 24						; size = 8
_rate$ = 32						; size = 4
_delt$ = 36						; size = 8
?RateLimit@SIMLIB_MATH_CLASS@@QAENNNNPANN@Z PROC	; SIMLIB_MATH_CLASS::RateLimit
; _this$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 250  :         *rate = (input - cur) / delt;

	movsd	xmm0, QWORD PTR _input$[ebp]
	subsd	xmm0, QWORD PTR _cur$[ebp]
	divsd	xmm0, QWORD PTR _delt$[ebp]
	mov	eax, DWORD PTR _rate$[ebp]
	movsd	QWORD PTR [eax], xmm0

; 251  :         *rate = Limit(*rate, -max_rate, max_rate);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _max_rate$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movsd	xmm0, QWORD PTR _max_rate$[ebp]
	xorpd	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _rate$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Limit@SIMLIB_MATH_CLASS@@QAENNNN@Z	; SIMLIB_MATH_CLASS::Limit
	mov	edx, DWORD PTR _rate$[ebp]
	fstp	QWORD PTR [edx]

; 252  :         return (cur + *rate * delt);

	mov	eax, DWORD PTR _rate$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	mulsd	xmm0, QWORD PTR _delt$[ebp]
	addsd	xmm0, QWORD PTR _cur$[ebp]
	movsd	QWORD PTR tv92[ebp], xmm0
	fld	QWORD PTR tv92[ebp]

; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?RateLimit@SIMLIB_MATH_CLASS@@QAENNNNPANN@Z ENDP	; SIMLIB_MATH_CLASS::RateLimit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
tv69 = -28						; size = 8
tv68 = -20						; size = 8
tv65 = -12						; size = 8
_this$ = -4						; size = 4
_input$ = 8						; size = 8
_min_val$ = 16						; size = 8
_max_val$ = 24						; size = 8
?Limit@SIMLIB_MATH_CLASS@@QAENNNN@Z PROC		; SIMLIB_MATH_CLASS::Limit
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 188  :         return (min ( max ( input, min_val ), max_val ) );

	movsd	xmm0, QWORD PTR _input$[ebp]
	comisd	xmm0, QWORD PTR _min_val$[ebp]
	jbe	SHORT $LN3@Limit
	movsd	xmm0, QWORD PTR _input$[ebp]
	movsd	QWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN4@Limit
$LN3@Limit:
	movsd	xmm0, QWORD PTR _min_val$[ebp]
	movsd	QWORD PTR tv65[ebp], xmm0
$LN4@Limit:
	movsd	xmm0, QWORD PTR _max_val$[ebp]
	comisd	xmm0, QWORD PTR tv65[ebp]
	jbe	SHORT $LN7@Limit
	movsd	xmm0, QWORD PTR _input$[ebp]
	comisd	xmm0, QWORD PTR _min_val$[ebp]
	jbe	SHORT $LN5@Limit
	movsd	xmm0, QWORD PTR _input$[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN6@Limit
$LN5@Limit:
	movsd	xmm0, QWORD PTR _min_val$[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
$LN6@Limit:
	movsd	xmm0, QWORD PTR tv68[ebp]
	movsd	QWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN8@Limit
$LN7@Limit:
	movsd	xmm0, QWORD PTR _max_val$[ebp]
	movsd	QWORD PTR tv69[ebp], xmm0
$LN8@Limit:
	fld	QWORD PTR tv69[ebp]

; 189  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Limit@SIMLIB_MATH_CLASS@@QAENNNN@Z ENDP		; SIMLIB_MATH_CLASS::Limit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_max_angle$ = 12					; size = 4
?ResolveWrap@SIMLIB_MATH_CLASS@@QAEMMM@Z PROC		; SIMLIB_MATH_CLASS::ResolveWrap
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  :         input = Resolve (input, 2.0F * max_angle);

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _max_angle$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _input$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Resolve@SIMLIB_MATH_CLASS@@QAEMMM@Z	; SIMLIB_MATH_CLASS::Resolve
	fstp	DWORD PTR _input$[ebp]

; 489  : 
; 490  :         if (input > max_angle)

	movss	xmm0, DWORD PTR _input$[ebp]
	comiss	xmm0, DWORD PTR _max_angle$[ebp]
	jbe	SHORT $LN3@ResolveWra

; 491  :                 input = 2.0F * max_angle - input;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _max_angle$[ebp]
	subss	xmm0, DWORD PTR _input$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN1@ResolveWra
$LN3@ResolveWra:

; 492  :         else if (input < -max_angle)

	movss	xmm0, DWORD PTR _max_angle$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _input$[ebp]
	jbe	SHORT $LN1@ResolveWra

; 493  :                 input = -2.0F * max_angle - input;

	movss	xmm0, DWORD PTR __real@c0000000
	mulss	xmm0, DWORD PTR _max_angle$[ebp]
	subss	xmm0, DWORD PTR _input$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
$LN1@ResolveWra:

; 494  : 
; 495  :         return (input);

	fld	DWORD PTR _input$[ebp]

; 496  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ResolveWrap@SIMLIB_MATH_CLASS@@QAEMMM@Z ENDP		; SIMLIB_MATH_CLASS::ResolveWrap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_max_angle$ = 12					; size = 4
?Resolve0@SIMLIB_MATH_CLASS@@QAEMMM@Z PROC		; SIMLIB_MATH_CLASS::Resolve0
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@Resolve0:

; 421  :         while (input >= max_angle)

	movss	xmm0, DWORD PTR _input$[ebp]
	comiss	xmm0, DWORD PTR _max_angle$[ebp]
	jb	SHORT $LN3@Resolve0

; 422  :                 input -= max_angle;

	movss	xmm0, DWORD PTR _input$[ebp]
	subss	xmm0, DWORD PTR _max_angle$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN4@Resolve0
$LN3@Resolve0:

; 423  : 
; 424  :         while (input < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _input$[ebp]
	jbe	SHORT $LN1@Resolve0

; 425  :                 input += max_angle;

	movss	xmm0, DWORD PTR _input$[ebp]
	addss	xmm0, DWORD PTR _max_angle$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN3@Resolve0
$LN1@Resolve0:

; 426  : 
; 427  :         return (input);

	fld	DWORD PTR _input$[ebp]

; 428  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Resolve0@SIMLIB_MATH_CLASS@@QAEMMM@Z ENDP		; SIMLIB_MATH_CLASS::Resolve0
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_delta$ = -4						; size = 4
_input$ = 8						; size = 4
_max_angle$ = 12					; size = 4
?Resolve@SIMLIB_MATH_CLASS@@QAEMMM@Z PROC		; SIMLIB_MATH_CLASS::Resolve
; _this$ = ecx

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 349  : register SIM_FLOAT delta;
; 350  : 
; 351  :         delta = 2.0F * max_angle;

	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _max_angle$[ebp]
	movss	DWORD PTR _delta$[ebp], xmm0
$LN4@Resolve:

; 352  :         while (input >= max_angle)

	movss	xmm0, DWORD PTR _input$[ebp]
	comiss	xmm0, DWORD PTR _max_angle$[ebp]
	jb	SHORT $LN3@Resolve

; 353  :                 input -= delta;

	movss	xmm0, DWORD PTR _input$[ebp]
	subss	xmm0, DWORD PTR _delta$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN4@Resolve
$LN3@Resolve:

; 354  : 
; 355  :         while (input < -max_angle)

	movss	xmm0, DWORD PTR _max_angle$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _input$[ebp]
	jbe	SHORT $LN1@Resolve

; 356  :                 input += delta;

	movss	xmm0, DWORD PTR _input$[ebp]
	addss	xmm0, DWORD PTR _delta$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN3@Resolve
$LN1@Resolve:

; 357  : 
; 358  :         return (input);

	fld	DWORD PTR _input$[ebp]

; 359  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Resolve@SIMLIB_MATH_CLASS@@QAEMMM@Z ENDP		; SIMLIB_MATH_CLASS::Resolve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_min_breakout$ = 12					; size = 4
_max_breakout$ = 16					; size = 4
?DeadBand@SIMLIB_MATH_CLASS@@QAEMMMM@Z PROC		; SIMLIB_MATH_CLASS::DeadBand
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 280  :         if (input > max_breakout)

	movss	xmm0, DWORD PTR _input$[ebp]
	comiss	xmm0, DWORD PTR _max_breakout$[ebp]
	jbe	SHORT $LN4@DeadBand

; 281  :                 input -= max_breakout;

	movss	xmm0, DWORD PTR _input$[ebp]
	subss	xmm0, DWORD PTR _max_breakout$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0
	jmp	SHORT $LN1@DeadBand
$LN4@DeadBand:

; 282  :         else if (input < min_breakout)

	movss	xmm0, DWORD PTR _min_breakout$[ebp]
	comiss	xmm0, DWORD PTR _input$[ebp]
	jbe	SHORT $LN2@DeadBand

; 283  :                 input -= min_breakout;

	movss	xmm0, DWORD PTR _input$[ebp]
	subss	xmm0, DWORD PTR _min_breakout$[ebp]
	movss	DWORD PTR _input$[ebp], xmm0

; 284  :         else

	jmp	SHORT $LN1@DeadBand
$LN2@DeadBand:

; 285  :                 input = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _input$[ebp], xmm0
$LN1@DeadBand:

; 286  : 
; 287  :         return (input);

	fld	DWORD PTR _input$[ebp]

; 288  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DeadBand@SIMLIB_MATH_CLASS@@QAEMMMM@Z ENDP		; SIMLIB_MATH_CLASS::DeadBand
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_input$ = 8						; size = 4
_cur$ = 12						; size = 4
_max_rate$ = 16						; size = 4
_rate$ = 20						; size = 4
_delt$ = 24						; size = 4
?RateLimit@SIMLIB_MATH_CLASS@@QAEMMMMPAMM@Z PROC	; SIMLIB_MATH_CLASS::RateLimit
; _this$ = ecx

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 218  :         *rate = (input - cur) / delt;

	movss	xmm0, DWORD PTR _input$[ebp]
	subss	xmm0, DWORD PTR _cur$[ebp]
	divss	xmm0, DWORD PTR _delt$[ebp]
	mov	eax, DWORD PTR _rate$[ebp]
	movss	DWORD PTR [eax], xmm0

; 219  :         *rate = Limit(*rate, -max_rate, max_rate);

	push	ecx
	movss	xmm0, DWORD PTR _max_rate$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _max_rate$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _rate$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Limit@SIMLIB_MATH_CLASS@@QAEMMMM@Z	; SIMLIB_MATH_CLASS::Limit
	mov	edx, DWORD PTR _rate$[ebp]
	fstp	DWORD PTR [edx]

; 220  :         return (cur + *rate * delt);

	mov	eax, DWORD PTR _rate$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _delt$[ebp]
	addss	xmm0, DWORD PTR _cur$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
	fld	DWORD PTR tv92[ebp]

; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?RateLimit@SIMLIB_MATH_CLASS@@QAEMMMMPAMM@Z ENDP	; SIMLIB_MATH_CLASS::RateLimit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv69 = -12						; size = 4
tv68 = -8						; size = 4
tv65 = -4						; size = 4
_input$ = 8						; size = 4
_min_val$ = 12						; size = 4
_max_val$ = 16						; size = 4
?Limit@SIMLIB_MATH_CLASS@@QAEMMMM@Z PROC		; SIMLIB_MATH_CLASS::Limit
; _this$ = ecx

; 159  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 160  :         return (min ( max ( input, min_val ), max_val ) );

	movss	xmm0, DWORD PTR _input$[ebp]
	comiss	xmm0, DWORD PTR _min_val$[ebp]
	jbe	SHORT $LN3@Limit
	movss	xmm0, DWORD PTR _input$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	jmp	SHORT $LN4@Limit
$LN3@Limit:
	movss	xmm0, DWORD PTR _min_val$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
$LN4@Limit:
	movss	xmm0, DWORD PTR _max_val$[ebp]
	comiss	xmm0, DWORD PTR tv65[ebp]
	jbe	SHORT $LN7@Limit
	movss	xmm0, DWORD PTR _input$[ebp]
	comiss	xmm0, DWORD PTR _min_val$[ebp]
	jbe	SHORT $LN5@Limit
	movss	xmm0, DWORD PTR _input$[ebp]
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN6@Limit
$LN5@Limit:
	movss	xmm0, DWORD PTR _min_val$[ebp]
	movss	DWORD PTR tv68[ebp], xmm0
$LN6@Limit:
	movss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN8@Limit
$LN7@Limit:
	movss	xmm0, DWORD PTR _max_val$[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
$LN8@Limit:
	fld	DWORD PTR tv69[ebp]

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Limit@SIMLIB_MATH_CLASS@@QAEMMMM@Z ENDP		; SIMLIB_MATH_CLASS::Limit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv69 = -12						; size = 4
tv68 = -8						; size = 4
tv65 = -4						; size = 4
_input$ = 8						; size = 4
_min_val$ = 12						; size = 4
_max_val$ = 16						; size = 4
?Limit@SIMLIB_MATH_CLASS@@QAEJJJJ@Z PROC		; SIMLIB_MATH_CLASS::Limit
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 132  :         return (min ( max ( input, min_val ), max_val ) );

	mov	eax, DWORD PTR _input$[ebp]
	cmp	eax, DWORD PTR _min_val$[ebp]
	jle	SHORT $LN3@Limit
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
	jmp	SHORT $LN4@Limit
$LN3@Limit:
	mov	edx, DWORD PTR _min_val$[ebp]
	mov	DWORD PTR tv65[ebp], edx
$LN4@Limit:
	mov	eax, DWORD PTR tv65[ebp]
	cmp	eax, DWORD PTR _max_val$[ebp]
	jge	SHORT $LN7@Limit
	mov	ecx, DWORD PTR _input$[ebp]
	cmp	ecx, DWORD PTR _min_val$[ebp]
	jle	SHORT $LN5@Limit
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN6@Limit
$LN5@Limit:
	mov	eax, DWORD PTR _min_val$[ebp]
	mov	DWORD PTR tv68[ebp], eax
$LN6@Limit:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN8@Limit
$LN7@Limit:
	mov	edx, DWORD PTR _max_val$[ebp]
	mov	DWORD PTR tv69[ebp], edx
$LN8@Limit:
	mov	eax, DWORD PTR tv69[ebp]

; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Limit@SIMLIB_MATH_CLASS@@QAEJJJJ@Z ENDP		; SIMLIB_MATH_CLASS::Limit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv69 = -12						; size = 4
tv68 = -8						; size = 4
tv65 = -4						; size = 4
_input$ = 8						; size = 4
_min_val$ = 12						; size = 4
_max_val$ = 16						; size = 4
?Limit@SIMLIB_MATH_CLASS@@QAEHHHH@Z PROC		; SIMLIB_MATH_CLASS::Limit
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 104  :         return (min ( max ( input, min_val ), max_val ) );

	mov	eax, DWORD PTR _input$[ebp]
	cmp	eax, DWORD PTR _min_val$[ebp]
	jle	SHORT $LN3@Limit
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
	jmp	SHORT $LN4@Limit
$LN3@Limit:
	mov	edx, DWORD PTR _min_val$[ebp]
	mov	DWORD PTR tv65[ebp], edx
$LN4@Limit:
	mov	eax, DWORD PTR tv65[ebp]
	cmp	eax, DWORD PTR _max_val$[ebp]
	jge	SHORT $LN7@Limit
	mov	ecx, DWORD PTR _input$[ebp]
	cmp	ecx, DWORD PTR _min_val$[ebp]
	jle	SHORT $LN5@Limit
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN6@Limit
$LN5@Limit:
	mov	eax, DWORD PTR _min_val$[ebp]
	mov	DWORD PTR tv68[ebp], eax
$LN6@Limit:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN8@Limit
$LN7@Limit:
	mov	edx, DWORD PTR _max_val$[ebp]
	mov	DWORD PTR tv69[ebp], edx
$LN8@Limit:
	mov	eax, DWORD PTR tv69[ebp]

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Limit@SIMLIB_MATH_CLASS@@QAEHHHH@Z ENDP		; SIMLIB_MATH_CLASS::Limit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\simlib\math.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv75 = -6						; size = 2
tv74 = -4						; size = 2
tv67 = -2						; size = 2
_input$ = 8						; size = 2
_min_val$ = 12						; size = 2
_max_val$ = 16						; size = 2
?Limit@SIMLIB_MATH_CLASS@@QAEFFFF@Z PROC		; SIMLIB_MATH_CLASS::Limit
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 76   :         return (min ( max ( input, min_val ), max_val ) );

	movsx	eax, WORD PTR _input$[ebp]
	movsx	ecx, WORD PTR _min_val$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN3@Limit
	mov	dx, WORD PTR _input$[ebp]
	mov	WORD PTR tv67[ebp], dx
	jmp	SHORT $LN4@Limit
$LN3@Limit:
	mov	ax, WORD PTR _min_val$[ebp]
	mov	WORD PTR tv67[ebp], ax
$LN4@Limit:
	movsx	ecx, WORD PTR tv67[ebp]
	movsx	edx, WORD PTR _max_val$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN7@Limit
	movsx	eax, WORD PTR _input$[ebp]
	movsx	ecx, WORD PTR _min_val$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN5@Limit
	mov	dx, WORD PTR _input$[ebp]
	mov	WORD PTR tv74[ebp], dx
	jmp	SHORT $LN6@Limit
$LN5@Limit:
	mov	ax, WORD PTR _min_val$[ebp]
	mov	WORD PTR tv74[ebp], ax
$LN6@Limit:
	mov	cx, WORD PTR tv74[ebp]
	mov	WORD PTR tv75[ebp], cx
	jmp	SHORT $LN8@Limit
$LN7@Limit:
	mov	dx, WORD PTR _max_val$[ebp]
	mov	WORD PTR tv75[ebp], dx
$LN8@Limit:
	mov	ax, WORD PTR tv75[ebp]

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Limit@SIMLIB_MATH_CLASS@@QAEFFFF@Z ENDP		; SIMLIB_MATH_CLASS::Limit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?exp@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?exp@@YAMM@Z PROC					; exp, COMDAT

; 515  :         {return (expf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_expf
	add	esp, 4
	pop	ebp
	ret	0
?exp@@YAMM@Z ENDP					; exp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _expf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_expf	PROC						; COMDAT

; 414  :         {return ((float)exp((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_exp
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_expf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
END
