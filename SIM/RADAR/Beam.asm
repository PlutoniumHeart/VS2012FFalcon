; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\RADAR\Beam.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?IsSet@RadarDopplerClass@@QAEHH@Z		; RadarDopplerClass::IsSet
PUBLIC	?SetFlagBit@RadarDopplerClass@@QAEXH@Z		; RadarDopplerClass::SetFlagBit
PUBLIC	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ClearFlagBit
PUBLIC	?MoveBeam@RadarDopplerClass@@IAEXXZ		; RadarDopplerClass::MoveBeam
PUBLIC	?LookingAtObject@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z ; RadarDopplerClass::LookingAtObject
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@40000000
PUBLIC	__real@bf800000
PUBLIC	__real@bf860a91
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	?TargetAz@@YAMPAVFalconEntity@@MM@Z:PROC	; TargetAz
EXTRN	?TargetEl@@YAMPAVFalconEntity@@MMM@Z:PROC	; TargetEl
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?g_fDBS1ScanRateFactor@@3MA:DWORD		; g_fDBS1ScanRateFactor
EXTRN	?g_fDBS2ScanRateFactor@@3MA:DWORD		; g_fDBS2ScanRateFactor
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf860a91
CONST	SEGMENT
__real@bf860a91 DD 0bf860a91r			; -1.0472
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\beam.cpp
_TEXT	SEGMENT
_az$ = -24						; size = 4
_retval$ = -20						; size = 4
_theta$ = -16						; size = 4
_targetData$ = -12					; size = 4
_el$ = -8						; size = 4
_this$ = -4						; size = 4
_target$ = 8						; size = 4
?LookingAtObject@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z PROC ; RadarDopplerClass::LookingAtObject
; _this$ = ecx

; 435  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 436  : int retval;
; 437  : float az, el, theta;
; 438  : SimObjectLocalData* targetData = target->localData;

	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _targetData$[ebp], ecx

; 439  : 
; 440  : 	if (!IsSet(SpaceStabalized))

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	SHORT $LN9@LookingAtO

; 441  : 	{
; 442  : 		if (targetData->az >= curScanLeft && targetData->az <= curScanRight &&
; 443  : 			targetData->el <= curScanTop && targetData->el >= curScanBottom)

	mov	edx, DWORD PTR _targetData$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	comiss	xmm0, DWORD PTR [eax+280]
	jb	SHORT $LN8@LookingAtO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _targetData$[ebp]
	movss	xmm0, DWORD PTR [ecx+284]
	comiss	xmm0, DWORD PTR [edx+16]
	jb	SHORT $LN8@LookingAtO
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _targetData$[ebp]
	movss	xmm0, DWORD PTR [eax+272]
	comiss	xmm0, DWORD PTR [ecx+28]
	jb	SHORT $LN8@LookingAtO
	mov	edx, DWORD PTR _targetData$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	comiss	xmm0, DWORD PTR [eax+276]
	jb	SHORT $LN8@LookingAtO

; 444  : 			retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 445  : 		else

	jmp	SHORT $LN7@LookingAtO
$LN8@LookingAtO:

; 446  : 			retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
$LN7@LookingAtO:

; 447  : 	}
; 448  : 	else

	jmp	$LN1@LookingAtO
$LN9@LookingAtO:

; 449  : 	{
; 450  :    	theta  = target->BaseData()->Pitch();

	mov	ecx, DWORD PTR _target$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR _theta$[ebp]

; 451  : 		az = TargetAz (platform, target->BaseData()->XPos(), target->BaseData()->YPos());

	mov	ecx, DWORD PTR _target$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?TargetAz@@YAMPAVFalconEntity@@MM@Z	; TargetAz
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _az$[ebp]

; 452  : 		el = TargetEl (platform, target->BaseData()->XPos(), target->BaseData()->YPos(),
; 453  :          target->BaseData()->ZPos());

	mov	ecx, DWORD PTR _target$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _target$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?TargetEl@@YAMPAVFalconEntity@@MMM@Z	; TargetEl
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _el$[ebp]

; 454  : 
; 455  :       if (theta > MAX_ANT_EL)

	movss	xmm0, DWORD PTR _theta$[ebp]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	SHORT $LN5@LookingAtO

; 456  :          el -= (theta - MAX_ANT_EL);

	movss	xmm0, DWORD PTR _theta$[ebp]
	subss	xmm0, DWORD PTR __real@3f860a91
	movss	xmm1, DWORD PTR _el$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _el$[ebp], xmm1
	jmp	SHORT $LN3@LookingAtO
$LN5@LookingAtO:

; 457  :       else if (theta < -MAX_ANT_EL)

	movss	xmm0, DWORD PTR __real@bf860a91
	comiss	xmm0, DWORD PTR _theta$[ebp]
	jbe	SHORT $LN3@LookingAtO

; 458  :          el += (-MAX_ANT_EL - theta);

	movss	xmm0, DWORD PTR __real@bf860a91
	subss	xmm0, DWORD PTR _theta$[ebp]
	addss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR _el$[ebp], xmm0
$LN3@LookingAtO:

; 459  : 
; 460  : 		if (az >= curScanLeft && az <= curScanRight &&
; 461  : 			el <= curScanTop && el >= curScanBottom)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	comiss	xmm0, DWORD PTR [edx+280]
	jb	SHORT $LN2@LookingAtO
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+284]
	comiss	xmm0, DWORD PTR _az$[ebp]
	jb	SHORT $LN2@LookingAtO
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+272]
	comiss	xmm0, DWORD PTR _el$[ebp]
	jb	SHORT $LN2@LookingAtO
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	comiss	xmm0, DWORD PTR [edx+276]
	jb	SHORT $LN2@LookingAtO

; 462  : 			retval = TRUE;

	mov	DWORD PTR _retval$[ebp], 1

; 463  : 		else

	jmp	SHORT $LN1@LookingAtO
$LN2@LookingAtO:

; 464  : 			retval = FALSE;

	mov	DWORD PTR _retval$[ebp], 0
$LN1@LookingAtO:

; 465  : 	}
; 466  : 
; 467  : 	return (retval);

	mov	eax, DWORD PTR _retval$[ebp]

; 468  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LookingAtObject@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z ENDP ; RadarDopplerClass::LookingAtObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\beam.cpp
_TEXT	SEGMENT
tv877 = -32						; size = 4
tv829 = -28						; size = 4
tv84 = -24						; size = 4
_theta$ = -20						; size = 4
_az$ = -16						; size = 4
_el$ = -12						; size = 4
_curScanRate$ = -8					; size = 4
_this$ = -4						; size = 4
?MoveBeam@RadarDopplerClass@@IAEXXZ PROC		; RadarDopplerClass::MoveBeam
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 19   : float curScanRate;
; 20   : float az, el, theta;
; 21   : 
; 22   : 	//MI no radar if RF Switch in SILENT or QUIET
; 23   : 	if(SimDriver.GetPlayerAircraft() && (SimDriver.GetPlayerAircraft()->RFState == 1 ||
; 24   : 		SimDriver.GetPlayerAircraft()->RFState == 2))

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN98@MoveBeam
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 1
	je	SHORT $LN97@MoveBeam
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	cmp	DWORD PTR [eax+1520], 2
	jne	SHORT $LN98@MoveBeam
$LN97@MoveBeam:

; 25   : 	{
; 26   : 		SetEmitting(FALSE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN98@MoveBeam:

; 27   : 	}
; 28   : 
; 29   : 	// Seems like most of this could be done once at mode change or in per mode processing???
; 30   : 	switch(mode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv84[ebp], edx
	cmp	DWORD PTR tv84[ebp], 3
	je	SHORT $LN89@MoveBeam
	cmp	DWORD PTR tv84[ebp], 10			; 0000000aH
	je	$LN88@MoveBeam
	cmp	DWORD PTR tv84[ebp], 14			; 0000000eH
	je	SHORT $LN94@MoveBeam
	jmp	$LN85@MoveBeam
$LN94@MoveBeam:

; 31   : 	{
; 32   : 	  case GM:
; 33   : 		if (flags & DBS1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, 4
	je	SHORT $LN93@MoveBeam

; 34   : 		{
; 35   : 			curScanRate = scanRate * g_fDBS1ScanRateFactor;//0.25F;	// We're fudging -- Up the scan rate to reduce the latency

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+256]
	mulss	xmm0, DWORD PTR ?g_fDBS1ScanRateFactor@@3MA
	movss	DWORD PTR _curScanRate$[ebp], xmm0
	jmp	SHORT $LN90@MoveBeam
$LN93@MoveBeam:

; 36   : 		}
; 37   : 		else if (flags & DBS2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, 8
	je	SHORT $LN91@MoveBeam

; 38   : 		{
; 39   : 			curScanRate = scanRate * g_fDBS2ScanRateFactor;//0.05F;	// We're fudging -- Up the scan rate to reduce the latency

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+256]
	mulss	xmm0, DWORD PTR ?g_fDBS2ScanRateFactor@@3MA
	movss	DWORD PTR _curScanRate$[ebp], xmm0

; 40   : 		}
; 41   : 		else

	jmp	SHORT $LN90@MoveBeam
$LN91@MoveBeam:

; 42   : 		{
; 43   : 			curScanRate = scanRate * 2.0f;	// We're fudging -- Up the scan rate to reduce the latency

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+256]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _curScanRate$[ebp], xmm0
$LN90@MoveBeam:

; 44   : 		}
; 45   : 		break;

	jmp	SHORT $LN95@MoveBeam
$LN89@MoveBeam:

; 46   : 
; 47   : 	  case LRS:
; 48   : 	      curScanRate = scanRate * 0.5f; // JPO a bit slower

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+256]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _curScanRate$[ebp], xmm0

; 49   : 	  break;

	jmp	SHORT $LN95@MoveBeam
$LN88@MoveBeam:

; 50   : 	  case SAM:
; 51   : 		  if(prevMode == LRS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 3
	jne	SHORT $LN87@MoveBeam

; 52   : 			  curScanRate = scanRate * 0.5f; // JPO a bit slower

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+256]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _curScanRate$[ebp], xmm0

; 53   : 		  else

	jmp	SHORT $LN86@MoveBeam
$LN87@MoveBeam:

; 54   : 			  curScanRate = scanRate;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+256]
	movss	DWORD PTR _curScanRate$[ebp], xmm0
$LN86@MoveBeam:

; 55   : 	  break;

	jmp	SHORT $LN95@MoveBeam
$LN85@MoveBeam:

; 56   : 	  default:
; 57   : 		curScanRate = scanRate;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+256]
	movss	DWORD PTR _curScanRate$[ebp], xmm0
$LN95@MoveBeam:

; 58   : 		break;
; 59   : 	}
; 60   : 
; 61   : 
; 62   :    if (scanDir == ScanNone)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+252]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN84@MoveBeam

; 63   :    {
; 64   : 	   curScanLeft   = beamAz - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+280], xmm0

; 65   : 	   curScanRight  = beamAz + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+284], xmm0

; 66   : 	   curScanTop    = beamEl + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+272], xmm0

; 67   : 	   curScanBottom = beamEl - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+276], xmm0
	jmp	$LN1@MoveBeam
$LN84@MoveBeam:

; 68   :    }
; 69   :    else if (IsSet(HomingBeam))

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN82@MoveBeam

; 70   :    {
; 71   :       if (beamAz > -azScan)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+196]
	comiss	xmm1, xmm0
	jbe	SHORT $LN81@MoveBeam

; 72   :       {
; 73   : 			beamAz -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+196]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+196], xmm1

; 74   :          if (beamAz < -azScan)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [eax+196]
	jbe	SHORT $LN80@MoveBeam

; 75   :             beamAz = -azScan;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+196], xmm0
$LN80@MoveBeam:

; 76   :       }

	jmp	$LN77@MoveBeam
$LN81@MoveBeam:

; 77   :       else if (beamAz < -azScan)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+196]
	jbe	SHORT $LN77@MoveBeam

; 78   :       {
; 79   : 			beamAz += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+196]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm0

; 80   :          if (beamAz > -azScan)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+196]
	comiss	xmm1, xmm0
	jbe	SHORT $LN77@MoveBeam

; 81   :             beamAz = -azScan;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+196], xmm0
$LN77@MoveBeam:

; 82   :       }
; 83   : 
; 84   :       if (beamEl > elScan)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	comiss	xmm0, DWORD PTR [eax+208]
	jbe	SHORT $LN76@MoveBeam

; 85   :       {
; 86   : 			beamEl -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+200]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+200], xmm1

; 87   :          if (beamEl < elScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+208]
	comiss	xmm0, DWORD PTR [ecx+200]
	jbe	SHORT $LN75@MoveBeam

; 88   :             beamEl = elScan;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR [edx+200], ecx
$LN75@MoveBeam:

; 89   :       }

	jmp	SHORT $LN72@MoveBeam
$LN76@MoveBeam:

; 90   :       else if (beamEl < elScan)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+208]
	comiss	xmm0, DWORD PTR [eax+200]
	jbe	SHORT $LN72@MoveBeam

; 91   :       {
; 92   : 			beamEl += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+200]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+200], xmm0

; 93   :          if (beamEl > elScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	comiss	xmm0, DWORD PTR [ecx+208]
	jbe	SHORT $LN72@MoveBeam

; 94   :             beamEl = elScan;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR [edx+200], ecx
$LN72@MoveBeam:

; 95   :       }
; 96   : 
; 97   :       if (beamAz == -azScan && beamEl == elScan)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+196]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN71@MoveBeam
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	ucomiss	xmm0, DWORD PTR [edx+208]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN71@MoveBeam

; 98   :          ClearFlagBit(HomingBeam);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN71@MoveBeam:

; 99   :    }

	jmp	$LN1@MoveBeam
$LN82@MoveBeam:

; 100  :    /*-----------------*/
; 101  :    /* Vertical search */
; 102  :    /*-----------------*/
; 103  :    else if (IsSet(VerticalScan))

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN69@MoveBeam

; 104  :    {
; 105  : 	   /*----------------*/
; 106  : 	   /* Inbetween bars */
; 107  : 	   /*----------------*/
; 108  : 	   if (IsSet(ChangingBars))

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN68@MoveBeam

; 109  : 	   {
; 110  : 		   curScanTop    = beamEl + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+272], xmm0

; 111  : 		   curScanBottom = beamEl - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+276], xmm0

; 112  : 		   /*-------------*/
; 113  : 		   /* Going Right */
; 114  : 		   /*-------------*/
; 115  : 		   if (targetAz > beamAz)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+244]
	comiss	xmm0, DWORD PTR [ecx+196]
	jbe	$LN67@MoveBeam

; 116  : 		   {
; 117  : 			   curScanLeft = beamAz - beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+196]
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+280], xmm0

; 118  : 			   beamAz += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+196]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm0

; 119  : 			   if (beamAz >= targetAz)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	comiss	xmm0, DWORD PTR [edx+244]
	jb	SHORT $LN66@MoveBeam

; 120  : 			   {
; 121  : 				   beamAz = targetAz;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR [eax+196], edx

; 122  :               ClearFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN66@MoveBeam:

; 123  : 			   }
; 124  : 			   curScanRight = beamAz + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+284], xmm0

; 125  : 		   }
; 126  : 		   else

	jmp	$LN65@MoveBeam
$LN67@MoveBeam:

; 127  : 		   {
; 128  : 			   /*------------*/
; 129  : 			   /* Going Left */
; 130  : 			   /*------------*/
; 131  : 			   curScanRight = beamAz + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+284], xmm0

; 132  : 		 	   beamAz -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+196]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+196], xmm1

; 133  : 			   if (beamAz <= targetAz)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+244]
	comiss	xmm0, DWORD PTR [eax+196]
	jb	SHORT $LN64@MoveBeam

; 134  : 			   {
; 135  : 				   beamAz = targetAz;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR [ecx+196], eax

; 136  :               ClearFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN64@MoveBeam:

; 137  : 			   }
; 138  : 			   curScanLeft = beamAz - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+280], xmm0
$LN65@MoveBeam:

; 139  : 		   }
; 140  : 	   }
; 141  : 	   else

	jmp	$LN55@MoveBeam
$LN68@MoveBeam:

; 142  : 	   {
; 143  : 		   curScanRight = beamAz + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+284], xmm0

; 144  : 		   curScanLeft = beamAz - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+280], xmm0

; 145  : 		   if (scanDir > 0.0F)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+252]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN62@MoveBeam

; 146  : 		   {
; 147  : 			   curScanBottom = beamEl - beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+276], xmm0

; 148  : 			   beamEl += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+200]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+200], xmm0

; 149  : 			   curScanTop    = beamEl + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+272], xmm0

; 150  : 		   }
; 151  : 		   else

	jmp	SHORT $LN61@MoveBeam
$LN62@MoveBeam:

; 152  : 		   {
; 153  : 			   curScanTop    = beamEl + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+272], xmm0

; 154  : 			   beamEl -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+200]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+200], xmm1

; 155  : 			   curScanBottom = beamEl - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+276], xmm0
$LN61@MoveBeam:

; 156  : 		   }
; 157  : 
; 158  : 		   /*------------------*/
; 159  : 		   /* Off the top edge */
; 160  : 		   /*------------------*/
; 161  : 		   if (beamEl > elScan || beamEl + seekerElCenter > MAX_ANT_EL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	comiss	xmm0, DWORD PTR [ecx+208]
	ja	SHORT $LN59@MoveBeam
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	addss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	SHORT $LN60@MoveBeam
$LN59@MoveBeam:

; 162  : 		   {
; 163  :            SetFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 164  : 			   targetAz = beamAz + barWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [edx+248]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+244], xmm0

; 165  : 			   beamEl = elScan;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR [ecx+200], eax

; 166  : 			   scanDir = ScanRev;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+252], xmm0

; 167  : 			   curScanTop    = beamEl + beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	addss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+272], xmm0
	jmp	$LN57@MoveBeam
$LN60@MoveBeam:

; 168  : 		   }
; 169  : 		   /*---------------------*/
; 170  : 		   /* Off the bottom edge */
; 171  : 		   /*---------------------*/
; 172  : 		   else if (beamEl < -elScan || beamEl + seekerElCenter < -MAX_ANT_EL)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+208]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [eax+200]
	ja	SHORT $LN56@MoveBeam
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+60]
	movss	xmm1, DWORD PTR __real@bf860a91
	comiss	xmm1, xmm0
	jbe	SHORT $LN57@MoveBeam
$LN56@MoveBeam:

; 173  : 		   {
; 174  :            SetFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 175  : 			   targetAz = beamAz + barWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+244], xmm0

; 176  : 			   beamEl = -elScan;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+208]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+200], xmm0

; 177  : 			   scanDir = ScanFwd;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+252], xmm0

; 178  : 			   curScanBottom = beamEl - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+276], xmm0
$LN57@MoveBeam:

; 179  : 		   }
; 180  : 
; 181  : 		   /*--------------------*/
; 182  : 		   /* Off the right edge */
; 183  : 		   /*--------------------*/
; 184  : 		   if (targetAz > azScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+244]
	comiss	xmm0, DWORD PTR [ecx+204]
	jbe	SHORT $LN55@MoveBeam

; 185  : 			   targetAz = -azScan;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+244], xmm0
$LN55@MoveBeam:

; 186  : 	   }
; 187  :    }
; 188  :    /*-------------------*/
; 189  :    /* Horizontal Search */
; 190  :    /*-------------------*/
; 191  :    else

	jmp	$LN1@MoveBeam
$LN69@MoveBeam:

; 192  :    {
; 193  :       // Check the SAM target if needed
; 194  :       if (IsSet(SAMingTarget))

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN53@MoveBeam

; 195  :       {
; 196  :          if (lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	$LN52@MoveBeam

; 197  :          {
; 198  :             // Firstly, is the beam over the target? if yes, return to search
; 199  :             // else, go to the target
; 200  :    	      theta  = lockedTarget->BaseData()->Pitch();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR _theta$[ebp]

; 201  : 		      az = TargetAz (platform, lockedTarget->BaseData()->XPos(), lockedTarget->BaseData()->YPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?TargetAz@@YAMPAVFalconEntity@@MM@Z	; TargetAz
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _az$[ebp]

; 202  : 		      el = TargetEl (platform, lockedTarget->BaseData()->XPos(), lockedTarget->BaseData()->YPos(),
; 203  :                lockedTarget->BaseData()->ZPos());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?TargetEl@@YAMPAVFalconEntity@@MMM@Z	; TargetEl
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _el$[ebp]

; 204  : 
; 205  :             if (theta > MAX_ANT_EL)

	movss	xmm0, DWORD PTR _theta$[ebp]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	SHORT $LN51@MoveBeam

; 206  :                el -= (theta - MAX_ANT_EL);

	movss	xmm0, DWORD PTR _theta$[ebp]
	subss	xmm0, DWORD PTR __real@3f860a91
	movss	xmm1, DWORD PTR _el$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _el$[ebp], xmm1
	jmp	SHORT $LN49@MoveBeam
$LN51@MoveBeam:

; 207  :             else if (theta < -MAX_ANT_EL)

	movss	xmm0, DWORD PTR __real@bf860a91
	comiss	xmm0, DWORD PTR _theta$[ebp]
	jbe	SHORT $LN49@MoveBeam

; 208  :                el += (-MAX_ANT_EL - theta);

	movss	xmm0, DWORD PTR __real@bf860a91
	subss	xmm0, DWORD PTR _theta$[ebp]
	addss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR _el$[ebp], xmm0
$LN49@MoveBeam:

; 209  : 
; 210  :             // target in beam ?
; 211  : 		      if ((az >= curScanLeft && az <= curScanRight &&
; 212  : 			        el <= curScanTop && el >= curScanBottom) || scanDir == ScanRev )

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	comiss	xmm0, DWORD PTR [eax+280]
	jb	SHORT $LN46@MoveBeam
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+284]
	comiss	xmm0, DWORD PTR _az$[ebp]
	jb	SHORT $LN46@MoveBeam
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+272]
	comiss	xmm0, DWORD PTR _el$[ebp]
	jb	SHORT $LN46@MoveBeam
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	comiss	xmm0, DWORD PTR [eax+276]
	jae	SHORT $LN47@MoveBeam
$LN46@MoveBeam:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+252]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN48@MoveBeam
$LN47@MoveBeam:

; 213  :             {
; 214  :                // Can See, or, have seen so head home
; 215  :                scanDir = ScanRev;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+252], xmm0

; 216  :                if (beamAz > azScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	comiss	xmm0, DWORD PTR [ecx+204]
	jbe	SHORT $LN45@MoveBeam

; 217  :                {
; 218  :    			      beamAz -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+196]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm1

; 219  :                   if (beamAz < azScan)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	comiss	xmm0, DWORD PTR [edx+196]
	jbe	SHORT $LN44@MoveBeam

; 220  :                      beamAz = azScan;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR [eax+196], edx
$LN44@MoveBeam:

; 221  :                }

	jmp	SHORT $LN41@MoveBeam
$LN45@MoveBeam:

; 222  :                else if (beamAz < azScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR [ecx+196]
	jbe	SHORT $LN41@MoveBeam

; 223  :                {
; 224  :    			      beamAz += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+196]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm0

; 225  :                   if (beamAz > azScan)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	comiss	xmm0, DWORD PTR [edx+204]
	jbe	SHORT $LN41@MoveBeam

; 226  :                      beamAz = azScan;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR [eax+196], edx
$LN41@MoveBeam:

; 227  :                }
; 228  : 
; 229  :                // And in elevation
; 230  :                if (beamEl > elScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	comiss	xmm0, DWORD PTR [ecx+208]
	jbe	SHORT $LN40@MoveBeam

; 231  :                {
; 232  :    			      beamEl -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+200]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+200], xmm1

; 233  :                   if (beamEl < elScan)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+208]
	comiss	xmm0, DWORD PTR [edx+200]
	jbe	SHORT $LN39@MoveBeam

; 234  :                      beamEl = elScan;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	mov	DWORD PTR [eax+200], edx
$LN39@MoveBeam:

; 235  :                }

	jmp	SHORT $LN36@MoveBeam
$LN40@MoveBeam:

; 236  :                else if (beamEl < elScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+208]
	comiss	xmm0, DWORD PTR [ecx+200]
	jbe	SHORT $LN36@MoveBeam

; 237  :                {
; 238  :    			      beamEl += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+200]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+200], xmm0

; 239  :                   if (beamEl > elScan)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	comiss	xmm0, DWORD PTR [edx+208]
	jbe	SHORT $LN36@MoveBeam

; 240  :                      beamEl = elScan;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	mov	DWORD PTR [eax+200], edx
$LN36@MoveBeam:

; 241  :                }
; 242  : 
; 243  :                if (beamAz == azScan && beamEl == elScan)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	ucomiss	xmm0, DWORD PTR [ecx+204]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN35@MoveBeam
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	ucomiss	xmm0, DWORD PTR [eax+208]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN35@MoveBeam

; 244  :                {
; 245  :                   ClearFlagBit (SAMingTarget);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 246  :                   ClearFlagBit (ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 247  :                   scanDir = ScanFwd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+252], xmm0
$LN35@MoveBeam:

; 248  :                }
; 249  :             }
; 250  : 		      else

	jmp	$LN18@MoveBeam
$LN48@MoveBeam:

; 251  :             {
; 252  :                az -= seekerAzCenter;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	subss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR _az$[ebp], xmm0

; 253  :                el -= seekerElCenter;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	subss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR _el$[ebp], xmm0

; 254  :                // Can't See
; 255  :                scanDir = ScanFwd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+252], xmm0

; 256  :                if (beamAz > az)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+196]
	comiss	xmm0, DWORD PTR _az$[ebp]
	jbe	SHORT $LN33@MoveBeam

; 257  :                {
; 258  :    			      beamAz -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+196]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+196], xmm1

; 259  :                   if (beamAz < az)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	comiss	xmm0, DWORD PTR [edx+196]
	jbe	SHORT $LN32@MoveBeam

; 260  :                      beamAz = az;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [eax+196], xmm0
$LN32@MoveBeam:

; 261  :                }

	jmp	SHORT $LN29@MoveBeam
$LN33@MoveBeam:

; 262  :                else if (beamAz < az)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	comiss	xmm0, DWORD PTR [ecx+196]
	jbe	SHORT $LN29@MoveBeam

; 263  :                {
; 264  :    			      beamAz += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+196]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm0

; 265  :                   if (beamAz > az)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	comiss	xmm0, DWORD PTR _az$[ebp]
	jbe	SHORT $LN29@MoveBeam

; 266  :                      beamAz = az;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [edx+196], xmm0
$LN29@MoveBeam:

; 267  :                }
; 268  : 
; 269  :                // And in elevation
; 270  :                if (beamEl > el)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	comiss	xmm0, DWORD PTR _el$[ebp]
	jbe	SHORT $LN28@MoveBeam

; 271  :                {
; 272  :    			      beamEl -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+200]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+200], xmm1

; 273  :                   if (beamEl < el)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	comiss	xmm0, DWORD PTR [eax+200]
	jbe	SHORT $LN27@MoveBeam

; 274  :                      beamEl = el;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [ecx+200], xmm0
$LN27@MoveBeam:

; 275  :                }

	jmp	SHORT $LN24@MoveBeam
$LN28@MoveBeam:

; 276  :                else if (beamEl < el)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	comiss	xmm0, DWORD PTR [edx+200]
	jbe	SHORT $LN24@MoveBeam

; 277  :                {
; 278  :    			      beamEl += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+200], xmm0

; 279  :                   if (beamEl > el)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	comiss	xmm0, DWORD PTR _el$[ebp]
	jbe	SHORT $LN24@MoveBeam

; 280  :                      beamEl = el;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [eax+200], xmm0
$LN24@MoveBeam:

; 281  :                }
; 282  : 
; 283  :                // Keep the beam legal
; 284  :                if (beamAz + seekerAzCenter > MAX_ANT_EL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [edx+56]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	SHORT $LN23@MoveBeam

; 285  :                {
; 286  :                   beamAz = MAX_ANT_EL - seekerAzCenter;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+196], xmm0

; 287  :                   scanDir = ScanRev;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+252], xmm0
	jmp	SHORT $LN21@MoveBeam
$LN23@MoveBeam:

; 288  :                }
; 289  :                else if (beamAz + seekerAzCenter < -MAX_ANT_EL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+56]
	movss	xmm1, DWORD PTR __real@bf860a91
	comiss	xmm1, xmm0
	jbe	SHORT $LN21@MoveBeam

; 290  :                {
; 291  :                   beamAz = -MAX_ANT_EL - seekerAzCenter;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	subss	xmm0, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm0

; 292  :                   scanDir = ScanRev;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+252], xmm0
$LN21@MoveBeam:

; 293  :                }
; 294  : 
; 295  :                if (beamEl + seekerElCenter > MAX_ANT_EL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	addss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	SHORT $LN20@MoveBeam

; 296  :                {
; 297  :                   beamEl = MAX_ANT_EL - seekerElCenter;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+200], xmm0

; 298  :                   scanDir = ScanRev;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+252], xmm0
	jmp	SHORT $LN18@MoveBeam
$LN20@MoveBeam:

; 299  :                }
; 300  :                else if (beamEl + seekerElCenter < -MAX_ANT_EL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+60]
	movss	xmm1, DWORD PTR __real@bf860a91
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@MoveBeam

; 301  :                {
; 302  :                   beamEl = -MAX_ANT_EL - seekerElCenter;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	subss	xmm0, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+200], xmm0

; 303  :                   scanDir = ScanRev;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+252], xmm0
$LN18@MoveBeam:

; 304  :                }
; 305  :             }
; 306  : 
; 307  :             // Where are we really looking
; 308  : 	         curScanLeft   = beamAz - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+280], xmm0

; 309  : 	         curScanRight  = beamAz + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+284], xmm0

; 310  : 	         curScanTop    = beamEl + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+272], xmm0

; 311  : 	         curScanBottom = beamEl - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+276], xmm0

; 312  : 
; 313  :             // These get added back in later for all modes
; 314  : //	         curScanLeft   -= seekerAzCenter;
; 315  : //	         curScanRight  -= seekerAzCenter;
; 316  : //	         curScanTop    -= seekerElCenter;
; 317  : //	         curScanBottom -= seekerElCenter;
; 318  :          }
; 319  :          else

	jmp	SHORT $LN17@MoveBeam
$LN52@MoveBeam:

; 320  :          {
; 321  :             ClearFlagBit (SAMingTarget);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 322  :             ClearFlagBit (ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 323  :             scanDir = ScanFwd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+252], xmm0
$LN17@MoveBeam:

; 324  :          }

	jmp	$LN1@MoveBeam
$LN53@MoveBeam:

; 325  :       }
; 326  : 	   /*----------------*/
; 327  : 	   /* Inbetween bars */
; 328  : 	   /*----------------*/
; 329  : 	   else if (IsSet(ChangingBars))

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN15@MoveBeam

; 330  : 	   {
; 331  : 		   curScanRight = beamAz + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+284], xmm0

; 332  : 		   curScanLeft = beamAz - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+280], xmm0

; 333  : 		   /*----------*/
; 334  : 		   /* Going Up */
; 335  : 		   /*----------*/
; 336  : 		   if (targetEl > beamEl)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+240]
	comiss	xmm0, DWORD PTR [edx+200]
	jbe	$LN14@MoveBeam

; 337  : 		   {
; 338  : 			   curScanBottom = beamEl - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+276], xmm0

; 339  : 			   beamEl += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+200]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+200], xmm0

; 340  : 			   if (beamEl >= targetEl)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	comiss	xmm0, DWORD PTR [eax+240]
	jb	SHORT $LN13@MoveBeam

; 341  : 			   {
; 342  : 				   beamEl = targetEl;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	mov	DWORD PTR [ecx+200], eax

; 343  :               ClearFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN13@MoveBeam:

; 344  : 			   }
; 345  : 			   curScanTop = beamEl + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+272], xmm0

; 346  : 		   }
; 347  : 		   /*------------*/
; 348  : 		   /* Going Down */
; 349  : 		   /*------------*/
; 350  : 		   else

	jmp	$LN12@MoveBeam
$LN14@MoveBeam:

; 351  : 		   {
; 352  : 			   curScanTop = beamEl + beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+272], xmm0

; 353  : 			   beamEl -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+200]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+200], xmm1

; 354  : 			   if (beamEl <= targetEl)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+240]
	comiss	xmm0, DWORD PTR [ecx+200]
	jb	SHORT $LN11@MoveBeam

; 355  : 			   {
; 356  : 				   beamEl = targetEl;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	mov	DWORD PTR [edx+200], ecx

; 357  :               ClearFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN11@MoveBeam:

; 358  : 			   }
; 359  : 			   curScanBottom = beamEl - beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+276], xmm0
$LN12@MoveBeam:

; 360  : 		   }
; 361  : 	   }
; 362  : 	   else

	jmp	$LN1@MoveBeam
$LN15@MoveBeam:

; 363  : 	   {
; 364  : 		   curScanTop = beamEl + beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	addss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+272], xmm0

; 365  : 		   curScanBottom = beamEl - beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+276], xmm0

; 366  : 
; 367  : 		   if (scanDir > 0.0F)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+252]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@MoveBeam

; 368  : 		   {
; 369  : 			   curScanLeft = beamAz + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+280], xmm0

; 370  : 			   beamAz += curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+196]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+196], xmm0

; 371  : 			   curScanRight = beamAz + beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+196]
	addss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+284], xmm0

; 372  : 		   }
; 373  : 		   else

	jmp	SHORT $LN8@MoveBeam
$LN9@MoveBeam:

; 374  : 		   {
; 375  : 			   curScanRight = beamAz - beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+196]
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+284], xmm0

; 376  : 			   beamAz -= curScanRate * SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR _curScanRate$[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+196]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+196], xmm1

; 377  : 			   curScanLeft = beamAz - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+280], xmm0
$LN8@MoveBeam:

; 378  : 		   }
; 379  : 
; 380  : 		   /*------------*/
; 381  : 		   /* Right Edge */
; 382  : 		   /*------------*/
; 383  : 		   if (scanDir == ScanFwd &&
; 384  : 			   (beamAz > azScan || beamAz + seekerAzCenter > MAX_ANT_EL))

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+252]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN7@MoveBeam
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+196]
	comiss	xmm0, DWORD PTR [eax+204]
	ja	SHORT $LN6@MoveBeam
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [edx+56]
	comiss	xmm0, DWORD PTR __real@3f860a91
	jbe	$LN7@MoveBeam
$LN6@MoveBeam:

; 385  : 		   {
; 386  : #if 0	// This will be nice but is a bit broken inside GMComposit.cpp  SCR 8/14/98
; 387  : 				// In GM DBS modes, the beam always sweeps from left to right
; 388  : 				if ((mode==GM) && ((flags & DBS1) || (flags&DBS2))) {
; 389  : 					beamAz = max (-azScan, -MAX_ANT_EL + seekerAzCenter);
; 390  : 				} else 
; 391  : #endif
; 392  : 				{
; 393  : 					SetFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 394  : 					targetEl = beamEl - barWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	subss	xmm0, DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+240], xmm0

; 395  : 					beamAz = min (azScan, MAX_ANT_EL - seekerAzCenter);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+56]
	comiss	xmm0, DWORD PTR [eax+204]
	jbe	SHORT $LN101@MoveBeam
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv829[ebp], xmm0
	jmp	SHORT $LN102@MoveBeam
$LN101@MoveBeam:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv829[ebp], xmm0
$LN102@MoveBeam:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv829[ebp]
	movss	DWORD PTR [ecx+196], xmm0

; 396  : 					scanDir = ScanRev;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+252], xmm0

; 397  : 					curScanRight = beamAz + beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+284], xmm0

; 398  : 				}
; 399  : 		   }
; 400  : 		   /*-----------*/
; 401  : 		   /* Left Edge */
; 402  : 		   /*-----------*/
; 403  : 		   else if (scanDir == ScanRev &&

	jmp	$LN4@MoveBeam
$LN7@MoveBeam:

; 404  : 			   (beamAz < -azScan || beamAz + seekerAzCenter < -MAX_ANT_EL))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+252]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN4@MoveBeam
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [edx+196]
	ja	SHORT $LN3@MoveBeam
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+56]
	movss	xmm1, DWORD PTR __real@bf860a91
	comiss	xmm1, xmm0
	jbe	$LN4@MoveBeam
$LN3@MoveBeam:

; 405  : 		   {
; 406  :            SetFlagBit(ChangingBars);

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 407  : 			   targetEl = beamEl - barWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+200]
	subss	xmm0, DWORD PTR [eax+248]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+240], xmm0

; 408  : 			   beamAz = max (-azScan, -MAX_ANT_EL + seekerAzCenter);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [eax+56]
	comiss	xmm0, xmm1
	jbe	SHORT $LN103@MoveBeam
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv877[ebp], xmm0
	jmp	SHORT $LN104@MoveBeam
$LN103@MoveBeam:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR tv877[ebp], xmm0
$LN104@MoveBeam:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv877[ebp]
	movss	DWORD PTR [eax+196], xmm0

; 409  : 			   scanDir = ScanFwd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+252], xmm0

; 410  : 			   curScanRight = beamAz + beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+196]
	addss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+284], xmm0
$LN4@MoveBeam:

; 411  : 		   }
; 412  : 
; 413  : 		   /*----------------*/
; 414  : 		   /* Off the bottom */
; 415  : 		   /*----------------*/
; 416  : 		   if (targetEl < -elScan)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+208]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [eax+240]
	jbe	SHORT $LN1@MoveBeam

; 417  :          {
; 418  : 			   targetEl = elScan;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR [ecx+240], eax

; 419  :             if (mode == SAM)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 10			; 0000000aH
	jne	SHORT $LN1@MoveBeam

; 420  :             {
; 421  :                SetFlagBit (SAMingTarget);

	push	32768					; 00008000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 422  :                scanDir = ScanFwd;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+252], xmm0
$LN1@MoveBeam:

; 423  :             }
; 424  :          }
; 425  : 	   }
; 426  :    }
; 427  : 
; 428  : 	curScanLeft += seekerAzCenter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+280]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+280], xmm0

; 429  : 	curScanRight += seekerAzCenter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+284]
	addss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+284], xmm0

; 430  : 	curScanTop += seekerElCenter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+272]
	addss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+272], xmm0

; 431  : 	curScanBottom += seekerElCenter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+276]
	addss	xmm0, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+276], xmm0

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MoveBeam@RadarDopplerClass@@IAEXXZ ENDP		; RadarDopplerClass::MoveBeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ClearFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ClearFlagBit, COMDAT
; _this$ = ecx

; 238  : 	void ClearFlagBit (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+492]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ClearFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::SetFlagBit, COMDAT
; _this$ = ecx

; 237  :    void SetFlagBit (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::SetFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsSet@RadarDopplerClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@RadarDopplerClass@@QAEHH@Z PROC			; RadarDopplerClass::IsSet, COMDAT
; _this$ = ecx

; 236  :    int  IsSet (int newFlag) {return (newFlag & flags) ? TRUE : FALSE;}; //MI moved to public

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	and	ecx, DWORD PTR [eax+492]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@RadarDopplerClass@@QAEHH@Z ENDP			; RadarDopplerClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
END
