; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\RADAR\RadarDoppler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	??_C@_02DALMIMOA@GM?$AA@			; `string'
PUBLIC	??_C@_03HOONMGKE@GMT?$AA@			; `string'
PUBLIC	??_C@_03JIDALBMA@SEA?$AA@			; `string'
PUBLIC	??_C@_03PDIAOBEH@BCN?$AA@			; `string'
PUBLIC	??_C@_04BKGGJKLP@STBY?$AA@			; `string'
PUBLIC	??_C@_03MKBIBNGK@ACM?$AA@			; `string'
PUBLIC	??_C@_03HNPFBMKG@CRM?$AA@			; `string'
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ??_C@_03HNPFBMKG@CRM?$AA@
CONST	SEGMENT
??_C@_03HNPFBMKG@CRM?$AA@ DB 'CRM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MKBIBNGK@ACM?$AA@
CONST	SEGMENT
??_C@_03MKBIBNGK@ACM?$AA@ DB 'ACM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKGGJKLP@STBY?$AA@
CONST	SEGMENT
??_C@_04BKGGJKLP@STBY?$AA@ DB 'STBY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDIAOBEH@BCN?$AA@
CONST	SEGMENT
??_C@_03PDIAOBEH@BCN?$AA@ DB 'BCN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIDALBMA@SEA?$AA@
CONST	SEGMENT
??_C@_03JIDALBMA@SEA?$AA@ DB 'SEA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HOONMGKE@GMT?$AA@
CONST	SEGMENT
??_C@_03HOONMGKE@GMT?$AA@ DB 'GMT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DALMIMOA@GM?$AA@
CONST	SEGMENT
??_C@_02DALMIMOA@GM?$AA@ DB 'GM', 00H			; `string'
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
_rmenu	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_02DALMIMOA@GM?$AA@
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_03HOONMGKE@GMT?$AA@
	DD	00H
	DD	010H
	DD	FLAT:??_C@_03JIDALBMA@SEA?$AA@
	DD	00H
	DD	011H
	DD	FLAT:??_C@_03PDIAOBEH@BCN?$AA@
	DD	00H
	DD	013H
	DD	FLAT:??_C@_04BKGGJKLP@STBY?$AA@
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03MKBIBNGK@ACM?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_03HNPFBMKG@CRM?$AA@
	DD	00H
	DD	02H
_rmenuaa DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_04BKGGJKLP@STBY?$AA@
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03MKBIBNGK@ACM?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_03HNPFBMKG@CRM?$AA@
	DD	00H
	DD	02H
_rmenuag DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_02DALMIMOA@GM?$AA@
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_03HOONMGKE@GMT?$AA@
	DD	00H
	DD	010H
	DD	FLAT:??_C@_03JIDALBMA@SEA?$AA@
	DD	00H
	DD	011H
	DD	FLAT:??_C@_03PDIAOBEH@BCN?$AA@
	DD	00H
	DD	013H
	DD	FLAT:??_C@_04BKGGJKLP@STBY?$AA@
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_03MKBIBNGK@ACM?$AA@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_03HNPFBMKG@CRM?$AA@
	DD	00H
	DD	02H
_GM_OVERSCAN DD	03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z	; MfdDrawable::Display
PUBLIC	?SetType@SensorClass@@UAEXW4SensorType@1@@Z	; SensorClass::SetType
PUBLIC	?IsOn@SensorClass@@UAEHXZ			; SensorClass::IsOn
PUBLIC	?ExecModes@SensorClass@@UAEXHH@Z		; SensorClass::ExecModes
PUBLIC	?UpdateState@SensorClass@@UAEXHH@Z		; SensorClass::UpdateState
PUBLIC	?SetSeekerPos@SensorClass@@UAEXMM@Z		; SensorClass::SetSeekerPos
PUBLIC	?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ	; SensorClass::TargetUnderCursor
PUBLIC	?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ ; SensorClass::GetDisplay
PUBLIC	??1RadarClass@@UAE@XZ				; RadarClass::~RadarClass
PUBLIC	?RangeStep@RadarClass@@UAEXH@Z			; RadarClass::RangeStep
PUBLIC	?NextTarget@RadarClass@@UAEXXZ			; RadarClass::NextTarget
PUBLIC	?PrevTarget@RadarClass@@UAEXXZ			; RadarClass::PrevTarget
PUBLIC	?DefaultAAMode@RadarClass@@UAEXXZ		; RadarClass::DefaultAAMode
PUBLIC	?StepAAmode@RadarClass@@UAEXXZ			; RadarClass::StepAAmode
PUBLIC	?SetSRMOverride@RadarClass@@UAEXXZ		; RadarClass::SetSRMOverride
PUBLIC	?SetMRMOverride@RadarClass@@UAEXXZ		; RadarClass::SetMRMOverride
PUBLIC	?ClearOverride@RadarClass@@UAEXXZ		; RadarClass::ClearOverride
PUBLIC	?SelectACMVertical@RadarClass@@UAEXXZ		; RadarClass::SelectACMVertical
PUBLIC	?SelectACMBore@RadarClass@@UAEXXZ		; RadarClass::SelectACMBore
PUBLIC	?SelectACMSlew@RadarClass@@UAEXXZ		; RadarClass::SelectACMSlew
PUBLIC	?SelectACM30x20@RadarClass@@UAEXXZ		; RadarClass::SelectACM30x20
PUBLIC	?StepAAscanHeight@RadarClass@@UAEXXZ		; RadarClass::StepAAscanHeight
PUBLIC	?StepAAscanWidth@RadarClass@@UAEXXZ		; RadarClass::StepAAscanWidth
PUBLIC	?StepAAelvation@RadarClass@@UAEXH@Z		; RadarClass::StepAAelvation
PUBLIC	?DefaultAGMode@RadarClass@@UAEXXZ		; RadarClass::DefaultAGMode
PUBLIC	?StepAGmode@RadarClass@@UAEXXZ			; RadarClass::StepAGmode
PUBLIC	?StepAGfov@RadarClass@@UAEXXZ			; RadarClass::StepAGfov
PUBLIC	?StepAGgain@RadarClass@@UAEXH@Z			; RadarClass::StepAGgain
PUBLIC	?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z	; RadarClass::SetMode
PUBLIC	?ToggleAGfreeze@RadarClass@@UAEXXZ		; RadarClass::ToggleAGfreeze
PUBLIC	?ToggleAGsnowPlow@RadarClass@@UAEXXZ		; RadarClass::ToggleAGsnowPlow
PUBLIC	?SetAGSnowPlow@RadarClass@@UAEXH@Z		; RadarClass::SetAGSnowPlow
PUBLIC	?ToggleAGcursorZero@RadarClass@@UAEXXZ		; RadarClass::ToggleAGcursorZero
PUBLIC	?SetGroundPoint@RadarClass@@UAEXMMM@Z		; RadarClass::SetGroundPoint
PUBLIC	?IsAG@RadarClass@@UAEHXZ			; RadarClass::IsAG
PUBLIC	?GetAGCenter@RadarClass@@UAEXPAM0@Z		; RadarClass::GetAGCenter
PUBLIC	?GetRange@RadarClass@@UAEMXZ			; RadarClass::GetRange
PUBLIC	?GetVolume@RadarClass@@UAEMXZ			; RadarClass::GetVolume
PUBLIC	?GetCursorPosition@RadarClass@@UAEXPAM0@Z	; RadarClass::GetCursorPosition
PUBLIC	?GetBuggedData@RadarClass@@UAEHPAM000@Z		; RadarClass::GetBuggedData
PUBLIC	?ClearModeDesiredCmd@RadarClass@@UAEXXZ		; RadarClass::ClearModeDesiredCmd
PUBLIC	?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ ; RadarClass::GetRadarModeR
PUBLIC	??_GRadarClass@@UAEPAXI@Z			; RadarClass::`scalar deleting destructor'
PUBLIC	??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z	; RadarDopplerClass::RadarDopplerClass
PUBLIC	??1RadarDopplerClass@@UAE@XZ			; RadarDopplerClass::~RadarDopplerClass
PUBLIC	?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z ; RadarDopplerClass::DisplayInit
PUBLIC	?Exec@RadarDopplerClass@@UAEPAVSimObjectType@@PAV2@@Z ; RadarDopplerClass::Exec
PUBLIC	?PushButton@RadarDopplerClass@@UAEXHH@Z		; RadarDopplerClass::PushButton
PUBLIC	?AGPushButton@RadarDopplerClass@@QAEXHH@Z	; RadarDopplerClass::AGPushButton
PUBLIC	?AAPushButton@RadarDopplerClass@@QAEXHH@Z	; RadarDopplerClass::AAPushButton
PUBLIC	?OtherPushButton@RadarDopplerClass@@QAEXHH@Z	; RadarDopplerClass::OtherPushButton
PUBLIC	?MenuPushButton@RadarDopplerClass@@QAEXHH@Z	; RadarDopplerClass::MenuPushButton
PUBLIC	?CtlPushButton@RadarDopplerClass@@QAEXHH@Z	; RadarDopplerClass::CtlPushButton
PUBLIC	?RangeStep@RadarDopplerClass@@UAEXH@Z		; RadarDopplerClass::RangeStep
PUBLIC	?SelectACMVertical@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SelectACMVertical
PUBLIC	?SelectACMBore@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SelectACMBore
PUBLIC	?SelectACMSlew@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SelectACMSlew
PUBLIC	?SelectACM30x20@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SelectACM30x20
PUBLIC	?GetRadarMode@RadarDopplerClass@@UAE?AW4RadarMode@RadarClass@@XZ ; RadarDopplerClass::GetRadarMode
PUBLIC	?SelectTWS@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::SelectTWS
PUBLIC	?SelectRWS@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::SelectRWS
PUBLIC	?SelectSAM@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::SelectSAM
PUBLIC	?DrawRCRCount@RadarDopplerClass@@QAEXXZ		; RadarDopplerClass::DrawRCRCount
PUBLIC	?SelectGMT@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::SelectGMT
PUBLIC	?SelectGM@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::SelectGM
PUBLIC	?SelectAGR@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::SelectAGR
PUBLIC	?SelectLastAGMode@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SelectLastAGMode
PUBLIC	?StepAAscanHeight@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::StepAAscanHeight
PUBLIC	?StepAAscanWidth@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::StepAAscanWidth
PUBLIC	?StepAGfov@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::StepAGfov
PUBLIC	?StepAGgain@RadarDopplerClass@@UAEXH@Z		; RadarDopplerClass::StepAGgain
PUBLIC	?GetRange@RadarDopplerClass@@UAEMXZ		; RadarDopplerClass::GetRange
PUBLIC	?GetVolume@RadarDopplerClass@@UAEMXZ		; RadarDopplerClass::GetVolume
PUBLIC	?GetCursorPosition@RadarDopplerClass@@UAEXPAM0@Z ; RadarDopplerClass::GetCursorPosition
PUBLIC	?ClearModeDesiredCmd@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::ClearModeDesiredCmd
PUBLIC	?SetAutoAGRange@RadarDopplerClass@@UAEX_N@Z	; RadarDopplerClass::SetAutoAGRange
PUBLIC	?ClearSensorTarget@RadarDopplerClass@@MAEXXZ	; RadarDopplerClass::ClearSensorTarget
PUBLIC	?SetSensorTarget@RadarDopplerClass@@MAEXPAVSimObjectType@@@Z ; RadarDopplerClass::SetSensorTarget
PUBLIC	?IsSet@RadarDopplerClass@@QAEHH@Z		; RadarDopplerClass::IsSet
PUBLIC	?SetFlagBit@RadarDopplerClass@@QAEXH@Z		; RadarDopplerClass::SetFlagBit
PUBLIC	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ClearFlagBit
PUBLIC	?ToggleFlag@RadarDopplerClass@@QAEXH@Z		; RadarDopplerClass::ToggleFlag
PUBLIC	?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ToggleModeFlag
PUBLIC	?IsModeFlag@RadarDopplerClass@@IAEHH@Z		; RadarDopplerClass::IsModeFlag
PUBLIC	?ToggleIFFFlags@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ToggleIFFFlags
PUBLIC	?IsIFFFlags@RadarDopplerClass@@IAEHH@Z		; RadarDopplerClass::IsIFFFlags
PUBLIC	?MENUDisplay@RadarDopplerClass@@IAEXXZ		; RadarDopplerClass::MENUDisplay
PUBLIC	?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z ; RadarDopplerClass::SetGMSPWaypt
PUBLIC	??_GRadarDopplerClass@@UAEPAXI@Z		; RadarDopplerClass::`scalar deleting destructor'
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?TStance@TeamClass@@QAEHE@Z			; TeamClass::TStance
PUBLIC	?Set@HudDataType@@QAEXH@Z			; HudDataType::Set
PUBLIC	?Clear@HudDataType@@QAEXH@Z			; HudDataType::Clear
PUBLIC	?IsICPSet@ICPClass@@QAEHH@Z			; ICPClass::IsICPSet
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7RadarClass@@6B@				; RadarClass::`vftable'
PUBLIC	??_7RadarDopplerClass@@6B@			; RadarDopplerClass::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_04GHIMNPNF@CHAN?$AA@			; `string'
PUBLIC	??_C@_07CMLODLLC@TGT?5HIS?$AA@			; `string'
PUBLIC	??_C@_03FEPNBJLJ@MTR?$AA@			; `string'
PUBLIC	??_C@_02ONPABID@LO?$AA@				; `string'
PUBLIC	??_C@_04CNHPCPAB@DCPL?$AA@			; `string'
PUBLIC	??_C@_03GHGKPJIJ@CPL?$AA@			; `string'
PUBLIC	??_C@_04PKDHFCJF@HIGH?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R0?AVDrawableClass@@@8			; DrawableClass `RTTI Type Descriptor'
PUBLIC	??_R3DrawableClass@@8				; DrawableClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DrawableClass@@8				; DrawableClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DrawableClass@@8			; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RadarDopplerClass@@6B@			; RadarDopplerClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRadarDopplerClass@@@8			; RadarDopplerClass `RTTI Type Descriptor'
PUBLIC	??_R3RadarDopplerClass@@8			; RadarDopplerClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RadarDopplerClass@@8			; RadarDopplerClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RadarDopplerClass@@8		; RadarDopplerClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@RadarClass@@8			; RadarClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRadarClass@@@8				; RadarClass `RTTI Type Descriptor'
PUBLIC	??_R3RadarClass@@8				; RadarClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RadarClass@@8				; RadarClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SensorClass@@8			; SensorClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSensorClass@@@8				; SensorClass `RTTI Type Descriptor'
PUBLIC	??_R3SensorClass@@8				; SensorClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SensorClass@@8				; SensorClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MfdDrawable@@8			; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMfdDrawable@@@8				; MfdDrawable `RTTI Type Descriptor'
PUBLIC	??_R3MfdDrawable@@8				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MfdDrawable@@8				; MfdDrawable::`RTTI Base Class Array'
PUBLIC	??_R4RadarClass@@6B@				; RadarClass::`RTTI Complete Object Locator'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e99999a
PUBLIC	__real@3edf66f1
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f333333
PUBLIC	__real@3f490fd9
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@3f860aa6
PUBLIC	__real@3fa00000
PUBLIC	__real@40400000
PUBLIC	__real@40c00000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	__real@42200000
PUBLIC	__real@42a00000
PUBLIC	__real@43200000
PUBLIC	__real@44960000
PUBLIC	__real@45160000
PUBLIC	__real@461c3c00
PUBLIC	__real@46fffe00
PUBLIC	__real@bf800000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_sprintf:PROC
EXTRN	_fabs:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?DisplayExit@DrawableClass@@UAEXXZ:PROC		; DrawableClass::DisplayExit
EXTRN	?LabelButton@DrawableClass@@QAEXHPAD0H@Z:PROC	; DrawableClass::LabelButton
EXTRN	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z:PROC	; MFDClass::SetNewMode
EXTRN	?PushButton@MfdDrawable@@UAEXHH@Z:PROC		; MfdDrawable::PushButton
EXTRN	?BottomRow@MfdDrawable@@QAEXXZ:PROC		; MfdDrawable::BottomRow
EXTRN	?MFDSwapDisplays@@YAXXZ:PROC			; MFDSwapDisplays
EXTRN	??1SensorClass@@UAE@XZ:PROC			; SensorClass::~SensorClass
EXTRN	?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z:PROC ; SensorClass::SetSensorTargetHack
EXTRN	?CheckLockedTarget@SensorClass@@MAEXXZ:PROC	; SensorClass::CheckLockedTarget
EXTRN	?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z:PROC ; RadarClass::SetSensorTarget
EXTRN	?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z:PROC ; RadarClass::ReturnStrength
EXTRN	??0RadarClass@@QAE@HPAVSimMoverClass@@@Z:PROC	; RadarClass::RadarClass
EXTRN	?DisplayInit@RadarClass@@UAEXPAVImageBuffer@@@Z:PROC ; RadarClass::DisplayInit
EXTRN	?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z:PROC ; RadarClass::SendTrackMsg
EXTRN	?SetPower@RadarClass@@UAEXH@Z:PROC		; RadarClass::SetPower
EXTRN	?SetEmitting@RadarClass@@UAEXH@Z:PROC		; RadarClass::SetEmitting
EXTRN	?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z:PROC ; RadarClass::SetDesiredTarget
EXTRN	?ClearSensorTarget@RadarClass@@UAEXXZ:PROC	; RadarClass::ClearSensorTarget
EXTRN	??_ERadarClass@@UAEPAXI@Z:PROC			; RadarClass::`vector deleting destructor'
EXTRN	?ExecModes@RadarDopplerClass@@UAEXHH@Z:PROC	; RadarDopplerClass::ExecModes
EXTRN	?UpdateState@RadarDopplerClass@@UAEXHH@Z:PROC	; RadarDopplerClass::UpdateState
EXTRN	?Display@RadarDopplerClass@@UAEXPAVVirtualDisplay@@@Z:PROC ; RadarDopplerClass::Display
EXTRN	?StepAAmode@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::StepAAmode
EXTRN	?SetSRMOverride@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::SetSRMOverride
EXTRN	?SetMRMOverride@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::SetMRMOverride
EXTRN	?ClearOverride@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::ClearOverride
EXTRN	?StepAAelvation@RadarDopplerClass@@UAEXH@Z:PROC	; RadarDopplerClass::StepAAelvation
EXTRN	?AntElevKnob@RadarDopplerClass@@UAEMXZ:PROC	; RadarDopplerClass::AntElevKnob
EXTRN	?StepAGmode@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::StepAGmode
EXTRN	?SetAGSnowPlow@RadarDopplerClass@@UAEXH@Z:PROC	; RadarDopplerClass::SetAGSnowPlow
EXTRN	?SetAGSteerpoint@RadarDopplerClass@@UAEXH@Z:PROC ; RadarDopplerClass::SetAGSteerpoint
EXTRN	?ToggleAGfreeze@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::ToggleAGfreeze
EXTRN	?ToggleAGsnowPlow@RadarDopplerClass@@UAEXXZ:PROC ; RadarDopplerClass::ToggleAGsnowPlow
EXTRN	?ToggleAGcursorZero@RadarDopplerClass@@UAEXXZ:PROC ; RadarDopplerClass::ToggleAGcursorZero
EXTRN	?DefaultAGMode@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::DefaultAGMode
EXTRN	?DefaultAAMode@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::DefaultAAMode
EXTRN	?NextTarget@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::NextTarget
EXTRN	?PrevTarget@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::PrevTarget
EXTRN	?SetGroundPoint@RadarDopplerClass@@UAEXMMM@Z:PROC ; RadarDopplerClass::SetGroundPoint
EXTRN	?IsAG@RadarDopplerClass@@UAEHXZ:PROC		; RadarDopplerClass::IsAG
EXTRN	?GetAGCenter@RadarDopplerClass@@UAEXPAM0@Z:PROC	; RadarDopplerClass::GetAGCenter
EXTRN	?GetBuggedData@RadarDopplerClass@@UAEHPAM000@Z:PROC ; RadarDopplerClass::GetBuggedData
EXTRN	?SetMode@RadarDopplerClass@@UAEXW4RadarMode@RadarClass@@@Z:PROC ; RadarDopplerClass::SetMode
EXTRN	?RestoreAGCursor@RadarDopplerClass@@UAEXXZ:PROC	; RadarDopplerClass::RestoreAGCursor
EXTRN	?Remove@TWSTrackList@RadarDopplerClass@@QAEPAV12@PAVSimObjectType@@@Z:PROC ; RadarDopplerClass::TWSTrackList::Remove
EXTRN	?Purge@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ:PROC ; RadarDopplerClass::TWSTrackList::Purge
EXTRN	?ChangeMode@RadarDopplerClass@@IAEXH@Z:PROC	; RadarDopplerClass::ChangeMode
EXTRN	?MoveBeam@RadarDopplerClass@@IAEXXZ:PROC	; RadarDopplerClass::MoveBeam
EXTRN	?SetScan@RadarDopplerClass@@IAEXXZ:PROC		; RadarDopplerClass::SetScan
EXTRN	?LookingAtObject@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z:PROC ; RadarDopplerClass::LookingAtObject
EXTRN	?ObjectDetected@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z:PROC ; RadarDopplerClass::ObjectDetected
EXTRN	?InResCell@RadarDopplerClass@@IAEHPAVSimObjectType@@HPAH11@Z:PROC ; RadarDopplerClass::InResCell
EXTRN	?AddToHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z:PROC ; RadarDopplerClass::AddToHistory
EXTRN	?ClearHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z:PROC ; RadarDopplerClass::ClearHistory
EXTRN	?SlipHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@@Z:PROC ; RadarDopplerClass::SlipHistory
EXTRN	?ExtrapolateHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@@Z:PROC ; RadarDopplerClass::ExtrapolateHistory
EXTRN	?IsUnderCursor@RadarDopplerClass@@IAEHPAVSimObjectType@@M@Z:PROC ; RadarDopplerClass::IsUnderCursor
EXTRN	?IsUnderVSCursor@RadarDopplerClass@@IAEHPAVSimObjectType@@M@Z:PROC ; RadarDopplerClass::IsUnderVSCursor
EXTRN	?SetGMScan@RadarDopplerClass@@IAEXXZ:PROC	; RadarDopplerClass::SetGMScan
EXTRN	?AddTargetReturnCallback@RadarDopplerClass@@KAXPAXPAVRenderGMRadar@@_N@Z:PROC ; RadarDopplerClass::AddTargetReturnCallback
EXTRN	?FreeGMList@RadarDopplerClass@@IAEXPAVGMList@1@@Z:PROC ; RadarDopplerClass::FreeGMList
EXTRN	??_ERadarDopplerClass@@UAEPAXI@Z:PROC		; RadarDopplerClass::`vector deleting destructor'
EXTRN	?Reference@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Reference
EXTRN	?Release@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Release
EXTRN	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetAz
EXTRN	?TargetEl@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetEl
EXTRN	?SetRdrAz@SimBaseClass@@QAEXM@Z:PROC		; SimBaseClass::SetRdrAz
EXTRN	?SetRdrEl@SimBaseClass@@QAEXM@Z:PROC		; SimBaseClass::SetRdrEl
EXTRN	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrAzCenter
EXTRN	?SetRdrElCenter@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrElCenter
EXTRN	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrCycleTime
EXTRN	?SetRdrRng@SimBaseClass@@QAEXM@Z:PROC		; SimBaseClass::SetRdrRng
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??0RenderGMComposite@@QAE@XZ:PROC		; RenderGMComposite::RenderGMComposite
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?CursorRate@RadarClass@@1MB:DWORD		; RadarClass::CursorRate
EXTRN	?TrackUpdateTime@RadarClass@@2KB:DWORD		; RadarClass::TrackUpdateTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?g_bSmartCombatAP@@3_NA:BYTE			; g_bSmartCombatAP
EXTRN	?g_bAGRadarFixes@@3_NA:BYTE			; g_bAGRadarFixes
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_GM_OVERSCAN_RNG DD 01H DUP (?)
_GM_OVERSCAN_H DD 01H DUP (?)
_GM_OVERSCAN_V DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@45160000
CONST	SEGMENT
__real@45160000 DD 045160000r			; 2400
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@43200000
CONST	SEGMENT
__real@43200000 DD 043200000r			; 160
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f860aa6
CONST	SEGMENT
__real@3f860aa6 DD 03f860aa6r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f490fd9
CONST	SEGMENT
__real@3f490fd9 DD 03f490fd9r			; 0.785398
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3edf66f1
CONST	SEGMENT
__real@3edf66f1 DD 03edf66f1r			; 0.436332
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4RadarClass@@6B@
rdata$r	SEGMENT
??_R4RadarClass@@6B@ DD 00H				; RadarClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRadarClass@@@8
	DD	FLAT:??_R3RadarClass@@8
rdata$r	ENDS
;	COMDAT ??_R2MfdDrawable@@8
rdata$r	SEGMENT
??_R2MfdDrawable@@8 DD FLAT:??_R1A@?0A@EA@MfdDrawable@@8 ; MfdDrawable::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3MfdDrawable@@8
rdata$r	SEGMENT
??_R3MfdDrawable@@8 DD 00H				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMfdDrawable@@@8
_DATA	SEGMENT
??_R0?AVMfdDrawable@@@8 DD FLAT:??_7type_info@@6B@	; MfdDrawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMfdDrawable@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@MfdDrawable@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MfdDrawable@@8 DD FLAT:??_R0?AVMfdDrawable@@@8 ; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R2SensorClass@@8
rdata$r	SEGMENT
??_R2SensorClass@@8 DD FLAT:??_R1A@?0A@EA@SensorClass@@8 ; SensorClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3SensorClass@@8
rdata$r	SEGMENT
??_R3SensorClass@@8 DD 00H				; SensorClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SensorClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSensorClass@@@8
_DATA	SEGMENT
??_R0?AVSensorClass@@@8 DD FLAT:??_7type_info@@6B@	; SensorClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSensorClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SensorClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SensorClass@@8 DD FLAT:??_R0?AVSensorClass@@@8 ; SensorClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SensorClass@@8
rdata$r	ENDS
;	COMDAT ??_R2RadarClass@@8
rdata$r	SEGMENT
??_R2RadarClass@@8 DD FLAT:??_R1A@?0A@EA@RadarClass@@8	; RadarClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SensorClass@@8
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3RadarClass@@8
rdata$r	SEGMENT
??_R3RadarClass@@8 DD 00H				; RadarClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2RadarClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRadarClass@@@8
_DATA	SEGMENT
??_R0?AVRadarClass@@@8 DD FLAT:??_7type_info@@6B@	; RadarClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRadarClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@RadarClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RadarClass@@8 DD FLAT:??_R0?AVRadarClass@@@8 ; RadarClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RadarClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RadarDopplerClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RadarDopplerClass@@8 DD FLAT:??_R0?AVRadarDopplerClass@@@8 ; RadarDopplerClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RadarDopplerClass@@8
rdata$r	ENDS
;	COMDAT ??_R2RadarDopplerClass@@8
rdata$r	SEGMENT
??_R2RadarDopplerClass@@8 DD FLAT:??_R1A@?0A@EA@RadarDopplerClass@@8 ; RadarDopplerClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RadarClass@@8
	DD	FLAT:??_R1A@?0A@EA@SensorClass@@8
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3RadarDopplerClass@@8
rdata$r	SEGMENT
??_R3RadarDopplerClass@@8 DD 00H			; RadarDopplerClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2RadarDopplerClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRadarDopplerClass@@@8
_DATA	SEGMENT
??_R0?AVRadarDopplerClass@@@8 DD FLAT:??_7type_info@@6B@ ; RadarDopplerClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRadarDopplerClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RadarDopplerClass@@6B@
rdata$r	SEGMENT
??_R4RadarDopplerClass@@6B@ DD 00H			; RadarDopplerClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRadarDopplerClass@@@8
	DD	FLAT:??_R3RadarDopplerClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DrawableClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DrawableClass@@8 DD FLAT:??_R0?AVDrawableClass@@@8 ; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R2DrawableClass@@8
rdata$r	SEGMENT
??_R2DrawableClass@@8 DD FLAT:??_R1A@?0A@EA@DrawableClass@@8 ; DrawableClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DrawableClass@@8
rdata$r	SEGMENT
??_R3DrawableClass@@8 DD 00H				; DrawableClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawableClass@@@8
_DATA	SEGMENT
??_R0?AVDrawableClass@@@8 DD FLAT:??_7type_info@@6B@	; DrawableClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawableClass@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKDHFCJF@HIGH?$AA@
CONST	SEGMENT
??_C@_04PKDHFCJF@HIGH?$AA@ DB 'HIGH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GHGKPJIJ@CPL?$AA@
CONST	SEGMENT
??_C@_03GHGKPJIJ@CPL?$AA@ DB 'CPL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNHPCPAB@DCPL?$AA@
CONST	SEGMENT
??_C@_04CNHPCPAB@DCPL?$AA@ DB 'DCPL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02ONPABID@LO?$AA@
CONST	SEGMENT
??_C@_02ONPABID@LO?$AA@ DB 'LO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEPNBJLJ@MTR?$AA@
CONST	SEGMENT
??_C@_03FEPNBJLJ@MTR?$AA@ DB 'MTR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMLODLLC@TGT?5HIS?$AA@
CONST	SEGMENT
??_C@_07CMLODLLC@TGT?5HIS?$AA@ DB 'TGT HIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHIMNPNF@CHAN?$AA@
CONST	SEGMENT
??_C@_04GHIMNPNF@CHAN?$AA@ DB 'CHAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7RadarDopplerClass@@6B@
CONST	SEGMENT
??_7RadarDopplerClass@@6B@ DD FLAT:??_R4RadarDopplerClass@@6B@ ; RadarDopplerClass::`vftable'
	DD	FLAT:??_ERadarDopplerClass@@UAEPAXI@Z
	DD	FLAT:?Display@RadarDopplerClass@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@RadarDopplerClass@@UAEXHH@Z
	DD	FLAT:?SetType@SensorClass@@UAEXW4SensorType@1@@Z
	DD	FLAT:?SetPower@RadarClass@@UAEXH@Z
	DD	FLAT:?IsOn@SensorClass@@UAEHXZ
	DD	FLAT:?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z
	DD	FLAT:?ClearSensorTarget@RadarDopplerClass@@MAEXXZ
	DD	FLAT:?Exec@RadarDopplerClass@@UAEPAVSimObjectType@@PAV2@@Z
	DD	FLAT:?ExecModes@RadarDopplerClass@@UAEXHH@Z
	DD	FLAT:?UpdateState@RadarDopplerClass@@UAEXHH@Z
	DD	FLAT:?SetSeekerPos@SensorClass@@UAEXMM@Z
	DD	FLAT:?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetSensorTarget@RadarDopplerClass@@MAEXPAVSimObjectType@@@Z
	DD	FLAT:?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z
	DD	FLAT:?CheckLockedTarget@SensorClass@@MAEXXZ
	DD	FLAT:?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z
	DD	FLAT:?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z
	DD	FLAT:?SetEmitting@RadarClass@@UAEXH@Z
	DD	FLAT:?RangeStep@RadarDopplerClass@@UAEXH@Z
	DD	FLAT:?NextTarget@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?PrevTarget@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?DefaultAAMode@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAAmode@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SetSRMOverride@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SetMRMOverride@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?ClearOverride@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectACMVertical@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectACMBore@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectACMSlew@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectACM30x20@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAAscanHeight@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAAscanWidth@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAAelvation@RadarDopplerClass@@UAEXH@Z
	DD	FLAT:?DefaultAGMode@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAGmode@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAGfov@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?StepAGgain@RadarDopplerClass@@UAEXH@Z
	DD	FLAT:?SetMode@RadarDopplerClass@@UAEXW4RadarMode@RadarClass@@@Z
	DD	FLAT:?ToggleAGfreeze@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?ToggleAGsnowPlow@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SetAGSnowPlow@RadarDopplerClass@@UAEXH@Z
	DD	FLAT:?ToggleAGcursorZero@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SetGroundPoint@RadarDopplerClass@@UAEXMMM@Z
	DD	FLAT:?IsAG@RadarDopplerClass@@UAEHXZ
	DD	FLAT:?GetAGCenter@RadarDopplerClass@@UAEXPAM0@Z
	DD	FLAT:?GetRange@RadarDopplerClass@@UAEMXZ
	DD	FLAT:?GetVolume@RadarDopplerClass@@UAEMXZ
	DD	FLAT:?GetCursorPosition@RadarDopplerClass@@UAEXPAM0@Z
	DD	FLAT:?GetBuggedData@RadarDopplerClass@@UAEHPAM000@Z
	DD	FLAT:?ClearModeDesiredCmd@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
	DD	FLAT:?GetRadarMode@RadarDopplerClass@@UAE?AW4RadarMode@RadarClass@@XZ
	DD	FLAT:?SelectTWS@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectRWS@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectSAM@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectGMT@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectGM@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectAGR@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SelectLastAGMode@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?AntElevKnob@RadarDopplerClass@@UAEMXZ
	DD	FLAT:?SetAGSteerpoint@RadarDopplerClass@@UAEXH@Z
	DD	FLAT:?RestoreAGCursor@RadarDopplerClass@@UAEXXZ
	DD	FLAT:?SetAutoAGRange@RadarDopplerClass@@UAEX_N@Z
CONST	ENDS
;	COMDAT ??_7RadarClass@@6B@
CONST	SEGMENT
??_7RadarClass@@6B@ DD FLAT:??_R4RadarClass@@6B@	; RadarClass::`vftable'
	DD	FLAT:??_ERadarClass@@UAEPAXI@Z
	DD	FLAT:?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@RadarClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@MfdDrawable@@UAEXHH@Z
	DD	FLAT:?SetType@SensorClass@@UAEXW4SensorType@1@@Z
	DD	FLAT:?SetPower@RadarClass@@UAEXH@Z
	DD	FLAT:?IsOn@SensorClass@@UAEHXZ
	DD	FLAT:?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z
	DD	FLAT:?ClearSensorTarget@RadarClass@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:?ExecModes@SensorClass@@UAEXHH@Z
	DD	FLAT:?UpdateState@SensorClass@@UAEXHH@Z
	DD	FLAT:?SetSeekerPos@SensorClass@@UAEXMM@Z
	DD	FLAT:?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z
	DD	FLAT:?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z
	DD	FLAT:?CheckLockedTarget@SensorClass@@MAEXXZ
	DD	FLAT:?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z
	DD	FLAT:?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z
	DD	FLAT:?SetEmitting@RadarClass@@UAEXH@Z
	DD	FLAT:?RangeStep@RadarClass@@UAEXH@Z
	DD	FLAT:?NextTarget@RadarClass@@UAEXXZ
	DD	FLAT:?PrevTarget@RadarClass@@UAEXXZ
	DD	FLAT:?DefaultAAMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAmode@RadarClass@@UAEXXZ
	DD	FLAT:?SetSRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SetMRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?ClearOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMVertical@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMBore@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMSlew@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACM30x20@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanHeight@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanWidth@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAelvation@RadarClass@@UAEXH@Z
	DD	FLAT:?DefaultAGMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGmode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGfov@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGgain@RadarClass@@UAEXH@Z
	DD	FLAT:?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z
	DD	FLAT:?ToggleAGfreeze@RadarClass@@UAEXXZ
	DD	FLAT:?ToggleAGsnowPlow@RadarClass@@UAEXXZ
	DD	FLAT:?SetAGSnowPlow@RadarClass@@UAEXH@Z
	DD	FLAT:?ToggleAGcursorZero@RadarClass@@UAEXXZ
	DD	FLAT:?SetGroundPoint@RadarClass@@UAEXMMM@Z
	DD	FLAT:?IsAG@RadarClass@@UAEHXZ
	DD	FLAT:?GetAGCenter@RadarClass@@UAEXPAM0@Z
	DD	FLAT:?GetRange@RadarClass@@UAEMXZ
	DD	FLAT:?GetVolume@RadarClass@@UAEMXZ
	DD	FLAT:?GetCursorPosition@RadarClass@@UAEXPAM0@Z
	DD	FLAT:?GetBuggedData@RadarClass@@UAEHPAM000@Z
	DD	FLAT:?ClearModeDesiredCmd@RadarClass@@UAEXXZ
	DD	FLAT:?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z$0
__unwindtable$??1RadarDopplerClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RadarDopplerClass@@UAE@XZ$0
__unwindtable$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z$0
__ehfuncinfo$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1RadarDopplerClass@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1RadarDopplerClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_GM_OVERSCAN_RNG$initializer$ DD FLAT:??__EGM_OVERSCAN_RNG@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_GM_OVERSCAN_H$initializer$ DD FLAT:??__EGM_OVERSCAN_H@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_GM_OVERSCAN_V$initializer$ DD FLAT:??__EGM_OVERSCAN_V@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?IsICPSet@ICPClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsICPSet@ICPClass@@QAEHH@Z PROC			; ICPClass::IsICPSet, COMDAT
; _this$ = ecx

; 499  : 	int IsICPSet (int testFlag) {return ICPModeFlags & testFlag ? 1 : 0;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1376]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsICPSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsICPSet
$LN3@IsICPSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsICPSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsICPSet@ICPClass@@QAEHH@Z ENDP			; ICPClass::IsICPSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?Clear@HudDataType@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_testFlag$ = 8						; size = 4
?Clear@HudDataType@@QAEXH@Z PROC			; HudDataType::Clear, COMDAT
; _this$ = ecx

; 72   : 	void	Clear (int testFlag)	{ flags &= ~testFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _testFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@HudDataType@@QAEXH@Z ENDP			; HudDataType::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?Set@HudDataType@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_testFlag$ = 8						; size = 4
?Set@HudDataType@@QAEXH@Z PROC				; HudDataType::Set, COMDAT
; _this$ = ecx

; 71   : 	void	Set (int testFlag)		{ flags |= testFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, DWORD PTR _testFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Set@HudDataType@@QAEXH@Z ENDP				; HudDataType::Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?TStance@TeamClass@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_team$ = 8						; size = 1
?TStance@TeamClass@@QAEHE@Z PROC			; TeamClass::TStance, COMDAT
; _this$ = ecx

; 317  : 	int TStance(Team team)						{ return stance[team]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _team$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [ecx+eax*2+580]
	mov	esp, ebp
	pop	ebp
	ret	4
?TStance@TeamClass@@QAEHE@Z ENDP			; TeamClass::TStance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\gmcomposit.h
;	COMDAT ??__EGM_OVERSCAN_V@@YAXXZ
text$yc	SEGMENT
??__EGM_OVERSCAN_V@@YAXXZ PROC				; `dynamic initializer for 'GM_OVERSCAN_V'', COMDAT

; 21   : static const float	GM_OVERSCAN_V		= 1.0f + GM_OVERSCAN + GM_OVERSCAN;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _GM_OVERSCAN
	addss	xmm0, DWORD PTR _GM_OVERSCAN
	movss	DWORD PTR _GM_OVERSCAN_V, xmm0
	pop	ebp
	ret	0
??__EGM_OVERSCAN_V@@YAXXZ ENDP				; `dynamic initializer for 'GM_OVERSCAN_V''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\gmcomposit.h
;	COMDAT ??__EGM_OVERSCAN_H@@YAXXZ
text$yc	SEGMENT
??__EGM_OVERSCAN_H@@YAXXZ PROC				; `dynamic initializer for 'GM_OVERSCAN_H'', COMDAT

; 20   : static const float	GM_OVERSCAN_H		= 1.0f + GM_OVERSCAN;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _GM_OVERSCAN
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _GM_OVERSCAN_H, xmm0
	pop	ebp
	ret	0
??__EGM_OVERSCAN_H@@YAXXZ ENDP				; `dynamic initializer for 'GM_OVERSCAN_H''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\gmcomposit.h
;	COMDAT ??__EGM_OVERSCAN_RNG@@YAXXZ
text$yc	SEGMENT
??__EGM_OVERSCAN_RNG@@YAXXZ PROC			; `dynamic initializer for 'GM_OVERSCAN_RNG'', COMDAT

; 19   : static const float	GM_OVERSCAN_RNG		= 1.0f + GM_OVERSCAN;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _GM_OVERSCAN
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _GM_OVERSCAN_RNG, xmm0
	pop	ebp
	ret	0
??__EGM_OVERSCAN_RNG@@YAXXZ ENDP			; `dynamic initializer for 'GM_OVERSCAN_RNG''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRadarDopplerClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRadarDopplerClass@@UAEPAXI@Z PROC			; RadarDopplerClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarDopplerClass@@UAE@XZ		; RadarDopplerClass::~RadarDopplerClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRadarDopplerClass@@UAEPAXI@Z ENDP			; RadarDopplerClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_pt$ = 8						; size = 4
?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z PROC ; RadarDopplerClass::SetGMSPWaypt
; _this$ = ecx

; 1234 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1235 : 	if (GMSPPseudoWaypt)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+536], 0
	je	SHORT $LN4@SetGMSPWay

; 1236 : 	{ 
; 1237 : 		// MLR 5/10/2004 - CTD/HEAP issues, the FCC was using this object after it had
; 1238 : 		// been freed. 
; 1239 : 		if(((AircraftClass *)platform)->curWaypoint == GMSPPseudoWaypt)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+728]
	cmp	ecx, DWORD PTR [eax+536]
	jne	SHORT $LN3@SetGMSPWay

; 1240 : 		{
; 1241 : 			((AircraftClass *)platform)->curWaypoint = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+728], 0
$LN3@SetGMSPWay:

; 1242 : 		}
; 1243 : 		delete GMSPPseudoWaypt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@SetGMSPWay:

; 1244 : 	}
; 1245 : 	if (pt)

	cmp	DWORD PTR _pt$[ebp], 0
	je	SHORT $LN2@SetGMSPWay

; 1246 : 	{
; 1247 : 		GMSPPseudoWaypt = pt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [ecx+536], edx

; 1248 : 		// MD -- 20040515: following up on Mike's catch for the HEAP related CTD:
; 1249 : 		// if you do set a new valid Pseudo point, make sure the FCC knows about it.
; 1250 : 		((AircraftClass *)platform)->curWaypoint = GMSPPseudoWaypt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+536]
	mov	DWORD PTR [ecx+728], eax

; 1251 : 	}
; 1252 : 	else

	jmp	SHORT $LN5@SetGMSPWay
$LN2@SetGMSPWay:

; 1253 : 	{
; 1254 : 		GMSPPseudoWaypt = (WayPointClass *)NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], 0
$LN5@SetGMSPWay:

; 1255 : 	}
; 1256 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z ENDP ; RadarDopplerClass::SetGMSPWaypt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
tv92 = -108						; size = 4
tv182 = -104						; size = 4
tv251 = -100						; size = 4
tv157 = -96						; size = 4
_this$ = -92						; size = 4
_i$1 = -88						; size = 4
_tbuf$2 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
?MENUDisplay@RadarDopplerClass@@IAEXXZ PROC		; RadarDopplerClass::MENUDisplay
; _this$ = ecx

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 561  :     if (IsSet(MenuMode)) {

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	$LN14@MENUDispla

; 562  : 	for (int i = 0; i < 20; i++) 

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN13@MENUDispla
$LN12@MENUDispla:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN13@MENUDispla:
	cmp	DWORD PTR _i$1[ebp], 20			; 00000014H
	jge	$LN11@MENUDispla

; 563  : 	{
; 564  : 		//MI make it master mode dependant
; 565  : 		if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&
; 566  : 			OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_A))

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	$LN10@MENUDispla
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN10@MENUDispla
	push	1
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN10@MENUDispla

; 567  : 		{
; 568  : 			if(rmenuaa[i].label1)

	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR _rmenuaa[eax], 0
	je	SHORT $LN9@MENUDispla

; 569  : 				LabelButton(i, rmenuaa[i].label1, rmenuaa[i].label2, mode == rmenuaa[i].mode);

	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	cmp	eax, DWORD PTR _rmenuaa[ecx+8]
	jne	SHORT $LN17@MENUDispla
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN18@MENUDispla
$LN17@MENUDispla:
	mov	DWORD PTR tv92[ebp], 0
$LN18@MENUDispla:
	mov	ecx, DWORD PTR tv92[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _rmenuaa[edx+4]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _rmenuaa[ecx]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN9@MENUDispla:

; 570  : 		}
; 571  : 		else if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&

	jmp	$LN8@MENUDispla
$LN10@MENUDispla:

; 572  : 			OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_G))

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	$LN7@MENUDispla
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [ecx+688], 0
	je	SHORT $LN7@MENUDispla
	push	2
	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN7@MENUDispla

; 573  : 		{
; 574  : 			if(rmenuag[i].label1)

	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR _rmenuag[eax], 0
	je	SHORT $LN6@MENUDispla

; 575  : 				LabelButton(i, rmenuag[i].label1, rmenuag[i].label2, mode == rmenuag[i].mode);

	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	cmp	eax, DWORD PTR _rmenuag[ecx+8]
	jne	SHORT $LN19@MENUDispla
	mov	DWORD PTR tv157[ebp], 1
	jmp	SHORT $LN20@MENUDispla
$LN19@MENUDispla:
	mov	DWORD PTR tv157[ebp], 0
$LN20@MENUDispla:
	mov	ecx, DWORD PTR tv157[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _rmenuag[edx+4]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _rmenuag[ecx]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN6@MENUDispla:

; 576  : 		}
; 577  : 		else

	jmp	SHORT $LN8@MENUDispla
$LN7@MENUDispla:

; 578  : 		{
; 579  : 			if(rmenu[i].label1)

	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 12					; 0000000cH
	cmp	DWORD PTR _rmenu[ecx], 0
	je	SHORT $LN8@MENUDispla

; 580  : 			LabelButton(i, rmenu[i].label1, rmenu[i].label2, mode == rmenu[i].mode);

	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	cmp	ecx, DWORD PTR _rmenu[edx+8]
	jne	SHORT $LN21@MENUDispla
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN22@MENUDispla
$LN21@MENUDispla:
	mov	DWORD PTR tv182[ebp], 0
$LN22@MENUDispla:
	mov	edx, DWORD PTR tv182[ebp]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _rmenu[eax+4]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _rmenu[edx]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN8@MENUDispla:

; 581  : 		}
; 582  : 	}

	jmp	$LN12@MENUDispla
$LN11@MENUDispla:

; 583  :     }
; 584  :     else {

	jmp	$LN3@MENUDispla
$LN14@MENUDispla:

; 585  : 	char tbuf[80];
; 586  : 
; 587  : 	sprintf (tbuf, "%d", channelno);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+548]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	ecx, DWORD PTR _tbuf$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 588  : 	LabelButton(5, "CHAN", tbuf);

	push	0
	lea	edx, DWORD PTR _tbuf$2[ebp]
	push	edx
	push	OFFSET ??_C@_04GHIMNPNF@CHAN?$AA@
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 589  : #if 0 // while we work out if this is ok.
; 590  : 	sprintf (tbuf, "%d", mkint);
; 591  : 	LabelButton(6, "MK INT", tbuf);
; 592  : 	LabelButton(7, "BAND", IsModeFlag(NaroBand) ? "NARO" : "WIDE");
; 593  : 	sprintf (tbuf, "%.2f", bdelay);
; 594  : 	LabelButton(8, "BCN DLY", tbuf);
; 595  : 	LabelButton(9, "PM", IsModeFlag(PmMode) ? "ON" : "OFF");
; 596  : 
; 597  : 	sprintf (tbuf, "%d", level);
; 598  : 	LabelButton(16, "LVL", tbuf);
; 599  : #endif
; 600  : 	if (IsIFFFlags(Dcpl))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIFFFlags@RadarDopplerClass@@IAEHH@Z	; RadarDopplerClass::IsIFFFlags
	test	eax, eax
	je	SHORT $LN2@MENUDispla

; 601  : 		LabelButton(9, "DCPL");//Cobra

	push	0
	push	0
	push	OFFSET ??_C@_04CNHPCPAB@DCPL?$AA@
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 602  : 	else

	jmp	SHORT $LN1@MENUDispla
$LN2@MENUDispla:

; 603  : 		LabelButton(9, "CPL");//Cobra

	push	0
	push	0
	push	OFFSET ??_C@_03GHGKPJIJ@CPL?$AA@
	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN1@MENUDispla:

; 604  : 
; 605  : 	sprintf (tbuf, "%d", histno);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+552]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	edx, DWORD PTR _tbuf$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 606  : 	LabelButton(17, "TGT HIS", tbuf);

	push	0
	lea	eax, DWORD PTR _tbuf$2[ebp]
	push	eax
	push	OFFSET ??_C@_07CMLODLLC@TGT?5HIS?$AA@
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton

; 607  : #if 0 // while we work out if this is ok.
; 608  : 	LabelButton(18, "ALT TRK", IsModeFlag(AltTrack) ? "ON" : "OFF");
; 609  : #endif
; 610  : 	LabelButton(19, "MTR", IsModeFlag(SpeedLo) ? "LO" : "HIGH");

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsModeFlag@RadarDopplerClass@@IAEHH@Z	; RadarDopplerClass::IsModeFlag
	test	eax, eax
	je	SHORT $LN23@MENUDispla
	mov	DWORD PTR tv251[ebp], OFFSET ??_C@_02ONPABID@LO?$AA@
	jmp	SHORT $LN24@MENUDispla
$LN23@MENUDispla:
	mov	DWORD PTR tv251[ebp], OFFSET ??_C@_04PKDHFCJF@HIGH?$AA@
$LN24@MENUDispla:
	push	0
	mov	ecx, DWORD PTR tv251[ebp]
	push	ecx
	push	OFFSET ??_C@_03FEPNBJLJ@MTR?$AA@
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LabelButton@DrawableClass@@QAEXHPAD0H@Z ; DrawableClass::LabelButton
$LN3@MENUDispla:

; 611  :     }
; 612  :     BottomRow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BottomRow@MfdDrawable@@QAEXXZ		; MfdDrawable::BottomRow

; 613  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?MENUDisplay@RadarDopplerClass@@IAEXXZ ENDP		; RadarDopplerClass::MENUDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsIFFFlags@RadarDopplerClass@@IAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_flag$ = 8						; size = 4
?IsIFFFlags@RadarDopplerClass@@IAEHH@Z PROC		; RadarDopplerClass::IsIFFFlags, COMDAT
; _this$ = ecx

; 369  :    int IsIFFFlags(int flag) { return (iffmodeflags & flag) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+572]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsIFFFlags
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsIFFFlags
$LN3@IsIFFFlags:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsIFFFlags:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIFFFlags@RadarDopplerClass@@IAEHH@Z ENDP		; RadarDopplerClass::IsIFFFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ToggleIFFFlags@RadarDopplerClass@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ToggleIFFFlags@RadarDopplerClass@@IAEXH@Z PROC		; RadarDopplerClass::ToggleIFFFlags, COMDAT
; _this$ = ecx

; 368  :    void ToggleIFFFlags (int flag) { iffmodeflags ^= flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+572]
	xor	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+572], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleIFFFlags@RadarDopplerClass@@IAEXH@Z ENDP		; RadarDopplerClass::ToggleIFFFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsModeFlag@RadarDopplerClass@@IAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_flag$ = 8						; size = 4
?IsModeFlag@RadarDopplerClass@@IAEHH@Z PROC		; RadarDopplerClass::IsModeFlag, COMDAT
; _this$ = ecx

; 358  :    int IsModeFlag(int flag) { return (radarmodeflags & flag) ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+568]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsModeFlag
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsModeFlag
$LN3@IsModeFlag:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsModeFlag:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsModeFlag@RadarDopplerClass@@IAEHH@Z ENDP		; RadarDopplerClass::IsModeFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z PROC		; RadarDopplerClass::ToggleModeFlag, COMDAT
; _this$ = ecx

; 357  :    void ToggleModeFlag (int flag) { radarmodeflags ^= flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+568]
	xor	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+568], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z ENDP		; RadarDopplerClass::ToggleModeFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ToggleFlag@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ToggleFlag@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ToggleFlag, COMDAT
; _this$ = ecx

; 239  : 	void ToggleFlag (int flag) {flags ^= flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	xor	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ToggleFlag@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ToggleFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ClearFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ClearFlagBit, COMDAT
; _this$ = ecx

; 238  : 	void ClearFlagBit (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+492]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ClearFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::SetFlagBit, COMDAT
; _this$ = ecx

; 237  :    void SetFlagBit (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::SetFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsSet@RadarDopplerClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@RadarDopplerClass@@QAEHH@Z PROC			; RadarDopplerClass::IsSet, COMDAT
; _this$ = ecx

; 236  :    int  IsSet (int newFlag) {return (newFlag & flags) ? TRUE : FALSE;}; //MI moved to public

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	and	ecx, DWORD PTR [eax+492]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@RadarDopplerClass@@QAEHH@Z ENDP			; RadarDopplerClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTarget$ = 8						; size = 4
?SetSensorTarget@RadarDopplerClass@@MAEXPAVSimObjectType@@@Z PROC ; RadarDopplerClass::SetSensorTarget
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 197  : 	if (newTarget)

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	SHORT $LN2@SetSensorT

; 198  : 		lockedTargetData = newTarget->localData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTarget$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+176], edx

; 199  : 	else

	jmp	SHORT $LN1@SetSensorT
$LN2@SetSensorT:

; 200  : 		lockedTargetData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+176], 0
$LN1@SetSensorT:

; 201  : 	RadarClass::SetSensorTarget(newTarget);

	mov	ecx, DWORD PTR _newTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z ; RadarClass::SetSensorTarget

; 202  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSensorTarget@RadarDopplerClass@@MAEXPAVSimObjectType@@@Z ENDP ; RadarDopplerClass::SetSensorTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearSensorTarget@RadarDopplerClass@@MAEXXZ PROC	; RadarDopplerClass::ClearSensorTarget
; _this$ = ecx

; 205  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 	 if (lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN1@ClearSenso

; 207  : 	{
; 208  : 		SendTrackMsg (lockedTarget, Track_Unlock);

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN1@ClearSenso:

; 209  : 	}
; 210  : 	lockedTargetData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], 0

; 211  : 	RadarClass::ClearSensorTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearSensorTarget@RadarClass@@UAEXXZ	; RadarClass::ClearSensorTarget

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearSensorTarget@RadarDopplerClass@@MAEXXZ ENDP	; RadarDopplerClass::ClearSensorTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetAutoAGRange@RadarDopplerClass@@UAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 1
?SetAutoAGRange@RadarDopplerClass@@UAEX_N@Z PROC	; RadarDopplerClass::SetAutoAGRange, COMDAT
; _this$ = ecx

; 116  : 	virtual void SetAutoAGRange(bool flag) { WasAutoAGRange = flag; }  // MD -- 20040305: saint's range command F3/F4 fix

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _flag$[ebp]
	mov	BYTE PTR [eax+940], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAutoAGRange@RadarDopplerClass@@UAEX_N@Z ENDP	; RadarDopplerClass::SetAutoAGRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ClearModeDesiredCmd@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearModeDesiredCmd@RadarDopplerClass@@UAEXXZ PROC	; RadarDopplerClass::ClearModeDesiredCmd, COMDAT
; _this$ = ecx

; 113  : 	virtual void ClearModeDesiredCmd(void)	{modeDesiredCmd = -1;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], -1
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearModeDesiredCmd@RadarDopplerClass@@UAEXXZ ENDP	; RadarDopplerClass::ClearModeDesiredCmd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_trig$ = -20						; size = 8
_az$ = -12						; size = 4
_range$ = -8						; size = 4
_this$ = -4						; size = 4
_xPos$ = 8						; size = 4
_yPos$ = 12						; size = 4
?GetCursorPosition@RadarDopplerClass@@UAEXPAM0@Z PROC	; RadarDopplerClass::GetCursorPosition
; _this$ = ecx

; 1215 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1216 : float range, az;
; 1217 : mlTrig trig;
; 1218 : 
; 1219 :    // Correct for azimuth skew towards bottom of the hud
; 1220 :    range = (cursorY + 1.0F) * displayRange * 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+212]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _range$[ebp], xmm0

; 1221 :    az = cursorX * MAX_ANT_EL;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR _az$[ebp], xmm0

; 1222 :    mlSinCos (&trig, az);

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1223 : 
; 1224 :    *xPos = range * trig.cos;

	movss	xmm0, DWORD PTR _range$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	mov	ecx, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 1225 :    *yPos = range * trig.sin;

	movss	xmm0, DWORD PTR _range$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	mov	edx, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1226 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetCursorPosition@RadarDopplerClass@@UAEXPAM0@Z ENDP	; RadarDopplerClass::GetCursorPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?GetVolume@RadarDopplerClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVolume@RadarDopplerClass@@UAEMXZ PROC		; RadarDopplerClass::GetVolume, COMDAT
; _this$ = ecx

; 106  : 	virtual float GetVolume (void)					{ return azScan; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+204]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVolume@RadarDopplerClass@@UAEMXZ ENDP		; RadarDopplerClass::GetVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?GetRange@RadarDopplerClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRange@RadarDopplerClass@@UAEMXZ PROC		; RadarDopplerClass::GetRange, COMDAT
; _this$ = ecx

; 105  : 	virtual float GetRange (void)					{ return displayRange; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+212]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRange@RadarDopplerClass@@UAEMXZ ENDP		; RadarDopplerClass::GetRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?StepAGgain@RadarDopplerClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_cmd$ = 8						; size = 4
?StepAGgain@RadarDopplerClass@@UAEXH@Z PROC		; RadarDopplerClass::StepAGgain, COMDAT
; _this$ = ecx

; 89   : 	virtual void StepAGgain( int cmd )				{ gainCmd = (cmd>0) ? 1.25f : 0.8f; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _cmd$[ebp], 0
	jle	SHORT $LN3@StepAGgain
	movss	xmm0, DWORD PTR __real@3fa00000
	movss	DWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN4@StepAGgain
$LN3@StepAGgain:
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv66[ebp], xmm0
$LN4@StepAGgain:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR [eax+136], xmm0
	mov	esp, ebp
	pop	ebp
	ret	4
?StepAGgain@RadarDopplerClass@@UAEXH@Z ENDP		; RadarDopplerClass::StepAGgain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?StepAGfov@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGfov@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::StepAGfov, COMDAT
; _this$ = ecx

; 88   : 	virtual void StepAGfov()						{ fovStepCmd = TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGfov@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::StepAGfov
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?StepAAscanWidth@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAscanWidth@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::StepAAscanWidth, COMDAT
; _this$ = ecx

; 82   : 	virtual void StepAAscanWidth()					{ scanWidthCmd = TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAscanWidth@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::StepAAscanWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?StepAAscanHeight@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAscanHeight@RadarDopplerClass@@UAEXXZ PROC	; RadarDopplerClass::StepAAscanHeight, COMDAT
; _this$ = ecx

; 81   : 	virtual void StepAAscanHeight()					{ scanHeightCmd = TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 1
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAscanHeight@RadarDopplerClass@@UAEXXZ ENDP	; RadarDopplerClass::StepAAscanHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectLastAGMode@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectLastAGMode@RadarDopplerClass@@UAEXXZ PROC	; RadarDopplerClass::SelectLastAGMode, COMDAT
; _this$ = ecx

; 76   : 	virtual void SelectLastAGMode(void)				{ ChangeMode(LastAGMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectLastAGMode@RadarDopplerClass@@UAEXXZ ENDP	; RadarDopplerClass::SelectLastAGMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectAGR@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectAGR@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectAGR, COMDAT
; _this$ = ecx

; 75   : 	virtual void SelectAGR(void)					{ modeDesiredCmd = AGR;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 20			; 00000014H
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectAGR@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectAGR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectGM@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectGM@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectGM, COMDAT
; _this$ = ecx

; 74   : 	virtual void SelectGM(void)						{ modeDesiredCmd = GM;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 14			; 0000000eH
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectGM@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectGM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectGMT@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectGMT@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectGMT, COMDAT
; _this$ = ecx

; 73   : 	virtual void SelectGMT(void)					{ modeDesiredCmd = GMT;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 16			; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectGMT@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectGMT
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawRCRCount@RadarDopplerClass@@QAEXXZ PROC		; RadarDopplerClass::DrawRCRCount
; _this$ = ecx

; 1229 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1230 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawRCRCount@RadarDopplerClass@@QAEXXZ ENDP		; RadarDopplerClass::DrawRCRCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectSAM@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectSAM@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectSAM, COMDAT
; _this$ = ecx

; 70   : 	virtual void SelectSAM(void)					{ if(prevMode == LRS) modeDesiredCmd = LRS; else modeDesiredCmd = RWS; ClearFlagBit(STTingTarget);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 3
	jne	SHORT $LN2@SelectSAM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 3
	jmp	SHORT $LN1@SelectSAM
$LN2@SelectSAM:
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 2
$LN1@SelectSAM:
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectSAM@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectSAM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectRWS@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectRWS@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectRWS, COMDAT
; _this$ = ecx

; 69   : 	virtual void SelectRWS(void)					{ modeDesiredCmd = RWS;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 2
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectRWS@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectRWS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectTWS@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectTWS@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectTWS, COMDAT
; _this$ = ecx

; 68   : 	virtual void SelectTWS(void)					{ modeDesiredCmd = TWS;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 4
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectTWS@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectTWS
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?GetRadarMode@RadarDopplerClass@@UAE?AW4RadarMode@RadarClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@RadarDopplerClass@@UAE?AW4RadarMode@RadarClass@@XZ PROC ; RadarDopplerClass::GetRadarMode, COMDAT
; _this$ = ecx

; 67   : 	virtual RadarMode	GetRadarMode(void)	{return mode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@RadarDopplerClass@@UAE?AW4RadarMode@RadarClass@@XZ ENDP ; RadarDopplerClass::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectACM30x20@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACM30x20@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectACM30x20, COMDAT
; _this$ = ecx

; 64   : 	virtual void SelectACM30x20()					{ modeDesiredCmd = ACM_30x20; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 6
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACM30x20@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectACM30x20
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectACMSlew@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMSlew@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectACMSlew, COMDAT
; _this$ = ecx

; 63   : 	virtual void SelectACMSlew()					{ modeDesiredCmd = ACM_SLEW; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 7
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMSlew@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectACMSlew
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectACMBore@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMBore@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SelectACMBore, COMDAT
; _this$ = ecx

; 62   : 	virtual void SelectACMBore()					{ modeDesiredCmd = ACM_BORE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 8
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMBore@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SelectACMBore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SelectACMVertical@RadarDopplerClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMVertical@RadarDopplerClass@@UAEXXZ PROC	; RadarDopplerClass::SelectACMVertical, COMDAT
; _this$ = ecx

; 61   : 	virtual void SelectACMVertical()				{ modeDesiredCmd = ACM_10x60; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 9
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMVertical@RadarDopplerClass@@UAEXXZ ENDP	; RadarDopplerClass::SelectACMVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?RangeStep@RadarDopplerClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cmd$ = 8						; size = 4
?RangeStep@RadarDopplerClass@@UAEXH@Z PROC		; RadarDopplerClass::RangeStep, COMDAT
; _this$ = ecx

; 54   : 	virtual void RangeStep( int cmd )				{ rangeChangeCmd = cmd; };	// Step up/down in range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax+140], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?RangeStep@RadarDopplerClass@@UAEXH@Z ENDP		; RadarDopplerClass::RangeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
tv86 = -24						; size = 4
tv81 = -20						; size = 4
tv72 = -16						; size = 4
tv67 = -12						; size = 4
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?CtlPushButton@RadarDopplerClass@@QAEXHH@Z PROC		; RadarDopplerClass::CtlPushButton
; _this$ = ecx

; 647  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 648  :     switch (whichButton) {

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 5
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 14			; 0000000eH
	ja	$LN16@CtlPushBut
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN18@CtlPushBut[edx]
	jmp	DWORD PTR $LN19@CtlPushBut[eax*4]
$LN13@CtlPushBut:

; 649  :     case 5:
; 650  : 	if (++channelno > 4)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	add	edx, 1
	mov	DWORD PTR tv67[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR [eax+548], ecx
	cmp	DWORD PTR tv67[ebp], 4
	jle	SHORT $LN12@CtlPushBut

; 651  : 	    channelno = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+548], 1
$LN12@CtlPushBut:

; 652  : 	break;

	jmp	$LN16@CtlPushBut
$LN11@CtlPushBut:

; 653  :     case 6:
; 654  : 	if (++mkint > 4)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+560]
	add	ecx, 1
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR [edx+560], eax
	cmp	DWORD PTR tv72[ebp], 4
	jle	SHORT $LN10@CtlPushBut

; 655  : 	    mkint = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], 1
$LN10@CtlPushBut:

; 656  : 	break;

	jmp	$LN16@CtlPushBut
$LN9@CtlPushBut:

; 657  :     case 7:
; 658  : 	ToggleModeFlag (NaroBand);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z ; RadarDopplerClass::ToggleModeFlag

; 659  : 	break;

	jmp	$LN16@CtlPushBut

; 660  :     case 8:
; 661  : 	break;

	jmp	$LN16@CtlPushBut
$LN7@CtlPushBut:

; 662  :     case 9:
; 663  : 	//ToggleModeFlag(PmMode);
; 664  : 	ToggleIFFFlags(Dcpl);//Cobra

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleIFFFlags@RadarDopplerClass@@IAEXH@Z ; RadarDopplerClass::ToggleIFFFlags

; 665  : 	break;

	jmp	SHORT $LN16@CtlPushBut
$LN6@CtlPushBut:

; 666  :     case 16:
; 667  : 	if (++level > 4)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+556]
	add	eax, 1
	mov	DWORD PTR tv81[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [ecx+556], edx
	cmp	DWORD PTR tv81[ebp], 4
	jle	SHORT $LN5@CtlPushBut

; 668  : 	    level = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+556], 1
$LN5@CtlPushBut:

; 669  : 	break;

	jmp	SHORT $LN16@CtlPushBut
$LN4@CtlPushBut:

; 670  :     case 17:
; 671  : 	if (++histno > NUM_RADAR_HISTORY)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	add	edx, 1
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR [eax+552], ecx
	cmp	DWORD PTR tv86[ebp], 4
	jle	SHORT $LN3@CtlPushBut

; 672  : 	    histno = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+552], 1
$LN3@CtlPushBut:

; 673  : 	break;

	jmp	SHORT $LN16@CtlPushBut
$LN2@CtlPushBut:

; 674  :     case 18:
; 675  : 	ToggleModeFlag(AltTrack);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z ; RadarDopplerClass::ToggleModeFlag

; 676  : 	break;

	jmp	SHORT $LN16@CtlPushBut
$LN1@CtlPushBut:

; 677  :     case 19:
; 678  : 	ToggleModeFlag(SpeedLo);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleModeFlag@RadarDopplerClass@@IAEXH@Z ; RadarDopplerClass::ToggleModeFlag
$LN16@CtlPushBut:

; 679  : 	break;
; 680  :     }
; 681  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN19@CtlPushBut:
	DD	$LN13@CtlPushBut
	DD	$LN11@CtlPushBut
	DD	$LN9@CtlPushBut
	DD	$LN7@CtlPushBut
	DD	$LN6@CtlPushBut
	DD	$LN4@CtlPushBut
	DD	$LN2@CtlPushBut
	DD	$LN1@CtlPushBut
	DD	$LN16@CtlPushBut
$LN18@CtlPushBut:
	DB	0
	DB	1
	DB	2
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	5
	DB	6
	DB	7
?CtlPushButton@RadarDopplerClass@@QAEXHH@Z ENDP		; RadarDopplerClass::CtlPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?MenuPushButton@RadarDopplerClass@@QAEXHH@Z PROC	; RadarDopplerClass::MenuPushButton
; _this$ = ecx

; 616  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 617  : 	//MI changed
; 618  : 	if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&
; 619  : 		OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_A))

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN7@MenuPushBu
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [eax+688], 0
	je	SHORT $LN7@MenuPushBu
	push	1
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN7@MenuPushBu

; 620  : 	{
; 621  : 		if(rmenuaa[whichButton].label1)

	mov	edx, DWORD PTR _whichButton$[ebp]
	imul	edx, 12					; 0000000cH
	cmp	DWORD PTR _rmenuaa[edx], 0
	je	SHORT $LN6@MenuPushBu

; 622  : 		{
; 623  : 			modeDesiredCmd = rmenuaa[whichButton].mode;

	mov	eax, DWORD PTR _whichButton$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rmenuaa[eax+8]
	mov	DWORD PTR [ecx+156], edx

; 624  : 			ClearFlagBit(MenuMode);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN6@MenuPushBu:

; 625  : 		}			
; 626  : 	}
; 627  : 	else if(OTWDriver.pCockpitManager && OTWDriver.pCockpitManager->mpIcp &&

	jmp	$LN8@MenuPushBu
$LN7@MenuPushBu:

; 628  : 		OTWDriver.pCockpitManager->mpIcp->IsICPSet(ICPClass::MODE_A_G))

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN4@MenuPushBu
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	cmp	DWORD PTR [eax+688], 0
	je	SHORT $LN4@MenuPushBu
	push	2
	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?IsICPSet@ICPClass@@QAEHH@Z		; ICPClass::IsICPSet
	test	eax, eax
	je	SHORT $LN4@MenuPushBu

; 629  : 	{
; 630  : 		if(rmenuag[whichButton].label1)

	mov	edx, DWORD PTR _whichButton$[ebp]
	imul	edx, 12					; 0000000cH
	cmp	DWORD PTR _rmenuag[edx], 0
	je	SHORT $LN3@MenuPushBu

; 631  : 		{
; 632  : 			modeDesiredCmd = rmenuag[whichButton].mode;

	mov	eax, DWORD PTR _whichButton$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rmenuag[eax+8]
	mov	DWORD PTR [ecx+156], edx

; 633  : 			ClearFlagBit(MenuMode);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN3@MenuPushBu:

; 634  : 		}
; 635  : 	}
; 636  : 	else

	jmp	SHORT $LN8@MenuPushBu
$LN4@MenuPushBu:

; 637  : 	{
; 638  : 		if(rmenu[whichButton].label1) 

	mov	eax, DWORD PTR _whichButton$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR _rmenu[eax], 0
	je	SHORT $LN8@MenuPushBu

; 639  : 		{
; 640  : 			modeDesiredCmd = rmenu[whichButton].mode;

	mov	ecx, DWORD PTR _whichButton$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rmenu[ecx+8]
	mov	DWORD PTR [edx+156], eax

; 641  : 			ClearFlagBit(MenuMode);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN8@MenuPushBu:

; 642  : 		}
; 643  : 	}
; 644  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MenuPushButton@RadarDopplerClass@@QAEXHH@Z ENDP	; RadarDopplerClass::MenuPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?OtherPushButton@RadarDopplerClass@@QAEXHH@Z PROC	; RadarDopplerClass::OtherPushButton
; _this$ = ecx

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 429  :     switch( whichButton ) {

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 5
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 14			; 0000000eH
	ja	SHORT $LN11@OtherPushB
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN13@OtherPushB[edx]
	jmp	DWORD PTR $LN14@OtherPushB[eax*4]

; 430  :     case 0:
; 431  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN7@OtherPushB:

; 432  :     case 5:
; 433  : 	modeDesiredCmd = GM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 14			; 0000000eH

; 434  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN6@OtherPushB:

; 435  :     case 6:
; 436  : 	modeDesiredCmd = GMT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 16			; 00000010H

; 437  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN5@OtherPushB:

; 438  :     case 7:
; 439  : 	modeDesiredCmd = SEA;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 17			; 00000011H

; 440  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN4@OtherPushB:

; 441  :     case 16:
; 442  : 	modeDesiredCmd = ACM_30x20;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 6

; 443  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN3@OtherPushB:

; 444  :     case 17:
; 445  : 	modeDesiredCmd = VS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 5

; 446  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN2@OtherPushB:

; 447  :     case 18:
; 448  : 	modeDesiredCmd = RWS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 2

; 449  : 	break;

	jmp	SHORT $LN11@OtherPushB
$LN1@OtherPushB:

; 450  :     case 19:
; 451  : 	modeDesiredCmd = TWS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 4
$LN11@OtherPushB:

; 452  : 	break;
; 453  :     }
; 454  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN14@OtherPushB:
	DD	$LN7@OtherPushB
	DD	$LN6@OtherPushB
	DD	$LN5@OtherPushB
	DD	$LN4@OtherPushB
	DD	$LN3@OtherPushB
	DD	$LN2@OtherPushB
	DD	$LN1@OtherPushB
	DD	$LN11@OtherPushB
$LN13@OtherPushB:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	4
	DB	5
	DB	6
?OtherPushButton@RadarDopplerClass@@QAEXHH@Z ENDP	; RadarDopplerClass::OtherPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?AAPushButton@RadarDopplerClass@@QAEXHH@Z PROC		; RadarDopplerClass::AAPushButton
; _this$ = ecx

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 380  :     switch( whichButton ) {

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 19			; 00000013H
	ja	$LN22@AAPushButt
	mov	ecx, DWORD PTR tv64[ebp]
	movzx	edx, BYTE PTR $LN24@AAPushButt[ecx]
	jmp	DWORD PTR $LN25@AAPushButt[edx*4]
$LN19@AAPushButt:

; 381  :     case 0:
; 382  : 	StepAAmode();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 383  : 	break;

	jmp	$LN22@AAPushButt
$LN18@AAPushButt:

; 384  :     case 1:
; 385  : 	if (g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN17@AAPushButt

; 386  : 	    StepAAmode ();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx

; 387  : 	else if ((mode == ACM_30x20)	|| (mode == ACM_SLEW) || (mode == ACM_BORE)

	jmp	SHORT $LN16@AAPushButt
$LN17@AAPushButt:

; 388  : 	    || (mode == ACM_10x60))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 6
	je	SHORT $LN14@AAPushButt
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 7
	je	SHORT $LN14@AAPushButt
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 8
	je	SHORT $LN14@AAPushButt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 9
	jne	SHORT $LN16@AAPushButt
$LN14@AAPushButt:

; 389  : 	{
; 390  : 	    scanWidthCmd = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 1
$LN16@AAPushButt:

; 391  : 	}
; 392  : 	break;

	jmp	$LN22@AAPushButt
$LN13@AAPushButt:

; 393  :     case 2:
; 394  : 	if ((mode == TWS || mode == RWS || mode == LRS || mode == SAM) && g_bRealisticAvionics)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 4
	je	SHORT $LN11@AAPushButt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 2
	je	SHORT $LN11@AAPushButt
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 3
	je	SHORT $LN11@AAPushButt
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 10			; 0000000aH
	jne	SHORT $LN12@AAPushButt
$LN11@AAPushButt:
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN12@AAPushButt

; 395  : 	    	fovStepCmd = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 1
$LN12@AAPushButt:

; 396  : 	break;

	jmp	$LN22@AAPushButt
$LN10@AAPushButt:

; 397  :     case 10:
; 398  : 	if (g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN9@AAPushButt

; 399  : 	    ToggleFlag(AADecluttered);

	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleFlag@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ToggleFlag
$LN9@AAPushButt:

; 400  : 	break;

	jmp	$LN22@AAPushButt
$LN8@AAPushButt:

; 401  :     case 16:
; 402  : 	scanHeightCmd = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 1

; 403  : 	break;

	jmp	$LN22@AAPushButt
$LN7@AAPushButt:

; 404  :     case 17:
; 405  : 	if ((mode == RWS) || (mode == TWS) || (mode == VS) || (mode == LRS)) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 2
	je	SHORT $LN5@AAPushButt
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 4
	je	SHORT $LN5@AAPushButt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 5
	je	SHORT $LN5@AAPushButt
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 3
	jne	SHORT $LN6@AAPushButt
$LN5@AAPushButt:

; 406  : 	    scanWidthCmd = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 1
$LN6@AAPushButt:

; 407  : 	}
; 408  : 	break;

	jmp	SHORT $LN22@AAPushButt
$LN4@AAPushButt:

; 409  :     case 18:
; 410  : 	if ((mode != ACM_SLEW)	&& (mode != ACM_30x20)	&& 
; 411  : 	    (mode != ACM_10x60)	&& (mode != ACM_BORE)) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 7
	je	SHORT $LN3@AAPushButt
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 6
	je	SHORT $LN3@AAPushButt
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 9
	je	SHORT $LN3@AAPushButt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 8
	je	SHORT $LN3@AAPushButt

; 412  : 	{
; 413  : 	    rangeChangeCmd = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], -1
$LN3@AAPushButt:

; 414  : 	}
; 415  : 	break;

	jmp	SHORT $LN22@AAPushButt
$LN2@AAPushButt:

; 416  :     case 19:
; 417  : 	if ((mode != ACM_SLEW)	&& (mode != ACM_30x20)	&& 
; 418  : 	    (mode != ACM_10x60)	&& (mode != ACM_BORE)) 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 7
	je	SHORT $LN22@AAPushButt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 6
	je	SHORT $LN22@AAPushButt
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 9
	je	SHORT $LN22@AAPushButt
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 8
	je	SHORT $LN22@AAPushButt

; 419  : 	{
; 420  : 	    rangeChangeCmd = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 1
$LN22@AAPushButt:

; 421  : 	}
; 422  : 	break;
; 423  : 	
; 424  :     }
; 425  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN25@AAPushButt:
	DD	$LN19@AAPushButt
	DD	$LN18@AAPushButt
	DD	$LN13@AAPushButt
	DD	$LN10@AAPushButt
	DD	$LN8@AAPushButt
	DD	$LN7@AAPushButt
	DD	$LN4@AAPushButt
	DD	$LN2@AAPushButt
	DD	$LN22@AAPushButt
$LN24@AAPushButt:
	DB	0
	DB	1
	DB	2
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	5
	DB	6
	DB	7
?AAPushButton@RadarDopplerClass@@QAEXHH@Z ENDP		; RadarDopplerClass::AAPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?AGPushButton@RadarDopplerClass@@QAEXHH@Z PROC		; RadarDopplerClass::AGPushButton
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 295  :     switch( whichButton ) {

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 19			; 00000013H
	ja	$LN29@AGPushButt
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN31@AGPushButt[ecx*4]
$LN26@AGPushButt:

; 296  :     case 0:
; 297  : 	StepAGmode();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx

; 298  : 	break;

	jmp	$LN29@AGPushButt
$LN25@AGPushButt:

; 299  :     case 1:
; 300  : 	if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN24@AGPushButt
	movzx	ecx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	ecx, ecx
	je	SHORT $LN24@AGPushButt

; 301  : 	{
; 302  : 		ToggleFlag(AutoAGRange);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleFlag@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ToggleFlag

; 303  : 		if(IsSet(AutoAGRange))

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN23@AGPushButt

; 304  : 			WasAutoAGRange = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+940], 1

; 305  : 		else

	jmp	SHORT $LN22@AGPushButt
$LN23@AGPushButt:

; 306  : 			WasAutoAGRange = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+940], 0
$LN22@AGPushButt:
	jmp	SHORT $LN21@AGPushButt
$LN24@AGPushButt:

; 307  : 	    //StepAGmode();	//MI this should definately not be here
; 308  : 	}
; 309  : 	else if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN21@AGPushButt

; 310  : 		StepAGmode();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx
$LN21@AGPushButt:

; 311  : 	break;

	jmp	$LN29@AGPushButt
$LN19@AGPushButt:

; 312  :     case 2:
; 313  : 	fovStepCmd = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 1

; 314  : 	break;

	jmp	$LN29@AGPushButt
$LN18@AGPushButt:

; 315  :     case 6:
; 316  : 	ToggleAGfreeze();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+168]
	call	eax

; 317  : 	//LastAGModes = 1; // ASSOCIATOR: Redundant now
; 318  : 	break;

	jmp	$LN29@AGPushButt
$LN17@AGPushButt:

; 319  :     case 7:
; 320  : 	SetAGSnowPlow(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 321  : 	if (g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN16@AGPushButt
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN16@AGPushButt

; 322  : 	{
; 323  : 		RestoreAGCursor();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN16@AGPushButt:

; 324  : 	}
; 325  : 	LastAGModes = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+936], 2

; 326  : 	break;

	jmp	$LN29@AGPushButt
$LN15@AGPushButt:

; 327  :     case 8:
; 328  : 	ToggleAGcursorZero();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+180]
	call	edx

; 329  : 	break;

	jmp	$LN29@AGPushButt
$LN14@AGPushButt:

; 330  :     case 9:
; 331  : 	SetAGSteerpoint(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax

; 332  : 	if (g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN13@AGPushButt
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN13@AGPushButt

; 333  : 		RestoreAGCursor();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN13@AGPushButt:

; 334  : 	LastAGModes = 3;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+936], 3

; 335  : 	break;

	jmp	$LN29@AGPushButt
$LN12@AGPushButt:

; 336  :     case 10:
; 337  : 	if (g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN11@AGPushButt

; 338  : 	    ToggleFlag(AGDecluttered);

	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleFlag@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ToggleFlag
$LN11@AGPushButt:

; 339  : 	break;

	jmp	$LN29@AGPushButt
$LN10@AGPushButt:

; 340  : 
; 341  :     case 16:
; 342  : 	if (mode == OFF) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jne	SHORT $LN9@AGPushButt

; 343  : 	    modeDesiredCmd = ACM_30x20;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 6

; 344  : 	} else {

	jmp	SHORT $LN8@AGPushButt
$LN9@AGPushButt:

; 345  : 	    scanHeightCmd = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 1
$LN8@AGPushButt:

; 346  : 	}
; 347  : 	break;

	jmp	$LN29@AGPushButt
$LN7@AGPushButt:

; 348  :     case 17:
; 349  : 	scanWidthCmd = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 1

; 350  : 	break;

	jmp	$LN29@AGPushButt
$LN6@AGPushButt:

; 351  :     case 18:
; 352  : 	rangeChangeCmd = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], -1

; 353  : 	//MI
; 354  : 	if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN5@AGPushButt
	movzx	eax, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	eax, eax
	je	SHORT $LN5@AGPushButt

; 355  : 	{
; 356  : 		if(IsSet(AutoAGRange))

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN5@AGPushButt

; 357  : 		{
; 358  : 			ClearFlagBit(AutoAGRange);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 359  : 			WasAutoAGRange = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+940], 0
$LN5@AGPushButt:

; 360  : 		}
; 361  : 	}
; 362  : 	break;

	jmp	SHORT $LN29@AGPushButt
$LN3@AGPushButt:

; 363  :     case 19:
; 364  : 	rangeChangeCmd = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 1

; 365  : 	//MI
; 366  : 	if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN29@AGPushButt
	movzx	ecx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	ecx, ecx
	je	SHORT $LN29@AGPushButt

; 367  : 	{
; 368  : 		if(IsSet(AutoAGRange))

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN29@AGPushButt

; 369  : 		{
; 370  : 			ClearFlagBit(AutoAGRange);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 371  : 			WasAutoAGRange = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+940], 0
$LN29@AGPushButt:

; 372  : 		}
; 373  : 	}
; 374  : 	break;
; 375  : 	
; 376  :     }
; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN31@AGPushButt:
	DD	$LN26@AGPushButt
	DD	$LN25@AGPushButt
	DD	$LN19@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN18@AGPushButt
	DD	$LN17@AGPushButt
	DD	$LN15@AGPushButt
	DD	$LN14@AGPushButt
	DD	$LN12@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN29@AGPushButt
	DD	$LN10@AGPushButt
	DD	$LN7@AGPushButt
	DD	$LN6@AGPushButt
	DD	$LN3@AGPushButt
?AGPushButton@RadarDopplerClass@@QAEXHH@Z ENDP		; RadarDopplerClass::AGPushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
tv187 = -12						; size = 4
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?PushButton@RadarDopplerClass@@UAEXHH@Z PROC		; RadarDopplerClass::PushButton
; _this$ = ecx

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 217  :     switch (whichButton) { // common cases

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 14			; 0000000eH
	ja	$LN10@PushButton
	mov	ecx, DWORD PTR tv64[ebp]
	movzx	edx, BYTE PTR $LN35@PushButton[ecx]
	jmp	DWORD PTR $LN37@PushButton[edx*4]
$LN30@PushButton:

; 218  :     case 4:
; 219  : 	if (g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN29@PushButton

; 220  : 	    ToggleFlag(CtlMode);

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ToggleFlag@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ToggleFlag
$LN29@PushButton:

; 221  : 	break;

	jmp	$LN33@PushButton
$LN28@PushButton:

; 222  :     case 3:
; 223  : 		//MI if we're in STBY, don't do anything with it.
; 224  : 		if(mode == STBY)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 1
	jne	SHORT $LN27@PushButton

; 225  : 			return;

	jmp	$LN33@PushButton
$LN27@PushButton:

; 226  : 	SetEmitting (1 - isEmitting);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 1
	sub	eax, DWORD PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 227  : 	break;

	jmp	$LN33@PushButton
$LN26@PushButton:

; 228  : 
; 229  :     case 11:
; 230  : 	if (g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN25@PushButton

; 231  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
	jmp	SHORT $LN24@PushButton
$LN25@PushButton:

; 232  : 	else if (mode != OFF) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 0
	je	SHORT $LN24@PushButton

; 233  : 	    MfdDisplay[whichMFD]->SetNewMode(MFDClass::SMSMode);

	push	11					; 0000000bH
	mov	edx, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[edx*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode
$LN24@PushButton:

; 234  : 	}
; 235  : 	break;

	jmp	$LN33@PushButton
$LN22@PushButton:

; 236  :     case 12:
; 237  : 	if (g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN21@PushButton

; 238  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
$LN21@PushButton:

; 239  : 	break;

	jmp	$LN33@PushButton
$LN20@PushButton:

; 240  :     case 13:
; 241  : 	if (g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN19@PushButton

; 242  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
	jmp	SHORT $LN18@PushButton
$LN19@PushButton:

; 243  : 	else if (mode == OFF) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jne	SHORT $LN17@PushButton

; 244  : 	    MfdDisplay[whichMFD]->SetNewMode(MFDClass::MfdMenu);

	push	1
	mov	ecx, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 245  : 	} else {

	jmp	SHORT $LN18@PushButton
$LN17@PushButton:

; 246  : 	    modeDesiredCmd = STBY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 1
$LN18@PushButton:

; 247  : 	}
; 248  : 	break;

	jmp	$LN33@PushButton
$LN15@PushButton:

; 249  :     case 14:
; 250  : 	if (g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN14@PushButton

; 251  : 	    MfdDrawable::PushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PushButton@MfdDrawable@@UAEXHH@Z	; MfdDrawable::PushButton
	jmp	SHORT $LN13@PushButton
$LN14@PushButton:

; 252  : 	else MFDSwapDisplays();

	call	?MFDSwapDisplays@@YAXXZ			; MFDSwapDisplays
$LN13@PushButton:

; 253  : 	break;

	jmp	$LN33@PushButton
$LN12@PushButton:

; 254  :     case 0:
; 255  : 	if (g_bRealisticAvionics) {

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN10@PushButton

; 256  : 	    SetFlagBit(MenuMode);

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 257  : 	    break;

	jmp	$LN33@PushButton
$LN10@PushButton:

; 258  : 	}
; 259  : 	// else fall through
; 260  : 
; 261  :     default:
; 262  : 	// catch the menu and ctl buttons
; 263  : 	if (whichButton > 4 && whichButton < 20) {

	cmp	DWORD PTR _whichButton$[ebp], 4
	jle	SHORT $LN9@PushButton
	cmp	DWORD PTR _whichButton$[ebp], 20	; 00000014H
	jge	SHORT $LN9@PushButton

; 264  : 	    if (IsSet(MenuMode)) {

	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN8@PushButton

; 265  : 		MenuPushButton (whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MenuPushButton@RadarDopplerClass@@QAEXHH@Z ; RadarDopplerClass::MenuPushButton

; 266  : 		return;

	jmp	SHORT $LN33@PushButton
	jmp	SHORT $LN9@PushButton
$LN8@PushButton:

; 267  : 	    }
; 268  : 	    else if (IsSet(CtlMode)) {

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN9@PushButton

; 269  : 		CtlPushButton (whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CtlPushButton@RadarDopplerClass@@QAEXHH@Z ; RadarDopplerClass::CtlPushButton

; 270  : 		return;

	jmp	SHORT $LN33@PushButton
$LN9@PushButton:

; 271  : 	    }
; 272  : 	}
; 273  : 	switch (mode) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR tv187[ebp], eax
	cmp	DWORD PTR tv187[ebp], 17		; 00000011H
	ja	SHORT $LN1@PushButton
	mov	ecx, DWORD PTR tv187[ebp]
	movzx	edx, BYTE PTR $LN36@PushButton[ecx]
	jmp	DWORD PTR $LN38@PushButton[edx*4]
$LN3@PushButton:

; 274  : 	case GM:
; 275  : 	case GMT:
; 276  : 	case SEA:
; 277  : 	    AGPushButton(whichButton, whichMFD);

	mov	eax, DWORD PTR _whichMFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichButton$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AGPushButton@RadarDopplerClass@@QAEXHH@Z ; RadarDopplerClass::AGPushButton

; 278  : 	    break;

	jmp	SHORT $LN33@PushButton
$LN2@PushButton:

; 279  : 	case OFF:
; 280  : 	//case STBY:	//MI don't think we should do anything here. (acts weird now)
; 281  : 	    OtherPushButton(whichButton, whichMFD);

	mov	edx, DWORD PTR _whichMFD$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichButton$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OtherPushButton@RadarDopplerClass@@QAEXHH@Z ; RadarDopplerClass::OtherPushButton

; 282  : 	    break;

	jmp	SHORT $LN33@PushButton
$LN1@PushButton:

; 283  : 	default:
; 284  : 	    AAPushButton(whichButton, whichMFD);

	mov	ecx, DWORD PTR _whichMFD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichButton$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AAPushButton@RadarDopplerClass@@QAEXHH@Z ; RadarDopplerClass::AAPushButton
$LN33@PushButton:

; 285  : 	    break;
; 286  : 	    
; 287  : 	}
; 288  : 	break;
; 289  :     }
; 290  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN37@PushButton:
	DD	$LN12@PushButton
	DD	$LN28@PushButton
	DD	$LN30@PushButton
	DD	$LN26@PushButton
	DD	$LN22@PushButton
	DD	$LN20@PushButton
	DD	$LN15@PushButton
	DD	$LN10@PushButton
$LN35@PushButton:
	DB	0
	DB	7
	DB	7
	DB	1
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	4
	DB	5
	DB	6
	npad	1
$LN38@PushButton:
	DD	$LN2@PushButton
	DD	$LN3@PushButton
	DD	$LN1@PushButton
$LN36@PushButton:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
	DB	1
?PushButton@RadarDopplerClass@@UAEXHH@Z ENDP		; RadarDopplerClass::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
$T1 = -1328						; size = 8
$T2 = -1320						; size = 8
_testTime$ = -1312					; size = 4
_delta$ = -1308						; size = 4
tv1646 = -1304						; size = 4
tv1634 = -1300						; size = 4
tv494 = -1296						; size = 4
tv224 = -1292						; size = 4
tv452 = -1288						; size = 4
tv1061 = -1284						; size = 4
tv535 = -1280						; size = 4
tv1069 = -1276						; size = 4
tv1421 = -1272						; size = 4
tv1048 = -1268						; size = 4
tv1296 = -1264						; size = 4
_lockedFound$ = -1260					; size = 4
tv514 = -1256						; size = 4
_tmpPtrNext$3 = -1252					; size = 4
_radarMode$4 = -1248					; size = 4
_digimode$5 = -1244					; size = 4
_sendThisFrame$ = -1240					; size = 4
_i$ = -1236						; size = 4
_rVal$ = -1232						; size = 4
_lastLocked$ = -1228					; size = 4
_canSee$6 = -1224					; size = 4
_rdrObj$ = -1220					; size = 4
_rdrData$ = -1216					; size = 4
_tmpPtr$7 = -1212					; size = 4
_this$ = -1208						; size = 4
_velCell$ = -1204					; size = 400
_angCell$ = -804					; size = 400
_rngCell$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_targetList$ = 8					; size = 4
?Exec@RadarDopplerClass@@UAEPAVSimObjectType@@PAV2@@Z PROC ; RadarDopplerClass::Exec
; _this$ = ecx

; 684  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1328				; 00000530H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 685  : 	int i, rngCell[MAX_OBJECTS], angCell[MAX_OBJECTS], velCell[MAX_OBJECTS];
; 686  : 	SimObjectType* rdrObj;
; 687  : 	SimObjectType* lastLocked;
; 688  : 	SimObjectLocalData* rdrData;
; 689  : 	float rVal, delta;
; 690  : 	int sendThisFrame;
; 691  : 	int lockedFound = FALSE;

	mov	DWORD PTR _lockedFound$[ebp], 0

; 692  : 	int testTime;
; 693  : 
; 694  :     if (!((AircraftClass*)platform)->HasPower(AircraftClass::FCRPower)) {

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	SHORT $LN107@Exec

; 695  : 		SetPower(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 696  : 		SetEmitting(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 697  : 		if (mode != OFF) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 0
	je	SHORT $LN106@Exec

; 698  : 			prevMode = mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+88], ecx

; 699  : 			mode = OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], 0
$LN106@Exec:

; 700  : 		}
; 701  :     }

	jmp	SHORT $LN104@Exec
$LN107@Exec:

; 702  :     else if (mode == OFF) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jne	SHORT $LN104@Exec

; 703  : 		modeDesiredCmd = STBY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 1
$LN104@Exec:

; 704  :     }
; 705  : 	
; 706  : 	// Update the hud
; 707  : 	if (TheHud) // JB 010615 CTD

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN100@Exec

; 708  : 	{
; 709  : 		if (isEmitting)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 0
	je	SHORT $LN102@Exec

; 710  : 			TheHud->HudData.Clear(HudDataType::RadarNoRad);

	push	8
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Clear@HudDataType@@QAEXH@Z		; HudDataType::Clear
	jmp	SHORT $LN100@Exec
$LN102@Exec:

; 711  : 		else if (radarData->NominalRange != 0.0) // JB 010706 Only set if the aircraft has radar to begin with

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	cvtss2sd xmm0, DWORD PTR [ecx+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN100@Exec

; 712  : 			TheHud->HudData.Set(HudDataType::RadarNoRad);

	push	8
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Set@HudDataType@@QAEXH@Z		; HudDataType::Set
$LN100@Exec:

; 713  : 	}
; 714  : 	
; 715  : 	// Validate our locked target
; 716  : 	lastLocked = lockedTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _lastLocked$[ebp], eax

; 717  : 	if (lastLocked)

	cmp	DWORD PTR _lastLocked$[ebp], 0
	je	SHORT $LN99@Exec

; 718  : 		lastLocked->Reference();

	mov	ecx, DWORD PTR _lastLocked$[ebp]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference
$LN99@Exec:

; 719  : 	
; 720  : 	CheckLockedTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 721  : 	
; 722  : 	// Maintain track history across agg/deag boundary
; 723  : 	if (lockedTarget != lastLocked && lockedTarget && lastLocked)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	edx, DWORD PTR _lastLocked$[ebp]
	je	SHORT $LN98@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN98@Exec
	cmp	DWORD PTR _lastLocked$[ebp], 0
	je	SHORT $LN98@Exec

; 724  : 	{
; 725  : 		ShiAssert( lockedTargetData == lockedTarget->localData );
; 726  : 		memcpy (lockedTargetData, lastLocked->localData, sizeof (SimObjectLocalData));

	push	232					; 000000e8H
	mov	ecx, DWORD PTR _lastLocked$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN98@Exec:

; 727  : 	}
; 728  : 	if (lastLocked)

	cmp	DWORD PTR _lastLocked$[ebp], 0
	je	SHORT $LN97@Exec

; 729  : 		lastLocked->Release();

	mov	ecx, DWORD PTR _lastLocked$[ebp]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release
$LN97@Exec:

; 730  : 	lastLocked = lockedTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _lastLocked$[ebp], eax

; 731  : 
; 732  : 	if(!lastLocked) // MLR 6/21/2004 - So cursors come back after loosing tgt

	cmp	DWORD PTR _lastLocked$[ebp], 0
	jne	SHORT $LN96@Exec

; 733  : 	{
; 734  : 		ClearFlagBit(STTingTarget);

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN96@Exec:

; 735  : 	}
; 736  : 	
; 737  : 	// JB 010224 Start Enable the CombatAP to shoot A2A missiles
; 738  : 	//if (g_bSmartCombatAP && lockedTarget) && 
; 739  : 	if (g_bSmartCombatAP && lockedTarget && ((mode > 1) && (mode < 14)) && 
; 740  : 		((AircraftClass*) platform)->autopilotType == AircraftClass::CombatAP	)

	movzx	ecx, BYTE PTR ?g_bSmartCombatAP@@3_NA	; g_bSmartCombatAP
	test	ecx, ecx
	je	$LN95@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	$LN95@Exec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 1
	jle	$LN95@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 14			; 0000000eH
	jge	$LN95@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	DWORD PTR [eax+968], 2
	jne	$LN95@Exec

; 741  : 	{
; 742  : 		int digimode;
; 743  : 		switch (mode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv224[ebp], edx
	cmp	DWORD PTR tv224[ebp], 2
	jl	SHORT $LN91@Exec
	cmp	DWORD PTR tv224[ebp], 13		; 0000000dH
	jle	SHORT $LN92@Exec
	jmp	SHORT $LN91@Exec
$LN92@Exec:

; 744  : 		{
; 745  : 		case RWS:
; 746  : 		case LRS:
; 747  : 		case TWS:
; 748  : 		case VS:
; 749  : 		case ACM_30x20:
; 750  : 		case ACM_SLEW:
; 751  : 		case ACM_BORE:
; 752  : 		case ACM_10x60:
; 753  : 		case SAM:
; 754  : 		case SAM_AUTO_MODE:
; 755  : 		case SAM_MANUAL_MODE:
; 756  : 		case STT:
; 757  : 			digimode = AA;

	mov	DWORD PTR _digimode$5[ebp], 18		; 00000012H

; 758  : 			break;

	jmp	SHORT $LN93@Exec
$LN91@Exec:

; 759  : 		default:
; 760  : 			digimode = 0;

	mov	DWORD PTR _digimode$5[ebp], 0
$LN93@Exec:

; 761  : 		}
; 762  : 		
; 763  : #define SG_NOLOCK 0x00
; 764  : #define SG_LOCK 0x01
; 765  : #define SG_JAMMING 0x02
; 766  : #define SG_FADING 0x04
; 767  : 		// Weight on wheels inhibit
; 768  : 		if (platform->IsAirplane())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN90@Exec

; 769  : 		{
; 770  : 			if (platform->OnGround())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	$LN89@Exec

; 771  : 			{
; 772  : 				SetSeekerPos( 0.0f, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 773  : 				platform->SetRdrRng( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrRng@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrRng

; 774  : 				platform->SetRdrAz( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 775  : 				platform->SetRdrEl( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 776  : 				platform->SetRdrCycleTime( 9999.0F );//me123

	push	ecx
	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 777  : 				platform->SetRdrAzCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 778  : 				platform->SetRdrElCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter

; 779  : 				SetDesiredTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 780  : 				return NULL;

	xor	eax, eax
	jmp	$LN108@Exec
$LN89@Exec:

; 781  : 			}
; 782  : 			
; 783  : 			// Original code check for isEmiting again, its useless since we return if not emiting above anyway
; 784  : 			platform->SetRdrRng( radarData->NominalRange );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrRng@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrRng

; 785  : 			platform->SetRdrAz( radarData->ScanHalfAngle );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+24]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 786  : 			platform->SetRdrEl( radarData->ScanHalfAngle );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+24]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 787  : 			platform->SetRdrCycleTime( 8.0F );//me123

	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 788  : 			platform->SetRdrAzCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 789  : 			platform->SetRdrElCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter
$LN90@Exec:

; 790  : 		}
; 791  : 		
; 792  : 		// See if it is time to send a "painted" list update
; 793  : 		if (lastLocked != lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _lastLocked$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	je	SHORT $LN88@Exec

; 794  : 		{
; 795  : 			if (lastLocked)

	cmp	DWORD PTR _lastLocked$[ebp], 0
	je	SHORT $LN87@Exec

; 796  : 			{
; 797  : 				SendTrackMsg (lastLocked, Track_Unlock);

	push	0
	push	2
	mov	eax, DWORD PTR _lastLocked$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN87@Exec:

; 798  : 			}
; 799  : 			sendThisFrame = TRUE;

	mov	DWORD PTR _sendThisFrame$[ebp], 1

; 800  : 		} else {

	jmp	SHORT $LN86@Exec
$LN88@Exec:

; 801  : 			// See if it is time to send a "painted" list update (AA mode only)
; 802  : 			sendThisFrame = (SimLibElapsedTime - lastTargetLockSend > TrackUpdateTime);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+72]
	cmp	edx, DWORD PTR ?TrackUpdateTime@RadarClass@@2KB ; RadarClass::TrackUpdateTime
	jbe	SHORT $LN110@Exec
	mov	DWORD PTR tv452[ebp], 1
	jmp	SHORT $LN111@Exec
$LN110@Exec:
	mov	DWORD PTR tv452[ebp], 0
$LN111@Exec:
	mov	eax, DWORD PTR tv452[ebp]
	mov	DWORD PTR _sendThisFrame$[ebp], eax
$LN86@Exec:

; 803  : 		}
; 804  : 		
; 805  : 		// S.G. Now this is where we scan for each target in our target list,  la EyeballClass::Exec
; 806  : 		SimObjectType* tmpPtr = targetList;

	mov	ecx, DWORD PTR _targetList$[ebp]
	mov	DWORD PTR _tmpPtr$7[ebp], ecx

; 807  : 		
; 808  : 		// Just in case we don't have a list but we do have a locked target OR IF THE RADAR IS NOT IN AA MODE
; 809  : 		// I noticed the radar isn't really used in air to ground mode so we'll do just the lockedTarget then					
; 810  : 		if (!tmpPtr || digimode != AA)

	cmp	DWORD PTR _tmpPtr$7[ebp], 0
	je	SHORT $LN84@Exec
	cmp	DWORD PTR _digimode$5[ebp], 18		; 00000012H
	je	SHORT $LN85@Exec
$LN84@Exec:

; 811  : 			tmpPtr = lockedTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _tmpPtr$7[ebp], eax
$LN85@Exec:

; 812  : 		
; 813  : 		while (tmpPtr) {

	cmp	DWORD PTR _tmpPtr$7[ebp], 0
	je	$LN82@Exec

; 814  : 			// S.G. canSee has THREE meaning now. Bit 0 is when we can see signal, bit 1 is when the signal is jammed and bit 2 is when the signal is fading
; 815  : 			// By default, we can see the target (bit 0 at value 1)
; 816  : 			int canSee = SG_LOCK;

	mov	DWORD PTR _canSee$6[ebp], 1

; 817  : 
; 818  : 			// 2000-10-07 S.G. POSSIBLE BUG! If we are looking at our lockedTarget and we are the only one referencing it, clearing it
; 819  : 			// might invalidate tmpPtr->next. So I'll read it ahead of time
; 820  : 			SimObjectType* tmpPtrNext = tmpPtr->next;

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _tmpPtrNext$3[ebp], edx

; 821  : 
; 822  : 			// FRB - CTD below
; 823  : 			if ((!tmpPtr->BaseData()) || (!tmpPtr->localData))

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	test	eax, eax
	je	SHORT $LN80@Exec
	mov	eax, DWORD PTR _tmpPtr$7[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN81@Exec
$LN80@Exec:

; 824  : 				tmpPtr = tmpPtrNext;

	mov	ecx, DWORD PTR _tmpPtrNext$3[ebp]
	mov	DWORD PTR _tmpPtr$7[ebp], ecx
$LN81@Exec:

; 825  : 			if (!tmpPtr)

	cmp	DWORD PTR _tmpPtr$7[ebp], 0
	jne	SHORT $LN79@Exec

; 826  : 				break;

	jmp	$LN82@Exec
$LN79@Exec:

; 827  : 
; 828  : 			
; 829  : 			if (TeamInfo[platform->GetTeam()]->TStance(tmpPtr->BaseData()->GetTeam()) <= Neutral)

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv494[ebp], eax
	mov	edx, DWORD PTR tv494[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv494[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?TStance@TeamClass@@QAEHE@Z		; TeamClass::TStance
	cmp	eax, 3
	jg	SHORT $LN78@Exec

; 830  : 			{//me123 don't lock up freindlys
; 831  : 				canSee = SG_NOLOCK;

	mov	DWORD PTR _canSee$6[ebp], 0
$LN78@Exec:

; 832  : 			}
; 833  : 			// Can't hold a lock if its outside our radar cone
; 834  : 			if (fabs(tmpPtr->localData->ata) > radarData->ScanHalfAngle)

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1634[ebp]
	movss	xmm0, DWORD PTR tv1634[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	comiss	xmm0, DWORD PTR [edx+24]
	jbe	SHORT $LN77@Exec

; 835  : 			{
; 836  : 				canSee = SG_NOLOCK;

	mov	DWORD PTR _canSee$6[ebp], 0

; 837  : 			}
; 838  : 			else {

	jmp	SHORT $LN72@Exec
$LN77@Exec:

; 839  : 				// Only track object in the correct domain (air/land)
; 840  : 				if ( tmpPtr->BaseData()->OnGround() )

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv514[ebp], eax
	mov	eax, DWORD PTR tv514[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv514[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN75@Exec

; 841  : 				{
; 842  : 					if (digimode == AA)

	cmp	DWORD PTR _digimode$5[ebp], 18		; 00000012H
	jne	SHORT $LN74@Exec

; 843  : 					{
; 844  : 						// Skip ground objects in AA mode
; 845  : 						canSee = SG_NOLOCK;

	mov	DWORD PTR _canSee$6[ebp], 0
$LN74@Exec:

; 846  : 					}
; 847  : 				}
; 848  : 				else

	jmp	SHORT $LN72@Exec
$LN75@Exec:

; 849  : 				{
; 850  : 					// Ground mode is more than just GM, it can be GMT and SEA as well (not sure about SEA though, but gndAttck.cpp DO put the digital radar in GMT mode)
; 851  : 					// But AFAIK, if NOT in AA, you're in GM or GMT mode (SEA is NOT used by AI after all)
; 852  : 					if (digimode != AA)

	cmp	DWORD PTR _digimode$5[ebp], 18		; 00000012H
	je	SHORT $LN72@Exec

; 853  : 					{
; 854  : 						// Skip air objects in AA mode
; 855  : 						canSee = SG_NOLOCK;

	mov	DWORD PTR _canSee$6[ebp], 0
$LN72@Exec:

; 856  : 					}
; 857  : 				}
; 858  : 			}
; 859  : 
; 860  : 			// Now we check the signal strength only if the target is in the radar cone and the right mode
; 861  : 			if (canSee) {

	cmp	DWORD PTR _canSee$6[ebp], 0
	je	$LN66@Exec

; 862  : 				// Drop lock if the guy has been below the signal strength threshhold too long
; 863  : 				if (ReturnStrength(tmpPtr) < 1.0f) {

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	call	edx
	fstp	DWORD PTR tv1646[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv1646[ebp]
	jbe	SHORT $LN66@Exec

; 864  : 					// Ok so it's too low, but is it jamming? If so, follow anyway...
; 865  : 					if (tmpPtr->BaseData()->IsSPJamming())

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv535[ebp], eax
	mov	eax, DWORD PTR tv535[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv535[ebp]
	mov	eax, DWORD PTR [edx+268]
	call	eax
	test	eax, eax
	je	SHORT $LN69@Exec

; 866  : 						canSee |= SG_JAMMING; // That's our second bit being used

	mov	ecx, DWORD PTR _canSee$6[ebp]
	or	ecx, 2
	mov	DWORD PTR _canSee$6[ebp], ecx
	jmp	SHORT $LN66@Exec
$LN69@Exec:

; 867  : 					// So it's too low and were are not jamming. When did we loose the signal?
; 868  : 					else if (SimLibElapsedTime - tmpPtr->localData->rdrLastHit > radarData->CoastTime) {

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	cmp	ecx, DWORD PTR [eax+32]
	jbe	SHORT $LN67@Exec

; 869  : 						// Give up and drop lock
; 870  : 						canSee = SG_NOLOCK;

	mov	DWORD PTR _canSee$6[ebp], 0

; 871  : 					}
; 872  : 					// We just lost the signal, but we can still follow it, right?
; 873  : 					else

	jmp	SHORT $LN66@Exec
$LN67@Exec:

; 874  : 						canSee |= SG_FADING;

	mov	ecx, DWORD PTR _canSee$6[ebp]
	or	ecx, 4
	mov	DWORD PTR _canSee$6[ebp], ecx
$LN66@Exec:

; 875  : 				}
; 876  : 			}
; 877  : 			
; 878  : 			// Now set that target sensor track according to what we got
; 879  : 			if (canSee) {		

	cmp	DWORD PTR _canSee$6[ebp], 0
	je	$LN65@Exec

; 880  : 				
; 881  : 				//me123 first time we atempt a lock, it requires some time to lock it up
; 882  : 				if (tmpPtr->localData->sensorState[Radar] == NoTrack) 

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, 4
	shl	ecx, 0
	cmp	DWORD PTR [eax+ecx+192], 0
	jne	SHORT $LN64@Exec

; 883  : 				{
; 884  : 					tmpPtr->localData->rdrLastHit = SimLibElapsedTime;// we are starting to lock the guy

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+136], ecx

; 885  : 					canSee |= SG_FADING; // this will make the sensor state max set to detection

	mov	edx, DWORD PTR _canSee$6[ebp]
	or	edx, 4
	mov	DWORD PTR _canSee$6[ebp], edx
$LN64@Exec:

; 886  : 				}
; 887  : 				if (radarDatFile && tmpPtr->localData->sensorState[Radar] == Detection &&  SimLibElapsedTime - tmpPtr->localData->rdrLastHit < (unsigned)radarDatFile->TimeToLock)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN63@Exec
	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR [edx+eax+192], 1
	jne	SHORT $LN63@Exec
	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+136]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN63@Exec

; 888  : 				{
; 889  : 					canSee |= SG_FADING;// we are attempting a lock so don't go higher then detection

	mov	eax, DWORD PTR _canSee$6[ebp]
	or	eax, 4
	mov	DWORD PTR _canSee$6[ebp], eax
$LN63@Exec:

; 890  : 				}
; 891  : 				
; 892  : 				// Can we see it (either with a valid lock, a jammed or fading signal?
; 893  : 				if (canSee & (SG_JAMMING | SG_FADING))						// Is it a jammed or fading signal?

	mov	ecx, DWORD PTR _canSee$6[ebp]
	and	ecx, 6
	je	SHORT $LN62@Exec

; 894  : 					tmpPtr->localData->sensorState[Radar] = Detection;			// Yep, say so (weapon can't lock on 'Detection' but digi plane can track it)

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR [eax+ecx+192], 1

; 895  : 				else

	jmp	SHORT $LN61@Exec
$LN62@Exec:

; 896  : 					tmpPtr->localData->sensorState[Radar] = SensorTrack;		// It's a valid lock, mark it as such. Even when fading, we can launch

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR [eax+ecx+192], 3
$LN61@Exec:

; 897  : 				
; 898  : 				if (!(canSee & SG_FADING))									// Is the signal fading?

	mov	edx, DWORD PTR _canSee$6[ebp]
	and	edx, 4
	jne	SHORT $LN60@Exec

; 899  : 					tmpPtr->localData->rdrLastHit = SimLibElapsedTime;// No, so update the last hit field

	mov	eax, DWORD PTR _tmpPtr$7[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+136], edx
$LN60@Exec:

; 900  : 			}
; 901  : 			else

	jmp	SHORT $LN59@Exec
$LN65@Exec:

; 902  : 				tmpPtr->localData->sensorState[Radar] = NoTrack;				// Sorry, we lost that target...

	mov	eax, DWORD PTR _tmpPtr$7[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR [ecx+edx+192], 0
$LN59@Exec:

; 903  : 			//
; 904  : 			// 2000-10-07 S.G. POSSIBLE BUG! If we are looking at our lockedTarget and we are the only one referencing it, clearing it
; 905  : 			// might invalidate tmpPtr->next. So I'll read it ahead of time
; 906  : 			//SimObjectType* tmpPtrNext = tmpPtr->next;
; 907  : 			tmpPtrNext = tmpPtr->next;

	mov	eax, DWORD PTR _tmpPtr$7[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _tmpPtrNext$3[ebp], ecx

; 908  : 			
; 909  : 			// Now is it time to do lockedTarget housekeeping stuff?
; 910  : 			// 2000-09-18 S.G. We need to check the base data because targetList item and lockedData might not be the same
; 911  : 			if (lockedTarget && tmpPtr->BaseData() == lockedTarget->BaseData()) 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	$LN48@Exec
	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	esi, eax
	jne	$LN48@Exec

; 912  : 			{
; 913  : 				// 2000-09-18 S.G. Update the lockedTarget radar sensor state with what we just calculated.
; 914  : 				lockedTarget->localData->sensorState[Radar] = tmpPtr->localData->sensorState[Radar];

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [ecx+12]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax+192]
	mov	DWORD PTR [ecx+esi+192], edx

; 915  : 				
; 916  : 				// If we can see our target, Tell the base class and the rest of the world where we're looking (if we are looking somewhere)
; 917  : 				if (canSee) 

	cmp	DWORD PTR _canSee$6[ebp], 0
	je	$LN57@Exec

; 918  : 				{
; 919  : 					tmpPtr->localData->painted = TRUE;

	mov	eax, DWORD PTR _tmpPtr$7[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+52], 1

; 920  : 					// FRB - rdrObj and rdrData not intialized yet
; 921  : 					//tmpPtr->localData->rdrDetect = rdrData->rdrDetect >> 1;
; 922  : 					SetSeekerPos( TargetAz(platform, tmpPtr), TargetEl(platform, tmpPtr) );

	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?TargetEl@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetEl
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _tmpPtr$7[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 923  : 					platform->SetRdrAz( radarData->BeamHalfAngle );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 924  : 					platform->SetRdrEl( radarData->BeamHalfAngle );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 925  : 					// 2002-02-10 MODIFIED BY S.G. Different radar cycle timer for different radar mode
; 926  : 					if (digiRadarMode == DigiSTT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+128], 0
	jne	SHORT $LN56@Exec

; 927  : 						platform->SetRdrCycleTime( 0.5F ); // Original line used to be 0.0f Made it 0.5f like the digiRadar

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime
	jmp	SHORT $LN51@Exec
$LN56@Exec:

; 928  : 					else if (digiRadarMode == DigiSAM)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+128], 1
	jne	SHORT $LN54@Exec

; 929  : 						platform->SetRdrCycleTime( 3.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime
	jmp	SHORT $LN51@Exec
$LN54@Exec:

; 930  : 					else if (digiRadarMode == DigiTWS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+128], 2
	jne	SHORT $LN52@Exec

; 931  : 						platform->SetRdrCycleTime( 3.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 932  : 					else

	jmp	SHORT $LN51@Exec
$LN52@Exec:

; 933  : 						platform->SetRdrCycleTime( 6.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@40c00000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime
$LN51@Exec:

; 934  : 					platform->SetRdrAzCenter( tmpPtr->localData->az );

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 935  : 					platform->SetRdrElCenter( tmpPtr->localData->el );

	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter

; 936  : 					
; 937  : 					// Tag the target as seen from this frame, unless the target is fading
; 938  : 					if (!(canSee & SG_FADING)) 

	mov	ecx, DWORD PTR _canSee$6[ebp]
	and	ecx, 4
	jne	SHORT $LN49@Exec

; 939  : 					{
; 940  : 						if (sendThisFrame) 

	cmp	DWORD PTR _sendThisFrame$[ebp], 0
	je	SHORT $LN49@Exec

; 941  : 						{
; 942  : 							SendTrackMsg( tmpPtr, Track_Lock, digiRadarMode );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	push	3
	mov	ecx, DWORD PTR _tmpPtr$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+80]
	call	edx

; 943  : 							lastTargetLockSend = SimLibElapsedTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+72], ecx
$LN49@Exec:

; 944  : 						}
; 945  : 					}
; 946  : 				}
; 947  : 				// If we cannot see it, we clear it...
; 948  : 				else

	jmp	SHORT $LN48@Exec
$LN57@Exec:

; 949  : 					SetDesiredTarget( NULL );

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx
$LN48@Exec:

; 950  : 			}
; 951  : 			
; 952  : 			// Now it's time to try our next target... (2000-10-07: We'll use what we saved earlier)
; 953  : 			tmpPtr = tmpPtrNext;

	mov	eax, DWORD PTR _tmpPtrNext$3[ebp]
	mov	DWORD PTR _tmpPtr$7[ebp], eax

; 954  : 		}

	jmp	$LN85@Exec
$LN82@Exec:

; 955  : 		
; 956  : 		// If we do not have a locked target, leave the radar centered...
; 957  : 		if (!lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	$LN46@Exec

; 958  : 		{
; 959  : 			SetSeekerPos( 0.0f, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 960  : 			platform->SetRdrAz( radarData->ScanHalfAngle );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+24]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 961  : 			platform->SetRdrEl( radarData->ScanHalfAngle );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+24]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 962  : 			platform->SetRdrCycleTime( 8.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 963  : 			platform->SetRdrAzCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 964  : 			platform->SetRdrElCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter

; 965  : 
; 966  : 			// FRB 
; 967  : 			if (SimDriver.GetPlayerAircraft()->AutopilotType() == AircraftClass::CombatAP)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, eax
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	jne	SHORT $LN46@Exec

; 968  : 				platform->SetRdrCycleTime( 3.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime
$LN46@Exec:

; 969  : 
; 970  : 		}
; 971  : 
; 972  : 		return lockedTarget;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	jmp	$LN108@Exec
$LN95@Exec:

; 973  : 	}
; 974  : 	// JB 010224 End Enable the CombatAP to shoot A2A missiles
; 975  : 
; 976  : 	// JPO - radar doesn't scan with WOW
; 977  : 	//if (g_bRealisticAvionics && platform->OnGround()) 
; 978  : 	//{ 
; 979  : 	//	// do nothing
; 980  : 	//}
; 981  : 	//else if (isEmitting) // only scans if its scanning!
; 982  : 
; 983  : 	// FRB - Some problems interpreting the above conditionals
; 984  : 	if (!platform->OnGround() && (isEmitting)) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN45@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN45@Exec

; 985  : 	//if (isEmitting) 
; 986  : 	{
; 987  : 		MoveBeam();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveBeam@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::MoveBeam
$LN45@Exec:

; 988  : 	}
; 989  : 	
; 990  : 	/*------------------------*/
; 991  : 	/* Go through the objects */
; 992  : 	/*------------------------*/
; 993  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 994  : 	rdrObj = targetList;

	mov	edx, DWORD PTR _targetList$[ebp]
	mov	DWORD PTR _rdrObj$[ebp], edx

; 995  : 	
; 996  : 	// Hack -- You really can lock a target, etc. in these modes...
; 997  : 	if (mode == GM || mode == GMT || mode == SEA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 14			; 0000000eH
	je	SHORT $LN43@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 16			; 00000010H
	je	SHORT $LN43@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 17			; 00000011H
	jne	SHORT $LN44@Exec
$LN43@Exec:

; 998  : 		return (NULL);

	xor	eax, eax
	jmp	$LN108@Exec
$LN44@Exec:

; 999  : 	
; 1000 : 	targetUnderCursor = FalconNullId;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+36], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+40], edx
$LN42@Exec:

; 1001 : 	
; 1002 : 	while (rdrObj)

	cmp	DWORD PTR _rdrObj$[ebp], 0
	je	$LN41@Exec

; 1003 : 	{
; 1004 : 		if (rdrObj == lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jne	SHORT $LN40@Exec

; 1005 : 			lockedFound = TRUE;

	mov	DWORD PTR _lockedFound$[ebp], 1
$LN40@Exec:

; 1006 : 		
; 1007 : 		// Is this the target under the cursor?
; 1008 : 		if (mode != VS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 5
	je	SHORT $LN39@Exec

; 1009 : 		{
; 1010 : 			if (IsUnderCursor(rdrObj, platform->Yaw()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUnderCursor@RadarDopplerClass@@IAEHPAVSimObjectType@@M@Z ; RadarDopplerClass::IsUnderCursor
	test	eax, eax
	je	SHORT $LN38@Exec

; 1011 : 				targetUnderCursor = rdrObj->BaseData()->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], edx
$LN38@Exec:

; 1012 : 		}
; 1013 : 		else

	jmp	SHORT $LN36@Exec
$LN39@Exec:

; 1014 : 		{
; 1015 : 			if (IsUnderVSCursor(rdrObj, platform->Yaw()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _rdrObj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUnderVSCursor@RadarDopplerClass@@IAEHPAVSimObjectType@@M@Z ; RadarDopplerClass::IsUnderVSCursor
	test	eax, eax
	je	SHORT $LN36@Exec

; 1016 : 				targetUnderCursor = rdrObj->BaseData()->Id();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], edx
$LN36@Exec:

; 1017 : 		}
; 1018 : 		
; 1019 : 		/*-----------------*/
; 1020 : 		/* Clear res cells */
; 1021 : 		/*-----------------*/
; 1022 : 		rngCell[i] = -1;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _rngCell$[ebp+ecx*4], -1

; 1023 : 		angCell[i] = -1;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _angCell$[ebp+edx*4], -1

; 1024 : 		velCell[i] = -1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _velCell$[ebp+eax*4], -1

; 1025 : 		rdrData = rdrObj->localData;

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _rdrData$[ebp], edx

; 1026 : 
; 1027 : 		// Did the beam cross the object
; 1028 : 		if (isEmitting && rdrObj->BaseData() &&// Radar On?
; 1029 : 			!rdrObj->BaseData()->OnGround() && // In the Air? 
; 1030 : 			(!rdrObj->BaseData()->IsSim() ||   // Campaign Entity
; 1031 : 			(!rdrObj->BaseData()->IsExploding() && // Live none weapon sim thing
; 1032 : 			!rdrObj->BaseData()->IsWeapon())) && 
; 1033 : 			LookingAtObject (rdrObj))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN35@Exec
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	test	eax, eax
	je	$LN35@Exec
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv1048[ebp], eax
	mov	ecx, DWORD PTR tv1048[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1048[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN35@Exec
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN34@Exec
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv1061[ebp], eax
	mov	ecx, DWORD PTR tv1061[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1061[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	$LN35@Exec
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv1069[ebp], eax
	mov	ecx, DWORD PTR tv1069[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1069[ebp]
	mov	eax, DWORD PTR [edx+204]
	call	eax
	test	eax, eax
	jne	$LN35@Exec
$LN34@Exec:
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookingAtObject@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z ; RadarDopplerClass::LookingAtObject
	test	eax, eax
	je	$LN35@Exec

; 1034 : 		{
; 1035 : 			rdrData->painted = TRUE;

	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+52], 1

; 1036 : 			rdrData->rdrDetect = rdrData->rdrDetect >> 1;

	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	shr	ecx, 1
	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+140], ecx

; 1037 : 			
; 1038 : 			if (ObjectDetected (rdrObj))

	mov	eax, DWORD PTR _rdrObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectDetected@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z ; RadarDopplerClass::ObjectDetected
	test	eax, eax
	je	$LN32@Exec

; 1039 : 			{
; 1040 : 				if (!InResCell (rdrObj, i, rngCell, angCell,velCell))

	lea	ecx, DWORD PTR _velCell$[ebp]
	push	ecx
	lea	edx, DWORD PTR _angCell$[ebp]
	push	edx
	lea	eax, DWORD PTR _rngCell$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rdrObj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InResCell@RadarDopplerClass@@IAEHPAVSimObjectType@@HPAH11@Z ; RadarDopplerClass::InResCell
	test	eax, eax
	jne	$LN32@Exec

; 1041 : 				{
; 1042 : 					i ++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1043 : 					ShiAssert (i<MAX_OBJECTS);
; 1044 : 					rdrData->rdrDetect = rdrData->rdrDetect | 0x0010;

	mov	ecx, DWORD PTR _rdrData$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [eax+140], edx

; 1045 : 					// 2000-11-17 ADDED BY S.G. ONLY WHEN WE HAVE 'NoTrack' DO WE SET IT TO 'Detection'. OTHERWISE WE DON'T TOUCH IT (IT MIGHT ALREADY BE 'SensorTrack')
; 1046 : 					if (rdrData->sensorState[Radar] == NoTrack)

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rdrData$[ebp]
	cmp	DWORD PTR [edx+ecx+192], 0
	jne	SHORT $LN31@Exec

; 1047 : 						// END OF ADDED SECTION
; 1048 : 						rdrData->sensorState[Radar] = Detection;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [ecx+eax+192], 1
$LN31@Exec:

; 1049 : 					rdrData->sensorLoopCount[Radar] = SimLibElapsedTime;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+edx+164], ecx

; 1050 : 					rdrData->extrapolateStart = 0;  // MD -- 20040121: reset for no extrapolation

	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+144], 0
$LN32@Exec:

; 1051 : 				}
; 1052 : 			}
; 1053 : 		}
; 1054 : 		else

	jmp	SHORT $LN28@Exec
$LN35@Exec:

; 1055 : 		{
; 1056 : 			if (!isEmitting)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN29@Exec

; 1057 : 				rdrData->sensorLoopCount[Radar] = 0;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+ecx+164], 0
$LN29@Exec:

; 1058 : 			rdrData->painted = FALSE;

	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [eax+52], 0

; 1059 : 			//Cobra 11/21/04 Wipe history if IFF not functioning
; 1060 : 			if (!((AircraftClass*)platform)->iffEnabled)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx+896], 0
	jne	SHORT $LN28@Exec

; 1061 : 				rdrData->interrogated = FALSE;

	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [eax+156], 0
$LN28@Exec:

; 1062 : 		}
; 1063 : 		
; 1064 : 		
; 1065 : 		/*-------------------------------------------------*/
; 1066 : 		/* if the target dies or goes out of the radar fov */
; 1067 : 		/* shift in one 0 per frame to "age" the track.    */
; 1068 : 		/*-------------------------------------------------*/
; 1069 : 		testTime = SimLibElapsedTime - patternTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+300]
	mov	DWORD PTR _testTime$[ebp], edx

; 1070 : 		if (rdrData->sensorLoopCount[Radar] < testTime)

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rdrData$[ebp]
	mov	edx, DWORD PTR [ecx+eax+164]
	cmp	edx, DWORD PTR _testTime$[ebp]
	jge	$LN27@Exec

; 1071 : 		{
; 1072 : 			/*-------------*/
; 1073 : 			/* shift right */
; 1074 : 			/*-------------*/
; 1075 : 			rdrData->rdrDetect = rdrData->rdrDetect >> 1;

	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	shr	ecx, 1
	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+140], ecx

; 1076 : 			
; 1077 : 			/*----------------------------------*/
; 1078 : 			/* slip, shift in a 0 for no detect */
; 1079 : 			/*----------------------------------*/
; 1080 : 			rdrData->rdrDetect = rdrData->rdrDetect & 0x000f;

	mov	eax, DWORD PTR _rdrData$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+140], ecx

; 1081 : 			
; 1082 : 			if (mode == TWS )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 4
	jne	$LN26@Exec

; 1083 : 			{
; 1084 : 				if (rdrData->extrapolateStart == 0)  // start the counter

	mov	ecx, DWORD PTR _rdrData$[ebp]
	cmp	DWORD PTR [ecx+144], 0
	jne	SHORT $LN25@Exec

; 1085 : 					rdrData->extrapolateStart = SimLibElapsedTime;

	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+144], eax
$LN25@Exec:

; 1086 : 				if ((SimLibElapsedTime - rdrData->extrapolateStart) < TwsExtrapolateTime)

	mov	ecx, DWORD PTR _rdrData$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+144]
	cmp	edx, 13000				; 000032c8H
	jae	SHORT $LN24@Exec

; 1087 : 				{
; 1088 : 					ExtrapolateHistory (rdrObj);

	mov	eax, DWORD PTR _rdrObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ExtrapolateHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@@Z ; RadarDopplerClass::ExtrapolateHistory

; 1089 : 				}
; 1090 : 				else

	jmp	$LN21@Exec
$LN24@Exec:

; 1091 : 				{
; 1092 : 					if (rdrObj == lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rdrObj$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jne	SHORT $LN22@Exec

; 1093 : 					{
; 1094 : 						reacqEl = lockedTargetData->el;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+484], eax

; 1095 : 						SetSensorTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	call	eax
$LN22@Exec:

; 1096 : 					}
; 1097 : 					ClearHistory (rdrObj);

	push	0
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z ; RadarDopplerClass::ClearHistory

; 1098 : 					rdrData->extrapolateStart = 0;  // MD -- 20040121: reset for no extrapolation

	mov	edx, DWORD PTR _rdrData$[ebp]
	mov	DWORD PTR [edx+144], 0

; 1099 : 					// MD -- 20040117: and remove from the TWS track directory after extrapolation expires
; 1100 : 					if (TWSTrackDirectory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+532], 0
	je	SHORT $LN21@Exec

; 1101 : 						TWSTrackDirectory = TWSTrackDirectory->Remove(rdrObj);

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+532]
	call	?Remove@TWSTrackList@RadarDopplerClass@@QAEPAV12@PAVSimObjectType@@@Z ; RadarDopplerClass::TWSTrackList::Remove
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+532], eax
$LN21@Exec:

; 1102 : 				}
; 1103 : 				//MI test
; 1104 : 				// MD -- 20040117: looks like this shouldn't have been left in...don't wipe extrapolation data!
; 1105 : 				//AddToHistory(rdrObj, None);
; 1106 : 			}
; 1107 : 			else // MD -- 20040118: don't do this for TWS tracks as well!

	jmp	SHORT $LN16@Exec
$LN26@Exec:

; 1108 : 			if (!rdrData->TWSTrackFileOpen)

	mov	edx, DWORD PTR _rdrData$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN16@Exec

; 1109 : 				if (rdrData->rdrSy[0] == Solid || rdrData->rdrSy[0] == None) 

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _rdrData$[ebp]
	cmp	DWORD PTR [ecx+eax+72], 2
	je	SHORT $LN17@Exec
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _rdrData$[ebp]
	cmp	DWORD PTR [eax+edx+72], 0
	jne	SHORT $LN18@Exec
$LN17@Exec:

; 1110 : 					AddToHistory(rdrObj, None);

	push	0
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z ; RadarDopplerClass::AddToHistory

; 1111 : 				else

	jmp	SHORT $LN16@Exec
$LN18@Exec:

; 1112 : 					SlipHistory(rdrObj);

	mov	edx, DWORD PTR _rdrObj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SlipHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@@Z ; RadarDopplerClass::SlipHistory
$LN16@Exec:

; 1113 : 			
; 1114 : 			/*----------------------*/
; 1115 : 			/* reset search counter */
; 1116 : 			/*----------------------*/
; 1117 : 			rdrData->sensorLoopCount[Radar] = SimLibElapsedTime;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rdrData$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+eax+164], edx
$LN27@Exec:

; 1118 : 		}
; 1119 : 		
; 1120 : 		rdrObj = rdrObj->next;

	mov	eax, DWORD PTR _rdrObj$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _rdrObj$[ebp], ecx

; 1121 : 	}

	jmp	$LN42@Exec
$LN41@Exec:

; 1122 : 	
; 1123 : 	if (!lockedFound && lockedTarget)

	cmp	DWORD PTR _lockedFound$[ebp], 0
	jne	SHORT $LN15@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN15@Exec

; 1124 : 		lockedTargetData->rdrDetect = lockedTargetData->rdrDetect >> 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR [ecx+140]
	shr	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	DWORD PTR [ecx+140], edx
$LN15@Exec:

; 1125 : 	
; 1126 : 	// Update output paramters
; 1127 : 	// NOTE:  These should be set to the _overall_ active serach volume,
; 1128 : 	// instead of sweeping with the beam to reduce the amount of dirty data we
; 1129 : 	// generate.
; 1130 : 	platform->SetRdrAz(beamWidth);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+260]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 1131 : 	platform->SetRdrEl(beamWidth);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+260]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 1132 : 	
; 1133 : 	// WARNING:  THIS IS WRONG.
; 1134 : 	// seekerAzCenter is NOT body rotated (for pitch and roll)
; 1135 : 	// while beamAz and beamEl might be.
; 1136 : 	// In any case, SetRdrAzCenter and SetRdrElCenter SHOULD BE
; 1137 : 	// body rolled so the RWR can properly interpret them...
; 1138 : 	platform->SetRdrAzCenter(beamAz + seekerAzCenter);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [ecx+56]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 1139 : 	platform->SetRdrElCenter(beamEl + seekerElCenter);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+200]
	addss	xmm0, DWORD PTR [ecx+60]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter

; 1140 : 	
; 1141 : 	
; 1142 : 	// If we changed locks, tell our previous target he's off the hook
; 1143 : 	if (lastLocked != lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lastLocked$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	je	SHORT $LN14@Exec

; 1144 : 	{
; 1145 : 		if (lastLocked)

	cmp	DWORD PTR _lastLocked$[ebp], 0
	je	SHORT $LN13@Exec

; 1146 : 		{
; 1147 : 			SendTrackMsg (lastLocked, Track_Unlock);

	push	0
	push	2
	mov	edx, DWORD PTR _lastLocked$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN13@Exec:

; 1148 : 		}
; 1149 : 		sendThisFrame = TRUE;

	mov	DWORD PTR _sendThisFrame$[ebp], 1

; 1150 : 	} else {

	jmp	SHORT $LN12@Exec
$LN14@Exec:

; 1151 : 		// See if it is time to send a "painted" list update (AA mode only)
; 1152 : 		sendThisFrame = (SimLibElapsedTime - lastTargetLockSend > TrackUpdateTime);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, DWORD PTR [ecx+72]
	cmp	edx, DWORD PTR ?TrackUpdateTime@RadarClass@@2KB ; RadarClass::TrackUpdateTime
	jbe	SHORT $LN112@Exec
	mov	DWORD PTR tv1296[ebp], 1
	jmp	SHORT $LN113@Exec
$LN112@Exec:
	mov	DWORD PTR tv1296[ebp], 0
$LN113@Exec:
	mov	eax, DWORD PTR tv1296[ebp]
	mov	DWORD PTR _sendThisFrame$[ebp], eax
$LN12@Exec:

; 1153 : 	}
; 1154 : 	
; 1155 : 	// 2002-02-09 MODIFIED BY S.G. Since radarMode is sent as well and is passed to the AI, will let him make the decision to deal with us or not...
; 1156 : 	// Tell our current target he's locked
; 1157 : 	/*	if (sendThisFrame && lockedTarget && (mode != TWS || IsSet(STTingTarget)))
; 1158 : 	{
; 1159 : 	SendTrackMsg (lockedTarget, Track_Lock);
; 1160 : 	lastTargetLockSend = SimLibElapsedTime;
; 1161 : 	}
; 1162 : 	else if (lockedTarget && mode == TWS && lockedTarget->localData->lockmsgsend == Track_Lock)
; 1163 : 	SendTrackMsg (lockedTarget, Track_Unlock);
; 1164 : 	*/
; 1165 : 	if (sendThisFrame && lockedTarget)

	cmp	DWORD PTR _sendThisFrame$[ebp], 0
	je	$LN11@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	$LN11@Exec

; 1166 : 	{
; 1167 : 		int radarMode;
; 1168 : 		
; 1169 : 		if (IsSet(STTingTarget)) // Prioritize STT over other modes

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN10@Exec

; 1170 : 			radarMode = DigiSTT;

	mov	DWORD PTR _radarMode$4[ebp], 0
	jmp	SHORT $LN5@Exec
$LN10@Exec:

; 1171 : 		else if (mode == SAM)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 10			; 0000000aH
	jne	SHORT $LN8@Exec

; 1172 : 			radarMode = DigiSAM;//me123 when pinged by a SAM mode you realize someone is targeting/interested in you. 2002-02-19 MODIFIED BY S.G. Uses the new DigiSAM mode so that if I lock another player, his RWR doesn't go wild.

	mov	DWORD PTR _radarMode$4[ebp], 1
	jmp	SHORT $LN5@Exec
$LN8@Exec:

; 1173 : 		else if (mode == TWS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 4
	jne	SHORT $LN6@Exec

; 1174 : 			radarMode = DigiTWS;

	mov	DWORD PTR _radarMode$4[ebp], 2

; 1175 : 		else

	jmp	SHORT $LN5@Exec
$LN6@Exec:

; 1176 : 			radarMode = DigiRWS;

	mov	DWORD PTR _radarMode$4[ebp], 3
$LN5@Exec:

; 1177 : 		
; 1178 : #ifdef DEBUG
; 1179 : 		MonoPrint("Player sending a type %d Track_Lock\n", radarMode);
; 1180 : #endif
; 1181 : 		SendTrackMsg (lockedTarget, Track_Lock, radarMode);

	mov	ecx, DWORD PTR _radarMode$4[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 1182 : 		lastTargetLockSend = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+72], edx
$LN11@Exec:

; 1183 : 	}
; 1184 : 	// END OF MODFIIED SECTION
; 1185 : 	
; 1186 : 	// Do NCTR Stuff
; 1187 : 	if (lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN4@Exec

; 1188 : 	{
; 1189 : 		// Saw this frame, so update our best guess
; 1190 : 		if (radarDatFile && lockedTargetData->painted && lockedTargetData->range < radarDatFile->MaxNctrRange &&
; 1191 : 			lockedTargetData->ataFrom < 45 * DTR)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	$LN3@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	cmp	DWORD PTR [eax+52], 0
	je	$LN3@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	movss	xmm0, DWORD PTR [ecx+164]
	comiss	xmm0, DWORD PTR [edx+44]
	jbe	$LN3@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	movss	xmm0, DWORD PTR __real@3f490fd9
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	$LN3@Exec

; 1192 : 		{
; 1193 : 			// Make a guess based on range
; 1194 : 			rVal = ((float)rand() / RAND_MAX);

	call	_rand
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46fffe00
	movss	DWORD PTR _rVal$[ebp], xmm0

; 1195 : 			delta = radarDatFile->NctrDelta * lockedTargetData->range / radarDatFile->MaxNctrRange * rVal;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	movss	xmm0, DWORD PTR [edx+168]
	mulss	xmm0, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	divss	xmm0, DWORD PTR [eax+164]
	mulss	xmm0, DWORD PTR _rVal$[ebp]
	movss	DWORD PTR _delta$[ebp], xmm0

; 1196 : 			
; 1197 : 			// Add in the truth, with a range factor
; 1198 : 			rVal = 1.0F - lockedTargetData->range / radarDatFile->MaxNctrRange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	movss	xmm0, DWORD PTR [edx+44]
	divss	xmm0, DWORD PTR [ecx+164]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR _rVal$[ebp], xmm1

; 1199 : 			if ( TeamInfo[platform->GetTeam()]->TStance(lockedTarget->BaseData()->GetTeam()) == War )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv1421[ebp], eax
	mov	eax, DWORD PTR tv1421[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1421[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?TStance@TeamClass@@QAEHE@Z		; TeamClass::TStance
	cmp	eax, 5
	jne	SHORT $LN2@Exec

; 1200 : 				rVal *= -1.0F;

	movss	xmm0, DWORD PTR _rVal$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _rVal$[ebp], xmm0
$LN2@Exec:

; 1201 : 			rVal += delta;

	movss	xmm0, DWORD PTR _rVal$[ebp]
	addss	xmm0, DWORD PTR _delta$[ebp]
	movss	DWORD PTR _rVal$[ebp], xmm0

; 1202 : 			
; 1203 : 			// integrate NCTR Percentage
; 1204 : 			nctrData = 0.3F * rVal + 0.7F * nctrData;

	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR _rVal$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@3f333333
	mulss	xmm1, DWORD PTR [edx+488]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+488], xmm0
$LN3@Exec:

; 1205 : 		}
; 1206 : 	}
; 1207 : 	else

	jmp	SHORT $LN1@Exec
$LN4@Exec:

; 1208 : 	{
; 1209 : 		nctrData = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+488], xmm0
$LN1@Exec:

; 1210 : 	}
; 1211 : 	return lockedTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
$LN108@Exec:

; 1212 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?Exec@RadarDopplerClass@@UAEPAVSimObjectType@@PAV2@@Z ENDP ; RadarDopplerClass::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv86 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newImage$ = 8						; size = 4
?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z PROC ; RadarDopplerClass::DisplayInit
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	DisplayExit();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 184  : 	
; 185  : 	privateDisplay = new RenderGMComposite;

	push	526140					; 0008073cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@DisplayIni
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0RenderGMComposite@@QAE@XZ		; RenderGMComposite::RenderGMComposite
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN6@DisplayIni
$LN5@DisplayIni:
	mov	DWORD PTR tv86[ebp], 0
$LN6@DisplayIni:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+24], eax

; 186  : 	((RenderGMComposite*)privateDisplay)->Setup(newImage, AddTargetReturnCallback, this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET ?AddTargetReturnCallback@RadarDopplerClass@@KAXPAXPAVRenderGMRadar@@_N@Z ; RadarDopplerClass::AddTargetReturnCallback
	mov	edx, DWORD PTR _newImage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [eax+144]
	call	edx

; 187  : 	
; 188  : 	// Prep GM Radar
; 189  : 	if (mode == GM || mode == GMT || mode == SEA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 14			; 0000000eH
	je	SHORT $LN1@DisplayIni
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 16			; 00000010H
	je	SHORT $LN1@DisplayIni
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 17			; 00000011H
	jne	SHORT $LN2@DisplayIni
$LN1@DisplayIni:

; 190  : 		SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan
$LN2@DisplayIni:

; 191  : 	
; 192  : 	privateDisplay->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+24]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 193  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayInit@RadarDopplerClass@@UAEXPAVImageBuffer@@@Z ENDP ; RadarDopplerClass::DisplayInit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RadarDopplerClass@@UAE@XZ PROC			; RadarDopplerClass::~RadarDopplerClass
; _this$ = ecx

; 167  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RadarDopplerClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RadarDopplerClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 168  :    FreeGMList (GMFeatureListRoot);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeGMList@RadarDopplerClass@@IAEXPAVGMList@1@@Z ; RadarDopplerClass::FreeGMList

; 169  :    FreeGMList (GMMoverListRoot);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+520]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeGMList@RadarDopplerClass@@IAEXPAVGMList@1@@Z ; RadarDopplerClass::FreeGMList

; 170  :    GMFeatureListRoot = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], 0

; 171  :    GMMoverListRoot = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 0

; 172  :    ClearSensorTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearSensorTarget@RadarDopplerClass@@MAEXXZ ; RadarDopplerClass::ClearSensorTarget

; 173  : 
; 174  :    // MD -- 20040116: clean up TWS directory
; 175  :    if (TWSTrackDirectory) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+532], 0
	je	SHORT $LN2@RadarDoppl

; 176  : 	   TWSTrackDirectory = TWSTrackDirectory->Purge();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+532]
	call	?Purge@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ ; RadarDopplerClass::TWSTrackList::Purge
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+532], eax
$LN2@RadarDoppl:

; 177  :    }
; 178  : 
; 179  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarClass@@UAE@XZ			; RadarClass::~RadarClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1RadarDopplerClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RadarClass@@UAE@XZ			; RadarClass::~RadarClass
__ehhandler$??1RadarDopplerClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RadarDopplerClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RadarDopplerClass@@UAE@XZ ENDP			; RadarDopplerClass::~RadarDopplerClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radardoppler.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_self$ = 12						; size = 4
??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z PROC	; RadarDopplerClass::RadarDopplerClass
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _self$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RadarClass@@QAE@HPAVSimMoverClass@@@Z ; RadarClass::RadarClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7RadarDopplerClass@@6B@

; 30   : 	rangeScales[0] = 10.0F;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+eax+312], xmm0

; 31   : 	rangeScales[1] = 20.0F;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [eax+edx+312], xmm0

; 32   : 	rangeScales[2] = 40.0F;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR [edx+ecx+312], xmm0

; 33   : 	rangeScales[3] = 80.0F;

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [ecx+eax+312], xmm0

; 34   : 	rangeScales[4] = 160.0F;

	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43200000
	movss	DWORD PTR [eax+edx+312], xmm0

; 35   : 	velScales[0] = 1200.0F;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [edx+ecx+356], xmm0

; 36   : 	velScales[1] = 2400.0F;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@45160000
	movss	DWORD PTR [ecx+eax+356], xmm0

; 37   : 	rwsAzs[0] = 30.0F * DTR;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f060a91
	movss	DWORD PTR [eax+edx+332], xmm0

; 38   : 	rwsAzs[1] = 10.0F * DTR;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	movss	DWORD PTR [edx+ecx+332], xmm0

; 39   : 	rwsAzs[2] = 60.0F * DTR;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR [ecx+eax+332], xmm0

; 40   : 	rwsBars[0] = 1;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+364], 1

; 41   : 	rwsBars[1] = 2;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+364], 2

; 42   : 	rwsBars[2] = 4;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+364], 4

; 43   : 	twsAzs[0] = 10.0F * DTR;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	movss	DWORD PTR [eax+edx+344], xmm0

; 44   : 	twsAzs[1] = 60.0F * DTR;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR [edx+ecx+344], xmm0

; 45   : 	twsAzs[2] = 25.0F * DTR;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3edf66f1
	movss	DWORD PTR [ecx+eax+344], xmm0

; 46   : 	twsBars[0] = 4;

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+376], 4

; 47   : 	twsBars[1] = 2;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+376], 2

; 48   : 	twsBars[2] = 3;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+376], 3

; 49   : 	vsVelIdx = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 0

; 50   : 	gmRangeIdx = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+404], 2

; 51   : 	airRangeIdx = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+408], 2

; 52   : 	twsAzIdx = lastTwsAzIdx = 2;  // MD

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+416], 2

; 53   : 	rwsAzIdx = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+412], 2

; 54   : 	vsAzIdx = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+424], 2

; 55   : 	//MI
; 56   : 	gmAzIdx = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+428], 2

; 57   : 	gmtAzIdx = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], 2

; 58   : 	rwsBarIdx = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+436], 2

; 59   : 	twsBarIdx = lastTwsBarIdx = 2;  // MD

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+444], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+440], 2

; 60   : 	gmBarIdx = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+448], 0

; 61   : 	vsBarIdx = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+452], 2

; 62   : 	scanRate = 60.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR [ecx+256], xmm0

; 63   : 	designateCmd		= FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0

; 64   : 	dropTrackCmd		= FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 65   : 	rangeChangeCmd		= FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0

; 66   : 	scanHeightCmd		= FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 67   : 	scanWidthCmd		= FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0

; 68   : 	elSlewCmd			= FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0

; 69   : 	targetAz			= 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+244], xmm0

; 70   : 	targetEl			= 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+240], xmm0

; 71   : 	curScanTop			= 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+272], xmm0

; 72   : 	curScanBottom		= 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+276], xmm0

; 73   : 	curScanLeft			= 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+280], xmm0

; 74   : 	curScanRight		= 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+284], xmm0

; 75   : 	scanCenterAlt		= 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+288], xmm0

; 76   : 	lastBars			= 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 1

; 77   : 	cursRange			= 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+480], xmm0

; 78   : 	subMode				= FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+504], 0

; 79   : 	lastFeatureUpdate = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+512], 0

; 80   : 	reacqFlag         = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+192], 0

; 81   : 	reacqEl           = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+484], xmm0

; 82   : 	displayAzScan     = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+216], xmm0

; 83   : 	displayRange = 10.f; // something JPO

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+212], xmm0

; 84   : 	azScan = 60.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR [edx+204], xmm0

; 85   : 	elScan = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+208], xmm0

; 86   : 
; 87   : 	beamAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+196], xmm0

; 88   : 	beamEl = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+200], xmm0

; 89   : 	mode = prevMode = RWS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], 2

; 90   : 	Missovrradarmode = RWS;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 2

; 91   : 	Dogfovrradarmode = ACM_30x20;//me123

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 6

; 92   : 	noovrradarmode = RWS; //me123

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 2

; 93   : 	Overridemode = 0;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 0

; 94   : 	cursorX = cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+220], xmm0

; 95   : 	flags = NORM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], 1

; 96   : 	lockedTargetData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+176], 0

; 97   : 	curCursorRate = CursorRate;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?CursorRate@RadarClass@@1MB
	movss	DWORD PTR [ecx+228], xmm0

; 98   : 	centerCmd = FALSE; // JPO initialise

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+172], 0

; 99   : 
; 100  : 	// MD -- 20040116: TWS mode init
; 101  : 	// MD -- 20040204: moved up to avoid CTD in ChangeMode()
; 102  : 	TWSTrackDirectory = (TWSTrackList *) NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+532], 0

; 103  : 	GMSPPseudoWaypt = NULL;  // MD -- 20040214: pseudo waypoint for ground stabilised GM SP mode

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], 0

; 104  : 
; 105  : 	ChangeMode (mode);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode

; 106  : 	SetScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetScan

; 107  : 
; 108  : 	// GM mode init
; 109  : 	GMFeatureListRoot = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+516], 0

; 110  : 	GMMoverListRoot = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+520], 0

; 111  : 	gainCmd = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+136], xmm0

; 112  : 	groundLookAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+468], xmm0

; 113  : 
; 114  : 	//JPO initialise the stuff
; 115  : 	channelno = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+548], 1

; 116  : 	histno = 4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+552], 4

; 117  : 	level = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+556], 1

; 118  : 	mkint = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+560], 1

; 119  : 	bdelay = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+564], xmm0

; 120  : 	radarmodeflags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+568], 0

; 121  : 	fovStepCmd = 0;	//MI

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+160], 0

; 122  : 	// JPO default declutter modes
; 123  : 	agdclt = DefaultAgDclt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+500], 147192		; 00023ef8H

; 124  : 	aadclt = DefaultAaDclt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+496], 146968		; 00023e18H

; 125  : 
; 126  : 	//MI
; 127  : 	DrawRCR = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+132], 0

; 128  : 	//MI IFF stuff
; 129  : 	InterogateTimer = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+580], xmm0

; 130  : 	DoInterogate = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+601], 0

; 131  : 	LOS = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+576], 0

; 132  : 	SCAN = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+577], 0

; 133  : 	CountUp = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+600], 0

; 134  : 	Input = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+592], xmm0

; 135  : 	InterogateDelay = 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+584], xmm0

; 136  : 	Mode1 = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+602], 0

; 137  : 	Mode2 = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+603], 0

; 138  : 	Mode3 = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+604], 0

; 139  : 	Mode4 = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+605], 0

; 140  : 	ModeC = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+606], 0

; 141  : 	InterogateModus = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+588], 0

; 142  : 	CmdLOS = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+578], 0

; 143  : 	Pointer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+596], 0

; 144  : 
; 145  : 	//MI remember our last MissOver Range
; 146  : 	MissOvrRangeIdx = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+928], 1

; 147  : 	lastAirRangeIdx = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+932], 2

; 148  : 
; 149  : 	//MI
; 150  : 	LastAAMode = RWS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 2

; 151  : 	LastNAVMode = RWS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 2

; 152  : 	LastAGMode = GM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], 14			; 0000000eH

; 153  : 	LastAGModes = 3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+936], 3

; 154  : 	WasAutoAGRange = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+940], 1

; 155  : 	GainPos = 10.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+944], xmm0

; 156  : 	InitGain = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+956], 1

; 157  : 	lastRngKnobPos = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+952], 0

; 158  : 	antElevKnob = 0.0f;//TJL 05/30/04 This fixes the -99/-99 error some are having

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+232], xmm0

; 159  : //	GMTSlowSpeedReject = 5.0F;	MN externalised
; 160  : //	GMTHighSpeedReject = 100.0F;
; 161  : 	iffmodeflags = 0;//Cobra 11/24/04

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+572], 0

; 162  : 	wipeIFF = FALSE;//Cobra 11/24/04

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+180], 0

; 163  : 	iffTimer = 0.0f;//Cobra 11/24/04

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+236], xmm0

; 164  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RadarClass@@UAE@XZ			; RadarClass::~RadarClass
__ehhandler$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RadarDopplerClass@@QAE@HPAVSimMoverClass@@@Z ENDP	; RadarDopplerClass::RadarDopplerClass
; Function compile flags: /Odtp
;	COMDAT ??_GRadarClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRadarClass@@UAEPAXI@Z PROC				; RadarClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarClass@@UAE@XZ			; RadarClass::~RadarClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRadarClass@@UAEPAXI@Z ENDP				; RadarClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ PROC	; RadarClass::GetRadarModeR, COMDAT
; _this$ = ecx

; 115  : 	virtual RadarMode	GetRadarModeR(void)	{return mode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+84]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ ENDP	; RadarClass::GetRadarModeR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ClearModeDesiredCmd@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearModeDesiredCmd@RadarClass@@UAEXXZ PROC		; RadarClass::ClearModeDesiredCmd, COMDAT
; _this$ = ecx

; 105  : 	virtual void ClearModeDesiredCmd(void)	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearModeDesiredCmd@RadarClass@@UAEXXZ ENDP		; RadarClass::ClearModeDesiredCmd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetBuggedData@RadarClass@@UAEHPAM000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dir$ = 16						; size = 4
_speed$ = 20						; size = 4
?GetBuggedData@RadarClass@@UAEHPAM000@Z PROC		; RadarClass::GetBuggedData, COMDAT
; _this$ = ecx

; 99   : 	virtual int GetBuggedData (float *x, float *y, float *dir, float *speed) { return FALSE; }; // info about bugged target

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetBuggedData@RadarClass@@UAEHPAM000@Z ENDP		; RadarClass::GetBuggedData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetCursorPosition@RadarClass@@UAEXPAM0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetCursorPosition@RadarClass@@UAEXPAM0@Z PROC		; RadarClass::GetCursorPosition, COMDAT
; _this$ = ecx

; 98   : 	virtual void  GetCursorPosition (float*, float*) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetCursorPosition@RadarClass@@UAEXPAM0@Z ENDP		; RadarClass::GetCursorPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetVolume@RadarClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVolume@RadarClass@@UAEMXZ PROC			; RadarClass::GetVolume, COMDAT
; _this$ = ecx

; 97   : 	virtual float GetVolume (void)				{ return 1.0472F; };	// Default to 60 degree cone

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@3f860aa6
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVolume@RadarClass@@UAEMXZ ENDP			; RadarClass::GetVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetRange@RadarClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRange@RadarClass@@UAEMXZ PROC			; RadarClass::GetRange, COMDAT
; _this$ = ecx

; 96   : 	virtual float GetRange(void)				{ return 10.0F; };		// Display range in NM

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@41200000
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRange@RadarClass@@UAEMXZ ENDP			; RadarClass::GetRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetAGCenter@RadarClass@@UAEXPAM0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetAGCenter@RadarClass@@UAEXPAM0@Z PROC		; RadarClass::GetAGCenter, COMDAT
; _this$ = ecx

; 95   : 	virtual void  GetAGCenter (float* x, float* y)	{*x = 0; *y = 0;};	// Center of radar ground search

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAGCenter@RadarClass@@UAEXPAM0@Z ENDP		; RadarClass::GetAGCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?IsAG@RadarClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAG@RadarClass@@UAEHXZ PROC				; RadarClass::IsAG, COMDAT
; _this$ = ecx

; 94   : 	virtual int   IsAG (void)					{ return FALSE; };		// Is radar in A/G mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAG@RadarClass@@UAEHXZ ENDP				; RadarClass::IsAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetGroundPoint@RadarClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SetGroundPoint@RadarClass@@UAEXMMM@Z PROC		; RadarClass::SetGroundPoint, COMDAT
; _this$ = ecx

; 91   : 	virtual void SetGroundPoint (float, float, float) {};	//Set center of ground map radar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetGroundPoint@RadarClass@@UAEXMMM@Z ENDP		; RadarClass::SetGroundPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ToggleAGcursorZero@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleAGcursorZero@RadarClass@@UAEXXZ PROC		; RadarClass::ToggleAGcursorZero, COMDAT
; _this$ = ecx

; 90   : 	virtual void ToggleAGcursorZero()			{};	// Remove pilot cursor offsets

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGcursorZero@RadarClass@@UAEXXZ ENDP		; RadarClass::ToggleAGcursorZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetAGSnowPlow@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetAGSnowPlow@RadarClass@@UAEXH@Z PROC			; RadarClass::SetAGSnowPlow, COMDAT
; _this$ = ecx

; 89   : 	virtual void SetAGSnowPlow(int )				{};	// Look a fixed distance ahead of the AC

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGSnowPlow@RadarClass@@UAEXH@Z ENDP			; RadarClass::SetAGSnowPlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ToggleAGsnowPlow@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleAGsnowPlow@RadarClass@@UAEXXZ PROC		; RadarClass::ToggleAGsnowPlow, COMDAT
; _this$ = ecx

; 88   : 	virtual void ToggleAGsnowPlow()				{};	// Look a fixed distance ahead of the AC

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGsnowPlow@RadarClass@@UAEXXZ ENDP		; RadarClass::ToggleAGsnowPlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ToggleAGfreeze@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleAGfreeze@RadarClass@@UAEXXZ PROC			; RadarClass::ToggleAGfreeze, COMDAT
; _this$ = ecx

; 87   : 	virtual void ToggleAGfreeze()				{};	// Freeze radar image

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGfreeze@RadarClass@@UAEXXZ ENDP			; RadarClass::ToggleAGfreeze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z PROC		; RadarClass::SetMode, COMDAT
; _this$ = ecx

; 85   :    virtual void SetMode(RadarMode )       {};   // Select new mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z ENDP		; RadarClass::SetMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAGgain@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?StepAGgain@RadarClass@@UAEXH@Z PROC			; RadarClass::StepAGgain, COMDAT
; _this$ = ecx

; 84   : 	virtual void StepAGgain( int )			{};	// Select gain on GM radar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?StepAGgain@RadarClass@@UAEXH@Z ENDP			; RadarClass::StepAGgain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAGfov@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGfov@RadarClass@@UAEXXZ PROC			; RadarClass::StepAGfov, COMDAT
; _this$ = ecx

; 83   : 	virtual void StepAGfov()					{};	// Select the degree of "zoom" on GM radar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGfov@RadarClass@@UAEXXZ ENDP			; RadarClass::StepAGfov
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAGmode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGmode@RadarClass@@UAEXXZ PROC			; RadarClass::StepAGmode, COMDAT
; _this$ = ecx

; 81   : 	virtual void StepAGmode( void )				{};	// Enter or step AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGmode@RadarClass@@UAEXXZ ENDP			; RadarClass::StepAGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?DefaultAGMode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DefaultAGMode@RadarClass@@UAEXXZ PROC			; RadarClass::DefaultAGMode, COMDAT
; _this$ = ecx

; 80   : 	virtual void DefaultAGMode( void )			{};	// If not in AG go to default AG mode, otherwise nothing

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultAGMode@RadarClass@@UAEXXZ ENDP			; RadarClass::DefaultAGMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAelvation@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?StepAAelvation@RadarClass@@UAEXH@Z PROC		; RadarClass::StepAAelvation, COMDAT
; _this$ = ecx

; 78   : 	virtual void StepAAelvation( int )		{};	// Adjust the lookup/lookdown angle of the radar (cmd=0 means center it)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?StepAAelvation@RadarClass@@UAEXH@Z ENDP		; RadarClass::StepAAelvation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAscanWidth@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAscanWidth@RadarClass@@UAEXXZ PROC		; RadarClass::StepAAscanWidth, COMDAT
; _this$ = ecx

; 77   : 	virtual void StepAAscanWidth()				{};	// radar scan volume.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAscanWidth@RadarClass@@UAEXXZ ENDP		; RadarClass::StepAAscanWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAscanHeight@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAscanHeight@RadarClass@@UAEXXZ PROC		; RadarClass::StepAAscanHeight, COMDAT
; _this$ = ecx

; 76   : 	virtual void StepAAscanHeight()				{};	// Adjust the width and height of the

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAscanHeight@RadarClass@@UAEXXZ ENDP		; RadarClass::StepAAscanHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACM30x20@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACM30x20@RadarClass@@UAEXXZ PROC			; RadarClass::SelectACM30x20, COMDAT
; _this$ = ecx

; 74   : 	virtual void SelectACM30x20()				{};	//  when already in an ACM mode.)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACM30x20@RadarClass@@UAEXXZ ENDP			; RadarClass::SelectACM30x20
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACMSlew@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMSlew@RadarClass@@UAEXXZ PROC			; RadarClass::SelectACMSlew, COMDAT
; _this$ = ecx

; 73   : 	virtual void SelectACMSlew()				{};	// (in hard mode, at least, this only works

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMSlew@RadarClass@@UAEXXZ ENDP			; RadarClass::SelectACMSlew
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACMBore@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMBore@RadarClass@@UAEXXZ PROC			; RadarClass::SelectACMBore, COMDAT
; _this$ = ecx

; 72   : 	virtual void SelectACMBore()				{};	// AA mode.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMBore@RadarClass@@UAEXXZ ENDP			; RadarClass::SelectACMBore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACMVertical@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMVertical@RadarClass@@UAEXXZ PROC		; RadarClass::SelectACMVertical, COMDAT
; _this$ = ecx

; 71   : 	virtual void SelectACMVertical()			{};	// Go directly to the named

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMVertical@RadarClass@@UAEXXZ ENDP		; RadarClass::SelectACMVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ClearOverride@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearOverride@RadarClass@@UAEXXZ PROC			; RadarClass::ClearOverride, COMDAT
; _this$ = ecx

; 69   : 	virtual void ClearOverride()				{};	// Return to previous mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearOverride@RadarClass@@UAEXXZ ENDP			; RadarClass::ClearOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetMRMOverride@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetMRMOverride@RadarClass@@UAEXXZ PROC			; RadarClass::SetMRMOverride, COMDAT
; _this$ = ecx

; 68   : 	virtual void SetMRMOverride()				{};	// Temporary pop into medium range AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMRMOverride@RadarClass@@UAEXXZ ENDP			; RadarClass::SetMRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetSRMOverride@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetSRMOverride@RadarClass@@UAEXXZ PROC			; RadarClass::SetSRMOverride, COMDAT
; _this$ = ecx

; 67   : 	virtual void SetSRMOverride()				{};	// Temporary pop into short range AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetSRMOverride@RadarClass@@UAEXXZ ENDP			; RadarClass::SetSRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAmode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAmode@RadarClass@@UAEXXZ PROC			; RadarClass::StepAAmode, COMDAT
; _this$ = ecx

; 66   : 	virtual void StepAAmode( void )				{};	// Enter or step AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAmode@RadarClass@@UAEXXZ ENDP			; RadarClass::StepAAmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?DefaultAAMode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DefaultAAMode@RadarClass@@UAEXXZ PROC			; RadarClass::DefaultAAMode, COMDAT
; _this$ = ecx

; 65   : 	virtual void DefaultAAMode( void )			{};	// If not in AA go to default AA mode, otherwise nothing

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultAAMode@RadarClass@@UAEXXZ ENDP			; RadarClass::DefaultAAMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?PrevTarget@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PrevTarget@RadarClass@@UAEXXZ PROC			; RadarClass::PrevTarget, COMDAT
; _this$ = ecx

; 61   : 	virtual void PrevTarget( void )				{};	// Step to prev available target

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrevTarget@RadarClass@@UAEXXZ ENDP			; RadarClass::PrevTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?NextTarget@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NextTarget@RadarClass@@UAEXXZ PROC			; RadarClass::NextTarget, COMDAT
; _this$ = ecx

; 60   : 	virtual void NextTarget( void )				{};	// Step to next available target

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextTarget@RadarClass@@UAEXXZ ENDP			; RadarClass::NextTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?RangeStep@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?RangeStep@RadarClass@@UAEXH@Z PROC			; RadarClass::RangeStep, COMDAT
; _this$ = ecx

; 58   : 	virtual void RangeStep( int )			{};	// Step up/down in range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?RangeStep@RadarClass@@UAEXH@Z ENDP			; RadarClass::RangeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ??1RadarClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RadarClass@@UAE@XZ PROC				; RadarClass::~RadarClass, COMDAT
; _this$ = ecx

; 38   : 	virtual ~RadarClass()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RadarClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SensorClass@@UAE@XZ			; SensorClass::~SensorClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1RadarClass@@UAE@XZ ENDP				; RadarClass::~RadarClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ PROC	; SensorClass::GetDisplay, COMDAT
; _this$ = ecx

; 55   : 	VirtualDisplay*	GetDisplay(void)                        { return privateDisplay; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ ENDP	; SensorClass::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ PROC	; SensorClass::TargetUnderCursor, COMDAT
; _this$ = ecx

; 53   : 	virtual VU_ID TargetUnderCursor (void)                  { return targetUnderCursor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ ENDP	; SensorClass::TargetUnderCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SetSeekerPos@SensorClass@@UAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newAz$ = 8						; size = 4
_newEl$ = 12						; size = 4
?SetSeekerPos@SensorClass@@UAEXMM@Z PROC		; SensorClass::SetSeekerPos, COMDAT
; _this$ = ecx

; 51   : 	virtual void SetSeekerPos (float newAz, float newEl)	{ seekerAzCenter = newAz; seekerElCenter = newEl; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newAz$[ebp]
	movss	DWORD PTR [eax+56], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newEl$[ebp]
	movss	DWORD PTR [ecx+60], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSeekerPos@SensorClass@@UAEXMM@Z ENDP		; SensorClass::SetSeekerPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?UpdateState@SensorClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?UpdateState@SensorClass@@UAEXHH@Z PROC			; SensorClass::UpdateState, COMDAT
; _this$ = ecx

; 50   : 	virtual void UpdateState(int, int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateState@SensorClass@@UAEXHH@Z ENDP			; SensorClass::UpdateState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?ExecModes@SensorClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?ExecModes@SensorClass@@UAEXHH@Z PROC			; SensorClass::ExecModes, COMDAT
; _this$ = ecx

; 49   : 	virtual void ExecModes(int, int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?ExecModes@SensorClass@@UAEXHH@Z ENDP			; SensorClass::ExecModes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?IsOn@SensorClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOn@SensorClass@@UAEHXZ PROC				; SensorClass::IsOn, COMDAT
; _this$ = ecx

; 40   : 	virtual BOOL			IsOn(void)				{ return isOn; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsOn@SensorClass@@UAEHXZ ENDP				; SensorClass::IsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SetType@SensorClass@@UAEXW4SensorType@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_senstype$ = 8						; size = 4
?SetType@SensorClass@@UAEXW4SensorType@1@@Z PROC	; SensorClass::SetType, COMDAT
; _this$ = ecx

; 37   : 	virtual void	SetType(SensorType senstype)		{ sensorType = senstype; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _senstype$[ebp]
	mov	DWORD PTR [eax+68], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetType@SensorClass@@UAEXW4SensorType@1@@Z ENDP	; SensorClass::SetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vd$ = 8						; size = 4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z PROC	; MfdDrawable::Display, COMDAT
; _this$ = ecx

; 138  :       virtual void Display (VirtualDisplay*vd) { display = vd; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vd$[ebp]
	mov	DWORD PTR [eax+20], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z ENDP	; MfdDrawable::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
