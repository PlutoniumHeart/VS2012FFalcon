; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\RADAR\State.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
_APG68_BAR_WIDTH DD 03d1d466dr			; 0.0383972
_SAM_PATTERN_TIME DD 040a00000r			; 5
_GM_OVERSCAN DD	03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??BVU_SESSION_ID@@QBEKXZ			; VU_SESSION_ID::operator unsigned long
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??BVU_ID@@QBEKXZ				; VU_ID::operator unsigned long
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?IsSOI@DrawableClass@@QAEHXZ			; DrawableClass::IsSOI
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?Set@HudDataType@@QAEXH@Z			; HudDataType::Set
PUBLIC	?Clear@HudDataType@@QAEXH@Z			; HudDataType::Clear
PUBLIC	?UpdateState@RadarDopplerClass@@UAEXHH@Z	; RadarDopplerClass::UpdateState
PUBLIC	?StepAAmode@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::StepAAmode
PUBLIC	?SetSRMOverride@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SetSRMOverride
PUBLIC	?SetMRMOverride@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::SetMRMOverride
PUBLIC	?ClearOverride@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::ClearOverride
PUBLIC	?FindClosest@RadarDopplerClass@@QAEXM@Z		; RadarDopplerClass::FindClosest
PUBLIC	?StepAzimuth@RadarDopplerClass@@QAEXMH@Z	; RadarDopplerClass::StepAzimuth
PUBLIC	?StepAAelvation@RadarDopplerClass@@UAEXH@Z	; RadarDopplerClass::StepAAelvation
PUBLIC	?AntElevKnob@RadarDopplerClass@@UAEMXZ		; RadarDopplerClass::AntElevKnob
PUBLIC	?StepAGmode@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::StepAGmode
PUBLIC	?DefaultAGMode@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::DefaultAGMode
PUBLIC	?DefaultAAMode@RadarDopplerClass@@UAEXXZ	; RadarDopplerClass::DefaultAAMode
PUBLIC	?NextTarget@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::NextTarget
PUBLIC	?PrevTarget@RadarDopplerClass@@UAEXXZ		; RadarDopplerClass::PrevTarget
PUBLIC	?SetMode@RadarDopplerClass@@UAEXW4RadarMode@RadarClass@@@Z ; RadarDopplerClass::SetMode
PUBLIC	?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ; RadarDopplerClass::TWSTrackList::TrackFile
PUBLIC	?Next@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ ; RadarDopplerClass::TWSTrackList::Next
PUBLIC	?IsSet@RadarDopplerClass@@QAEHH@Z		; RadarDopplerClass::IsSet
PUBLIC	?SetFlagBit@RadarDopplerClass@@QAEXH@Z		; RadarDopplerClass::SetFlagBit
PUBLIC	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::ClearFlagBit
PUBLIC	?ChangeMode@RadarDopplerClass@@IAEXH@Z		; RadarDopplerClass::ChangeMode
PUBLIC	?SetScan@RadarDopplerClass@@IAEXXZ		; RadarDopplerClass::SetScan
PUBLIC	?CalcSAMAzLimit@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::CalcSAMAzLimit
PUBLIC	?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ; RadarDopplerClass::GMSPWaypt
PUBLIC	?GetLastMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetLastMasterMode
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?IsAGMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsAGMasterMode
PUBLIC	?IsAAMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsAAMasterMode
PUBLIC	?IsNavMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsNavMasterMode
PUBLIC	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e860a91
PUBLIC	__real@3ecd87ab
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@3f866666
PUBLIC	__real@3fba2e8c
PUBLIC	__real@3ffeb852
PUBLIC	__real@40000000
PUBLIC	__real@400ccccd
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40d00000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	__real@447a0000
PUBLIC	__real@45bde1b0
PUBLIC	__real@461c4000
PUBLIC	__real@48ed5a1c
PUBLIC	__real@bd56774e
PUBLIC	__real@bdb2b8c1
PUBLIC	__real@bf666666
PUBLIC	__real@bf800000
PUBLIC	__real@bf860a91
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_abs:PROC
EXTRN	_fabs:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?TargetAz@@YAMPAVFalconEntity@@MM@Z:PROC	; TargetAz
EXTRN	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetAz
EXTRN	?TargetEl@@YAMPAVFalconEntity@@MMM@Z:PROC	; TargetEl
EXTRN	?TargetEl@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetEl
EXTRN	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrCycleTime
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?OnList@TWSTrackList@RadarDopplerClass@@QAEPAV12@PAVSimObjectType@@@Z:PROC ; RadarDopplerClass::TWSTrackList::OnList
EXTRN	?Purge@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ:PROC ; RadarDopplerClass::TWSTrackList::Purge
EXTRN	?ObjectDetected@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z:PROC ; RadarDopplerClass::ObjectDetected
EXTRN	?AddToHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z:PROC ; RadarDopplerClass::AddToHistory
EXTRN	?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z:PROC ; RadarDopplerClass::SetGMSPWaypt
EXTRN	?SetGMScan@RadarDopplerClass@@IAEXXZ:PROC	; RadarDopplerClass::SetGMScan
EXTRN	?SetAimPoint@RadarDopplerClass@@IAEXMM@Z:PROC	; RadarDopplerClass::SetAimPoint
EXTRN	?CheckGMBump@RadarDopplerClass@@IAEHXZ:PROC	; RadarDopplerClass::CheckGMBump
EXTRN	?DropGMTrack@RadarDopplerClass@@IAEXXZ:PROC	; RadarDopplerClass::DropGMTrack
EXTRN	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ:PROC ; FireControlComputer::GetMainMasterMode
EXTRN	?SetStptMode@FireControlComputer@@QAEXW4FCCStptMode@1@@Z:PROC ; FireControlComputer::SetStptMode
EXTRN	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z:PROC ; SIMLIB_IO_CLASS::GetAxisValue
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?TheHud@@3PAVHudClass@@A:DWORD			; TheHud
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?CursorRate@RadarClass@@1MB:DWORD		; RadarClass::CursorRate
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	?g_bMLU@@3_NA:BYTE				; g_bMLU
EXTRN	?g_fCursorSpeed@@3MA:DWORD			; g_fCursorSpeed
EXTRN	?g_bAGRadarFixes@@3_NA:BYTE			; g_bAGRadarFixes
EXTRN	?g_bAntElevKnobFix@@3_NA:BYTE			; g_bAntElevKnobFix
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_GM_OVERSCAN_RNG DD 01H DUP (?)
_GM_OVERSCAN_H DD 01H DUP (?)
_GM_OVERSCAN_V DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?test@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA
_BSS	SEGMENT
?test@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA DD 01H DUP (?) ; `RadarDopplerClass::UpdateState'::`13'::test
_BSS	ENDS
;	COMDAT ?testa@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA
_BSS	SEGMENT
?testa@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA DD 01H DUP (?) ; `RadarDopplerClass::UpdateState'::`13'::testa
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@bf860a91
CONST	SEGMENT
__real@bf860a91 DD 0bf860a91r			; -1.0472
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf666666
CONST	SEGMENT
__real@bf666666 DD 0bf666666r			; -0.9
CONST	ENDS
;	COMDAT __real@bdb2b8c1
CONST	SEGMENT
__real@bdb2b8c1 DD 0bdb2b8c1r			; -0.0872665
CONST	ENDS
;	COMDAT __real@bd56774e
CONST	SEGMENT
__real@bd56774e DD 0bd56774er			; -0.0523599
CONST	ENDS
;	COMDAT __real@48ed5a1c
CONST	SEGMENT
__real@48ed5a1c DD 048ed5a1cr			; 486097
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40d00000
CONST	SEGMENT
__real@40d00000 DD 040d00000r			; 6.5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400ccccd
CONST	SEGMENT
__real@400ccccd DD 0400ccccdr			; 2.2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ffeb852
CONST	SEGMENT
__real@3ffeb852 DD 03ffeb852r			; 1.99
CONST	ENDS
;	COMDAT __real@3fba2e8c
CONST	SEGMENT
__real@3fba2e8c DD 03fba2e8cr			; 1.45455
CONST	ENDS
;	COMDAT __real@3f866666
CONST	SEGMENT
__real@3f866666 DD 03f866666r			; 1.05
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecd87ab
CONST	SEGMENT
__real@3ecd87ab DD 03ecd87abr			; 0.401426
CONST	ENDS
;	COMDAT __real@3e860a91
CONST	SEGMENT
__real@3e860a91 DD 03e860a91r			; 0.261799
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_GM_OVERSCAN_RNG$initializer$ DD FLAT:??__EGM_OVERSCAN_RNG@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_GM_OVERSCAN_H$initializer$ DD FLAT:??__EGM_OVERSCAN_H@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_GM_OVERSCAN_V$initializer$ DD FLAT:??__EGM_OVERSCAN_V@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\gmcomposit.h
;	COMDAT ??__EGM_OVERSCAN_V@@YAXXZ
text$yc	SEGMENT
??__EGM_OVERSCAN_V@@YAXXZ PROC				; `dynamic initializer for 'GM_OVERSCAN_V'', COMDAT

; 21   : static const float	GM_OVERSCAN_V		= 1.0f + GM_OVERSCAN + GM_OVERSCAN;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _GM_OVERSCAN
	addss	xmm0, DWORD PTR _GM_OVERSCAN
	movss	DWORD PTR _GM_OVERSCAN_V, xmm0
	pop	ebp
	ret	0
??__EGM_OVERSCAN_V@@YAXXZ ENDP				; `dynamic initializer for 'GM_OVERSCAN_V''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\gmcomposit.h
;	COMDAT ??__EGM_OVERSCAN_H@@YAXXZ
text$yc	SEGMENT
??__EGM_OVERSCAN_H@@YAXXZ PROC				; `dynamic initializer for 'GM_OVERSCAN_H'', COMDAT

; 20   : static const float	GM_OVERSCAN_H		= 1.0f + GM_OVERSCAN;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _GM_OVERSCAN
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _GM_OVERSCAN_H, xmm0
	pop	ebp
	ret	0
??__EGM_OVERSCAN_H@@YAXXZ ENDP				; `dynamic initializer for 'GM_OVERSCAN_H''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\gmcomposit.h
;	COMDAT ??__EGM_OVERSCAN_RNG@@YAXXZ
text$yc	SEGMENT
??__EGM_OVERSCAN_RNG@@YAXXZ PROC			; `dynamic initializer for 'GM_OVERSCAN_RNG'', COMDAT

; 19   : static const float	GM_OVERSCAN_RNG		= 1.0f + GM_OVERSCAN;

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _GM_OVERSCAN
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _GM_OVERSCAN_RNG, xmm0
	pop	ebp
	ret	0
??__EGM_OVERSCAN_RNG@@YAXXZ ENDP			; `dynamic initializer for 'GM_OVERSCAN_RNG''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ PROC ; FireControlComputer::GetSubMode, COMDAT
; _this$ = ecx

; 281  : 	FCCSubMode GetSubMode (void) {return (subMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ENDP ; FireControlComputer::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsNavMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsNavMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsNavMasterMode, COMDAT
; _this$ = ecx

; 280  : 	int IsNavMasterMode() { return GetMainMasterMode() == MM_NAV; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 2
	jne	SHORT $LN3@IsNavMaste
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsNavMaste
$LN3@IsNavMaste:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsNavMaste:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNavMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsNavMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsAAMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsAAMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsAAMasterMode, COMDAT
; _this$ = ecx

; 279  : 	int IsAAMasterMode() { return GetMainMasterMode() == MM_AA; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	cmp	eax, 1
	jne	SHORT $LN3@IsAAMaster
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAAMaster
$LN3@IsAAMaster:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAAMaster:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAAMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsAAMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsAGMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsAGMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsAGMasterMode, COMDAT
; _this$ = ecx

; 278  : 	int IsAGMasterMode() { return GetMainMasterMode() == MM_AG; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	test	eax, eax
	jne	SHORT $LN3@IsAGMaster
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAGMaster
$LN3@IsAGMaster:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAGMaster:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAGMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsAGMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetLastMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetLastMasterMode, COMDAT
; _this$ = ecx

; 105  : 	FCCMasterMode GetLastMasterMode()	{return lastMasterMode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+72]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetLastMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ PROC ; RadarDopplerClass::GMSPWaypt, COMDAT
; _this$ = ecx

; 424  : 	WayPointClass* GMSPWaypt() { return GMSPPseudoWaypt; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+536]
	mov	esp, ebp
	pop	ebp
	ret	0
?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ENDP ; RadarDopplerClass::GMSPWaypt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
tv289 = -24						; size = 4
_az$ = -20						; size = 4
tv215 = -16						; size = 4
_el$ = -12						; size = 4
_angleDelta$ = -8					; size = 4
_this$ = -4						; size = 4
?CalcSAMAzLimit@RadarDopplerClass@@IAEXXZ PROC		; RadarDopplerClass::CalcSAMAzLimit
; _this$ = ecx

; 1025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1026 : float angleDelta;
; 1027 : float az, el;
; 1028 : 
; 1029 : 	az = TargetAz (platform, lockedTarget->BaseData()->XPos(), lockedTarget->BaseData()->YPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?TargetAz@@YAMPAVFalconEntity@@MM@Z	; TargetAz
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _az$[ebp]

; 1030 : 	el = TargetEl (platform, lockedTarget->BaseData()->XPos(), lockedTarget->BaseData()->YPos(),
; 1031 :       lockedTarget->BaseData()->ZPos());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?TargetEl@@YAMPAVFalconEntity@@MMM@Z	; TargetEl
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _el$[ebp]

; 1032 : 
; 1033 :    angleDelta = (float)fabs (az - seekerAzCenter);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	subss	xmm0, DWORD PTR [eax+56]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR _angleDelta$[ebp]

; 1034 :    angleDelta = max (angleDelta, (float)fabs(el - seekerElCenter));

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	subss	xmm0, DWORD PTR [ecx+60]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv289[ebp]
	movss	xmm0, DWORD PTR _angleDelta$[ebp]
	comiss	xmm0, DWORD PTR tv289[ebp]
	jbe	SHORT $LN4@CalcSAMAzL
	movss	xmm0, DWORD PTR _angleDelta$[ebp]
	movss	DWORD PTR tv215[ebp], xmm0
	jmp	SHORT $LN5@CalcSAMAzL
$LN4@CalcSAMAzL:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	subss	xmm0, DWORD PTR [edx+60]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv215[ebp]
$LN5@CalcSAMAzL:
	movss	xmm0, DWORD PTR tv215[ebp]
	movss	DWORD PTR _angleDelta$[ebp], xmm0

; 1035 : 
; 1036 :    azScan = ((SAM_PATTERN_TIME - 1.0F)*scanRate - 2.2F*angleDelta - 3.0F * bars * barWidth) / (bars + 1);

	movss	xmm0, DWORD PTR _SAM_PATTERN_TIME
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+256]
	movss	xmm1, DWORD PTR __real@400ccccd
	mulss	xmm1, DWORD PTR _angleDelta$[ebp]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+188]
	mulss	xmm1, DWORD PTR __real@40400000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [edx+248]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	add	ecx, 1
	cvtsi2ss xmm1, ecx
	divss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm0

; 1037 :    if (azScan < 0.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+204]
	jbe	SHORT $LN1@CalcSAMAzL

; 1038 :       azScan = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+204], xmm0
$LN1@CalcSAMAzL:

; 1039 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcSAMAzLimit@RadarDopplerClass@@IAEXXZ ENDP		; RadarDopplerClass::CalcSAMAzLimit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetScan@RadarDopplerClass@@IAEXXZ PROC			; RadarDopplerClass::SetScan
; _this$ = ecx

; 1002 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1003 : 	if (bars > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+188], 0
	jle	SHORT $LN4@SetScan

; 1004 : 		elScan = (bars - 1) * barWidth/1.99f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	sub	edx, 1
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+248]
	divss	xmm0, DWORD PTR __real@3ffeb852
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+208], xmm0
$LN4@SetScan:

; 1005 : 	tbarWidth = barWidth ;//me123* 2.0F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	mov	DWORD PTR [edx+268], ecx

; 1006 : 	
; 1007 : 	// In SAM we have a fixed pattern time, and change volume to maintain
; 1008 : 	if (mode == SAM)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 10			; 0000000aH
	jne	SHORT $LN3@SetScan

; 1009 : 	{
; 1010 : 		patternTime = FloatToInt32(SAM_PATTERN_TIME * SEC_TO_MSEC);

	movss	xmm0, DWORD PTR _SAM_PATTERN_TIME
	mulss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 1011 : 	}
; 1012 : 	else

	jmp	$LN2@SetScan
$LN3@SetScan:

; 1013 : 	{
; 1014 : 		patternTime = FloatToInt32((2.2F * abs(bars) * (azScan + beamWidth + barWidth * 2.0F) /
; 1015 : 			scanRate * SEC_TO_MSEC) * 1.05F + 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	push	eax
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@400ccccd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+204]
	addss	xmm1, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm2, DWORD PTR [eax+248]
	mulss	xmm2, DWORD PTR __real@40000000
	addss	xmm1, xmm2
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+256]
	mulss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@3f866666
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], eax
$LN2@SetScan:

; 1016 : 	}
; 1017 : 	//   ClearFlagBit(STTingTarget);
; 1018 : 	platform->SetRdrCycleTime ((float)patternTime / SEC_TO_MSEC);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+300]
	divss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 1019 : 	
; 1020 : 	if (mode != SAM && mode != STT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 10			; 0000000aH
	je	SHORT $LN1@SetScan
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 13			; 0000000dH
	je	SHORT $LN1@SetScan

; 1021 : 		displayAzScan = azScan;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR [ecx+216], eax
$LN1@SetScan:

; 1022 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetScan@RadarDopplerClass@@IAEXXZ ENDP			; RadarDopplerClass::SetScan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
tv576 = -60						; size = 4
tv572 = -56						; size = 4
tv548 = -52						; size = 4
tv455 = -48						; size = 4
tv451 = -44						; size = 4
tv427 = -40						; size = 4
tv311 = -36						; size = 4
tv307 = -32						; size = 4
tv283 = -28						; size = 4
tv209 = -24						; size = 4
_maxIdx$ = -20						; size = 4
_playerAC$1 = -16					; size = 4
_wasGround$ = -12					; size = 4
_FCC$ = -8						; size = 4
_this$ = -4						; size = 4
_newMode$ = 8						; size = 4
?ChangeMode@RadarDopplerClass@@IAEXH@Z PROC		; RadarDopplerClass::ChangeMode
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 	int maxIdx;
; 35   : 	int wasGround = FALSE;

	mov	DWORD PTR _wasGround$[ebp], 0

; 36   : 	
; 37   : 	/*--------------------------------*/
; 38   : 	/* Save the old mode just in case */
; 39   : 	/*--------------------------------*/
; 40   : 	
; 41   : 	//prevMode = mode;
; 42   : 	
; 43   : 	//static float oldseekerElCenter =0.0f;
; 44   : 	
; 45   : 	if (prevMode == SAM || prevMode == TWS
; 46   : 		|| prevMode == RWS || prevMode == LRS|| prevMode == VS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 10			; 0000000aH
	je	SHORT $LN89@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 4
	je	SHORT $LN89@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 2
	je	SHORT $LN89@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 3
	je	SHORT $LN89@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 5
	jne	SHORT $LN90@ChangeMode
$LN89@ChangeMode:

; 47   : 		oldseekerElCenter = seekerElCenter;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+64], ecx
$LN90@ChangeMode:

; 48   : 	
; 49   : 	if (prevMode == GM || prevMode == GMT || prevMode == SEA)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 14			; 0000000eH
	je	SHORT $LN87@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 16			; 00000010H
	je	SHORT $LN87@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 17			; 00000011H
	jne	$LN85@ChangeMode
$LN87@ChangeMode:

; 50   : 	{
; 51   : 		DropGMTrack();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropGMTrack@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::DropGMTrack

; 52   : 		wasGround = TRUE;

	mov	DWORD PTR _wasGround$[ebp], 1

; 53   : 		seekerElCenter = oldseekerElCenter;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edx+60], ecx

; 54   : 
; 55   : 		// MD -- 20040228: clear and GM SP related pseudo waypoint and revert to STPT nav
; 56   : 		if (IsSet(SP_STAB))

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN86@ChangeMode

; 57   : 			ClearFlagBit(SP_STAB);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN86@ChangeMode:

; 58   : 		if (GMSPWaypt())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GMSPWaypt@RadarDopplerClass@@QAEPAVWayPointClass@@XZ ; RadarDopplerClass::GMSPWaypt
	test	eax, eax
	je	SHORT $LN85@ChangeMode

; 59   : 		{
; 60   : 			// RV - Biker - Should fix CTD 
; 61   : 			// if (SimDriver.GetPlayerAircraft())
; 62   : 			//	SimDriver.GetPlayerAircraft()->FCC->SetStptMode(FireControlComputer::FCCWaypoint);
; 63   : 			//	SimDriver.GetPlayerAircraft()->FCC->waypointStepCmd = 127;
; 64   : 			AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$1[ebp], eax

; 65   : 			if (playerAC) {

	cmp	DWORD PTR _playerAC$1[ebp], 0
	je	SHORT $LN84@ChangeMode

; 66   : 				playerAC->FCC->SetStptMode(FireControlComputer::FCCWaypoint);

	push	0
	mov	edx, DWORD PTR _playerAC$1[ebp]
	mov	ecx, DWORD PTR [edx+936]
	call	?SetStptMode@FireControlComputer@@QAEXW4FCCStptMode@1@@Z ; FireControlComputer::SetStptMode

; 67   : 				playerAC->FCC->waypointStepCmd = 127;

	mov	eax, DWORD PTR _playerAC$1[ebp]
	mov	ecx, DWORD PTR [eax+936]
	mov	BYTE PTR [ecx+194], 127			; 0000007fH
$LN84@ChangeMode:

; 68   : 			}
; 69   : 			SetGMSPWaypt(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMSPWaypt@RadarDopplerClass@@QAEXPAVWayPointClass@@@Z ; RadarDopplerClass::SetGMSPWaypt
$LN85@ChangeMode:

; 70   : 		}
; 71   : 	}
; 72   : 	
; 73   : 	// MD -- 20040118: clean up on mode change from TWS
; 74   : 	// sfr: removes JB hack. Seems to cure memory corruption somehow...
; 75   : #define NEW_TWS_CHECK 1
; 76   : #if NEW_TWS_CHECK
; 77   : 	if (newMode != TWS && TWSTrackDirectory){

	cmp	DWORD PTR _newMode$[ebp], 4
	je	SHORT $LN83@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+532], 0
	je	SHORT $LN83@ChangeMode

; 78   : 		TWSTrackDirectory = TWSTrackDirectory->Purge();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	call	?Purge@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ ; RadarDopplerClass::TWSTrackList::Purge
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+532], eax
$LN83@ChangeMode:

; 79   : 	}
; 80   : #else
; 81   : 	if (newMode != TWS && !F4IsBadReadPtr(TWSTrackDirectory, sizeof(RadarDopplerClass::TWSTrackList))){
; 82   : 		TWSTrackDirectory = TWSTrackDirectory->Purge();
; 83   : 	}
; 84   : #endif
; 85   : 
; 86   : 	// Drop SAM target on mode switch (except when bugging)
; 87   : 	if (mode == SAM && newMode != STT){
; 88   : 		//ClearSensorTarget(); me123 status ok no keep the target on mode switch
; 89   : 	}
; 90   : 	
; 91   : 	isOn = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 1

; 92   : 	if (TheHud){

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN81@ChangeMode

; 93   : 		TheHud->HudData.Clear(HudDataType::RadarSlew);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Clear@HudDataType@@QAEXH@Z		; HudDataType::Clear

; 94   : 		TheHud->HudData.Clear(HudDataType::RadarBoresight);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Clear@HudDataType@@QAEXH@Z		; HudDataType::Clear

; 95   : 		TheHud->HudData.Clear(HudDataType::RadarVertical);

	push	4
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Clear@HudDataType@@QAEXH@Z		; HudDataType::Clear
$LN81@ChangeMode:

; 96   : 	}
; 97   : 	
; 98   : 	/*-------------------------------------*/
; 99   : 	/* Set the parameters for the new mode */
; 100  : 	/*-------------------------------------*/
; 101  : 	
; 102  :    	switch (newMode)

	mov	ecx, DWORD PTR _newMode$[ebp]
	mov	DWORD PTR tv209[ebp], ecx
	cmp	DWORD PTR tv209[ebp], 20		; 00000014H
	ja	$LN79@ChangeMode
	mov	edx, DWORD PTR tv209[ebp]
	jmp	DWORD PTR $LN111@ChangeMode[edx*4]
$LN78@ChangeMode:

; 103  : 	{
; 104  : 	case RWS:   // Range while search
; 105  : 	case LRS:
; 106  : 		prevMode = mode = (RadarMode)newMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newMode$[ebp]
	mov	DWORD PTR [eax+184], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newMode$[ebp]
	mov	DWORD PTR [edx+88], eax

; 107  : 		fovStepCmd = 0;	//MI

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 108  : 		SetFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 109  : 		beamWidth = radarData->BeamHalfAngle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+260], edx

; 110  : 		displayRange = 20.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [eax+212], xmm0

; 111  : 		curRangeIdx = airRangeIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+408]
	mov	DWORD PTR [ecx+388], eax

; 112  : 		displayRange = rangeScales[curRangeIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+312]
	mov	DWORD PTR [eax+212], edx

; 113  : 		curAzIdx = rwsAzIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+412]
	mov	DWORD PTR [eax+400], edx

; 114  : 		azScan = rwsAzs[curAzIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+332]
	mov	DWORD PTR [edx+204], ecx

; 115  : 		curBarIdx = rwsBarIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+436]
	mov	DWORD PTR [edx+392], ecx

; 116  : 		bars = rwsBars[curBarIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+364]
	mov	DWORD PTR [ecx+188], eax

; 117  : 		barWidth = APG68_BAR_WIDTH;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [ecx+248], xmm0

; 118  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 119  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 120  : 		scanDir  = ScanFwd;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+252], xmm0

; 121  : 		
; 122  : 		if (!g_bAntElevKnobFix)

	movzx	eax, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	eax, eax
	jne	$LN77@ChangeMode

; 123  : 			//me123 set the old el center
; 124  : 			seekerElCenter = min ( max (oldseekerElCenter, -MAX_ANT_EL + elScan), MAX_ANT_EL - elScan);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [edx+208]
	comiss	xmm0, xmm1
	jbe	SHORT $LN93@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	movss	DWORD PTR tv283[ebp], xmm0
	jmp	SHORT $LN94@ChangeMode
$LN93@ChangeMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [ecx+208]
	movss	DWORD PTR tv283[ebp], xmm0
$LN94@ChangeMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+208]
	comiss	xmm0, DWORD PTR tv283[ebp]
	jbe	SHORT $LN97@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [ecx+208]
	comiss	xmm0, xmm1
	jbe	SHORT $LN95@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	movss	DWORD PTR tv307[ebp], xmm0
	jmp	SHORT $LN96@ChangeMode
$LN95@ChangeMode:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [eax+208]
	movss	DWORD PTR tv307[ebp], xmm0
$LN96@ChangeMode:
	movss	xmm0, DWORD PTR tv307[ebp]
	movss	DWORD PTR tv311[ebp], xmm0
	jmp	SHORT $LN98@ChangeMode
$LN97@ChangeMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+208]
	movss	DWORD PTR tv311[ebp], xmm0
$LN98@ChangeMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv311[ebp]
	movss	DWORD PTR [edx+60], xmm0

; 125  : 		else

	jmp	SHORT $LN76@ChangeMode
$LN77@ChangeMode:

; 126  : 			seekerElCenter = AntElevKnob();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+60]
$LN76@ChangeMode:

; 127  : 
; 128  : 		SetEmitting (TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 129  : 		if (wasGround)

	cmp	DWORD PTR _wasGround$[ebp], 0
	je	SHORT $LN75@ChangeMode

; 130  : 		{
; 131  :             cursorX = cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+220], xmm0
$LN75@ChangeMode:

; 132  : 		}
; 133  : 		
; 134  : 		// Go to sam if there is a lock
; 135  : 		//MI added check for RWS mode. If this isn't here, we never make it out of RWS/SAM
; 136  : 		//mode. This makes sure that if we switch to RWS, we go to SAM, which is right I think.
; 137  : 		if (lockedTarget  && (mode == RWS || mode == LRS))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN74@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 2
	je	SHORT $LN73@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 3
	jne	SHORT $LN74@ChangeMode
$LN73@ChangeMode:

; 138  : 		{
; 139  :             ChangeMode (SAM);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode
$LN74@ChangeMode:

; 140  : 		}
; 141  : 		break;

	jmp	$LN79@ChangeMode
$LN72@ChangeMode:

; 142  : 		
; 143  : 	case TWS:  // Track while scan
; 144  : 		prevMode = mode = TWS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 4

; 145  : 		fovStepCmd = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 146  : 		
; 147  : 		SetFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 148  : 		curRangeIdx = airRangeIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+408]
	mov	DWORD PTR [edx+388], ecx

; 149  : 		displayRange = rangeScales[curRangeIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+312]
	mov	DWORD PTR [ecx+212], eax

; 150  : 
; 151  : 		// MD -- 20040124: updated TWS mode gets its own specific scan patterns
; 152  : 		curAzIdx = twsAzIdx = lastTwsAzIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+420]
	mov	DWORD PTR [ecx+416], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+416]
	mov	DWORD PTR [ecx+400], eax

; 153  : 		azScan = twsAzs[curAzIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+344]
	mov	DWORD PTR [eax+204], edx

; 154  : 		displayAzScan = twsAzs[curAzIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+344]
	mov	DWORD PTR [edx+216], ecx

; 155  : 
; 156  : 		curBarIdx = twsBarIdx = lastTwsBarIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+440], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+440]
	mov	DWORD PTR [edx+392], ecx

; 157  : 		bars = twsBars[curBarIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+376]
	mov	DWORD PTR [ecx+188], eax

; 158  : 
; 159  : 		beamWidth = radarData->BeamHalfAngle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+260], ecx

; 160  : 		// 2001-02-21 MODIFIED BY S.G. IN TWS, APG68_BAR_WIDTH IS 3.2 (2.2 * 1.4545455)
; 161  : 		//			barWidth = APG68_BAR_WIDTH * 1.3f;
; 162  : 		barWidth = APG68_BAR_WIDTH * 1.4545455f;

	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	mulss	xmm0, DWORD PTR __real@3fba2e8c
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+248], xmm0

; 163  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 164  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 165  : 		scanDir  = ScanFwd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+252], xmm0

; 166  : 
; 167  : 		if (!g_bAntElevKnobFix)

	movzx	ecx, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	ecx, ecx
	jne	$LN71@ChangeMode

; 168  : 			//me123 set the old el center
; 169  : 			seekerElCenter = min ( max (oldseekerElCenter, -MAX_ANT_EL + elScan), MAX_ANT_EL - elScan);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [eax+208]
	comiss	xmm0, xmm1
	jbe	SHORT $LN99@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	movss	DWORD PTR tv427[ebp], xmm0
	jmp	SHORT $LN100@ChangeMode
$LN99@ChangeMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+208]
	movss	DWORD PTR tv427[ebp], xmm0
$LN100@ChangeMode:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+208]
	comiss	xmm0, DWORD PTR tv427[ebp]
	jbe	SHORT $LN103@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [edx+208]
	comiss	xmm0, xmm1
	jbe	SHORT $LN101@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	movss	DWORD PTR tv451[ebp], xmm0
	jmp	SHORT $LN102@ChangeMode
$LN101@ChangeMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [ecx+208]
	movss	DWORD PTR tv451[ebp], xmm0
$LN102@ChangeMode:
	movss	xmm0, DWORD PTR tv451[ebp]
	movss	DWORD PTR tv455[ebp], xmm0
	jmp	SHORT $LN104@ChangeMode
$LN103@ChangeMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+208]
	movss	DWORD PTR tv455[ebp], xmm0
$LN104@ChangeMode:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv455[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 170  : 		else

	jmp	SHORT $LN69@ChangeMode
$LN71@ChangeMode:

; 171  : 			if (!lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN69@ChangeMode

; 172  : 				seekerElCenter = AntElevKnob();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+60]
$LN69@ChangeMode:

; 173  : 
; 174  : 		SetEmitting (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 175  : 		if (wasGround)

	cmp	DWORD PTR _wasGround$[ebp], 0
	je	SHORT $LN68@ChangeMode

; 176  : 		{
; 177  :             cursorX = cursorY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+224], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+220], xmm0
$LN68@ChangeMode:

; 178  : 		}
; 179  : 
; 180  : 		break;

	jmp	$LN79@ChangeMode
$LN67@ChangeMode:

; 181  : 		
; 182  : 	case VS:   // Velocity search
; 183  : 		mode = VS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 5

; 184  : 		displayRange = velScales[vsVelIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+396]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+356]
	mov	DWORD PTR [eax+212], edx

; 185  : 		curAzIdx = vsAzIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+424]
	mov	DWORD PTR [eax+400], edx

; 186  : 		curBarIdx = vsBarIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+452]
	mov	DWORD PTR [eax+392], edx

; 187  : 		SetFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 188  : 		beamWidth = radarData->BeamHalfAngle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+260], eax

; 189  : 		azScan = rwsAzs[curAzIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+332]
	mov	DWORD PTR [eax+204], edx

; 190  : 		curBarIdx = rwsBarIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+436]
	mov	DWORD PTR [eax+392], edx

; 191  : 		bars = rwsBars[curBarIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+364]
	mov	DWORD PTR [edx+188], ecx

; 192  : 		barWidth = APG68_BAR_WIDTH;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [edx+248], xmm0

; 193  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 194  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 195  : 		scanDir  = ScanFwd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+252], xmm0

; 196  : 
; 197  : 		if (!g_bAntElevKnobFix)

	movzx	ecx, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	ecx, ecx
	jne	$LN66@ChangeMode

; 198  : 			//me123 set the old el center
; 199  : 			seekerElCenter = min ( max (oldseekerElCenter, -MAX_ANT_EL + elScan), MAX_ANT_EL - elScan);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [eax+208]
	comiss	xmm0, xmm1
	jbe	SHORT $LN105@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	movss	DWORD PTR tv548[ebp], xmm0
	jmp	SHORT $LN106@ChangeMode
$LN105@ChangeMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+208]
	movss	DWORD PTR tv548[ebp], xmm0
$LN106@ChangeMode:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+208]
	comiss	xmm0, DWORD PTR tv548[ebp]
	jbe	SHORT $LN109@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [edx+208]
	comiss	xmm0, xmm1
	jbe	SHORT $LN107@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+64]
	movss	DWORD PTR tv572[ebp], xmm0
	jmp	SHORT $LN108@ChangeMode
$LN107@ChangeMode:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [ecx+208]
	movss	DWORD PTR tv572[ebp], xmm0
$LN108@ChangeMode:
	movss	xmm0, DWORD PTR tv572[ebp]
	movss	DWORD PTR tv576[ebp], xmm0
	jmp	SHORT $LN110@ChangeMode
$LN109@ChangeMode:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+208]
	movss	DWORD PTR tv576[ebp], xmm0
$LN110@ChangeMode:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv576[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 200  : 		else

	jmp	SHORT $LN65@ChangeMode
$LN66@ChangeMode:

; 201  : 			seekerElCenter = AntElevKnob();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+60]
$LN65@ChangeMode:

; 202  : 
; 203  : 		SetEmitting (TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 204  : 		if (wasGround)

	cmp	DWORD PTR _wasGround$[ebp], 0
	je	SHORT $LN64@ChangeMode

; 205  : 		{
; 206  :             cursorX = cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+220], xmm0
$LN64@ChangeMode:

; 207  : 		}
; 208  : 		break;

	jmp	$LN79@ChangeMode
$LN63@ChangeMode:

; 209  : 		
; 210  : 	case ACM_30x20:  // Auto Aquisition - 30x20 FOV
; 211  : 		mode = ACM_30x20;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], 6

; 212  : 		seekerAzCenter = 0.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+56], xmm0

; 213  : 		seekerElCenter = -5.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bdb2b8c1
	movss	DWORD PTR [ecx+60], xmm0

; 214  : 		ClearFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 215  : 		beamWidth = radarData->BeamHalfAngle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+260], edx

; 216  : 		azScan = 15.0F * DTR - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e860a91
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+204], xmm0

; 217  : 		elScan = 10.0F * DTR - beamWidth;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	subss	xmm0, DWORD PTR [edx+260]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+208], xmm0

; 218  : 		displayRange = 10.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+212], xmm0

; 219  : 		bars = 4;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], 4

; 220  : 		barWidth = APG68_BAR_WIDTH;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [eax+248], xmm0

; 221  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 222  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 223  : 		scanDir  = ScanFwd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+252], xmm0

; 224  : 		// me123 status ok. We don't always want to stop emitting when we change to an acm mode from a non acm radar mode
; 225  : 		// we just wanna transfer to acm and get the symbolgy for that. 
; 226  : 		//MI but that's how it works in the Block 50 Viper, so let's change it back
; 227  : 		if (prevMode == ACM_30x20 || prevMode == ACM_BORE || prevMode == ACM_10x60 || prevMode == ACM_SLEW || lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 6
	je	SHORT $LN61@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 8
	je	SHORT $LN61@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 9
	je	SHORT $LN61@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 7
	je	SHORT $LN61@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN62@ChangeMode
$LN61@ChangeMode:

; 228  :             SetEmitting (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 229  : 		else

	jmp	SHORT $LN60@ChangeMode
$LN62@ChangeMode:

; 230  :             SetEmitting (FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN60@ChangeMode:

; 231  : 		
; 232  : 		prevMode = mode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+88], eax

; 233  : 		break;

	jmp	$LN79@ChangeMode
$LN59@ChangeMode:

; 234  : 		
; 235  : 	case ACM_BORE: // Auto Aquisition - Boresight
; 236  : 		mode = ACM_BORE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], 8

; 237  : 		//        ClearSensorTarget(); me123 status ok. don't ever drop the target just becourse we are enterign acm bore. it probaly not possible enyway to enter bore with a lock.
; 238  : 		ClearFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 239  : 		beamWidth = radarData->BeamHalfAngle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+260], edx

; 240  : 		azScan = 0.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+204], xmm0

; 241  : 		displayRange = 10.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [ecx+212], xmm0

; 242  : 		elScan = 0.0F * DTR;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+208], xmm0

; 243  : 		seekerAzCenter = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+56], xmm0

; 244  : 		seekerElCenter = -3.0F*DTR;//me123 from 0.00.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bd56774e
	movss	DWORD PTR [ecx+60], xmm0

; 245  : 		beamAz = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+196], xmm0

; 246  : 		beamEl = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+200], xmm0

; 247  : 		bars = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+188], 1

; 248  : 		barWidth = APG68_BAR_WIDTH;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [edx+248], xmm0

; 249  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 250  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 251  : 		scanDir  = ScanNone;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+252], xmm0

; 252  : 		if (TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN58@ChangeMode

; 253  : 		{
; 254  :             TheHud->HudData.Set(HudDataType::RadarBoresight);

	push	1
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Set@HudDataType@@QAEXH@Z		; HudDataType::Set
$LN58@ChangeMode:

; 255  : 		}
; 256  : 		if (prevMode == ACM_30x20 || prevMode == ACM_BORE || prevMode == ACM_10x60 || prevMode == ACM_SLEW || lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 6
	je	SHORT $LN56@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 8
	je	SHORT $LN56@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 9
	je	SHORT $LN56@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 7
	je	SHORT $LN56@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN57@ChangeMode
$LN56@ChangeMode:

; 257  :             SetEmitting (TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 258  : 		else

	jmp	SHORT $LN55@ChangeMode
$LN57@ChangeMode:

; 259  :             SetEmitting (FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN55@ChangeMode:

; 260  : 		
; 261  : 		prevMode = ACM_BORE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 8

; 262  : 		break;

	jmp	$LN79@ChangeMode
$LN54@ChangeMode:

; 263  : 		
; 264  : 	case ACM_10x60: // Auto Aquisition - Vertical Search
; 265  : 		mode = ACM_10x60;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], 9

; 266  : 		//        ClearSensorTarget(); me123 status ok. don't ever drop the target just becourse we are enterign acm
; 267  : 		seekerAzCenter = 0.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+56], xmm0

; 268  : 		seekerElCenter = 23.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3ecd87ab
	movss	DWORD PTR [ecx+60], xmm0

; 269  : 		ClearFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 270  : 		beamWidth = radarData->BeamHalfAngle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+260], edx

; 271  : 		displayRange = 10.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+212], xmm0

; 272  : 		elScan = 30.0F * DTR - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f060a91
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+208], xmm0

; 273  : 		azScan = 5.0F * DTR - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3db2b8c1
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+204], xmm0

; 274  : 		bars = -4;  //JPG 28 Apr 04 - was -3  ????

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], -4			; fffffffcH

; 275  : 		barWidth = APG68_BAR_WIDTH;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [eax+248], xmm0

; 276  : 		SetFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 277  : 		ClearFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 278  : 		scanDir  = ScanFwd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+252], xmm0

; 279  : 		if (TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN53@ChangeMode

; 280  : 		{
; 281  :             TheHud->HudData.Set(HudDataType::RadarVertical);

	push	4
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Set@HudDataType@@QAEXH@Z		; HudDataType::Set
$LN53@ChangeMode:

; 282  : 		}
; 283  : 		if (prevMode == ACM_30x20 || prevMode == ACM_BORE || prevMode == ACM_10x60 || prevMode == ACM_SLEW || lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 6
	je	SHORT $LN51@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 8
	je	SHORT $LN51@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 9
	je	SHORT $LN51@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 7
	je	SHORT $LN51@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN52@ChangeMode
$LN51@ChangeMode:

; 284  :             SetEmitting (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 285  : 		else

	jmp	SHORT $LN50@ChangeMode
$LN52@ChangeMode:

; 286  :             SetEmitting (FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN50@ChangeMode:

; 287  : 		
; 288  : 		prevMode = mode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+88], eax

; 289  : 		break;

	jmp	$LN79@ChangeMode
$LN49@ChangeMode:

; 290  : 		
; 291  : 	case ACM_SLEW:  // Auto Aquisition - Slewable, 20x60 FOV
; 292  : 		mode = ACM_SLEW;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], 7

; 293  : 		//        ClearSensorTarget(); me123 status ok. don't ever drop the target just becourse we are enterign acm
; 294  : 		SetFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 295  : 		beamWidth = radarData->BeamHalfAngle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+260], edx

; 296  : 		displayRange = 10.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+212], xmm0

; 297  : 		azScan = 30.0F * DTR - beamWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f060a91
	subss	xmm0, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm0

; 298  : 		elScan = 10.0F * DTR - beamWidth;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3e32b8c1
	subss	xmm0, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+208], xmm0

; 299  : 		bars = 4;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], 4

; 300  : 		barWidth = APG68_BAR_WIDTH;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [eax+248], xmm0

; 301  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 302  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 303  : 		scanDir  = ScanFwd;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+252], xmm0

; 304  : 		if (TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN48@ChangeMode

; 305  : 		{
; 306  :             TheHud->HudData.Set(HudDataType::RadarSlew);

	push	2
	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	add	ecx, 4972				; 0000136cH
	call	?Set@HudDataType@@QAEXH@Z		; HudDataType::Set
$LN48@ChangeMode:

; 307  : 		}
; 308  : 		if (prevMode == ACM_30x20 || prevMode == ACM_BORE || prevMode == ACM_10x60 || prevMode == ACM_SLEW || lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 6
	je	SHORT $LN46@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 8
	je	SHORT $LN46@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 9
	je	SHORT $LN46@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 7
	je	SHORT $LN46@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN47@ChangeMode
$LN46@ChangeMode:

; 309  :             SetEmitting (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 310  : 		else

	jmp	SHORT $LN45@ChangeMode
$LN47@ChangeMode:

; 311  :             SetEmitting (FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
$LN45@ChangeMode:

; 312  : 		if (wasGround)

	cmp	DWORD PTR _wasGround$[ebp], 0
	je	SHORT $LN44@ChangeMode

; 313  : 		{
; 314  :             cursorX = cursorY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+224], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+220], xmm0
$LN44@ChangeMode:

; 315  : 		}
; 316  : 		
; 317  : 		prevMode = mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+88], edx

; 318  : 		break;

	jmp	$LN79@ChangeMode
$LN43@ChangeMode:

; 319  : 		
; 320  : 	case STT:
; 321  : 		prevMode = mode = STT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 13			; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 13			; 0000000dH

; 322  : 		ClearFlagBit(SpaceStabalized);

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 323  : 		beamWidth = radarData->BeamHalfAngle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+260], edx

; 324  : 		azScan = 0.0F * DTR;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+204], xmm0

; 325  : 		bars = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+188], 1

; 326  : 		barWidth = APG68_BAR_WIDTH;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [edx+248], xmm0

; 327  : 		ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 328  : 		SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 329  : 		scanDir  = ScanNone;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+252], xmm0

; 330  : 		SetEmitting (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 331  : 		break;

	jmp	$LN79@ChangeMode
$LN42@ChangeMode:

; 332  : 		
; 333  : 	case SAM:
; 334  : 		//MI
; 335  : 		if(mode == RWS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 2
	jne	SHORT $LN41@ChangeMode

; 336  : 			prevMode = RWS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 2
	jmp	SHORT $LN39@ChangeMode
$LN41@ChangeMode:

; 337  : 		else if(mode == LRS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 3
	jne	SHORT $LN39@ChangeMode

; 338  : 			prevMode = LRS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 3
$LN39@ChangeMode:

; 339  : 		mode = SAM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], 10			; 0000000aH

; 340  : 		fovStepCmd = 0;	//MI

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 341  : 		subMode = SAM_AUTO_MODE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+504], 11			; 0000000bH

; 342  : 		displayAzScan = rwsAzs[curAzIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+332]
	mov	DWORD PTR [ecx+216], eax

; 343  : 		if (lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN38@ChangeMode

; 344  : 		{
; 345  : 			//MI
; 346  :             //prevMode = RWS;
; 347  :             CalcSAMAzLimit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcSAMAzLimit@RadarDopplerClass@@IAEXXZ ; RadarDopplerClass::CalcSAMAzLimit
$LN38@ChangeMode:

; 348  : 		}
; 349  : 		SetEmitting (TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 350  : 		break;

	jmp	$LN79@ChangeMode
$LN37@ChangeMode:

; 351  : 		
; 352  : 	case GM:
; 353  : 	case GMT:
; 354  : 	case SEA:
; 355  : 		fovStepCmd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 356  : 		
; 357  : 		mode = (RadarMode)newMode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newMode$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 358  : 		// New to GM radar, start in 40 mile scope
; 359  : 		if (prevMode != GM && prevMode != GMT && prevMode != SEA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 14			; 0000000eH
	je	$LN36@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 16			; 00000010H
	je	$LN36@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 17			; 00000011H
	je	$LN36@ChangeMode

; 360  : 		{
; 361  : 			curRangeIdx = gmRangeIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+404]
	mov	DWORD PTR [eax+388], edx

; 362  : 			displayRange = rangeScales[curRangeIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+312]
	mov	DWORD PTR [edx+212], ecx

; 363  : 			tdisplayRange = displayRange * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+264], xmm0

; 364  : 			groundMapRange = tdisplayRange * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+264]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+476], xmm0

; 365  : 			flags &= SP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx

; 366  : 			SetFlagBit(NORM);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 367  : 			if(WasAutoAGRange && g_bRealisticAvionics && g_bAGRadarFixes)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+940]
	test	ecx, ecx
	je	SHORT $LN35@ChangeMode
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN35@ChangeMode
	movzx	eax, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	eax, eax
	je	SHORT $LN35@ChangeMode

; 368  : 				SetFlagBit(AutoAGRange);

	push	4194304					; 00400000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit
$LN35@ChangeMode:

; 369  : 			if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN34@ChangeMode
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN34@ChangeMode

; 370  : 			{
; 371  : 				if(mode == GM || mode == SEA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 14			; 0000000eH
	je	SHORT $LN32@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 17			; 00000011H
	jne	SHORT $LN33@ChangeMode
$LN32@ChangeMode:

; 372  : 					curAzIdx = gmAzIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+428]
	mov	DWORD PTR [edx+400], ecx

; 373  : 				else

	jmp	SHORT $LN31@ChangeMode
$LN33@ChangeMode:

; 374  : 					curAzIdx = gmtAzIdx;				 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	mov	DWORD PTR [edx+400], ecx
$LN31@ChangeMode:

; 375  : 				azScan = rwsAzs[curAzIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+332]
	mov	DWORD PTR [ecx+204], eax

; 376  : 			}
; 377  : 			else

	jmp	SHORT $LN30@ChangeMode
$LN34@ChangeMode:

; 378  : 				azScan = 60.0F * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR [ecx+204], xmm0
$LN30@ChangeMode:

; 379  : 			barWidth = APG68_BAR_WIDTH;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _APG68_BAR_WIDTH
	movss	DWORD PTR [edx+248], xmm0

; 380  : 			ClearFlagBit(VerticalScan);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 381  : 			SetFlagBit(HorizontalScan);

	push	4096					; 00001000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 382  : 			scanDir  = ScanFwd;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+252], xmm0

; 383  : 			SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan

; 384  : 		}
; 385  : 		else

	jmp	$LN29@ChangeMode
$LN36@ChangeMode:

; 386  : 		{
; 387  : 			// Reuse current range, within limits of course
; 388  : 			if (flags & (DBS1 | DBS2) || mode == GMT || mode == SEA)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	and	edx, 12					; 0000000cH
	jne	SHORT $LN27@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 16			; 00000010H
	je	SHORT $LN27@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 17			; 00000011H
	jne	SHORT $LN28@ChangeMode
$LN27@ChangeMode:

; 389  : 			{
; 390  : 				maxIdx = NUM_RANGES - 3;

	mov	DWORD PTR _maxIdx$[ebp], 2

; 391  : 			}
; 392  : 			else

	jmp	SHORT $LN26@ChangeMode
$LN28@ChangeMode:

; 393  : 			{
; 394  : 				maxIdx = NUM_RANGES - 2;

	mov	DWORD PTR _maxIdx$[ebp], 3
$LN26@ChangeMode:

; 395  : 			}
; 396  : 			
; 397  : 			if (mode != GM)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 14			; 0000000eH
	je	SHORT $LN25@ChangeMode

; 398  : 			{
; 399  : 				ClearFlagBit(DBS1);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit

; 400  : 				ClearFlagBit(DBS2);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ; RadarDopplerClass::ClearFlagBit
$LN25@ChangeMode:

; 401  : 			}
; 402  : 			
; 403  : 			curRangeIdx += rangeChangeCmd;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], ecx

; 404  : 			if (curRangeIdx > maxIdx)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	cmp	edx, DWORD PTR _maxIdx$[ebp]
	jle	SHORT $LN24@ChangeMode

; 405  : 				curRangeIdx = maxIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _maxIdx$[ebp]
	mov	DWORD PTR [eax+388], ecx
	jmp	SHORT $LN22@ChangeMode
$LN24@ChangeMode:

; 406  : 			else if (curRangeIdx < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+388], 0
	jge	SHORT $LN22@ChangeMode

; 407  : 				curRangeIdx = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0
$LN22@ChangeMode:

; 408  : 			
; 409  : 			gmRangeIdx = curRangeIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR [ecx+404], eax
$LN29@ChangeMode:

; 410  : 		}
; 411  : 		//MI make sure we're at the correct range
; 412  : 		if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN21@ChangeMode
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN21@ChangeMode

; 413  : 		{
; 414  : 			displayRange = rangeScales[curRangeIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+312]
	mov	DWORD PTR [edx+212], ecx

; 415  :   	         tdisplayRange = displayRange * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+264], xmm0

; 416  : 			 SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan

; 417  : 			 //Set our gain
; 418  : 			 InitGain = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+956], 1
$LN21@ChangeMode:

; 419  : 		}
; 420  : 		// GMT starts in snowplow
; 421  : 		//      if (mode == GMT)
; 422  : 		//         flags |= SP;//me123 no don't start in SP
; 423  : 		SetEmitting (TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 424  : 		prevMode = mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+88], edx

; 425  : 		break;

	jmp	SHORT $LN79@ChangeMode
$LN20@ChangeMode:

; 426  : 	case STBY:
; 427  : 		mode = STBY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 1

; 428  : 		SetEmitting(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 429  : 		break;

	jmp	SHORT $LN79@ChangeMode
$LN19@ChangeMode:

; 430  : 		//MI		
; 431  : 	case AGR:
; 432  : 		mode = AGR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], 20			; 00000014H

; 433  : 		break;

	jmp	SHORT $LN79@ChangeMode
$LN18@ChangeMode:

; 434  : 	case OFF:
; 435  : 		mode = OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], 0

; 436  : 		SetPower( FALSE );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN79@ChangeMode:

; 437  : 		break;
; 438  : 	}
; 439  : 	
; 440  : 	
; 441  : 	
; 442  : 	if (mode == VS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 5
	jne	SHORT $LN17@ChangeMode

; 443  : 		tdisplayRange = 80.0F * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@48ed5a1c
	movss	DWORD PTR [edx+264], xmm0

; 444  : 	else

	jmp	SHORT $LN16@ChangeMode
$LN17@ChangeMode:

; 445  : 		tdisplayRange = displayRange * NM_TO_FT;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+212]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+264], xmm0
$LN16@ChangeMode:

; 446  : 	
; 447  : 	SetScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetScan

; 448  : 	SetFlagBit(HomingBeam);

	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBit@RadarDopplerClass@@QAEXH@Z	; RadarDopplerClass::SetFlagBit

; 449  : 	
; 450  : 	//MI
; 451  : 	FireControlComputer *FCC = NULL;

	mov	DWORD PTR _FCC$[ebp], 0

; 452  : 	if(SimDriver.GetPlayerAircraft())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN15@ChangeMode

; 453  : 		FCC = SimDriver.GetPlayerAircraft()->FCC;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	edx, DWORD PTR [eax+936]
	mov	DWORD PTR _FCC$[ebp], edx
$LN15@ChangeMode:

; 454  : 	if(FCC)

	cmp	DWORD PTR _FCC$[ebp], 0
	je	$LN2@ChangeMode

; 455  : 	{
; 456  : 		if(FCC->GetMasterMode() == FireControlComputer::ClearOveride)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN13@ChangeMode

; 457  : 			return;

	jmp	$LN91@ChangeMode
$LN13@ChangeMode:

; 458  : 		
; 459  : 		if(FCC->IsAAMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAAMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAAMasterMode
	test	eax, eax
	je	SHORT $LN12@ChangeMode

; 460  : 			LastAAMode = mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+112], edx
	jmp	$LN2@ChangeMode
$LN12@ChangeMode:

; 461  : 		else if(FCC->IsNavMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsNavMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsNavMasterMode
	test	eax, eax
	je	SHORT $LN10@ChangeMode

; 462  : 			LastNAVMode = mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+116], edx
	jmp	$LN2@ChangeMode
$LN10@ChangeMode:

; 463  : 		else if(FCC->IsAGMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	je	SHORT $LN8@ChangeMode

; 464  : 		{
; 465  : 			if(mode != AGR)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 20			; 00000014H
	je	SHORT $LN7@ChangeMode

; 466  : 				LastAGMode = mode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+120], eax
$LN7@ChangeMode:

; 467  : 		}

	jmp	SHORT $LN2@ChangeMode
$LN8@ChangeMode:

; 468  : 		else if(FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN5@ChangeMode

; 469  : 			Missovrradarmode = mode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+92], eax
	jmp	SHORT $LN2@ChangeMode
$LN5@ChangeMode:

; 470  : 		else if(FCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN2@ChangeMode

; 471  : 		{
; 472  : 			if(mode == ACM_30x20 || mode == ACM_10x60 || mode == ACM_SLEW || mode == ACM_BORE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 6
	je	SHORT $LN1@ChangeMode
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 9
	je	SHORT $LN1@ChangeMode
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 7
	je	SHORT $LN1@ChangeMode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 8
	jne	SHORT $LN2@ChangeMode
$LN1@ChangeMode:

; 473  : 				Dogfovrradarmode = mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+96], ecx
$LN2@ChangeMode:
$LN91@ChangeMode:

; 474  : 		}
; 475  : 	}
; 476  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN111@ChangeMode:
	DD	$LN18@ChangeMode
	DD	$LN20@ChangeMode
	DD	$LN78@ChangeMode
	DD	$LN78@ChangeMode
	DD	$LN72@ChangeMode
	DD	$LN67@ChangeMode
	DD	$LN63@ChangeMode
	DD	$LN49@ChangeMode
	DD	$LN59@ChangeMode
	DD	$LN54@ChangeMode
	DD	$LN42@ChangeMode
	DD	$LN79@ChangeMode
	DD	$LN79@ChangeMode
	DD	$LN43@ChangeMode
	DD	$LN37@ChangeMode
	DD	$LN79@ChangeMode
	DD	$LN37@ChangeMode
	DD	$LN37@ChangeMode
	DD	$LN79@ChangeMode
	DD	$LN79@ChangeMode
	DD	$LN19@ChangeMode
?ChangeMode@RadarDopplerClass@@IAEXH@Z ENDP		; RadarDopplerClass::ChangeMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?ClearFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::ClearFlagBit, COMDAT
; _this$ = ecx

; 238  : 	void ClearFlagBit (int newFlag) {flags &= ~newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+492]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::ClearFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?SetFlagBit@RadarDopplerClass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newFlag$ = 8						; size = 4
?SetFlagBit@RadarDopplerClass@@QAEXH@Z PROC		; RadarDopplerClass::SetFlagBit, COMDAT
; _this$ = ecx

; 237  :    void SetFlagBit (int newFlag) {flags |= newFlag;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	or	ecx, DWORD PTR _newFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlagBit@RadarDopplerClass@@QAEXH@Z ENDP		; RadarDopplerClass::SetFlagBit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsSet@RadarDopplerClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@RadarDopplerClass@@QAEHH@Z PROC			; RadarDopplerClass::IsSet, COMDAT
; _this$ = ecx

; 236  :    int  IsSet (int newFlag) {return (newFlag & flags) ? TRUE : FALSE;}; //MI moved to public

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	and	ecx, DWORD PTR [eax+492]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@RadarDopplerClass@@QAEHH@Z ENDP			; RadarDopplerClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?Next@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Next@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ PROC	; RadarDopplerClass::TWSTrackList::Next, COMDAT
; _this$ = ecx

; 228  : 		TWSTrackList* Next(void) { return nextTrack; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Next@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ ENDP	; RadarDopplerClass::TWSTrackList::Next
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ PROC ; RadarDopplerClass::TWSTrackList::TrackFile, COMDAT
; _this$ = ecx

; 227  : 		SimObjectType* TrackFile(void) { return track; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ENDP ; RadarDopplerClass::TWSTrackList::TrackFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cmd$ = 8						; size = 4
?SetMode@RadarDopplerClass@@UAEXW4RadarMode@RadarClass@@@Z PROC ; RadarDopplerClass::SetMode
; _this$ = ecx

; 1192 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1193 :    // Default AA mode is RWS
; 1194 :    if (cmd == AA)

	cmp	DWORD PTR _cmd$[ebp], 18		; 00000012H
	jne	SHORT $LN2@SetMode

; 1195 :       cmd = RWS;

	mov	DWORD PTR _cmd$[ebp], 2
$LN2@SetMode:

; 1196 : 
; 1197 :    if (cmd != mode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	cmp	ecx, DWORD PTR [eax+184]
	je	SHORT $LN3@SetMode

; 1198 :       modeDesiredCmd = cmd;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+156], eax
$LN3@SetMode:

; 1199 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMode@RadarDopplerClass@@UAEXW4RadarMode@RadarClass@@@Z ENDP ; RadarDopplerClass::SetMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PrevTarget@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::PrevTarget
; _this$ = ecx

; 1351 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1352 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PrevTarget@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::PrevTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_RangeToBeat$1 = -40					; size = 4
tv150 = -36						; size = 4
tv142 = -32						; size = 4
tv134 = -28						; size = 4
tv94 = -24						; size = 4
_NextFurther$ = -20					; size = 4
_MinRange$2 = -16					; size = 4
_tmp$3 = -12						; size = 4
_rdrObj$ = -8						; size = 4
_this$ = -4						; size = 4
?NextTarget@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::NextTarget
; _this$ = ecx

; 1264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1265 : 	//Step target starting with the closest one to us
; 1266 : 	SimObjectType* rdrObj = platform->targetList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+660]
	mov	DWORD PTR _rdrObj$[ebp], edx

; 1267 : 	SimObjectType* NextFurther = NULL;

	mov	DWORD PTR _NextFurther$[ebp], 0

; 1268 : 	
; 1269 : 	
; 1270 : 	if (mode != TWS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 4
	je	$LN28@NextTarget

; 1271 : 	{
; 1272 : 		float RangeToBeat; //next target needs to be further then this
; 1273 : 		float MinRange = tdisplayRange;	//make sure we check the whole radar range

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+264]
	movss	DWORD PTR _MinRange$2[ebp], xmm0

; 1274 : 		
; 1275 : 		if(lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	$LN27@NextTarget

; 1276 : 		{
; 1277 : 			//store our dist
; 1278 : 			RangeToBeat = lockedTarget->localData->range;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+12]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _RangeToBeat$1[ebp], xmm0
$LN26@NextTarget:

; 1279 : 			while(rdrObj)

	cmp	DWORD PTR _rdrObj$[ebp], 0
	je	$LN25@NextTarget

; 1280 : 			{
; 1281 : 				//only what we've detected
; 1282 : 				if(ObjectDetected(rdrObj))

	mov	eax, DWORD PTR _rdrObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectDetected@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z ; RadarDopplerClass::ObjectDetected
	test	eax, eax
	je	$LN21@NextTarget

; 1283 : 				{
; 1284 : 					//can't lock onto these
; 1285 : 					if(!rdrObj->BaseData()->OnGround() && !rdrObj->BaseData()->IsMissile() && 
; 1286 : 						!rdrObj->BaseData()->IsBomb() && !rdrObj->BaseData()->IsEject() &&
; 1287 : 						rdrObj->localData->rdrDetect)

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN21@NextTarget
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	jne	$LN21@NextTarget
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	jne	SHORT $LN21@NextTarget
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR tv150[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv150[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	test	eax, eax
	jne	SHORT $LN21@NextTarget
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+140], 0
	je	SHORT $LN21@NextTarget

; 1288 : 					{
; 1289 : 						if(MinRange > rdrObj->localData->range)

	mov	eax, DWORD PTR _rdrObj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR _MinRange$2[ebp]
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN21@NextTarget

; 1290 : 						{ 
; 1291 : 							if(rdrObj->localData->range > RangeToBeat)

	mov	edx, DWORD PTR _rdrObj$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movss	xmm0, DWORD PTR [eax+44]
	comiss	xmm0, DWORD PTR _RangeToBeat$1[ebp]
	jbe	SHORT $LN21@NextTarget

; 1292 : 							{
; 1293 : 								NextFurther = rdrObj;

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	mov	DWORD PTR _NextFurther$[ebp], ecx

; 1294 : 								MinRange = rdrObj->localData->range;

	mov	edx, DWORD PTR _rdrObj$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _MinRange$2[ebp], xmm0
$LN21@NextTarget:

; 1295 : 							}
; 1296 : 						}
; 1297 : 					}
; 1298 : 				}
; 1299 : 				if(!rdrObj->next)

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN20@NextTarget

; 1300 : 					break;

	jmp	SHORT $LN25@NextTarget
$LN20@NextTarget:

; 1301 : 				rdrObj = rdrObj->next;

	mov	edx, DWORD PTR _rdrObj$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _rdrObj$[ebp], eax

; 1302 : 			}

	jmp	$LN26@NextTarget
$LN25@NextTarget:

; 1303 : 			if(NextFurther)

	cmp	DWORD PTR _NextFurther$[ebp], 0
	je	SHORT $LN19@NextTarget

; 1304 : 				SetDesiredTarget(NextFurther);

	mov	ecx, DWORD PTR _NextFurther$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 1305 : 			else

	jmp	SHORT $LN18@NextTarget
$LN19@NextTarget:

; 1306 : 				FindClosest(MinRange);

	push	ecx
	movss	xmm0, DWORD PTR _MinRange$2[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindClosest@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::FindClosest
$LN18@NextTarget:

; 1307 : 		}
; 1308 : 		else

	jmp	SHORT $LN17@NextTarget
$LN27@NextTarget:

; 1309 : 			FindClosest(MinRange);

	push	ecx
	movss	xmm0, DWORD PTR _MinRange$2[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindClosest@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::FindClosest
$LN17@NextTarget:

; 1310 : 	}
; 1311 : 	else  // revised TWS mode TWS directory based targeting

	jmp	$LN1@NextTarget
$LN28@NextTarget:

; 1312 : 	{
; 1313 : 		if (IsSet(STTingTarget))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	je	SHORT $LN15@NextTarget

; 1314 : 			return;  // no cycling if we are in STT

	jmp	$LN29@NextTarget
$LN15@NextTarget:

; 1315 : 
; 1316 : 		if (lockedTarget && TWSTrackDirectory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN14@NextTarget
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+532], 0
	je	$LN14@NextTarget

; 1317 : 		{
; 1318 : 			if (!IsSet(STTingTarget)) 

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	$LN5@NextTarget

; 1319 : 			{
; 1320 : 				TWSTrackList* tmp = TWSTrackDirectory->OnList(lockedTarget);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+532]
	call	?OnList@TWSTrackList@RadarDopplerClass@@QAEPAV12@PAVSimObjectType@@@Z ; RadarDopplerClass::TWSTrackList::OnList
	mov	DWORD PTR _tmp$3[ebp], eax

; 1321 : 				AddToHistory(lockedTarget, Track);  // demote current from bug to a track

	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z ; RadarDopplerClass::AddToHistory

; 1322 : 				if (tmp)

	cmp	DWORD PTR _tmp$3[ebp], 0
	je	SHORT $LN6@NextTarget
$LN11@NextTarget:

; 1323 : 					do
; 1324 : 					{
; 1325 : 						if (!tmp->Next())

	mov	ecx, DWORD PTR _tmp$3[ebp]
	call	?Next@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ ; RadarDopplerClass::TWSTrackList::Next
	test	eax, eax
	jne	SHORT $LN8@NextTarget

; 1326 : 							tmp = TWSTrackDirectory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	mov	DWORD PTR _tmp$3[ebp], edx

; 1327 : 						else

	jmp	SHORT $LN7@NextTarget
$LN8@NextTarget:

; 1328 : 							tmp = tmp->Next();

	mov	ecx, DWORD PTR _tmp$3[ebp]
	call	?Next@TWSTrackList@RadarDopplerClass@@QAEPAV12@XZ ; RadarDopplerClass::TWSTrackList::Next
	mov	DWORD PTR _tmp$3[ebp], eax
$LN7@NextTarget:

; 1329 : 					} while ((tmp->TrackFile()->localData->extrapolateStart != 0)
; 1330 : 						&& (tmp->TrackFile() != lockedTarget));

	mov	ecx, DWORD PTR _tmp$3[ebp]
	call	?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ; RadarDopplerClass::TWSTrackList::TrackFile
	mov	eax, DWORD PTR [eax+12]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN6@NextTarget
	mov	ecx, DWORD PTR _tmp$3[ebp]
	call	?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ; RadarDopplerClass::TWSTrackList::TrackFile
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+48]
	jne	SHORT $LN11@NextTarget
$LN6@NextTarget:

; 1331 : 
; 1332 : 				ClearSensorTarget();  // ...and release it.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx

; 1333 : 				// ...and if there's a suitable candidate bug it instead
; 1334 : 				if (tmp && (tmp->TrackFile()->localData->extrapolateStart == 0))

	cmp	DWORD PTR _tmp$3[ebp], 0
	je	SHORT $LN5@NextTarget
	mov	ecx, DWORD PTR _tmp$3[ebp]
	call	?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ; RadarDopplerClass::TWSTrackList::TrackFile
	mov	eax, DWORD PTR [eax+12]
	cmp	DWORD PTR [eax+144], 0
	jne	SHORT $LN5@NextTarget

; 1335 : 				{
; 1336 : 					SetDesiredTarget(tmp->TrackFile());

	mov	ecx, DWORD PTR _tmp$3[ebp]
	call	?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ; RadarDopplerClass::TWSTrackList::TrackFile
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN5@NextTarget:

; 1337 : 				}
; 1338 : 			}
; 1339 : 		}

	jmp	SHORT $LN2@NextTarget
$LN14@NextTarget:

; 1340 : 		else if (TWSTrackDirectory)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+532], 0
	je	SHORT $LN3@NextTarget

; 1341 : 			SetDesiredTarget(TWSTrackDirectory->TrackFile());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+532]
	call	?TrackFile@TWSTrackList@RadarDopplerClass@@QAEPAVSimObjectType@@XZ ; RadarDopplerClass::TWSTrackList::TrackFile
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1342 : 		else

	jmp	SHORT $LN2@NextTarget
$LN3@NextTarget:

; 1343 : 			FindClosest(tdisplayRange);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+264]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindClosest@RadarDopplerClass@@QAEXM@Z	; RadarDopplerClass::FindClosest
$LN2@NextTarget:

; 1344 : 
; 1345 : 		if (lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN1@NextTarget

; 1346 : 			AddToHistory(lockedTarget, Bug);  // promote new one to a bug

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z ; RadarDopplerClass::AddToHistory
$LN1@NextTarget:
$LN29@NextTarget:

; 1347 : 	}
; 1348 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NextTarget@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::NextTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_FCC$ = -8						; size = 4
_this$ = -4						; size = 4
?DefaultAAMode@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::DefaultAAMode
; _this$ = ecx

; 1120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1121 : 	//MI
; 1122 : 	FireControlComputer *FCC = NULL;

	mov	DWORD PTR _FCC$[ebp], 0

; 1123 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN23@DefaultAAM

; 1124 : 	{
; 1125 : 		if(SimDriver.GetPlayerAircraft())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN22@DefaultAAM

; 1126 : 			FCC = SimDriver.GetPlayerAircraft()->FCC;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR _FCC$[ebp], ecx
$LN22@DefaultAAM:

; 1127 : 		if(FCC)

	cmp	DWORD PTR _FCC$[ebp], 0
	je	$LN21@DefaultAAM

; 1128 : 		{
; 1129 : 			if(FCC->IsAAMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAAMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAAMasterMode
	test	eax, eax
	je	SHORT $LN20@DefaultAAM

; 1130 : 				modeDesiredCmd = LastAAMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [edx+156], ecx
	jmp	$LN21@DefaultAAM
$LN20@DefaultAAM:

; 1131 : 			else if(FCC->IsNavMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsNavMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsNavMasterMode
	test	eax, eax
	je	SHORT $LN18@DefaultAAM

; 1132 : 				modeDesiredCmd = LastNAVMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR [edx+156], ecx
	jmp	$LN21@DefaultAAM
$LN18@DefaultAAM:

; 1133 : 			else if(FCC->IsAGMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	je	SHORT $LN16@DefaultAAM

; 1134 : 			{
; 1135 : 				modeDesiredCmd = LastAGMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR [edx+156], ecx

; 1136 : 				if(LastAGModes == 2)	//SnowPlow

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+936], 2
	jne	SHORT $LN15@DefaultAAM

; 1137 : 				{
; 1138 : 					SetAGSnowPlow(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	call	eax
	jmp	SHORT $LN14@DefaultAAM
$LN15@DefaultAAM:

; 1139 : 				}
; 1140 : 				else if(LastAGModes == 3)	//STPT

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+936], 3
	jne	SHORT $LN14@DefaultAAM

; 1141 : 					SetAGSnowPlow(FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+176]
	call	edx
$LN14@DefaultAAM:

; 1142 : 				else
; 1143 : 					ShiWarning("Inconsistant state");

	jmp	SHORT $LN21@DefaultAAM
$LN16@DefaultAAM:

; 1144 : 			}
; 1145 : 			else if(FCC->GetMasterMode() == FireControlComputer::ClearOveride)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN10@DefaultAAM

; 1146 : 			{
; 1147 : 				if(FCC->GetLastMasterMode() == FireControlComputer::AAGun)	//AA mode

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetLastMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetLastMasterMode
	test	eax, eax
	jne	SHORT $LN9@DefaultAAM

; 1148 : 					modeDesiredCmd = LastAAMode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR [eax+156], edx
$LN9@DefaultAAM:

; 1149 : 			}

	jmp	SHORT $LN21@DefaultAAM
$LN10@DefaultAAM:

; 1150 : 			else if(FCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN7@DefaultAAM

; 1151 : 				modeDesiredCmd = Dogfovrradarmode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+156], edx
	jmp	SHORT $LN21@DefaultAAM
$LN7@DefaultAAM:

; 1152 : 			else if(FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN21@DefaultAAM

; 1153 : 				modeDesiredCmd = Missovrradarmode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+156], edx
$LN21@DefaultAAM:

; 1154 : 			else
; 1155 : 				ShiWarning("How did you get here?");
; 1156 : 		}
; 1157 : 		return;

	jmp	SHORT $LN24@DefaultAAM
$LN23@DefaultAAM:

; 1158 : 	}
; 1159 : 	if (mode == GMT ||
; 1160 :        mode == SEA ||
; 1161 :        mode == GM)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 16			; 00000010H
	je	SHORT $LN2@DefaultAAM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 17			; 00000011H
	je	SHORT $LN2@DefaultAAM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 14			; 0000000eH
	jne	SHORT $LN3@DefaultAAM
$LN2@DefaultAAM:

; 1162 :    {
; 1163 :       modeDesiredCmd = RWS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 2

; 1164 :    }
; 1165 : 	else {

	jmp	SHORT $LN24@DefaultAAM
$LN3@DefaultAAM:

; 1166 : 		modeDesiredCmd = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], -1
$LN24@DefaultAAM:

; 1167 : 	}
; 1168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultAAMode@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::DefaultAAMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_FCC$ = -8						; size = 4
_this$ = -4						; size = 4
?DefaultAGMode@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::DefaultAGMode
; _this$ = ecx

; 1202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1203 : 	//MI
; 1204 : 	FireControlComputer *FCC = NULL;

	mov	DWORD PTR _FCC$[ebp], 0

; 1205 : 	if(g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN24@DefaultAGM

; 1206 : 	 {
; 1207 : 		if(SimDriver.GetPlayerAircraft())

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN23@DefaultAGM

; 1208 : 			FCC = SimDriver.GetPlayerAircraft()->FCC;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	ecx, DWORD PTR [eax+936]
	mov	DWORD PTR _FCC$[ebp], ecx
$LN23@DefaultAGM:

; 1209 : 		if(FCC)

	cmp	DWORD PTR _FCC$[ebp], 0
	je	$LN22@DefaultAGM

; 1210 : 		{
; 1211 : 			if(FCC->IsAAMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAAMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAAMasterMode
	test	eax, eax
	je	SHORT $LN21@DefaultAGM

; 1212 : 				modeDesiredCmd = LastAAMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [edx+156], ecx
	jmp	$LN22@DefaultAGM
$LN21@DefaultAGM:

; 1213 : 			else if(FCC->IsNavMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsNavMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsNavMasterMode
	test	eax, eax
	je	SHORT $LN19@DefaultAGM

; 1214 : 				modeDesiredCmd = LastNAVMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR [edx+156], ecx
	jmp	$LN22@DefaultAGM
$LN19@DefaultAGM:

; 1215 : 			else if(FCC->IsAGMasterMode())

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	je	$LN17@DefaultAGM

; 1216 : 			{
; 1217 : 				// ASSOCIATOR moved this check from RadarDopplerClass::Display in Bscope.cpp to here so that it only
; 1218 : 				// defaults to AGR when first selected and than be changed manually to any other radar mode
; 1219 : 				if(FCC->GetSubMode() == FireControlComputer::CCIP || FCC->GetSubMode() == FireControlComputer::DTOSS ||
; 1220 : 					FCC->GetSubMode() == FireControlComputer::STRAF || 
; 1221 : 					FCC->GetSubMode() == FireControlComputer::MAN ||   // Cobra - for JSOWa
; 1222 : 					FCC->GetMasterMode() == FireControlComputer::AirGroundRocket/*FCC->GetSubMode() == FireControlComputer::RCKT*/ && mode != AGR )

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 7
	je	SHORT $LN15@DefaultAGM
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN15@DefaultAGM
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN15@DefaultAGM
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	je	SHORT $LN15@DefaultAGM
	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN16@DefaultAGM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 20			; 00000014H
	je	SHORT $LN16@DefaultAGM
$LN15@DefaultAGM:

; 1223 : 				{
; 1224 : 					mode = AGR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 20			; 00000014H

; 1225 : 					return;

	jmp	$LN25@DefaultAGM
$LN16@DefaultAGM:

; 1226 : 				}
; 1227 : 				modeDesiredCmd = LastAGMode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR [ecx+156], eax

; 1228 : 				if(LastAGModes == 2)	//SnowPlow

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+936], 2
	jne	SHORT $LN14@DefaultAGM

; 1229 : 				{
; 1230 : 					SetAGSnowPlow(TRUE);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+176]
	call	edx
	jmp	SHORT $LN13@DefaultAGM
$LN14@DefaultAGM:

; 1231 : 				}
; 1232 : 				else if(LastAGModes == 3)	//STPT

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+936], 3
	jne	SHORT $LN13@DefaultAGM

; 1233 : 					SetAGSnowPlow(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	call	eax
$LN13@DefaultAGM:

; 1234 : 				else
; 1235 : 					ShiWarning("Inconsistant state");

	jmp	SHORT $LN22@DefaultAGM
$LN17@DefaultAGM:

; 1236 : 			}
; 1237 : 			else if(FCC->GetMasterMode() == FireControlComputer::ClearOveride)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN9@DefaultAGM

; 1238 : 			{
; 1239 : 				if(FCC->GetLastMasterMode() == FireControlComputer::AAGun)	//AA mode

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetLastMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetLastMasterMode
	test	eax, eax
	jne	SHORT $LN8@DefaultAGM

; 1240 : 					modeDesiredCmd = LastAAMode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx+156], eax
$LN8@DefaultAGM:

; 1241 : 			}

	jmp	SHORT $LN22@DefaultAGM
$LN9@DefaultAGM:

; 1242 : 			else if(FCC->GetMasterMode() == FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN6@DefaultAGM

; 1243 : 				modeDesiredCmd = Dogfovrradarmode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR [ecx+156], eax
	jmp	SHORT $LN22@DefaultAGM
$LN6@DefaultAGM:

; 1244 : 			else if(FCC->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	ecx, DWORD PTR _FCC$[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN22@DefaultAGM

; 1245 : 				modeDesiredCmd = Missovrradarmode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR [ecx+156], eax
$LN22@DefaultAGM:

; 1246 : 			else
; 1247 : 				ShiWarning("How did you get here?");
; 1248 : 		}
; 1249 : 		return;

	jmp	SHORT $LN25@DefaultAGM
$LN24@DefaultAGM:

; 1250 : 	}
; 1251 : 
; 1252 :    if (mode != GMT &&
; 1253 :        mode != SEA &&
; 1254 :        mode != GM)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 16			; 00000010H
	je	SHORT $LN2@DefaultAGM
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 17			; 00000011H
	je	SHORT $LN2@DefaultAGM
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 14			; 0000000eH
	je	SHORT $LN2@DefaultAGM

; 1255 :    {
; 1256 :       modeDesiredCmd = GMT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 16			; 00000010H

; 1257 :    }
; 1258 : 	else {

	jmp	SHORT $LN25@DefaultAGM
$LN2@DefaultAGM:

; 1259 : 		modeDesiredCmd = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], -1
$LN25@DefaultAGM:

; 1260 : 	}
; 1261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultAGMode@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::DefaultAGMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?StepAGmode@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::StepAGmode
; _this$ = ecx

; 1171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1172 : 	switch (mode) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 14			; 0000000eH
	je	SHORT $LN4@StepAGmode
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	je	SHORT $LN3@StepAGmode
	cmp	DWORD PTR tv65[ebp], 17			; 00000011H
	je	SHORT $LN2@StepAGmode
	jmp	SHORT $LN1@StepAGmode
$LN4@StepAGmode:

; 1173 : 	  case GM:
; 1174 : 		modeDesiredCmd = GMT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 16			; 00000010H

; 1175 : 		break;

	jmp	SHORT $LN7@StepAGmode
$LN3@StepAGmode:

; 1176 : 
; 1177 : 	  case GMT:
; 1178 : 		modeDesiredCmd = SEA;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 17			; 00000011H

; 1179 : 		break;

	jmp	SHORT $LN7@StepAGmode
$LN2@StepAGmode:

; 1180 : 
; 1181 : 	  case SEA:
; 1182 : 		modeDesiredCmd = GM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 14			; 0000000eH

; 1183 : 		break;

	jmp	SHORT $LN7@StepAGmode
$LN1@StepAGmode:

; 1184 : 
; 1185 : 	  default:
; 1186 : 		modeDesiredCmd = GM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 14			; 0000000eH
$LN7@StepAGmode:

; 1187 : 		break;
; 1188 : 	}
; 1189 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGmode@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::StepAGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AntElevKnob@RadarDopplerClass@@UAEMXZ PROC		; RadarDopplerClass::AntElevKnob
; _this$ = ecx

; 1540 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1541 : 	// MD -- 20031223: make this a regular function because soon this will be integrated with analog
; 1542 : 	// axis support for the HOTAS Antenna Knob
; 1543 : 
; 1544 : 	// MD -- 20031231: and now for the analog support thanks to Retr0
; 1545 : 	// Antenna elevation is stored in Radians.  Analog curves probably
; 1546 : 	// want to be shaped to ensure relatively good control near the
; 1547 : 	// center detent and less fine adjustment near the ends of travel.
; 1548 : 
; 1549 : 	if (IO.AnalogIsUsed(AXIS_ANT_ELEV)) {

	push	10					; 0000000aH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@AntElevKno

; 1550 : 		antElevKnob = ((IO.GetAxisValue(AXIS_ANT_ELEV) / 10000.0F) * MAX_ANT_EL);

	push	10					; 0000000aH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::GetAxisValue
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@461c4000
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+232], xmm0
$LN1@AntElevKno:

; 1551 : 	}
; 1552 : 	
; 1553 : 	return antElevKnob;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+232]

; 1554 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AntElevKnob@RadarDopplerClass@@UAEMXZ ENDP		; RadarDopplerClass::AntElevKnob
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
tv142 = -16						; size = 4
tv141 = -12						; size = 4
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_cmd$ = 8						; size = 4
?StepAAelvation@RadarDopplerClass@@UAEXH@Z PROC		; RadarDopplerClass::StepAAelvation
; _this$ = ecx

; 1520 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1521 : 	if (IO.AnalogIsUsed(AXIS_ANT_ELEV))

	push	10					; 0000000aH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@StepAAelva

; 1522 : 		return;

	jmp	$LN8@StepAAelva
$LN7@StepAAelva:

; 1523 : 
; 1524 : 	if (!g_bAntElevKnobFix) {

	movzx	ecx, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	ecx, ecx
	jne	SHORT $LN6@StepAAelva

; 1525 : 		if (cmd)

	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN5@StepAAelva

; 1526 : 			elSlewCmd = cmd;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+152], eax

; 1527 : 		else

	jmp	SHORT $LN4@StepAAelva
$LN5@StepAAelva:

; 1528 : 			centerCmd = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], 1
$LN4@StepAAelva:

; 1529 : 	}
; 1530 : 	else

	jmp	$LN1@StepAAelva
$LN6@StepAAelva:

; 1531 : 	{
; 1532 : 		if (cmd == 0)

	cmp	DWORD PTR _cmd$[ebp], 0
	jne	SHORT $LN2@StepAAelva

; 1533 : 			antElevKnob = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+232], xmm0

; 1534 : 		else

	jmp	$LN1@StepAAelva
$LN2@StepAAelva:

; 1535 : 			antElevKnob = min ( max ( (antElevKnob + (cmd * EL_CHANGE_RATE)), -MAX_ANT_EL), MAX_ANT_EL);

	cvtsi2ss xmm0, DWORD PTR _cmd$[ebp]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+232]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN10@StepAAelva
	cvtsi2ss xmm0, DWORD PTR _cmd$[ebp]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+232]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN11@StepAAelva
$LN10@StepAAelva:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv92[ebp], xmm0
$LN11@StepAAelva:
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv92[ebp]
	jbe	SHORT $LN14@StepAAelva
	cvtsi2ss xmm0, DWORD PTR _cmd$[ebp]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+232]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN12@StepAAelva
	cvtsi2ss xmm0, DWORD PTR _cmd$[ebp]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+232]
	movss	DWORD PTR tv141[ebp], xmm0
	jmp	SHORT $LN13@StepAAelva
$LN12@StepAAelva:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv141[ebp], xmm0
$LN13@StepAAelva:
	movss	xmm0, DWORD PTR tv141[ebp]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN15@StepAAelva
$LN14@StepAAelva:
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR tv142[ebp], xmm0
$LN15@StepAAelva:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR [ecx+232], xmm0
$LN1@StepAAelva:
$LN8@StepAAelva:

; 1536 : 	}
; 1537 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StepAAelvation@RadarDopplerClass@@UAEXH@Z ENDP		; RadarDopplerClass::StepAAelvation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Cmd$ = 12						; size = 4
?StepAzimuth@RadarDopplerClass@@QAEXMH@Z PROC		; RadarDopplerClass::StepAzimuth
; _this$ = ecx

; 1442 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1443 : 	// MD -- 20040111: modified test for cmd value to be compatible with analog cursor support
; 1444 : 	// MD -- 20040123: modified to take into account revised TWS scan pattern implementation
; 1445 : 	if(X == 1.0F && Cmd > 0)

	movss	xmm0, DWORD PTR _X$[ebp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@StepAzimut
	cmp	DWORD PTR _Cmd$[ebp], 0
	jle	$LN19@StepAzimut

; 1446 : 	{
; 1447 : 		if (mode == TWS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 4
	jne	$LN18@StepAzimut

; 1448 : 		{
; 1449 : 			// only bump between 25 and 60 degree patterns
; 1450 : 			if(curAzIdx == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+400], 2
	jne	SHORT $LN17@StepAzimut

; 1451 : 				curAzIdx = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+400], 1

; 1452 : 			else

	jmp	SHORT $LN16@StepAzimut
$LN17@StepAzimut:

; 1453 : 				curAzIdx = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], 2
$LN16@StepAzimut:

; 1454 : 			azScan =twsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx*4+344]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm1

; 1455 : 			displayAzScan = twsAzs[curAzIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+344]
	mov	DWORD PTR [edx+216], ecx

; 1456 : 			curBarIdx = twsBarIdx = curAzIdx;  // move bars in lock step

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR [edx+440], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+440]
	mov	DWORD PTR [edx+392], ecx

; 1457 : 			bars = twsBars[curBarIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+376]
	mov	DWORD PTR [ecx+188], eax

; 1458 : 		}
; 1459 : 		else

	jmp	SHORT $LN15@StepAzimut
$LN18@StepAzimut:

; 1460 : 		{
; 1461 : 			//step our Azimuth, only step 30 and 60 degree
; 1462 : 			//2 = 60, 1 = 30
; 1463 : 			if(curAzIdx == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+400], 0
	jne	SHORT $LN14@StepAzimut

; 1464 : 				curAzIdx = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+400], 2

; 1465 : 			else

	jmp	SHORT $LN13@StepAzimut
$LN14@StepAzimut:

; 1466 : 				curAzIdx = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], 0
$LN13@StepAzimut:

; 1467 : 			azScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx*4+332]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm1

; 1468 : 			displayAzScan = rwsAzs[curAzIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+332]
	mov	DWORD PTR [edx+216], ecx
$LN15@StepAzimut:

; 1469 : 		}
; 1470 : 
; 1471 : 		//bump the cursor back to the center, if no locked target
; 1472 : 		//otherwise, just bump it back a bit.
; 1473 : 		if(!lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN12@StepAzimut

; 1474 : 			cursorX = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+220], xmm0

; 1475 : 		else

	jmp	SHORT $LN11@StepAzimut
$LN12@StepAzimut:

; 1476 : 			cursorX = 0.9F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [ecx+220], xmm0
$LN11@StepAzimut:
	jmp	$LN1@StepAzimut
$LN19@StepAzimut:

; 1477 : 	}
; 1478 : 	else if(X == -1.0F && Cmd < 0)

	movss	xmm0, DWORD PTR _X$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN1@StepAzimut
	cmp	DWORD PTR _Cmd$[ebp], 0
	jge	$LN1@StepAzimut

; 1479 : 	{
; 1480 : 		if (mode == TWS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 4
	jne	$LN8@StepAzimut

; 1481 : 		{
; 1482 : 			// only bump between 25 and 60 degree patterns
; 1483 : 			if(curAzIdx == 2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+400], 2
	jne	SHORT $LN7@StepAzimut

; 1484 : 				curAzIdx = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+400], 1

; 1485 : 			else

	jmp	SHORT $LN6@StepAzimut
$LN7@StepAzimut:

; 1486 : 				curAzIdx = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+400], 2
$LN6@StepAzimut:

; 1487 : 			azScan =twsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx*4+344]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+204], xmm1

; 1488 : 			displayAzScan = twsAzs[curAzIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+344]
	mov	DWORD PTR [ecx+216], eax

; 1489 : 			curBarIdx = twsBarIdx = curAzIdx;  // move bars in lock step

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	DWORD PTR [ecx+440], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+440]
	mov	DWORD PTR [ecx+392], eax

; 1490 : 			bars = twsBars[curBarIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+376]
	mov	DWORD PTR [eax+188], edx

; 1491 : 		}
; 1492 : 		else

	jmp	SHORT $LN5@StepAzimut
$LN8@StepAzimut:

; 1493 : 		{
; 1494 : 			//step our Azimuth, only step 30 and 60 degree
; 1495 : 			//2 = 60, 1 = 30
; 1496 : 			if(curAzIdx == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN4@StepAzimut

; 1497 : 				curAzIdx = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+400], 2

; 1498 : 			else

	jmp	SHORT $LN3@StepAzimut
$LN4@StepAzimut:

; 1499 : 				curAzIdx = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+400], 0
$LN3@StepAzimut:

; 1500 : 			azScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx*4+332]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+204], xmm1

; 1501 : 			displayAzScan = rwsAzs[curAzIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+332]
	mov	DWORD PTR [ecx+216], eax
$LN5@StepAzimut:

; 1502 : 		}
; 1503 : 		//bump the cursor back to the center, if no locked target
; 1504 : 		//otherwise, just bump it back a bit.
; 1505 : 		if(!lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN2@StepAzimut

; 1506 : 			cursorX = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+220], xmm0

; 1507 : 		else

	jmp	SHORT $LN1@StepAzimut
$LN2@StepAzimut:

; 1508 : 			cursorX = -0.9F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [eax+220], xmm0
$LN1@StepAzimut:

; 1509 : 	}
; 1510 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?StepAzimuth@RadarDopplerClass@@QAEXMH@Z ENDP		; RadarDopplerClass::StepAzimuth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
tv134 = -28						; size = 4
tv94 = -24						; size = 4
tv86 = -20						; size = 4
tv78 = -16						; size = 4
_Closest$ = -12						; size = 4
_this$ = -8						; size = 4
_rdrObj$ = -4						; size = 4
_MinRange$ = 8						; size = 4
?FindClosest@RadarDopplerClass@@QAEXM@Z PROC		; RadarDopplerClass::FindClosest
; _this$ = ecx

; 1410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1411 : 	SimObjectType* Closest = NULL;

	mov	DWORD PTR _Closest$[ebp], 0

; 1412 : 	SimObjectType* rdrObj = platform->targetList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+660]
	mov	DWORD PTR _rdrObj$[ebp], edx
$LN8@FindCloses:

; 1413 : 
; 1414 : 	while(rdrObj)

	cmp	DWORD PTR _rdrObj$[ebp], 0
	je	$LN7@FindCloses

; 1415 : 	{
; 1416 : 		if(ObjectDetected(rdrObj))

	mov	eax, DWORD PTR _rdrObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectDetected@RadarDopplerClass@@IAEHPAVSimObjectType@@@Z ; RadarDopplerClass::ObjectDetected
	test	eax, eax
	je	$LN4@FindCloses

; 1417 : 		{
; 1418 : 			//can't lock onto these
; 1419 : 			if(!rdrObj->BaseData()->OnGround() && !rdrObj->BaseData()->IsMissile() && 
; 1420 : 				!rdrObj->BaseData()->IsBomb() && !rdrObj->BaseData()->IsEject() &&
; 1421 : 				rdrObj->localData->rdrDetect)

	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv78[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN4@FindCloses
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@FindCloses
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR [edx+164]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@FindCloses
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	test	eax, eax
	jne	SHORT $LN4@FindCloses
	mov	ecx, DWORD PTR _rdrObj$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+140], 0
	je	SHORT $LN4@FindCloses

; 1422 : 			{
; 1423 : 				if(rdrObj->localData->range < MinRange)

	mov	eax, DWORD PTR _rdrObj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR _MinRange$[ebp]
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN4@FindCloses

; 1424 : 				{
; 1425 : 					Closest = rdrObj;

	mov	edx, DWORD PTR _rdrObj$[ebp]
	mov	DWORD PTR _Closest$[ebp], edx

; 1426 : 					MinRange = rdrObj->localData->range;

	mov	eax, DWORD PTR _rdrObj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR _MinRange$[ebp], xmm0
$LN4@FindCloses:

; 1427 : 				}
; 1428 : 			}
; 1429 : 		}
; 1430 : 		if(!rdrObj->next)

	mov	edx, DWORD PTR _rdrObj$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN3@FindCloses

; 1431 : 			break;

	jmp	SHORT $LN7@FindCloses
$LN3@FindCloses:

; 1432 : 		rdrObj = rdrObj->next;

	mov	eax, DWORD PTR _rdrObj$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _rdrObj$[ebp], ecx

; 1433 : 	}

	jmp	$LN8@FindCloses
$LN7@FindCloses:

; 1434 : 	if(Closest)

	cmp	DWORD PTR _Closest$[ebp], 0
	je	SHORT $LN1@FindCloses

; 1435 : 	{
; 1436 : 		SetDesiredTarget(Closest);

	mov	edx, DWORD PTR _Closest$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 1437 : 		if (mode == TWS)  // MD -- 20040122: bug the target right away for TWS

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 4
	jne	SHORT $LN1@FindCloses

; 1438 : 			AddToHistory(Closest, Bug);

	push	7
	mov	edx, DWORD PTR _Closest$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToHistory@RadarDopplerClass@@IAEXPAVSimObjectType@@H@Z ; RadarDopplerClass::AddToHistory
$LN1@FindCloses:

; 1439 : 	}
; 1440 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindClosest@RadarDopplerClass@@QAEXM@Z ENDP		; RadarDopplerClass::FindClosest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearOverride@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::ClearOverride
; _this$ = ecx

; 1387 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1388 : 
; 1389 : 	if (Overridemode == 2) //me123 dogfight flag

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 2
	jne	SHORT $LN4@ClearOverr

; 1390 : 	{
; 1391 : 		if(mode == ACM_30x20 || mode == ACM_10x60 || mode == ACM_SLEW || mode == ACM_BORE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 6
	je	SHORT $LN2@ClearOverr
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 9
	je	SHORT $LN2@ClearOverr
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 7
	je	SHORT $LN2@ClearOverr
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 8
	jne	SHORT $LN3@ClearOverr
$LN2@ClearOverr:

; 1392 : 			Dogfovrradarmode = mode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+96], ecx
$LN3@ClearOverr:

; 1393 : 
; 1394 : 		//restore our range
; 1395 : 		airRangeIdx = lastAirRangeIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	DWORD PTR [edx+408], ecx
$LN4@ClearOverr:

; 1396 : 	}
; 1397 : 
; 1398 : 	if (Overridemode == 1)//me123 missovride flag

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+108], 1
	jne	SHORT $LN1@ClearOverr

; 1399 : 	{
; 1400 : 		Missovrradarmode = mode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+92], edx

; 1401 : 		//restore our range
; 1402 : 		airRangeIdx = lastAirRangeIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [eax+408], edx

; 1403 : 		MissOvrRangeIdx = curRangeIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR [eax+928], edx
$LN1@ClearOverr:

; 1404 : 	}
; 1405 : 
; 1406 : 	Overridemode = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 1407 : 	ChangeMode (noovrradarmode);//me123

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode

; 1408 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearOverride@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::ClearOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetMRMOverride@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SetMRMOverride
; _this$ = ecx

; 1367 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1368 :    SetPower(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 1369 :     //MI
; 1370 :    if(mode == SAM)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 10			; 0000000aH
	jne	SHORT $LN3@SetMRMOver

; 1371 : 	   noovrradarmode = prevMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR [edx+100], ecx

; 1372 :    else

	jmp	SHORT $LN2@SetMRMOver
$LN3@SetMRMOver:

; 1373 : 	   noovrradarmode = mode;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+100], ecx
$LN2@SetMRMOver:

; 1374 : 	if (!lockedTarget)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN1@SetMRMOver

; 1375 : 	{
; 1376 : 		//MI changed so it remembers our last mode
; 1377 : 		//airRangeIdx = 1;//me123
; 1378 : 		//MI
; 1379 : 		lastAirRangeIdx = airRangeIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	mov	DWORD PTR [eax+932], edx

; 1380 : 		airRangeIdx = MissOvrRangeIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+928]
	mov	DWORD PTR [eax+408], edx
$LN1@SetMRMOver:

; 1381 : 	}
; 1382 : 	ChangeMode (Missovrradarmode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode

; 1383 : 	Overridemode = 1;//me123 missovride flag

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 1

; 1384 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetMRMOverride@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SetMRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetSRMOverride@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::SetSRMOverride
; _this$ = ecx

; 1355 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1356 :    SetPower(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 1357 :    //MI
; 1358 :    if(mode == SAM)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 10			; 0000000aH
	jne	SHORT $LN2@SetSRMOver

; 1359 : 	   noovrradarmode = prevMode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR [edx+100], ecx

; 1360 :    else

	jmp	SHORT $LN1@SetSRMOver
$LN2@SetSRMOver:

; 1361 : 	   noovrradarmode = mode;//me123

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR [edx+100], ecx
$LN1@SetSRMOver:

; 1362 :    ChangeMode (Dogfovrradarmode); 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode

; 1363 :    Overridemode = 2;//me123 dogfight flag

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 2

; 1364 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetSRMOverride@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::SetSRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
?StepAAmode@RadarDopplerClass@@UAEXXZ PROC		; RadarDopplerClass::StepAAmode
; _this$ = ecx

; 1042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1043 : 	//MI make sure we stay in dogfight modes when in dogfight override
; 1044 : 	if(Overridemode == 2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 2
	jne	SHORT $LN29@StepAAmode

; 1045 : 	{
; 1046 : 		if(mode == ACM_30x20)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 6
	jne	SHORT $LN28@StepAAmode

; 1047 : 			modeDesiredCmd = ACM_SLEW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 7
	jmp	SHORT $LN22@StepAAmode
$LN28@StepAAmode:

; 1048 : 		else if(mode == ACM_SLEW)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 7
	jne	SHORT $LN26@StepAAmode

; 1049 : 			modeDesiredCmd = ACM_BORE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 8
	jmp	SHORT $LN22@StepAAmode
$LN26@StepAAmode:

; 1050 : 		else if(mode == ACM_BORE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 8
	jne	SHORT $LN24@StepAAmode

; 1051 : 			modeDesiredCmd = ACM_10x60;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 9
	jmp	SHORT $LN22@StepAAmode
$LN24@StepAAmode:

; 1052 : 		else if(mode == ACM_10x60)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 9
	jne	SHORT $LN22@StepAAmode

; 1053 : 			modeDesiredCmd = ACM_30x20;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 6
$LN22@StepAAmode:

; 1054 : 
; 1055 : 		return;

	jmp	$LN30@StepAAmode
$LN29@StepAAmode:

; 1056 : 	}
; 1057 : 
; 1058 :     switch (mode) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR tv83[ebp], ecx
	mov	edx, DWORD PTR tv83[ebp]
	sub	edx, 2
	mov	DWORD PTR tv83[ebp], edx
	cmp	DWORD PTR tv83[ebp], 8
	ja	$LN1@StepAAmode
	mov	eax, DWORD PTR tv83[ebp]
	jmp	DWORD PTR $LN32@StepAAmode[eax*4]
$LN19@StepAAmode:

; 1059 : 	{
; 1060 :     case RWS:
; 1061 :     case SAM:
; 1062 : 	if (g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN18@StepAAmode

; 1063 : 	{
; 1064 : 	    modeDesiredCmd = LRS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 3

; 1065 : 		//MI
; 1066 : 		if(mode == SAM && prevMode == LRS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 10			; 0000000aH
	jne	SHORT $LN17@StepAAmode
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 3
	jne	SHORT $LN17@StepAAmode

; 1067 : 			modeDesiredCmd = VS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 5
$LN17@StepAAmode:

; 1068 : 	}
; 1069 : 	else

	jmp	SHORT $LN16@StepAAmode
$LN18@StepAAmode:

; 1070 : 	    modeDesiredCmd = VS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 5
$LN16@StepAAmode:

; 1071 : 	break;

	jmp	$LN20@StepAAmode
$LN15@StepAAmode:

; 1072 :     case LRS:
; 1073 : 		modeDesiredCmd = VS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 5

; 1074 : 	break;

	jmp	$LN20@StepAAmode
$LN14@StepAAmode:

; 1075 : 	
; 1076 :     case VS:
; 1077 : 		modeDesiredCmd = TWS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 4

; 1078 : 	break;

	jmp	$LN20@StepAAmode
$LN13@StepAAmode:

; 1079 : 	
; 1080 :     case TWS:
; 1081 : 	// Marco Edit - don't cycle to ACM modes
; 1082 : 	// modeDesiredCmd = ACM_30x20;
; 1083 : 	if (g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN12@StepAAmode

; 1084 : 		modeDesiredCmd = RWS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 2

; 1085 : 	else

	jmp	SHORT $LN11@StepAAmode
$LN12@StepAAmode:

; 1086 : 		modeDesiredCmd = ACM_30x20;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 6
$LN11@StepAAmode:

; 1087 : 	break;

	jmp	$LN20@StepAAmode
$LN10@StepAAmode:

; 1088 : 	
; 1089 :     case ACM_30x20:
; 1090 :     case ACM_SLEW:
; 1091 :     case ACM_BORE:
; 1092 :     case ACM_10x60:
; 1093 :       if (lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN9@StepAAmode

; 1094 :       {
; 1095 :          prevMode = RWS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 2

; 1096 :          modeDesiredCmd = SAM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 10			; 0000000aH

; 1097 :          lastSAMAzScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx*4+332]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+296], xmm1

; 1098 :          lastSAMBars = rwsBars[curBarIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+364]
	mov	DWORD PTR [ecx+308], eax

; 1099 :          lastAzScan = lastSAMAzScan;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+296]
	mov	DWORD PTR [ecx+292], eax

; 1100 :          lastBars = lastSAMBars;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+308]
	mov	DWORD PTR [ecx+304], eax
$LN9@StepAAmode:

; 1101 :       }
; 1102 : 	  //MI OSB2 fix
; 1103 : 	  if(mode == ACM_30x20)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 6
	jne	SHORT $LN8@StepAAmode

; 1104 : 		  modeDesiredCmd = ACM_SLEW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 7
	jmp	SHORT $LN2@StepAAmode
$LN8@StepAAmode:

; 1105 : 	  else if(mode == ACM_SLEW)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 7
	jne	SHORT $LN6@StepAAmode

; 1106 : 		  modeDesiredCmd = ACM_BORE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], 8
	jmp	SHORT $LN2@StepAAmode
$LN6@StepAAmode:

; 1107 : 	  else if(mode == ACM_BORE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 8
	jne	SHORT $LN4@StepAAmode

; 1108 : 		  modeDesiredCmd = ACM_10x60;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 9
	jmp	SHORT $LN2@StepAAmode
$LN4@StepAAmode:

; 1109 : 	  else if(mode == ACM_10x60)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 9
	jne	SHORT $LN2@StepAAmode

; 1110 : 		  modeDesiredCmd = RWS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 2
$LN2@StepAAmode:

; 1111 :      break;

	jmp	SHORT $LN20@StepAAmode
$LN1@StepAAmode:

; 1112 : 
; 1113 : 	  default:
; 1114 : 		modeDesiredCmd = RWS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 2
$LN20@StepAAmode:
$LN30@StepAAmode:

; 1115 : 		break;
; 1116 : 	}
; 1117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@StepAAmode:
	DD	$LN19@StepAAmode
	DD	$LN15@StepAAmode
	DD	$LN13@StepAAmode
	DD	$LN14@StepAAmode
	DD	$LN10@StepAAmode
	DD	$LN10@StepAAmode
	DD	$LN10@StepAAmode
	DD	$LN10@StepAAmode
	DD	$LN19@StepAAmode
?StepAAmode@RadarDopplerClass@@UAEXXZ ENDP		; RadarDopplerClass::StepAAmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\state.cpp
_TEXT	SEGMENT
$T1 = -240						; size = 8
tv578 = -232						; size = 4
_tmpRange$2 = -228					; size = 4
tv239 = -224						; size = 4
_fromBump$ = -220					; size = 4
tv301 = -216						; size = 4
_curCursorY$ = -212					; size = 4
tv195 = -208						; size = 4
_tmpRange$3 = -204					; size = 4
tv436 = -200						; size = 4
tv1463 = -196						; size = 4
tv285 = -192						; size = 4
tv1462 = -188						; size = 4
tv740 = -184						; size = 4
tv1439 = -180						; size = 4
tv611 = -176						; size = 4
tv1410 = -172						; size = 4
tv460 = -168						; size = 4
tv1406 = -164						; size = 4
tv403 = -160						; size = 4
tv1382 = -156						; size = 4
tv293 = -152						; size = 4
tv1263 = -148						; size = 4
tv271 = -144						; size = 4
tv1259 = -140						; size = 4
tv745 = -136						; size = 4
tv1235 = -132						; size = 4
tv713 = -128						; size = 4
tv1088 = -124						; size = 4
tv634 = -120						; size = 4
tv1087 = -116						; size = 4
tv582 = -112						; size = 4
tv1064 = -108						; size = 4
tv554 = -104						; size = 4
tv1035 = -100						; size = 4
tv459 = -96						; size = 4
tv1031 = -92						; size = 4
tv407 = -88						; size = 4
tv1007 = -84						; size = 4
tv379 = -80						; size = 4
tv844 = -76						; size = 4
tv300 = -72						; size = 4
tv840 = -68						; size = 4
tv286 = -64						; size = 4
tv828 = -60						; size = 4
tv278 = -56						; size = 4
tv798 = -52						; size = 4
tv264 = -48						; size = 4
tv794 = -44						; size = 4
tv770 = -40						; size = 4
tv635 = -36						; size = 4
tv1687 = -32						; size = 4
_Fcc$4 = -28						; size = 4
_maxIdx$ = -24						; size = 4
tv316 = -20						; size = 4
_tmpVal$5 = -16						; size = 4
_change$ = -12						; size = 4
_tmpVal$6 = -8						; size = 4
_this$ = -4						; size = 4
_cursorXCmd$ = 8					; size = 4
_cursorYCmd$ = 12					; size = 4
?UpdateState@RadarDopplerClass@@UAEXHH@Z PROC		; RadarDopplerClass::UpdateState
; _this$ = ecx

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	mov	DWORD PTR _this$[ebp], ecx

; 480  : 	int change = FALSE;

	mov	DWORD PTR _change$[ebp], 0

; 481  : 	int fromBump = FALSE;

	mov	DWORD PTR _fromBump$[ebp], 0

; 482  : 	int maxIdx;
; 483  : 	float curCursorY = cursorY;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	movss	DWORD PTR _curCursorY$[ebp], xmm0

; 484  : 	
; 485  : 	if (IsSOI() && !IsAG() && mode != STBY)	//MI added STBY check. No cursors in STBY

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	$LN127@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	test	eax, eax
	jne	$LN127@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 1
	je	$LN127@UpdateStat

; 486  : 	{
; 487  : 		if ((cursorXCmd != 0.0F || cursorYCmd != 0.0F) && !IsSet(STTingTarget))  // don't move cursor when you are in STT

	cvtsi2ss xmm0, DWORD PTR _cursorXCmd$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN131@UpdateStat
	cvtsi2ss xmm0, DWORD PTR _cursorYCmd$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN132@UpdateStat
$LN131@UpdateStat:
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	$LN132@UpdateStat

; 488  : 		{
; 489  : 			if ((IO.AnalogIsUsed(AXIS_CURSOR_X) == true) && (IO.AnalogIsUsed(AXIS_CURSOR_Y) == true))

	push	11					; 0000000bH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	edx, al
	cmp	edx, 1
	jne	$LN130@UpdateStat
	push	12					; 0000000cH
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	eax, al
	cmp	eax, 1
	jne	$LN130@UpdateStat

; 490  : 			{
; 491  : 				cursorX += (cursorXCmd / 10000.0F) * g_fCursorSpeed * (6.5F * CursorRate) * SimLibMajorFrameTime;

	cvtsi2ss xmm0, DWORD PTR _cursorXCmd$[ebp]
	divss	xmm0, DWORD PTR __real@461c4000
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	movss	xmm1, DWORD PTR __real@40d00000
	mulss	xmm1, DWORD PTR ?CursorRate@RadarClass@@1MB
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+220]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+220], xmm0

; 492  : 				cursorY += (cursorYCmd / 10000.0F) * g_fCursorSpeed * (6.5F * CursorRate) * SimLibMajorFrameTime;

	cvtsi2ss xmm0, DWORD PTR _cursorYCmd$[ebp]
	divss	xmm0, DWORD PTR __real@461c4000
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	movss	xmm1, DWORD PTR __real@40d00000
	mulss	xmm1, DWORD PTR ?CursorRate@RadarClass@@1MB
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+224]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+224], xmm0

; 493  : 			}
; 494  : 			else

	jmp	$LN129@UpdateStat
$LN130@UpdateStat:

; 495  : 			{
; 496  : 				cursorX += cursorXCmd * g_fCursorSpeed * curCursorRate * SimLibMajorFrameTime;

	cvtsi2ss xmm0, DWORD PTR _cursorXCmd$[ebp]
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+228]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+220]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+220], xmm0

; 497  : 				cursorY += cursorYCmd * g_fCursorSpeed * curCursorRate * SimLibMajorFrameTime;

	cvtsi2ss xmm0, DWORD PTR _cursorYCmd$[ebp]
	mulss	xmm0, DWORD PTR ?g_fCursorSpeed@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+228]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+224]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+224], xmm0

; 498  : 				static float test = 0.0f;
; 499  : 				static float testa = 0.0f;
; 500  : 				curCursorRate = min (curCursorRate + CursorRate * SimLibMajorFrameTime * (4.0F+test), (6.5F+testa) * CursorRate);

	movss	xmm0, DWORD PTR ?CursorRate@RadarClass@@1MB
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR __real@40800000
	addss	xmm1, DWORD PTR ?test@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+228]
	movss	xmm1, DWORD PTR __real@40d00000
	addss	xmm1, DWORD PTR ?testa@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA
	mulss	xmm1, DWORD PTR ?CursorRate@RadarClass@@1MB
	comiss	xmm1, xmm0
	jbe	SHORT $LN136@UpdateStat
	movss	xmm0, DWORD PTR ?CursorRate@RadarClass@@1MB
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR __real@40800000
	addss	xmm1, DWORD PTR ?test@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+228]
	movss	DWORD PTR tv195[ebp], xmm0
	jmp	SHORT $LN137@UpdateStat
$LN136@UpdateStat:
	movss	xmm0, DWORD PTR __real@40d00000
	addss	xmm0, DWORD PTR ?testa@?N@??UpdateState@RadarDopplerClass@@UAEXHH@Z@4MA
	mulss	xmm0, DWORD PTR ?CursorRate@RadarClass@@1MB
	movss	DWORD PTR tv195[ebp], xmm0
$LN137@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv195[ebp]
	movss	DWORD PTR [ecx+228], xmm0
$LN129@UpdateStat:

; 501  : 			}				
; 502  : 			if ((mode == TWS) && lockedTarget) // MD -- 20040125: in TWS constrain the cursors to the radar FOV when bugging

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 4
	jne	$LN128@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN128@UpdateStat

; 503  : 			{
; 504  : 				float tmpVal = TargetAz(platform, lockedTarget);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 8
	fstp	DWORD PTR _tmpVal$5[ebp]

; 505  : 				cursorX = min ( max (cursorX, (tmpVal - (2 * azScan))), (tmpVal + (2 * azScan)));

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR [eax+204]
	movss	xmm2, DWORD PTR _tmpVal$5[ebp]
	subss	xmm2, xmm1
	comiss	xmm0, xmm2
	jbe	SHORT $LN138@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	movss	DWORD PTR tv239[ebp], xmm0
	jmp	SHORT $LN139@UpdateStat
$LN138@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [edx+204]
	movss	xmm1, DWORD PTR _tmpVal$5[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR tv239[ebp], xmm1
$LN139@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [eax+204]
	addss	xmm0, DWORD PTR _tmpVal$5[ebp]
	comiss	xmm0, DWORD PTR tv239[ebp]
	jbe	SHORT $LN142@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR [edx+204]
	movss	xmm2, DWORD PTR _tmpVal$5[ebp]
	subss	xmm2, xmm1
	comiss	xmm0, xmm2
	jbe	SHORT $LN140@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	movss	DWORD PTR tv264[ebp], xmm0
	jmp	SHORT $LN141@UpdateStat
$LN140@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [ecx+204]
	movss	xmm1, DWORD PTR _tmpVal$5[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR tv264[ebp], xmm1
$LN141@UpdateStat:
	movss	xmm0, DWORD PTR tv264[ebp]
	movss	DWORD PTR tv271[ebp], xmm0
	jmp	SHORT $LN143@UpdateStat
$LN142@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [edx+204]
	addss	xmm0, DWORD PTR _tmpVal$5[ebp]
	movss	DWORD PTR tv271[ebp], xmm0
$LN143@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv271[ebp]
	movss	DWORD PTR [eax+220], xmm0
$LN128@UpdateStat:

; 506  : 			}
; 507  : 			cursorX = min ( max (cursorX, -1.0F), 1.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN144@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	movss	DWORD PTR tv278[ebp], xmm0
	jmp	SHORT $LN145@UpdateStat
$LN144@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv278[ebp], xmm0
$LN145@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv278[ebp]
	jbe	SHORT $LN148@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN146@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	movss	DWORD PTR tv285[ebp], xmm0
	jmp	SHORT $LN147@UpdateStat
$LN146@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv285[ebp], xmm0
$LN147@UpdateStat:
	movss	xmm0, DWORD PTR tv285[ebp]
	movss	DWORD PTR tv286[ebp], xmm0
	jmp	SHORT $LN149@UpdateStat
$LN148@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv286[ebp], xmm0
$LN149@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv286[ebp]
	movss	DWORD PTR [edx+220], xmm0

; 508  : 			cursorY = min ( max (cursorY, -1.0F), 1.0F);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN150@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+224]
	movss	DWORD PTR tv293[ebp], xmm0
	jmp	SHORT $LN151@UpdateStat
$LN150@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv293[ebp], xmm0
$LN151@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv293[ebp]
	jbe	SHORT $LN154@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+224]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN152@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	movss	DWORD PTR tv300[ebp], xmm0
	jmp	SHORT $LN153@UpdateStat
$LN152@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv300[ebp], xmm0
$LN153@UpdateStat:
	movss	xmm0, DWORD PTR tv300[ebp]
	movss	DWORD PTR tv301[ebp], xmm0
	jmp	SHORT $LN155@UpdateStat
$LN154@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv301[ebp], xmm0
$LN155@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv301[ebp]
	movss	DWORD PTR [ecx+224], xmm0

; 509  : 			flags |= WasMoving;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+492]
	or	eax, 16384				; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], eax

; 510  : 		}
; 511  : 		else

	jmp	SHORT $LN127@UpdateStat
$LN132@UpdateStat:

; 512  : 		{
; 513  : 			curCursorRate = CursorRate;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?CursorRate@RadarClass@@1MB
	movss	DWORD PTR [edx+228], xmm0

; 514  : 			flags &= ~WasMoving;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, -16385				; ffffbfffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
$LN127@UpdateStat:

; 515  : 		}
; 516  : 		
; 517  : 	}
; 518  : 	
; 519  : 	if (modeDesiredCmd >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jl	SHORT $LN126@UpdateStat

; 520  : 	{
; 521  : 		//      ClearSensorTarget();
; 522  : 		ChangeMode (modeDesiredCmd);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode

; 523  : 		modeDesiredCmd = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], -1
$LN126@UpdateStat:

; 524  : 	}
; 525  : 	
; 526  : 	switch (mode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR tv316[ebp], edx
	mov	eax, DWORD PTR tv316[ebp]
	sub	eax, 2
	mov	DWORD PTR tv316[ebp], eax
	cmp	DWORD PTR tv316[ebp], 15		; 0000000fH
	ja	$LN124@UpdateStat
	mov	ecx, DWORD PTR tv316[ebp]
	movzx	edx, BYTE PTR $LN228@UpdateStat[ecx]
	jmp	DWORD PTR $LN229@UpdateStat[edx*4]
$LN123@UpdateStat:

; 527  : 	{
; 528  : 	case RWS:
; 529  : 	case LRS:
; 530  : 		// Range change from cursor bump
; 531  : 		if (cursorY > 0.9F && curRangeIdx < 4)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN122@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+388], 4
	jge	SHORT $LN122@UpdateStat

; 532  : 		{
; 533  : 			rangeChangeCmd = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 1

; 534  : 			cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
	jmp	SHORT $LN120@UpdateStat
$LN122@UpdateStat:

; 535  : 			//fromBump = TRUE;
; 536  : 		}
; 537  : 		else if (cursorY < -0.9F && curRangeIdx > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf666666
	comiss	xmm0, DWORD PTR [ecx+224]
	jbe	SHORT $LN120@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+388], 0
	jle	SHORT $LN120@UpdateStat

; 538  : 		{
; 539  : 			rangeChangeCmd = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], -1

; 540  : 			cursorY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+224], xmm0
$LN120@UpdateStat:

; 541  : 			//fromBump = TRUE;
; 542  : 		}
; 543  : 		//MI
; 544  : 		if((cursorX == 1.0F && cursorXCmd > 0) || (cursorX == -1.0F && cursorXCmd < 0))

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN117@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jg	SHORT $LN118@UpdateStat
$LN117@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN119@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jge	SHORT $LN119@UpdateStat
$LN118@UpdateStat:

; 545  : 			StepAzimuth(cursorX, cursorXCmd);

	mov	ecx, DWORD PTR _cursorXCmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+220]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepAzimuth@RadarDopplerClass@@QAEXMH@Z ; RadarDopplerClass::StepAzimuth
$LN119@UpdateStat:

; 546  : 		if (azScan + beamWidth != MAX_ANT_EL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+204]
	addss	xmm0, DWORD PTR [ecx+260]
	ucomiss	xmm0, DWORD PTR __real@3f860a91
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN116@UpdateStat

; 547  : 			seekerAzCenter = cursorX * MAX_ANT_EL;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 548  : 		else

	jmp	SHORT $LN115@UpdateStat
$LN116@UpdateStat:

; 549  : 			seekerAzCenter = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+56], xmm0
$LN115@UpdateStat:

; 550  : 		
; 551  : 		seekerAzCenter = max ( min (seekerAzCenter, MAX_ANT_EL - azScan), -MAX_ANT_EL + azScan);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR [edx+56]
	jbe	SHORT $LN156@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv379[ebp], xmm0
	jmp	SHORT $LN157@UpdateStat
$LN156@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv379[ebp], xmm0
$LN157@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [eax+204]
	movss	xmm1, DWORD PTR tv379[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN160@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	comiss	xmm0, DWORD PTR [ecx+56]
	jbe	SHORT $LN158@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv403[ebp], xmm0
	jmp	SHORT $LN159@UpdateStat
$LN158@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv403[ebp], xmm0
$LN159@UpdateStat:
	movss	xmm0, DWORD PTR tv403[ebp]
	movss	DWORD PTR tv407[ebp], xmm0
	jmp	SHORT $LN161@UpdateStat
$LN160@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv407[ebp], xmm0
$LN161@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv407[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 552  : 		
; 553  : 		if (!g_bAntElevKnobFix) {

	movzx	ecx, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	ecx, ecx
	jne	$LN114@UpdateStat

; 554  : 			seekerElCenter = min ( max (seekerElCenter + elSlewCmd * EL_CHANGE_RATE,
; 555  : 				-MAX_ANT_EL), MAX_ANT_EL);

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN162@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv436[ebp], xmm0
	jmp	SHORT $LN163@UpdateStat
$LN162@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv436[ebp], xmm0
$LN163@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv436[ebp]
	jbe	SHORT $LN166@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN164@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR tv459[ebp], xmm0
	jmp	SHORT $LN165@UpdateStat
$LN164@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv459[ebp], xmm0
$LN165@UpdateStat:
	movss	xmm0, DWORD PTR tv459[ebp]
	movss	DWORD PTR tv460[ebp], xmm0
	jmp	SHORT $LN167@UpdateStat
$LN166@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR tv460[ebp], xmm0
$LN167@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv460[ebp]
	movss	DWORD PTR [ecx+60], xmm0

; 556  : 			
; 557  : 			if (centerCmd)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+172], 0
	je	SHORT $LN113@UpdateStat

; 558  : 			{
; 559  : 				seekerElCenter = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+60], xmm0

; 560  : 				centerCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], 0
$LN113@UpdateStat:

; 561  : 			}
; 562  : 		}
; 563  : 		else

	jmp	SHORT $LN112@UpdateStat
$LN114@UpdateStat:

; 564  : 			seekerElCenter = AntElevKnob();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+60]
$LN112@UpdateStat:

; 565  : 		
; 566  : 		if (scanWidthCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+148], 0
	je	SHORT $LN111@UpdateStat

; 567  : 		{
; 568  : 			curAzIdx = (curAzIdx + scanWidthCmd) % NUM_RWS_AZS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+148]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], edx

; 569  : 			azScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx*4+332]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm1

; 570  : 			change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 571  :             rwsAzIdx = curAzIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	DWORD PTR [eax+412], edx
$LN111@UpdateStat:

; 572  : 		}
; 573  : 		
; 574  : 		if (scanHeightCmd)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN110@UpdateStat

; 575  : 		{
; 576  : 			curBarIdx = (curBarIdx + scanHeightCmd) % NUM_RWS_BARS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+392]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+144]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+392], edx

; 577  : 			bars = rwsBars[curBarIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+364]
	mov	DWORD PTR [eax+188], edx

; 578  : 			change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 579  :             rwsBarIdx = curBarIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+436], edx
$LN110@UpdateStat:

; 580  : 		}
; 581  : 		break;

	jmp	$LN124@UpdateStat
$LN109@UpdateStat:

; 582  : 	case TWS:
; 583  : 		// Slewing Scan
; 584  : 		// Make sure that we only do this when were not locking or trying to lock
; 585  : 		if (!lockedTarget|| g_bMLU && !IsSet(STTingTarget))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN107@UpdateStat
	movzx	ecx, BYTE PTR ?g_bMLU@@3_NA		; g_bMLU
	test	ecx, ecx
	je	$LN108@UpdateStat
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	$LN108@UpdateStat
$LN107@UpdateStat:

; 586  : 		{
; 587  :             seekerAzCenter = cursorX * MAX_ANT_EL;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 588  :             seekerAzCenter = max ( min (seekerAzCenter, MAX_ANT_EL - azScan), -MAX_ANT_EL + azScan);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	comiss	xmm0, DWORD PTR [ecx+56]
	jbe	SHORT $LN168@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv554[ebp], xmm0
	jmp	SHORT $LN169@UpdateStat
$LN168@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv554[ebp], xmm0
$LN169@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+204]
	movss	xmm1, DWORD PTR tv554[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN172@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	comiss	xmm0, DWORD PTR [eax+56]
	jbe	SHORT $LN170@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR tv578[ebp], xmm0
	jmp	SHORT $LN171@UpdateStat
$LN170@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+204]
	movss	DWORD PTR tv578[ebp], xmm0
$LN171@UpdateStat:
	movss	xmm0, DWORD PTR tv578[ebp]
	movss	DWORD PTR tv582[ebp], xmm0
	jmp	SHORT $LN173@UpdateStat
$LN172@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv582[ebp], xmm0
$LN173@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv582[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 589  : 			if (!g_bAntElevKnobFix) {

	movzx	eax, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	eax, eax
	jne	$LN106@UpdateStat

; 590  : 				seekerElCenter = min ( max (seekerElCenter + elSlewCmd * EL_CHANGE_RATE, -MAX_ANT_EL), MAX_ANT_EL);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN174@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR tv611[ebp], xmm0
	jmp	SHORT $LN175@UpdateStat
$LN174@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv611[ebp], xmm0
$LN175@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv611[ebp]
	jbe	SHORT $LN178@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN176@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv634[ebp], xmm0
	jmp	SHORT $LN177@UpdateStat
$LN176@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv634[ebp], xmm0
$LN177@UpdateStat:
	movss	xmm0, DWORD PTR tv634[ebp]
	movss	DWORD PTR tv635[ebp], xmm0
	jmp	SHORT $LN179@UpdateStat
$LN178@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR tv635[ebp], xmm0
$LN179@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv635[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 591  : 				
; 592  : 				if (centerCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+172], 0
	je	SHORT $LN105@UpdateStat

; 593  : 				{
; 594  : 					seekerElCenter = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0

; 595  : 					centerCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+172], 0
$LN105@UpdateStat:

; 596  : 				}
; 597  : 			}
; 598  : 			else

	jmp	SHORT $LN104@UpdateStat
$LN106@UpdateStat:

; 599  : 				// MD --20031223: always center on knob in absence of bugged target
; 600  : 				seekerElCenter = AntElevKnob();  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+60]
$LN104@UpdateStat:
	jmp	$LN102@UpdateStat
$LN108@UpdateStat:

; 601  : 		}
; 602  : 		else if (lockedTarget && !IsSet(STTingTarget))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	$LN102@UpdateStat
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	$LN102@UpdateStat

; 603  : 		{
; 604  : 			// MD -- 20040117: once a priority bugged target is established, the radar elevation centers 
; 605  : 			// more or less on that target until the bug is dropped or moved.
; 606  : 			// The AZ scan centers on the cursor but will not move past the point that the bugged target falls
; 607  : 			// outside the scan area.
; 608  : 			float tmpVal = TargetAz(platform, lockedTarget);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 8
	fstp	DWORD PTR _tmpVal$6[ebp]

; 609  :             seekerAzCenter = cursorX * MAX_ANT_EL;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 610  : 			seekerAzCenter = max ( min (seekerAzCenter, (tmpVal + azScan)), (tmpVal - azScan));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	addss	xmm0, DWORD PTR [ecx+204]
	comiss	xmm0, DWORD PTR [eax+56]
	jbe	SHORT $LN180@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR tv713[ebp], xmm0
	jmp	SHORT $LN181@UpdateStat
$LN180@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	addss	xmm0, DWORD PTR [eax+204]
	movss	DWORD PTR tv713[ebp], xmm0
$LN181@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	subss	xmm0, DWORD PTR [ecx+204]
	movss	xmm1, DWORD PTR tv713[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN184@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	addss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR [edx+56]
	jbe	SHORT $LN182@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv740[ebp], xmm0
	jmp	SHORT $LN183@UpdateStat
$LN182@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	addss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv740[ebp], xmm0
$LN183@UpdateStat:
	movss	xmm0, DWORD PTR tv740[ebp]
	movss	DWORD PTR tv745[ebp], xmm0
	jmp	SHORT $LN185@UpdateStat
$LN184@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	subss	xmm0, DWORD PTR [eax+204]
	movss	DWORD PTR tv745[ebp], xmm0
$LN185@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv745[ebp]
	movss	DWORD PTR [ecx+56], xmm0

; 611  : 			seekerAzCenter = min ( max (seekerAzCenter ,-MAX_ANT_EL + azScan), MAX_ANT_EL - azScan);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [eax+204]
	comiss	xmm0, xmm1
	jbe	SHORT $LN186@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv770[ebp], xmm0
	jmp	SHORT $LN187@UpdateStat
$LN186@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv770[ebp], xmm0
$LN187@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR tv770[ebp]
	jbe	SHORT $LN190@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@bf860a91
	addss	xmm1, DWORD PTR [edx+204]
	comiss	xmm0, xmm1
	jbe	SHORT $LN188@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv794[ebp], xmm0
	jmp	SHORT $LN189@UpdateStat
$LN188@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv794[ebp], xmm0
$LN189@UpdateStat:
	movss	xmm0, DWORD PTR tv794[ebp]
	movss	DWORD PTR tv798[ebp], xmm0
	jmp	SHORT $LN191@UpdateStat
$LN190@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv798[ebp], xmm0
$LN191@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv798[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 612  : 			
; 613  : 			tmpVal = TargetEl(platform, lockedTarget);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	?TargetEl@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetEl
	add	esp, 8
	fstp	DWORD PTR _tmpVal$6[ebp]

; 614  : 			seekerElCenter = min ( max (tmpVal, -MAX_ANT_EL + elScan), MAX_ANT_EL - elScan);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+208]
	movss	xmm1, DWORD PTR _tmpVal$6[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN192@UpdateStat
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	movss	DWORD PTR tv828[ebp], xmm0
	jmp	SHORT $LN193@UpdateStat
$LN192@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [eax+208]
	movss	DWORD PTR tv828[ebp], xmm0
$LN193@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+208]
	comiss	xmm0, DWORD PTR tv828[ebp]
	jbe	SHORT $LN196@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+208]
	movss	xmm1, DWORD PTR _tmpVal$6[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN194@UpdateStat
	movss	xmm0, DWORD PTR _tmpVal$6[ebp]
	movss	DWORD PTR tv840[ebp], xmm0
	jmp	SHORT $LN195@UpdateStat
$LN194@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [eax+208]
	movss	DWORD PTR tv840[ebp], xmm0
$LN195@UpdateStat:
	movss	xmm0, DWORD PTR tv840[ebp]
	movss	DWORD PTR tv844[ebp], xmm0
	jmp	SHORT $LN197@UpdateStat
$LN196@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+208]
	movss	DWORD PTR tv844[ebp], xmm0
$LN197@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv844[ebp]
	movss	DWORD PTR [edx+60], xmm0
$LN102@UpdateStat:

; 615  : 		}
; 616  : 		
; 617  : 		// Range change from cursor bump
; 618  : 		if (cursorY > 0.9F && curRangeIdx < 4)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN101@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+388], 4
	jge	SHORT $LN101@UpdateStat

; 619  : 		{
; 620  : 			rangeChangeCmd = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 1

; 621  : 			cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
	jmp	SHORT $LN99@UpdateStat
$LN101@UpdateStat:

; 622  : 			//fromBump = TRUE;
; 623  : 		}
; 624  : 		else if (cursorY < -0.9F && curRangeIdx > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf666666
	comiss	xmm0, DWORD PTR [ecx+224]
	jbe	SHORT $LN99@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+388], 0
	jle	SHORT $LN99@UpdateStat

; 625  : 		{
; 626  : 			rangeChangeCmd = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], -1

; 627  : 			cursorY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+224], xmm0
$LN99@UpdateStat:

; 628  : 			//fromBump = TRUE;
; 629  : 		}
; 630  : 		//MI
; 631  : 		// MD -- 20040123: don't bump the scan pattern when there's a bugged track file
; 632  : 		if (!lockedTarget && ((cursorX == 1.0F && cursorXCmd > 0) || (cursorX == -1.0F && cursorXCmd < 0)))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN98@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN96@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jg	SHORT $LN97@UpdateStat
$LN96@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN98@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jge	SHORT $LN98@UpdateStat
$LN97@UpdateStat:

; 633  : 			StepAzimuth(cursorX, cursorXCmd);

	mov	edx, DWORD PTR _cursorXCmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+220]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepAzimuth@RadarDopplerClass@@QAEXMH@Z ; RadarDopplerClass::StepAzimuth
$LN98@UpdateStat:

; 634  : 		
; 635  : 		//me123 az/bar change same as rws -- MD, umm no, that's not correct...there are three fixed
; 636  : 		// scan patterns for TWS so any bump in Az or Bars will bump the other dimension also.  Thus
; 637  : 		// these change commands now step both twsAzIdx and twsBarIdx at the same time!
; 638  : 		
; 639  : 		// MD -- 20040123: don't bump the scan pattern when there's a bugged track file
; 640  : 		if (!lockedTarget && scanWidthCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	$LN95@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+148], 0
	je	$LN95@UpdateStat

; 641  : 		{ 
; 642  : 			curAzIdx = (curAzIdx + scanWidthCmd) % NUM_TWS_AZS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+400]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+148]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], edx

; 643  : 			azScan = twsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx*4+344]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm1

; 644  : 			curBarIdx = curAzIdx;  // keep patterns in lock step as you change

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	DWORD PTR [eax+392], edx

; 645  : 			bars = twsBars[curBarIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+376]
	mov	DWORD PTR [edx+188], ecx

; 646  : 			change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 647  : 			twsAzIdx = curAzIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR [edx+416], ecx

; 648  : 			twsBarIdx = curBarIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	mov	DWORD PTR [edx+440], ecx
$LN95@UpdateStat:

; 649  : 		}
; 650  : 		
; 651  : 		// MD -- 20040123: don't bump the scan pattern when there's a bugged track file
; 652  : 		if (!lockedTarget && scanHeightCmd)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	$LN94@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	$LN94@UpdateStat

; 653  : 		{
; 654  : 			curBarIdx = (curBarIdx + scanHeightCmd) % NUM_TWS_BARS; //me123 max 3 bars in tws; MD -- but don't hard code it here

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+392]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+144]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+392], edx

; 655  : 			bars = twsBars[curBarIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+376]
	mov	DWORD PTR [eax+188], edx

; 656  : 			curAzIdx = curBarIdx;  // keep patterns in lock step as you change

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+400], edx

; 657  : 			azScan = twsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx*4+344]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+204], xmm1

; 658  : 			change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 659  : 			twsBarIdx = curBarIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	mov	DWORD PTR [edx+440], ecx

; 660  : 			twsAzIdx = curAzIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR [edx+416], ecx
$LN94@UpdateStat:

; 661  : 		}
; 662  : 		
; 663  : 		break;

	jmp	$LN124@UpdateStat
$LN93@UpdateStat:

; 664  : 	case SAM:
; 665  : 		if (!IsSet(STTingTarget))

	push	65536					; 00010000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	$LN73@UpdateStat

; 666  : 		{
; 667  : 			if (subMode != SAM_AUTO_MODE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+504], 11			; 0000000bH
	je	$LN81@UpdateStat

; 668  : 			{
; 669  : 				if (cursorY > 0.9F && curRangeIdx < 4)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN90@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+388], 4
	jge	SHORT $LN90@UpdateStat

; 670  : 				{
; 671  : 					rangeChangeCmd = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 1

; 672  : 					cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
	jmp	SHORT $LN88@UpdateStat
$LN90@UpdateStat:

; 673  : 				}
; 674  : 				else if (cursorY < -0.9F && curRangeIdx > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf666666
	comiss	xmm0, DWORD PTR [ecx+224]
	jbe	SHORT $LN88@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+388], 0
	jle	SHORT $LN88@UpdateStat

; 675  : 				{
; 676  : 					rangeChangeCmd = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], -1

; 677  : 					cursorY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+224], xmm0
$LN88@UpdateStat:

; 678  : 				}
; 679  : 				//MI
; 680  : 				if((cursorX == 1.0F && cursorXCmd > 0) || (cursorX == -1.0F && cursorXCmd < 0))

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN85@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jg	SHORT $LN86@UpdateStat
$LN85@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN87@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jge	SHORT $LN87@UpdateStat
$LN86@UpdateStat:

; 681  : 					StepAzimuth(cursorX, cursorXCmd);

	mov	ecx, DWORD PTR _cursorXCmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+220]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepAzimuth@RadarDopplerClass@@QAEXMH@Z ; RadarDopplerClass::StepAzimuth
$LN87@UpdateStat:

; 682  : 				
; 683  : 				if (azScan != MAX_ANT_EL)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+204]
	ucomiss	xmm0, DWORD PTR __real@3f860a91
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN84@UpdateStat

; 684  : 					seekerAzCenter = cursorX * MAX_ANT_EL;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 685  : 				else

	jmp	SHORT $LN83@UpdateStat
$LN84@UpdateStat:

; 686  : 					seekerAzCenter = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+56], xmm0
$LN83@UpdateStat:

; 687  : 				seekerAzCenter = max ( min (seekerAzCenter, MAX_ANT_EL - azScan), -MAX_ANT_EL + azScan);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	comiss	xmm0, DWORD PTR [ecx+56]
	jbe	SHORT $LN198@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv1007[ebp], xmm0
	jmp	SHORT $LN199@UpdateStat
$LN198@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv1007[ebp], xmm0
$LN199@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+204]
	movss	xmm1, DWORD PTR tv1007[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN202@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	comiss	xmm0, DWORD PTR [eax+56]
	jbe	SHORT $LN200@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+56]
	movss	DWORD PTR tv1031[ebp], xmm0
	jmp	SHORT $LN201@UpdateStat
$LN200@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+204]
	movss	DWORD PTR tv1031[ebp], xmm0
$LN201@UpdateStat:
	movss	xmm0, DWORD PTR tv1031[ebp]
	movss	DWORD PTR tv1035[ebp], xmm0
	jmp	SHORT $LN203@UpdateStat
$LN202@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv1035[ebp], xmm0
$LN203@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1035[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 688  : 				if (!g_bAntElevKnobFix) {

	movzx	eax, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	eax, eax
	jne	$LN81@UpdateStat

; 689  : 					
; 690  : 					seekerElCenter = min ( max (seekerElCenter + elSlewCmd * EL_CHANGE_RATE,
; 691  : 						-MAX_ANT_EL), MAX_ANT_EL);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN204@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR tv1064[ebp], xmm0
	jmp	SHORT $LN205@UpdateStat
$LN204@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv1064[ebp], xmm0
$LN205@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv1064[ebp]
	jbe	SHORT $LN208@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN206@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv1087[ebp], xmm0
	jmp	SHORT $LN207@UpdateStat
$LN206@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv1087[ebp], xmm0
$LN207@UpdateStat:
	movss	xmm0, DWORD PTR tv1087[ebp]
	movss	DWORD PTR tv1088[ebp], xmm0
	jmp	SHORT $LN209@UpdateStat
$LN208@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR tv1088[ebp], xmm0
$LN209@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1088[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 692  : 					
; 693  : 					if (centerCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+172], 0
	je	SHORT $LN81@UpdateStat

; 694  : 					{
; 695  : 						seekerElCenter = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0

; 696  : 						centerCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+172], 0
$LN81@UpdateStat:

; 697  : 					}
; 698  : 				}
; 699  : 				
; 700  : 			}
; 701  : 			
; 702  : 			if (g_bAntElevKnobFix)

	movzx	ecx, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	ecx, ecx
	je	SHORT $LN80@UpdateStat

; 703  : 				// MD -- 20032121: fixing the antenna elevation controls
; 704  : 				seekerElCenter = AntElevKnob(); // always center on the knob in SAM

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+60]
$LN80@UpdateStat:

; 705  : 			
; 706  : 			/*--------------*/
; 707  : 			/* Manual SAM ? */
; 708  : 			/*--------------*/
; 709  : 			if (((cursorXCmd != 0) || (cursorYCmd != 0))&& !targetUnderCursor)

	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jne	SHORT $LN78@UpdateStat
	cmp	DWORD PTR _cursorYCmd$[ebp], 0
	je	SHORT $LN79@UpdateStat
$LN78@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVU_ID@@QBEKXZ			; VU_ID::operator unsigned long
	test	eax, eax
	jne	SHORT $LN79@UpdateStat

; 710  :             {
; 711  : 				subMode = SAM_MANUAL_MODE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+504], 12			; 0000000cH
	jmp	SHORT $LN76@UpdateStat
$LN79@UpdateStat:

; 712  :             }
; 713  : 			else if ((cursorXCmd == 0) && (cursorYCmd == 0) && lockedTarget && (targetUnderCursor == lockedTarget->BaseData()->Id()) )

	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jne	SHORT $LN76@UpdateStat
	cmp	DWORD PTR _cursorYCmd$[ebp], 0
	jne	SHORT $LN76@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN76@UpdateStat
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN76@UpdateStat

; 714  : 			{
; 715  : 				subMode = SAM_AUTO_MODE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+504], 11			; 0000000bH
$LN76@UpdateStat:

; 716  : 			}
; 717  : 			
; 718  : 			if (scanWidthCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+148], 0
	je	$LN75@UpdateStat

; 719  : 			{
; 720  : 				curAzIdx = (curAzIdx + scanWidthCmd) % NUM_RWS_AZS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+148]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], edx

; 721  : 				if (curAzIdx == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+400], 0
	jne	SHORT $LN74@UpdateStat

; 722  : 					curAzIdx ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+400], eax
$LN74@UpdateStat:

; 723  : 				azScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+eax*4+332]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+204], xmm1

; 724  : 				change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 725  : 				rwsAzIdx = curAzIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	DWORD PTR [ecx+412], eax
$LN75@UpdateStat:

; 726  : 			}
; 727  : 			
; 728  : 			if (scanHeightCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 0
	je	SHORT $LN73@UpdateStat

; 729  : 			{
; 730  : 				curBarIdx = (curBarIdx + scanHeightCmd) % NUM_RWS_BARS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+144]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+392], edx

; 731  : 				bars = rwsBars[curBarIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+364]
	mov	DWORD PTR [eax+188], edx

; 732  : 				change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 733  : 				rwsBarIdx = curBarIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+436], edx
$LN73@UpdateStat:

; 734  : 			}
; 735  : 		}
; 736  : 		break;

	jmp	$LN124@UpdateStat
$LN72@UpdateStat:

; 737  : 	case ACM_SLEW:
; 738  : 		if (!lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN71@UpdateStat

; 739  : 		{
; 740  : 			seekerAzCenter = cursorX * MAX_ANT_EL;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 741  : 			seekerElCenter = cursorY * MAX_ANT_EL;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+224]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+60], xmm0
$LN71@UpdateStat:

; 742  : 		}
; 743  : 		
; 744  : 		seekerAzCenter = max ( min (seekerAzCenter, MAX_ANT_EL - azScan), -MAX_ANT_EL + azScan);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR [edx+56]
	jbe	SHORT $LN210@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv1235[ebp], xmm0
	jmp	SHORT $LN211@UpdateStat
$LN210@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv1235[ebp], xmm0
$LN211@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [eax+204]
	movss	xmm1, DWORD PTR tv1235[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN214@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	comiss	xmm0, DWORD PTR [ecx+56]
	jbe	SHORT $LN212@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv1259[ebp], xmm0
	jmp	SHORT $LN213@UpdateStat
$LN212@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv1259[ebp], xmm0
$LN213@UpdateStat:
	movss	xmm0, DWORD PTR tv1259[ebp]
	movss	DWORD PTR tv1263[ebp], xmm0
	jmp	SHORT $LN215@UpdateStat
$LN214@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv1263[ebp], xmm0
$LN215@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1263[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 745  : 		if (TheHud)

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN70@UpdateStat

; 746  : 		{
; 747  :             TheHud->HudData.radarAz = seekerAzCenter;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+4988], eax

; 748  :             TheHud->HudData.radarEl = seekerElCenter;

	mov	ecx, DWORD PTR ?TheHud@@3PAVHudClass@@A	; TheHud
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+4992], eax
$LN70@UpdateStat:

; 749  : 		}
; 750  : 	case ACM_BORE:
; 751  : 	case ACM_30x20:
; 752  : 	case ACM_10x60:
; 753  : 		if (scanWidthCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+148], 0
	je	SHORT $LN62@UpdateStat

; 754  : 		{
; 755  :             scanWidthCmd = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 756  : 			
; 757  :             if (mode == ACM_SLEW)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 7
	jne	SHORT $LN67@UpdateStat

; 758  : 				ChangeMode (ACM_BORE);

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode
	jmp	SHORT $LN62@UpdateStat
$LN67@UpdateStat:

; 759  :             else if (mode == ACM_BORE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 8
	jne	SHORT $LN65@UpdateStat

; 760  : 				ChangeMode (ACM_30x20);

	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode
	jmp	SHORT $LN62@UpdateStat
$LN65@UpdateStat:

; 761  :             else if (mode == ACM_30x20)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 6
	jne	SHORT $LN63@UpdateStat

; 762  : 				ChangeMode (ACM_10x60);

	push	9
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode

; 763  :             else

	jmp	SHORT $LN62@UpdateStat
$LN63@UpdateStat:

; 764  : 				ChangeMode (ACM_SLEW);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeMode@RadarDopplerClass@@IAEXH@Z	; RadarDopplerClass::ChangeMode
$LN62@UpdateStat:

; 765  : 		}
; 766  : 		
; 767  : 		if (!lockedTarget)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN61@UpdateStat

; 768  : 		{
; 769  :             rangeChangeCmd = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0
$LN61@UpdateStat:

; 770  : 		}
; 771  : 		break;

	jmp	$LN124@UpdateStat
$LN60@UpdateStat:

; 772  : 	case VS:
; 773  : 		if (cursorY > 0.9F && vsVelIdx < 1)			

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+224]
	comiss	xmm0, DWORD PTR __real@3f666666
	jbe	SHORT $LN59@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+396], 1
	jge	SHORT $LN59@UpdateStat

; 774  : 		{
; 775  : 			rangeChangeCmd = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 1

; 776  : 			cursorY = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+224], xmm0
	jmp	SHORT $LN57@UpdateStat
$LN59@UpdateStat:

; 777  : 		}
; 778  : 		else if (cursorY < -0.9F && vsVelIdx > 0)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf666666
	comiss	xmm0, DWORD PTR [eax+224]
	jbe	SHORT $LN57@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+396], 0
	jle	SHORT $LN57@UpdateStat

; 779  : 		{
; 780  : 			rangeChangeCmd = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], -1

; 781  : 			cursorY = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+224], xmm0
$LN57@UpdateStat:

; 782  : 		}
; 783  : 		
; 784  : 		if (rangeChangeCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+140], 0
	je	SHORT $LN56@UpdateStat

; 785  : 		{
; 786  : 			vsVelIdx ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+396]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+396], eax

; 787  : 			if (vsVelIdx >= NUM_VELS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+396], 2
	jl	SHORT $LN55@UpdateStat

; 788  : 				vsVelIdx = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+396], 0
	jmp	SHORT $LN53@UpdateStat
$LN55@UpdateStat:

; 789  : 			else if (vsVelIdx == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+396], -1
	jne	SHORT $LN53@UpdateStat

; 790  : 				vsVelIdx = NUM_VELS - 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 1
$LN53@UpdateStat:

; 791  : 			
; 792  : 			displayRange = velScales[vsVelIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+356]
	mov	DWORD PTR [edx+212], ecx

; 793  : 			tdisplayRange = 80.0F * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@48ed5a1c
	movss	DWORD PTR [edx+264], xmm0
$LN56@UpdateStat:

; 794  : 		}
; 795  : 		
; 796  : 		//MI
; 797  : 		if((cursorX == 1.0F && cursorXCmd > 0) || (cursorX == -1.0F && cursorXCmd < 0))

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+220]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN50@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jg	SHORT $LN51@UpdateStat
$LN50@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+220]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN52@UpdateStat
	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jge	SHORT $LN52@UpdateStat
$LN51@UpdateStat:

; 798  : 			StepAzimuth(cursorX, cursorXCmd);

	mov	edx, DWORD PTR _cursorXCmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+220]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepAzimuth@RadarDopplerClass@@QAEXMH@Z ; RadarDopplerClass::StepAzimuth
$LN52@UpdateStat:

; 799  : 		
; 800  : 		// Scan Center
; 801  : 		if (azScan != MAX_ANT_EL)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+204]
	ucomiss	xmm0, DWORD PTR __real@3f860a91
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN49@UpdateStat

; 802  : 			seekerAzCenter = cursorX * MAX_ANT_EL;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+220]
	mulss	xmm0, DWORD PTR __real@3f860a91
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 803  : 		else

	jmp	SHORT $LN48@UpdateStat
$LN49@UpdateStat:

; 804  : 			seekerAzCenter = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+56], xmm0
$LN48@UpdateStat:

; 805  : 		
; 806  : 		seekerAzCenter = max ( min (seekerAzCenter, MAX_ANT_EL - azScan), -MAX_ANT_EL + azScan);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [eax+204]
	comiss	xmm0, DWORD PTR [edx+56]
	jbe	SHORT $LN216@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv1382[ebp], xmm0
	jmp	SHORT $LN217@UpdateStat
$LN216@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv1382[ebp], xmm0
$LN217@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [eax+204]
	movss	xmm1, DWORD PTR tv1382[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN220@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [edx+204]
	comiss	xmm0, DWORD PTR [ecx+56]
	jbe	SHORT $LN218@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv1406[ebp], xmm0
	jmp	SHORT $LN219@UpdateStat
$LN218@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f860a91
	subss	xmm0, DWORD PTR [ecx+204]
	movss	DWORD PTR tv1406[ebp], xmm0
$LN219@UpdateStat:
	movss	xmm0, DWORD PTR tv1406[ebp]
	movss	DWORD PTR tv1410[ebp], xmm0
	jmp	SHORT $LN221@UpdateStat
$LN220@UpdateStat:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf860a91
	addss	xmm0, DWORD PTR [edx+204]
	movss	DWORD PTR tv1410[ebp], xmm0
$LN221@UpdateStat:
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1410[ebp]
	movss	DWORD PTR [eax+56], xmm0

; 807  : 		
; 808  : 		if (!g_bAntElevKnobFix) {

	movzx	ecx, BYTE PTR ?g_bAntElevKnobFix@@3_NA	; g_bAntElevKnobFix
	test	ecx, ecx
	jne	$LN47@UpdateStat

; 809  : 			seekerElCenter = min ( max (seekerElCenter + elSlewCmd * EL_CHANGE_RATE,
; 810  : 				-MAX_ANT_EL), MAX_ANT_EL);

	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN222@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv1439[ebp], xmm0
	jmp	SHORT $LN223@UpdateStat
$LN222@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv1439[ebp], xmm0
$LN223@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	comiss	xmm0, DWORD PTR tv1439[ebp]
	jbe	SHORT $LN226@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+60]
	comiss	xmm0, DWORD PTR __real@bf860a91
	jbe	SHORT $LN224@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+152]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR tv1462[ebp], xmm0
	jmp	SHORT $LN225@UpdateStat
$LN224@UpdateStat:
	movss	xmm0, DWORD PTR __real@bf860a91
	movss	DWORD PTR tv1462[ebp], xmm0
$LN225@UpdateStat:
	movss	xmm0, DWORD PTR tv1462[ebp]
	movss	DWORD PTR tv1463[ebp], xmm0
	jmp	SHORT $LN227@UpdateStat
$LN226@UpdateStat:
	movss	xmm0, DWORD PTR __real@3f860a91
	movss	DWORD PTR tv1463[ebp], xmm0
$LN227@UpdateStat:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv1463[ebp]
	movss	DWORD PTR [ecx+60], xmm0

; 811  : 			
; 812  : 			if (centerCmd)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+172], 0
	je	SHORT $LN46@UpdateStat

; 813  : 			{
; 814  : 				seekerElCenter = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+60], xmm0

; 815  : 				centerCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], 0
$LN46@UpdateStat:

; 816  : 			}
; 817  : 		}
; 818  : 		else

	jmp	SHORT $LN45@UpdateStat
$LN47@UpdateStat:

; 819  : 			seekerElCenter = AntElevKnob();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+252]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+60]
$LN45@UpdateStat:

; 820  : 		
; 821  : 		// Scan Volume
; 822  : 		if (scanWidthCmd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+148], 0
	je	SHORT $LN44@UpdateStat

; 823  : 		{
; 824  : 			curAzIdx = (curAzIdx + scanWidthCmd) % NUM_RWS_AZS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+148]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], edx

; 825  : 			azScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+260]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx*4+332]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+204], xmm1

; 826  : 			change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 827  :             vsAzIdx = curAzIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	DWORD PTR [eax+424], edx
$LN44@UpdateStat:

; 828  : 		}
; 829  : 		
; 830  : 		if (scanHeightCmd)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN43@UpdateStat

; 831  : 		{
; 832  : 			curBarIdx = (curBarIdx + scanHeightCmd) % NUM_RWS_BARS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+392]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+144]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+392], edx

; 833  : 			bars = rwsBars[curBarIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+364]
	mov	DWORD PTR [eax+188], edx

; 834  : 			change = TRUE;

	mov	DWORD PTR _change$[ebp], 1

; 835  :             vsBarIdx = curBarIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	mov	DWORD PTR [eax+452], edx
$LN43@UpdateStat:

; 836  : 		}
; 837  : 		break;

	jmp	$LN124@UpdateStat
$LN42@UpdateStat:

; 838  : 	case GM:
; 839  : 	case GMT:
; 840  : 	case SEA:
; 841  : 		// No 80 mile range in DBS1, DBS2, GMT or SEA
; 842  : 		if (rangeChangeCmd)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+140], 0
	je	$LN41@UpdateStat

; 843  : 		{
; 844  :             if (flags & (DBS1 | DBS2) || mode == GMT || mode == SEA)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	and	edx, 12					; 0000000cH
	jne	SHORT $LN39@UpdateStat
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 16			; 00000010H
	je	SHORT $LN39@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 17			; 00000011H
	jne	SHORT $LN40@UpdateStat
$LN39@UpdateStat:

; 845  :             {
; 846  : 				maxIdx = NUM_RANGES - 2;

	mov	DWORD PTR _maxIdx$[ebp], 3

; 847  :             }
; 848  :             else

	jmp	SHORT $LN38@UpdateStat
$LN40@UpdateStat:

; 849  :             {
; 850  : 				maxIdx = NUM_RANGES - 1;

	mov	DWORD PTR _maxIdx$[ebp], 4
$LN38@UpdateStat:

; 851  :             }
; 852  : 			
; 853  :             curRangeIdx += rangeChangeCmd;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+140]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], eax

; 854  : 			if (curRangeIdx >= maxIdx)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	cmp	ecx, DWORD PTR _maxIdx$[ebp]
	jl	SHORT $LN37@UpdateStat

; 855  : 				curRangeIdx = maxIdx - 1;

	mov	edx, DWORD PTR _maxIdx$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], edx
	jmp	SHORT $LN35@UpdateStat
$LN37@UpdateStat:

; 856  : 			else if (curRangeIdx < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+388], 0
	jge	SHORT $LN35@UpdateStat

; 857  : 				curRangeIdx = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], 0
$LN35@UpdateStat:

; 858  : 			displayRange = rangeScales[curRangeIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+312]
	mov	DWORD PTR [edx+212], ecx

; 859  :   	         tdisplayRange = displayRange * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+264], xmm0

; 860  : 			 SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan

; 861  : 			 rangeChangeCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0

; 862  : 			 gmRangeIdx = curRangeIdx;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR [edx+404], ecx
$LN41@UpdateStat:

; 863  : 		}
; 864  : 		if(scanWidthCmd && g_bRealisticAvionics && g_bAGRadarFixes)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+148], 0
	je	$LN34@UpdateStat
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN34@UpdateStat
	movzx	ecx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	ecx, ecx
	je	$LN34@UpdateStat

; 865  : 		{
; 866  : 			curAzIdx = (curAzIdx + scanWidthCmd) % NUM_RWS_AZS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+148]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], edx

; 867  : 			//azScan = rwsAzs[curAzIdx] - beamWidth * 0.5F;			
; 868  : 			if(mode == GM || mode == SEA)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 14			; 0000000eH
	je	SHORT $LN32@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 17			; 00000011H
	jne	SHORT $LN33@UpdateStat
$LN32@UpdateStat:

; 869  : 				gmAzIdx = curAzIdx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	DWORD PTR [eax+428], edx
	jmp	SHORT $LN30@UpdateStat
$LN33@UpdateStat:

; 870  : 			else if(mode == GMT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 16			; 00000010H
	jne	SHORT $LN30@UpdateStat

; 871  : 				gmtAzIdx = curAzIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+400]
	mov	DWORD PTR [ecx+432], eax
$LN30@UpdateStat:

; 872  : 			
; 873  : 			azScan = displayAzScan = rwsAzs[curAzIdx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+332]
	mov	DWORD PTR [eax+216], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	mov	DWORD PTR [eax+204], edx

; 874  : 			//azScan = rwsAzs[rwsAzIdx];
; 875  : 			
; 876  : 			SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan

; 877  : 			scanWidthCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0
$LN34@UpdateStat:

; 878  : 		}
; 879  : 		if ((cursorXCmd != 0) || (cursorYCmd != 0))

	cmp	DWORD PTR _cursorXCmd$[ebp], 0
	jne	SHORT $LN28@UpdateStat
	cmp	DWORD PTR _cursorYCmd$[ebp], 0
	je	SHORT $LN29@UpdateStat
$LN28@UpdateStat:

; 880  : 		{
; 881  : 			SetAimPoint ((float)cursorXCmd, (float)cursorYCmd);

	cvtsi2ss xmm0, DWORD PTR _cursorYCmd$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _cursorXCmd$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAimPoint@RadarDopplerClass@@IAEXMM@Z ; RadarDopplerClass::SetAimPoint

; 882  :             SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan

; 883  :             flags |= WasMoving;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+492], edx

; 884  : 		}
; 885  : 		else

	jmp	SHORT $LN27@UpdateStat
$LN29@UpdateStat:

; 886  : 		{
; 887  : 			if (flags & WasMoving)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	and	edx, 16384				; 00004000H
	je	SHORT $LN26@UpdateStat

; 888  : 			{
; 889  : 				// MD -- 20040229: switched ordering here - need WasMoving set to FALSE to bump!
; 890  : 				flags &= ~WasMoving;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, -16385				; ffffbfffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx
$LN26@UpdateStat:

; 891  : 			}
; 892  :             rangeChangeCmd = CheckGMBump();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckGMBump@RadarDopplerClass@@IAEHXZ	; RadarDopplerClass::CheckGMBump
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax
$LN27@UpdateStat:
$LN124@UpdateStat:

; 893  : 		}
; 894  : 		break;
; 895  : 	}
; 896  : 	
; 897  : 	// WHY is this here?  Isn't this already delt with in the switch above???
; 898  : 	if (rangeChangeCmd)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+140], 0
	je	$LN25@UpdateStat

; 899  : 	{
; 900  : 		//MI remeber our MissileOverride range
; 901  : 		FireControlComputer *Fcc = NULL;

	mov	DWORD PTR _Fcc$4[ebp], 0

; 902  : 		// COBRA - RED - CTD Fix - If player is dead
; 903  : 		if(SimDriver.GetPlayerAircraft()) Fcc = SimDriver.GetPlayerAircraft()->FCC;

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	test	eax, eax
	je	SHORT $LN24@UpdateStat
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	eax, DWORD PTR [eax+936]
	mov	DWORD PTR _Fcc$4[ebp], eax
$LN24@UpdateStat:

; 904  : 
; 905  : 		if(Fcc)

	cmp	DWORD PTR _Fcc$4[ebp], 0
	je	$LN22@UpdateStat

; 906  : 		{
; 907  : 			if(Fcc->GetMasterMode() == FireControlComputer::MissileOverride)

	mov	ecx, DWORD PTR _Fcc$4[ebp]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 10					; 0000000aH
	jne	$LN22@UpdateStat

; 908  : 			{
; 909  : 				if(mode == VS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 5
	jne	SHORT $LN21@UpdateStat

; 910  : 				{
; 911  : 					displayRange = velScales[vsVelIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+396]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+356]
	mov	DWORD PTR [ecx+212], eax

; 912  : 					tdisplayRange = 80.0F * NM_TO_FT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@48ed5a1c
	movss	DWORD PTR [ecx+264], xmm0

; 913  : 					
; 914  : 					rangeChangeCmd = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 0

; 915  : 					return;

	jmp	$LN134@UpdateStat

; 916  : 				}
; 917  : 				else

	jmp	SHORT $LN17@UpdateStat
$LN21@UpdateStat:

; 918  : 				{
; 919  : 					curRangeIdx += rangeChangeCmd;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], ecx

; 920  : 					if (curRangeIdx >= NUM_RANGES)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+388], 5
	jl	SHORT $LN19@UpdateStat

; 921  : 						curRangeIdx = NUM_RANGES - 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], 4
	jmp	SHORT $LN17@UpdateStat
$LN19@UpdateStat:

; 922  : 					else if (curRangeIdx < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+388], 0
	jge	SHORT $LN17@UpdateStat

; 923  : 						curRangeIdx = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+388], 0
$LN17@UpdateStat:

; 924  : 				}
; 925  : 				
; 926  : 				displayRange = rangeScales[curRangeIdx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+312]
	mov	DWORD PTR [ecx+212], eax

; 927  : 				
; 928  : 				float tmpRange = (curCursorY + 1.0F) * tdisplayRange;

	movss	xmm0, DWORD PTR _curCursorY$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+264]
	movss	DWORD PTR _tmpRange$3[ebp], xmm0

; 929  : 				
; 930  : 				tdisplayRange = displayRange * NM_TO_FT;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+212]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+264], xmm0

; 931  : 				
; 932  : 				if (mode != VS && fromBump && tmpRange)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 5
	je	SHORT $LN16@UpdateStat
	cmp	DWORD PTR _fromBump$[ebp], 0
	je	SHORT $LN16@UpdateStat
	movss	xmm0, DWORD PTR _tmpRange$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@UpdateStat

; 933  : 				{ 
; 934  : 					cursorY = tmpRange / tdisplayRange - 1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpRange$3[ebp]
	divss	xmm0, DWORD PTR [edx+264]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+224], xmm0
$LN16@UpdateStat:

; 935  : 				} 
; 936  : 				rangeChangeCmd = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0

; 937  : 				return;

	jmp	$LN134@UpdateStat
$LN22@UpdateStat:

; 938  : 			}
; 939  : 			
; 940  : 		}
; 941  : 		float tmpRange = (curCursorY + 1.0F) * tdisplayRange;

	movss	xmm0, DWORD PTR _curCursorY$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+264]
	movss	DWORD PTR _tmpRange$2[ebp], xmm0

; 942  : 		
; 943  : 		if (mode != VS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 5
	je	$LN8@UpdateStat

; 944  : 		{
; 945  : 			curRangeIdx += rangeChangeCmd;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+140]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+388], edx

; 946  : 			if (curRangeIdx >= NUM_RANGES)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+388], 5
	jl	SHORT $LN14@UpdateStat

; 947  : 			{
; 948  : 				curRangeIdx = NUM_RANGES - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 4

; 949  : 				//MI
; 950  : 				if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN13@UpdateStat
	movzx	edx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	edx, edx
	je	SHORT $LN13@UpdateStat

; 951  : 					rangeChangeCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 0
$LN13@UpdateStat:

; 952  : 			}

	jmp	SHORT $LN10@UpdateStat
$LN14@UpdateStat:

; 953  : 			else if (curRangeIdx < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+388], 0
	jge	SHORT $LN10@UpdateStat

; 954  : 			{
; 955  : 				curRangeIdx = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], 0

; 956  : 				//MI
; 957  : 				if(g_bRealisticAvionics && g_bAGRadarFixes)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN10@UpdateStat
	movzx	ecx, BYTE PTR ?g_bAGRadarFixes@@3_NA	; g_bAGRadarFixes
	test	ecx, ecx
	je	SHORT $LN10@UpdateStat

; 958  : 					rangeChangeCmd = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 0
$LN10@UpdateStat:

; 959  : 			}
; 960  : 			
; 961  : 			displayRange = rangeScales[curRangeIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+312]
	mov	DWORD PTR [edx+212], ecx

; 962  : 			switch (mode)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR tv1687[ebp], eax
	cmp	DWORD PTR tv1687[ebp], 14		; 0000000eH
	je	SHORT $LN7@UpdateStat
	cmp	DWORD PTR tv1687[ebp], 15		; 0000000fH
	jle	SHORT $LN6@UpdateStat
	cmp	DWORD PTR tv1687[ebp], 17		; 00000011H
	jle	SHORT $LN7@UpdateStat
	jmp	SHORT $LN6@UpdateStat
$LN7@UpdateStat:

; 963  : 			{
; 964  :             case GM:
; 965  :             case GMT:
; 966  :             case SEA:
; 967  : 				gmRangeIdx = curRangeIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR [ecx+404], eax

; 968  : 				break;

	jmp	SHORT $LN8@UpdateStat
$LN6@UpdateStat:

; 969  : 				
; 970  :             default:
; 971  : 				airRangeIdx = curRangeIdx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR [ecx+408], eax
$LN8@UpdateStat:

; 972  : 				break;
; 973  : 			}
; 974  : 		}
; 975  : 		tdisplayRange = displayRange * NM_TO_FT;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+212]
	mulss	xmm0, DWORD PTR __real@45bde1b0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+264], xmm0

; 976  : 		
; 977  : 		if (mode == GM || mode == GMT || mode == SEA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 14			; 0000000eH
	je	SHORT $LN4@UpdateStat
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+184], 16			; 00000010H
	je	SHORT $LN4@UpdateStat
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 17			; 00000011H
	jne	SHORT $LN5@UpdateStat
$LN4@UpdateStat:

; 978  : 		{
; 979  : 			SetGMScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGMScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetGMScan
	jmp	SHORT $LN2@UpdateStat
$LN5@UpdateStat:

; 980  : 			// MD -- 20040303: commenting this out -- when range is bumped in AUTO mode
; 981  : 			// this was being called and it was doing something very bogus to the cursor
; 982  : 			// positioning -- no useful value it seems.
; 983  : 			// AdjustGMOffset (rangeChangeCmd);
; 984  : 		}
; 985  : 		else if (mode != VS && fromBump && tmpRange)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 5
	je	SHORT $LN2@UpdateStat
	cmp	DWORD PTR _fromBump$[ebp], 0
	je	SHORT $LN2@UpdateStat
	movss	xmm0, DWORD PTR _tmpRange$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@UpdateStat

; 986  : 		{
; 987  : 			cursorY = tmpRange / tdisplayRange - 1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tmpRange$2[ebp]
	divss	xmm0, DWORD PTR [ecx+264]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+224], xmm0
$LN2@UpdateStat:

; 988  : 		}
; 989  : 		rangeChangeCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 0
$LN25@UpdateStat:

; 990  : 	}
; 991  : 	
; 992  : 	if (change)

	cmp	DWORD PTR _change$[ebp], 0
	je	SHORT $LN1@UpdateStat

; 993  : 	{
; 994  : 		SetScan();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScan@RadarDopplerClass@@IAEXXZ	; RadarDopplerClass::SetScan

; 995  : 		scanWidthCmd    = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 996  : 		scanHeightCmd   = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 997  : 		rangeChangeCmd = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 0
$LN1@UpdateStat:

; 998  : 	}
; 999  : 	elSlewCmd    = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0
$LN134@UpdateStat:

; 1000 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN229@UpdateStat:
	DD	$LN123@UpdateStat
	DD	$LN109@UpdateStat
	DD	$LN60@UpdateStat
	DD	$LN70@UpdateStat
	DD	$LN72@UpdateStat
	DD	$LN93@UpdateStat
	DD	$LN42@UpdateStat
	DD	$LN124@UpdateStat
$LN228@UpdateStat:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	3
	DB	3
	DB	5
	DB	7
	DB	7
	DB	7
	DB	6
	DB	7
	DB	6
	DB	6
?UpdateState@RadarDopplerClass@@UAEXHH@Z ENDP		; RadarDopplerClass::UpdateState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?Clear@HudDataType@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_testFlag$ = 8						; size = 4
?Clear@HudDataType@@QAEXH@Z PROC			; HudDataType::Clear, COMDAT
; _this$ = ecx

; 72   : 	void	Clear (int testFlag)	{ flags &= ~testFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _testFlag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@HudDataType@@QAEXH@Z ENDP			; HudDataType::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?Set@HudDataType@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_testFlag$ = 8						; size = 4
?Set@HudDataType@@QAEXH@Z PROC				; HudDataType::Set, COMDAT
; _this$ = ecx

; 71   : 	void	Set (int testFlag)		{ flags |= testFlag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, DWORD PTR _testFlag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Set@HudDataType@@QAEXH@Z ENDP				; HudDataType::Set
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?IsSOI@DrawableClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsSOI@DrawableClass@@QAEHXZ PROC			; DrawableClass::IsSOI, COMDAT
; _this$ = ecx

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN3@IsSOI
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSOI
$LN3@IsSOI:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSOI:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSOI@DrawableClass@@QAEHXZ ENDP			; DrawableClass::IsSOI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??BVU_ID@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVU_ID@@QBEKXZ PROC					; VU_ID::operator unsigned long, COMDAT
; _this$ = ecx

; 162  : 	operator VU_KEY() const { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		return (VU_KEY)(((unsigned short)creator_ << 16) | ((unsigned short)num_)); 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??BVU_SESSION_ID@@QBEKXZ		; VU_SESSION_ID::operator unsigned long
	movzx	eax, ax
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx]
	or	eax, edx

; 164  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVU_ID@@QBEKXZ ENDP					; VU_ID::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??BVU_SESSION_ID@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVU_SESSION_ID@@QBEKXZ PROC				; VU_SESSION_ID::operator unsigned long, COMDAT
; _this$ = ecx

; 79   : 	operator unsigned long() const { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		return (unsigned long) value_; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVU_SESSION_ID@@QBEKXZ ENDP				; VU_SESSION_ID::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
