; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\RADAR\RadarAGOnly.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z	; MfdDrawable::Display
PUBLIC	?SetType@SensorClass@@UAEXW4SensorType@1@@Z	; SensorClass::SetType
PUBLIC	?IsOn@SensorClass@@UAEHXZ			; SensorClass::IsOn
PUBLIC	?ExecModes@SensorClass@@UAEXHH@Z		; SensorClass::ExecModes
PUBLIC	?UpdateState@SensorClass@@UAEXHH@Z		; SensorClass::UpdateState
PUBLIC	?SetSeekerPos@SensorClass@@UAEXMM@Z		; SensorClass::SetSeekerPos
PUBLIC	?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ	; SensorClass::TargetUnderCursor
PUBLIC	?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ ; SensorClass::GetDisplay
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	??1RadarClass@@UAE@XZ				; RadarClass::~RadarClass
PUBLIC	?RangeStep@RadarClass@@UAEXH@Z			; RadarClass::RangeStep
PUBLIC	?NextTarget@RadarClass@@UAEXXZ			; RadarClass::NextTarget
PUBLIC	?PrevTarget@RadarClass@@UAEXXZ			; RadarClass::PrevTarget
PUBLIC	?DefaultAAMode@RadarClass@@UAEXXZ		; RadarClass::DefaultAAMode
PUBLIC	?StepAAmode@RadarClass@@UAEXXZ			; RadarClass::StepAAmode
PUBLIC	?SetSRMOverride@RadarClass@@UAEXXZ		; RadarClass::SetSRMOverride
PUBLIC	?SetMRMOverride@RadarClass@@UAEXXZ		; RadarClass::SetMRMOverride
PUBLIC	?ClearOverride@RadarClass@@UAEXXZ		; RadarClass::ClearOverride
PUBLIC	?SelectACMVertical@RadarClass@@UAEXXZ		; RadarClass::SelectACMVertical
PUBLIC	?SelectACMBore@RadarClass@@UAEXXZ		; RadarClass::SelectACMBore
PUBLIC	?SelectACMSlew@RadarClass@@UAEXXZ		; RadarClass::SelectACMSlew
PUBLIC	?SelectACM30x20@RadarClass@@UAEXXZ		; RadarClass::SelectACM30x20
PUBLIC	?StepAAscanHeight@RadarClass@@UAEXXZ		; RadarClass::StepAAscanHeight
PUBLIC	?StepAAscanWidth@RadarClass@@UAEXXZ		; RadarClass::StepAAscanWidth
PUBLIC	?StepAAelvation@RadarClass@@UAEXH@Z		; RadarClass::StepAAelvation
PUBLIC	?DefaultAGMode@RadarClass@@UAEXXZ		; RadarClass::DefaultAGMode
PUBLIC	?StepAGmode@RadarClass@@UAEXXZ			; RadarClass::StepAGmode
PUBLIC	?StepAGfov@RadarClass@@UAEXXZ			; RadarClass::StepAGfov
PUBLIC	?StepAGgain@RadarClass@@UAEXH@Z			; RadarClass::StepAGgain
PUBLIC	?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z	; RadarClass::SetMode
PUBLIC	?ToggleAGfreeze@RadarClass@@UAEXXZ		; RadarClass::ToggleAGfreeze
PUBLIC	?ToggleAGsnowPlow@RadarClass@@UAEXXZ		; RadarClass::ToggleAGsnowPlow
PUBLIC	?SetAGSnowPlow@RadarClass@@UAEXH@Z		; RadarClass::SetAGSnowPlow
PUBLIC	?ToggleAGcursorZero@RadarClass@@UAEXXZ		; RadarClass::ToggleAGcursorZero
PUBLIC	?SetGroundPoint@RadarClass@@UAEXMMM@Z		; RadarClass::SetGroundPoint
PUBLIC	?IsAG@RadarClass@@UAEHXZ			; RadarClass::IsAG
PUBLIC	?GetAGCenter@RadarClass@@UAEXPAM0@Z		; RadarClass::GetAGCenter
PUBLIC	?GetRange@RadarClass@@UAEMXZ			; RadarClass::GetRange
PUBLIC	?GetVolume@RadarClass@@UAEMXZ			; RadarClass::GetVolume
PUBLIC	?GetCursorPosition@RadarClass@@UAEXPAM0@Z	; RadarClass::GetCursorPosition
PUBLIC	?GetBuggedData@RadarClass@@UAEHPAM000@Z		; RadarClass::GetBuggedData
PUBLIC	?ClearModeDesiredCmd@RadarClass@@UAEXXZ		; RadarClass::ClearModeDesiredCmd
PUBLIC	?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ ; RadarClass::GetRadarModeR
PUBLIC	??_GRadarClass@@UAEPAXI@Z			; RadarClass::`scalar deleting destructor'
PUBLIC	??1RadarDigiClass@@UAE@XZ			; RadarDigiClass::~RadarDigiClass
PUBLIC	?RangeStep@RadarDigiClass@@UAEXH@Z		; RadarDigiClass::RangeStep
PUBLIC	?StepAAmode@RadarDigiClass@@UAEXXZ		; RadarDigiClass::StepAAmode
PUBLIC	?StepAGmode@RadarDigiClass@@UAEXXZ		; RadarDigiClass::StepAGmode
PUBLIC	??_GRadarDigiClass@@UAEPAXI@Z			; RadarDigiClass::`scalar deleting destructor'
PUBLIC	??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z	; RadarAGOnlyClass::RadarAGOnlyClass
PUBLIC	??1RadarAGOnlyClass@@UAE@XZ			; RadarAGOnlyClass::~RadarAGOnlyClass
PUBLIC	?Exec@RadarAGOnlyClass@@UAEPAVSimObjectType@@PAV2@@Z ; RadarAGOnlyClass::Exec
PUBLIC	?StepAAmode@RadarAGOnlyClass@@UAEXXZ		; RadarAGOnlyClass::StepAAmode
PUBLIC	?StepAGmode@RadarAGOnlyClass@@UAEXXZ		; RadarAGOnlyClass::StepAGmode
PUBLIC	?SetMode@RadarAGOnlyClass@@UAEXW4RadarMode@RadarClass@@@Z ; RadarAGOnlyClass::SetMode
PUBLIC	?IsAG@RadarAGOnlyClass@@UAEHXZ			; RadarAGOnlyClass::IsAG
PUBLIC	?SetDesiredTarget@RadarAGOnlyClass@@UAEXPAVSimObjectType@@@Z ; RadarAGOnlyClass::SetDesiredTarget
PUBLIC	??_GRadarAGOnlyClass@@UAEPAXI@Z			; RadarAGOnlyClass::`scalar deleting destructor'
PUBLIC	??_7RadarClass@@6B@				; RadarClass::`vftable'
PUBLIC	??_7RadarDigiClass@@6B@				; RadarDigiClass::`vftable'
PUBLIC	??_7RadarAGOnlyClass@@6B@			; RadarAGOnlyClass::`vftable'
PUBLIC	??_R0?AVDrawableClass@@@8			; DrawableClass `RTTI Type Descriptor'
PUBLIC	??_R3DrawableClass@@8				; DrawableClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DrawableClass@@8				; DrawableClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DrawableClass@@8			; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMfdDrawable@@@8				; MfdDrawable `RTTI Type Descriptor'
PUBLIC	??_R3MfdDrawable@@8				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MfdDrawable@@8				; MfdDrawable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MfdDrawable@@8			; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RadarClass@@6B@				; RadarClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRadarClass@@@8				; RadarClass `RTTI Type Descriptor'
PUBLIC	??_R3RadarClass@@8				; RadarClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RadarClass@@8				; RadarClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RadarClass@@8			; RadarClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@SensorClass@@8			; SensorClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSensorClass@@@8				; SensorClass `RTTI Type Descriptor'
PUBLIC	??_R3SensorClass@@8				; SensorClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SensorClass@@8				; SensorClass::`RTTI Base Class Array'
PUBLIC	??_R4RadarDigiClass@@6B@			; RadarDigiClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRadarDigiClass@@@8			; RadarDigiClass `RTTI Type Descriptor'
PUBLIC	??_R3RadarDigiClass@@8				; RadarDigiClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RadarDigiClass@@8				; RadarDigiClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RadarDigiClass@@8			; RadarDigiClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RadarAGOnlyClass@@6B@			; RadarAGOnlyClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRadarAGOnlyClass@@@8			; RadarAGOnlyClass `RTTI Type Descriptor'
PUBLIC	??_R3RadarAGOnlyClass@@8			; RadarAGOnlyClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RadarAGOnlyClass@@8			; RadarAGOnlyClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RadarAGOnlyClass@@8		; RadarAGOnlyClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f860aa6
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
EXTRN	__purecall:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_fabs:PROC
EXTRN	?DisplayExit@DrawableClass@@UAEXXZ:PROC		; DrawableClass::DisplayExit
EXTRN	?PushButton@MfdDrawable@@UAEXHH@Z:PROC		; MfdDrawable::PushButton
EXTRN	??1SensorClass@@UAE@XZ:PROC			; SensorClass::~SensorClass
EXTRN	?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z:PROC ; SensorClass::SetSensorTargetHack
EXTRN	?CheckLockedTarget@SensorClass@@MAEXXZ:PROC	; SensorClass::CheckLockedTarget
EXTRN	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetAz
EXTRN	?TargetEl@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z:PROC ; TargetEl
EXTRN	?SetRdrAz@SimBaseClass@@QAEXM@Z:PROC		; SimBaseClass::SetRdrAz
EXTRN	?SetRdrEl@SimBaseClass@@QAEXM@Z:PROC		; SimBaseClass::SetRdrEl
EXTRN	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrAzCenter
EXTRN	?SetRdrElCenter@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrElCenter
EXTRN	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z:PROC	; SimBaseClass::SetRdrCycleTime
EXTRN	?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z:PROC ; RadarClass::SetSensorTarget
EXTRN	?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z:PROC ; RadarClass::ReturnStrength
EXTRN	?DisplayInit@RadarClass@@UAEXPAVImageBuffer@@@Z:PROC ; RadarClass::DisplayInit
EXTRN	?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z:PROC ; RadarClass::SendTrackMsg
EXTRN	?SetPower@RadarClass@@UAEXH@Z:PROC		; RadarClass::SetPower
EXTRN	?SetEmitting@RadarClass@@UAEXH@Z:PROC		; RadarClass::SetEmitting
EXTRN	?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z:PROC ; RadarClass::SetDesiredTarget
EXTRN	?ClearSensorTarget@RadarClass@@UAEXXZ:PROC	; RadarClass::ClearSensorTarget
EXTRN	??_ERadarClass@@UAEPAXI@Z:PROC			; RadarClass::`vector deleting destructor'
EXTRN	??0RadarDigiClass@@QAE@HPAVSimMoverClass@@@Z:PROC ; RadarDigiClass::RadarDigiClass
EXTRN	?Exec@RadarDigiClass@@UAEPAVSimObjectType@@PAV2@@Z:PROC ; RadarDigiClass::Exec
EXTRN	?SetMode@RadarDigiClass@@UAEXW4RadarMode@RadarClass@@@Z:PROC ; RadarDigiClass::SetMode
EXTRN	?IsAG@RadarDigiClass@@UAEHXZ:PROC		; RadarDigiClass::IsAG
EXTRN	?GetAGCenter@RadarDigiClass@@UAEXPAM0@Z:PROC	; RadarDigiClass::GetAGCenter
EXTRN	?NewRange@RadarDigiClass@@IAEXM@Z:PROC		; RadarDigiClass::NewRange
EXTRN	??_ERadarDigiClass@@UAEPAXI@Z:PROC		; RadarDigiClass::`vector deleting destructor'
EXTRN	??_ERadarAGOnlyClass@@UAEPAXI@Z:PROC		; RadarAGOnlyClass::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f860aa6
CONST	SEGMENT
__real@3f860aa6 DD 03f860aa6r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@RadarAGOnlyClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RadarAGOnlyClass@@8 DD FLAT:??_R0?AVRadarAGOnlyClass@@@8 ; RadarAGOnlyClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RadarAGOnlyClass@@8
rdata$r	ENDS
;	COMDAT ??_R2RadarAGOnlyClass@@8
rdata$r	SEGMENT
??_R2RadarAGOnlyClass@@8 DD FLAT:??_R1A@?0A@EA@RadarAGOnlyClass@@8 ; RadarAGOnlyClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RadarDigiClass@@8
	DD	FLAT:??_R1A@?0A@EA@RadarClass@@8
	DD	FLAT:??_R1A@?0A@EA@SensorClass@@8
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3RadarAGOnlyClass@@8
rdata$r	SEGMENT
??_R3RadarAGOnlyClass@@8 DD 00H				; RadarAGOnlyClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2RadarAGOnlyClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRadarAGOnlyClass@@@8
_DATA	SEGMENT
??_R0?AVRadarAGOnlyClass@@@8 DD FLAT:??_7type_info@@6B@	; RadarAGOnlyClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRadarAGOnlyClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RadarAGOnlyClass@@6B@
rdata$r	SEGMENT
??_R4RadarAGOnlyClass@@6B@ DD 00H			; RadarAGOnlyClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRadarAGOnlyClass@@@8
	DD	FLAT:??_R3RadarAGOnlyClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RadarDigiClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RadarDigiClass@@8 DD FLAT:??_R0?AVRadarDigiClass@@@8 ; RadarDigiClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RadarDigiClass@@8
rdata$r	ENDS
;	COMDAT ??_R2RadarDigiClass@@8
rdata$r	SEGMENT
??_R2RadarDigiClass@@8 DD FLAT:??_R1A@?0A@EA@RadarDigiClass@@8 ; RadarDigiClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RadarClass@@8
	DD	FLAT:??_R1A@?0A@EA@SensorClass@@8
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3RadarDigiClass@@8
rdata$r	SEGMENT
??_R3RadarDigiClass@@8 DD 00H				; RadarDigiClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2RadarDigiClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRadarDigiClass@@@8
_DATA	SEGMENT
??_R0?AVRadarDigiClass@@@8 DD FLAT:??_7type_info@@6B@	; RadarDigiClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRadarDigiClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RadarDigiClass@@6B@
rdata$r	SEGMENT
??_R4RadarDigiClass@@6B@ DD 00H				; RadarDigiClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRadarDigiClass@@@8
	DD	FLAT:??_R3RadarDigiClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SensorClass@@8
rdata$r	SEGMENT
??_R2SensorClass@@8 DD FLAT:??_R1A@?0A@EA@SensorClass@@8 ; SensorClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3SensorClass@@8
rdata$r	SEGMENT
??_R3SensorClass@@8 DD 00H				; SensorClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SensorClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSensorClass@@@8
_DATA	SEGMENT
??_R0?AVSensorClass@@@8 DD FLAT:??_7type_info@@6B@	; SensorClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSensorClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SensorClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SensorClass@@8 DD FLAT:??_R0?AVSensorClass@@@8 ; SensorClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SensorClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RadarClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RadarClass@@8 DD FLAT:??_R0?AVRadarClass@@@8 ; RadarClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RadarClass@@8
rdata$r	ENDS
;	COMDAT ??_R2RadarClass@@8
rdata$r	SEGMENT
??_R2RadarClass@@8 DD FLAT:??_R1A@?0A@EA@RadarClass@@8	; RadarClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SensorClass@@8
	DD	FLAT:??_R1A@?0A@EA@MfdDrawable@@8
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3RadarClass@@8
rdata$r	SEGMENT
??_R3RadarClass@@8 DD 00H				; RadarClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2RadarClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRadarClass@@@8
_DATA	SEGMENT
??_R0?AVRadarClass@@@8 DD FLAT:??_7type_info@@6B@	; RadarClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRadarClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RadarClass@@6B@
rdata$r	SEGMENT
??_R4RadarClass@@6B@ DD 00H				; RadarClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRadarClass@@@8
	DD	FLAT:??_R3RadarClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MfdDrawable@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MfdDrawable@@8 DD FLAT:??_R0?AVMfdDrawable@@@8 ; MfdDrawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R2MfdDrawable@@8
rdata$r	SEGMENT
??_R2MfdDrawable@@8 DD FLAT:??_R1A@?0A@EA@MfdDrawable@@8 ; MfdDrawable::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3MfdDrawable@@8
rdata$r	SEGMENT
??_R3MfdDrawable@@8 DD 00H				; MfdDrawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MfdDrawable@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMfdDrawable@@@8
_DATA	SEGMENT
??_R0?AVMfdDrawable@@@8 DD FLAT:??_7type_info@@6B@	; MfdDrawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMfdDrawable@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@DrawableClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DrawableClass@@8 DD FLAT:??_R0?AVDrawableClass@@@8 ; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R2DrawableClass@@8
rdata$r	SEGMENT
??_R2DrawableClass@@8 DD FLAT:??_R1A@?0A@EA@DrawableClass@@8 ; DrawableClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DrawableClass@@8
rdata$r	SEGMENT
??_R3DrawableClass@@8 DD 00H				; DrawableClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawableClass@@@8
_DATA	SEGMENT
??_R0?AVDrawableClass@@@8 DD FLAT:??_7type_info@@6B@	; DrawableClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawableClass@@', 00H
_DATA	ENDS
;	COMDAT ??_7RadarAGOnlyClass@@6B@
CONST	SEGMENT
??_7RadarAGOnlyClass@@6B@ DD FLAT:??_R4RadarAGOnlyClass@@6B@ ; RadarAGOnlyClass::`vftable'
	DD	FLAT:??_ERadarAGOnlyClass@@UAEPAXI@Z
	DD	FLAT:?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@RadarClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@MfdDrawable@@UAEXHH@Z
	DD	FLAT:?SetType@SensorClass@@UAEXW4SensorType@1@@Z
	DD	FLAT:?SetPower@RadarClass@@UAEXH@Z
	DD	FLAT:?IsOn@SensorClass@@UAEHXZ
	DD	FLAT:?SetDesiredTarget@RadarAGOnlyClass@@UAEXPAVSimObjectType@@@Z
	DD	FLAT:?ClearSensorTarget@RadarClass@@UAEXXZ
	DD	FLAT:?Exec@RadarAGOnlyClass@@UAEPAVSimObjectType@@PAV2@@Z
	DD	FLAT:?ExecModes@SensorClass@@UAEXHH@Z
	DD	FLAT:?UpdateState@SensorClass@@UAEXHH@Z
	DD	FLAT:?SetSeekerPos@SensorClass@@UAEXMM@Z
	DD	FLAT:?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z
	DD	FLAT:?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z
	DD	FLAT:?CheckLockedTarget@SensorClass@@MAEXXZ
	DD	FLAT:?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z
	DD	FLAT:?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z
	DD	FLAT:?SetEmitting@RadarClass@@UAEXH@Z
	DD	FLAT:?RangeStep@RadarDigiClass@@UAEXH@Z
	DD	FLAT:?NextTarget@RadarClass@@UAEXXZ
	DD	FLAT:?PrevTarget@RadarClass@@UAEXXZ
	DD	FLAT:?DefaultAAMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAmode@RadarAGOnlyClass@@UAEXXZ
	DD	FLAT:?SetSRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SetMRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?ClearOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMVertical@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMBore@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMSlew@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACM30x20@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanHeight@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanWidth@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAelvation@RadarClass@@UAEXH@Z
	DD	FLAT:?DefaultAGMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGmode@RadarAGOnlyClass@@UAEXXZ
	DD	FLAT:?StepAGfov@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGgain@RadarClass@@UAEXH@Z
	DD	FLAT:?SetMode@RadarAGOnlyClass@@UAEXW4RadarMode@RadarClass@@@Z
	DD	FLAT:?ToggleAGfreeze@RadarClass@@UAEXXZ
	DD	FLAT:?ToggleAGsnowPlow@RadarClass@@UAEXXZ
	DD	FLAT:?SetAGSnowPlow@RadarClass@@UAEXH@Z
	DD	FLAT:?ToggleAGcursorZero@RadarClass@@UAEXXZ
	DD	FLAT:?SetGroundPoint@RadarClass@@UAEXMMM@Z
	DD	FLAT:?IsAG@RadarAGOnlyClass@@UAEHXZ
	DD	FLAT:?GetAGCenter@RadarDigiClass@@UAEXPAM0@Z
	DD	FLAT:?GetRange@RadarClass@@UAEMXZ
	DD	FLAT:?GetVolume@RadarClass@@UAEMXZ
	DD	FLAT:?GetCursorPosition@RadarClass@@UAEXPAM0@Z
	DD	FLAT:?GetBuggedData@RadarClass@@UAEHPAM000@Z
	DD	FLAT:?ClearModeDesiredCmd@RadarClass@@UAEXXZ
	DD	FLAT:?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
CONST	ENDS
;	COMDAT ??_7RadarDigiClass@@6B@
CONST	SEGMENT
??_7RadarDigiClass@@6B@ DD FLAT:??_R4RadarDigiClass@@6B@ ; RadarDigiClass::`vftable'
	DD	FLAT:??_ERadarDigiClass@@UAEPAXI@Z
	DD	FLAT:?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@RadarClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@MfdDrawable@@UAEXHH@Z
	DD	FLAT:?SetType@SensorClass@@UAEXW4SensorType@1@@Z
	DD	FLAT:?SetPower@RadarClass@@UAEXH@Z
	DD	FLAT:?IsOn@SensorClass@@UAEHXZ
	DD	FLAT:?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z
	DD	FLAT:?ClearSensorTarget@RadarClass@@UAEXXZ
	DD	FLAT:?Exec@RadarDigiClass@@UAEPAVSimObjectType@@PAV2@@Z
	DD	FLAT:?ExecModes@SensorClass@@UAEXHH@Z
	DD	FLAT:?UpdateState@SensorClass@@UAEXHH@Z
	DD	FLAT:?SetSeekerPos@SensorClass@@UAEXMM@Z
	DD	FLAT:?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z
	DD	FLAT:?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z
	DD	FLAT:?CheckLockedTarget@SensorClass@@MAEXXZ
	DD	FLAT:?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z
	DD	FLAT:?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z
	DD	FLAT:?SetEmitting@RadarClass@@UAEXH@Z
	DD	FLAT:?RangeStep@RadarDigiClass@@UAEXH@Z
	DD	FLAT:?NextTarget@RadarClass@@UAEXXZ
	DD	FLAT:?PrevTarget@RadarClass@@UAEXXZ
	DD	FLAT:?DefaultAAMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAmode@RadarDigiClass@@UAEXXZ
	DD	FLAT:?SetSRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SetMRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?ClearOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMVertical@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMBore@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMSlew@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACM30x20@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanHeight@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanWidth@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAelvation@RadarClass@@UAEXH@Z
	DD	FLAT:?DefaultAGMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGmode@RadarDigiClass@@UAEXXZ
	DD	FLAT:?StepAGfov@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGgain@RadarClass@@UAEXH@Z
	DD	FLAT:?SetMode@RadarDigiClass@@UAEXW4RadarMode@RadarClass@@@Z
	DD	FLAT:?ToggleAGfreeze@RadarClass@@UAEXXZ
	DD	FLAT:?ToggleAGsnowPlow@RadarClass@@UAEXXZ
	DD	FLAT:?SetAGSnowPlow@RadarClass@@UAEXH@Z
	DD	FLAT:?ToggleAGcursorZero@RadarClass@@UAEXXZ
	DD	FLAT:?SetGroundPoint@RadarClass@@UAEXMMM@Z
	DD	FLAT:?IsAG@RadarDigiClass@@UAEHXZ
	DD	FLAT:?GetAGCenter@RadarDigiClass@@UAEXPAM0@Z
	DD	FLAT:?GetRange@RadarClass@@UAEMXZ
	DD	FLAT:?GetVolume@RadarClass@@UAEMXZ
	DD	FLAT:?GetCursorPosition@RadarClass@@UAEXPAM0@Z
	DD	FLAT:?GetBuggedData@RadarClass@@UAEHPAM000@Z
	DD	FLAT:?ClearModeDesiredCmd@RadarClass@@UAEXXZ
	DD	FLAT:?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
CONST	ENDS
;	COMDAT ??_7RadarClass@@6B@
CONST	SEGMENT
??_7RadarClass@@6B@ DD FLAT:??_R4RadarClass@@6B@	; RadarClass::`vftable'
	DD	FLAT:??_ERadarClass@@UAEPAXI@Z
	DD	FLAT:?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@RadarClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@MfdDrawable@@UAEXHH@Z
	DD	FLAT:?SetType@SensorClass@@UAEXW4SensorType@1@@Z
	DD	FLAT:?SetPower@RadarClass@@UAEXH@Z
	DD	FLAT:?IsOn@SensorClass@@UAEHXZ
	DD	FLAT:?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z
	DD	FLAT:?ClearSensorTarget@RadarClass@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:?ExecModes@SensorClass@@UAEXHH@Z
	DD	FLAT:?UpdateState@SensorClass@@UAEXHH@Z
	DD	FLAT:?SetSeekerPos@SensorClass@@UAEXMM@Z
	DD	FLAT:?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
	DD	FLAT:?SetSensorTarget@RadarClass@@MAEXPAVSimObjectType@@@Z
	DD	FLAT:?SetSensorTargetHack@SensorClass@@MAEXPAVFalconEntity@@@Z
	DD	FLAT:?CheckLockedTarget@SensorClass@@MAEXXZ
	DD	FLAT:?ReturnStrength@RadarClass@@UAEMPAVSimObjectType@@@Z
	DD	FLAT:?SendTrackMsg@RadarClass@@UAEXPAVSimObjectType@@II@Z
	DD	FLAT:?SetEmitting@RadarClass@@UAEXH@Z
	DD	FLAT:?RangeStep@RadarClass@@UAEXH@Z
	DD	FLAT:?NextTarget@RadarClass@@UAEXXZ
	DD	FLAT:?PrevTarget@RadarClass@@UAEXXZ
	DD	FLAT:?DefaultAAMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAmode@RadarClass@@UAEXXZ
	DD	FLAT:?SetSRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SetMRMOverride@RadarClass@@UAEXXZ
	DD	FLAT:?ClearOverride@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMVertical@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMBore@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACMSlew@RadarClass@@UAEXXZ
	DD	FLAT:?SelectACM30x20@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanHeight@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAscanWidth@RadarClass@@UAEXXZ
	DD	FLAT:?StepAAelvation@RadarClass@@UAEXH@Z
	DD	FLAT:?DefaultAGMode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGmode@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGfov@RadarClass@@UAEXXZ
	DD	FLAT:?StepAGgain@RadarClass@@UAEXH@Z
	DD	FLAT:?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z
	DD	FLAT:?ToggleAGfreeze@RadarClass@@UAEXXZ
	DD	FLAT:?ToggleAGsnowPlow@RadarClass@@UAEXXZ
	DD	FLAT:?SetAGSnowPlow@RadarClass@@UAEXH@Z
	DD	FLAT:?ToggleAGcursorZero@RadarClass@@UAEXXZ
	DD	FLAT:?SetGroundPoint@RadarClass@@UAEXMMM@Z
	DD	FLAT:?IsAG@RadarClass@@UAEHXZ
	DD	FLAT:?GetAGCenter@RadarClass@@UAEXPAM0@Z
	DD	FLAT:?GetRange@RadarClass@@UAEMXZ
	DD	FLAT:?GetVolume@RadarClass@@UAEMXZ
	DD	FLAT:?GetCursorPosition@RadarClass@@UAEXPAM0@Z
	DD	FLAT:?GetBuggedData@RadarClass@@UAEHPAM000@Z
	DD	FLAT:?ClearModeDesiredCmd@RadarClass@@UAEXXZ
	DD	FLAT:?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z$0
__ehfuncinfo$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRadarAGOnlyClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRadarAGOnlyClass@@UAEPAXI@Z PROC			; RadarAGOnlyClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarAGOnlyClass@@UAE@XZ		; RadarAGOnlyClass::~RadarAGOnlyClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRadarAGOnlyClass@@UAEPAXI@Z ENDP			; RadarAGOnlyClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radaragonly.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_newTarget$ = 8						; size = 4
?SetDesiredTarget@RadarAGOnlyClass@@UAEXPAVSimObjectType@@@Z PROC ; RadarAGOnlyClass::SetDesiredTarget
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 114  :    // Only accept ground targets
; 115  :    if (!newTarget || newTarget->BaseData()->OnGround())

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	SHORT $LN1@SetDesired
	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv68[ebp], eax
	mov	eax, DWORD PTR tv68[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN3@SetDesired
$LN1@SetDesired:

; 116  :       RadarClass::SetDesiredTarget( newTarget );

	mov	ecx, DWORD PTR _newTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDesiredTarget@RadarClass@@UAEXPAVSimObjectType@@@Z ; RadarClass::SetDesiredTarget
$LN3@SetDesired:

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDesiredTarget@RadarAGOnlyClass@@UAEXPAVSimObjectType@@@Z ENDP ; RadarAGOnlyClass::SetDesiredTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radaragonly.h
;	COMDAT ?IsAG@RadarAGOnlyClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAG@RadarAGOnlyClass@@UAEHXZ PROC			; RadarAGOnlyClass::IsAG, COMDAT
; _this$ = ecx

; 19   : 	virtual int   IsAG (void) {return TRUE;};		// Always in AG mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAG@RadarAGOnlyClass@@UAEHXZ ENDP			; RadarAGOnlyClass::IsAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radaragonly.h
;	COMDAT ?SetMode@RadarAGOnlyClass@@UAEXW4RadarMode@RadarClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetMode@RadarAGOnlyClass@@UAEXW4RadarMode@RadarClass@@@Z PROC ; RadarAGOnlyClass::SetMode, COMDAT
; _this$ = ecx

; 18   :    virtual void SetMode (RadarMode)      { };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMode@RadarAGOnlyClass@@UAEXW4RadarMode@RadarClass@@@Z ENDP ; RadarAGOnlyClass::SetMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radaragonly.h
;	COMDAT ?StepAGmode@RadarAGOnlyClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGmode@RadarAGOnlyClass@@UAEXXZ PROC		; RadarAGOnlyClass::StepAGmode, COMDAT
; _this$ = ecx

; 17   : 	virtual void StepAGmode( void )				{ };	// Always in AG mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGmode@RadarAGOnlyClass@@UAEXXZ ENDP		; RadarAGOnlyClass::StepAGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radaragonly.h
;	COMDAT ?StepAAmode@RadarAGOnlyClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAmode@RadarAGOnlyClass@@UAEXXZ PROC		; RadarAGOnlyClass::StepAAmode, COMDAT
; _this$ = ecx

; 16   : 	virtual void StepAAmode( void )				{ };	// No AA Mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAmode@RadarAGOnlyClass@@UAEXXZ ENDP		; RadarAGOnlyClass::StepAAmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radaragonly.cpp
_TEXT	SEGMENT
_sendThisFrame$ = -24					; size = 4
tv457 = -20						; size = 4
tv443 = -16						; size = 4
tv139 = -12						; size = 4
_canSee$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Exec@RadarAGOnlyClass@@UAEPAVSimObjectType@@PAV2@@Z PROC ; RadarAGOnlyClass::Exec
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 	int				sendThisFrame;
; 27   : 	int				canSee;
; 28   : 
; 29   : 	// Validate our locked target
; 30   : 	CheckLockedTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 31   : 
; 32   : 	// If we don't have a locked target, we don't have anything to do.
; 33   : 	if (!lockedTarget) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN10@Exec

; 34   : 		return NULL;

	xor	eax, eax
	jmp	$LN11@Exec
$LN10@Exec:

; 35   : 	}
; 36   : 
; 37   : 	// See if it is time to send a "painted" list update
; 38   : 	sendThisFrame = FALSE;

	mov	DWORD PTR _sendThisFrame$[ebp], 0

; 39   : 
; 40   : 	// Time to see if we can still track our target
; 41   : 	canSee = TRUE;

	mov	DWORD PTR _canSee$[ebp], 1

; 42   : 
; 43   : 	// Can't hold a lock while we're off
; 44   : 	if (!isEmitting)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 0
	jne	SHORT $LN9@Exec

; 45   :    {
; 46   : 		canSee = FALSE;

	mov	DWORD PTR _canSee$[ebp], 0
$LN9@Exec:

; 47   : 	}
; 48   : 
; 49   : 	// Can't hold a lock if its outside our radar cone
; 50   : 	if (fabs(lockedTarget->localData->ata) > radarData->ScanHalfAngle)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+12]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv443[ebp]
	movss	xmm0, DWORD PTR tv443[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	comiss	xmm0, DWORD PTR [ecx+24]
	jbe	SHORT $LN8@Exec

; 51   : 	{
; 52   : 		canSee = FALSE;

	mov	DWORD PTR _canSee$[ebp], 0
$LN8@Exec:

; 53   : 	}
; 54   : 
; 55   : 	// Only track object in the correct domain (air/land)
; 56   : 	if ( !lockedTarget->BaseData()->OnGround() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv139[ebp], eax
	mov	eax, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv139[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN7@Exec

; 57   : 	{
; 58   : 		canSee = FALSE;

	mov	DWORD PTR _canSee$[ebp], 0
$LN7@Exec:

; 59   : 	}
; 60   : 
; 61   : 	// Drop lock if the guy has been below the signal strength threshhold too long
; 62   : 	if (ReturnStrength(lockedTarget) < 1.0f)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax
	fstp	DWORD PTR tv457[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR tv457[ebp]
	jbe	SHORT $LN5@Exec

; 63   :    {
; 64   : 		// He's faded.  How long has he been hiding?
; 65   : 		if (SimLibElapsedTime - lockedTarget->localData->rdrLastHit > radarData->CoastTime)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	cmp	ecx, DWORD PTR [eax+32]
	jbe	SHORT $LN5@Exec

; 66   :       {
; 67   : 			// Give up and drop lock
; 68   : 			canSee = FALSE;

	mov	DWORD PTR _canSee$[ebp], 0
$LN5@Exec:

; 69   : 		}
; 70   : 	}
; 71   : 
; 72   : 
; 73   : 	// If we can't see the target, drop lock
; 74   : 	if (!canSee)

	cmp	DWORD PTR _canSee$[ebp], 0
	jne	SHORT $LN4@Exec

; 75   :    {
; 76   : 		SetDesiredTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN4@Exec:

; 77   : 	}
; 78   : 
; 79   : 
; 80   : 	// Tell the base class and the rest of the world where we're looking
; 81   : 	if (lockedTarget)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	$LN3@Exec

; 82   : 	{
; 83   : 		SetSeekerPos( TargetAz(platform, lockedTarget), TargetEl(platform, lockedTarget) );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?TargetEl@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetEl
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	?TargetAz@@YAMPAVFalconEntity@@PAVSimObjectType@@@Z ; TargetAz
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 84   : 		platform->SetRdrAz( radarData->BeamHalfAngle );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 85   : 		platform->SetRdrEl( radarData->BeamHalfAngle );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+20]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 86   : 		platform->SetRdrCycleTime( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 87   : 		platform->SetRdrAzCenter( lockedTarget->localData->az );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 88   : 		platform->SetRdrElCenter( lockedTarget->localData->el );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+12]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter

; 89   : 
; 90   : 		// Tag the target as seen this frame
; 91   : 		lockedTarget->localData->rdrLastHit = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+136], ecx

; 92   : 
; 93   : 		// Tell our current target he's locked
; 94   : 		if (sendThisFrame) {

	cmp	DWORD PTR _sendThisFrame$[ebp], 0
	je	SHORT $LN2@Exec

; 95   : 			SendTrackMsg(lockedTarget, Track_Lock );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 96   : 			lastTargetLockSend = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+72], edx
$LN2@Exec:

; 97   : 		}
; 98   : 	}
; 99   : 	else

	jmp	$LN1@Exec
$LN3@Exec:

; 100  : 	{
; 101  : 		SetSeekerPos( 0.0f, 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 102  : 		platform->SetRdrAz( 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 103  : 		platform->SetRdrEl( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 104  : 		platform->SetRdrCycleTime( 3.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 105  : 		platform->SetRdrAzCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 106  : 		platform->SetRdrElCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter
$LN1@Exec:

; 107  : 	}
; 108  : 
; 109  : 	return lockedTarget;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
$LN11@Exec:

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Exec@RadarAGOnlyClass@@UAEPAVSimObjectType@@PAV2@@Z ENDP ; RadarAGOnlyClass::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radaragonly.h
;	COMDAT ??1RadarAGOnlyClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RadarAGOnlyClass@@UAE@XZ PROC			; RadarAGOnlyClass::~RadarAGOnlyClass, COMDAT
; _this$ = ecx

; 11   : 	virtual ~RadarAGOnlyClass()					{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RadarAGOnlyClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarDigiClass@@UAE@XZ		; RadarDigiClass::~RadarDigiClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1RadarAGOnlyClass@@UAE@XZ ENDP			; RadarAGOnlyClass::~RadarAGOnlyClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\radar\radaragonly.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_parentPlatform$ = 12					; size = 4
??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z PROC	; RadarAGOnlyClass::RadarAGOnlyClass
; _this$ = ecx

; 13   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _parentPlatform$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RadarDigiClass@@QAE@HPAVSimMoverClass@@@Z ; RadarDigiClass::RadarDigiClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7RadarAGOnlyClass@@6B@

; 14   : 	mode = GM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 14			; 0000000eH

; 15   : 	NewRange( 20.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NewRange@RadarDigiClass@@IAEXM@Z	; RadarDigiClass::NewRange

; 16   : 	platform->SetRdrAz( 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrAz@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrAz

; 17   : 	platform->SetRdrEl( 0.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrEl@SimBaseClass@@QAEXM@Z		; SimBaseClass::SetRdrEl

; 18   : 	platform->SetRdrCycleTime( 3.0F );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?SetRdrCycleTime@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrCycleTime

; 19   : 	platform->SetRdrAzCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?SetRdrAzCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrAzCenter

; 20   : 	platform->SetRdrElCenter( 0.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?SetRdrElCenter@SimBaseClass@@QAEXM@Z	; SimBaseClass::SetRdrElCenter

; 21   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RadarDigiClass@@UAE@XZ		; RadarDigiClass::~RadarDigiClass
__ehhandler$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RadarAGOnlyClass@@QAE@HPAVSimMoverClass@@@Z ENDP	; RadarAGOnlyClass::RadarAGOnlyClass
; Function compile flags: /Odtp
;	COMDAT ??_GRadarDigiClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRadarDigiClass@@UAEPAXI@Z PROC			; RadarDigiClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarDigiClass@@UAE@XZ		; RadarDigiClass::~RadarDigiClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRadarDigiClass@@UAEPAXI@Z ENDP			; RadarDigiClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardigi.h
;	COMDAT ?StepAGmode@RadarDigiClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGmode@RadarDigiClass@@UAEXXZ PROC			; RadarDigiClass::StepAGmode, COMDAT
; _this$ = ecx

; 19   : 	virtual void StepAGmode( void )				{ mode = GM; };	// Enter AG mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 14			; 0000000eH
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGmode@RadarDigiClass@@UAEXXZ ENDP			; RadarDigiClass::StepAGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardigi.h
;	COMDAT ?StepAAmode@RadarDigiClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAmode@RadarDigiClass@@UAEXXZ PROC			; RadarDigiClass::StepAAmode, COMDAT
; _this$ = ecx

; 18   : 	virtual void StepAAmode( void )				{ mode = AA; };	// Enter AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 18			; 00000012H
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAmode@RadarDigiClass@@UAEXXZ ENDP			; RadarDigiClass::StepAAmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardigi.h
;	COMDAT ?RangeStep@RadarDigiClass@@UAEXH@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_cmd$ = 8						; size = 4
?RangeStep@RadarDigiClass@@UAEXH@Z PROC			; RadarDigiClass::RangeStep, COMDAT
; _this$ = ecx

; 16   : 	virtual void RangeStep( int cmd )			{ NewRange( (cmd>0) ? rangeNM*2.0f: rangeNM*0.5f); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _cmd$[ebp], 0
	jle	SHORT $LN3@RangeStep
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN4@RangeStep
$LN3@RangeStep:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+132]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv70[ebp], xmm0
$LN4@RangeStep:
	push	ecx
	movss	xmm0, DWORD PTR tv70[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NewRange@RadarDigiClass@@IAEXM@Z	; RadarDigiClass::NewRange
	mov	esp, ebp
	pop	ebp
	ret	4
?RangeStep@RadarDigiClass@@UAEXH@Z ENDP			; RadarDigiClass::RangeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardigi.h
;	COMDAT ??1RadarDigiClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RadarDigiClass@@UAE@XZ PROC				; RadarDigiClass::~RadarDigiClass, COMDAT
; _this$ = ecx

; 11   : 	virtual ~RadarDigiClass()					{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RadarDigiClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarClass@@UAE@XZ			; RadarClass::~RadarClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1RadarDigiClass@@UAE@XZ ENDP				; RadarDigiClass::~RadarDigiClass
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRadarClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRadarClass@@UAEPAXI@Z PROC				; RadarClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RadarClass@@UAE@XZ			; RadarClass::~RadarClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRadarClass@@UAEPAXI@Z ENDP				; RadarClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ PROC	; RadarClass::GetRadarModeR, COMDAT
; _this$ = ecx

; 115  : 	virtual RadarMode	GetRadarModeR(void)	{return mode;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+84]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarModeR@RadarClass@@UAE?AW4RadarMode@1@XZ ENDP	; RadarClass::GetRadarModeR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ClearModeDesiredCmd@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearModeDesiredCmd@RadarClass@@UAEXXZ PROC		; RadarClass::ClearModeDesiredCmd, COMDAT
; _this$ = ecx

; 105  : 	virtual void ClearModeDesiredCmd(void)	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearModeDesiredCmd@RadarClass@@UAEXXZ ENDP		; RadarClass::ClearModeDesiredCmd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetBuggedData@RadarClass@@UAEHPAM000@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dir$ = 16						; size = 4
_speed$ = 20						; size = 4
?GetBuggedData@RadarClass@@UAEHPAM000@Z PROC		; RadarClass::GetBuggedData, COMDAT
; _this$ = ecx

; 99   : 	virtual int GetBuggedData (float *x, float *y, float *dir, float *speed) { return FALSE; }; // info about bugged target

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetBuggedData@RadarClass@@UAEHPAM000@Z ENDP		; RadarClass::GetBuggedData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetCursorPosition@RadarClass@@UAEXPAM0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetCursorPosition@RadarClass@@UAEXPAM0@Z PROC		; RadarClass::GetCursorPosition, COMDAT
; _this$ = ecx

; 98   : 	virtual void  GetCursorPosition (float*, float*) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetCursorPosition@RadarClass@@UAEXPAM0@Z ENDP		; RadarClass::GetCursorPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetVolume@RadarClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVolume@RadarClass@@UAEMXZ PROC			; RadarClass::GetVolume, COMDAT
; _this$ = ecx

; 97   : 	virtual float GetVolume (void)				{ return 1.0472F; };	// Default to 60 degree cone

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@3f860aa6
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVolume@RadarClass@@UAEMXZ ENDP			; RadarClass::GetVolume
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetRange@RadarClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRange@RadarClass@@UAEMXZ PROC			; RadarClass::GetRange, COMDAT
; _this$ = ecx

; 96   : 	virtual float GetRange(void)				{ return 10.0F; };		// Display range in NM

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@41200000
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRange@RadarClass@@UAEMXZ ENDP			; RadarClass::GetRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?GetAGCenter@RadarClass@@UAEXPAM0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetAGCenter@RadarClass@@UAEXPAM0@Z PROC		; RadarClass::GetAGCenter, COMDAT
; _this$ = ecx

; 95   : 	virtual void  GetAGCenter (float* x, float* y)	{*x = 0; *y = 0;};	// Center of radar ground search

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAGCenter@RadarClass@@UAEXPAM0@Z ENDP		; RadarClass::GetAGCenter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?IsAG@RadarClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAG@RadarClass@@UAEHXZ PROC				; RadarClass::IsAG, COMDAT
; _this$ = ecx

; 94   : 	virtual int   IsAG (void)					{ return FALSE; };		// Is radar in A/G mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAG@RadarClass@@UAEHXZ ENDP				; RadarClass::IsAG
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetGroundPoint@RadarClass@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SetGroundPoint@RadarClass@@UAEXMMM@Z PROC		; RadarClass::SetGroundPoint, COMDAT
; _this$ = ecx

; 91   : 	virtual void SetGroundPoint (float, float, float) {};	//Set center of ground map radar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetGroundPoint@RadarClass@@UAEXMMM@Z ENDP		; RadarClass::SetGroundPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ToggleAGcursorZero@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleAGcursorZero@RadarClass@@UAEXXZ PROC		; RadarClass::ToggleAGcursorZero, COMDAT
; _this$ = ecx

; 90   : 	virtual void ToggleAGcursorZero()			{};	// Remove pilot cursor offsets

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGcursorZero@RadarClass@@UAEXXZ ENDP		; RadarClass::ToggleAGcursorZero
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetAGSnowPlow@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetAGSnowPlow@RadarClass@@UAEXH@Z PROC			; RadarClass::SetAGSnowPlow, COMDAT
; _this$ = ecx

; 89   : 	virtual void SetAGSnowPlow(int )				{};	// Look a fixed distance ahead of the AC

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAGSnowPlow@RadarClass@@UAEXH@Z ENDP			; RadarClass::SetAGSnowPlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ToggleAGsnowPlow@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleAGsnowPlow@RadarClass@@UAEXXZ PROC		; RadarClass::ToggleAGsnowPlow, COMDAT
; _this$ = ecx

; 88   : 	virtual void ToggleAGsnowPlow()				{};	// Look a fixed distance ahead of the AC

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGsnowPlow@RadarClass@@UAEXXZ ENDP		; RadarClass::ToggleAGsnowPlow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ToggleAGfreeze@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleAGfreeze@RadarClass@@UAEXXZ PROC			; RadarClass::ToggleAGfreeze, COMDAT
; _this$ = ecx

; 87   : 	virtual void ToggleAGfreeze()				{};	// Freeze radar image

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleAGfreeze@RadarClass@@UAEXXZ ENDP			; RadarClass::ToggleAGfreeze
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z PROC		; RadarClass::SetMode, COMDAT
; _this$ = ecx

; 85   :    virtual void SetMode(RadarMode )       {};   // Select new mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMode@RadarClass@@UAEXW4RadarMode@1@@Z ENDP		; RadarClass::SetMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAGgain@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?StepAGgain@RadarClass@@UAEXH@Z PROC			; RadarClass::StepAGgain, COMDAT
; _this$ = ecx

; 84   : 	virtual void StepAGgain( int )			{};	// Select gain on GM radar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?StepAGgain@RadarClass@@UAEXH@Z ENDP			; RadarClass::StepAGgain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAGfov@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGfov@RadarClass@@UAEXXZ PROC			; RadarClass::StepAGfov, COMDAT
; _this$ = ecx

; 83   : 	virtual void StepAGfov()					{};	// Select the degree of "zoom" on GM radar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGfov@RadarClass@@UAEXXZ ENDP			; RadarClass::StepAGfov
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAGmode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAGmode@RadarClass@@UAEXXZ PROC			; RadarClass::StepAGmode, COMDAT
; _this$ = ecx

; 81   : 	virtual void StepAGmode( void )				{};	// Enter or step AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAGmode@RadarClass@@UAEXXZ ENDP			; RadarClass::StepAGmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?DefaultAGMode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DefaultAGMode@RadarClass@@UAEXXZ PROC			; RadarClass::DefaultAGMode, COMDAT
; _this$ = ecx

; 80   : 	virtual void DefaultAGMode( void )			{};	// If not in AG go to default AG mode, otherwise nothing

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultAGMode@RadarClass@@UAEXXZ ENDP			; RadarClass::DefaultAGMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAelvation@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?StepAAelvation@RadarClass@@UAEXH@Z PROC		; RadarClass::StepAAelvation, COMDAT
; _this$ = ecx

; 78   : 	virtual void StepAAelvation( int )		{};	// Adjust the lookup/lookdown angle of the radar (cmd=0 means center it)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?StepAAelvation@RadarClass@@UAEXH@Z ENDP		; RadarClass::StepAAelvation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAscanWidth@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAscanWidth@RadarClass@@UAEXXZ PROC		; RadarClass::StepAAscanWidth, COMDAT
; _this$ = ecx

; 77   : 	virtual void StepAAscanWidth()				{};	// radar scan volume.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAscanWidth@RadarClass@@UAEXXZ ENDP		; RadarClass::StepAAscanWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAscanHeight@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAscanHeight@RadarClass@@UAEXXZ PROC		; RadarClass::StepAAscanHeight, COMDAT
; _this$ = ecx

; 76   : 	virtual void StepAAscanHeight()				{};	// Adjust the width and height of the

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAscanHeight@RadarClass@@UAEXXZ ENDP		; RadarClass::StepAAscanHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACM30x20@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACM30x20@RadarClass@@UAEXXZ PROC			; RadarClass::SelectACM30x20, COMDAT
; _this$ = ecx

; 74   : 	virtual void SelectACM30x20()				{};	//  when already in an ACM mode.)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACM30x20@RadarClass@@UAEXXZ ENDP			; RadarClass::SelectACM30x20
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACMSlew@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMSlew@RadarClass@@UAEXXZ PROC			; RadarClass::SelectACMSlew, COMDAT
; _this$ = ecx

; 73   : 	virtual void SelectACMSlew()				{};	// (in hard mode, at least, this only works

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMSlew@RadarClass@@UAEXXZ ENDP			; RadarClass::SelectACMSlew
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACMBore@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMBore@RadarClass@@UAEXXZ PROC			; RadarClass::SelectACMBore, COMDAT
; _this$ = ecx

; 72   : 	virtual void SelectACMBore()				{};	// AA mode.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMBore@RadarClass@@UAEXXZ ENDP			; RadarClass::SelectACMBore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SelectACMVertical@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SelectACMVertical@RadarClass@@UAEXXZ PROC		; RadarClass::SelectACMVertical, COMDAT
; _this$ = ecx

; 71   : 	virtual void SelectACMVertical()			{};	// Go directly to the named

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectACMVertical@RadarClass@@UAEXXZ ENDP		; RadarClass::SelectACMVertical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?ClearOverride@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearOverride@RadarClass@@UAEXXZ PROC			; RadarClass::ClearOverride, COMDAT
; _this$ = ecx

; 69   : 	virtual void ClearOverride()				{};	// Return to previous mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearOverride@RadarClass@@UAEXXZ ENDP			; RadarClass::ClearOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetMRMOverride@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetMRMOverride@RadarClass@@UAEXXZ PROC			; RadarClass::SetMRMOverride, COMDAT
; _this$ = ecx

; 68   : 	virtual void SetMRMOverride()				{};	// Temporary pop into medium range AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetMRMOverride@RadarClass@@UAEXXZ ENDP			; RadarClass::SetMRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetSRMOverride@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetSRMOverride@RadarClass@@UAEXXZ PROC			; RadarClass::SetSRMOverride, COMDAT
; _this$ = ecx

; 67   : 	virtual void SetSRMOverride()				{};	// Temporary pop into short range AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetSRMOverride@RadarClass@@UAEXXZ ENDP			; RadarClass::SetSRMOverride
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?StepAAmode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StepAAmode@RadarClass@@UAEXXZ PROC			; RadarClass::StepAAmode, COMDAT
; _this$ = ecx

; 66   : 	virtual void StepAAmode( void )				{};	// Enter or step AA mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?StepAAmode@RadarClass@@UAEXXZ ENDP			; RadarClass::StepAAmode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?DefaultAAMode@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DefaultAAMode@RadarClass@@UAEXXZ PROC			; RadarClass::DefaultAAMode, COMDAT
; _this$ = ecx

; 65   : 	virtual void DefaultAAMode( void )			{};	// If not in AA go to default AA mode, otherwise nothing

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultAAMode@RadarClass@@UAEXXZ ENDP			; RadarClass::DefaultAAMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?PrevTarget@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PrevTarget@RadarClass@@UAEXXZ PROC			; RadarClass::PrevTarget, COMDAT
; _this$ = ecx

; 61   : 	virtual void PrevTarget( void )				{};	// Step to prev available target

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrevTarget@RadarClass@@UAEXXZ ENDP			; RadarClass::PrevTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?NextTarget@RadarClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NextTarget@RadarClass@@UAEXXZ PROC			; RadarClass::NextTarget, COMDAT
; _this$ = ecx

; 60   : 	virtual void NextTarget( void )				{};	// Step to next available target

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?NextTarget@RadarClass@@UAEXXZ ENDP			; RadarClass::NextTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?RangeStep@RadarClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?RangeStep@RadarClass@@UAEXH@Z PROC			; RadarClass::RangeStep, COMDAT
; _this$ = ecx

; 58   : 	virtual void RangeStep( int )			{};	// Step up/down in range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?RangeStep@RadarClass@@UAEXH@Z ENDP			; RadarClass::RangeStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ??1RadarClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RadarClass@@UAE@XZ PROC				; RadarClass::~RadarClass, COMDAT
; _this$ = ecx

; 38   : 	virtual ~RadarClass()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RadarClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SensorClass@@UAE@XZ			; SensorClass::~SensorClass
	mov	esp, ebp
	pop	ebp
	ret	0
??1RadarClass@@UAE@XZ ENDP				; RadarClass::~RadarClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ PROC	; SensorClass::GetDisplay, COMDAT
; _this$ = ecx

; 55   : 	VirtualDisplay*	GetDisplay(void)                        { return privateDisplay; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@SensorClass@@UAEPAVVirtualDisplay@@XZ ENDP	; SensorClass::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ PROC	; SensorClass::TargetUnderCursor, COMDAT
; _this$ = ecx

; 53   : 	virtual VU_ID TargetUnderCursor (void)                  { return targetUnderCursor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?TargetUnderCursor@SensorClass@@UAE?AVVU_ID@@XZ ENDP	; SensorClass::TargetUnderCursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SetSeekerPos@SensorClass@@UAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newAz$ = 8						; size = 4
_newEl$ = 12						; size = 4
?SetSeekerPos@SensorClass@@UAEXMM@Z PROC		; SensorClass::SetSeekerPos, COMDAT
; _this$ = ecx

; 51   : 	virtual void SetSeekerPos (float newAz, float newEl)	{ seekerAzCenter = newAz; seekerElCenter = newEl; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newAz$[ebp]
	movss	DWORD PTR [eax+56], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newEl$[ebp]
	movss	DWORD PTR [ecx+60], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSeekerPos@SensorClass@@UAEXMM@Z ENDP		; SensorClass::SetSeekerPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?UpdateState@SensorClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?UpdateState@SensorClass@@UAEXHH@Z PROC			; SensorClass::UpdateState, COMDAT
; _this$ = ecx

; 50   : 	virtual void UpdateState(int, int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateState@SensorClass@@UAEXHH@Z ENDP			; SensorClass::UpdateState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?ExecModes@SensorClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?ExecModes@SensorClass@@UAEXHH@Z PROC			; SensorClass::ExecModes, COMDAT
; _this$ = ecx

; 49   : 	virtual void ExecModes(int, int)						{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?ExecModes@SensorClass@@UAEXHH@Z ENDP			; SensorClass::ExecModes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?IsOn@SensorClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOn@SensorClass@@UAEHXZ PROC				; SensorClass::IsOn, COMDAT
; _this$ = ecx

; 40   : 	virtual BOOL			IsOn(void)				{ return isOn; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsOn@SensorClass@@UAEHXZ ENDP				; SensorClass::IsOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SetType@SensorClass@@UAEXW4SensorType@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_senstype$ = 8						; size = 4
?SetType@SensorClass@@UAEXW4SensorType@1@@Z PROC	; SensorClass::SetType, COMDAT
; _this$ = ecx

; 37   : 	virtual void	SetType(SensorType senstype)		{ sensorType = senstype; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _senstype$[ebp]
	mov	DWORD PTR [eax+68], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetType@SensorClass@@UAEXW4SensorType@1@@Z ENDP	; SensorClass::SetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mfd.h
;	COMDAT ?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vd$ = 8						; size = 4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z PROC	; MfdDrawable::Display, COMDAT
; _this$ = ecx

; 138  :       virtual void Display (VirtualDisplay*vd) { display = vd; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vd$[ebp]
	mov	DWORD PTR [eax+20], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@MfdDrawable@@UAEXPAVVirtualDisplay@@@Z ENDP	; MfdDrawable::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
