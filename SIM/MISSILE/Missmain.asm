; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\MISSILE\Missmain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?misPos@@3UACMIMissilePositionRecord@@A		; misPos
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
_BSS	SEGMENT
?misPos@@3UACMIMissilePositionRecord@@A DB 025H DUP (?)	; misPos
_BSS	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_MISSILE_SPEED DD 044bb8000r			; 1500
_MISSILE_ALTITUDE_BONUS DD 041b80000r		; 23
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
_DATA	SEGMENT
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_DATA	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_atanf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	_tanf
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?tan@@YAMM@Z					; tan
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z	; DrawableObject::GetPosition
PUBLIC	?GetNumSwitches@DrawableBSP@@QAEHXZ		; DrawableBSP::GetNumSwitches
PUBLIC	?SetYPR@VuEntity@@QAEXMMM@Z			; VuEntity::SetYPR
PUBLIC	?SetYPRDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPRDelta
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?ZDelta@VuEntity@@QBEMXZ			; VuEntity::ZDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?RequestReliableTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestReliableTransmit
PUBLIC	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestOutOfBandTransmit
PUBLIC	?IsCampBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsCampBase
PUBLIC	?IsCampaign@FalconEntity@@QAEHXZ		; FalconEntity::IsCampaign
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?GetRadarMode@FalconEntity@@UAEHXZ		; FalconEntity::GetRadarMode
PUBLIC	?SetRadarMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetRadarMode
PUBLIC	?ReturnToSearch@FalconEntity@@UAEXXZ		; FalconEntity::ReturnToSearch
PUBLIC	?SetSearchMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetSearchMode
PUBLIC	?CombatClass@FalconEntity@@UAEHXZ		; FalconEntity::CombatClass
PUBLIC	?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z	; FalconEntity::HasEntity
PUBLIC	?IsLauncher@FalconEntity@@UAEHXZ		; FalconEntity::IsLauncher
PUBLIC	?IsBomb@FalconEntity@@UAEHXZ			; FalconEntity::IsBomb
PUBLIC	?IsGun@FalconEntity@@UAEHXZ			; FalconEntity::IsGun
PUBLIC	?IsVehicle@FalconEntity@@UAEHXZ			; FalconEntity::IsVehicle
PUBLIC	?IsStatic@FalconEntity@@UAEHXZ			; FalconEntity::IsStatic
PUBLIC	?IsHelicopter@FalconEntity@@UAEHXZ		; FalconEntity::IsHelicopter
PUBLIC	?IsEject@FalconEntity@@UAEHXZ			; FalconEntity::IsEject
PUBLIC	?IsAirplane@FalconEntity@@UAEHXZ		; FalconEntity::IsAirplane
PUBLIC	?IsGroundVehicle@FalconEntity@@UAEHXZ		; FalconEntity::IsGroundVehicle
PUBLIC	?IsShip@FalconEntity@@UAEHXZ			; FalconEntity::IsShip
PUBLIC	?IsDead@FalconEntity@@UAEHXZ			; FalconEntity::IsDead
PUBLIC	?IsEmitting@FalconEntity@@UAEHXZ		; FalconEntity::IsEmitting
PUBLIC	?IsUnit@FalconEntity@@UAEHXZ			; FalconEntity::IsUnit
PUBLIC	?IsObjective@FalconEntity@@UAEHXZ		; FalconEntity::IsObjective
PUBLIC	?IsBattalion@FalconEntity@@UAEHXZ		; FalconEntity::IsBattalion
PUBLIC	?IsBrigade@FalconEntity@@UAEHXZ			; FalconEntity::IsBrigade
PUBLIC	?IsFlight@FalconEntity@@UBEHXZ			; FalconEntity::IsFlight
PUBLIC	?IsSquadron@FalconEntity@@UAEHXZ		; FalconEntity::IsSquadron
PUBLIC	?IsPackage@FalconEntity@@UAEHXZ			; FalconEntity::IsPackage
PUBLIC	?IsTeam@FalconEntity@@UAEHXZ			; FalconEntity::IsTeam
PUBLIC	?IsTaskForce@FalconEntity@@UAEHXZ		; FalconEntity::IsTaskForce
PUBLIC	?GetRCSFactor@FalconEntity@@UAEMXZ		; FalconEntity::GetRCSFactor
PUBLIC	?GetIRFactor@FalconEntity@@UAEMXZ		; FalconEntity::GetIRFactor
PUBLIC	?SetAQUIREtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetAQUIREtimer
PUBLIC	?SetSEARCHtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetSEARCHtimer
PUBLIC	?SetStepSearchMode@FalconEntity@@UAEXE@Z	; FalconEntity::SetStepSearchMode
PUBLIC	?GetAQUIREtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetAQUIREtimer
PUBLIC	?GetSEARCHtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetSEARCHtimer
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	?Type@SensorClass@@QAE?AW4SensorType@1@XZ	; SensorClass::Type
PUBLIC	?SeekerAz@SensorClass@@QAEMXZ			; SensorClass::SeekerAz
PUBLIC	?SeekerEl@SensorClass@@QAEMXZ			; SensorClass::SeekerEl
PUBLIC	??0ObjectGeometry@@QAE@XZ			; ObjectGeometry::ObjectGeometry
PUBLIC	??1ObjectGeometry@@QAE@XZ			; ObjectGeometry::~ObjectGeometry
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?JoinFlight@SimBaseClass@@UAEXXZ		; SimBaseClass::JoinFlight
PUBLIC	?IsSimBase@SimBaseClass@@UAE_NXZ		; SimBaseClass::IsSimBase
PUBLIC	?GetSlot@SimBaseClass@@QAEHXZ			; SimBaseClass::GetSlot
PUBLIC	?GetCountry@SimBaseClass@@UAEEXZ		; SimBaseClass::GetCountry
PUBLIC	?OnGround@SimBaseClass@@UAEHXZ			; SimBaseClass::OnGround
PUBLIC	?IsExploding@SimBaseClass@@UAEHXZ		; SimBaseClass::IsExploding
PUBLIC	?IsDead@SimBaseClass@@UBEHXZ			; SimBaseClass::IsDead
PUBLIC	?IsAwake@SimBaseClass@@QBEHXZ			; SimBaseClass::IsAwake
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?PowerOutput@SimBaseClass@@QAEMXZ		; SimBaseClass::PowerOutput
PUBLIC	?MakePlayerVehicle@SimBaseClass@@UAEXXZ		; SimBaseClass::MakePlayerVehicle
PUBLIC	?MakeNonPlayerVehicle@SimBaseClass@@UAEXXZ	; SimBaseClass::MakeNonPlayerVehicle
PUBLIC	?ConfigurePlayerAvionics@SimBaseClass@@UAEXXZ	; SimBaseClass::ConfigurePlayerAvionics
PUBLIC	?Regenerate@SimBaseClass@@UAEXMMMM@Z		; SimBaseClass::Regenerate
PUBLIC	?Mass@SimBaseClass@@UAEMXZ			; SimBaseClass::Mass
PUBLIC	??7?$VuBin@VFalconEntity@@@@QBE_NXZ		; VuBin<FalconEntity>::operator!
PUBLIC	??B?$VuBin@VFalconEntity@@@@QBE_NXZ		; VuBin<FalconEntity>::operator bool
PUBLIC	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?SetLead@SimMoverClass@@UAEXH@Z			; SimMoverClass::SetLead
PUBLIC	?WeaponKeepAlive@SimMoverClass@@UAEXXZ		; SimMoverClass::WeaponKeepAlive
PUBLIC	?IsMover@SimMoverClass@@UAEHXZ			; SimMoverClass::IsMover
PUBLIC	?SetSeekerPos@MaverickDisplayClass@@QAEXMM@Z	; MaverickDisplayClass::SetSeekerPos
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?MotionOn@SimulationDriver@@QAEHXZ		; SimulationDriver::MotionOn
PUBLIC	?GenerateFastRandom@@YAJXZ			; GenerateFastRandom
PUBLIC	?PRANDInt3@@YAHXZ				; PRANDInt3
PUBLIC	?IsRecording@ACMIRecorder@@QAEHXZ		; ACMIRecorder::IsRecording
PUBLIC	?IsWeapon@SimWeaponClass@@UAEHXZ		; SimWeaponClass::IsWeapon
PUBLIC	?IsUseable@SimWeaponClass@@UAEHXZ		; SimWeaponClass::IsUseable
PUBLIC	?IncrementMissileCount@BattalionClass@@QAEXXZ	; BattalionClass::IncrementMissileCount
PUBLIC	?DecrementMissileCount@BattalionClass@@QAEXXZ	; BattalionClass::DecrementMissileCount
PUBLIC	?IncrementMissileCount@TaskForceClass@@QAEXXZ	; TaskForceClass::IncrementMissileCount
PUBLIC	?DecrementMissileCount@TaskForceClass@@QAEXXZ	; TaskForceClass::DecrementMissileCount
PUBLIC	??0MissileInFlightData@@QAE@XZ			; MissileInFlightData::MissileInFlightData
PUBLIC	??1MissileInFlightData@@QAE@XZ			; MissileInFlightData::~MissileInFlightData
PUBLIC	??_GMissileInFlightData@@QAEPAXI@Z		; MissileInFlightData::`scalar deleting destructor'
PUBLIC	??0MissileClass@@QAE@PAPAEPAJ@Z			; MissileClass::MissileClass
PUBLIC	??0MissileClass@@QAE@PAU_iobuf@@@Z		; MissileClass::MissileClass
PUBLIC	??0MissileClass@@QAE@H@Z			; MissileClass::MissileClass
PUBLIC	??1MissileClass@@UAE@XZ				; MissileClass::~MissileClass
PUBLIC	?InitData@MissileClass@@UAEXXZ			; MissileClass::InitData
PUBLIC	?CleanupData@MissileClass@@UAEXXZ		; MissileClass::CleanupData
PUBLIC	?InitLocalData@MissileClass@@AAEXXZ		; MissileClass::InitLocalData
PUBLIC	?CleanupLocalData@MissileClass@@AAEXXZ		; MissileClass::CleanupLocalData
PUBLIC	?GetSeekerType@MissileClass@@QAEHXZ		; MissileClass::GetSeekerType
PUBLIC	?LaunchDelayTime@MissileClass@@UAEHXZ		; MissileClass::LaunchDelayTime
PUBLIC	?Init@MissileClass@@UAEXXZ			; MissileClass::Init
PUBLIC	?Init@MissileClass@@UAEXPAVSimInitDataClass@@@Z	; MissileClass::Init
PUBLIC	?Exec@MissileClass@@UAEHXZ			; MissileClass::Exec
PUBLIC	?GetTransform@MissileClass@@UAEXQAY02M@Z	; MissileClass::GetTransform
PUBLIC	?Start@MissileClass@@QAEXPAVSimObjectType@@@Z	; MissileClass::Start
PUBLIC	?ClearReferences@MissileClass@@QAEXXZ		; MissileClass::ClearReferences
PUBLIC	?SetSeekerPos@MissileClass@@QAEHPAM0@Z		; MissileClass::SetSeekerPos
PUBLIC	?GetSeekerPos@MissileClass@@QAEXPAM0@Z		; MissileClass::GetSeekerPos
PUBLIC	?UpdatePosition@MissileClass@@QAEXXZ		; MissileClass::UpdatePosition
PUBLIC	?GetRMax@MissileClass@@QAEMMMMMM@Z		; MissileClass::GetRMax
PUBLIC	?GetTOF@MissileClass@@QAEMMMMMM@Z		; MissileClass::GetTOF
PUBLIC	?GetASE@MissileClass@@QAEMMMMMM@Z		; MissileClass::GetASE
PUBLIC	?GetActiveTime@MissileClass@@QAEMMMMMM@Z	; MissileClass::GetActiveTime
PUBLIC	?GetActiveRange@MissileClass@@QAEMMMMMM@Z	; MissileClass::GetActiveRange
PUBLIC	?SetDead@MissileClass@@UAEXH@Z			; MissileClass::SetDead
PUBLIC	?Sleep@MissileClass@@UAEHXZ			; MissileClass::Sleep
PUBLIC	?Wake@MissileClass@@UAEHXZ			; MissileClass::Wake
PUBLIC	?SetVuPosition@MissileClass@@UAEXXZ		; MissileClass::SetVuPosition
PUBLIC	?IsMissile@MissileClass@@UAEHXZ			; MissileClass::IsMissile
PUBLIC	?FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z ; MissileClass::FindRocketGroundImpact
PUBLIC	?FlyMissile@MissileClass@@AAEXXZ		; MissileClass::FlyMissile
PUBLIC	?EndMissile@MissileClass@@AAEXXZ		; MissileClass::EndMissile
PUBLIC	?ApplyProximityDamage@MissileClass@@AAEXXZ	; MissileClass::ApplyProximityDamage
PUBLIC	??_GMissileClass@@UAEPAXI@Z			; MissileClass::`scalar deleting destructor'
PUBLIC	?GetColor@TeamClass@@QAEHXZ			; TeamClass::GetColor
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA	; `GenerateFastRandom'::`2'::LastRandom
PUBLIC	??_7MissileClass@@6B@				; MissileClass::`vftable'
PUBLIC	??_C@_0FN@MNJCEOEK@?$CK?$CK?9?9?$CK?$CK?5Rng?5?$CFf?5Imp?5X?5?$CFf?5Imp?5Y?5?$CFf?5@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MissileClass@@6B@				; MissileClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMissileClass@@@8			; MissileClass `RTTI Type Descriptor'
PUBLIC	??_R3MissileClass@@8				; MissileClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MissileClass@@8				; MissileClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MissileClass@@8			; MissileClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@SimWeaponClass@@8			; SimWeaponClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimWeaponClass@@@8			; SimWeaponClass `RTTI Type Descriptor'
PUBLIC	??_R3SimWeaponClass@@8				; SimWeaponClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimWeaponClass@@8				; SimWeaponClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimMoverClass@@8			; SimMoverClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimMoverClass@@@8			; SimMoverClass `RTTI Type Descriptor'
PUBLIC	??_R3SimMoverClass@@8				; SimMoverClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimMoverClass@@8				; SimMoverClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimBaseClass@@8			; SimBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimBaseClass@@@8			; SimBaseClass `RTTI Type Descriptor'
PUBLIC	??_R3SimBaseClass@@8				; SimBaseClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimBaseClass@@8				; SimBaseClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FalconEntity@@8			; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFalconEntity@@@8			; FalconEntity `RTTI Type Descriptor'
PUBLIC	??_R3FalconEntity@@8				; FalconEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FalconEntity@@8				; FalconEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuEntity@@8			; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuEntity@@@8				; VuEntity `RTTI Type Descriptor'
PUBLIC	??_R3VuEntity@@8				; VuEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuEntity@@8				; VuEntity::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f800000
PUBLIC	__real@3fb1eb851eb851ec
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@42652ee1
PUBLIC	__real@42c80000
PUBLIC	__real@43160000
PUBLIC	__real@43340000
PUBLIC	__real@447a0000
PUBLIC	__real@44bb8000
PUBLIC	__real@451c4000
PUBLIC	__real@454cffae
PUBLIC	__real@462be000
PUBLIC	__real@463de1b0
PUBLIC	__real@7f7fffff
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0a00000
PUBLIC	__real@c4610000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_fflush:PROC
EXTRN	_fprintf:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SetSwitchMask@DrawableBSP@@QAEXHK@Z:PROC	; DrawableBSP::SetSwitchMask
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?SetPosition@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetPosition
EXTRN	?SetDelta@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetDelta
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z:PROC ; VuEntity::CustomCollisionCheck
EXTRN	?TerrainCollisionCheck@VuEntity@@UAEEXZ:PROC	; VuEntity::TerrainCollisionCheck
EXTRN	?IsTarget@VuEntity@@UAEEXZ:PROC			; VuEntity::IsTarget
EXTRN	?IsSession@VuEntity@@UAEEXZ:PROC		; VuEntity::IsSession
EXTRN	?IsGroup@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGroup
EXTRN	?IsGame@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGame
EXTRN	?IsCamera@VuEntity@@UBEEXZ:PROC			; VuEntity::IsCamera
EXTRN	?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuEvent@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuEntityCollisionEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuSessionEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z:PROC ; VuGridIterator::VuGridIterator
EXTRN	??1VuGridIterator@@UAE@XZ:PROC			; VuGridIterator::~VuGridIterator
EXTRN	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetFirst
EXTRN	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ:PROC ; VuGridIterator::GetNext
EXTRN	?GetDomain@FalconEntity@@UAEEXZ:PROC		; FalconEntity::GetDomain
EXTRN	?GetDamageModifiers@FalconEntity@@UAEPAEXZ:PROC	; FalconEntity::GetDamageModifiers
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	??0EyeballClass@@QAE@HPAVSimMoverClass@@@Z:PROC	; EyeballClass::EyeballClass
EXTRN	??0IrstClass@@QAE@HPAVSimMoverClass@@@Z:PROC	; IrstClass::IrstClass
EXTRN	?UpdatePos@F4SoundPos@@QAEXPAVSimBaseClass@@@Z:PROC ; F4SoundPos::UpdatePos
EXTRN	?Sfx@F4SoundPos@@QAEXHHMM@Z:PROC		; F4SoundPos::Sfx
EXTRN	?GetTeam@SimBaseClass@@UAEEXZ:PROC		; SimBaseClass::GetTeam
EXTRN	?GetCampID@SimBaseClass@@UAEFXZ:PROC		; SimBaseClass::GetCampID
EXTRN	?GetMovementType@SimBaseClass@@UAE?AW4MoveType@@XZ:PROC ; SimBaseClass::GetMovementType
EXTRN	?SetExploding@SimBaseClass@@QAEXH@Z:PROC	; SimBaseClass::SetExploding
EXTRN	?IsSPJamming@SimBaseClass@@UAEHXZ:PROC		; SimBaseClass::IsSPJamming
EXTRN	?IsAreaJamming@SimBaseClass@@UAEHXZ:PROC	; SimBaseClass::IsAreaJamming
EXTRN	?HasSPJamming@SimBaseClass@@UAEHXZ:PROC		; SimBaseClass::HasSPJamming
EXTRN	?HasAreaJamming@SimBaseClass@@UAEHXZ:PROC	; SimBaseClass::HasAreaJamming
EXTRN	?SetFlag@SimBaseClass@@QAEXH@Z:PROC		; SimBaseClass::SetFlag
EXTRN	?ApplyDamage@SimBaseClass@@UAEXPAVFalconDamageMessage@@@Z:PROC ; SimBaseClass::ApplyDamage
EXTRN	?ApplyDeathMessage@SimBaseClass@@UAEXPAVFalconDeathMessage@@@Z:PROC ; SimBaseClass::ApplyDeathMessage
EXTRN	?GetFocusPoint@SimBaseClass@@UAEXAAM00@Z:PROC	; SimBaseClass::GetFocusPoint
EXTRN	?GetP@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetP
EXTRN	?GetQ@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetQ
EXTRN	?GetR@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetR
EXTRN	?GetAlpha@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetAlpha
EXTRN	?GetBeta@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetBeta
EXTRN	?GetNx@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetNx
EXTRN	?GetNy@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetNy
EXTRN	?GetNz@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetNz
EXTRN	?GetGamma@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetGamma
EXTRN	?GetSigma@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetSigma
EXTRN	?GetMu@SimMoverClass@@UAEMXZ:PROC		; SimMoverClass::GetMu
EXTRN	?GetVt@SimMoverClass@@UBEMXZ:PROC		; SimMoverClass::GetVt
EXTRN	?GetKias@SimMoverClass@@UBEMXZ:PROC		; SimMoverClass::GetKias
EXTRN	?MakeLocal@SimMoverClass@@UAEXXZ:PROC		; SimMoverClass::MakeLocal
EXTRN	?MakeRemote@SimMoverClass@@UAEXXZ:PROC		; SimMoverClass::MakeRemote
EXTRN	?ChangeOwner@SimMoverClass@@UAEXVVU_ID@@@Z:PROC	; SimMoverClass::ChangeOwner
EXTRN	?FeatureCollision@SimMoverClass@@UAEPAVSimBaseClass@@M@Z:PROC ; SimMoverClass::FeatureCollision
EXTRN	?CheckLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z:PROC ; SimMoverClass::CheckLOS
EXTRN	?CheckCompositeLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z:PROC ; SimMoverClass::CheckCompositeLOS
EXTRN	?InsertionCallback@SimMoverClass@@UAEHXZ:PROC	; SimMoverClass::InsertionCallback
EXTRN	?RemovalCallback@SimMoverClass@@UAEHXZ:PROC	; SimMoverClass::RemovalCallback
EXTRN	??0MaverickDisplayClass@@QAE@PAVSimMoverClass@@@Z:PROC ; MaverickDisplayClass::MaverickDisplayClass
EXTRN	??0SimObjectType@@QAE@PAVFalconEntity@@@Z:PROC	; SimObjectType::SimObjectType
EXTRN	?Reference@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Reference
EXTRN	?Release@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Release
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?GetGroundType@OTWDriverClass@@QAEHMM@Z:PROC	; OTWDriverClass::GetGroundType
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z:PROC ; CampBaseClass::GetComponentIndex
EXTRN	??0BeamRiderClass@@QAE@HPAVSimMoverClass@@@Z:PROC ; BeamRiderClass::BeamRiderClass
EXTRN	?SetGuidancePlatform@BeamRiderClass@@QAEXPAVFalconEntity@@@Z:PROC ; BeamRiderClass::SetGuidancePlatform
EXTRN	?SendTrackMsg@BeamRiderClass@@QAEXPAVSimObjectType@@II@Z:PROC ; BeamRiderClass::SendTrackMsg
EXTRN	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z:PROC		; ACMI_Hash::Add
EXTRN	?MissilePositionRecord@ACMIRecorder@@QAEXPAUACMIMissilePositionRecord@@@Z:PROC ; ACMIRecorder::MissilePositionRecord
EXTRN	?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z:PROC ; ACMIRecorder::StationarySfxRecord
EXTRN	?AddToTimedPersistantList@@YAXHKMM@Z:PROC	; AddToTimedPersistantList
EXTRN	??0SimWeaponClass@@QAE@H@Z:PROC			; SimWeaponClass::SimWeaponClass
EXTRN	??0SimWeaponClass@@QAE@PAPAEPAJ@Z:PROC		; SimWeaponClass::SimWeaponClass
EXTRN	??0SimWeaponClass@@QAE@PAU_iobuf@@@Z:PROC	; SimWeaponClass::SimWeaponClass
EXTRN	??1SimWeaponClass@@UAE@XZ:PROC			; SimWeaponClass::~SimWeaponClass
EXTRN	?InitData@SimWeaponClass@@UAEXXZ:PROC		; SimWeaponClass::InitData
EXTRN	?CleanupData@SimWeaponClass@@UAEXXZ:PROC	; SimWeaponClass::CleanupData
EXTRN	?Sleep@SimWeaponClass@@UAEHXZ:PROC		; SimWeaponClass::Sleep
EXTRN	?Wake@SimWeaponClass@@UAEHXZ:PROC		; SimWeaponClass::Wake
EXTRN	?Init@SimWeaponClass@@UAEXXZ:PROC		; SimWeaponClass::Init
EXTRN	?SetDead@SimWeaponClass@@UAEXH@Z:PROC		; SimWeaponClass::SetDead
EXTRN	?SaveSize@SimWeaponClass@@UAEHXZ:PROC		; SimWeaponClass::SaveSize
EXTRN	?Save@SimWeaponClass@@UAEHPAPAE@Z:PROC		; SimWeaponClass::Save
EXTRN	?Save@SimWeaponClass@@UAEHPAU_iobuf@@@Z:PROC	; SimWeaponClass::Save
EXTRN	?Handle@SimWeaponClass@@UAEHPAVVuFullUpdateEvent@@@Z:PROC ; SimWeaponClass::Handle
EXTRN	?Handle@SimWeaponClass@@UAEHPAVVuPositionUpdateEvent@@@Z:PROC ; SimWeaponClass::Handle
EXTRN	?Handle@SimWeaponClass@@UAEHPAVVuTransferEvent@@@Z:PROC ; SimWeaponClass::Handle
EXTRN	?SendDamageMessage@SimWeaponClass@@QAEXPAVFalconEntity@@MH@Z:PROC ; SimWeaponClass::SendDamageMessage
EXTRN	?GetRadarType@SimWeaponClass@@UAEHXZ:PROC	; SimWeaponClass::GetRadarType
EXTRN	??0HarmSeekerClass@@QAE@HPAVSimMoverClass@@@Z:PROC ; HarmSeekerClass::HarmSeekerClass
EXTRN	?ThreedInterp@SIMLIB_MATH_CLASS@@QAEMMMMPBM000HHHPAH11@Z:PROC ; SIMLIB_MATH_CLASS::ThreedInterp
EXTRN	??0FalconMissileEndMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconMissileEndMessage::FalconMissileEndMessage
EXTRN	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z:PROC ; FalconMissileEndMessage::SetParticleEffectName
EXTRN	?UpdateTargetData@MissileClass@@QAEXXZ:PROC	; MissileClass::UpdateTargetData
EXTRN	?SetTarget@MissileClass@@QAEXPAVSimObjectType@@@Z:PROC ; MissileClass::SetTarget
EXTRN	?DropTarget@MissileClass@@QAEXXZ:PROC		; MissileClass::DropTarget
EXTRN	?ClosestApproach@MissileClass@@AAEXXZ:PROC	; MissileClass::ClosestApproach
EXTRN	?CommandGuide@MissileClass@@AAEXXZ:PROC		; MissileClass::CommandGuide
EXTRN	?Flight@MissileClass@@AAEXXZ:PROC		; MissileClass::Flight
EXTRN	?Init1@MissileClass@@AAEXXZ:PROC		; MissileClass::Init1
EXTRN	?Launch@MissileClass@@AAEXXZ:PROC		; MissileClass::Launch
EXTRN	?LimitSeeker@MissileClass@@AAEXMM@Z:PROC	; MissileClass::LimitSeeker
EXTRN	?ReadInput@MissileClass@@AAEXH@Z:PROC		; MissileClass::ReadInput
EXTRN	?SetStatus@MissileClass@@AAEXXZ:PROC		; MissileClass::SetStatus
EXTRN	?UpdateTrail@MissileClass@@AAEXXZ:PROC		; MissileClass::UpdateTrail
EXTRN	?RemoveTrail@MissileClass@@AAEXXZ:PROC		; MissileClass::RemoveTrail
EXTRN	??_EMissileClass@@UAEPAXI@Z:PROC		; MissileClass::`vector deleting destructor'
EXTRN	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconRadioChatterMessage::FalconRadioChatterMessage
EXTRN	?GetPilotVoiceID@FlightClass@@QAEEH@Z:PROC	; FlightClass::GetPilotVoiceID
EXTRN	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z:PROC ; CalcTransformMatrix
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibMinorFrameTime@@3MA:DWORD		; SimLibMinorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?SimLibFrameCount@@3IA:DWORD			; SimLibFrameCount
EXTRN	?SimLibMinorPerMajor@@3HA:DWORD			; SimLibMinorPerMajor
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?SimWeaponDataTable@@3PAUSimWeaponDataType@@A:DWORD ; SimWeaponDataTable
EXTRN	?ObjProxList@@3PAVVuGridTree@@A:DWORD		; ObjProxList
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?gACMIRec@@3VACMIRecorder@@A:BYTE		; gACMIRec
EXTRN	?ACMIIDTable@@3PAVACMI_Hash@@A:DWORD		; ACMIIDTable
EXTRN	?missileDataset@@3PAVMissileDataSetClass@@A:DWORD ; missileDataset
EXTRN	?numMissileDatasets@@3HA:DWORD			; numMissileDatasets
EXTRN	?Math@@3VSIMLIB_MATH_CLASS@@A:BYTE		; Math
EXTRN	?TeamInfo@@3PAPAVTeamClass@@A:BYTE		; TeamInfo
EXTRN	?g_nMissileFix@@3HA:DWORD			; g_nMissileFix
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA
_BSS	SEGMENT
?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA DD 01H DUP (?) ; `GenerateFastRandom'::`2'::LastRandom
_BSS	ENDS
;	COMDAT ?fp@?1??FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z@4PAU_iobuf@@A
_BSS	SEGMENT
?fp@?1??FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z@4PAU_iobuf@@A DD 01H DUP (?) ; `MissileClass::FindRocketGroundImpact'::`2'::fp
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c4610000
CONST	SEGMENT
__real@c4610000 DD 0c4610000r			; -900
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
CONST	ENDS
;	COMDAT __real@463de1b0
CONST	SEGMENT
__real@463de1b0 DD 0463de1b0r			; 12152.4
CONST	ENDS
;	COMDAT __real@462be000
CONST	SEGMENT
__real@462be000 DD 0462be000r			; 11000
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@451c4000
CONST	SEGMENT
__real@451c4000 DD 0451c4000r			; 2500
CONST	ENDS
;	COMDAT __real@44bb8000
CONST	SEGMENT
__real@44bb8000 DD 044bb8000r			; 1500
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fb1eb851eb851ec
CONST	SEGMENT
__real@3fb1eb851eb851ec DQ 03fb1eb851eb851ecr	; 0.07
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2VuEntity@@8
rdata$r	SEGMENT
??_R2VuEntity@@8 DD FLAT:??_R1A@?0A@EA@VuEntity@@8	; VuEntity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuEntity@@8
rdata$r	SEGMENT
??_R3VuEntity@@8 DD 00H					; VuEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuEntity@@@8
_DATA	SEGMENT
??_R0?AVVuEntity@@@8 DD FLAT:??_7type_info@@6B@		; VuEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuEntity@@8 DD FLAT:??_R0?AVVuEntity@@@8	; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FalconEntity@@8
rdata$r	SEGMENT
??_R2FalconEntity@@8 DD FLAT:??_R1A@?0A@EA@FalconEntity@@8 ; FalconEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3FalconEntity@@8
rdata$r	SEGMENT
??_R3FalconEntity@@8 DD 00H				; FalconEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFalconEntity@@@8
_DATA	SEGMENT
??_R0?AVFalconEntity@@@8 DD FLAT:??_7type_info@@6B@	; FalconEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFalconEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FalconEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FalconEntity@@8 DD FLAT:??_R0?AVFalconEntity@@@8 ; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2SimBaseClass@@8
rdata$r	SEGMENT
??_R2SimBaseClass@@8 DD FLAT:??_R1A@?0A@EA@SimBaseClass@@8 ; SimBaseClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3SimBaseClass@@8
rdata$r	SEGMENT
??_R3SimBaseClass@@8 DD 00H				; SimBaseClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SimBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimBaseClass@@@8
_DATA	SEGMENT
??_R0?AVSimBaseClass@@@8 DD FLAT:??_7type_info@@6B@	; SimBaseClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimBaseClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SimBaseClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimBaseClass@@8 DD FLAT:??_R0?AVSimBaseClass@@@8 ; SimBaseClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimBaseClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SimMoverClass@@8
rdata$r	SEGMENT
??_R2SimMoverClass@@8 DD FLAT:??_R1A@?0A@EA@SimMoverClass@@8 ; SimMoverClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3SimMoverClass@@8
rdata$r	SEGMENT
??_R3SimMoverClass@@8 DD 00H				; SimMoverClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2SimMoverClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimMoverClass@@@8
_DATA	SEGMENT
??_R0?AVSimMoverClass@@@8 DD FLAT:??_7type_info@@6B@	; SimMoverClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimMoverClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SimMoverClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimMoverClass@@8 DD FLAT:??_R0?AVSimMoverClass@@@8 ; SimMoverClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimMoverClass@@8
rdata$r	ENDS
;	COMDAT ??_R2SimWeaponClass@@8
rdata$r	SEGMENT
??_R2SimWeaponClass@@8 DD FLAT:??_R1A@?0A@EA@SimWeaponClass@@8 ; SimWeaponClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimMoverClass@@8
	DD	FLAT:??_R1A@?0A@EA@SimBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3SimWeaponClass@@8
rdata$r	SEGMENT
??_R3SimWeaponClass@@8 DD 00H				; SimWeaponClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2SimWeaponClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimWeaponClass@@@8
_DATA	SEGMENT
??_R0?AVSimWeaponClass@@@8 DD FLAT:??_7type_info@@6B@	; SimWeaponClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimWeaponClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@SimWeaponClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimWeaponClass@@8 DD FLAT:??_R0?AVSimWeaponClass@@@8 ; SimWeaponClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimWeaponClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MissileClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MissileClass@@8 DD FLAT:??_R0?AVMissileClass@@@8 ; MissileClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MissileClass@@8
rdata$r	ENDS
;	COMDAT ??_R2MissileClass@@8
rdata$r	SEGMENT
??_R2MissileClass@@8 DD FLAT:??_R1A@?0A@EA@MissileClass@@8 ; MissileClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimWeaponClass@@8
	DD	FLAT:??_R1A@?0A@EA@SimMoverClass@@8
	DD	FLAT:??_R1A@?0A@EA@SimBaseClass@@8
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3MissileClass@@8
rdata$r	SEGMENT
??_R3MissileClass@@8 DD 00H				; MissileClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2MissileClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMissileClass@@@8
_DATA	SEGMENT
??_R0?AVMissileClass@@@8 DD FLAT:??_7type_info@@6B@	; MissileClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMissileClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MissileClass@@6B@
rdata$r	SEGMENT
??_R4MissileClass@@6B@ DD 00H				; MissileClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMissileClass@@@8
	DD	FLAT:??_R3MissileClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@MNJCEOEK@?$CK?$CK?9?9?$CK?$CK?5Rng?5?$CFf?5Imp?5X?5?$CFf?5Imp?5Y?5?$CFf?5@
CONST	SEGMENT
??_C@_0FN@MNJCEOEK@?$CK?$CK?9?9?$CK?$CK?5Rng?5?$CFf?5Imp?5X?5?$CFf?5Imp?5Y?5?$CFf?5@ DB '*'
	DB	'*--** Rng %f Imp X %f Imp Y %f Imp Z %f pel %f paz %f PipEl %'
	DB	'f PipAz %f dx %f dy %f dz %f ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_7MissileClass@@6B@
CONST	SEGMENT
??_7MissileClass@@6B@ DD FLAT:??_R4MissileClass@@6B@	; MissileClass::`vftable'
	DD	FLAT:?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z
	DD	FLAT:?TerrainCollisionCheck@VuEntity@@UAEEXZ
	DD	FLAT:?IsTarget@VuEntity@@UAEEXZ
	DD	FLAT:?IsSession@VuEntity@@UAEEXZ
	DD	FLAT:?IsGroup@VuEntity@@UAEEXZ
	DD	FLAT:?IsGame@VuEntity@@UAEEXZ
	DD	FLAT:?IsCamera@VuEntity@@UBEEXZ
	DD	FLAT:?SaveSize@SimWeaponClass@@UAEHXZ
	DD	FLAT:?Save@SimWeaponClass@@UAEHPAU_iobuf@@@Z
	DD	FLAT:?Save@SimWeaponClass@@UAEHPAPAE@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuSessionEvent@@@Z
	DD	FLAT:?Handle@SimWeaponClass@@UAEHPAVVuTransferEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuEntityCollisionEvent@@@Z
	DD	FLAT:?Handle@SimWeaponClass@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@SimWeaponClass@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z
	DD	FLAT:??_EMissileClass@@UAEPAXI@Z
	DD	FLAT:?InsertionCallback@SimMoverClass@@UAEHXZ
	DD	FLAT:?RemovalCallback@SimMoverClass@@UAEHXZ
	DD	FLAT:?InitData@MissileClass@@UAEXXZ
	DD	FLAT:?CleanupData@MissileClass@@UAEXXZ
	DD	FLAT:?IsSimBase@SimBaseClass@@UAE_NXZ
	DD	FLAT:?IsCampBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?Wake@MissileClass@@UAEHXZ
	DD	FLAT:?Sleep@MissileClass@@UAEHXZ
	DD	FLAT:?GetCampID@SimBaseClass@@UAEFXZ
	DD	FLAT:?GetTeam@SimBaseClass@@UAEEXZ
	DD	FLAT:?GetCountry@SimBaseClass@@UAEEXZ
	DD	FLAT:?GetDomain@FalconEntity@@UAEEXZ
	DD	FLAT:?GetRadarMode@FalconEntity@@UAEHXZ
	DD	FLAT:?SetRadarMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?ReturnToSearch@FalconEntity@@UAEXXZ
	DD	FLAT:?SetSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?CombatClass@FalconEntity@@UAEHXZ
	DD	FLAT:?OnGround@SimBaseClass@@UAEHXZ
	DD	FLAT:?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z
	DD	FLAT:?IsMissile@MissileClass@@UAEHXZ
	DD	FLAT:?IsLauncher@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBomb@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGun@FalconEntity@@UAEHXZ
	DD	FLAT:?IsMover@SimMoverClass@@UAEHXZ
	DD	FLAT:?IsVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsStatic@FalconEntity@@UAEHXZ
	DD	FLAT:?IsHelicopter@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEject@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAirplane@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGroundVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsShip@FalconEntity@@UAEHXZ
	DD	FLAT:?IsWeapon@SimWeaponClass@@UAEHXZ
	DD	FLAT:?IsExploding@SimBaseClass@@UAEHXZ
	DD	FLAT:?IsDead@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEmitting@FalconEntity@@UAEHXZ
	DD	FLAT:?GetVt@SimMoverClass@@UBEMXZ
	DD	FLAT:?GetKias@SimMoverClass@@UBEMXZ
	DD	FLAT:?GetMovementType@SimBaseClass@@UAE?AW4MoveType@@XZ
	DD	FLAT:?IsUnit@FalconEntity@@UAEHXZ
	DD	FLAT:?IsObjective@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBattalion@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBrigade@FalconEntity@@UAEHXZ
	DD	FLAT:?IsFlight@FalconEntity@@UBEHXZ
	DD	FLAT:?IsSquadron@FalconEntity@@UAEHXZ
	DD	FLAT:?IsPackage@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTeam@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTaskForce@FalconEntity@@UAEHXZ
	DD	FLAT:?IsSPJamming@SimBaseClass@@UAEHXZ
	DD	FLAT:?IsAreaJamming@SimBaseClass@@UAEHXZ
	DD	FLAT:?HasSPJamming@SimBaseClass@@UAEHXZ
	DD	FLAT:?HasAreaJamming@SimBaseClass@@UAEHXZ
	DD	FLAT:?GetRCSFactor@FalconEntity@@UAEMXZ
	DD	FLAT:?GetIRFactor@FalconEntity@@UAEMXZ
	DD	FLAT:?GetRadarType@SimWeaponClass@@UAEHXZ
	DD	FLAT:?GetDamageModifiers@FalconEntity@@UAEPAEXZ
	DD	FLAT:?SetAQUIREtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetSEARCHtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetStepSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?GetAQUIREtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?GetSEARCHtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?WeaponKeepAlive@SimMoverClass@@UAEXXZ
	DD	FLAT:?JoinFlight@SimBaseClass@@UAEXXZ
	DD	FLAT:?ChangeOwner@SimMoverClass@@UAEXVVU_ID@@@Z
	DD	FLAT:?MakeLocal@SimMoverClass@@UAEXXZ
	DD	FLAT:?MakeRemote@SimMoverClass@@UAEXXZ
	DD	FLAT:?IsDead@SimBaseClass@@UBEHXZ
	DD	FLAT:?Init@MissileClass@@UAEXPAVSimInitDataClass@@@Z
	DD	FLAT:?Exec@MissileClass@@UAEHXZ
	DD	FLAT:?GetTransform@MissileClass@@UAEXQAY02M@Z
	DD	FLAT:?ApplyDamage@SimBaseClass@@UAEXPAVFalconDamageMessage@@@Z
	DD	FLAT:?ApplyDeathMessage@SimBaseClass@@UAEXPAVFalconDeathMessage@@@Z
	DD	FLAT:?SetDead@MissileClass@@UAEXH@Z
	DD	FLAT:?MakePlayerVehicle@SimBaseClass@@UAEXXZ
	DD	FLAT:?MakeNonPlayerVehicle@SimBaseClass@@UAEXXZ
	DD	FLAT:?ConfigurePlayerAvionics@SimBaseClass@@UAEXXZ
	DD	FLAT:?SetVuPosition@MissileClass@@UAEXXZ
	DD	FLAT:?Regenerate@SimBaseClass@@UAEXMMMM@Z
	DD	FLAT:?Mass@SimBaseClass@@UAEMXZ
	DD	FLAT:?GetFocusPoint@SimBaseClass@@UAEXAAM00@Z
	DD	FLAT:?GetP@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetQ@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetR@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetAlpha@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetBeta@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetNx@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetNy@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetNz@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetGamma@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetSigma@SimMoverClass@@UAEMXZ
	DD	FLAT:?GetMu@SimMoverClass@@UAEMXZ
	DD	FLAT:?SetLead@SimMoverClass@@UAEXH@Z
	DD	FLAT:?FeatureCollision@SimMoverClass@@UAEPAVSimBaseClass@@M@Z
	DD	FLAT:?CheckLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z
	DD	FLAT:?CheckCompositeLOS@SimMoverClass@@UAEHPAVSimObjectType@@@Z
	DD	FLAT:?Init@MissileClass@@UAEXXZ
	DD	FLAT:?IsUseable@SimWeaponClass@@UAEHXZ
	DD	FLAT:?LaunchDelayTime@MissileClass@@UAEHXZ
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z$0
__unwindtable$?Exec@MissileClass@@UAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Exec@MissileClass@@UAEHXZ$0
__unwindtable$??1MissileClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MissileClass@@UAE@XZ$0
__unwindtable$??0MissileClass@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MissileClass@@QAE@H@Z$0
__unwindtable$??0MissileClass@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MissileClass@@QAE@PAU_iobuf@@@Z$0
__unwindtable$??0MissileClass@@QAE@PAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MissileClass@@QAE@PAPAEPAJ@Z$0
__unwindtable$?EndMissile@MissileClass@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EndMissile@MissileClass@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndMissile@MissileClass@@AAEXXZ$1
__unwindtable$?ApplyProximityDamage@MissileClass@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyProximityDamage@MissileClass@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyProximityDamage@MissileClass@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ApplyProximityDamage@MissileClass@@AAEXXZ$2
__ehfuncinfo$?ApplyProximityDamage@MissileClass@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ApplyProximityDamage@MissileClass@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EndMissile@MissileClass@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EndMissile@MissileClass@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Exec@MissileClass@@UAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Exec@MissileClass@@UAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Init@MissileClass@@UAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Init@MissileClass@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1MissileClass@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MissileClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0MissileClass@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MissileClass@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0MissileClass@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MissileClass@@QAE@PAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0MissileClass@@QAE@PAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MissileClass@@QAE@PAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Init@MissileClass@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@MissileClass@@UAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@MissileClass@@UAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@MissileClass@@UAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@MissileClass@@UAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@MissileClass@@UAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@MissileClass@@UAEXXZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetColor@TeamClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetColor@TeamClass@@QAEHXZ PROC			; TeamClass::GetColor, COMDAT
; _this$ = ecx

; 329  : 	int GetColor (void)							{ return (int) teamColor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+889]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetColor@TeamClass@@QAEHXZ ENDP			; TeamClass::GetColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GMissileClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMissileClass@@UAEPAXI@Z PROC			; MissileClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MissileClass@@UAE@XZ			; MissileClass::~MissileClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMissileClass@@UAEPAXI@Z ENDP			; MissileClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_gridIt$ = -272						; size = 60
tv579 = -212						; size = 8
_featureWalker$2 = -204					; size = 12
_objectWalker$3 = -192					; size = 12
tv704 = -180						; size = 4
tv611 = -176						; size = 4
tv710 = -172						; size = 4
tv599 = -168						; size = 4
tv637 = -164						; size = 4
tv552 = -160						; size = 4
tv692 = -156						; size = 4
tv607 = -152						; size = 4
tv716 = -148						; size = 4
tv659 = -144						; size = 4
tv688 = -140						; size = 4
tv655 = -136						; size = 4
tv684 = -132						; size = 4
tv619 = -128						; size = 4
tv714 = -124						; size = 4
tv615 = -120						; size = 4
tv680 = -116						; size = 4
tv706 = -112						; size = 4
tv667 = -108						; size = 4
tv603 = -104						; size = 4
tv712 = -100						; size = 4
tv663 = -96						; size = 4
tv708 = -92						; size = 4
_groundType$4 = -88					; size = 4
_tmpZ$ = -84						; size = 4
tv575 = -80						; size = 4
_agl$ = -76						; size = 4
_objective$ = -72					; size = 4
_rangeSquare$ = -68					; size = 4
_tmpY$ = -64						; size = 4
_tmpX$ = -60						; size = 4
_testObject$ = -56					; size = 4
_this$ = -52						; size = 4
_acmiStatSfx$ = -48					; size = 29
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ApplyProximityDamage@MissileClass@@AAEXXZ PROC		; MissileClass::ApplyProximityDamage
; _this$ = ecx

; 1138 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ApplyProximityDamage@MissileClass@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 	float tmpX, tmpY, tmpZ;
; 1140 : 	float rangeSquare;
; 1141 : 	FalconEntity* testObject;
; 1142 : 	CampBaseClass* objective;
; 1143 : 	ACMIStationarySfxRecord acmiStatSfx;
; 1144 : 	//float normBlastDist;
; 1145 : #ifdef VU_GRID_TREE_Y_MAJOR
; 1146 : 	VuGridIterator gridIt(ObjProxList, YPos(), XPos(), NM_TO_FT * 2.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@463de1b0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR ?ObjProxList@@3PAVVuGridTree@@A ; ObjProxList
	push	eax
	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	??0VuGridIterator@@QAE@PAVVuGridTree@@MMM@Z ; VuGridIterator::VuGridIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1147 : #else
; 1148 : 	VuGridIterator gridIt(ObjProxList, XPos(), YPos(), NM_TO_FT * 2.0F);
; 1149 : #endif
; 1150 : 
; 1151 : 	// 2002-03-28 MN added BombImpact for "bomb-like" missiles (JSOW...)
; 1152 : 	// RV - Biker - For AGMs we use FeatureImpact also
; 1153 : 	if (done == FalconMissileEndMessage::MissileKill || done == FalconMissileEndMessage::BombImpact || done == FalconMissileEndMessage::FeatureImpact)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+720], 1
	je	SHORT $LN24@ApplyProxi
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+720], 11			; 0000000bH
	je	SHORT $LN24@ApplyProxi
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 10			; 0000000aH
	jne	SHORT $LN23@ApplyProxi
$LN24@ApplyProxi:

; 1154 : 	{
; 1155 : 		//TJ_Changes .... how about we check for another object in the vicinity and apply damage to that ?
; 1156 : 		//Instead of just attacking object you are targeting we will now loop through all aircraft ....
; 1157 : 
; 1158 : //JAM 03Nov03 - This block is causing HARMS and many AA missiles to not cause any damage. Restoring SP3 code for now.
; 1159 : /*		if( domain & wdAir ) {
; 1160 : 			SimBaseClass* testObject;
; 1161 : 
; 1162 : 			if (!SimDriver.objectList) return;
; 1163 : 
; 1164 : 			VuListIterator objectWalker(SimDriver.objectList);
; 1165 : 			testObject = (SimBaseClass*) objectWalker.GetFirst();
; 1166 : 
; 1167 : 			while (testObject) {
; 1168 : 				//TJ_changes
; 1169 : 				//Only check against planes ....
; 1170 : 				//removed this -> dont check against plane that we already were targeting that is handled abouve ... for now .. this could become only check
; 1171 : 				if ( !(testObject->IsAirplane())/* || targetPtr &&  ( targetPtr->BaseData()->Id() == testObject->Id() ) */ /* ) {
; 1172 : 					testObject = (SimBaseClass*) objectWalker.GetNext();
; 1173 : 					continue;
; 1174 : 				}
; 1175 : 				tmpX = testObject->XPos() - XPos();
; 1176 : 				tmpY = testObject->YPos() - YPos();
; 1177 : 				tmpZ = testObject->ZPos() - ZPos();
; 1178 : 
; 1179 : 				rangeSquare = tmpX*tmpX + tmpY*tmpY + tmpZ*tmpZ;
; 1180 : 
; 1181 : 				if (rangeSquare < lethalRadiusSqrd ) {
; 1182 : 					// edg: calculate a normalized blast Dist
; 1183 : 					normBlastDist = ( lethalRadiusSqrd - rangeSquare )/( lethalRadiusSqrd );
; 1184 : 
; 1185 : 					// quadratic dropoff
; 1186 : 					normBlastDist *= normBlastDist;
; 1187 : 					SendDamageMessage( targetPtr->BaseData(), rangeSquare, FalconDamageType::MissileDamage ); // 2002-02-26 MODIFIED BY S.G. Removed '(SimBaseClass*)' from targetPtr->BaseData() since it can be a campaign object anyway (bad practice but no harm was done).
; 1188 : 				}
; 1189 : 				testObject = (SimBaseClass*) objectWalker.GetNext();
; 1190 : 			}
; 1191 : 		}
; 1192 : */		if (targetPtr)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+656], 0
	je	SHORT $LN23@ApplyProxi

; 1193 : 		{
; 1194 : 			// F4Assert(targetPtr->BaseData()->IsSim());
; 1195 : 			SendDamageMessage(targetPtr->BaseData(),0,FalconDamageType::MissileDamage); // 2002-02-26 MODIFIED BY S.G. Removed '(SimBaseClass*)' from targetPtr->BaseData() since it can be a campaign object anyway (bad practice but no harm was done).

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendDamageMessage@SimWeaponClass@@QAEXPAVFalconEntity@@MH@Z ; SimWeaponClass::SendDamageMessage
$LN23@ApplyProxi:

; 1196 : 		}
; 1197 : 	}
; 1198 : 
; 1199 : 	if (done == FalconMissileEndMessage::GroundImpact || ZPos() > groundZ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 7
	je	SHORT $LN21@ApplyProxi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv552[ebp]
	movss	xmm0, DWORD PTR tv552[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+796]
	jbe	$LN18@ApplyProxi
$LN21@ApplyProxi:

; 1200 : 	{
; 1201 : 		int groundType;
; 1202 : 		
; 1203 : 		// check for water b4 placing crater
; 1204 : 		groundType = OTWDriver.GetGroundType (XPos(), YPos() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundType@OTWDriverClass@@QAEHMM@Z	; OTWDriverClass::GetGroundType
	mov	DWORD PTR _groundType$4[ebp], eax

; 1205 : 		if ( !(groundType == COVERAGE_WATER || groundType == COVERAGE_RIVER) )

	cmp	DWORD PTR _groundType$4[ebp], 1
	je	$LN19@ApplyProxi
	cmp	DWORD PTR _groundType$4[ebp], 2
	je	$LN19@ApplyProxi

; 1206 : 		{
; 1207 : 			AddToTimedPersistantList (VIS_CRATER2 + PRANDInt3(), Camp_GetCurrentTime() + CRATER_REMOVAL_TIME, XPos(), YPos());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	add	eax, 3600000				; 0036ee80H
	push	eax
	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	add	eax, 127				; 0000007fH
	push	eax
	call	?AddToTimedPersistantList@@YAXHKMM@Z	; AddToTimedPersistantList
	add	esp, 16					; 00000010H

; 1208 : 			// add crater to ACMI as special effect
; 1209 : 			if ( gACMIRec.IsRecording() )

	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?IsRecording@ACMIRecorder@@QAEHXZ	; ACMIRecorder::IsRecording
	test	eax, eax
	je	$LN19@ApplyProxi

; 1210 : 			{
; 1211 : 
; 1212 : 				acmiStatSfx.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv575[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv575[ebp]
	mov	eax, DWORD PTR tv575[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv579[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv579[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR _acmiStatSfx$[ebp+1], xmm0

; 1213 : 				acmiStatSfx.data.type = SFX_CRATER2 + PRANDInt3();

	call	?PRANDInt3@@YAHXZ			; PRANDInt3
	add	eax, 107				; 0000006bH
	mov	DWORD PTR _acmiStatSfx$[ebp+5], eax

; 1214 : 				acmiStatSfx.data.x = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _acmiStatSfx$[ebp+9]

; 1215 : 				acmiStatSfx.data.y = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _acmiStatSfx$[ebp+13]

; 1216 : 				acmiStatSfx.data.z = ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR _acmiStatSfx$[ebp+17]

; 1217 : 				acmiStatSfx.data.timeToLive = 180.0f;

	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR _acmiStatSfx$[ebp+21], xmm0

; 1218 : 				acmiStatSfx.data.scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _acmiStatSfx$[ebp+25], xmm0

; 1219 : 				gACMIRec.StationarySfxRecord( &acmiStatSfx );

	lea	ecx, DWORD PTR _acmiStatSfx$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?StationarySfxRecord@ACMIRecorder@@QAEXPAUACMIStationarySfxRecord@@@Z ; ACMIRecorder::StationarySfxRecord
$LN19@ApplyProxi:

; 1220 : 			}
; 1221 : 		}
; 1222 : 		
; 1223 : 		
; 1224 : 		// now we need to check objects
; 1225 : 		// only do this on ground impact
; 1226 : 		if (SimDriver.combinedList)

	cmp	DWORD PTR ?SimDriver@@3VSimulationDriver@@A+16, 0
	je	$LN18@ApplyProxi

; 1227 : 		{
; 1228 : 			VuListIterator objectWalker(SimDriver.combinedList);	

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+16
	push	edx
	lea	ecx, DWORD PTR _objectWalker$3[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1229 : 			// Check vs vehicles
; 1230 : 			testObject = (FalconEntity*) objectWalker.GetFirst();

	lea	ecx, DWORD PTR _objectWalker$3[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN17@ApplyProxi:

; 1231 : 			while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN16@ApplyProxi

; 1232 : 			{
; 1233 : 				if (testObject != this)

	mov	eax, DWORD PTR _testObject$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	je	$LN12@ApplyProxi

; 1234 : 				{
; 1235 : 					tmpX = testObject->XPos() - XPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv599[ebp]
	movss	xmm0, DWORD PTR tv599[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv704[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv603[ebp]
	movss	xmm0, DWORD PTR tv704[ebp]
	subss	xmm0, DWORD PTR tv603[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 1236 : 					tmpY = testObject->YPos() - YPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv607[ebp]
	movss	xmm0, DWORD PTR tv607[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv706[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv611[ebp]
	movss	xmm0, DWORD PTR tv706[ebp]
	subss	xmm0, DWORD PTR tv611[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 1237 : 					tmpZ = testObject->ZPos() - ZPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv615[ebp]
	movss	xmm0, DWORD PTR tv615[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv708[ebp], xmm0
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv619[ebp]
	movss	xmm0, DWORD PTR tv708[ebp]
	subss	xmm0, DWORD PTR tv619[ebp]
	movss	DWORD PTR _tmpZ$[ebp], xmm0

; 1238 : 					
; 1239 : 					// for ground units, don't use Z diff
; 1240 : 					if ( testObject->OnGround() )

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN14@ApplyProxi

; 1241 : 						rangeSquare = tmpX*tmpX + tmpY*tmpY;

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rangeSquare$[ebp], xmm0

; 1242 : 					else

	jmp	SHORT $LN13@ApplyProxi
$LN14@ApplyProxi:

; 1243 : 						rangeSquare = tmpX*tmpX + tmpY*tmpY + tmpZ*tmpZ;

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _tmpZ$[ebp]
	mulss	xmm1, DWORD PTR _tmpZ$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rangeSquare$[ebp], xmm0
$LN13@ApplyProxi:

; 1244 : 					
; 1245 : 					if (rangeSquare < lethalRadiusSqrd)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+684]
	comiss	xmm0, DWORD PTR _rangeSquare$[ebp]
	jbe	SHORT $LN12@ApplyProxi

; 1246 : 					{
; 1247 : 						SendDamageMessage(testObject,rangeSquare,FalconDamageType::ProximityDamage);

	push	9
	push	ecx
	movss	xmm0, DWORD PTR _rangeSquare$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _testObject$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendDamageMessage@SimWeaponClass@@QAEXPAVFalconEntity@@MH@Z ; SimWeaponClass::SendDamageMessage
$LN12@ApplyProxi:

; 1248 : 					}
; 1249 : 				}
; 1250 : 				testObject = (FalconEntity*) objectWalker.GetNext();

	lea	ecx, DWORD PTR _objectWalker$3[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 1251 : 			}

	jmp	$LN17@ApplyProxi
$LN16@ApplyProxi:

; 1252 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _objectWalker$3[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN18@ApplyProxi:

; 1253 : 	}
; 1254 : 	
; 1255 : 	// relative height above ground (Z = 0)
; 1256 : 	float agl = ZPos() - groundZ;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv637[ebp]
	movss	xmm0, DWORD PTR tv637[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+796]
	movss	DWORD PTR _agl$[ebp], xmm0

; 1257 : 	
; 1258 : 	// no point in checking proximity if too high above ground
; 1259 : 	// This needs to be >= the check for building impact ala FeatureCollision()
; 1260 : 	if ( agl > -900.0f )

	movss	xmm0, DWORD PTR _agl$[ebp]
	comiss	xmm0, DWORD PTR __real@c4610000
	jbe	$LN9@ApplyProxi

; 1261 : 	{
; 1262 : 		// get the 1st objective that contains the bomb
; 1263 : 		objective = (CampBaseClass*) gridIt.GetFirst();

	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	?GetFirst@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetFirst
	mov	DWORD PTR _objective$[ebp], eax
$LN10@ApplyProxi:

; 1264 : 		
; 1265 : 		// main loop through objectives
; 1266 : 		while ( objective )

	cmp	DWORD PTR _objective$[ebp], 0
	je	$LN9@ApplyProxi

; 1267 : 		{
; 1268 : 			if (objective->GetComponents())

	mov	ecx, DWORD PTR _objective$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	je	$LN8@ApplyProxi

; 1269 : 			{
; 1270 : 				// loop thru each element in the objective
; 1271 : 				VuListIterator	featureWalker(objective->GetComponents());

	mov	ecx, DWORD PTR _objective$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1272 : 				testObject = (FalconEntity*) featureWalker.GetFirst();

	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN7@ApplyProxi:

; 1273 : 				while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN6@ApplyProxi

; 1274 : 				{
; 1275 : 					// don't test the original target ('cause we already dealt with him)
; 1276 : 					// 2002-03-28 MN apply proximity damage if it IS the target, 
; 1277 : 					// but we have got no missile kill or BombImpact - 
; 1278 : 					// or the target can not be damaged by proximity damage
; 1279 : 					if (
; 1280 : 						!targetPtr || testObject != targetPtr->BaseData() ||
; 1281 : 						(g_nMissileFix & 0x08) && testObject == targetPtr->BaseData() && 
; 1282 : 						done != FalconMissileEndMessage::MissileKill && 
; 1283 : 						done != FalconMissileEndMessage::BombImpact
; 1284 : 					){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+656], 0
	je	SHORT $LN4@ApplyProxi
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	DWORD PTR _testObject$[ebp], eax
	jne	SHORT $LN4@ApplyProxi
	mov	eax, DWORD PTR ?g_nMissileFix@@3HA	; g_nMissileFix
	and	eax, 8
	je	$LN3@ApplyProxi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	DWORD PTR _testObject$[ebp], eax
	jne	$LN3@ApplyProxi
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+720], 1
	je	$LN3@ApplyProxi
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 11			; 0000000bH
	je	$LN3@ApplyProxi
$LN4@ApplyProxi:

; 1285 : 						tmpX = testObject->XPos() - XPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv655[ebp]
	movss	xmm0, DWORD PTR tv655[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv710[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv659[ebp]
	movss	xmm0, DWORD PTR tv710[ebp]
	subss	xmm0, DWORD PTR tv659[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 1286 : 						tmpY = testObject->YPos() - YPos();

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv663[ebp]
	movss	xmm0, DWORD PTR tv663[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv712[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv667[ebp]
	movss	xmm0, DWORD PTR tv712[ebp]
	subss	xmm0, DWORD PTR tv667[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 1287 : 						
; 1288 : 						rangeSquare = tmpX*tmpX + tmpY*tmpY + agl*agl;

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _agl$[ebp]
	mulss	xmm1, DWORD PTR _agl$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rangeSquare$[ebp], xmm0

; 1289 : 						
; 1290 : 						if (rangeSquare < lethalRadiusSqrd)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+684]
	comiss	xmm0, DWORD PTR _rangeSquare$[ebp]
	jbe	SHORT $LN3@ApplyProxi

; 1291 : 							SendDamageMessage(testObject,rangeSquare,FalconDamageType::ProximityDamage);

	push	9
	push	ecx
	movss	xmm0, DWORD PTR _rangeSquare$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _testObject$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendDamageMessage@SimWeaponClass@@QAEXPAVFalconEntity@@MH@Z ; SimWeaponClass::SendDamageMessage
$LN3@ApplyProxi:

; 1292 : 					}
; 1293 : 					testObject = (FalconEntity*) featureWalker.GetNext();

	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 1294 : 				}

	jmp	$LN7@ApplyProxi
$LN6@ApplyProxi:

; 1295 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1296 : 			else

	jmp	$LN1@ApplyProxi
$LN8@ApplyProxi:

; 1297 : 			{
; 1298 : 				// Apply damage to an aggregated objective
; 1299 : 				tmpX = objective->XPos() - XPos();

	mov	ecx, DWORD PTR _objective$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv680[ebp]
	movss	xmm0, DWORD PTR tv680[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv714[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv684[ebp]
	movss	xmm0, DWORD PTR tv714[ebp]
	subss	xmm0, DWORD PTR tv684[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 1300 : 				tmpY = objective->YPos() - YPos();

	mov	ecx, DWORD PTR _objective$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv688[ebp]
	movss	xmm0, DWORD PTR tv688[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR tv716[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv692[ebp]
	movss	xmm0, DWORD PTR tv716[ebp]
	subss	xmm0, DWORD PTR tv692[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 1301 : 				
; 1302 : 				rangeSquare = tmpX*tmpX + tmpY*tmpY + agl*agl;

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _agl$[ebp]
	mulss	xmm1, DWORD PTR _agl$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rangeSquare$[ebp], xmm0

; 1303 : 				
; 1304 : 				if (rangeSquare < lethalRadiusSqrd)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+684]
	comiss	xmm0, DWORD PTR _rangeSquare$[ebp]
	jbe	SHORT $LN1@ApplyProxi

; 1305 : 					SendDamageMessage(objective,rangeSquare,FalconDamageType::ProximityDamage);

	push	9
	push	ecx
	movss	xmm0, DWORD PTR _rangeSquare$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _objective$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendDamageMessage@SimWeaponClass@@QAEXPAVFalconEntity@@MH@Z ; SimWeaponClass::SendDamageMessage
$LN1@ApplyProxi:

; 1306 : 			}
; 1307 : 			
; 1308 : 			// get the next objective that contains the bomb
; 1309 : 			objective = (CampBaseClass*) gridIt.GetNext();

	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	?GetNext@VuGridIterator@@QAEPAVVuEntity@@XZ ; VuGridIterator::GetNext
	mov	DWORD PTR _objective$[ebp], eax

; 1310 : 
; 1311 : 		} // end objective loop

	jmp	$LN10@ApplyProxi
$LN9@ApplyProxi:

; 1312 : 	}
; 1313 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _gridIt$[ebp]
	call	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ApplyProximityDamage@MissileClass@@AAEXXZ$0:
	lea	ecx, DWORD PTR _gridIt$[ebp]
	jmp	??1VuGridIterator@@UAE@XZ		; VuGridIterator::~VuGridIterator
__unwindfunclet$?ApplyProximityDamage@MissileClass@@AAEXXZ$1:
	lea	ecx, DWORD PTR _objectWalker$3[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?ApplyProximityDamage@MissileClass@@AAEXXZ$2:
	lea	ecx, DWORD PTR _featureWalker$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?ApplyProximityDamage@MissileClass@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ApplyProximityDamage@MissileClass@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ApplyProximityDamage@MissileClass@@AAEXXZ ENDP		; MissileClass::ApplyProximityDamage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
$T2 = -112						; size = 8
$T3 = -104						; size = 8
$T4 = -96						; size = 8
$T5 = -88						; size = 8
tv795 = -80						; size = 4
$T6 = -76						; size = 4
$T7 = -72						; size = 4
tv437 = -68						; size = 4
tv423 = -64						; size = 4
tv324 = -60						; size = 4
tv310 = -56						; size = 4
tv273 = -52						; size = 4
$T8 = -48						; size = 4
tv262 = -44						; size = 4
tv233 = -40						; size = 4
tv195 = -36						; size = 4
$T9 = -32						; size = 4
tv572 = -28						; size = 4
_campBaseObj$10 = -24					; size = 4
_endMessage$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?EndMissile@MissileClass@@AAEXXZ PROC			; MissileClass::EndMissile
; _this$ = ecx

; 985  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EndMissile@MissileClass@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 986  : 	FalconMissileEndMessage* endMessage;
; 987  : 	
; 988  : 
; 989  : 	if (done != FalconMissileEndMessage::MissileKill &&
; 990  : 		done != FalconMissileEndMessage::GroundImpact &&
; 991  : 		done != FalconMissileEndMessage::FeatureImpact &&
; 992  : 		done != FalconMissileEndMessage::BombImpact && // "bomb warhead" missiles hit SIM target
; 993  : 		done != FalconMissileEndMessage::ArmingDelay)	// when the warhead is not yet armed, do nothing here

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 1
	je	$LN22@EndMissile
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+720], 7
	je	$LN22@EndMissile
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+720], 10			; 0000000aH
	je	$LN22@EndMissile
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 11			; 0000000bH
	je	$LN22@EndMissile
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+720], 3
	je	$LN22@EndMissile

; 994  : 	{
; 995  : 	  if (flags & SensorLostLock)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	and	eax, 4
	je	SHORT $LN26@EndMissile

; 996  : 	      done = FalconMissileEndMessage::ExceedFOV;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+720], 5
$LN26@EndMissile:

; 997  : 
; 998  : 	   // 2002-02-26 ADDED BY S.G. This is the best place to handle aggregated campaign object as target that got missed...
; 999  : 	   if (targetPtr) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+656], 0
	je	$LN22@EndMissile

; 1000 : 		   // First get the campaign object if it's still a sim entity
; 1001 : 		   CampBaseClass *campBaseObj;
; 1002 : 		   if (targetPtr->BaseData()->IsSim()) // If we're a SIM object, get our campaign object

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN24@EndMissile

; 1003 : 			   campBaseObj = ((SimBaseClass*)targetPtr->BaseData())->GetCampaignObject();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _campBaseObj$10[ebp], eax

; 1004 : 		   else

	jmp	SHORT $LN23@EndMissile
$LN24@EndMissile:

; 1005 : 			   campBaseObj = (CampBaseClass *)targetPtr->BaseData();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR _campBaseObj$10[ebp], eax
$LN23@EndMissile:

; 1006 : 		   // Now find out if our campaign object is aggregated
; 1007 : 		   if (campBaseObj && campBaseObj->IsAggregate()) {

	cmp	DWORD PTR _campBaseObj$10[ebp], 0
	je	$LN22@EndMissile
	mov	ecx, DWORD PTR _campBaseObj$10[ebp]
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	$LN22@EndMissile

; 1008 : 			   // Yes, replace the current target by its aggregated campaign object
; 1009 : 			   if (campBaseObj != targetPtr->BaseData()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	DWORD PTR _campBaseObj$10[ebp], eax
	je	SHORT $LN21@EndMissile

; 1010 : 				   if (targetPtr)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+656], 0
	je	SHORT $LN20@EndMissile

; 1011 : 					   targetPtr->Release(  );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release
$LN20@EndMissile:

; 1012 : 
; 1013 : #ifdef DEBUG
; 1014 : 			/*	   targetPtr = new SimObjectType( OBJ_TAG, NULL, campBaseObj );*/
; 1015 : #else
; 1016 : 				   targetPtr = new SimObjectType( campBaseObj );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN30@EndMissile
	mov	eax, DWORD PTR _campBaseObj$10[ebp]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0SimObjectType@@QAE@PAVFalconEntity@@@Z ; SimObjectType::SimObjectType
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN31@EndMissile
$LN30@EndMissile:
	mov	DWORD PTR tv195[ebp], 0
$LN31@EndMissile:
	mov	ecx, DWORD PTR tv195[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [edx+656], eax

; 1017 : #endif
; 1018 : 				   targetPtr->Reference(  );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+656]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference
$LN21@EndMissile:

; 1019 : 			   }
; 1020 : 
; 1021 : 			   // Now say we've killed the target and let the 2D code handle the damage
; 1022 : 			   done = FalconMissileEndMessage::MissileKill;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+720], 1
$LN22@EndMissile:

; 1023 : 		   }
; 1024 : 	   }
; 1025 : 	}
; 1026 : 
; 1027 : 
; 1028 : 	// MonoPrint ("Missile %d done: Time %8ld code %d\n", Id().num_, SimLibElapsedTime, done);
; 1029 : 	SetExploding (TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetExploding@SimBaseClass@@QAEXH@Z	; SimBaseClass::SetExploding

; 1030 : 
; 1031 : 	ShiAssert(parent);
; 1032 : 	
; 1033 : 	if (!parent)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??7?$VuBin@VFalconEntity@@@@QBE_NXZ	; VuBin<FalconEntity>::operator!
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@EndMissile

; 1034 : 		return;

	jmp	$LN28@EndMissile
$LN19@EndMissile:

; 1035 : 
; 1036 : 	// SCR 11/29/98  
; 1037 : 	// We skip doing damage if a surface launched missile blew up on launch
; 1038 : 	// (cause it hit a building or something silly like that)
; 1039 : 
; 1040 : 	// 2002-03-28 MN if end message is ArmingDelay, don't apply damage at all
; 1041 : 	if (!(done == FalconMissileEndMessage::ArmingDelay) && inputData && (runTime > inputData->guidanceDelay || !parent->OnGround()))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+720], 3
	je	SHORT $LN18@EndMissile
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+848], 0
	je	SHORT $LN18@EndMissile
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+868]
	comiss	xmm0, DWORD PTR [ecx+64]
	ja	SHORT $LN17@EndMissile
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv233[ebp], eax
	mov	eax, DWORD PTR tv233[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv233[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN18@EndMissile
$LN17@EndMissile:

; 1042 : 		ApplyProximityDamage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ApplyProximityDamage@MissileClass@@AAEXXZ ; MissileClass::ApplyProximityDamage
$LN18@EndMissile:

; 1043 : 
; 1044 : 	endMessage = new FalconMissileEndMessage (Id(), FalconLocalGame);

	push	285					; 0000011dH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN34@EndMissile
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@EndMissile
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv262[ebp], eax
	jmp	SHORT $LN33@EndMissile
$LN32@EndMissile:
	mov	DWORD PTR tv262[ebp], 0
$LN33@EndMissile:
	push	1
	mov	edx, DWORD PTR tv262[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0FalconMissileEndMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconMissileEndMessage::FalconMissileEndMessage
	mov	DWORD PTR tv273[ebp], eax
	jmp	SHORT $LN35@EndMissile
$LN34@EndMissile:
	mov	DWORD PTR tv273[ebp], 0
$LN35@EndMissile:
	mov	eax, DWORD PTR tv273[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _endMessage$[ebp], ecx

; 1045 : 	endMessage->RequestReliableTransmit ();

	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit

; 1046 : 	endMessage->RequestOutOfBandTransmit ();

	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestOutOfBandTransmit

; 1047 : 	endMessage->dataBlock.fEntityID  = parent->Id();

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _endMessage$[ebp]
	mov	DWORD PTR [eax+63], ecx
	mov	DWORD PTR [eax+67], edx

; 1048 : 	endMessage->dataBlock.fCampID    = parent->GetCampID();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv310[ebp], eax
	mov	ecx, DWORD PTR tv310[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv310[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [ecx+71], ax

; 1049 :    endMessage->dataBlock.fSide      = parent->GetCountry();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv324[ebp], eax
	mov	edx, DWORD PTR tv324[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv324[ebp]
	mov	edx, DWORD PTR [eax+120]
	call	edx
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [ecx+77], al

; 1050 : 	endMessage->dataBlock.fIndex     = parent->Type();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	ecx, eax
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [edx+75], ax

; 1051 : 	
; 1052 : 	if ( parent->IsSim() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN16@EndMissile

; 1053 : 		endMessage->dataBlock.fPilotID   = shooterPilotSlot;

	mov	eax, DWORD PTR _endMessage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+680]
	mov	BYTE PTR [eax+73], dl

; 1054 : 	else

	jmp	SHORT $LN15@EndMissile
$LN16@EndMissile:

; 1055 : 		endMessage->dataBlock.fPilotID   = 0;	// Flight leads get all kills for now...

	mov	eax, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [eax+73], 0
$LN15@EndMissile:

; 1056 : 	
; 1057 : 	if (targetPtr)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+656], 0
	je	$LN14@EndMissile

; 1058 : 	{
; 1059 : 		if ( targetPtr->BaseData()->IsSim() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN13@EndMissile

; 1060 : 		{
; 1061 : 			endMessage->dataBlock.dCampSlot  = (char)((SimBaseClass*)targetPtr->BaseData())->GetSlot();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?GetSlot@SimBaseClass@@QAEHXZ		; SimBaseClass::GetSlot
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [ecx+59], al

; 1062 : 		}
; 1063 : 		else

	jmp	SHORT $LN12@EndMissile
$LN13@EndMissile:

; 1064 : 		{
; 1065 : 			endMessage->dataBlock.dCampSlot  = 0;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [edx+59], 0
$LN12@EndMissile:

; 1066 : 		}
; 1067 : 		
; 1068 : 		endMessage->dataBlock.dEntityID  = targetPtr->BaseData()->Id();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 1069 : 		endMessage->dataBlock.dCampID    = targetPtr->BaseData()->GetCampID();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv423[ebp], eax
	mov	eax, DWORD PTR tv423[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv423[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [ecx+56], ax

; 1070 : 		endMessage->dataBlock.dSide      = targetPtr->BaseData()->GetCountry();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv437[ebp], eax
	mov	eax, DWORD PTR tv437[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv437[ebp]
	mov	eax, DWORD PTR [edx+120]
	call	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [ecx+62], al

; 1071 : 		endMessage->dataBlock.dIndex     = targetPtr->BaseData()->Type();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [ecx+60], ax

; 1072 : 		endMessage->dataBlock.dPilotID   = 0;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [edx+58], 0

; 1073 : 	}
; 1074 : 	else

	jmp	SHORT $LN11@EndMissile
$LN14@EndMissile:

; 1075 : 	{
; 1076 : 		endMessage->dataBlock.dEntityID  = FalconNullId;

	mov	eax, DWORD PTR _endMessage$[ebp]
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+48], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+52], edx

; 1077 : 		endMessage->dataBlock.dCampID    = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [ecx+56], ax

; 1078 : 		endMessage->dataBlock.dSide      = 0;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [edx+62], 0

; 1079 : 		endMessage->dataBlock.dIndex     = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [ecx+60], ax

; 1080 : 		endMessage->dataBlock.dPilotID   = 0;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [edx+58], 0
$LN11@EndMissile:

; 1081 : 	}
; 1082 : 	
; 1083 : 	endMessage->dataBlock.fWeaponUID = Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _endMessage$[ebp]
	mov	DWORD PTR [eax+82], ecx
	mov	DWORD PTR [eax+86], edx

; 1084 : 	endMessage->dataBlock.wIndex = Type();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	mov	ecx, DWORD PTR _endMessage$[ebp]
	mov	WORD PTR [ecx+115], ax

; 1085 : 	
; 1086 :    	endMessage->dataBlock.endCode    = done;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	mov	DWORD PTR [edx+78], ecx

; 1087 : 	endMessage->dataBlock.x    = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	edx, DWORD PTR _endMessage$[ebp]
	fstp	DWORD PTR [edx+90]

; 1088 : 	endMessage->dataBlock.y    = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _endMessage$[ebp]
	fstp	DWORD PTR [eax+94]

; 1089 : 	endMessage->dataBlock.z    = ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	ecx, DWORD PTR _endMessage$[ebp]
	fstp	DWORD PTR [ecx+98]

; 1090 : 	endMessage->dataBlock.xDelta    = XDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	mov	edx, DWORD PTR _endMessage$[ebp]
	fstp	DWORD PTR [edx+102]

; 1091 : 	endMessage->dataBlock.yDelta    = YDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	mov	eax, DWORD PTR _endMessage$[ebp]
	fstp	DWORD PTR [eax+106]

; 1092 : 	endMessage->dataBlock.zDelta    = ZDelta();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZDelta@VuEntity@@QBEMXZ		; VuEntity::ZDelta
	mov	ecx, DWORD PTR _endMessage$[ebp]
	fstp	DWORD PTR [ecx+110]

; 1093 : 	endMessage->dataBlock.groundType    = -1;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [edx+114], -1

; 1094 : 	
; 1095 : 	if (done == FalconMissileEndMessage::GroundImpact || ZPos() > groundZ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 7
	je	SHORT $LN9@EndMissile
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv795[ebp]
	movss	xmm0, DWORD PTR tv795[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	comiss	xmm0, DWORD PTR [ecx+796]
	jbe	SHORT $LN10@EndMissile
$LN9@EndMissile:

; 1096 : 	{
; 1097 : 		endMessage->dataBlock.z			 = groundZ;

	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+796]
	mov	DWORD PTR [edx+98], ecx

; 1098 : 		endMessage->dataBlock.groundType = (char)OTWDriver.GetGroundType (XPos(), YPos() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundType@OTWDriverClass@@QAEHMM@Z	; OTWDriverClass::GetGroundType
	mov	edx, DWORD PTR _endMessage$[ebp]
	mov	BYTE PTR [edx+114], al
$LN10@EndMissile:

; 1099 : 	}
; 1100 : 
; 1101 : 	switch(done)// particle effects

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	mov	DWORD PTR tv572[ebp], ecx
	mov	edx, DWORD PTR tv572[ebp]
	sub	edx, 1
	mov	DWORD PTR tv572[ebp], edx
	cmp	DWORD PTR tv572[ebp], 10		; 0000000aH
	ja	$LN7@EndMissile
	mov	eax, DWORD PTR tv572[ebp]
	jmp	DWORD PTR $LN39@EndMissile[eax*4]
$LN6@EndMissile:

; 1102 : 	{
; 1103 : 	case FalconMissileEndMessage::GroundImpact:
; 1104 : 		endMessage->SetParticleEffectName(auxData->psGroundImpact);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z ; FalconMissileEndMessage::SetParticleEffectName

; 1105 : 		break;

	jmp	SHORT $LN7@EndMissile
$LN5@EndMissile:

; 1106 : 	case FalconMissileEndMessage::MissileKill:
; 1107 : 		endMessage->SetParticleEffectName(auxData->psMissileKill);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z ; FalconMissileEndMessage::SetParticleEffectName

; 1108 : 		break;

	jmp	SHORT $LN7@EndMissile
$LN4@EndMissile:

; 1109 : 	case FalconMissileEndMessage::FeatureImpact:
; 1110 : 		endMessage->SetParticleEffectName(auxData->psFeatureImpact);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z ; FalconMissileEndMessage::SetParticleEffectName

; 1111 : 		break;

	jmp	SHORT $LN7@EndMissile
$LN3@EndMissile:

; 1112 : 	case FalconMissileEndMessage::BombImpact:
; 1113 : 		endMessage->SetParticleEffectName(auxData->psBombImpact);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z ; FalconMissileEndMessage::SetParticleEffectName

; 1114 : 		break;

	jmp	SHORT $LN7@EndMissile
$LN2@EndMissile:

; 1115 : 	case FalconMissileEndMessage::ArmingDelay:
; 1116 : 		endMessage->SetParticleEffectName(auxData->psArmingDelay);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edx+136]
	push	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z ; FalconMissileEndMessage::SetParticleEffectName

; 1117 : 		break;

	jmp	SHORT $LN7@EndMissile
$LN1@EndMissile:

; 1118 : 	case FalconMissileEndMessage::ExceedFOV:
; 1119 : 		endMessage->SetParticleEffectName(auxData->psExceedFOV);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _endMessage$[ebp]
	call	?SetParticleEffectName@FalconMissileEndMessage@@QAEXPAD@Z ; FalconMissileEndMessage::SetParticleEffectName
$LN7@EndMissile:

; 1120 : 		break;
; 1121 : 	}
; 1122 : 
; 1123 : 	// Can't send the end message until all the damage messages are gone.
; 1124 : 	FalconSendMessage (endMessage,FALSE);

	push	0
	mov	ecx, DWORD PTR _endMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN28@EndMissile:

; 1125 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN39@EndMissile:
	DD	$LN5@EndMissile
	DD	$LN7@EndMissile
	DD	$LN2@EndMissile
	DD	$LN7@EndMissile
	DD	$LN1@EndMissile
	DD	$LN7@EndMissile
	DD	$LN6@EndMissile
	DD	$LN7@EndMissile
	DD	$LN7@EndMissile
	DD	$LN4@EndMissile
	DD	$LN3@EndMissile
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EndMissile@MissileClass@@AAEXXZ$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?EndMissile@MissileClass@@AAEXXZ$1:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EndMissile@MissileClass@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EndMissile@MissileClass@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EndMissile@MissileClass@@AAEXXZ ENDP			; MissileClass::EndMissile
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FlyMissile@MissileClass@@AAEXXZ PROC			; MissileClass::FlyMissile
; _this$ = ecx

; 689  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 690  :    if (launchState == Launching)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+724], 1
	jne	SHORT $LN2@FlyMissile

; 691  :    {
; 692  :       Launch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Launch@MissileClass@@AAEXXZ		; MissileClass::Launch

; 693  : 	  Flight(); // MLR 1/5/2005 - 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Flight@MissileClass@@AAEXXZ		; MissileClass::Flight

; 694  :    }
; 695  :    else

	jmp	SHORT $LN1@FlyMissile
$LN2@FlyMissile:

; 696  :    {
; 697  :       Flight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Flight@MissileClass@@AAEXXZ		; MissileClass::Flight
$LN1@FlyMissile:

; 698  :    }
; 699  : 
; 700  : 	runTime += SimLibMinorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+868]
	addss	xmm0, DWORD PTR ?SimLibMinorFrameTime@@3MA
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+868], xmm0

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlyMissile@MissileClass@@AAEXXZ ENDP			; MissileClass::FlyMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv454 = -120						; size = 8
_lastz$ = -112						; size = 4
_lasty$ = -108						; size = 4
_lastx$ = -104						; size = 4
_PipEl$1 = -100						; size = 4
_PipAz$2 = -96						; size = 4
tv467 = -92						; size = 4
tv462 = -88						; size = 4
tv488 = -84						; size = 4
tv448 = -80						; size = 4
tv442 = -76						; size = 4
tv434 = -72						; size = 4
tv416 = -68						; size = 4
tv408 = -64						; size = 4
tv402 = -60						; size = 4
tv392 = -56						; size = 4
tv379 = -52						; size = 4
tv486 = -48						; size = 4
tv373 = -44						; size = 4
tv367 = -40						; size = 4
tv484 = -36						; size = 4
tv357 = -32						; size = 4
_pel$3 = -28						; size = 4
_paz$4 = -24						; size = 4
_dz$5 = -20						; size = 4
_rng$ = -16						; size = 4
_dx$ = -12						; size = 4
_dy$ = -8						; size = 4
_this$ = -4						; size = 4
_impactX$ = 8						; size = 4
_impactY$ = 12						; size = 4
_impactZ$ = 16						; size = 4
_impactTime$ = 20					; size = 4
?FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z PROC	; MissileClass::FindRocketGroundImpact
; _this$ = ecx

; 1327 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 1328 : 	//float saveMinorFrameTime; // FRB
; 1329 : 	float lastx = x, lasty = y, lastz = z;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+756]
	movss	DWORD PTR _lastx$[ebp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+760]
	movss	DWORD PTR _lasty$[ebp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+764]
	movss	DWORD PTR _lastz$[ebp], xmm0

; 1330 : 
; 1331 : 	// Cobra test
; 1332 : 	static FILE *fp = NULL;
; 1333 : 	//if (fp == NULL)
; 1334 : 	//	fp = fopen("G:\\RocketImpact.txt", "w");
; 1335 : 
; 1336 : /*
; 1337 : 	// edg: yuck.  Unfortuantely we have to do this
; 1338 : 	ifd = new MissileInFlightData;
; 1339 : 
; 1340 : 	// init stuff and save vars we need to set back at end....
; 1341 : 	runTime = 0.0f;
; 1342 : 	saveMinorFrameTime = SimLibMinorFrameTime;
; 1343 : 
; 1344 : 	initXLoc = 0.0f;
; 1345 : 	initYLoc = 0.0f;
; 1346 : 	initZLoc = 0.0f;
; 1347 : 	initAz = 0.0f;
; 1348 : 	initEl = 0.0f;
; 1349 : 
; 1350 : 	SimLibMinorFrameTime = 0.05f;
; 1351 : 
; 1352 : 	// Start stuff....
; 1353 :    Init1();
; 1354 : 	launchState = Launching;
; 1355 : 
; 1356 : 	// Exec Stuff
; 1357 : 	// runtime updated in fly missile
; 1358 : 	// keep flying up until a max time or until the ground is hit
; 1359 : 	while ( runTime < TIME_TO_RUN_IMPACT )
; 1360 : 	{
; 1361 : 		 // not sure if this is needed
; 1362 :          //CalcTransformMatrix(this);
; 1363 : 
; 1364 : 		//MI fix for rocket recticle bouncing... these 3 lines where commented....	
; 1365 : 		lastx = x;
; 1366 : 		lasty = y;
; 1367 : 		lastz = z;
; 1368 : 
; 1369 : 		 // flies the thing
; 1370 :          CommandGuide();		// TODO: Avoid this -- all it does for rockets is set the G commands to 1.0
; 1371 : 
; 1372 : 		 flags |= FindingImpact; // MLR 1/9/2004 - added to prevent the rocket's launch smoke puff trail when selected
; 1373 :          FlyMissile(); 
; 1374 : 		 flags &= ~FindingImpact;
; 1375 : 
; 1376 :          ClosestApproach();		// TODO: Avoid this -- it's only really meaningful for proximity fuzed weapons
; 1377 :          SetPosition (x, y, z);
; 1378 : 
; 1379 : 		 if ( launchState == InFlight )
; 1380 : 		 {
; 1381 :             SetDelta(xdot, ydot, zdot);
; 1382 :             SetYPR(psi, theta, phi);
; 1383 :             SetYPRDelta (r, q, p);
; 1384 : 			// sfr: no more
; 1385 :             //SetVt(vt);
; 1386 : 
; 1387 : 			groundZ = OTWDriver.GetGroundLevel( x, y );
; 1388 : 			if ( z > groundZ )
; 1389 : 		 		break;
; 1390 : 		 }
; 1391 : 	}
; 1392 : 
; 1393 : 	*impactTime = runTime;
; 1394 : 
; 1395 : 	float degpsi = psi * RTD;
; 1396 : 	float degphi = phi * RTD;
; 1397 : 	float degtheta = theta * RTD;
; 1398 : 
; 1399 : 
; 1400 : 	// restore stuff
; 1401 : 	runTime = 0.0f;
; 1402 : 	GuidenceTime = 0.0f;
; 1403 : 	SimLibMinorFrameTime = saveMinorFrameTime;
; 1404 :     launchState = PreLaunch;
; 1405 : 	delete ifd;
; 1406 : 	ifd = NULL;
; 1407 :    
; 1408 : 	// check for no resolution
; 1409 : 	if ( *impactTime >= TIME_TO_RUN_IMPACT )
; 1410 : 		return FALSE;
; 1411 : 
; 1412 : 	// at this point we've hit the ground
; 1413 :   // Interpolate for the time
; 1414 :   float delta = (groundZ - lastz) / (z - lastz);
; 1415 :   *impactX = lastx + delta * (x - lastx);
; 1416 :   *impactY = lasty + delta * (y - lasty);
; 1417 :   *impactZ = OTWDriver.GetGroundLevel(*impactX, *impactY);
; 1418 : 
; 1419 : */
; 1420 : 
; 1421 : 	float rng = fabs((static_cast<SimVehicleClass*>(parent.get())->ZPos() - OTWDriver.GetGroundLevel(x, y)) 
; 1422 : 											/ (tan(static_cast<SimVehicleClass*>(parent.get())->Pitch() - 0.01f)));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv357[ebp]
	movss	xmm0, DWORD PTR tv357[ebp]
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [eax+760]
	movss	DWORD PTR [esp], xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+756]
	movss	DWORD PTR [esp], xmm1
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	movss	DWORD PTR tv484[ebp], xmm0
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR tv367[ebp]
	movss	xmm0, DWORD PTR tv484[ebp]
	subss	xmm0, DWORD PTR tv367[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	movss	DWORD PTR tv486[ebp], xmm0
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv373[ebp]
	movss	xmm0, DWORD PTR tv373[ebp]
	subss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv379[ebp]
	movss	xmm0, DWORD PTR tv486[ebp]
	divss	xmm0, DWORD PTR tv379[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR _rng$[ebp]

; 1423 : 	float dx = sin(static_cast<SimVehicleClass*>(parent.get())->Yaw()) * rng;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv392[ebp]
	movss	xmm0, DWORD PTR tv392[ebp]
	mulss	xmm0, DWORD PTR _rng$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1424 : 	float dy = cos(static_cast<SimVehicleClass*>(parent.get())->Yaw()) * rng;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv402[ebp]
	movss	xmm0, DWORD PTR tv402[ebp]
	mulss	xmm0, DWORD PTR _rng$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1425 : 	*impactX = dx + static_cast<SimVehicleClass*>(parent.get())->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv408[ebp]
	movss	xmm0, DWORD PTR tv408[ebp]
	addss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _impactX$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1426 : 	*impactY = dy + static_cast<SimVehicleClass*>(parent.get())->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv416[ebp]
	movss	xmm0, DWORD PTR tv416[ebp]
	addss	xmm0, DWORD PTR _dy$[ebp]
	mov	eax, DWORD PTR _impactY$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1427 : 	*impactZ = OTWDriver.GetGroundLevel(*impactX, *impactY);

	push	0
	mov	ecx, DWORD PTR _impactY$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _impactX$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	mov	eax, DWORD PTR _impactZ$[ebp]
	fstp	DWORD PTR [eax]

; 1428 : 	if ((fp) && (rng < 11000.f))

	cmp	DWORD PTR ?fp@?1??FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z@4PAU_iobuf@@A, 0
	je	$LN1@FindRocket
	movss	xmm0, DWORD PTR __real@462be000
	comiss	xmm0, DWORD PTR _rng$[ebp]
	jbe	$LN1@FindRocket

; 1429 : 	{
; 1430 : 		float dz = *impactZ - static_cast<SimVehicleClass*>(parent.get())->ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv434[ebp]
	mov	ecx, DWORD PTR _impactZ$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR tv434[ebp]
	movss	DWORD PTR _dz$5[ebp], xmm0

; 1431 : 		float pel = static_cast<SimVehicleClass*>(parent.get())->Pitch() * RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv442[ebp]
	movss	xmm0, DWORD PTR tv442[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _pel$3[ebp], xmm0

; 1432 : 		float paz = static_cast<SimVehicleClass*>(parent.get())->Yaw() * RTD;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv448[ebp]
	movss	xmm0, DWORD PTR tv448[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	DWORD PTR _paz$4[ebp], xmm0

; 1433 : 		float PipAz = ((float)atan2(dx,dy) * RTD) - paz;

	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv454[ebp]
	movsd	xmm0, QWORD PTR tv454[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	subss	xmm0, DWORD PTR _paz$4[ebp]
	movss	DWORD PTR _PipAz$2[ebp], xmm0

; 1434 : 		float PipEl = ((float)atan(-dz/(float)sqrt(dx*dx+dy*dy+.1F)) * RTD) - pel;

	movss	xmm0, DWORD PTR _dz$5[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _dx$[ebp]
	mulss	xmm1, DWORD PTR _dx$[ebp]
	movss	xmm2, DWORD PTR _dy$[ebp]
	mulss	xmm2, DWORD PTR _dy$[ebp]
	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv488[ebp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv462[ebp]
	movss	xmm0, DWORD PTR tv488[ebp]
	divss	xmm0, DWORD PTR tv462[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR tv467[ebp]
	movss	xmm0, DWORD PTR tv467[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	subss	xmm0, DWORD PTR _pel$3[ebp]
	movss	DWORD PTR _PipEl$1[ebp], xmm0

; 1435 : 
; 1436 : 		//fprintf(fp,"**--** Rng %f Imp X %f Imp Y %f Imp Z %f Pitch %f Yaw %f pel %f paz %f PipEl %f PipAz %f dx %f dy %f dz %f \n",
; 1437 : 		fprintf(fp,"**--** Rng %f Imp X %f Imp Y %f Imp Z %f pel %f paz %f PipEl %f PipAz %f dx %f dy %f dz %f \n",
; 1438 : 					rng, dx, dy, dz, pel, paz, PipEl, PipAz, dx, dy, dz);

	cvtss2sd xmm0, DWORD PTR _dz$5[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _PipAz$2[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _PipEl$1[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _paz$4[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _pel$3[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dz$5[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _rng$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0FN@MNJCEOEK@?$CK?$CK?9?9?$CK?$CK?5Rng?5?$CFf?5Imp?5X?5?$CFf?5Imp?5Y?5?$CFf?5@
	mov	edx, DWORD PTR ?fp@?1??FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z@4PAU_iobuf@@A
	push	edx
	call	_fprintf
	add	esp, 96					; 00000060H

; 1439 : 				//rng, *impactX, *impactY, *impactZ, degtheta, degpsi, pel, paz, PipEl, PipAz, dx, dy, dz);
; 1440 : 		fflush(fp);

	mov	eax, DWORD PTR ?fp@?1??FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z@4PAU_iobuf@@A
	push	eax
	call	_fflush
	add	esp, 4
$LN1@FindRocket:

; 1441 : 	}
; 1442 : 	return TRUE;

	mov	eax, 1

; 1443 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FindRocketGroundImpact@MissileClass@@QAEHPAM000@Z ENDP	; MissileClass::FindRocketGroundImpact
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?IsMissile@MissileClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMissile@MissileClass@@UAEHXZ PROC			; MissileClass::IsMissile, COMDAT
; _this$ = ecx

; 343  : 	virtual int IsMissile (void) { return TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMissile@MissileClass@@UAEHXZ ENDP			; MissileClass::IsMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetVuPosition@MissileClass@@UAEXXZ PROC		; MissileClass::SetVuPosition
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 974  :    SetPosition (x, y, z);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+764]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+760]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+756]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 975  :    SetDelta(xdot, ydot, zdot);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+780]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+776]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+772]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 976  :    SetYPR(psi, theta, phi);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+788]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+784]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+792]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 977  :    SetYPRDelta (r, q, p);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+964]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+968]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+972]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta

; 978  :    // sfr: no more 
; 979  :    //SetVt(vt);
; 980  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetVuPosition@MissileClass@@UAEXXZ ENDP		; MissileClass::SetVuPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_retval$ = -28						; size = 4
_pg$1 = -24						; size = 4
tv209 = -20						; size = 4
tv184 = -16						; size = 4
tv94 = -12						; size = 4
_campobj$2 = -8						; size = 4
_this$ = -4						; size = 4
?Wake@MissileClass@@UAEHXZ PROC				; MissileClass::Wake
; _this$ = ecx

; 939  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 940  : 	if (IsAwake()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN10@Wake

; 941  : 		return 0;

	xor	eax, eax
	jmp	$LN11@Wake
$LN10@Wake:

; 942  : 	}
; 943  :     
; 944  : 	int retval = SimWeaponClass::Wake();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Wake@SimWeaponClass@@UAEHXZ		; SimWeaponClass::Wake
	mov	DWORD PTR _retval$[ebp], eax

; 945  : 
; 946  :     // Tell our campaign parent he's got missiles in the air
; 947  :     // (So that SAM battalions keep their radars on)
; 948  : 	if (parent){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??B?$VuBin@VFalconEntity@@@@QBE_NXZ	; VuBin<FalconEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN9@Wake

; 949  : 		//Campaign launched vehicles don't necessarily have a parent
; 950  : 		if (parent->IsGroundVehicle()) { 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR [edx+196]
	call	eax
	test	eax, eax
	je	SHORT $LN8@Wake

; 951  : 			// JPO more checks please
; 952  : 			GroundClass *pg = static_cast<GroundClass*>(parent.get());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	DWORD PTR _pg$1[ebp], eax

; 953  : 			CampBaseClass *campobj = pg->GetCampaignObject();

	mov	ecx, DWORD PTR _pg$1[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _campobj$2[ebp], eax

; 954  : 			if (campobj -> IsBattalion()){

	mov	ecx, DWORD PTR _campobj$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campobj$2[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN7@Wake

; 955  : 				((BattalionClass*)campobj)->IncrementMissileCount();

	mov	ecx, DWORD PTR _campobj$2[ebp]
	call	?IncrementMissileCount@BattalionClass@@QAEXXZ ; BattalionClass::IncrementMissileCount
	jmp	SHORT $LN6@Wake
$LN7@Wake:

; 956  : 			}
; 957  : 			else if (campobj -> IsTaskForce()){

	mov	ecx, DWORD PTR _campobj$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campobj$2[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN6@Wake

; 958  : 				// add in naval stuff
; 959  : 				((TaskForceClass*)campobj)->IncrementMissileCount();

	mov	ecx, DWORD PTR _campobj$2[ebp]
	call	?IncrementMissileCount@TaskForceClass@@QAEXXZ ; TaskForceClass::IncrementMissileCount
$LN6@Wake:

; 960  : 			}
; 961  : 		} 

	jmp	SHORT $LN9@Wake
$LN8@Wake:

; 962  : 		else if (parent->IsBattalion()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR tv184[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv184[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN3@Wake

; 963  : 			((BattalionClass*)parent.get())->IncrementMissileCount();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?IncrementMissileCount@BattalionClass@@QAEXXZ ; BattalionClass::IncrementMissileCount
	jmp	SHORT $LN9@Wake
$LN3@Wake:

; 964  : 		}
; 965  : 		else if (parent->IsTaskForce()) { // and again

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv209[ebp], eax
	mov	ecx, DWORD PTR tv209[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv209[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN9@Wake

; 966  : 			((TaskForceClass*)parent.get())->IncrementMissileCount();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?IncrementMissileCount@TaskForceClass@@QAEXXZ ; TaskForceClass::IncrementMissileCount
$LN9@Wake:

; 967  : 		}
; 968  :     }
; 969  :     return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN11@Wake:

; 970  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Wake@MissileClass@@UAEHXZ ENDP				; MissileClass::Wake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_retval$ = -24						; size = 4
tv206 = -20						; size = 4
tv181 = -16						; size = 4
tv91 = -12						; size = 4
_campobj$1 = -8						; size = 4
_this$ = -4						; size = 4
?Sleep@MissileClass@@UAEHXZ PROC			; MissileClass::Sleep
; _this$ = ecx

; 891  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 892  : 	int retval = 0;

	mov	DWORD PTR _retval$[ebp], 0

; 893  : 
; 894  : 	if (!IsAwake()){ return retval; }

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	jne	SHORT $LN11@Sleep
	mov	eax, DWORD PTR _retval$[ebp]
	jmp	$LN12@Sleep
$LN11@Sleep:

; 895  : 
; 896  : /*	if (trail)
; 897  : 		RemoveTrail();*/
; 898  : 
; 899  : 	if (TrailId){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+696], 0
	je	SHORT $LN10@Sleep

; 900  : 		RemoveTrail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTrail@MissileClass@@AAEXXZ	; MissileClass::RemoveTrail
$LN10@Sleep:

; 901  : 	}
; 902  : 
; 903  : 	// Drop the sensors platform if beamrider
; 904  : 	ClearReferences();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearReferences@MissileClass@@QAEXXZ	; MissileClass::ClearReferences

; 905  : 
; 906  : 	// make sure parent is no longer referenced
; 907  : 	// Tell the parent this missile doesn't need guidance anymore
; 908  : 	if (parent.get() != NULL){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	test	eax, eax
	je	$LN9@Sleep

; 909  : 		if (parent->IsGroundVehicle()){

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR tv91[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [edx+196]
	call	eax
	test	eax, eax
	je	SHORT $LN8@Sleep

; 910  : 			CampBaseClass *campobj = ((GroundClass*)parent.get())->GetCampaignObject();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _campobj$1[ebp], eax

; 911  : 			if (campobj->IsBattalion()){

	mov	ecx, DWORD PTR _campobj$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campobj$1[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN7@Sleep

; 912  : 				((BattalionClass*)campobj)->DecrementMissileCount();

	mov	ecx, DWORD PTR _campobj$1[ebp]
	call	?DecrementMissileCount@BattalionClass@@QAEXXZ ; BattalionClass::DecrementMissileCount
	jmp	SHORT $LN6@Sleep
$LN7@Sleep:

; 913  : 			}
; 914  : 			else if (campobj->IsTaskForce()){

	mov	ecx, DWORD PTR _campobj$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _campobj$1[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN6@Sleep

; 915  : 				// add in naval stuff
; 916  : 				((TaskForceClass*)campobj)->DecrementMissileCount();

	mov	ecx, DWORD PTR _campobj$1[ebp]
	call	?DecrementMissileCount@TaskForceClass@@QAEXXZ ; TaskForceClass::DecrementMissileCount
$LN6@Sleep:

; 917  : 			}
; 918  : 		} 

	jmp	SHORT $LN9@Sleep
$LN8@Sleep:

; 919  : 		else if (parent->IsBattalion()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR tv181[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv181[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN3@Sleep

; 920  : 			((BattalionClass*)parent.get())->DecrementMissileCount();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?DecrementMissileCount@BattalionClass@@QAEXXZ ; BattalionClass::DecrementMissileCount
	jmp	SHORT $LN9@Sleep
$LN3@Sleep:

; 921  : 		}
; 922  : 		else if (parent->IsTaskForce()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv206[ebp], eax
	mov	ecx, DWORD PTR tv206[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv206[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN9@Sleep

; 923  : 			((TaskForceClass*)parent.get())->DecrementMissileCount();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	ecx, eax
	call	?DecrementMissileCount@TaskForceClass@@QAEXXZ ; TaskForceClass::DecrementMissileCount
$LN9@Sleep:

; 924  : 		}
; 925  : 	}
; 926  : 
; 927  : 	SimWeaponClass::Sleep();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Sleep@SimWeaponClass@@UAEHXZ		; SimWeaponClass::Sleep

; 928  : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN12@Sleep:

; 929  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Sleep@MissileClass@@UAEHXZ ENDP			; MissileClass::Sleep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv85 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetDead@MissileClass@@UAEXH@Z PROC			; MissileClass::SetDead
; _this$ = ecx

; 873  : void MissileClass::SetDead (int flag){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 874  : 	if (IsAwake()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAwake@SimBaseClass@@QBEHXZ		; SimBaseClass::IsAwake
	test	eax, eax
	je	SHORT $LN2@SetDead

; 875  : 		Sleep();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN2@SetDead:

; 876  : 	}
; 877  : 
; 878  : 	// delete in flight data if any
; 879  : 	if (ifd){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+988], 0
	je	SHORT $LN1@SetDead

; 880  : 		delete ifd;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+988]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@SetDead
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GMissileInFlightData@@QAEPAXI@Z
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN6@SetDead
$LN5@SetDead:
	mov	DWORD PTR tv85[ebp], 0
$LN6@SetDead:

; 881  : 		ifd = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+988], 0
$LN1@SetDead:

; 882  : 	}
; 883  : 
; 884  : 	// clear out target if any
; 885  : 	DropTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropTarget@MissileClass@@QAEXXZ	; MissileClass::DropTarget

; 886  : 
; 887  : 	SimWeaponClass::SetDead(flag);

	mov	eax, DWORD PTR _flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDead@SimWeaponClass@@UAEXH@Z	; SimWeaponClass::SetDead

; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDead@MissileClass@@UAEXH@Z ENDP			; MissileClass::SetDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_rangeToGo$ = -24					; size = 4
_overtake$ = -20					; size = 4
tv135 = -16						; size = 4
_this$ = -12						; size = 4
tv140 = -8						; size = 4
tv88 = -4						; size = 4
_alt$ = 8						; size = 4
_vt$ = 12						; size = 4
_ataFrom$ = 16						; size = 4
_targetVt$ = 20						; size = 4
_range$ = 24						; size = 4
?GetActiveRange@MissileClass@@QAEMMMMMM@Z PROC		; MissileClass::GetActiveRange
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	// Well, I don't much like this, but it'll be consistent with the other bogus data...
; 765  : 	float overtake = MISSILE_SPEED  + (alt/1000.0f * MISSILE_ALTITUDE_BONUS)+ targetVt* (float)cos(ataFrom);//me123 + vt taken out and "alt" addet due to aim120 tof problems

	movss	xmm0, DWORD PTR _alt$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR _MISSILE_ALTITUDE_BONUS
	addss	xmm0, DWORD PTR _MISSILE_SPEED
	push	ecx
	movss	xmm1, DWORD PTR _ataFrom$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv140[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv88[ebp]
	movss	xmm0, DWORD PTR tv88[ebp]
	mulss	xmm0, DWORD PTR _targetVt$[ebp]
	movss	xmm1, DWORD PTR tv140[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _overtake$[ebp], xmm1

; 766  : 	float rangeToGo = overtake * GetActiveTime(alt, vt, ataFrom, targetVt, range);

	push	ecx
	movss	xmm0, DWORD PTR _range$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _targetVt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ataFrom$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _alt$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetActiveTime@MissileClass@@QAEMMMMMM@Z ; MissileClass::GetActiveTime
	fstp	DWORD PTR tv135[ebp]
	movss	xmm0, DWORD PTR tv135[ebp]
	mulss	xmm0, DWORD PTR _overtake$[ebp]
	movss	DWORD PTR _rangeToGo$[ebp], xmm0

; 767  : 	return rangeToGo; //me123 the missile goes active when there's a serden sec TOF left, not after a serden TOF // range - rangeToGo;

	fld	DWORD PTR _rangeToGo$[ebp]

; 768  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetActiveRange@MissileClass@@QAEMMMMMM@Z ENDP		; MissileClass::GetActiveRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?GetActiveTime@MissileClass@@QAEMMMMMM@Z PROC		; MissileClass::GetActiveTime
; _this$ = ecx

; 772  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 773  : 	// This could be a variable, but for now its a constant per missile type
; 774  : 	return inputData->mslActiveTtg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	fld	DWORD PTR [ecx+84]

; 775  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetActiveTime@MissileClass@@QAEMMMMMM@Z ENDP		; MissileClass::GetActiveTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_rmax$ = -24						; size = 4
_weaponData$ = -20					; size = 4
_classPtr$ = -16					; size = 4
tv83 = -12						; size = 4
_ase$ = -8						; size = 4
_this$ = -4						; size = 4
_alt$ = 8						; size = 4
_vt$ = 12						; size = 4
_ataFrom$ = 16						; size = 4
_targetVt$ = 20						; size = 4
_range$ = 24						; size = 4
?GetASE@MissileClass@@QAEMMMMMM@Z PROC			; MissileClass::GetASE
; _this$ = ecx

; 778  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 779  : Falcon4EntityClassType* classPtr = (Falcon4EntityClassType*)EntityType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	DWORD PTR _classPtr$[ebp], eax

; 780  : WeaponClassDataType* weaponData = (WeaponClassDataType*)classPtr->dataPtr;

	mov	eax, DWORD PTR _classPtr$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	mov	DWORD PTR _weaponData$[ebp], ecx

; 781  : 
; 782  : float ase;
; 783  : float rmax = weaponData->Range * KM_TO_FT;

	mov	edx, DWORD PTR _weaponData$[ebp]
	movsx	eax, WORD PTR [edx+8]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _rmax$[ebp], xmm0

; 784  : 
; 785  : 	alt = vt = ataFrom = targetVt = range;

	movss	xmm0, DWORD PTR _range$[ebp]
	movss	DWORD PTR _targetVt$[ebp], xmm0
	movss	xmm0, DWORD PTR _targetVt$[ebp]
	movss	DWORD PTR _ataFrom$[ebp], xmm0
	movss	xmm0, DWORD PTR _ataFrom$[ebp]
	movss	DWORD PTR _vt$[ebp], xmm0
	movss	xmm0, DWORD PTR _vt$[ebp]
	movss	DWORD PTR _alt$[ebp], xmm0

; 786  : 	ase = inputData->gimlim * RTD * (1.0F - range/rmax);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+848]
	movss	xmm0, DWORD PTR [edx+52]
	mulss	xmm0, DWORD PTR __real@42652ee1
	movss	xmm1, DWORD PTR _range$[ebp]
	divss	xmm1, DWORD PTR _rmax$[ebp]
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, xmm1
	mulss	xmm0, xmm2
	movss	DWORD PTR _ase$[ebp], xmm0

; 787  : 
; 788  : 	return (max (ase, 0.0F));

	movss	xmm0, DWORD PTR _ase$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@GetASE
	movss	xmm0, DWORD PTR _ase$[ebp]
	movss	DWORD PTR tv83[ebp], xmm0
	jmp	SHORT $LN4@GetASE
$LN3@GetASE:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv83[ebp], xmm0
$LN4@GetASE:
	fld	DWORD PTR tv83[ebp]

; 789  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetASE@MissileClass@@QAEMMMMMM@Z ENDP			; MissileClass::GetASE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv138 = -32						; size = 8
_this$ = -24						; size = 4
tv147 = -20						; size = 4
tv128 = -16						; size = 4
tv86 = -12						; size = 4
_overtake$ = -8						; size = 4
_tof$ = -4						; size = 4
_alt$ = 8						; size = 4
_vt$ = 12						; size = 4
_ataFrom$ = 16						; size = 4
_targetVt$ = 20						; size = 4
_range$ = 24						; size = 4
?GetTOF@MissileClass@@QAEMMMMMM@Z PROC			; MissileClass::GetTOF
; _this$ = ecx

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 753  : 	// TODO:  Get this from a table like the max range stuff above...
; 754  : 	float overtake = MISSILE_SPEED  + (alt/1000.0f * MISSILE_ALTITUDE_BONUS)+ targetVt* (float)cos(ataFrom);//me123 + vt taken out and "alt" addet due to aim120 tof problems

	movss	xmm0, DWORD PTR _alt$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR _MISSILE_ALTITUDE_BONUS
	addss	xmm0, DWORD PTR _MISSILE_SPEED
	push	ecx
	movss	xmm1, DWORD PTR _ataFrom$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv147[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv128[ebp]
	movss	xmm0, DWORD PTR tv128[ebp]
	mulss	xmm0, DWORD PTR _targetVt$[ebp]
	movss	xmm1, DWORD PTR tv147[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _overtake$[ebp], xmm1

; 755  : 		  overtake += (vt * FTPSEC_TO_KNOTS - 150.0f)/2 ;//me123 platform speed bonus // JB 010215 changed from 250 to 150

	movss	xmm0, DWORD PTR _vt$[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	subss	xmm0, DWORD PTR __real@43160000
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _overtake$[ebp]
	movss	DWORD PTR _overtake$[ebp], xmm0

; 756  : 	float tof = range/overtake;

	movss	xmm0, DWORD PTR _range$[ebp]
	divss	xmm0, DWORD PTR _overtake$[ebp]
	movss	DWORD PTR _tof$[ebp], xmm0

; 757  : 	tof += -5.0f * (float) sin(.07 * tof); // JB 010215

	cvtss2sd xmm0, DWORD PTR _tof$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fb1eb851eb851ec
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv138[ebp]
	movsd	xmm0, QWORD PTR tv138[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@c0a00000
	addss	xmm0, DWORD PTR _tof$[ebp]
	movss	DWORD PTR _tof$[ebp], xmm0

; 758  : 
; 759  : 	return max (0.0F, tof );	// Counting on silent failure of divid by 0.0 here...

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _tof$[ebp]
	jbe	SHORT $LN3@GetTOF
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN4@GetTOF
$LN3@GetTOF:
	movss	xmm0, DWORD PTR _tof$[ebp]
	movss	DWORD PTR tv86[ebp], xmm0
$LN4@GetTOF:
	fld	DWORD PTR tv86[ebp]

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetTOF@MissileClass@@QAEMMMMMM@Z ENDP			; MissileClass::GetTOF
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv214 = -24						; size = 4
tv208 = -20						; size = 4
_weaponData$1 = -16					; size = 4
_classPtr$ = -12					; size = 4
_rmax$ = -8						; size = 4
_this$ = -4						; size = 4
_alt$ = 8						; size = 4
_vt$ = 12						; size = 4
_az$ = 16						; size = 4
_targetVt$ = 20						; size = 4
_ataFrom$ = 24						; size = 4
?GetRMax@MissileClass@@QAEMMMMMM@Z PROC			; MissileClass::GetRMax
; _this$ = ecx

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 705  : #if 1
; 706  :     // JPO CTD checks
; 707  : 
; 708  :     ShiAssert(FALSE == F4IsBadReadPtr (rangeData, sizeof (rangeData)));
; 709  : 
; 710  : 	if (!rangeData || F4IsBadReadPtr (rangeData, sizeof (rangeData))) //Wombat778 3-23-04  Added CTD check

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+852], 0
	je	SHORT $LN4@GetRMax
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+852]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@GetRMax
$LN4@GetRMax:

; 711  : 							// MLR 5/2/2004 - this bug was caused by heli brains firing the new rocket code.
; 712  : 		return 0.0F;

	fldz
	jmp	$LN6@GetRMax
$LN5@GetRMax:

; 713  : 	
; 714  : 
; 715  : // 2000-11-17 MODIFIED BY S.G. az CAN'T BE USED HERE BECAUSE IT CAN BE NEGATIVE AND THE DATA FILE DO NOT ACCOUNT FOR THAT. PLUS HEAD AND TAIL HAVE THE SAME VALUE (BAD!)
; 716  : 	float rmax = 10.0f;

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _rmax$[ebp], xmm0

; 717  : 	if (rangeData)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+852], 0
	je	$LN3@GetRMax

; 718  : 	{
; 719  : 		// FRB - CTD's
; 720  : 		rmax = Math.ThreedInterp (alt, vt, ataFrom,
; 721  : 						  rangeData->altBreakpoints, rangeData->velBreakpoints,
; 722  : 						  rangeData->aspectBreakpoints, rangeData->data,
; 723  : 						  rangeData->numAltBreakpoints, rangeData->numVelBreakpoints,
; 724  : 						  rangeData->numAspectBreakpoints, &lastRmaxAlt, &lastRmaxVt, &lastRmaxAta);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 800				; 00000320H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 808				; 00000328H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 804				; 00000324H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+852]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _ataFrom$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vt$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _alt$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?Math@@3VSIMLIB_MATH_CLASS@@A ; Math
	call	?ThreedInterp@SIMLIB_MATH_CLASS@@QAEMMMMPBM000HHHPAH11@Z ; SIMLIB_MATH_CLASS::ThreedInterp
	fstp	DWORD PTR _rmax$[ebp]
$LN3@GetRMax:

; 725  : 	}
; 726  : //#else
; 727  : 	Falcon4EntityClassType* classPtr = (Falcon4EntityClassType*)EntityType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	DWORD PTR _classPtr$[ebp], eax

; 728  : 	if (classPtr)

	cmp	DWORD PTR _classPtr$[ebp], 0
	je	SHORT $LN1@GetRMax

; 729  : 	{
; 730  : 		WeaponClassDataType* weaponData = (WeaponClassDataType*)classPtr->dataPtr;

	mov	edx, DWORD PTR _classPtr$[ebp]
	mov	eax, DWORD PTR [edx+77]
	mov	DWORD PTR _weaponData$1[ebp], eax

; 731  : 		if (weaponData)

	cmp	DWORD PTR _weaponData$1[ebp], 0
	je	SHORT $LN1@GetRMax

; 732  : 			rmax = weaponData->Range * KM_TO_FT;

	mov	ecx, DWORD PTR _weaponData$1[ebp]
	movsx	edx, WORD PTR [ecx+8]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _rmax$[ebp], xmm0
$LN1@GetRMax:

; 733  : 	}
; 734  : #endif
; 735  : 
; 736  : 	// Scale for closure
; 737  : 	rmax *= (1500.0F + vt + targetVt*(float)cos(ataFrom)) / 1500.0F;

	movss	xmm0, DWORD PTR __real@44bb8000
	addss	xmm0, DWORD PTR _vt$[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _ataFrom$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv214[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv208[ebp]
	movss	xmm0, DWORD PTR tv208[ebp]
	mulss	xmm0, DWORD PTR _targetVt$[ebp]
	movss	xmm1, DWORD PTR tv214[ebp]
	addss	xmm1, xmm0
	divss	xmm1, DWORD PTR __real@44bb8000
	mulss	xmm1, DWORD PTR _rmax$[ebp]
	movss	DWORD PTR _rmax$[ebp], xmm1

; 738  : 
; 739  : 	// Scale for ataFrom
; 740  : //	rmax *= (cos(ataFrom) + 1.5F) / 2.5F;
; 741  : 
; 742  : 	return (rmax);

	fld	DWORD PTR _rmax$[ebp]
$LN6@GetRMax:

; 743  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetRMax@MissileClass@@QAEMMMMMM@Z ENDP			; MissileClass::GetRMax
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_newPos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?UpdatePosition@MissileClass@@QAEXXZ PROC		; MissileClass::UpdatePosition
; _this$ = ecx

; 850  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 851  : Tpoint newPos;
; 852  : 
; 853  : 	if (!ifd)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+988], 0
	jne	SHORT $LN1@UpdatePosi

; 854  : 		return; // JB 010803

	jmp	$LN2@UpdatePosi
$LN1@UpdatePosi:

; 855  : 
; 856  :    drawPointer->GetPosition(&newPos);

	lea	ecx, DWORD PTR _newPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 857  :    ifd->oldx[0] = newPos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR _newPos$[ebp]
	movss	DWORD PTR [ecx+edx+352], xmm0

; 858  :    ifd->oldx[1] = newPos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _newPos$[ebp]
	movss	DWORD PTR [ecx+edx+352], xmm0

; 859  :    ifd->oldx[2] = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx+352], xmm0

; 860  :    ifd->oldx[3] = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	imul	edx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx+352], xmm0

; 861  : 
; 862  :    ifd->oldy[0] = newPos.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR _newPos$[ebp+4]
	movss	DWORD PTR [ecx+edx+376], xmm0

; 863  :    ifd->oldy[1] = newPos.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _newPos$[ebp+4]
	movss	DWORD PTR [ecx+edx+376], xmm0

; 864  :    ifd->oldy[2] = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx+376], xmm0

; 865  :    ifd->oldy[3] = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	imul	edx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx+376], xmm0

; 866  : 
; 867  :    ifd->oldz[0] = newPos.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR _newPos$[ebp+8]
	movss	DWORD PTR [ecx+edx+400], xmm0

; 868  :    ifd->oldz[1] = newPos.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _newPos$[ebp+8]
	movss	DWORD PTR [ecx+edx+400], xmm0

; 869  :    ifd->oldz[2] = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx+400], xmm0

; 870  :    ifd->oldz[3] = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, 4
	imul	edx, 3
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+edx+400], xmm0
$LN2@UpdatePosi:

; 871  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdatePosition@MissileClass@@QAEXXZ ENDP		; MissileClass::UpdatePosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_az$ = 8						; size = 4
_el$ = 12						; size = 4
?GetSeekerPos@MissileClass@@QAEXPAM0@Z PROC		; MissileClass::GetSeekerPos
; _this$ = ecx

; 836  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 837  :    if (sensorArray)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+648], 0
	je	SHORT $LN2@GetSeekerP

; 838  :    {
; 839  : 		*az = sensorArray[0]->SeekerAz();

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR [eax+ecx]
	call	?SeekerAz@SensorClass@@QAEMXZ		; SensorClass::SeekerAz
	mov	ecx, DWORD PTR _az$[ebp]
	fstp	DWORD PTR [ecx]

; 840  : 		*el = sensorArray[0]->SeekerEl();

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	ecx, DWORD PTR [ecx+edx]
	call	?SeekerEl@SensorClass@@QAEMXZ		; SensorClass::SeekerEl
	mov	edx, DWORD PTR _el$[ebp]
	fstp	DWORD PTR [edx]

; 841  :    }
; 842  :    else

	jmp	SHORT $LN1@GetSeekerP
$LN2@GetSeekerP:

; 843  :    {
; 844  :       *az = 0.0F;

	mov	eax, DWORD PTR _az$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0

; 845  :       *el = 0.0F;

	mov	ecx, DWORD PTR _el$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx], xmm0
$LN1@GetSeekerP:

; 846  :    }
; 847  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetSeekerPos@MissileClass@@QAEXPAM0@Z ENDP		; MissileClass::GetSeekerPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv268 = -16						; size = 4
tv258 = -12						; size = 4
_isLimited$ = -8					; size = 4
_this$ = -4						; size = 4
_az$ = 8						; size = 4
_el$ = 12						; size = 4
?SetSeekerPos@MissileClass@@QAEHPAM0@Z PROC		; MissileClass::SetSeekerPos
; _this$ = ecx

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 798  : 	int isLimited = FALSE;

	mov	DWORD PTR _isLimited$[ebp], 0

; 799  : 	
; 800  : 	
; 801  : 	ShiAssert( parent->IsSim() );	// SCR 9/22/98:  I think this is only called on behalf of the player.
; 802  : 	ShiAssert( parent );			// A missile should always have a parent
; 803  : //	if (parent && parent->IsSim() )
; 804  : //	{
; 805  : 		memcpy (dmx, ((SimBaseClass*)parent.get())->dmx, sizeof (TransformMatrix));

	push	36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	add	eax, 296				; 00000128H
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 296				; 00000128H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 806  : //	}
; 807  : 	
; 808  : 	ShiAssert( sensorArray );	// SCR 10/9/98:  Who's calling this on a missile with no seeker???
; 809  : 	if(sensorArray == NULL) {	// VWF I'm hoping that this will help.

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+648], 0
	jne	SHORT $LN5@SetSeekerP

; 810  : 		return FALSE;

	xor	eax, eax
	jmp	$LN1@SetSeekerP
$LN5@SetSeekerP:

; 811  : 	}
; 812  : 	
; 813  : 	sensorArray[0]->SetSeekerPos (*az, *el);

	mov	edx, DWORD PTR _el$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _az$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+648]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [esi+56]
	call	edx

; 814  : 	LimitSeeker(*az,*el);

	mov	eax, DWORD PTR _el$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _az$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LimitSeeker@MissileClass@@AAEXMM@Z	; MissileClass::LimitSeeker

; 815  : 	*az = sensorArray[0]->SeekerAz();

	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	ecx, DWORD PTR [ecx+edx]
	call	?SeekerAz@SensorClass@@QAEMXZ		; SensorClass::SeekerAz
	mov	edx, DWORD PTR _az$[ebp]
	fstp	DWORD PTR [edx]

; 816  : 	*el = sensorArray[0]->SeekerEl();

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	ecx, DWORD PTR [edx+eax]
	call	?SeekerEl@SensorClass@@QAEMXZ		; SensorClass::SeekerEl
	mov	eax, DWORD PTR _el$[ebp]
	fstp	DWORD PTR [eax]

; 817  : 	if (fabs(*az) == inputData->gimlim ||
; 818  : 		fabs(*el) == inputData->gimlim)

	mov	ecx, DWORD PTR _az$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv258[ebp]
	movss	xmm0, DWORD PTR tv258[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	ucomiss	xmm0, DWORD PTR [eax+52]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@SetSeekerP
	mov	ecx, DWORD PTR _el$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv268[ebp]
	movss	xmm0, DWORD PTR tv268[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	ucomiss	xmm0, DWORD PTR [eax+52]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN4@SetSeekerP
$LN3@SetSeekerP:

; 819  : 	{
; 820  : 		sensorArray[0]->SetSeekerPos (*az, *el);

	mov	ecx, DWORD PTR _el$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _az$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+648]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 821  : 		isLimited = TRUE;

	mov	DWORD PTR _isLimited$[ebp], 1

; 822  : 		if (inputData->displayType != DisplayHTS && display)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	cmp	DWORD PTR [ecx+96], 4
	je	SHORT $LN2@SetSeekerP
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+712], 0
	je	SHORT $LN2@SetSeekerP

; 823  : 		{
; 824  : 			((MaverickDisplayClass*)display)->SetSeekerPos(*az/inputData->gimlim,
; 825  : 				*el/inputData->gimlim);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	edx, DWORD PTR _el$[ebp]
	movss	xmm0, DWORD PTR [edx]
	divss	xmm0, DWORD PTR [ecx+52]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	edx, DWORD PTR _az$[ebp]
	movss	xmm0, DWORD PTR [edx]
	divss	xmm0, DWORD PTR [ecx+52]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	call	?SetSeekerPos@MaverickDisplayClass@@QAEXMM@Z ; MaverickDisplayClass::SetSeekerPos
$LN2@SetSeekerP:

; 826  : 		}
; 827  : 		return isLimited;

	mov	eax, DWORD PTR _isLimited$[ebp]
	jmp	SHORT $LN1@SetSeekerP

; 828  : 	}
; 829  : 	else

	jmp	SHORT $LN1@SetSeekerP
$LN4@SetSeekerP:

; 830  : 	{
; 831  : 		return FALSE;

	xor	eax, eax
$LN1@SetSeekerP:

; 832  : 	}
; 833  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSeekerPos@MissileClass@@QAEHPAM0@Z ENDP		; MissileClass::SetSeekerPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearReferences@MissileClass@@QAEXXZ PROC		; MissileClass::ClearReferences
; _this$ = ecx

; 932  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 933  : 	if (sensorArray && sensorArray[0] && sensorArray[0]->Type() == SensorClass::RadarHoming){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+648], 0
	je	SHORT $LN2@ClearRefer
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	cmp	DWORD PTR [ecx+eax], 0
	je	SHORT $LN2@ClearRefer
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR [eax+ecx]
	call	?Type@SensorClass@@QAE?AW4SensorType@1@XZ ; SensorClass::Type
	cmp	eax, 6
	jne	SHORT $LN2@ClearRefer

; 934  :       ((BeamRiderClass*)sensorArray[0])->SetGuidancePlatform(NULL);

	push	0
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	ecx, DWORD PTR [eax+ecx]
	call	?SetGuidancePlatform@BeamRiderClass@@QAEXPAVFalconEntity@@@Z ; BeamRiderClass::SetGuidancePlatform
$LN2@ClearRefer:

; 935  : 	}
; 936  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearReferences@MissileClass@@QAEXXZ ENDP		; MissileClass::ClearReferences
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv179 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
tv72 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_hasref$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_tgt$ = 8						; size = 4
?Start@MissileClass@@QAEXPAVSimObjectType@@@Z PROC	; MissileClass::Start
; _this$ = ecx

; 383  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 384  :    // Make sure we have initialized the missile rotation properly
; 385  :    F4Assert (initAz < 10.0F);
; 386  :    F4Assert (initAz > -10.0F);
; 387  :    F4Assert (initEl < 10.0F);
; 388  :    F4Assert (initEl > -10.0F);
; 389  : 
; 390  :    // alloc the in flight data
; 391  :    ifd = new MissileInFlightData;

	push	896					; 00000380H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN10@Start
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0MissileInFlightData@@QAE@XZ		; MissileInFlightData::MissileInFlightData
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN11@Start
$LN10@Start:
	mov	DWORD PTR tv72[ebp], 0
$LN11@Start:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+988], edx

; 392  : 
; 393  :    Init1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init1@MissileClass@@AAEXXZ		; MissileClass::Init1

; 394  :    CommandGuide();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CommandGuide@MissileClass@@AAEXXZ	; MissileClass::CommandGuide

; 395  : 
; 396  :    // At this point, we need to make a copy of our target data - Since we need to start
; 397  :    // Using relative geometry between us and the target - so force a target drop and
; 398  :    // retarget now that we're 'Launching'
; 399  : 
; 400  :    // edg NOTE: fucking with the order we set launch state and targeting
; 401  :    // could have deleterious effects on reference counting!  We want to
; 402  :    // DropTarget BEFORE we change state to Launching.  The launch state
; 403  :    // effects how SimObjs are constructed and referenced for targeting!
; 404  :    // In a Prelaunch state the missile's target has no reference.  When
; 405  :    // on rail or in flight the target is COPIED in SetTarget and ref'd.
; 406  : 
; 407  :    // If the missile is boresight, it gets to ignore the passed in target and keep its own
; 408  :    // Marco Edit - actually - if it's boresighted or uncaged
; 409  : 	 bool hasref = false; // JB 020109 CTD fix. Engage in safe referencing.  Shooting a breathing but unlocked Mav caused a CTD because DropTarget would delete the object that was later used.

	mov	BYTE PTR _hasref$[ebp], 0

; 410  :    if (!isSlave || !isCaged || tgt == NULL)// && sensorArray[0]->Type() == SensorClass::IRST) //me123 make sure only ir's are unchaged for now

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+736], 0
	je	SHORT $LN6@Start
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+728], 0
	je	SHORT $LN6@Start
	cmp	DWORD PTR _tgt$[ebp], 0
	jne	SHORT $LN7@Start
$LN6@Start:

; 411  :    {
; 412  : 		tgt = targetPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+656]
	mov	DWORD PTR _tgt$[ebp], eax

; 413  : 		if (tgt)

	cmp	DWORD PTR _tgt$[ebp], 0
	je	SHORT $LN7@Start

; 414  : 		{
; 415  : 			tgt->Reference(  );

	mov	ecx, DWORD PTR _tgt$[ebp]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference

; 416  : 			hasref = true;

	mov	BYTE PTR _hasref$[ebp], 1
$LN7@Start:

; 417  : 		}
; 418  :    }
; 419  : 
; 420  :    DropTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropTarget@MissileClass@@QAEXXZ	; MissileClass::DropTarget

; 421  :    launchState = Launching;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+724], 1

; 422  :    SetTarget(tgt);

	mov	edx, DWORD PTR _tgt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTarget@MissileClass@@QAEXPAVSimObjectType@@@Z ; MissileClass::SetTarget

; 423  : 
; 424  : 	 if (hasref)

	movzx	eax, BYTE PTR _hasref$[ebp]
	test	eax, eax
	je	SHORT $LN4@Start

; 425  : 		tgt->Release(  );

	mov	ecx, DWORD PTR _tgt$[ebp]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release
$LN4@Start:

; 426  : 
; 427  : // 2001-03-02 ADDED BY S.G. SO A LAUNCH IS DETECTED AT LAUNCH FOR SARH MISSILE!
; 428  :    if (targetPtr) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+656], 0
	je	SHORT $LN3@Start

; 429  : 	   if (GetSeekerType() == SensorClass::RadarHoming && sensorArray)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSeekerType@MissileClass@@QAEHXZ	; MissileClass::GetSeekerType
	cmp	eax, 6
	jne	SHORT $LN3@Start
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+648], 0
	je	SHORT $LN3@Start

; 430  : 		   ((BeamRiderClass *)sensorArray[0])->SendTrackMsg( targetPtr, Track_Launch );

	push	0
	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	push	ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	ecx, DWORD PTR [ecx+edx]
	call	?SendTrackMsg@BeamRiderClass@@QAEXPAVSimObjectType@@II@Z ; BeamRiderClass::SendTrackMsg
$LN3@Start:

; 431  :    }
; 432  : // END OF ADDED SECTION
; 433  : 
; 434  :    /*
; 435  :    if ( targetPtr )
; 436  :    {
; 437  : 	   targetX = targetPtr->BaseData()->XPos();
; 438  : 	   targetY = targetPtr->BaseData()->YPos();
; 439  : 	   targetZ = targetPtr->BaseData()->ZPos();
; 440  :    }
; 441  :    */
; 442  : 
; 443  :    /*
; 444  : #ifndef MISSILE_TEST_PROG
; 445  :    if (tgt)
; 446  :       MonoPrint ("Missile %d Launch at %8ld %4d -> %4d\n", Id().num_,SimLibElapsedTime, parent->Id().num_, targetPtr->BaseData()->Id().num_);
; 447  :    else
; 448  :       MonoPrint ("Missile %d Launch at %8ld %4d -> No Target\n", Id().num_,SimLibElapsedTime, parent->Id().num_);
; 449  : #endif
; 450  :       */
; 451  : 
; 452  :    if (inputData->displayType != DisplayHTS && display)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	cmp	DWORD PTR [eax+96], 4
	je	SHORT $LN8@Start
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+712], 0
	je	SHORT $LN8@Start

; 453  :    {
; 454  :       display->DisplayExit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+712]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+712]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 455  :       delete display;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN12@Start
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN13@Start
$LN12@Start:
	mov	DWORD PTR tv179[ebp], 0
$LN13@Start:

; 456  :       display = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+712], 0
$LN8@Start:

; 457  :    }
; 458  : /*
; 459  :    if (targetPtr)
; 460  : 	   MonoPrint ("Missile launched at %d\n", targetPtr->BaseData()->Id().num_);
; 461  :    else
; 462  : 	   MonoPrint ("Missile launched at nothing\n");
; 463  : */
; 464  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Start@MissileClass@@QAEXPAVSimObjectType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Start@MissileClass@@QAEXPAVSimObjectType@@@Z ENDP	; MissileClass::Start
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vmat$ = 8						; size = 4
?GetTransform@MissileClass@@UAEXQAY02M@Z PROC		; MissileClass::GetTransform
; _this$ = ecx

; 792  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 793  :    memcpy (vmat, dmx, sizeof (TransformMatrix));

	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 296				; 00000128H
	push	eax
	mov	ecx, DWORD PTR _vmat$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 794  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTransform@MissileClass@@UAEXQAY02M@Z ENDP		; MissileClass::GetTransform
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
$T2 = -124						; size = 8
$T3 = -116						; size = 8
$T4 = -108						; size = 8
$T5 = -100						; size = 8
tv885 = -92						; size = 8
tv831 = -84						; size = 8
tv998 = -76						; size = 4
$T6 = -72						; size = 4
tv871 = -68						; size = 4
tv588 = -64						; size = 4
$T7 = -60						; size = 4
_MissileActiveTime$8 = -56				; size = 4
tv534 = -52						; size = 4
tv514 = -48						; size = 4
tv881 = -44						; size = 4
tv827 = -40						; size = 4
_LastMissileImpactTime$9 = -36				; size = 4
_theFCC$10 = -32					; size = 4
_i$ = -28						; size = 4
_pa$11 = -24						; size = 4
_radioMessage$12 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Exec@MissileClass@@UAEHXZ PROC				; MissileClass::Exec
; _this$ = ecx

; 468  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Exec@MissileClass@@UAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 	int i;
; 470  : 	if (IsDead()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	je	SHORT $LN32@Exec

; 471  : 		return TRUE;

	mov	eax, 1
	jmp	$LN33@Exec
$LN32@Exec:

; 472  : 	}
; 473  : 
; 474  : #ifdef MLR_NEWSNDCODE
; 475  : 	SoundPos.UpdatePos(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?UpdatePos@F4SoundPos@@QAEXPAVSimBaseClass@@@Z ; F4SoundPos::UpdatePos

; 476  : #endif
; 477  : 
; 478  : 	if (IsLocal()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	$LN31@Exec

; 479  : 		if (IsExploding()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	je	SHORT $LN30@Exec

; 480  : 			if ( !IsSetFlag( SHOW_EXPLOSION ) ){

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	jne	SHORT $LN29@Exec

; 481  : 				// edg note: all special effects moved to the MissileEndMessage
; 482  : 				// Process member function
; 483  : 				// make sure we don't do it again...
; 484  : 				SetFlag( SHOW_EXPLOSION );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlag@SimBaseClass@@QAEXH@Z		; SimBaseClass::SetFlag

; 485  : 				// we can now kill it immediately
; 486  : 				SetDead(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+364]
	call	eax
$LN29@Exec:

; 487  : 			}
; 488  : 		}
; 489  : 		else {

	jmp	$LN10@Exec
$LN30@Exec:

; 490  : 			//if (((DrawableBSP*)drawPointer)->Label()[0] != '\0')
; 491  : 			//	MonoPrint ("ZPOS %.2f\n", ZPos());
; 492  : #ifndef MISSILE_TEST_PROG
; 493  : 			if (sensorArray){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+648], 0
	je	SHORT $LN27@Exec

; 494  : 				ShiAssert( sensorArray[0] );
; 495  : 				UpdateTargetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTargetData@MissileClass@@QAEXXZ	; MissileClass::UpdateTargetData
$LN27@Exec:

; 496  : 			}
; 497  : #else
; 498  : 			/*
; 499  : 			if ( targetPtr ){
; 500  : 				targetX = targetPtr->BaseData()->XPos();
; 501  : 				targetY = targetPtr->BaseData()->YPos();
; 502  : 				targetZ = targetPtr->BaseData()->ZPos();
; 503  : 			}
; 504  : 			*/
; 505  : 			CalcTransformMatrix(this);
; 506  : 			CalcRelGeom(this, targetPtr, NULL, 1.0F / SimLibMajorFrameTime);
; 507  : 			//MonoPrint ("%8.2f %8.2f %8d\n", targetPtr->localData->az*57.29F, targetPtr->localData->el*57.29F, SimLibElapsedTime);
; 508  : 
; 509  : 			if (ifd){ // JB 010803
; 510  : 				ifd->gimbal = min ( max (targetPtr->localData->ata, -inputData->gimlim), inputData->gimlim);
; 511  : 				ataerr = targetPtr->localData->ata - ifd->gimbal;
; 512  : 			}
; 513  : 	#endif
; 514  : 
; 515  : 			if (SimDriver.MotionOn()){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?MotionOn@SimulationDriver@@QAEHXZ	; SimulationDriver::MotionOn
	test	eax, eax
	je	SHORT $LN23@Exec

; 516  : 				CommandGuide();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CommandGuide@MissileClass@@AAEXXZ	; MissileClass::CommandGuide

; 517  : 				for (i=0; i<SimLibMinorPerMajor; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@Exec
$LN24@Exec:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN25@Exec:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR ?SimLibMinorPerMajor@@3HA ; SimLibMinorPerMajor
	jge	SHORT $LN23@Exec

; 518  : 					FlyMissile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlyMissile@MissileClass@@AAEXXZ	; MissileClass::FlyMissile

; 519  : 				}

	jmp	SHORT $LN24@Exec
$LN23@Exec:

; 520  : 			}
; 521  : 
; 522  : 			// JPO - is it time to jettison 2nd stage?
; 523  : 			if (ifd && ifd->stage2gone == false && auxData && runTime > auxData->SecondStageTimer) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+988], 0
	je	SHORT $LN22@Exec
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+988]
	movzx	ecx, BYTE PTR [eax+892]
	test	ecx, ecx
	jne	SHORT $LN22@Exec
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+860], 0
	je	SHORT $LN22@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+868]
	comiss	xmm0, DWORD PTR [ecx+36]
	jbe	SHORT $LN22@Exec

; 524  : 				ifd->stage2gone = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	BYTE PTR [ecx+892], 1
$LN22@Exec:

; 525  : 			}
; 526  : 
; 527  : 			if (((DrawableBSP*)drawPointer)->GetNumSwitches() > 0 ) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?GetNumSwitches@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNumSwitches
	test	eax, eax
	jle	SHORT $LN19@Exec

; 528  : 				if (ifd && ifd->stage2gone){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+988], 0
	je	SHORT $LN20@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+988]
	movzx	eax, BYTE PTR [edx+892]
	test	eax, eax
	je	SHORT $LN20@Exec

; 529  : 					// 2002-03-04 MN CTD fix
; 530  : 					((DrawableBSP *)drawPointer)->SetSwitchMask( 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 531  : 				}
; 532  : 				else {

	jmp	SHORT $LN19@Exec
$LN20@Exec:

; 533  : 					((DrawableBSP *)drawPointer)->SetSwitchMask( 0, 1 );

	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN19@Exec:

; 534  : 				}
; 535  : 			}
; 536  : 			ShiAssert(auxData); // MN which missile doesn't have aux data ??
; 537  : 			// A.S. Begin  deployable wings if "deployableWingsTime" is set in the .dat file of the missile 
; 538  : 			if( auxData && auxData->deployableWingsTime > 0 ){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+860], 0
	je	SHORT $LN16@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	movss	xmm0, DWORD PTR [edx+44]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN16@Exec

; 539  : 				if( runTime > auxData->deployableWingsTime){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+868]
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN16@Exec

; 540  : 					if (((DrawableBSP*)drawPointer)->GetNumSwitches() > 0 ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	call	?GetNumSwitches@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNumSwitches
	test	eax, eax
	jle	SHORT $LN16@Exec

; 541  : 						((DrawableBSP *)drawPointer)->SetSwitchMask( 0, 1 );

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN16@Exec:

; 542  : 					}
; 543  : 				}
; 544  : 			}
; 545  : 			// A.S. end
; 546  : 
; 547  : 			/*-----------------*/
; 548  : 			/* body axis accel */
; 549  : 
; 550  : 			ClosestApproach();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClosestApproach@MissileClass@@AAEXXZ	; MissileClass::ClosestApproach

; 551  : 			
; 552  : 			groundZ = OTWDriver.GetGroundLevel( x, y );

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+760]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+756]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+796]

; 553  : 			
; 554  : 			SetStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetStatus@MissileClass@@AAEXXZ		; MissileClass::SetStatus

; 555  : 
; 556  : 			/*--------------------*/
; 557  : 			/* Update shared data */
; 558  : 			/*--------------------*/
; 559  : 			SetPosition (x, y, z);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+764]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+760]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+756]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPosition@VuEntity@@QAEXMMM@Z	; VuEntity::SetPosition

; 560  : 			SetDelta(xdot, ydot, zdot);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+780]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+776]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+772]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 561  : 			SetYPR(psi, theta, phi);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+788]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+784]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+792]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 562  : 			SetYPRDelta (r, q, p);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+964]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+968]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+972]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta

; 563  : 			// sfr: no more
; 564  : 			//SetVt(vt);
; 565  : 
; 566  : 			if (launchState == InFlight){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+724], 2
	jne	$LN14@Exec

; 567  : 				// ACMI Output
; 568  : 				if (gACMIRec.IsRecording() && (SimLibFrameCount & 0x00000003 ) == 0){

	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?IsRecording@ACMIRecorder@@QAEHXZ	; ACMIRecorder::IsRecording
	test	eax, eax
	je	$LN14@Exec
	mov	eax, DWORD PTR ?SimLibFrameCount@@3IA	; SimLibFrameCount
	and	eax, 3
	jne	$LN14@Exec

; 569  : 					misPos.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv827[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv827[ebp]
	mov	edx, DWORD PTR tv827[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv831[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv831[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+1, xmm0

; 570  : 					misPos.data.type = Type();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	mov	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+5, eax

; 571  : 					misPos.data.uniqueID = ACMIIDTable->Add(Id(),NULL,TeamInfo[GetTeam()]->GetColor());//.num_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetColor@TeamClass@@QAEHXZ		; TeamClass::GetColor
	push	eax
	push	0
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z	; ACMI_Hash::Add
	mov	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+9, eax

; 572  : 					misPos.data.x = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+13

; 573  : 					misPos.data.y = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+17

; 574  : 					misPos.data.z = ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+21

; 575  : 					misPos.data.roll = phi;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+788]
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+33, xmm0

; 576  : 					misPos.data.pitch = theta;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+784]
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+29, xmm0

; 577  : 					misPos.data.yaw = psi;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+792]
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+25, xmm0

; 578  : 					// remove: misPos.data.teamColor = TeamInfo[GetTeam()]->GetColor();
; 579  : 					gACMIRec.MissilePositionRecord( &misPos );

	push	OFFSET ?misPos@@3UACMIMissilePositionRecord@@A ; misPos
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?MissilePositionRecord@ACMIRecorder@@QAEXPAUACMIMissilePositionRecord@@@Z ; ACMIRecorder::MissilePositionRecord
$LN14@Exec:

; 580  : 				}
; 581  : 			}
; 582  : 
; 583  : 			// edg: If a missle has status of missed, let it run for a while.
; 584  : 			// In general it's probably not a bad idea.  Specifically there
; 585  : 			// was a prob with the Mav's exploding almost immediately on launch
; 586  : 			// apparently they go quickly to a Missed status.  There may be another
; 587  : 			// problem there -- I'm just treating the symptom
; 588  : 			// 2002-04-04 MN only do that if we did not yet have closest approach on the target !!!
; 589  : 			// Hope this finally fixes floating missiles
; 590  : 			if ( 
; 591  : 				done == FalconMissileEndMessage::Missed && 
; 592  : 				runTime < 15.0f && 
; 593  : 				!((g_nMissileFix & 0x10) && (flags & ClosestApprch))
; 594  : 			){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 4
	jne	SHORT $LN13@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	comiss	xmm0, DWORD PTR [ecx+868]
	jbe	SHORT $LN13@Exec
	mov	edx, DWORD PTR ?g_nMissileFix@@3HA	; g_nMissileFix
	and	edx, 16					; 00000010H
	je	SHORT $LN12@Exec
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	and	ecx, 2
	jne	SHORT $LN13@Exec
$LN12@Exec:

; 595  : #ifndef MISSILE_TEST_PROG
; 596  : 				done = FalconMissileEndMessage::NotDone;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+720], 0
$LN13@Exec:

; 597  : #endif
; 598  : 			}
; 599  : 
; 600  : 			if ( done == FalconMissileEndMessage::Missed && ZPos() < groundZ - 10){ // MLR

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 4
	jne	SHORT $LN11@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv871[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+796]
	subss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR tv871[ebp]
	jbe	SHORT $LN11@Exec

; 601  : 				done = FalconMissileEndMessage::NotDone;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+720], 0
$LN11@Exec:

; 602  : 			}
; 603  : 
; 604  : 			if (done != FalconMissileEndMessage::NotDone){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+720], 0
	je	SHORT $LN10@Exec

; 605  : #ifndef MISSILE_TEST_PROG
; 606  :    				EndMissile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EndMissile@MissileClass@@AAEXXZ	; MissileClass::EndMissile
$LN10@Exec:

; 607  : #endif
; 608  : 			}
; 609  : 		} // end motion on
; 610  : 
; 611  : 		if ( launchState == InFlight ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+724], 2
	jne	SHORT $LN9@Exec

; 612  :    			UpdateTrail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTrail@MissileClass@@AAEXXZ	; MissileClass::UpdateTrail
$LN9@Exec:

; 613  : 		}
; 614  : 	} // end is local
; 615  : 	else {

	jmp	$LN8@Exec
$LN31@Exec:

; 616  : #if 0	
; 617  : 		// SCR 11/6/98  PowerOutput is part of SimBase's high priority dirty data.  It should be propigated
; 618  : 		// to all machines, so this should not be necessary.  If this is a problem, figure out why dirty
; 619  : 		// data is handling it...
; 620  : 
; 621  : 		// not local, reduce IR Scale over time
; 622  : 		SetPowerOutput( PowerOutput() - 0.25 * SimLibMajorFrameTime );
; 623  : #endif
; 624  : 		if (launchState == InFlight){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+724], 2
	jne	$LN7@Exec

; 625  : 			// ACMI Output
; 626  : 			if (gACMIRec.IsRecording() && (SimLibFrameCount & 0x00000003 ) == 0){

	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?IsRecording@ACMIRecorder@@QAEHXZ	; ACMIRecorder::IsRecording
	test	eax, eax
	je	$LN6@Exec
	mov	eax, DWORD PTR ?SimLibFrameCount@@3IA	; SimLibFrameCount
	and	eax, 3
	jne	$LN6@Exec

; 627  : 				misPos.hdr.time = SimLibElapsedTime * MSEC_TO_SEC + OTWDriver.todOffset;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv881[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv881[ebp]
	mov	edx, DWORD PTR tv881[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv885[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv885[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	addss	xmm0, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+32052
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+1, xmm0

; 628  : 				misPos.data.type = Type();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	eax, ax
	mov	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+5, eax

; 629  : 				misPos.data.uniqueID = ACMIIDTable->Add(Id(),NULL,TeamInfo[GetTeam()]->GetColor());//.num_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetColor@TeamClass@@QAEHXZ		; TeamClass::GetColor
	push	eax
	push	0
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?ACMIIDTable@@3PAVACMI_Hash@@A ; ACMIIDTable
	call	?Add@ACMI_Hash@@QAEJVVU_ID@@PADJ@Z	; ACMI_Hash::Add
	mov	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+9, eax

; 630  : 				misPos.data.x = XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+13

; 631  : 				misPos.data.y = YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+17

; 632  : 				misPos.data.z = ZPos();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+21

; 633  : 				misPos.data.roll = phi;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+788]
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+33, xmm0

; 634  : 				misPos.data.pitch = theta;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+784]
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+29, xmm0

; 635  : 				misPos.data.yaw = psi;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+792]
	movss	DWORD PTR ?misPos@@3UACMIMissilePositionRecord@@A+25, xmm0

; 636  : 				// remove: misPos.data.teamColor = TeamInfo[GetTeam()]->GetColor();
; 637  : 				gACMIRec.MissilePositionRecord( &misPos );

	push	OFFSET ?misPos@@3UACMIMissilePositionRecord@@A ; misPos
	mov	ecx, OFFSET ?gACMIRec@@3VACMIRecorder@@A ; gACMIRec
	call	?MissilePositionRecord@ACMIRecorder@@QAEXPAUACMIMissilePositionRecord@@@Z ; ACMIRecorder::MissilePositionRecord
$LN6@Exec:

; 638  : 			}
; 639  : 		}
; 640  : 		else {

	jmp	SHORT $LN5@Exec
$LN7@Exec:

; 641  : 			launchState = InFlight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+724], 2
$LN5@Exec:

; 642  : 		}
; 643  : 		// Update the ground height for this missile (used by the engine glow stuff I think)
; 644  : 		groundZ = OTWDriver.GetGroundLevel( XPos(), YPos() );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+796]

; 645  : 
; 646  : 		// Update the trail
; 647  :    		UpdateTrail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTrail@MissileClass@@AAEXXZ	; MissileClass::UpdateTrail
$LN8@Exec:

; 648  : 	}
; 649  : 
; 650  : 	//MI 6/01/02
; 651  : 	if(Pitbull && parent && parent->IsAirplane() && !SaidPitbull){ 

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+814]
	test	eax, eax
	je	$LN2@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??B?$VuBin@VFalconEntity@@@@QBE_NXZ	; VuBin<FalconEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	DWORD PTR tv514[ebp], eax
	mov	edx, DWORD PTR tv514[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv514[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN2@Exec
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+815]
	test	ecx, ecx
	jne	$LN2@Exec

; 652  : 		float LastMissileImpactTime = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _LastMissileImpactTime$9[ebp], xmm0

; 653  : 		float MissileActiveTime = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _MissileActiveTime$8[ebp], xmm0

; 654  : 		FireControlComputer* theFCC = ((SimVehicleClass*)parent.get())->GetFCC();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	DWORD PTR tv534[ebp], eax
	mov	edx, DWORD PTR tv534[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv534[ebp]
	mov	edx, DWORD PTR [eax+460]
	call	edx
	mov	DWORD PTR _theFCC$10[ebp], eax

; 655  : 		if(theFCC){

	cmp	DWORD PTR _theFCC$10[ebp], 0
	je	SHORT $LN3@Exec

; 656  : 			LastMissileImpactTime = theFCC->lastMissileImpactTime;

	mov	eax, DWORD PTR _theFCC$10[ebp]
	movss	xmm0, DWORD PTR [eax+268]
	movss	DWORD PTR _LastMissileImpactTime$9[ebp], xmm0

; 657  : 			MissileActiveTime = theFCC->missileActiveTime;   

	mov	ecx, DWORD PTR _theFCC$10[ebp]
	movss	xmm0, DWORD PTR [ecx+280]
	movss	DWORD PTR _MissileActiveTime$8[ebp], xmm0
$LN3@Exec:

; 658  : 		}
; 659  : 		   	   
; 660  : 		if(LastMissileImpactTime > 0.0F && (LastMissileImpactTime < MissileActiveTime)){

	movss	xmm0, DWORD PTR _LastMissileImpactTime$9[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN2@Exec
	movss	xmm0, DWORD PTR _MissileActiveTime$8[ebp]
	comiss	xmm0, DWORD PTR _LastMissileImpactTime$9[ebp]
	jbe	$LN2@Exec

; 661  : 			AircraftClass *pa = static_cast<AircraftClass*>(parent.get());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	DWORD PTR _pa$11[ebp], eax

; 662  : 			FalconRadioChatterMessage* radioMessage = 
; 663  : 			new FalconRadioChatterMessage( parent->Id(), FalconLocalSession );

	push	84					; 00000054H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN35@Exec
	push	1
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconRadioChatterMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconRadioChatterMessage::FalconRadioChatterMessage
	mov	DWORD PTR tv588[ebp], eax
	jmp	SHORT $LN36@Exec
$LN35@Exec:
	mov	DWORD PTR tv588[ebp], 0
$LN36@Exec:
	mov	eax, DWORD PTR tv588[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _radioMessage$12[ebp], ecx

; 664  : 			radioMessage->dataBlock.from = parent->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	ecx, eax
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _radioMessage$12[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 665  : 			radioMessage->dataBlock.to = MESSAGE_FOR_TEAM;

	mov	ecx, DWORD PTR _radioMessage$12[ebp]
	mov	BYTE PTR [ecx+60], 1

; 666  : 			radioMessage->dataBlock.voice_id = ((FlightClass*)
; 667  : 				(pa->GetCampaignObject()))->GetPilotVoiceID(
; 668  : 					pa->GetCampaignObject()->GetComponentIndex(pa)
; 669  : 				)
; 670  : 			;

	mov	edx, DWORD PTR _pa$11[ebp]
	push	edx
	mov	ecx, DWORD PTR _pa$11[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	push	eax
	mov	ecx, DWORD PTR _pa$11[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetPilotVoiceID@FlightClass@@QAEEH@Z	; FlightClass::GetPilotVoiceID
	mov	ecx, DWORD PTR _radioMessage$12[ebp]
	mov	BYTE PTR [ecx+61], al

; 671  : 			radioMessage->dataBlock.edata[0] = pa->GetCampaignObject()->GetComponentIndex(pa);

	mov	edx, DWORD PTR _pa$11[ebp]
	push	edx
	mov	ecx, DWORD PTR _pa$11[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _radioMessage$12[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 672  : 			radioMessage->dataBlock.message = rcFIREAMRAAM;

	mov	eax, 247				; 000000f7H
	mov	ecx, DWORD PTR _radioMessage$12[ebp]
	mov	WORD PTR [ecx+62], ax

; 673  : 			radioMessage->dataBlock.edata[1] = 6; // Pit Bull

	mov	edx, 2
	shl	edx, 0
	mov	eax, 6
	mov	ecx, DWORD PTR _radioMessage$12[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 674  : 			FalconSendMessage(radioMessage, TRUE);

	push	1
	mov	edx, DWORD PTR _radioMessage$12[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 675  : 			SaidPitbull = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+815], 1
$LN2@Exec:

; 676  : 		}
; 677  : 	}
; 678  : 
; 679  : #ifdef MLR_NEWSNDCODE
; 680  : 	if(PowerOutput() && auxData->EngineSound){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PowerOutput@SimBaseClass@@QAEMXZ	; SimBaseClass::PowerOutput
	fstp	DWORD PTR tv998[ebp]
	movss	xmm0, DWORD PTR tv998[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1@Exec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	cmp	DWORD PTR [edx+84], 0
	je	SHORT $LN1@Exec

; 681  : 		SoundPos.Sfx(auxData->EngineSound);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	call	?Sfx@F4SoundPos@@QAEXHHMM@Z		; F4SoundPos::Sfx
$LN1@Exec:

; 682  : 	}
; 683  : #endif
; 684  : 
; 685  : 	return TRUE;

	mov	eax, 1
$LN33@Exec:

; 686  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Exec@MissileClass@@UAEHXZ$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Exec@MissileClass@@UAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Exec@MissileClass@@UAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Exec@MissileClass@@UAEHXZ ENDP				; MissileClass::Exec
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initData$ = 8						; size = 4
?Init@MissileClass@@UAEXPAVSimInitDataClass@@@Z PROC	; MissileClass::Init
; _this$ = ecx

; 217  : void MissileClass::Init (SimInitDataClass* initData){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 218  :    if (initData == NULL){

	cmp	DWORD PTR _initData$[ebp], 0
	jne	SHORT $LN2@Init

; 219  :       Init();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+456]
	call	eax
$LN2@Init:

; 220  :    }
; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@MissileClass@@UAEXPAVSimInitDataClass@@@Z ENDP	; MissileClass::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_wc$ = -136						; size = 4
$T2 = -132						; size = 4
$T3 = -128						; size = 4
$T4 = -124						; size = 4
$T5 = -120						; size = 4
$T6 = -116						; size = 4
$T7 = -112						; size = 4
$T8 = -108						; size = 4
_wpnDefinition$ = -104					; size = 4
tv323 = -100						; size = 4
$T9 = -96						; size = 4
tv304 = -92						; size = 4
$T10 = -88						; size = 4
tv285 = -84						; size = 4
$T11 = -80						; size = 4
tv260 = -76						; size = 4
$T12 = -72						; size = 4
tv241 = -68						; size = 4
$T13 = -64						; size = 4
tv222 = -60						; size = 4
tv174 = -56						; size = 4
$T14 = -52						; size = 4
tv148 = -48						; size = 4
tv140 = -44						; size = 4
tv132 = -40						; size = 4
tv92 = -36						; size = 4
_classPtr$ = -32					; size = 4
tv157 = -28						; size = 4
_snsr$15 = -24						; size = 4
_dataIdx$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Init@MissileClass@@UAEXXZ PROC				; MissileClass::Init
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@MissileClass@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	Falcon4EntityClassType* classPtr;
; 226  : 	WeaponClassDataType* wc;
; 227  : 	SimWeaponDataType* wpnDefinition;
; 228  : 	int dataIdx;
; 229  : 
; 230  :    SimWeaponClass::Init ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@SimWeaponClass@@UAEXXZ		; SimWeaponClass::Init

; 231  :    classPtr = (Falcon4EntityClassType*)EntityType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	DWORD PTR _classPtr$[ebp], eax

; 232  : // 2000-09-29 MODIFIED BY S.G. I NEED TO SET 'inputData' EVEN IF NON LOCAL SO incomingMissile HAS THE RIGHT DATA
; 233  :    wc = (WeaponClassDataType*)classPtr->dataPtr;

	mov	eax, DWORD PTR _classPtr$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	mov	DWORD PTR _wc$[ebp], ecx

; 234  :    wpnDefinition = &SimWeaponDataTable[classPtr->vehicleDataIndex];

	mov	edx, DWORD PTR _classPtr$[ebp]
	movsx	eax, WORD PTR [edx+74]
	imul	eax, 52					; 00000034H
	add	eax, DWORD PTR ?SimWeaponDataTable@@3PAUSimWeaponDataType@@A ; SimWeaponDataTable
	mov	DWORD PTR _wpnDefinition$[ebp], eax

; 235  :    dataIdx = wpnDefinition->dataIdx;

	mov	ecx, DWORD PTR _wpnDefinition$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _dataIdx$[ebp], edx

; 236  :    ReadInput(dataIdx);

	mov	eax, DWORD PTR _dataIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadInput@MissileClass@@AAEXH@Z	; MissileClass::ReadInput

; 237  : // END OF ADDED SECTION
; 238  : 
; 239  : 
; 240  : 
; 241  : // 2002-04-05 MN engineData was NULL once, causing a crash. So lets give all missiles on all machines their data, regardless if they're local or not...
; 242  : //   if (IsLocal())
; 243  :    {
; 244  :       done = FalconMissileEndMessage::NotDone;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+720], 0

; 245  :       isCaged = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+728], 1

; 246  : 	  isSlave = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+736], 1

; 247  : 	  isSpot = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+732], 1

; 248  : 	  isTD = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+740], 0

; 249  : 
; 250  : 
; 251  :       /*----------------------------*/
; 252  :       /* read in data and options   */
; 253  :       /*----------------------------*/
; 254  : //      wpnDefinition = (SimWpnDefinition*)mvrDefinition;
; 255  : // 2000-09-29 COMMENTED OUT BY S.G. SINCE IT'S DONE ABOBE (THE LINE BEFORE WAS ALREADY COMMENTED OUT)
; 256  : //    wc = (WeaponClassDataType*)classPtr->dataPtr;
; 257  : //    wpnDefinition = &SimWeaponDataTable[classPtr->vehicleDataIndex];
; 258  : //    dataIdx = wpnDefinition->dataIdx;
; 259  : //    ReadInput(dataIdx);
; 260  : 
; 261  : 
; 262  :       aeroData =   missileDataset[min (dataIdx, numMissileDatasets-1)].aeroData;

	mov	eax, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	eax, 1
	cmp	DWORD PTR _dataIdx$[ebp], eax
	jge	SHORT $LN26@Init
	mov	ecx, DWORD PTR _dataIdx$[ebp]
	mov	DWORD PTR tv92[ebp], ecx
	jmp	SHORT $LN27@Init
$LN26@Init:
	mov	edx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	edx, 1
	mov	DWORD PTR tv92[ebp], edx
$LN27@Init:
	mov	eax, DWORD PTR tv92[ebp]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?missileDataset@@3PAVMissileDataSetClass@@A ; missileDataset
	mov	eax, DWORD PTR [edx+eax+80]
	mov	DWORD PTR [ecx+844], eax

; 263  :       rangeData =  missileDataset[min (dataIdx, numMissileDatasets-1)].rangeData;

	mov	ecx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	ecx, 1
	cmp	DWORD PTR _dataIdx$[ebp], ecx
	jge	SHORT $LN28@Init
	mov	edx, DWORD PTR _dataIdx$[ebp]
	mov	DWORD PTR tv132[ebp], edx
	jmp	SHORT $LN29@Init
$LN28@Init:
	mov	eax, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	eax, 1
	mov	DWORD PTR tv132[ebp], eax
$LN29@Init:
	mov	ecx, DWORD PTR tv132[ebp]
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?missileDataset@@3PAVMissileDataSetClass@@A ; missileDataset
	mov	ecx, DWORD PTR [eax+ecx+88]
	mov	DWORD PTR [edx+852], ecx

; 264  :       engineData = missileDataset[min (dataIdx, numMissileDatasets-1)].engineData;

	mov	edx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	edx, 1
	cmp	DWORD PTR _dataIdx$[ebp], edx
	jge	SHORT $LN30@Init
	mov	eax, DWORD PTR _dataIdx$[ebp]
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN31@Init
$LN30@Init:
	mov	ecx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	ecx, 1
	mov	DWORD PTR tv140[ebp], ecx
$LN31@Init:
	mov	edx, DWORD PTR tv140[ebp]
	imul	edx, 100				; 00000064H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?missileDataset@@3PAVMissileDataSetClass@@A ; missileDataset
	mov	edx, DWORD PTR [ecx+edx+92]
	mov	DWORD PTR [eax+856], edx

; 265  : 	auxData = missileDataset[min(dataIdx, numMissileDatasets-1)].auxData; // JPO

	mov	eax, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	eax, 1
	cmp	DWORD PTR _dataIdx$[ebp], eax
	jge	SHORT $LN32@Init
	mov	ecx, DWORD PTR _dataIdx$[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	jmp	SHORT $LN33@Init
$LN32@Init:
	mov	edx, DWORD PTR ?numMissileDatasets@@3HA	; numMissileDatasets
	sub	edx, 1
	mov	DWORD PTR tv148[ebp], edx
$LN33@Init:
	mov	eax, DWORD PTR tv148[ebp]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?missileDataset@@3PAVMissileDataSetClass@@A ; missileDataset
	mov	eax, DWORD PTR [edx+eax+96]
	mov	DWORD PTR [ecx+860], eax

; 266  : 
; 267  : 	ShiAssert(aeroData);
; 268  : 	ShiAssert(rangeData);
; 269  : 	ShiAssert(engineData);
; 270  : 	ShiAssert(auxData);
; 271  : 
; 272  : 
; 273  : 	  initXLoc = initYLoc = initZLoc = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+936], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+932], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+928], xmm0

; 274  : 
; 275  : 
; 276  : #ifndef MISSILE_TEST_PROG
; 277  : 		switch (inputData->displayType)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+848]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR tv157[ebp], eax
	cmp	DWORD PTR tv157[ebp], 0
	jle	$LN17@Init
	cmp	DWORD PTR tv157[ebp], 2
	jle	SHORT $LN21@Init
	cmp	DWORD PTR tv157[ebp], 4
	je	SHORT $LN20@Init
	jmp	$LN17@Init
$LN21@Init:

; 278  : 		{
; 279  : 			case DisplayBW:
; 280  : 			case DisplayIR:
; 281  : 				display = new MaverickDisplayClass (this);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN34@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0MaverickDisplayClass@@QAE@PAVSimMoverClass@@@Z ; MaverickDisplayClass::MaverickDisplayClass
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN35@Init
$LN34@Init:
	mov	DWORD PTR tv174[ebp], 0
$LN35@Init:
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T8[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR [eax+712], ecx

; 282  : 			break;

	jmp	SHORT $LN22@Init
$LN20@Init:

; 283  : 
; 284  : 			case DisplayHTS:
; 285  : 		 		if ( parent->IsCampaign() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::operator->
	mov	ecx, eax
	call	?IsCampaign@FalconEntity@@QAEHXZ	; FalconEntity::IsCampaign
	test	eax, eax
	je	SHORT $LN19@Init

; 286  : 					display = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+712], 0

; 287  : 				else

	jmp	SHORT $LN18@Init
$LN19@Init:

; 288  :             		display = FindSensor((SimMoverClass*)parent.get(), SensorClass::HTS);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+712], eax
$LN18@Init:

; 289  : 			break;

	jmp	SHORT $LN22@Init
$LN17@Init:

; 290  : 
; 291  : 			case DisplayNone:
; 292  : 			case DisplayColor:
; 293  : 			default:
; 294  : 				display = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+712], 0
$LN22@Init:

; 295  : 			break;
; 296  : 		}
; 297  : 
; 298  : 		// edg: total hack here.
; 299  : 		if (((VuEntityType *)classPtr)->classInfo_[VU_STYPE] == STYPE_MISSILE_SURF_SURF ){

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _classPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+8]
	cmp	edx, 6
	jne	SHORT $LN16@Init

; 300  : 	  		inputData->seekerType = SensorClass::Visual;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	DWORD PTR [ecx+88], 3

; 301  : 			inputData->seekerVersion = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	mov	DWORD PTR [eax+92], 0

; 302  : 			inputData->gimlim = 90.0f * DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+848]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR [edx+52], xmm0
$LN16@Init:

; 303  : 	  }
; 304  : 
; 305  : 	  SensorClass	*snsr;
; 306  : 	   switch (inputData->seekerType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR tv222[ebp], edx
	cmp	DWORD PTR tv222[ebp], 6
	ja	$LN8@Init
	mov	eax, DWORD PTR tv222[ebp]
	jmp	DWORD PTR $LN53@Init[eax*4]
$LN13@Init:

; 307  : 	   {
; 308  : 	     case SensorClass::IRST:
; 309  : 		   snsr = new IrstClass (inputData->seekerVersion, this);

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN36@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0IrstClass@@QAE@HPAVSimMoverClass@@@Z	; IrstClass::IrstClass
	mov	DWORD PTR tv241[ebp], eax
	jmp	SHORT $LN37@Init
$LN36@Init:
	mov	DWORD PTR tv241[ebp], 0
$LN37@Init:
	mov	edx, DWORD PTR tv241[ebp]
	mov	DWORD PTR $T7[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _snsr$15[ebp], eax

; 310  : 		   break;

	jmp	$LN14@Init
$LN12@Init:

; 311  : 		   
; 312  : 	     case SensorClass::Visual:
; 313  : 		   snsr = new EyeballClass (inputData->seekerVersion, this);

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN38@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0EyeballClass@@QAE@HPAVSimMoverClass@@@Z ; EyeballClass::EyeballClass
	mov	DWORD PTR tv260[ebp], eax
	jmp	SHORT $LN39@Init
$LN38@Init:
	mov	DWORD PTR tv260[ebp], 0
$LN39@Init:
	mov	edx, DWORD PTR tv260[ebp]
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _snsr$15[ebp], eax

; 314  : 		   break;

	jmp	$LN14@Init
$LN11@Init:

; 315  : 		   
; 316  : 	     case SensorClass::Radar:
; 317  : 		   snsr = new BeamRiderClass (GetRadarType(), this);

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN40@Init
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+292]
	call	edx
	push	eax
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0BeamRiderClass@@QAE@HPAVSimMoverClass@@@Z ; BeamRiderClass::BeamRiderClass
	mov	DWORD PTR tv285[ebp], eax
	jmp	SHORT $LN41@Init
$LN40@Init:
	mov	DWORD PTR tv285[ebp], 0
$LN41@Init:
	mov	eax, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _snsr$15[ebp], ecx

; 318  : 		   break;

	jmp	$LN14@Init
$LN10@Init:

; 319  : 
; 320  : 	     case SensorClass::RWR:
; 321  : 		   snsr = new HarmSeekerClass (inputData->seekerVersion, this);

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN42@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0HarmSeekerClass@@QAE@HPAVSimMoverClass@@@Z ; HarmSeekerClass::HarmSeekerClass
	mov	DWORD PTR tv304[ebp], eax
	jmp	SHORT $LN43@Init
$LN42@Init:
	mov	DWORD PTR tv304[ebp], 0
$LN43@Init:
	mov	eax, DWORD PTR tv304[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _snsr$15[ebp], ecx

; 322  : 		   break;

	jmp	SHORT $LN14@Init
$LN9@Init:

; 323  : 		   
; 324  : 	     case SensorClass::RadarHoming:
; 325  : 		   snsr = new BeamRiderClass (inputData->seekerVersion, this);

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN44@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0BeamRiderClass@@QAE@HPAVSimMoverClass@@@Z ; BeamRiderClass::BeamRiderClass
	mov	DWORD PTR tv323[ebp], eax
	jmp	SHORT $LN45@Init
$LN44@Init:
	mov	DWORD PTR tv323[ebp], 0
$LN45@Init:
	mov	eax, DWORD PTR tv323[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _snsr$15[ebp], ecx

; 326  : 		   break;

	jmp	SHORT $LN14@Init
$LN8@Init:

; 327  : 		   
; 328  : 	     default:
; 329  : 		   snsr = NULL;

	mov	DWORD PTR _snsr$15[ebp], 0
$LN14@Init:

; 330  : 		   break;
; 331  : 	   }
; 332  : 
; 333  : 	   if (snsr) {

	cmp	DWORD PTR _snsr$15[ebp], 0
	je	SHORT $LN7@Init

; 334  : 		   sensorArray = new SensorClass*[1];

	push	4
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+648], eax

; 335  : 		   sensorArray[0] = snsr;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	edx, DWORD PTR _snsr$15[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 336  : 		   numSensors = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+652], 1

; 337  : 	   } else {

	jmp	SHORT $LN6@Init
$LN7@Init:

; 338  : 		   sensorArray = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+648], 0

; 339  : 		   numSensors = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+652], 0
$LN6@Init:

; 340  : 	   }
; 341  : #else
; 342  :       sensorArray = NULL;
; 343  :       display = NULL;
; 344  :       numSensors = 0;
; 345  : #endif
; 346  :    }
; 347  : //   else // not local
; 348  : 	if (!IsLocal())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Init

; 349  :    {
; 350  : // 2002-04-05 MN not needed anymore...
; 351  : //      sensorArray = NULL; 
; 352  : //      display = NULL;
; 353  : 
; 354  : 	  
; 355  : #if 0	// SCR 11/6/98  PowerOutput is part of SimBase's high priority dirty data.  It should be propigated
; 356  : 		// to all machines, so this should not be necessary.  If this is a problem, figure out why dirty
; 357  : 		// data is handling it...
; 358  : 
; 359  : 	  // edg: set ir scale here.  I think this will work for doing the
; 360  : 	  // missile trails.  If we're non local I think we're flying so we'll
; 361  : 	  // want to start out with a full burn
; 362  : 	  // could we also do launch cloud here?
; 363  : 	  SetPowerOutput( 1.0f );
; 364  : #endif
; 365  : 
; 366  :      CalcTransformMatrix(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?CalcTransformMatrix@@YAXPAVSimBaseClass@@@Z ; CalcTransformMatrix
	add	esp, 4
$LN5@Init:

; 367  :    }
; 368  : 
; 369  :    launchState = PreLaunch;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+724], 0

; 370  : 	 if (drawPointer == (DrawableBSP*)0xbaadf00d)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+332], -1163005939	; baadf00dH
	jne	SHORT $LN4@Init

; 371  : 		 return;

	jmp	SHORT $LN24@Init
$LN4@Init:

; 372  :    // prime the display
; 373  :    if (drawPointer && ((DrawableBSP*)drawPointer)->GetNumSwitches() > 0 ) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN1@Init
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?GetNumSwitches@DrawableBSP@@QAEHXZ	; DrawableBSP::GetNumSwitches
	test	eax, eax
	jle	SHORT $LN1@Init

; 374  : 	   if (ifd && ifd->stage2gone) // no 2nd stage

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+988], 0
	je	SHORT $LN2@Init
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+988]
	movzx	eax, BYTE PTR [edx+892]
	test	eax, eax
	je	SHORT $LN2@Init

; 375  : 		   ((DrawableBSP *)drawPointer)->SetSwitchMask( 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask

; 376  : 	   else  // draw 2nd stage

	jmp	SHORT $LN1@Init
$LN2@Init:

; 377  : 		   ((DrawableBSP *)drawPointer)->SetSwitchMask( 0, 1 );

	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?SetSwitchMask@DrawableBSP@@QAEXHK@Z	; DrawableBSP::SetSwitchMask
$LN1@Init:
$LN24@Init:

; 378  :    }
; 379  : 
; 380  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@Init:
	DD	$LN13@Init
	DD	$LN11@Init
	DD	$LN10@Init
	DD	$LN12@Init
	DD	$LN8@Init
	DD	$LN8@Init
	DD	$LN9@Init
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Init@MissileClass@@UAEXXZ$0:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@MissileClass@@UAEXXZ$1:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@MissileClass@@UAEXXZ$2:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@MissileClass@@UAEXXZ$3:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@MissileClass@@UAEXXZ$4:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Init@MissileClass@@UAEXXZ$5:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@MissileClass@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@MissileClass@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@MissileClass@@UAEXXZ ENDP				; MissileClass::Init
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?LaunchDelayTime@MissileClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LaunchDelayTime@MissileClass@@UAEHXZ PROC		; MissileClass::LaunchDelayTime, COMDAT
; _this$ = ecx

; 266  : 	int LaunchDelayTime(void) { return auxData->pickleTimeDelay; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	eax, DWORD PTR [ecx+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?LaunchDelayTime@MissileClass@@UAEHXZ ENDP		; MissileClass::LaunchDelayTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?GetSeekerType@MissileClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSeekerType@MissileClass@@QAEHXZ PROC		; MissileClass::GetSeekerType, COMDAT
; _this$ = ecx

; 264  : 	int GetSeekerType (void) { return inputData->seekerType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	eax, DWORD PTR [ecx+88]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeekerType@MissileClass@@QAEHXZ ENDP		; MissileClass::GetSeekerType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
tv128 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?CleanupLocalData@MissileClass@@AAEXXZ PROC		; MissileClass::CleanupLocalData
; _this$ = ecx

; 210  : void MissileClass::CleanupLocalData(){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	if (runTime != 0.0F && !IsDead()){ SetDead(TRUE); }

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+868]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@CleanupLoc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@CleanupLoc
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+364]
	call	eax
$LN2@CleanupLoc:

; 212  : 	DropTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropTarget@MissileClass@@QAEXXZ	; MissileClass::DropTarget

; 213  : 	if (display && inputData->displayType != DisplayHTS){ delete display; }

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+712], 0
	je	SHORT $LN6@CleanupLoc
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+848]
	cmp	DWORD PTR [eax+96], 4
	je	SHORT $LN6@CleanupLoc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+712]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@CleanupLoc
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN6@CleanupLoc
$LN5@CleanupLoc:
	mov	DWORD PTR tv128[ebp], 0
$LN6@CleanupLoc:

; 214  : 	display = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+712], 0

; 215  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupLocalData@MissileClass@@AAEXXZ ENDP		; MissileClass::CleanupLocalData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitLocalData@MissileClass@@AAEXXZ PROC		; MissileClass::InitLocalData
; _this$ = ecx

; 136  : void MissileClass::InitLocalData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 	ifd = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+988], 0

; 138  : 	TrailId = Trail = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+692], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+696], 0

; 139  : 	engGlow = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+700], 0

; 140  : 	groundGlow = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+704], 0

; 141  : 	engGlowBSP1 = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+708], 0

; 142  : 	runTime = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+868], xmm0

; 143  : 	GuidenceTime = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+876], xmm0

; 144  : 	slaveTgt = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+716], 0

; 145  : 	targetPtr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+656], 0

; 146  : 	targetList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+660], 0

; 147  : 	display = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+712], 0

; 148  : 	isCaged = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+728], 0

; 149  : 	isSpot = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+732], 0

; 150  : 	isSlave = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+736], 0

; 151  : 	isTD = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+740], 0

; 152  : 	alpha = alphat = beta = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+752], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+748], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+744], xmm0

; 153  : 	x = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+756], xmm0

; 154  : 	y = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+760], xmm0

; 155  : 	z = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+764], xmm0

; 156  : 	alt = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+768], xmm0

; 157  : 	xdot = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+772], xmm0

; 158  : 	ydot = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+776], xmm0

; 159  : 	zdot = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+780], xmm0

; 160  : 	psi = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+792], xmm0

; 161  : 	theta = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+784], xmm0

; 162  : 	phi = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+788], xmm0

; 163  : 	groundZ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+796], xmm0

; 164  : 	weight = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+820], xmm0

; 165  : 	wprop = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+824], xmm0

; 166  : 	mass = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+828], xmm0

; 167  : 	m0 = mp0 = mprop = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+840], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+836], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+832], xmm0

; 168  : 	aeroData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+844], 0

; 169  : 	inputData= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+848], 0

; 170  : 	rangeData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+852], 0

; 171  : 	engineData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+856], 0

; 172  : 	auxData = NULL; // JPO

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+860], 0

; 173  : 	flags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+864], 0

; 174  : 	runTime = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+868], xmm0

; 175  : 	vt = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+880], xmm0

; 176  : 	vtdot = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+884], xmm0

; 177  : 	timpct = 100.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [eax+976], xmm0

; 178  : 	p = q = r = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+972], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+968], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+964], xmm0

; 179  : 	ricept = FLT_MAX;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR [ecx+980], xmm0

; 180  : 	ata = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+960], xmm0

; 181  : 	gimbal = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+948], xmm0

; 182  : 	gimdot = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+952], xmm0

; 183  : 	ataerr = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+956], xmm0

; 184  : 	targetX = -1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+904], xmm0

; 185  : 	targetY = -1.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+908], xmm0

; 186  : 	targetZ = -1.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+912], xmm0

; 187  : 	targetDX = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+916], xmm0

; 188  : 	targetDY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+920], xmm0

; 189  : 	targetDZ = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+924], xmm0

; 190  : 	lastRmaxAta = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], 0

; 191  : 	lastRmaxAlt = lastRmaxVt = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+808], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+804], 0

; 192  : 	initAz = initEl = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+944], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+940], xmm0

; 193  : 	if (IsLocal ()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@InitLocalD

; 194  : 		SetVuPosition();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+380]
	call	eax
$LN1@InitLocalD:

; 195  : 	}
; 196  : 
; 197  : 	//MI
; 198  : 	Covered = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+812], 1

; 199  : 	HOC = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+813], 1

; 200  : 	Pitbull = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+814], 1

; 201  : 	SaidPitbull = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+815], 0

; 202  : 	wentActive = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+816], 0

; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitLocalData@MissileClass@@AAEXXZ ENDP		; MissileClass::InitLocalData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CleanupData@MissileClass@@UAEXXZ PROC			; MissileClass::CleanupData
; _this$ = ecx

; 205  : void MissileClass::CleanupData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 	CleanupLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLocalData@MissileClass@@AAEXXZ	; MissileClass::CleanupLocalData

; 207  : 	SimWeaponClass::CleanupData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupData@SimWeaponClass@@UAEXXZ	; SimWeaponClass::CleanupData

; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CleanupData@MissileClass@@UAEXXZ ENDP			; MissileClass::CleanupData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitData@MissileClass@@UAEXXZ PROC			; MissileClass::InitData
; _this$ = ecx

; 131  : void MissileClass::InitData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 	SimWeaponClass::InitData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitData@SimWeaponClass@@UAEXXZ	; SimWeaponClass::InitData

; 133  : 	InitLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@MissileClass@@AAEXXZ	; MissileClass::InitLocalData

; 134  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitData@MissileClass@@UAEXXZ ENDP			; MissileClass::InitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1MissileClass@@UAE@XZ PROC				; MissileClass::~MissileClass
; _this$ = ecx

; 127  : MissileClass::~MissileClass(void){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1MissileClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MissileClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 128  : 	CleanupLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CleanupLocalData@MissileClass@@AAEXXZ	; MissileClass::CleanupLocalData

; 129  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimWeaponClass@@UAE@XZ		; SimWeaponClass::~SimWeaponClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1MissileClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimWeaponClass@@UAE@XZ		; SimWeaponClass::~SimWeaponClass
__ehhandler$??1MissileClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1MissileClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MissileClass@@UAE@XZ ENDP				; MissileClass::~MissileClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
??0MissileClass@@QAE@H@Z PROC				; MissileClass::MissileClass
; _this$ = ecx

; 123  : MissileClass::MissileClass(int type) : SimWeaponClass (type) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MissileClass@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimWeaponClass@@QAE@H@Z		; SimWeaponClass::SimWeaponClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MissileClass@@6B@

; 124  : 	InitLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@MissileClass@@AAEXXZ	; MissileClass::InitLocalData

; 125  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0MissileClass@@QAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimWeaponClass@@UAE@XZ		; SimWeaponClass::~SimWeaponClass
__ehhandler$??0MissileClass@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MissileClass@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MissileClass@@QAE@H@Z ENDP				; MissileClass::MissileClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_filePtr$ = 8						; size = 4
??0MissileClass@@QAE@PAU_iobuf@@@Z PROC			; MissileClass::MissileClass
; _this$ = ecx

; 119  : MissileClass::MissileClass(FILE* filePtr) : SimWeaponClass (filePtr){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MissileClass@@QAE@PAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _filePtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimWeaponClass@@QAE@PAU_iobuf@@@Z	; SimWeaponClass::SimWeaponClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MissileClass@@6B@

; 120  : 	InitLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@MissileClass@@AAEXXZ	; MissileClass::InitLocalData

; 121  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0MissileClass@@QAE@PAU_iobuf@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimWeaponClass@@UAE@XZ		; SimWeaponClass::~SimWeaponClass
__ehhandler$??0MissileClass@@QAE@PAU_iobuf@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MissileClass@@QAE@PAU_iobuf@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MissileClass@@QAE@PAU_iobuf@@@Z ENDP			; MissileClass::MissileClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
??0MissileClass@@QAE@PAPAEPAJ@Z PROC			; MissileClass::MissileClass
; _this$ = ecx

; 115  : MissileClass::MissileClass(VU_BYTE** stream, long *rem) : SimWeaponClass (stream, rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MissileClass@@QAE@PAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SimWeaponClass@@QAE@PAPAEPAJ@Z	; SimWeaponClass::SimWeaponClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7MissileClass@@6B@

; 116  : 	InitLocalData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@MissileClass@@AAEXXZ	; MissileClass::InitLocalData

; 117  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0MissileClass@@QAE@PAPAEPAJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SimWeaponClass@@UAE@XZ		; SimWeaponClass::~SimWeaponClass
__ehhandler$??0MissileClass@@QAE@PAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MissileClass@@QAE@PAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MissileClass@@QAE@PAPAEPAJ@Z ENDP			; MissileClass::MissileClass
; Function compile flags: /Odtp
;	COMDAT ??_GMissileInFlightData@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMissileInFlightData@@QAEPAXI@Z PROC			; MissileInFlightData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MissileInFlightData@@QAE@XZ		; MissileInFlightData::~MissileInFlightData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMissileInFlightData@@QAEPAXI@Z ENDP			; MissileInFlightData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MissileInFlightData@@QAE@XZ PROC			; MissileInFlightData::~MissileInFlightData
; _this$ = ecx

; 112  : MissileInFlightData::~MissileInFlightData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??1ObjectGeometry@@QAE@XZ		; ObjectGeometry::~ObjectGeometry
	mov	esp, ebp
	pop	ebp
	ret	0
??1MissileInFlightData@@QAE@XZ ENDP			; MissileInFlightData::~MissileInFlightData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\missile\missmain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MissileInFlightData@@QAE@XZ PROC			; MissileInFlightData::MissileInFlightData
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0ObjectGeometry@@QAE@XZ		; ObjectGeometry::ObjectGeometry

; 66   :       // Gains
; 67   :       kp01 = kp02 = kp03 = kp04 = kp05 = kp06 = kp07 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+24], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+20], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+16], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+12], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+8], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0

; 68   :       tp01 = tp02 = tp03 = tp04 = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+40], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+36], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+32], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+28], xmm0

; 69   :       wp01 = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+44], xmm0

; 70   :       zp01 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+48], xmm0

; 71   :       ky01 = ky02 = ky03 = ky04 = ky05 = ky06 = ky07 = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+76], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+72], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+68], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+60], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+56], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+52], xmm0

; 72   :       ty01 = ty02 = ty03 = ty04 = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+92], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+88], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+84], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+80], xmm0

; 73   :       wy01 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+96], xmm0

; 74   :       zy01 = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+100], xmm0

; 75   : 
; 76   :       // Geometry
; 77   :       alpdot = betdot = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+108], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+104], xmm0

; 78   :       gamma = sigma = mu = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+120], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+116], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+112], xmm0

; 79   : 
; 80   :       // Guidance
; 81   : 	 
; 82   :       // State
; 83   :       burnIndex = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+204], 0

; 84   :       rstab = qstab = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+212], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+208], xmm0

; 85   :       e1 = e2 = e3 = e4 = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+228], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+224], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+220], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+216], xmm0

; 86   : 
; 87   :       // Save Arrays
; 88   :       oldalp = oldalpdt = oldbet = oldbetdt = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+748], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+744], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+740], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+736], 0

; 89   : 
; 90   :       // Aero data
; 91   :       lastmach = lastalpha = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+756], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+752], 0

; 92   :       qsom = qovt = qbar = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+768], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+764], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+760], xmm0

; 93   : 
; 94   :       // Accels
; 95   :       xaero = yaero = zaero = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+780], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+776], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+772], xmm0

; 96   :       xsaero = ysaero = zsaero = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+792], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+788], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+784], xmm0

; 97   :       xwaero = ywaero = zwaero = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+804], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+800], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+796], xmm0

; 98   :       xprop = yprop = zprop = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+816], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+812], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+808], xmm0

; 99   :       xsprop = ysprop = zsprop = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+828], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+824], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+820], xmm0

; 100  :       xwprop = ywprop = zwprop = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+840], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+836], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+832], xmm0

; 101  :       nxcgw = nycgw = nzcgw = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+852], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+848], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+844], xmm0

; 102  :       nxcgb = nycgb = nzcgb = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+864], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+860], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+856], xmm0

; 103  :       nxcgs = nycgs = nzcgs = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+876], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+872], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+868], xmm0

; 104  : 
; 105  :       clalph = cybeta = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+884], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+880], xmm0

; 106  : 
; 107  :       // Closest Approach
; 108  :       lastCMDeployed = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+888], 0

; 109  : 	stage2gone = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+892], 0

; 110  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0MissileInFlightData@@QAE@XZ ENDP			; MissileInFlightData::MissileInFlightData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\navunit.h
;	COMDAT ?DecrementMissileCount@TaskForceClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecrementMissileCount@TaskForceClass@@QAEXXZ PROC	; TaskForceClass::DecrementMissileCount, COMDAT
; _this$ = ecx

; 130  : 	void DecrementMissileCount (void)					{ missiles_flying--; if (missiles_flying == 0) ReturnToSearch(); ShiAssert( missiles_flying>=0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+296]
	sub	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+296], cl
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+296]
	test	ecx, ecx
	jne	SHORT $LN2@DecrementM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+136]
	call	edx
$LN2@DecrementM:
	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementMissileCount@TaskForceClass@@QAEXXZ ENDP	; TaskForceClass::DecrementMissileCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\navunit.h
;	COMDAT ?IncrementMissileCount@TaskForceClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementMissileCount@TaskForceClass@@QAEXXZ PROC	; TaskForceClass::IncrementMissileCount, COMDAT
; _this$ = ecx

; 129  : 	void IncrementMissileCount (void)					{ missiles_flying++; SetRadarMode(FEC_RADAR_GUIDE); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+296]
	add	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+296], cl
	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementMissileCount@TaskForceClass@@QAEXXZ ENDP	; TaskForceClass::IncrementMissileCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?DecrementMissileCount@BattalionClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DecrementMissileCount@BattalionClass@@QAEXXZ PROC	; BattalionClass::DecrementMissileCount, COMDAT
; _this$ = ecx

; 148  : 	void DecrementMissileCount (void)					{ missiles_flying--; if (missiles_flying == 0) ReturnToSearch(); ShiAssert( missiles_flying>=0); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+301]
	sub	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+301], cl
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+301]
	test	ecx, ecx
	jne	SHORT $LN2@DecrementM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+136]
	call	edx
$LN2@DecrementM:
	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementMissileCount@BattalionClass@@QAEXXZ ENDP	; BattalionClass::DecrementMissileCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\battalion.h
;	COMDAT ?IncrementMissileCount@BattalionClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementMissileCount@BattalionClass@@QAEXXZ PROC	; BattalionClass::IncrementMissileCount, COMDAT
; _this$ = ecx

; 147  : 	void IncrementMissileCount (void)					{ missiles_flying++; SetRadarMode(FEC_RADAR_GUIDE); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+301]
	add	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+301], cl
	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementMissileCount@BattalionClass@@QAEXXZ ENDP	; BattalionClass::IncrementMissileCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?IsUseable@SimWeaponClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUseable@SimWeaponClass@@UAEHXZ PROC			; SimWeaponClass::IsUseable, COMDAT
; _this$ = ecx

; 70   : 	virtual int IsUseable (void) {return TRUE;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUseable@SimWeaponClass@@UAEHXZ ENDP			; SimWeaponClass::IsUseable
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simweapn.h
;	COMDAT ?IsWeapon@SimWeaponClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWeapon@SimWeaponClass@@UAEHXZ PROC			; SimWeaponClass::IsWeapon, COMDAT
; _this$ = ecx

; 61   : 	virtual int IsWeapon (void) {return TRUE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWeapon@SimWeaponClass@@UAEHXZ ENDP			; SimWeaponClass::IsWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\acmi\src\include\acmirec.h
;	COMDAT ?IsRecording@ACMIRecorder@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRecording@ACMIRecorder@@QAEHXZ PROC			; ACMIRecorder::IsRecording, COMDAT
; _this$ = ecx

; 319  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return _recording;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 321  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRecording@ACMIRecorder@@QAEHXZ ENDP			; ACMIRecorder::IsRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?PRANDInt3@@YAHXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_x$ = -4						; size = 4
?PRANDInt3@@YAHXZ PROC					; PRANDInt3, COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 136  : //	return	FloatToInt32(NRANDPOS * 2.9999f);
; 137  : 	int	x= (int)GenerateFastRandom()&0x03;

	call	?GenerateFastRandom@@YAJXZ		; GenerateFastRandom
	and	eax, 3
	mov	DWORD PTR _x$[ebp], eax

; 138  : 	return((x<3)?x:x-3);

	cmp	DWORD PTR _x$[ebp], 3
	jge	SHORT $LN3@PRANDInt3
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@PRANDInt3
$LN3@PRANDInt3:
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv68[ebp], ecx
$LN4@PRANDInt3:
	mov	eax, DWORD PTR tv68[ebp]

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PRANDInt3@@YAHXZ ENDP					; PRANDInt3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\fakerand.h
;	COMDAT ?GenerateFastRandom@@YAJXZ
_TEXT	SEGMENT
_FastRandom$ = -4					; size = 4
?GenerateFastRandom@@YAJXZ PROC				; GenerateFastRandom, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  : 	static long LastRandom;
; 110  : 	long	FastRandom;														// The Random Variable
; 111  : 	_asm {	
; 112  : 			push	edx

	push	edx

; 113  : 			push	eax

	push	eax

; 114  : 			RDTSC

	rdtsc

; 115  : 			add	DWORD PTR FastRandom,edx

	add	DWORD PTR _FastRandom$[ebp], edx

; 116  : 			xor	DWORD PTR FastRandom,eax

	xor	DWORD PTR _FastRandom$[ebp], eax

; 117  : 			mov	eax, DWORD PTR LastRandom

	mov	eax, DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA ; `GenerateFastRandom'::`2'::LastRandom

; 118  : 			add	DWORD PTR FastRandom,eax

	add	DWORD PTR _FastRandom$[ebp], eax

; 119  : 			add	DWORD PTR LastRandom,edx

	add	DWORD PTR ?LastRandom@?1??GenerateFastRandom@@YAJXZ@4JA, edx ; `GenerateFastRandom'::`2'::LastRandom

; 120  : 			pop	eax

	pop	eax

; 121  : 			pop	edx

	pop	edx

; 122  : 	}
; 123  : 	return(FastRandom);

	mov	eax, DWORD PTR _FastRandom$[ebp]

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateFastRandom@@YAJXZ ENDP				; GenerateFastRandom
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?MotionOn@SimulationDriver@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MotionOn@SimulationDriver@@QAEHXZ PROC			; SimulationDriver::MotionOn, COMDAT
; _this$ = ecx

; 98   : 	int MotionOn(void) {return motionOn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+352]
	mov	esp, ebp
	pop	ebp
	ret	0
?MotionOn@SimulationDriver@@QAEHXZ ENDP			; SimulationDriver::MotionOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ PROC ; CampBaseClass::GetComponents, COMDAT
; _this$ = ecx

; 141  : 	TailInsertList *GetComponents() const		{	return components; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ENDP ; CampBaseClass::GetComponents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\mavdisp.h
;	COMDAT ?SetSeekerPos@MaverickDisplayClass@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_az$ = 8						; size = 4
_el$ = 12						; size = 4
?SetSeekerPos@MaverickDisplayClass@@QAEXMM@Z PROC	; MaverickDisplayClass::SetSeekerPos, COMDAT
; _this$ = ecx

; 31   :       void SetSeekerPos (float az, float el) { seekerAz = az; seekerEl = el; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [eax+52], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [ecx+56], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSeekerPos@MaverickDisplayClass@@QAEXMM@Z ENDP	; MaverickDisplayClass::SetSeekerPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?IsMover@SimMoverClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMover@SimMoverClass@@UAEHXZ PROC			; SimMoverClass::IsMover, COMDAT
; _this$ = ecx

; 145  : 	virtual int IsMover (void) {return TRUE;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@SimMoverClass@@UAEHXZ ENDP			; SimMoverClass::IsMover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?WeaponKeepAlive@SimMoverClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?WeaponKeepAlive@SimMoverClass@@UAEXXZ PROC		; SimMoverClass::WeaponKeepAlive, COMDAT
; _this$ = ecx

; 109  : 	virtual void WeaponKeepAlive() { return; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?WeaponKeepAlive@SimMoverClass@@UAEXXZ ENDP		; SimMoverClass::WeaponKeepAlive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simmover.h
;	COMDAT ?SetLead@SimMoverClass@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLead@SimMoverClass@@UAEXH@Z PROC			; SimMoverClass::SetLead, COMDAT
; _this$ = ecx

; 87   : 	virtual void SetLead (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLead@SimMoverClass@@UAEXH@Z ENDP			; SimMoverClass::SetLead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC	; VuBin<FalconEntity>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP	; VuBin<FalconEntity>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VFalconEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VFalconEntity@@@@QBE_NXZ PROC		; VuBin<FalconEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VFalconEntity@@@@QBE_NXZ ENDP		; VuBin<FalconEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??7?$VuBin@VFalconEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??7?$VuBin@VFalconEntity@@@@QBE_NXZ PROC		; VuBin<FalconEntity>::operator!, COMDAT
; _this$ = ecx

; 37   : 	bool operator!() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 		return e == NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 39   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??7?$VuBin@VFalconEntity@@@@QBE_NXZ ENDP		; VuBin<FalconEntity>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?Mass@SimBaseClass@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Mass@SimBaseClass@@UAEMXZ PROC				; SimBaseClass::Mass, COMDAT
; _this$ = ecx

; 267  : 	virtual float Mass(void)		{return 2500.0F;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@451c4000
	mov	esp, ebp
	pop	ebp
	ret	0
?Mass@SimBaseClass@@UAEMXZ ENDP				; SimBaseClass::Mass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?Regenerate@SimBaseClass@@UAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?Regenerate@SimBaseClass@@UAEXMMMM@Z PROC		; SimBaseClass::Regenerate, COMDAT
; _this$ = ecx

; 261  : 	virtual void Regenerate(float, float, float, float) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Regenerate@SimBaseClass@@UAEXMMMM@Z ENDP		; SimBaseClass::Regenerate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?ConfigurePlayerAvionics@SimBaseClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ConfigurePlayerAvionics@SimBaseClass@@UAEXXZ PROC	; SimBaseClass::ConfigurePlayerAvionics, COMDAT
; _this$ = ecx

; 259  : 	virtual void ConfigurePlayerAvionics() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ConfigurePlayerAvionics@SimBaseClass@@UAEXXZ ENDP	; SimBaseClass::ConfigurePlayerAvionics
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?MakeNonPlayerVehicle@SimBaseClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MakeNonPlayerVehicle@SimBaseClass@@UAEXXZ PROC		; SimBaseClass::MakeNonPlayerVehicle, COMDAT
; _this$ = ecx

; 258  : 	virtual void MakeNonPlayerVehicle() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeNonPlayerVehicle@SimBaseClass@@UAEXXZ ENDP		; SimBaseClass::MakeNonPlayerVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?MakePlayerVehicle@SimBaseClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MakePlayerVehicle@SimBaseClass@@UAEXXZ PROC		; SimBaseClass::MakePlayerVehicle, COMDAT
; _this$ = ecx

; 257  : 	virtual void MakePlayerVehicle() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakePlayerVehicle@SimBaseClass@@UAEXXZ ENDP		; SimBaseClass::MakePlayerVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?PowerOutput@SimBaseClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PowerOutput@SimBaseClass@@QAEMXZ PROC			; SimBaseClass::PowerOutput, COMDAT
; _this$ = ecx

; 215  : 	float PowerOutput (void) {return specialData.powerOutput;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+188]
	mov	esp, ebp
	pop	ebp
	ret	0
?PowerOutput@SimBaseClass@@QAEMXZ ENDP			; SimBaseClass::PowerOutput
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsAwake@SimBaseClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAwake@SimBaseClass@@QBEHXZ PROC			; SimBaseClass::IsAwake, COMDAT
; _this$ = ecx

; 177  : 	int IsAwake() const { return localFlags & OBJ_AWAKE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+284]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAwake@SimBaseClass@@QBEHXZ ENDP			; SimBaseClass::IsAwake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsDead@SimBaseClass@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -1						; size = 1
?IsDead@SimBaseClass@@UBEHXZ PROC			; SimBaseClass::IsDead, COMDAT
; _this$ = ecx

; 174  : 	virtual int IsDead() const { return (specialData.flags & OBJ_DEAD ? true : false); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 32					; 00000020H
	je	SHORT $LN3@IsDead
	mov	BYTE PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsDead
$LN3@IsDead:
	mov	BYTE PTR tv68[ebp], 0
$LN4@IsDead:
	movzx	eax, BYTE PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@SimBaseClass@@UBEHXZ ENDP			; SimBaseClass::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsExploding@SimBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsExploding@SimBaseClass@@UAEHXZ PROC			; SimBaseClass::IsExploding, COMDAT
; _this$ = ecx

; 173  : 	virtual int IsExploding () { return (specialData.flags & OBJ_EXPLODING ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 16					; 00000010H
	je	SHORT $LN3@IsExplodin
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsExplodin
$LN3@IsExplodin:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsExplodin:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExploding@SimBaseClass@@UAEHXZ ENDP			; SimBaseClass::IsExploding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?OnGround@SimBaseClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?OnGround@SimBaseClass@@UAEHXZ PROC			; SimBaseClass::OnGround, COMDAT
; _this$ = ecx

; 172  : 	virtual int OnGround () { return (specialData.flags & ON_GROUND ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, 128				; 00000080H
	je	SHORT $LN3@OnGround
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@OnGround
$LN3@OnGround:
	mov	DWORD PTR tv68[ebp], 0
$LN4@OnGround:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGround@SimBaseClass@@UAEHXZ ENDP			; SimBaseClass::OnGround
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCountry@SimBaseClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCountry@SimBaseClass@@UAEEXZ PROC			; SimBaseClass::GetCountry, COMDAT
; _this$ = ecx

; 157  : 	virtual uchar GetCountry() { return (uchar)specialData.country; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+180]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCountry@SimBaseClass@@UAEEXZ ENDP			; SimBaseClass::GetCountry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetSlot@SimBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSlot@SimBaseClass@@QAEHXZ PROC			; SimBaseClass::GetSlot, COMDAT
; _this$ = ecx

; 155  : 	int GetSlot () { return slotNumber;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+236]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSlot@SimBaseClass@@QAEHXZ ENDP			; SimBaseClass::GetSlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSimBase@SimBaseClass@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSimBase@SimBaseClass@@UAE_NXZ PROC			; SimBaseClass::IsSimBase, COMDAT
; _this$ = ecx

; 152  : 	virtual bool IsSimBase() { return true; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSimBase@SimBaseClass@@UAE_NXZ ENDP			; SimBaseClass::IsSimBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?JoinFlight@SimBaseClass@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?JoinFlight@SimBaseClass@@UAEXXZ PROC			; SimBaseClass::JoinFlight, COMDAT
; _this$ = ecx

; 139  : 	virtual void JoinFlight (void) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?JoinFlight@SimBaseClass@@UAEXXZ ENDP			; SimBaseClass::JoinFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\geometry.h
;	COMDAT ??1ObjectGeometry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ObjectGeometry@@QAE@XZ PROC				; ObjectGeometry::~ObjectGeometry, COMDAT
; _this$ = ecx

; 26   : 	~ObjectGeometry(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1ObjectGeometry@@QAE@XZ ENDP				; ObjectGeometry::~ObjectGeometry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\geometry.h
;	COMDAT ??0ObjectGeometry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ObjectGeometry@@QAE@XZ PROC				; ObjectGeometry::ObjectGeometry, COMDAT
; _this$ = ecx

; 25   : 	ObjectGeometry(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ObjectGeometry@@QAE@XZ ENDP				; ObjectGeometry::ObjectGeometry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SeekerEl@SensorClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SeekerEl@SensorClass@@QAEMXZ PROC			; SensorClass::SeekerEl, COMDAT
; _this$ = ecx

; 57   : 	float			SeekerEl(void)							{ return seekerElCenter; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?SeekerEl@SensorClass@@QAEMXZ ENDP			; SensorClass::SeekerEl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?SeekerAz@SensorClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SeekerAz@SensorClass@@QAEMXZ PROC			; SensorClass::SeekerAz, COMDAT
; _this$ = ecx

; 56   : 	float			SeekerAz(void)                          { return seekerAzCenter; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?SeekerAz@SensorClass@@QAEMXZ ENDP			; SensorClass::SeekerAz
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?Type@SensorClass@@QAE?AW4SensorType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@SensorClass@@QAE?AW4SensorType@1@XZ PROC		; SensorClass::Type, COMDAT
; _this$ = ecx

; 36   : 	SensorType	Type(void)			{ return sensorType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@SensorClass@@QAE?AW4SensorType@1@XZ ENDP		; SensorClass::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetSEARCHtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSEARCHtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetSEARCHtimer, COMDAT
; _this$ = ecx

; 198  : 	virtual VU_TIME GetSEARCHtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSEARCHtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetAQUIREtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAQUIREtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetAQUIREtimer, COMDAT
; _this$ = ecx

; 197  : 	virtual VU_TIME GetAQUIREtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAQUIREtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetStepSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetStepSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetStepSearchMode, COMDAT
; _this$ = ecx

; 196  : 	virtual void SetStepSearchMode(uchar)					{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStepSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetStepSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSEARCHtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetSEARCHtimer, COMDAT
; _this$ = ecx

; 194  : 	virtual void SetSEARCHtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetAQUIREtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetAQUIREtimer, COMDAT
; _this$ = ecx

; 193  : 	virtual void SetAQUIREtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetIRFactor@FalconEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIRFactor@FalconEntity@@UAEMXZ PROC			; FalconEntity::GetIRFactor, COMDAT
; _this$ = ecx

; 164  : 	virtual float GetIRFactor (void)			{ return 0.0f; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fldz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIRFactor@FalconEntity@@UAEMXZ ENDP			; FalconEntity::GetIRFactor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRCSFactor@FalconEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRCSFactor@FalconEntity@@UAEMXZ PROC			; FalconEntity::GetRCSFactor, COMDAT
; _this$ = ecx

; 163  : 	virtual float GetRCSFactor (void)			{ return 0.0f; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fldz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRCSFactor@FalconEntity@@UAEMXZ ENDP			; FalconEntity::GetRCSFactor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTaskForce@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTaskForce@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTaskForce, COMDAT
; _this$ = ecx

; 158  : 	virtual int IsTaskForce (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTaskForce@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTaskForce
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTeam@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeam@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTeam, COMDAT
; _this$ = ecx

; 157  : 	virtual int IsTeam (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeam@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPackage@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPackage@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsPackage, COMDAT
; _this$ = ecx

; 156  : 	virtual int IsPackage (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPackage@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSquadron@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSquadron@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSquadron, COMDAT
; _this$ = ecx

; 155  : 	virtual int IsSquadron (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSquadron@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsFlight@FalconEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlight@FalconEntity@@UBEHXZ PROC			; FalconEntity::IsFlight, COMDAT
; _this$ = ecx

; 154  : 	virtual int IsFlight() const				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlight@FalconEntity@@UBEHXZ ENDP			; FalconEntity::IsFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBrigade@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrigade@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBrigade, COMDAT
; _this$ = ecx

; 153  : 	virtual int IsBrigade (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrigade@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBrigade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBattalion@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBattalion@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBattalion, COMDAT
; _this$ = ecx

; 152  : 	virtual int IsBattalion (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBattalion@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBattalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsObjective@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjective@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsObjective, COMDAT
; _this$ = ecx

; 151  : 	virtual int IsObjective (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsObjective@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsUnit@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnit@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsUnit, COMDAT
; _this$ = ecx

; 150  : 	virtual int IsUnit (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnit@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEmitting@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEmitting, COMDAT
; _this$ = ecx

; 145  : 	virtual int IsEmitting (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsDead@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsDead, COMDAT
; _this$ = ecx

; 144  : 	virtual int IsDead (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsShip@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShip@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsShip, COMDAT
; _this$ = ecx

; 141  : 	virtual int IsShip (void) 			        { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShip@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGroundVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGroundVehicle@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsGroundVehicle, COMDAT
; _this$ = ecx

; 140  : 	virtual int IsGroundVehicle (void) 			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGroundVehicle@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsGroundVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAirplane@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirplane@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsAirplane, COMDAT
; _this$ = ecx

; 139  : 	virtual int IsAirplane (void)	   			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirplane@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsAirplane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEject@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEject@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEject, COMDAT
; _this$ = ecx

; 138  : 	virtual int IsEject (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEject@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsHelicopter@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHelicopter@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsHelicopter, COMDAT
; _this$ = ecx

; 137  : 	virtual int IsHelicopter (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHelicopter@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsHelicopter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsStatic@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStatic@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsStatic, COMDAT
; _this$ = ecx

; 136  : 	virtual int IsStatic (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStatic@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsStatic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsVehicle@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsVehicle, COMDAT
; _this$ = ecx

; 135  : 	virtual int IsVehicle (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVehicle@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGun@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGun@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsGun, COMDAT
; _this$ = ecx

; 133  : 	virtual int IsGun (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGun@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBomb@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBomb@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBomb, COMDAT
; _this$ = ecx

; 132  : 	virtual int IsBomb (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBomb@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsLauncher@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsLauncher, COMDAT
; _this$ = ecx

; 131  : 	virtual int IsLauncher (void)               { return FALSE; } // MLR 3/4/2004 - rocket pods

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_e$ = 8							; size = 4
?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z PROC	; FalconEntity::HasEntity, COMDAT
; _this$ = ecx

; 129  : 	virtual int HasEntity(VuEntity *e) const    { return this == e; } // sfr: added for new driver

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR _e$[ebp]
	jne	SHORT $LN3@HasEntity
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@HasEntity
$LN3@HasEntity:
	mov	DWORD PTR tv69[ebp], 0
$LN4@HasEntity:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z ENDP	; FalconEntity::HasEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?CombatClass@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatClass@FalconEntity@@UAEHXZ PROC			; FalconEntity::CombatClass, COMDAT
; _this$ = ecx

; 127  : 	virtual int CombatClass (void)				{ return 999; } // 2002-02-25 ADDED BY S.G. No combat class for non flight or non aircraft class

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 999				; 000003e7H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatClass@FalconEntity@@UAEHXZ ENDP			; FalconEntity::CombatClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetSearchMode, COMDAT
; _this$ = ecx

; 126  : 	virtual void SetSearchMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?ReturnToSearch@FalconEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReturnToSearch@FalconEntity@@UAEXXZ PROC		; FalconEntity::ReturnToSearch, COMDAT
; _this$ = ecx

; 124  : 	virtual void ReturnToSearch (void)			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReturnToSearch@FalconEntity@@UAEXXZ ENDP		; FalconEntity::ReturnToSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetRadarMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetRadarMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetRadarMode, COMDAT
; _this$ = ecx

; 123  : 	virtual void SetRadarMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRadarMode@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@FalconEntity@@UAEHXZ PROC			; FalconEntity::GetRadarMode, COMDAT
; _this$ = ecx

; 121  : 	virtual int GetRadarMode (void)				{ return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@FalconEntity@@UAEHXZ ENDP			; FalconEntity::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampaign@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsCampaign@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsCampaign, COMDAT
; _this$ = ecx

; 101  : 		{return (falconType & FalconCampaignEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 1
	je	SHORT $LN3@IsCampaign
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsCampaign
$LN3@IsCampaign:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsCampaign:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampaign@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCampBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsCampBase, COMDAT
; _this$ = ecx

; 99   : 	virtual bool IsCampBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsCampBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestOutOfBandTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestOutOfBandTransmit@VuMessage@@QAEXXZ PROC	; VuMessage::RequestOutOfBandTransmit, COMDAT
; _this$ = ecx

; 181  : 	void RequestOutOfBandTransmit() { flags_ |= VU_OUT_OF_BAND_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestOutOfBandTransmit@VuMessage@@QAEXXZ ENDP	; VuMessage::RequestOutOfBandTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestReliableTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestReliableTransmit@VuMessage@@QAEXXZ PROC		; VuMessage::RequestReliableTransmit, COMDAT
; _this$ = ecx

; 180  : 	void RequestReliableTransmit() { flags_ |= VU_RELIABLE_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestReliableTransmit@VuMessage@@QAEXXZ ENDP		; VuMessage::RequestReliableTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZDelta@VuEntity@@QBEMXZ PROC				; VuEntity::ZDelta, COMDAT
; _this$ = ecx

; 163  : 	SM_SCALAR ZDelta() const { return pos_.dz_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::ZDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPRDelta@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dyaw$ = 8						; size = 4
_dpitch$ = 12						; size = 4
_droll$ = 16						; size = 4
?SetYPRDelta@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPRDelta, COMDAT
; _this$ = ecx

; 116  : 	void SetYPRDelta(SM_SCALAR dyaw, SM_SCALAR dpitch,SM_SCALAR droll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		orient_.dyaw_ = dyaw; orient_.dpitch_ = dpitch; orient_.droll_=droll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dyaw$[ebp]
	movss	DWORD PTR [eax+72], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dpitch$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _droll$[ebp]
	movss	DWORD PTR [edx+80], xmm0

; 118  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPRDelta@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPRDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPR@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?SetYPR@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPR, COMDAT
; _this$ = ecx

; 113  : 	void SetYPR(SM_SCALAR yaw, SM_SCALAR pitch, SM_SCALAR roll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 115  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPR@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?GetNumSwitches@DrawableBSP@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumSwitches@DrawableBSP@@QAEHXZ PROC		; DrawableBSP::GetNumSwitches, COMDAT
; _this$ = ecx

; 37   : 	int	GetNumSwitches( void )			{ return instance.ParentObject->nSwitches; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	movsx	eax, WORD PTR [ecx+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumSwitches@DrawableBSP@@QAEHXZ ENDP		; DrawableBSP::GetNumSwitches
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z PROC	; DrawableObject::GetPosition, COMDAT
; _this$ = ecx

; 28   : 	void GetPosition(Tpoint* pos){ *pos = position; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ENDP	; DrawableObject::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?tan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?tan@@YAMM@Z PROC					; tan, COMDAT

; 543  :         {return (tanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_tanf
	add	esp, 4
	pop	ebp
	ret	0
?tan@@YAMM@Z ENDP					; tan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
