; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\GROUND\gndai.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?SquadFormations@@3PAY02UAIOffsetType@@A	; SquadFormations
PUBLIC	?PlatoonFormations@@3PAY03UAIOffsetType@@A	; PlatoonFormations
PUBLIC	?CompanyFormations@@3PAY03UAIOffsetType@@A	; CompanyFormations
PUBLIC	?FormationRandomness@@3PAUAIOffsetType@@A	; FormationRandomness
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?BattalionHeir@@3PAUBattalionInitType@@A	; BattalionHeir
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
_DATA	SEGMENT
?SquadFormations@@3PAY02UAIOffsetType@@A DD 000000000r ; 0 ; SquadFormations
	DD	000000000r			; 0
	DD	0c2c80000r			; -100
	DD	0c2c80000r			; -100
	DD	042c80000r			; 100
	DD	0c2c80000r			; -100
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	0c2c80000r			; -100
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	0c2480000r			; -50
	DD	042480000r			; 50
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	0c2c80000r			; -100
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	0c2480000r			; -50
	DD	042480000r			; 50
	DD	0c2480000r			; -50
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042480000r			; 50
	DD	0c2480000r			; -50
	DD	042c80000r			; 100
	DD	0c2c80000r			; -100
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042480000r			; 50
	DD	000000000r			; 0
	DD	0c2480000r			; -50
	DD	000000000r			; 0
?PlatoonFormations@@3PAY03UAIOffsetType@@A DD 000000000r ; 0 ; PlatoonFormations
	DD	000000000r			; 0
	DD	0c3960000r			; -300
	DD	0c3960000r			; -300
	DD	043960000r			; 300
	DD	0c3960000r			; -300
	DD	000000000r			; 0
	DD	0c4160000r			; -600
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	000000000r			; 0
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	0c43b8000r			; -750
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	0c37a0000r			; -250
	DD	0437a0000r			; 250
	DD	0c37a0000r			; -250
	DD	043fa0000r			; 500
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2fa0000r			; -125
	DD	0c37a0000r			; -250
	DD	042fa0000r			; 125
	DD	0c37a0000r			; -250
	DD	000000000r			; 0
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	0c37a0000r			; -250
	DD	0437a0000r			; 250
	DD	0c37a0000r			; -250
	DD	043fa0000r			; 500
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0437a0000r			; 250
	DD	0c37a0000r			; -250
	DD	043fa0000r			; 500
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c37a0000r			; -250
	DD	000000000r			; 0
	DD	0437a0000r			; 250
	DD	000000000r			; 0
	DD	043fa0000r			; 500
	DD	000000000r			; 0
?CompanyFormations@@3PAY03UAIOffsetType@@A DD 000000000r ; 0 ; CompanyFormations
	DD	000000000r			; 0
	DD	0c47a0000r			; -1000
	DD	0c47a0000r			; -1000
	DD	0447a0000r			; 1000
	DD	0c47a0000r			; -1000
	DD	000000000r			; 0
	DD	0c4fa0000r			; -2000
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c47a0000r			; -1000
	DD	000000000r			; 0
	DD	0c4fa0000r			; -2000
	DD	000000000r			; 0
	DD	0c53b8000r			; -3000
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c47a0000r			; -1000
	DD	0c47a0000r			; -1000
	DD	0447a0000r			; 1000
	DD	0c47a0000r			; -1000
	DD	044fa0000r			; 2000
	DD	0c4fa0000r			; -2000
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c3fa0000r			; -500
	DD	0c47a0000r			; -1000
	DD	043fa0000r			; 500
	DD	0c47a0000r			; -1000
	DD	000000000r			; 0
	DD	0c4fa0000r			; -2000
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c47a0000r			; -1000
	DD	0c47a0000r			; -1000
	DD	0447a0000r			; 1000
	DD	0c47a0000r			; -1000
	DD	044fa0000r			; 2000
	DD	0c4fa0000r			; -2000
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0447a0000r			; 1000
	DD	0c47a0000r			; -1000
	DD	044fa0000r			; 2000
	DD	0c3fa0000r			; -500
	DD	000000000r			; 0
	DD	0c4fa0000r			; -2000
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c47a0000r			; -1000
	DD	000000000r			; 0
	DD	0447a0000r			; 1000
	DD	000000000r			; 0
	DD	044fa0000r			; 2000
	DD	000000000r			; 0
?FormationRandomness@@3PAUAIOffsetType@@A DD 041c80000r ; 25 ; FormationRandomness
	DD	041c80000r			; 25
	DD	040f00000r			; 7.5
	DD	040a00000r			; 5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	041480000r			; 12.5
	DD	040a00000r			; 5
	DD	042480000r			; 50
?BattalionHeir@@3PAUBattalionInitType@@A DD 0ffffffffH	; BattalionHeir
	DD	0fH
	DD	00H
	DD	00H
	DD	08H
	DD	01H
	DD	00H
	DD	08H
	DD	02H
	DD	00H
	DD	0cH
	DD	01H
	DD	03H
	DD	08H
	DD	01H
	DD	03H
	DD	08H
	DD	02H
	DD	00H
	DD	0cH
	DD	02H
	DD	06H
	DD	08H
	DD	01H
	DD	06H
	DD	08H
	DD	02H
	DD	00H
	DD	0cH
	DD	03H
	DD	09H
	DD	08H
	DD	01H
	DD	09H
	DD	08H
	DD	02H
	DD	00H
	DD	0eH
	DD	01H
	DD	0cH
	DD	08H
	DD	01H
	DD	0cH
	DD	08H
	DD	02H
	DD	0cH
	DD	0cH
	DD	01H
	DD	0fH
	DD	08H
	DD	01H
	DD	0fH
	DD	08H
	DD	02H
	DD	0cH
	DD	0cH
	DD	02H
	DD	012H
	DD	08H
	DD	01H
	DD	012H
	DD	08H
	DD	02H
	DD	0cH
	DD	0cH
	DD	03H
	DD	015H
	DD	08H
	DD	01H
	DD	015H
	DD	08H
	DD	02H
	DD	00H
	DD	0eH
	DD	02H
	DD	018H
	DD	08H
	DD	01H
	DD	018H
	DD	08H
	DD	02H
	DD	018H
	DD	0cH
	DD	01H
	DD	01bH
	DD	08H
	DD	01H
	DD	01bH
	DD	08H
	DD	02H
	DD	018H
	DD	0cH
	DD	02H
	DD	01eH
	DD	08H
	DD	01H
	DD	01eH
	DD	08H
	DD	02H
	DD	018H
	DD	0cH
	DD	03H
	DD	021H
	DD	08H
	DD	01H
	DD	021H
	DD	08H
	DD	02H
	DD	00H
	DD	0eH
	DD	03H
	DD	024H
	DD	08H
	DD	01H
	DD	024H
	DD	08H
	DD	02H
	DD	024H
	DD	0cH
	DD	01H
	DD	027H
	DD	08H
	DD	01H
	DD	027H
	DD	08H
	DD	02H
	DD	024H
	DD	0cH
	DD	02H
	DD	02aH
	DD	08H
	DD	01H
	DD	02aH
	DD	08H
	DD	02H
	DD	024H
	DD	0cH
	DD	03H
	DD	02dH
	DD	08H
	DD	01H
	DD	02dH
	DD	08H
	DD	02H
_DATA	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
CONST	SEGMENT
_NEAR_CLIP DD	03f800000r			; 1
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?SetYPR@VuEntity@@QAEXMMM@Z			; VuEntity::SetYPR
PUBLIC	?SetYPRDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPRDelta
PUBLIC	?Type@VuEntity@@QBEGXZ				; VuEntity::Type
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsCampaign@FalconEntity@@QAEHXZ		; FalconEntity::IsCampaign
PUBLIC	?IsSim@FalconEntity@@QAEHXZ			; FalconEntity::IsSim
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
PUBLIC	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ	; SimObjectType::BaseData
PUBLIC	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?GetNextWP@WayPointClass@@QAEPAV1@XZ		; WayPointClass::GetNextWP
PUBLIC	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
PUBLIC	?IsAggregate@CampBaseClass@@QAEHXZ		; CampBaseClass::IsAggregate
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?UnsetChecked@CampBaseClass@@QAEXXZ		; CampBaseClass::UnsetChecked
PUBLIC	?RunningTactical@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningTactical
PUBLIC	?RunningCampaign@SimulationDriver@@QBE_NXZ	; SimulationDriver::RunningCampaign
PUBLIC	?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaignOrTactical
PUBLIC	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z		; TViewPoint::GetPos
PUBLIC	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ	; UnitClass::GetTarget
PUBLIC	??0GNDAIClass@@QAE@PAVGroundClass@@PAV0@FHH@Z	; GNDAIClass::GNDAIClass
PUBLIC	??1GNDAIClass@@QAE@XZ				; GNDAIClass::~GNDAIClass
PUBLIC	?Process@GNDAIClass@@QAEXXZ			; GNDAIClass::Process
PUBLIC	?ProcessTargeting@GNDAIClass@@QAEXXZ		; GNDAIClass::ProcessTargeting
PUBLIC	?SetLeader@GNDAIClass@@QAEXPAV1@@Z		; GNDAIClass::SetLeader
PUBLIC	?Order_Battalion@GNDAIClass@@QAEXXZ		; GNDAIClass::Order_Battalion
PUBLIC	?Order_Company@GNDAIClass@@QAEXXZ		; GNDAIClass::Order_Company
PUBLIC	?Order_Platoon@GNDAIClass@@QAEXXZ		; GNDAIClass::Order_Platoon
PUBLIC	?Order_Squad@GNDAIClass@@QAEXXZ			; GNDAIClass::Order_Squad
PUBLIC	?CheckThrough@GNDAIClass@@QAEHXZ		; GNDAIClass::CheckThrough
PUBLIC	?SetGroundTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetGroundTarget
PUBLIC	?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetAirTarget
PUBLIC	?PromoteSubordinates@GNDAIClass@@QAEXXZ		; GNDAIClass::PromoteSubordinates
PUBLIC	?SetDistLOD@GNDAIClass@@QAEXXZ			; GNDAIClass::SetDistLOD
PUBLIC	?Move_Towards_Dest@GNDAIClass@@QAEXXZ		; GNDAIClass::Move_Towards_Dest
PUBLIC	?LabelColor@DrawableBSP@@QAEKXZ			; DrawableBSP::LabelColor
PUBLIC	?SetFlag@RadarClass@@QAEXW4RadarFlag@1@@Z	; RadarClass::SetFlag
PUBLIC	?AdjustOffset@@YAXMMPAM0MM@Z			; AdjustOffset
PUBLIC	?AdjustOffset@@YAXMPAM0MM@Z			; AdjustOffset
PUBLIC	?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z ; NewGroundAI
PUBLIC	?FindVehiclePosition@@YAXPAVSimInitDataClass@@@Z ; FindVehiclePosition
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_03MPPIHBHJ@OFF?$AA@			; `string'
PUBLIC	??_C@_06ILIGGHLH@Detect?$AA@			; `string'
PUBLIC	??_C@_05BFDCPAGB@Track?$AA@			; `string'
PUBLIC	??_C@_05IFJIKCNG@?5S100?$AA@			; `string'
PUBLIC	??_C@_03NGCOBIIG@?5S1?$AA@			; `string'
PUBLIC	??_C@_03PNADELEF@?5S2?$AA@			; `string'
PUBLIC	??_C@_03OEBIHKAE@?5S3?$AA@			; `string'
PUBLIC	??_C@_06JPDLAIOB@?5Guide?$AA@			; `string'
PUBLIC	??_C@_08DMPDNHHH@?5Acquire?$AA@			; `string'
PUBLIC	??_C@_0M@NMGDLKFJ@?5Changemode?$AA@		; `string'
PUBLIC	??_C@_04OJFPHGHM@?5OFF?$AA@			; `string'
PUBLIC	??_C@_03HDKIMHPH@?5?$CFf?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3c8efa34
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f400000
PUBLIC	__real@3f693e32
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40200000
PUBLIC	__real@40490fd9
PUBLIC	__real@40490fdb
PUBLIC	__real@40c90fdb
PUBLIC	__real@41a00000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@454cffae
PUBLIC	__real@4dbebc20
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0490fdb
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_atan:PROC
EXTRN	_fabs:PROC
EXTRN	_sprintf:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?F4IsBadCodePtr@@YA_NPAX@Z:PROC			; F4IsBadCodePtr
EXTRN	?F4IsBadWritePtr@@YA_NPAXI@Z:PROC		; F4IsBadWritePtr
EXTRN	?SetDelta@VuEntity@@QAEXMMM@Z:PROC		; VuEntity::SetDelta
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z:PROC ; VuSessionsIterator::VuSessionsIterator
EXTRN	??1VuSessionsIterator@@UAE@XZ:PROC		; VuSessionsIterator::~VuSessionsIterator
EXTRN	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetFirst
EXTRN	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetNext
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?CalcRelAzElRangeAta@@YAXPAVSimBaseClass@@PAVSimObjectType@@@Z:PROC ; CalcRelAzElRangeAta
EXTRN	?CalcRelGeom@@YAXPAVSimBaseClass@@PAVSimObjectType@@QAY02MM@Z:PROC ; CalcRelGeom
EXTRN	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ:PROC ; OTWDriverClass::GetViewpoint
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	??0SimObjectType@@QAE@PAVFalconEntity@@@Z:PROC	; SimObjectType::SimObjectType
EXTRN	?Reference@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Reference
EXTRN	?Release@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Release
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z:PROC ; SimMoverClass::SetTarget
EXTRN	?GetCover@@YA?AW4CoverType@@FF@Z:PROC		; GetCover
EXTRN	?GetLocation@WayPointClass@@QBEXPAM00@Z:PROC	; WayPointClass::GetLocation
EXTRN	?SetSpotted@CampBaseClass@@QAEXEKH@Z:PROC	; CampBaseClass::SetSpotted
EXTRN	?SetLastCheck@UnitClass@@QAEXK@Z:PROC		; UnitClass::SetLastCheck
EXTRN	?GetCruiseSpeed@UnitClass@@QBEHXZ:PROC		; UnitClass::GetCruiseSpeed
EXTRN	?GetUnitFormation@UnitClass@@QBEHXZ:PROC	; UnitClass::GetUnitFormation
EXTRN	?SimCampHandoff@@YAPAVSimObjectType@@PAV1@0W4HandOffType@@@Z:PROC ; SimCampHandoff
EXTRN	?SelectWeapon@GroundClass@@QAEXH@Z:PROC		; GroundClass::SelectWeapon
EXTRN	?GetRoE@@YAHEEH@Z:PROC				; GetRoE
EXTRN	?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z:PROC ; Detected
EXTRN	?GetObjectiveByXY@@YAPAVObjectiveClass@@FF@Z:PROC ; GetObjectiveByXY
EXTRN	?GridToSim@@YAMF@Z:PROC				; GridToSim
EXTRN	?SetLabel@@YAXPAVSimBaseClass@@@Z:PROC		; SetLabel
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?SimLibMajorFrameTime@@3MA:DWORD		; SimLibMajorFrameTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?dx@@3PAFA:BYTE					; dx
EXTRN	?dy@@3PAFA:BYTE					; dy
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?g_nlookAroundWaterTiles@@3HA:DWORD		; g_nlookAroundWaterTiles
EXTRN	?g_bFireOntheMove@@3_NA:BYTE			; g_bFireOntheMove
EXTRN	?g_nShowDebugLabels@@3HA:DWORD			; g_nShowDebugLabels
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_simb	DD	030H DUP (?)
_batCmdr DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@4dbebc20
CONST	SEGMENT
__real@4dbebc20 DD 04dbebc20r			; 4e+008
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40490fd9
CONST	SEGMENT
__real@40490fd9 DD 040490fd9r			; 3.14159
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f693e32
CONST	SEGMENT
__real@3f693e32 DD 03f693e32r			; 0.911105
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03HDKIMHPH@?5?$CFf?$AA@
CONST	SEGMENT
??_C@_03HDKIMHPH@?5?$CFf?$AA@ DB ' %f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OJFPHGHM@?5OFF?$AA@
CONST	SEGMENT
??_C@_04OJFPHGHM@?5OFF?$AA@ DB ' OFF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMGDLKFJ@?5Changemode?$AA@
CONST	SEGMENT
??_C@_0M@NMGDLKFJ@?5Changemode?$AA@ DB ' Changemode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMPDNHHH@?5Acquire?$AA@
CONST	SEGMENT
??_C@_08DMPDNHHH@?5Acquire?$AA@ DB ' Acquire', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JPDLAIOB@?5Guide?$AA@
CONST	SEGMENT
??_C@_06JPDLAIOB@?5Guide?$AA@ DB ' Guide', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEBIHKAE@?5S3?$AA@
CONST	SEGMENT
??_C@_03OEBIHKAE@?5S3?$AA@ DB ' S3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNADELEF@?5S2?$AA@
CONST	SEGMENT
??_C@_03PNADELEF@?5S2?$AA@ DB ' S2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NGCOBIIG@?5S1?$AA@
CONST	SEGMENT
??_C@_03NGCOBIIG@?5S1?$AA@ DB ' S1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFJIKCNG@?5S100?$AA@
CONST	SEGMENT
??_C@_05IFJIKCNG@?5S100?$AA@ DB ' S100', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFDCPAGB@Track?$AA@
CONST	SEGMENT
??_C@_05BFDCPAGB@Track?$AA@ DB 'Track', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ILIGGHLH@Detect?$AA@
CONST	SEGMENT
??_C@_06ILIGGHLH@Detect?$AA@ DB 'Detect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MPPIHBHJ@OFF?$AA@
CONST	SEGMENT
??_C@_03MPPIHBHJ@OFF?$AA@ DB 'OFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z$2
__unwindtable$?PromoteSubordinates@GNDAIClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PromoteSubordinates@GNDAIClass@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PromoteSubordinates@GNDAIClass@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PromoteSubordinates@GNDAIClass@@QAEXXZ$2
__unwindtable$?ProcessTargeting@GNDAIClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$3
__ehfuncinfo$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?PromoteSubordinates@GNDAIClass@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PromoteSubordinates@GNDAIClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ProcessTargeting@GNDAIClass@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ProcessTargeting@GNDAIClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_rx$1 = -28						; size = 4
_ry$2 = -24						; size = 4
_randy$3 = -20						; size = 4
_randx$4 = -16						; size = 4
_cur_leader_idx$ = -12					; size = 4
_formation$ = -8					; size = 4
_position$ = -4						; size = 4
_initData$ = 8						; size = 4
?FindVehiclePosition@@YAXPAVSimInitDataClass@@@Z PROC	; FindVehiclePosition

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1342 : 	// Calculate battalion position (0-47) of this vehicle
; 1343 : 	int		position = initData->campSlot*3 + initData->inSlot;

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 3
	mov	edx, DWORD PTR _initData$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _position$[ebp], ecx

; 1344 : 	int		formation = ((UnitClass*)(initData->campBase))->GetUnitFormation();

	mov	eax, DWORD PTR _initData$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	mov	DWORD PTR _formation$[ebp], eax

; 1345 : 	int		cur_leader_idx;
; 1346 : 
; 1347 : 	// KCK: for now, place in formation (essentially, option 3 without checking for obsticals)
; 1348 : 	cur_leader_idx = BattalionHeir[position].leader_idx;

	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx]
	mov	DWORD PTR _cur_leader_idx$[ebp], edx
$LN5@FindVehicl:

; 1349 : 	while (cur_leader_idx >= 0 && position)

	cmp	DWORD PTR _cur_leader_idx$[ebp], 0
	jl	$LN4@FindVehicl
	cmp	DWORD PTR _position$[ebp], 0
	je	$LN4@FindVehicl

; 1350 : 	{
; 1351 : 		if (BattalionHeir[position].rank == GNDAI_SQUAD_LEADER)

	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax+4], 8
	jne	$LN3@FindVehicl

; 1352 : 		{
; 1353 : 			// Offset from our platoon leader + a random offset based on formation type
; 1354 : 
; 1355 : 			float	rx,ry;
; 1356 : 			int		randx,randy;
; 1357 : 			randx = FloatToInt32(FormationRandomness[formation].x);

	mov	ecx, DWORD PTR _formation$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?FormationRandomness@@3PAUAIOffsetType@@A[ecx*8]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _randx$4[ebp], eax

; 1358 : 			randy = FloatToInt32(FormationRandomness[formation].y);

	mov	edx, DWORD PTR _formation$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR ?FormationRandomness@@3PAUAIOffsetType@@A[edx*8+4]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _randy$3[ebp], eax

; 1359 : 			rx = (float)(rand() % randx) - (randx/2);

	call	_rand
	cdq
	idiv	DWORD PTR _randx$4[ebp]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _randx$4[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	subss	xmm0, xmm1
	movss	DWORD PTR _rx$1[ebp], xmm0

; 1360 : 			ry = (float)(rand() % randy) - (randy/2);

	call	_rand
	cdq
	idiv	DWORD PTR _randy$3[ebp]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _randy$3[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	subss	xmm0, xmm1
	movss	DWORD PTR _ry$2[ebp], xmm0

; 1361 : 
; 1362 : 			AdjustOffset(initData->heading, &initData->x, &initData->y, SquadFormations[formation][BattalionHeir[position].uid].x+rx, SquadFormations[formation][BattalionHeir[position].uid].y+ry);

	mov	eax, DWORD PTR _formation$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx+8]
	movss	xmm0, DWORD PTR ?SquadFormations@@3PAY02UAIOffsetType@@A[eax+edx*8+4]
	addss	xmm0, DWORD PTR _ry$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _formation$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx+8]
	movss	xmm0, DWORD PTR ?SquadFormations@@3PAY02UAIOffsetType@@A[eax+edx*8]
	addss	xmm0, DWORD PTR _rx$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _initData$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _initData$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	edx, DWORD PTR _initData$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+68]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMPAM0MM@Z		; AdjustOffset
	add	esp, 20					; 00000014H
$LN3@FindVehicl:

; 1363 : 
; 1364 : 			//AdjustOffset(initData->heading, &initData->x, &initData->y, SquadFormations[formation][BattalionHeir[position].uid].x, SquadFormations[formation][BattalionHeir[position].uid].y);
; 1365 : 		}
; 1366 : 		if (BattalionHeir[position].rank == GNDAI_PLATOON_COMMANDER)

	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax+4], 12 ; 0000000cH
	jne	SHORT $LN2@FindVehicl

; 1367 : 		{
; 1368 : 			// Offset from our company leader
; 1369 : 			AdjustOffset(initData->heading, &initData->x, &initData->y, PlatoonFormations[formation][BattalionHeir[position].uid].x, PlatoonFormations[formation][BattalionHeir[position].uid].y);

	mov	ecx, DWORD PTR _formation$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _position$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[edx+8]
	push	ecx
	movss	xmm0, DWORD PTR ?PlatoonFormations@@3PAY03UAIOffsetType@@A[ecx+eax*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _formation$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _position$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[edx+8]
	push	ecx
	movss	xmm0, DWORD PTR ?PlatoonFormations@@3PAY03UAIOffsetType@@A[ecx+eax*8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _initData$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	edx, DWORD PTR _initData$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _initData$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+68]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMPAM0MM@Z		; AdjustOffset
	add	esp, 20					; 00000014H
$LN2@FindVehicl:

; 1370 : 		}
; 1371 : 		if (BattalionHeir[position].rank == GNDAI_COMPANY_COMMANDER)

	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	cmp	DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx+4], 14 ; 0000000eH
	jne	SHORT $LN1@FindVehicl

; 1372 : 		{
; 1373 : 			// Offset from our battalion leader
; 1374 : 			AdjustOffset(initData->heading, &initData->x, &initData->y, CompanyFormations[formation][BattalionHeir[position].uid].x, CompanyFormations[formation][BattalionHeir[position].uid].y);

	mov	edx, DWORD PTR _formation$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax+8]
	push	ecx
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[edx+ecx*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _formation$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax+8]
	push	ecx
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[edx+ecx*8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _initData$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	eax, DWORD PTR _initData$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _initData$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+68]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMPAM0MM@Z		; AdjustOffset
	add	esp, 20					; 00000014H
$LN1@FindVehicl:

; 1375 : 		}
; 1376 : 		position = cur_leader_idx;

	mov	edx, DWORD PTR _cur_leader_idx$[ebp]
	mov	DWORD PTR _position$[ebp], edx

; 1377 : 		cur_leader_idx = BattalionHeir[position].leader_idx;

	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax]
	mov	DWORD PTR _cur_leader_idx$[ebp], ecx

; 1378 : 	}

	jmp	$LN5@FindVehicl
$LN4@FindVehicl:

; 1379 : 	initData->z = 0;

	mov	edx, DWORD PTR _initData$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+64], xmm0

; 1380 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindVehiclePosition@@YAXPAVSimInitDataClass@@@Z ENDP	; FindVehiclePosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
$T2 = -52						; size = 4
tv186 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
tv165 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
tv144 = -24						; size = 4
$T7 = -20						; size = 4
_gai$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_us$ = 8						; size = 4
_position$ = 12						; size = 4
_isFirst$ = 16						; size = 4
_skill$ = 20						; size = 4
?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z PROC ; NewGroundAI

; 285  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 286  : 	GNDAIClass	*gai;
; 287  : 
; 288  : 	if (isFirst)

	cmp	DWORD PTR _isFirst$[ebp], 0
	je	SHORT $LN8@NewGroundA

; 289  : 	{
; 290  : 		// Reset our creation data
; 291  : 		memset(simb, 0, sizeof (GNDAIClass*)*48);

	push	192					; 000000c0H
	push	0
	push	OFFSET _simb
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@NewGroundA:

; 292  : 	}
; 293  : 
; 294  : 	if (position)

	cmp	DWORD PTR _position$[ebp], 0
	je	$LN7@NewGroundA
$LN6@NewGroundA:

; 295  : 	{
; 296  : 		// Check if our leader exists -
; 297  : 		//while (position && !simb[BattalionHeir[position].leader_idx]) // JB 010220 CTD
; 298  : 		while (position && BattalionHeir[position].leader_idx >= 0 && !simb[BattalionHeir[position].leader_idx]) // JB 010220 CTD

	cmp	DWORD PTR _position$[ebp], 0
	je	SHORT $LN5@NewGroundA
	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	cmp	DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax], 0
	jl	SHORT $LN5@NewGroundA
	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx]
	cmp	DWORD PTR _simb[edx*4], 0
	jne	SHORT $LN5@NewGroundA

; 299  : 			position = BattalionHeir[position].leader_idx;

	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax]
	mov	DWORD PTR _position$[ebp], ecx
	jmp	SHORT $LN6@NewGroundA
$LN5@NewGroundA:

; 300  : 		if (BattalionHeir[position].leader_idx >= 0) // JB 001203 //+

	mov	edx, DWORD PTR _position$[ebp]
	imul	edx, 12					; 0000000cH
	cmp	DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[edx], 0
	jl	$LN4@NewGroundA

; 301  : 			gai = simb[position] = new GNDAIClass (us, simb[BattalionHeir[position].leader_idx], (short)BattalionHeir[position].rank, BattalionHeir[position].uid, skill );

	push	140					; 0000008cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN11@NewGroundA
	mov	eax, DWORD PTR _skill$[ebp]
	push	eax
	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx+8]
	push	edx
	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	movzx	ecx, WORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax+4]
	push	ecx
	mov	edx, DWORD PTR _position$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[edx]
	mov	ecx, DWORD PTR _simb[eax*4]
	push	ecx
	mov	edx, DWORD PTR _us$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0GNDAIClass@@QAE@PAVGroundClass@@PAV0@FHH@Z ; GNDAIClass::GNDAIClass
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN12@NewGroundA
$LN11@NewGroundA:
	mov	DWORD PTR tv144[ebp], 0
$LN12@NewGroundA:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _simb[ecx*4], edx
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _gai$[ebp], eax

; 302  : 		else // JB 001203 //+

	jmp	SHORT $LN3@NewGroundA
$LN4@NewGroundA:

; 303  : 			gai = simb[position] = new GNDAIClass (us, NULL, BattalionHeir[position].rank, (short)BattalionHeir[position].uid, skill ); // JB 001203 //+

	push	140					; 0000008cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN13@NewGroundA
	mov	ecx, DWORD PTR _skill$[ebp]
	push	ecx
	mov	edx, DWORD PTR _position$[ebp]
	imul	edx, 12					; 0000000cH
	movsx	eax, WORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[edx+8]
	push	eax
	mov	ecx, DWORD PTR _position$[ebp]
	imul	ecx, 12					; 0000000cH
	movzx	edx, WORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _us$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0GNDAIClass@@QAE@PAVGroundClass@@PAV0@FHH@Z ; GNDAIClass::GNDAIClass
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN14@NewGroundA
$LN13@NewGroundA:
	mov	DWORD PTR tv165[ebp], 0
$LN14@NewGroundA:
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _simb[edx*4], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _gai$[ebp], ecx
$LN3@NewGroundA:

; 304  : 	}
; 305  : 	else

	jmp	SHORT $LN2@NewGroundA
$LN7@NewGroundA:

; 306  : 		gai = simb[position] = new GNDAIClass (us, NULL, BattalionHeir[position].rank, (short)BattalionHeir[position].uid, skill );

	push	140					; 0000008cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN15@NewGroundA
	mov	edx, DWORD PTR _skill$[ebp]
	push	edx
	mov	eax, DWORD PTR _position$[ebp]
	imul	eax, 12					; 0000000cH
	movsx	ecx, WORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[eax+8]
	push	ecx
	mov	edx, DWORD PTR _position$[ebp]
	imul	edx, 12					; 0000000cH
	movzx	eax, WORD PTR ?BattalionHeir@@3PAUBattalionInitType@@A[edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _us$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0GNDAIClass@@QAE@PAVGroundClass@@PAV0@FHH@Z ; GNDAIClass::GNDAIClass
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN16@NewGroundA
$LN15@NewGroundA:
	mov	DWORD PTR tv186[ebp], 0
$LN16@NewGroundA:
	mov	edx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _position$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _simb[eax*4], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _gai$[ebp], edx
$LN2@NewGroundA:

; 307  : 
; 308  : 	if (isFirst) {

	cmp	DWORD PTR _isFirst$[ebp], 0
	je	SHORT $LN1@NewGroundA

; 309  : 		batCmdr = gai;

	mov	eax, DWORD PTR _gai$[ebp]
	mov	DWORD PTR _batCmdr, eax
$LN1@NewGroundA:

; 310  : 	}
; 311  : 	gai->battalionCommand = batCmdr;

	mov	ecx, DWORD PTR _gai$[ebp]
	mov	edx, DWORD PTR _batCmdr
	mov	DWORD PTR [ecx+80], edx

; 312  : 
; 313  : 	return gai;

	mov	eax, DWORD PTR _gai$[ebp]

; 314  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z$2:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NewGroundAI@@YAPAVGNDAIClass@@PAVGroundClass@@HHH@Z ENDP ; NewGroundAI
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
tv166 = -16						; size = 4
tv159 = -12						; size = 4
tv150 = -8						; size = 4
tv141 = -4						; size = 4
_us$ = 8						; size = 4
?InPosition@@YAHPAVGNDAIClass@@@Z PROC			; InPosition

; 1596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1597 : 	// WARNING:  There is potential for silliness here due to floating point precision errors.
; 1598 : 	// Particularly the fact that MSVC/Intel don't always ensure that compare arguments are rounded
; 1599 : 	// to the same precision before the compare.
; 1600 : 
; 1601 : 	if (us->ideal_x != us->self->XPos() || 
; 1602 : 			us->ideal_y != us->self->YPos() || 
; 1603 : 			us->battalionCommand->self->XDelta() != 0.0F || 
; 1604 : 			us->battalionCommand->self->YDelta() != 0.0F)

	mov	eax, DWORD PTR _us$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv141[ebp]
	mov	ecx, DWORD PTR _us$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	ucomiss	xmm0, DWORD PTR tv141[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@InPosition
	mov	edx, DWORD PTR _us$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv150[ebp]
	mov	eax, DWORD PTR _us$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	ucomiss	xmm0, DWORD PTR tv150[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@InPosition
	mov	ecx, DWORD PTR _us$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	ecx, DWORD PTR [edx+72]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv159[ebp]
	movss	xmm0, DWORD PTR tv159[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@InPosition
	mov	eax, DWORD PTR _us$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	ecx, DWORD PTR [ecx+72]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv166[ebp]
	movss	xmm0, DWORD PTR tv166[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@InPosition
$LN2@InPosition:

; 1605 : 
; 1606 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@InPosition

; 1607 : 	else

	jmp	SHORT $LN1@InPosition
$LN3@InPosition:

; 1608 : 		return 1;

	mov	eax, 1
$LN1@InPosition:

; 1609 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InPosition@@YAHPAVGNDAIClass@@@Z ENDP			; InPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_trig$ = -8						; size = 8
_h$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_xo$ = 20						; size = 4
_yo$ = 24						; size = 4
?AdjustOffset@@YAXMPAM0MM@Z PROC			; AdjustOffset

; 1393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1394 : 	mlTrig trig;
; 1395 : 
; 1396 : 	mlSinCos (&trig, h);

	push	ecx
	movss	xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1397 : 
; 1398 : 	xo *= OFFSET_SCALE;

	movss	xmm0, DWORD PTR _xo$[ebp]
	mulss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR _xo$[ebp], xmm0

; 1399 : 	yo *= OFFSET_SCALE;

	movss	xmm0, DWORD PTR _yo$[ebp]
	mulss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR _yo$[ebp], xmm0

; 1400 : 
; 1401 : 	*x += xo * trig.sin + yo * trig.cos;

	movss	xmm0, DWORD PTR _xo$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	movss	xmm1, DWORD PTR _yo$[ebp]
	mulss	xmm1, DWORD PTR _trig$[ebp+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1402 : 	*y -= xo * trig.cos - yo * trig.sin;

	movss	xmm0, DWORD PTR _xo$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	xmm1, DWORD PTR _yo$[ebp]
	mulss	xmm1, DWORD PTR _trig$[ebp]
	subss	xmm0, xmm1
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 1403 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustOffset@@YAXMPAM0MM@Z ENDP			; AdjustOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 4
_s$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_xo$ = 24						; size = 4
_yo$ = 28						; size = 4
?AdjustOffset@@YAXMMPAM0MM@Z PROC			; AdjustOffset

; 1384 : {

	push	ebp
	mov	ebp, esp

; 1385 : 	xo *= OFFSET_SCALE;

	movss	xmm0, DWORD PTR _xo$[ebp]
	mulss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR _xo$[ebp], xmm0

; 1386 : 	yo *= OFFSET_SCALE;

	movss	xmm0, DWORD PTR _yo$[ebp]
	mulss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR _yo$[ebp], xmm0

; 1387 : 
; 1388 : 	*x += xo * s + yo * c;

	movss	xmm0, DWORD PTR _xo$[ebp]
	mulss	xmm0, DWORD PTR _s$[ebp]
	movss	xmm1, DWORD PTR _yo$[ebp]
	mulss	xmm1, DWORD PTR _c$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 1389 : 	*y -= xo * c - yo * s;

	movss	xmm0, DWORD PTR _xo$[ebp]
	mulss	xmm0, DWORD PTR _c$[ebp]
	movss	xmm1, DWORD PTR _yo$[ebp]
	mulss	xmm1, DWORD PTR _s$[ebp]
	subss	xmm0, xmm1
	mov	edx, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [edx]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm1

; 1390 : }

	pop	ebp
	ret	0
?AdjustOffset@@YAXMMPAM0MM@Z ENDP			; AdjustOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radar.h
;	COMDAT ?SetFlag@RadarClass@@QAEXW4RadarFlag@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?SetFlag@RadarClass@@QAEXW4RadarFlag@1@@Z PROC		; RadarClass::SetFlag, COMDAT
; _this$ = ecx

; 112  : 	void SetFlag(RadarFlag val)					{ flag |= val; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	or	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlag@RadarClass@@QAEXW4RadarFlag@1@@Z ENDP		; RadarClass::SetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawbsp.h
;	COMDAT ?LabelColor@DrawableBSP@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LabelColor@DrawableBSP@@QAEKXZ PROC			; DrawableBSP::LabelColor, COMDAT
; _this$ = ecx

; 63   : 	DWORD LabelColor()										{ return labelColor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+164]
	mov	esp, ebp
	pop	ebp
	ret	0
?LabelColor@DrawableBSP@@QAEKXZ ENDP			; DrawableBSP::LabelColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
tv586 = -184						; size = 8
_trig$ = -176						; size = 8
tv754 = -168						; size = 4
tv773 = -164						; size = 4
tv846 = -160						; size = 4
tv638 = -156						; size = 4
tv839 = -152						; size = 4
tv858 = -148						; size = 4
tv834 = -144						; size = 4
tv650 = -140						; size = 4
tv827 = -136						; size = 4
tv614 = -132						; size = 4
tv815 = -128						; size = 4
tv767 = -124						; size = 4
tv864 = -120						; size = 4
tv760 = -116						; size = 4
tv808 = -112						; size = 4
tv679 = -108						; size = 4
tv801 = -104						; size = 4
tv856 = -100						; size = 4
tv862 = -96						; size = 4
tv562 = -92						; size = 4
tv794 = -88						; size = 4
tv569 = -84						; size = 4
tv860 = -80						; size = 4
tv632 = -76						; size = 4
tv508 = -72						; size = 4
tv199 = -68						; size = 4
tv487 = -64						; size = 4
tv324 = -60						; size = 4
tv459 = -56						; size = 4
tv420 = -52						; size = 4
tv297 = -48						; size = 4
_ty$ = -44						; size = 4
_tx$ = -40						; size = 4
_decSlow$ = -36						; size = 4
_rotvel$ = -32						; size = 4
_decFast$ = -28						; size = 4
_speed$ = -24						; size = 4
_newyaw$1 = -20						; size = 4
_delx$ = -16						; size = 4
_delh$ = -12						; size = 4
_dely$ = -8						; size = 4
_this$ = -4						; size = 4
?Move_Towards_Dest@GNDAIClass@@QAEXXZ PROC		; GNDAIClass::Move_Towards_Dest
; _this$ = ecx

; 1193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	DWORD PTR _this$[ebp], ecx

; 1194 : 	float	delx=0.0F,dely=0.0F,delh=0.0F,rotvel= OPTIMAL_VEHICLE_ROTATION,speed=0.0F,tx=0.0F,ty=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dely$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delh$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR _rotvel$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _speed$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _tx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ty$[ebp], xmm0

; 1195 : 	mlTrig	trig;
; 1196 : 
; 1197 : 	ShiAssert( battalionCommand );
; 1198 : 
; 1199 : 	// get delta to next x and y location
; 1200 : 	if ((moveState == GNDAI_MOVE_HALTED) || (battalionCommand->moveState == GNDAI_MOVE_HALTED)){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN29@Move_Towar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN30@Move_Towar
$LN29@Move_Towar:

; 1201 : 		delx = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delx$[ebp], xmm0

; 1202 : 		dely = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dely$[ebp], xmm0

; 1203 : 		moveState = GNDAI_MOVE_HALTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 0

; 1204 : 	}
; 1205 : 	else {

	jmp	$LN23@Move_Towar
$LN30@Move_Towar:

; 1206 : 		delx = ideal_x - self->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv562[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	subss	xmm0, DWORD PTR tv562[ebp]
	movss	DWORD PTR _delx$[ebp], xmm0

; 1207 : 		dely = ideal_y - self->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv569[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	subss	xmm0, DWORD PTR tv569[ebp]
	movss	DWORD PTR _dely$[ebp], xmm0

; 1208 : 		leftToGoSq = delx*delx + dely*dely;

	movss	xmm0, DWORD PTR _delx$[ebp]
	mulss	xmm0, DWORD PTR _delx$[ebp]
	movss	xmm1, DWORD PTR _dely$[ebp]
	mulss	xmm1, DWORD PTR _dely$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+56], xmm0

; 1209 : 		if (leftToGoSq)	{

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN27@Move_Towar

; 1210 : 			// determine direction we need to go
; 1211 : 			if (leftToGoSq >= 100.0F){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	comiss	xmm0, DWORD PTR __real@42c80000
	jb	SHORT $LN26@Move_Towar

; 1212 : 				ideal_h = (float)atan2(dely, delx) + move_backwards;

	cvtss2sd xmm0, DWORD PTR _delx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dely$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv586[ebp]
	movsd	xmm0, QWORD PTR tv586[ebp]
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 1213 : 			}
; 1214 : 			else // if (leftToGoSq < 100.0F || ideal_h-battalionCommand->ideal_h > PI || ideal_h-battalionCommand->ideal_h < -PI)

	jmp	SHORT $LN25@Move_Towar
$LN26@Move_Towar:

; 1215 : 			{
; 1216 : 				// we're close enough to our destination to think again, or
; 1217 : 				// we just don't want to bother backing up.
; 1218 : 				ideal_x = self->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+28]

; 1219 : 				ideal_y = self->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]

; 1220 : 				if (formation == GNDAI_FORM_COLUMN)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 1
	jne	SHORT $LN24@Move_Towar

; 1221 : 				{
; 1222 : 					moveFlags |= GNDAI_WENT_THROUGH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1223 : 					Process();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Process@GNDAIClass@@QAEXXZ		; GNDAIClass::Process

; 1224 : 					//					Move_Towards_Dest();
; 1225 : 					return;

	jmp	$LN31@Move_Towar
$LN24@Move_Towar:

; 1226 : 				}
; 1227 : 				ideal_h = battalionCommand->ideal_h + move_backwards;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [edx+68]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 1228 : 				delx = dely = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dely$[ebp], xmm0
	movss	xmm0, DWORD PTR _dely$[ebp]
	movss	DWORD PTR _delx$[ebp], xmm0
$LN25@Move_Towar:

; 1229 : 			}
; 1230 : 		}
; 1231 : 		else {

	jmp	SHORT $LN23@Move_Towar
$LN27@Move_Towar:

; 1232 : 			moveFlags |= GNDAI_WENT_THROUGH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN23@Move_Towar:

; 1233 : 		}
; 1234 : 	}
; 1235 : 
; 1236 : 	// Check if we need to turn
; 1237 : 	delh = ideal_h - self->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv614[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+36]
	subss	xmm0, DWORD PTR tv614[ebp]
	movss	DWORD PTR _delh$[ebp], xmm0

; 1238 : 	if (!(moveFlags & GNDAI_MOVE_FIXED_POSITIONS) && delh != 0.0F) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, 8
	jne	$LN22@Move_Towar
	movss	xmm0, DWORD PTR _delh$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN22@Move_Towar

; 1239 : 		//if (delh >= PI || (delh < 0 && delh > -PI))
; 1240 : 		//	rotvel = -1.0F * OPTIMAL_VEHICLE_ROTATION;
; 1241 : 		//else if (delh <= -PI || delh > 0)
; 1242 : 		//	rotvel = OPTIMAL_VEHICLE_ROTATION;
; 1243 : 
; 1244 : 		if (delh >= PI || (delh < 0 && delh > -PI)){

	movss	xmm0, DWORD PTR _delh$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jae	SHORT $LN20@Move_Towar
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _delh$[ebp]
	jbe	SHORT $LN21@Move_Towar
	movss	xmm0, DWORD PTR _delh$[ebp]
	comiss	xmm0, DWORD PTR __real@c0490fdb
	jbe	SHORT $LN21@Move_Towar
$LN20@Move_Towar:

; 1245 : 			rotvel *= -1.0F;

	movss	xmm0, DWORD PTR _rotvel$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _rotvel$[ebp], xmm0
$LN21@Move_Towar:

; 1246 : 		}
; 1247 : 		delh = (float)min(fabs(delh),(2.0F*PI)-fabs(delh));

	push	ecx
	movss	xmm0, DWORD PTR _delh$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv632[ebp]
	movss	xmm0, DWORD PTR tv632[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _delh$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv856[ebp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv638[ebp]
	movss	xmm0, DWORD PTR __real@40c90fdb
	subss	xmm0, DWORD PTR tv638[ebp]
	movss	xmm1, DWORD PTR tv856[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN33@Move_Towar
	push	ecx
	movss	xmm0, DWORD PTR _delh$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv199[ebp]
	jmp	SHORT $LN34@Move_Towar
$LN33@Move_Towar:
	push	ecx
	movss	xmm0, DWORD PTR _delh$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv650[ebp]
	movss	xmm0, DWORD PTR __real@40c90fdb
	subss	xmm0, DWORD PTR tv650[ebp]
	movss	DWORD PTR tv199[ebp], xmm0
$LN34@Move_Towar:
	movss	xmm0, DWORD PTR tv199[ebp]
	movss	DWORD PTR _delh$[ebp], xmm0

; 1248 : 		if (delh < 2.0F * OPTIMAL_VEHICLE_ROTATION * SimLibMajorFrameTime){

	movss	xmm0, DWORD PTR __real@40490fd9
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	comiss	xmm0, DWORD PTR _delh$[ebp]
	jbe	SHORT $LN19@Move_Towar

; 1249 : 			// Snap to new heading
; 1250 : 			self->SetYPR(ideal_h, self->Pitch(), self->Roll());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 1251 : 			self->SetYPRDelta(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta

; 1252 : 		}
; 1253 : 		else {

	jmp	$LN18@Move_Towar
$LN19@Move_Towar:

; 1254 : 			// start rotating
; 1255 : 			float  newyaw = self->Yaw()+rotvel*SimLibMajorFrameTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv679[ebp]
	movss	xmm0, DWORD PTR tv679[ebp]
	movss	xmm1, DWORD PTR _rotvel$[ebp]
	mulss	xmm1, DWORD PTR ?SimLibMajorFrameTime@@3MA
	addss	xmm0, xmm1
	movss	DWORD PTR _newyaw$1[ebp], xmm0

; 1256 : 			if (newyaw > PI)

	movss	xmm0, DWORD PTR _newyaw$1[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN17@Move_Towar

; 1257 : 				newyaw -= 2.0F*PI;

	movss	xmm0, DWORD PTR _newyaw$1[ebp]
	subss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _newyaw$1[ebp], xmm0
$LN17@Move_Towar:

; 1258 : 			if (newyaw < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _newyaw$1[ebp]
	jbe	SHORT $LN16@Move_Towar

; 1259 : 				newyaw += 2.0F*PI;

	movss	xmm0, DWORD PTR _newyaw$1[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _newyaw$1[ebp], xmm0
$LN16@Move_Towar:

; 1260 : 			self->SetYPR(newyaw, self->Pitch(), self->Roll());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _newyaw$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?SetYPR@VuEntity@@QAEXMMM@Z		; VuEntity::SetYPR

; 1261 : 			self->SetYPRDelta(rotvel, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _rotvel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta
$LN18@Move_Towar:

; 1262 : 		}
; 1263 : 	}
; 1264 : 	else {

	jmp	SHORT $LN15@Move_Towar
$LN22@Move_Towar:

; 1265 : 		self->SetYPRDelta(0.0f, 0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?SetYPRDelta@VuEntity@@QAEXMMM@Z	; VuEntity::SetYPRDelta
$LN15@Move_Towar:

; 1266 : 	}
; 1267 : 
; 1268 : 	if (delx || dely){

	movss	xmm0, DWORD PTR _delx$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Move_Towar
	movss	xmm0, DWORD PTR _dely$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@Move_Towar
$LN13@Move_Towar:

; 1269 : 		// Calculate speed.
; 1270 : 		if (delh > 5.0F * DTR){

	movss	xmm0, DWORD PTR _delh$[ebp]
	comiss	xmm0, DWORD PTR __real@3db2b8c1
	jbe	SHORT $LN12@Move_Towar

; 1271 : 			// cornering speed
; 1272 : 			speed = min(20.0F,maxvel);

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	comiss	xmm0, DWORD PTR __real@41a00000
	jbe	SHORT $LN35@Move_Towar
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR tv297[ebp], xmm0
	jmp	SHORT $LN36@Move_Towar
$LN35@Move_Towar:
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+60]
	movss	DWORD PTR tv297[ebp], xmm0
$LN36@Move_Towar:
	movss	xmm0, DWORD PTR tv297[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
	jmp	SHORT $LN8@Move_Towar
$LN12@Move_Towar:

; 1273 : 		}
; 1274 : 		else if (rank == GNDAI_BATTALION_COMMANDER || formation == GNDAI_FORM_COLUMN){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 15			; 0000000fH
	je	SHORT $LN9@Move_Towar
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 1
	jne	SHORT $LN10@Move_Towar
$LN9@Move_Towar:

; 1275 : 			// go at unit cruise speed
; 1276 : 			speed = unitvel;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+64]
	movss	DWORD PTR _speed$[ebp], xmm0

; 1277 : 		}
; 1278 : 		else{

	jmp	SHORT $LN8@Move_Towar
$LN10@Move_Towar:

; 1279 : 			// adjust speed to catch up/wait up (max at maxvel)
; 1280 : 			speed = min(maxvel, (leftToGoSq / battalionCommand->leftToGoSq) * maxvel);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+56]
	divss	xmm0, DWORD PTR [edx+56]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+60]
	comiss	xmm0, DWORD PTR [eax+60]
	jbe	SHORT $LN37@Move_Towar
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR tv324[ebp], xmm0
	jmp	SHORT $LN38@Move_Towar
$LN37@Move_Towar:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	divss	xmm0, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [ecx+60]
	movss	DWORD PTR tv324[ebp], xmm0
$LN38@Move_Towar:
	movss	xmm0, DWORD PTR tv324[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN8@Move_Towar:

; 1281 : 		}
; 1282 : 		if (move_backwards > 0.0F){

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+68]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@Move_Towar

; 1283 : 			speed *= -1.0F;

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _speed$[ebp], xmm0
$LN7@Move_Towar:

; 1284 : 		}
; 1285 : 		mlSinCos (&trig, self->Yaw());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1286 : 		tx = speed * trig.cos;

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _tx$[ebp], xmm0

; 1287 : 		ty = speed * trig.sin;

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _ty$[ebp], xmm0

; 1288 : 		if (fabs(delx) > fabs(tx) * SimLibMajorFrameTime){

	push	ecx
	movss	xmm0, DWORD PTR _delx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv754[ebp]
	movss	xmm0, DWORD PTR tv754[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _tx$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv858[ebp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv760[ebp]
	movss	xmm0, DWORD PTR tv760[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR tv858[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN6@Move_Towar

; 1289 : 			delx = tx;

	movss	xmm0, DWORD PTR _tx$[ebp]
	movss	DWORD PTR _delx$[ebp], xmm0
$LN6@Move_Towar:

; 1290 : 		}
; 1291 : 		if (fabs(dely) > fabs(ty) * SimLibMajorFrameTime){

	push	ecx
	movss	xmm0, DWORD PTR _dely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv767[ebp]
	movss	xmm0, DWORD PTR tv767[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _ty$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv860[ebp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv773[ebp]
	movss	xmm0, DWORD PTR tv773[ebp]
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	xmm1, DWORD PTR tv860[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@Move_Towar

; 1292 : 			dely = ty;

	movss	xmm0, DWORD PTR _ty$[ebp]
	movss	DWORD PTR _dely$[ebp], xmm0
$LN5@Move_Towar:

; 1293 : 		}
; 1294 : 		//MI
; 1295 : 		/*
; 1296 : 		// sfr: removed VT
; 1297 : 		if(g_bRealisticAvionics && g_bAGRadarFixes){
; 1298 : 			self->SetVt(speed);
; 1299 : 		}*/
; 1300 : 	}
; 1301 : 	/* sfr: removed setVt
; 1302 : 	//MI
; 1303 : 	else
; 1304 : 	{
; 1305 : 		if(g_bRealisticAvionics && g_bAGRadarFixes){
; 1306 : 			self->SetVt(0.0F);
; 1307 : 		}
; 1308 : 	}*/
; 1309 : 	// KCK: This is done in Exec()
; 1310 : 	//	self->SetPosition (self->XPos()+delx, self->YPos()+dely, self->ZPos());
; 1311 : 
; 1312 : 	// RV - Biker - Don't move at full speed when damaged
; 1313 : 	float decFast = 0.5f*SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _decFast$[ebp], xmm0

; 1314 : 	float decSlow = 0.1f*SimLibMajorFrameTime;

	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	movss	DWORD PTR _decSlow$[ebp], xmm0

; 1315 : 
; 1316 : 	if (self->pctStrength > 0.75f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	movss	xmm0, DWORD PTR [eax+292]
	comiss	xmm0, DWORD PTR __real@3f400000
	jbe	SHORT $LN4@Move_Towar

; 1317 : 		self->SetDelta (delx, dely, 0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dely$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _delx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta
	jmp	$LN1@Move_Towar
$LN4@Move_Towar:

; 1318 : 	else if (self->pctStrength > 0.25f)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	movss	xmm0, DWORD PTR [eax+292]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	$LN2@Move_Towar

; 1319 : 		self->SetDelta (max(delx*(self->pctStrength), self->XDelta()-decSlow), max(dely*(self->pctStrength), self->YDelta()-decSlow), 0.0F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	movss	xmm0, DWORD PTR [edx+292]
	mulss	xmm0, DWORD PTR _dely$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	movss	DWORD PTR tv862[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv794[ebp]
	movss	xmm0, DWORD PTR tv794[ebp]
	subss	xmm0, DWORD PTR _decSlow$[ebp]
	movss	xmm1, DWORD PTR tv862[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN39@Move_Towar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	movss	xmm0, DWORD PTR [edx+292]
	mulss	xmm0, DWORD PTR _dely$[ebp]
	movss	DWORD PTR tv420[ebp], xmm0
	jmp	SHORT $LN40@Move_Towar
$LN39@Move_Towar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv801[ebp]
	movss	xmm0, DWORD PTR tv801[ebp]
	subss	xmm0, DWORD PTR _decSlow$[ebp]
	movss	DWORD PTR tv420[ebp], xmm0
$LN40@Move_Towar:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	movss	xmm0, DWORD PTR [edx+292]
	mulss	xmm0, DWORD PTR _delx$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	movss	DWORD PTR tv864[ebp], xmm0
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv808[ebp]
	movss	xmm0, DWORD PTR tv808[ebp]
	subss	xmm0, DWORD PTR _decSlow$[ebp]
	movss	xmm1, DWORD PTR tv864[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN41@Move_Towar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	movss	xmm0, DWORD PTR [edx+292]
	mulss	xmm0, DWORD PTR _delx$[ebp]
	movss	DWORD PTR tv459[ebp], xmm0
	jmp	SHORT $LN42@Move_Towar
$LN41@Move_Towar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv815[ebp]
	movss	xmm0, DWORD PTR tv815[ebp]
	subss	xmm0, DWORD PTR _decSlow$[ebp]
	movss	DWORD PTR tv459[ebp], xmm0
$LN42@Move_Towar:
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv420[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv459[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta

; 1320 : 	else

	jmp	$LN1@Move_Towar
$LN2@Move_Towar:

; 1321 : 		self->SetDelta (max(0.0f, self->XDelta()-decFast), max(0.0f, self->YDelta()-decFast), 0.0F);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv827[ebp]
	movss	xmm0, DWORD PTR tv827[ebp]
	subss	xmm0, DWORD PTR _decFast$[ebp]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN43@Move_Towar
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv487[ebp], xmm0
	jmp	SHORT $LN44@Move_Towar
$LN43@Move_Towar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv834[ebp]
	movss	xmm0, DWORD PTR tv834[ebp]
	subss	xmm0, DWORD PTR _decFast$[ebp]
	movss	DWORD PTR tv487[ebp], xmm0
$LN44@Move_Towar:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv839[ebp]
	movss	xmm0, DWORD PTR tv839[ebp]
	subss	xmm0, DWORD PTR _decFast$[ebp]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN45@Move_Towar
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv508[ebp], xmm0
	jmp	SHORT $LN46@Move_Towar
$LN45@Move_Towar:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv846[ebp]
	movss	xmm0, DWORD PTR tv846[ebp]
	subss	xmm0, DWORD PTR _decFast$[ebp]
	movss	DWORD PTR tv508[ebp], xmm0
$LN46@Move_Towar:
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv487[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv508[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?SetDelta@VuEntity@@QAEXMMM@Z		; VuEntity::SetDelta
$LN1@Move_Towar:
$LN31@Move_Towar:

; 1322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Move_Towards_Dest@GNDAIClass@@QAEXXZ ENDP		; GNDAIClass::Move_Towards_Dest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
tv170 = -52						; size = 4
tv176 = -48						; size = 4
tv164 = -44						; size = 4
_xd$ = -40						; size = 4
_yd$ = -36						; size = 4
tv147 = -32						; size = 4
_zd$ = -28						; size = 4
_distsqu$ = -24						; size = 4
_this$ = -20						; size = 4
_viewLoc$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?SetDistLOD@GNDAIClass@@QAEXXZ PROC			; GNDAIClass::SetDistLOD
; _this$ = ecx

; 1561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1562 : 	Tpoint viewLoc;
; 1563 : 	float	xd,yd,zd,distsqu;
; 1564 : 
; 1565 : 	// get view pos
; 1566 : 	if (OTWDriver.GetViewpoint())

	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	test	eax, eax
	je	$LN4@SetDistLOD

; 1567 : 	{
; 1568 : 		OTWDriver.GetViewpoint()->GetPos( &viewLoc );

	lea	eax, DWORD PTR _viewLoc$[ebp]
	push	eax
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetViewpoint@OTWDriverClass@@QAEPAVRViewPoint@@XZ ; OTWDriverClass::GetViewpoint
	mov	ecx, eax
	call	?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z	; TViewPoint::GetPos

; 1569 : 
; 1570 : 		xd = viewLoc.x - self->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv164[ebp]
	movss	xmm0, DWORD PTR _viewLoc$[ebp]
	subss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _xd$[ebp], xmm0

; 1571 : 		yd = viewLoc.y - self->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv170[ebp]
	movss	xmm0, DWORD PTR _viewLoc$[ebp+4]
	subss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _yd$[ebp], xmm0

; 1572 : 		zd = viewLoc.z - self->ZPos();	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv176[ebp]
	movss	xmm0, DWORD PTR _viewLoc$[ebp+8]
	subss	xmm0, DWORD PTR tv176[ebp]
	movss	DWORD PTR _zd$[ebp], xmm0

; 1573 : 		distsqu = xd*xd + yd*yd + zd*zd;

	movss	xmm0, DWORD PTR _xd$[ebp]
	mulss	xmm0, DWORD PTR _xd$[ebp]
	movss	xmm1, DWORD PTR _yd$[ebp]
	mulss	xmm1, DWORD PTR _yd$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _zd$[ebp]
	mulss	xmm1, DWORD PTR _zd$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _distsqu$[ebp], xmm0

; 1574 : 
; 1575 : 		// Never label out beyond 10 NM
; 1576 : 		if (distsqu < 100.0F)

	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _distsqu$[ebp]
	jbe	SHORT $LN3@SetDistLOD

; 1577 : 		{
; 1578 : 			distLOD = max (0.0F, (LOD_MAX_DIST_SQU - distsqu)/LOD_MAX_DIST_SQU);

	movss	xmm0, DWORD PTR __real@4dbebc20
	subss	xmm0, DWORD PTR _distsqu$[ebp]
	divss	xmm0, DWORD PTR __real@4dbebc20
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@SetDistLOD
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN8@SetDistLOD
$LN7@SetDistLOD:
	movss	xmm0, DWORD PTR __real@4dbebc20
	subss	xmm0, DWORD PTR _distsqu$[ebp]
	divss	xmm0, DWORD PTR __real@4dbebc20
	movss	DWORD PTR tv147[ebp], xmm0
$LN8@SetDistLOD:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR [ecx+108], xmm0

; 1579 : 			distLOD *= distLOD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+108]
	mulss	xmm0, DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+108], xmm0

; 1580 : 		}
; 1581 : 		else

	jmp	SHORT $LN2@SetDistLOD
$LN3@SetDistLOD:

; 1582 : 		{
; 1583 : 			distLOD = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+108], xmm0
$LN2@SetDistLOD:

; 1584 : 		}
; 1585 : 	}
; 1586 : 	else

	jmp	SHORT $LN1@SetDistLOD
$LN4@SetDistLOD:

; 1587 : 	{
; 1588 : 		distLOD = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+108], xmm0
$LN1@SetDistLOD:

; 1589 : 	}
; 1590 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDistLOD@GNDAIClass@@QAEXXZ ENDP			; GNDAIClass::SetDistLOD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_vehicleWalker$2 = -64					; size = 12
_vehicleWalker$3 = -52					; size = 12
_vehicleWalker$4 = -40					; size = 12
_bc$ = -28						; size = 4
_newLead$ = -24						; size = 4
_theObj$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?PromoteSubordinates@GNDAIClass@@QAEXXZ PROC		; GNDAIClass::PromoteSubordinates
; _this$ = ecx

; 1411 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PromoteSubordinates@GNDAIClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1412 : 	GNDAIClass	*bc = NULL;

	mov	DWORD PTR _bc$[ebp], 0

; 1413 : 	GroundClass *theObj;
; 1414 : 	GroundClass *newLead = NULL;

	mov	DWORD PTR _newLead$[ebp], 0

; 1415 : 
; 1416 : 	// sfr: @todo remove these checks
; 1417 : 	if (!self || F4IsBadWritePtr(self, sizeof(GroundClass)) || F4IsBadCodePtr((FARPROC) self->GetCampaignObject())) // JB 010318 CTD

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN21@PromoteSub
	push	828					; 0000033cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	?F4IsBadWritePtr@@YA_NPAXI@Z		; F4IsBadWritePtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN21@PromoteSub
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	call	?F4IsBadCodePtr@@YA_NPAX@Z		; F4IsBadCodePtr
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@PromoteSub
$LN21@PromoteSub:

; 1418 : 	{
; 1419 : 		if (F4IsBadWritePtr(this, sizeof(GNDAIClass)))

	push	140					; 0000008cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?F4IsBadWritePtr@@YA_NPAXI@Z		; F4IsBadWritePtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@PromoteSub

; 1420 : 			return;

	jmp	$LN23@PromoteSub
$LN20@PromoteSub:

; 1421 : 
; 1422 : 		// set our own leader (if any) to NULL to deref
; 1423 : 		SetLeader( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 1424 : 		battalionCommand = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 1425 : 		rank = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1426 : 		return;

	jmp	$LN23@PromoteSub
$LN22@PromoteSub:

; 1427 : 	} // JB 010318 CTD
; 1428 : 
; 1429 : 	// edg: changed from assert.  A unit may have been killed just after a
; 1430 : 	// reagg and there may be no-one to promote!
; 1431 : 	if ( !self->GetCampaignObject()->GetComponents())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	jne	SHORT $LN19@PromoteSub

; 1432 : 	{
; 1433 : 		// set our own leader (if any) to NULL to deref
; 1434 : 		SetLeader( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 1435 : 		battalionCommand = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 1436 : 		rank = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1437 : 		return;

	jmp	$LN23@PromoteSub
$LN19@PromoteSub:

; 1438 : 	}
; 1439 : 
; 1440 : 	// KCK: In the case where we're simply reaggregating these guys, do a simple clean
; 1441 : 	// up - just eliminate pointers to us - this is ok, because everyone will do this
; 1442 : 	// shortly afterwards
; 1443 : 	if (self->GetCampaignObject()->IsAggregate())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?IsAggregate@CampBaseClass@@QAEHXZ	; CampBaseClass::IsAggregate
	test	eax, eax
	je	$LN18@PromoteSub

; 1444 : 	{
; 1445 : 		{
; 1446 : 			VuListIterator	vehicleWalker( self->GetCampaignObject()->GetComponents() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _vehicleWalker$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1447 : 			theObj = (GroundClass*)vehicleWalker.GetFirst();

	lea	ecx, DWORD PTR _vehicleWalker$4[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _theObj$[ebp], eax
$LN17@PromoteSub:

; 1448 : 			while (theObj)

	cmp	DWORD PTR _theObj$[ebp], 0
	je	SHORT $LN16@PromoteSub

; 1449 : 			{
; 1450 : 				if (theObj->gai->battalionCommand == this)

	mov	eax, DWORD PTR _theObj$[ebp]
	mov	ecx, DWORD PTR [eax+744]
	mov	edx, DWORD PTR [ecx+80]
	cmp	edx, DWORD PTR _this$[ebp]
	jne	SHORT $LN15@PromoteSub

; 1451 : 					theObj->gai->battalionCommand = NULL;

	mov	eax, DWORD PTR _theObj$[ebp]
	mov	ecx, DWORD PTR [eax+744]
	mov	DWORD PTR [ecx+80], 0
$LN15@PromoteSub:

; 1452 : 				if (theObj->gai->leader == this)

	mov	edx, DWORD PTR _theObj$[ebp]
	mov	eax, DWORD PTR [edx+744]
	mov	ecx, DWORD PTR [eax+76]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $LN14@PromoteSub

; 1453 : 					theObj->gai->SetLeader(NULL);

	push	0
	mov	edx, DWORD PTR _theObj$[ebp]
	mov	ecx, DWORD PTR [edx+744]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader
$LN14@PromoteSub:

; 1454 : 				theObj = (GroundClass*)vehicleWalker.GetNext();

	lea	ecx, DWORD PTR _vehicleWalker$4[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _theObj$[ebp], eax

; 1455 : 			}

	jmp	SHORT $LN17@PromoteSub
$LN16@PromoteSub:

; 1456 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vehicleWalker$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1457 : 		SetLeader( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 1458 : 		battalionCommand = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1459 : 		rank = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 1460 : 		return;

	jmp	$LN23@PromoteSub
$LN18@PromoteSub:

; 1461 : 	}
; 1462 : 
; 1463 : 	// Look for a new global commander, assuming we're the current one
; 1464 : 	if (this == battalionCommand)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+80]
	jne	$LN13@PromoteSub

; 1465 : 	{
; 1466 : 		// Note who our supreme commander is.  Emperical evidence suggests we could get
; 1467 : 		// here with one or more "expoding" objects in the list, so we have to find the
; 1468 : 		// first NON-exploding object (if any) to be the new battalion commander.
; 1469 : 		{
; 1470 : 			VuListIterator	vehicleWalker( self->GetCampaignObject()->GetComponents() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _vehicleWalker$3[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1471 : 			theObj = (GroundClass*)vehicleWalker.GetFirst();

	lea	ecx, DWORD PTR _vehicleWalker$3[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _theObj$[ebp], eax
$LN12@PromoteSub:

; 1472 : 			while (theObj && theObj != self && (theObj->IsExploding() || theObj->IsDead()))

	cmp	DWORD PTR _theObj$[ebp], 0
	je	SHORT $LN11@PromoteSub
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _theObj$[ebp]
	cmp	eax, DWORD PTR [edx+72]
	je	SHORT $LN11@PromoteSub
	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	jne	SHORT $LN10@PromoteSub
	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	eax, DWORD PTR [edx+340]
	call	eax
	test	eax, eax
	je	SHORT $LN11@PromoteSub
$LN10@PromoteSub:

; 1473 : 				theObj = (GroundClass*)vehicleWalker.GetNext();

	lea	ecx, DWORD PTR _vehicleWalker$3[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _theObj$[ebp], eax
	jmp	SHORT $LN12@PromoteSub
$LN11@PromoteSub:

; 1474 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vehicleWalker$3[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1475 : 
; 1476 : 		if (theObj)

	cmp	DWORD PTR _theObj$[ebp], 0
	je	SHORT $LN13@PromoteSub

; 1477 : 		{
; 1478 : 			ShiAssert( theObj->gai );
; 1479 : 			ShiAssert( theObj->VuState() == VU_MEM_ACTIVE );
; 1480 : 			ShiAssert (rank == GNDAI_BATTALION_COMMANDER);
; 1481 : 			bc = theObj->gai;

	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	edx, DWORD PTR [ecx+744]
	mov	DWORD PTR _bc$[ebp], edx

; 1482 : 			bc->rank = rank = GNDAI_BATTALION_COMMANDER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	ecx, DWORD PTR _bc$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1483 : 			bc->SetLeader( bc );

	mov	edx, DWORD PTR _bc$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bc$[ebp]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 1484 : 			// Make the new commander our leader, so that promotions will work
; 1485 : 			leader = bc; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bc$[ebp]
	mov	DWORD PTR [eax+76], ecx
$LN13@PromoteSub:

; 1486 : 		}
; 1487 : 	}
; 1488 : 
; 1489 : 	if (rank)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$LN8@PromoteSub

; 1490 : 	{
; 1491 : 		// Get the first vehicle in our battalion (or task force)
; 1492 : 		VuListIterator	vehicleWalker( self->GetCampaignObject()->GetComponents() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _vehicleWalker$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 1493 : 		theObj = (GroundClass*)vehicleWalker.GetFirst();

	lea	ecx, DWORD PTR _vehicleWalker$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _theObj$[ebp], eax
$LN7@PromoteSub:

; 1494 : 		// loop thru elements in flight
; 1495 : 		while (theObj) 

	cmp	DWORD PTR _theObj$[ebp], 0
	je	$LN6@PromoteSub

; 1496 : 		{
; 1497 : 
; 1498 : 			ShiAssert( theObj->gai );
; 1499 : 			ShiAssert( theObj != self );
; 1500 : 
; 1501 : 			// KCK: This creates problems by allowing a vehicle to
; 1502 : 			// null it's pointers prematurely. The easiest solution
; 1503 : 			// is to allow dead vehicles to inherit command, and then
; 1504 : 			// have them pass it along to the next guy when they call
; 1505 : 			// PromoteSubordinates()
; 1506 : 			/*			if ( theObj->IsExploding() || theObj->IsDead() ) 
; 1507 : 						{
; 1508 : 						SetLeader( NULL );
; 1509 : 						battalionCommand = NULL;
; 1510 : 						rank = 0;
; 1511 : 						theObj = (GroundClass*)vehicleWalker.GetNext();
; 1512 : 						continue;
; 1513 : 						}
; 1514 : 						*/
; 1515 : 			ShiAssert(theObj->VuState() == VU_MEM_ACTIVE);
; 1516 : 
; 1517 : 			// do we promote this guy?
; 1518 : 			if ( theObj->gai->leader == this)

	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	edx, DWORD PTR [ecx+744]
	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN5@PromoteSub

; 1519 : 			{
; 1520 : 				if (!newLead)

	cmp	DWORD PTR _newLead$[ebp], 0
	jne	SHORT $LN4@PromoteSub

; 1521 : 				{
; 1522 : 					// We're the new leader - set some stuff
; 1523 : 					newLead = theObj;

	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	DWORD PTR _newLead$[ebp], ecx

; 1524 : 					newLead->gai->rank = rank;

	mov	edx, DWORD PTR _newLead$[ebp]
	mov	eax, DWORD PTR [edx+744]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 1525 : 					newLead->gai->SetLeader (leader);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _newLead$[ebp]
	mov	ecx, DWORD PTR [edx+744]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 1526 : 					if (newLead->drawPointer)

	mov	eax, DWORD PTR _newLead$[ebp]
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN3@PromoteSub

; 1527 : 						SetLabel (newLead);

	mov	ecx, DWORD PTR _newLead$[ebp]
	push	ecx
	call	?SetLabel@@YAXPAVSimBaseClass@@@Z	; SetLabel
	add	esp, 4
$LN3@PromoteSub:

; 1528 : 				}
; 1529 : 				else

	jmp	SHORT $LN5@PromoteSub
$LN4@PromoteSub:

; 1530 : 				{
; 1531 : 					// Subordinate set to New Leader
; 1532 : 					theObj->gai->SetLeader (newLead->gai);

	mov	edx, DWORD PTR _newLead$[ebp]
	mov	eax, DWORD PTR [edx+744]
	push	eax
	mov	ecx, DWORD PTR _theObj$[ebp]
	mov	ecx, DWORD PTR [ecx+744]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader
$LN5@PromoteSub:

; 1533 : 				}
; 1534 : 			}
; 1535 : 
; 1536 : 			// Make sure our battalion commander pointer is set correctly
; 1537 : 			if (bc)

	cmp	DWORD PTR _bc$[ebp], 0
	je	SHORT $LN1@PromoteSub

; 1538 : 				theObj->gai->battalionCommand = bc;

	mov	edx, DWORD PTR _theObj$[ebp]
	mov	eax, DWORD PTR [edx+744]
	mov	ecx, DWORD PTR _bc$[ebp]
	mov	DWORD PTR [eax+80], ecx
$LN1@PromoteSub:

; 1539 : 
; 1540 : 			// Get the next member of our group
; 1541 : 			theObj = (GroundClass*)vehicleWalker.GetNext();

	lea	ecx, DWORD PTR _vehicleWalker$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _theObj$[ebp], eax

; 1542 : 		}

	jmp	$LN7@PromoteSub
$LN6@PromoteSub:

; 1543 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vehicleWalker$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN8@PromoteSub:

; 1544 : 
; 1545 : 	// set our own leader (if any) to NULL to deref
; 1546 : 	SetLeader( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 1547 : 	battalionCommand = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 1548 : 	rank = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN23@PromoteSub:

; 1549 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PromoteSubordinates@GNDAIClass@@QAEXXZ$0:
	lea	ecx, DWORD PTR _vehicleWalker$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?PromoteSubordinates@GNDAIClass@@QAEXXZ$1:
	lea	ecx, DWORD PTR _vehicleWalker$3[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?PromoteSubordinates@GNDAIClass@@QAEXXZ$2:
	lea	ecx, DWORD PTR _vehicleWalker$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?PromoteSubordinates@GNDAIClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PromoteSubordinates@GNDAIClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PromoteSubordinates@GNDAIClass@@QAEXXZ ENDP		; GNDAIClass::PromoteSubordinates
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTarget$ = 8						; size = 4
?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z PROC	; GNDAIClass::SetAirTarget
; _this$ = ecx

; 473  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 474  : 	if (newTarget == airTargetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTarget$[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jne	SHORT $LN3@SetAirTarg

; 475  : 		return;

	jmp	SHORT $LN4@SetAirTarg
$LN3@SetAirTarg:

; 476  : 
; 477  : 	if (airTargetPtr) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN2@SetAirTarg

; 478  : 		airTargetPtr->Release(  );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release
$LN2@SetAirTarg:

; 479  : 	}
; 480  : 
; 481  : 	// 2001-03-21 COMMENT BY S.G. INTENTIONNALY, I'M NOT SETTING SPOTTED HERE BECAUSE I NEED BETTER WAY THAN CAMPAIGN ENGINE TO MAKE DETECTION...
; 482  : 	if (newTarget) {

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	SHORT $LN1@SetAirTarg

; 483  : 		newTarget->Reference(  );

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference
$LN1@SetAirTarg:

; 484  : 	}
; 485  : 
; 486  : 	airTargetPtr = newTarget;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newTarget$[ebp]
	mov	DWORD PTR [ecx+136], edx
$LN4@SetAirTarg:

; 487  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ENDP	; GNDAIClass::SetAirTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
tv158 = -12						; size = 4
tv132 = -8						; size = 4
_this$ = -4						; size = 4
_newTarget$ = 8						; size = 4
?SetGroundTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z PROC ; GNDAIClass::SetGroundTarget
; _this$ = ecx

; 450  : void GNDAIClass::SetGroundTarget( SimObjectType *newTarget ){

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 451  : 	if (newTarget == gndTargetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTarget$[ebp]
	cmp	ecx, DWORD PTR [eax+132]
	jne	SHORT $LN5@SetGroundT

; 452  : 		return;

	jmp	$LN6@SetGroundT
$LN5@SetGroundT:

; 453  : 
; 454  : 	if (gndTargetPtr) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+132], 0
	je	SHORT $LN4@SetGroundT

; 455  : 		gndTargetPtr->Release(  );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release
$LN4@SetGroundT:

; 456  : 	}
; 457  : 
; 458  : 	if (newTarget) {

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	$LN3@SetGroundT

; 459  : 		newTarget->Reference(  );

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference

; 460  : 		// 2001-03-21 ADDED BY S.G. SINCE WE ARE A SIM THINGY, WE CAN'T RELY ON THE DetectVs CODE TO FLAG THE TARGET AS DETECTED. I NEED TO DO IT MYSELF HERE
; 461  : 		if (newTarget->BaseData()->IsSim())

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN2@SetGroundT

; 462  : 			((SimBaseClass *)newTarget->BaseData())->GetCampaignObject()->SetSpotted(self->GetCampaignObject()->GetTeam(),TheCampaign.CurrentTime, 1); // 2002-02-11 MODIFIED BY S.G. Added '1' to flag it identified

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv132[ebp], eax
	push	1
	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	edx
	mov	eax, DWORD PTR tv132[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted

; 463  : 		else

	jmp	SHORT $LN3@SetGroundT
$LN2@SetGroundT:

; 464  : 			((CampBaseClass *)newTarget->BaseData())->SetSpotted(self->GetCampaignObject()->GetTeam(),TheCampaign.CurrentTime, 1); // 2002-02-11 MODIFIED BY S.G. Added '1' to flag it identified

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv158[ebp], eax
	push	1
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	push	eax
	mov	ecx, DWORD PTR tv158[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv158[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?SetSpotted@CampBaseClass@@QAEXEKH@Z	; CampBaseClass::SetSpotted
$LN3@SetGroundT:

; 465  : 		// END OF ADDED SECTION
; 466  : 	}
; 467  : 
; 468  : 	gndTargetPtr = newTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTarget$[ebp]
	mov	DWORD PTR [edx+132], eax
$LN6@SetGroundT:

; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroundTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ENDP ; GNDAIClass::SetGroundTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CheckThrough@GNDAIClass@@QAEHXZ PROC			; GNDAIClass::CheckThrough
; _this$ = ecx

; 1172 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1173 : 	ShiAssert( battalionCommand );
; 1174 : 
; 1175 : 	// Check to see if we want to move through a turn point
; 1176 : 	if (battalionCommand->through_x != through_x || battalionCommand->through_y != through_y)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	ucomiss	xmm0, DWORD PTR [edx+40]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CheckThrou
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	ucomiss	xmm0, DWORD PTR [edx+44]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CheckThrou
$LN2@CheckThrou:

; 1177 : 	{
; 1178 : 		moveFlags &= ~GNDAI_WENT_THROUGH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1179 : 		through_x = battalionCommand->through_x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+40], eax

; 1180 : 		through_y = battalionCommand->through_y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+44], ecx
$LN3@CheckThrou:

; 1181 : 	}
; 1182 : 	if (!(moveFlags & GNDAI_WENT_THROUGH) && through_x && through_y)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, 16					; 00000010H
	jne	SHORT $LN1@CheckThrou
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+40]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1@CheckThrou
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1@CheckThrou

; 1183 : 	{
; 1184 : 		ideal_x = through_x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+28], edx

; 1185 : 		ideal_y = through_y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+32], edx

; 1186 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@CheckThrou
$LN1@CheckThrou:

; 1187 : 	}
; 1188 : 	return 0;

	xor	eax, eax
$LN4@CheckThrou:

; 1189 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckThrough@GNDAIClass@@QAEHXZ ENDP			; GNDAIClass::CheckThrough
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_rx$1 = -20						; size = 4
_ry$2 = -16						; size = 4
_randy$3 = -12						; size = 4
_randx$4 = -8						; size = 4
_this$ = -4						; size = 4
?Order_Squad@GNDAIClass@@QAEXXZ PROC			; GNDAIClass::Order_Squad
; _this$ = ecx

; 1134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1135 : 	ShiAssert( battalionCommand );	// This should always be TRUE, right?
; 1136 : 
; 1137 : 	if (moveState != GNDAI_MOVE_HALTED)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	$LN7@Order_Squa

; 1138 : 	{
; 1139 : 		// We can move, so get into formation
; 1140 : 		formation = battalionCommand->formation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 1141 : 		if (formation != GNDAI_FORM_COLUMN || !CheckThrough())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 1
	jne	SHORT $LN5@Order_Squa
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckThrough@GNDAIClass@@QAEHXZ	; GNDAIClass::CheckThrough
	test	eax, eax
	jne	$LN3@Order_Squa
$LN5@Order_Squa:

; 1142 : 		{
; 1143 : 			if (InPosition(this))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?InPosition@@YAHPAVGNDAIClass@@@Z	; InPosition
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Order_Squa

; 1144 : 			{
; 1145 : 				// Just rotate in place, if we're in position already
; 1146 : 				ideal_h = leader->ideal_h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx

; 1147 : 			}
; 1148 : 			else

	jmp	$LN3@Order_Squa
$LN4@Order_Squa:

; 1149 : 			{
; 1150 : 				// Otherwise, move out.
; 1151 : 				float	rx,ry;
; 1152 : 				int		randx,randy;
; 1153 : 				ideal_x = leader->ideal_x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], edx

; 1154 : 				ideal_y = leader->ideal_y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+32], eax

; 1155 : 				randx = FloatToInt32(FormationRandomness[formation].x);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	ecx
	movss	xmm0, DWORD PTR ?FormationRandomness@@3PAUAIOffsetType@@A[edx*8]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _randx$4[ebp], eax

; 1156 : 				randy = FloatToInt32(FormationRandomness[formation].x);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	movss	xmm0, DWORD PTR ?FormationRandomness@@3PAUAIOffsetType@@A[ecx*8]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _randy$3[ebp], eax

; 1157 : 				rx = (float)(rand() % randx) - (randx/2);

	call	_rand
	cdq
	idiv	DWORD PTR _randx$4[ebp]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _randx$4[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	subss	xmm0, xmm1
	movss	DWORD PTR _rx$1[ebp], xmm0

; 1158 : 				ry = (float)(rand() % randy) - (randy/2);

	call	_rand
	cdq
	idiv	DWORD PTR _randy$3[ebp]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _randy$3[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm1, eax
	subss	xmm0, xmm1
	movss	DWORD PTR _ry$2[ebp], xmm0

; 1159 : 				AdjustOffset(battalionCommand->icosh, battalionCommand->isinh, &ideal_x, &ideal_y, CompanyFormations[formation][company_id].x+rx, CompanyFormations[formation][company_id].y+ry);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[eax+edx*8+4]
	addss	xmm0, DWORD PTR _ry$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[ecx+eax*8]
	addss	xmm0, DWORD PTR _rx$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	ecx
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMMPAM0MM@Z		; AdjustOffset
	add	esp, 24					; 00000018H

; 1160 : 				AdjustOffset(battalionCommand->icosh, battalionCommand->isinh, &ideal_x, &ideal_y, PlatoonFormations[formation][platoon_id].x, PlatoonFormations[formation][platoon_id].y);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	movss	xmm0, DWORD PTR ?PlatoonFormations@@3PAY03UAIOffsetType@@A[edx+ecx*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	ecx
	movss	xmm0, DWORD PTR ?PlatoonFormations@@3PAY03UAIOffsetType@@A[eax+edx*8]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	ecx
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMMPAM0MM@Z		; AdjustOffset
	add	esp, 24					; 00000018H

; 1161 : 				AdjustOffset(battalionCommand->icosh, battalionCommand->isinh, &ideal_x, &ideal_y, SquadFormations[formation][squad_id].x, SquadFormations[formation][squad_id].y);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	ecx
	movss	xmm0, DWORD PTR ?SquadFormations@@3PAY02UAIOffsetType@@A[ecx+eax*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	movss	xmm0, DWORD PTR ?SquadFormations@@3PAY02UAIOffsetType@@A[edx+ecx*8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMMPAM0MM@Z		; AdjustOffset
	add	esp, 24					; 00000018H
$LN3@Order_Squa:

; 1162 : 			}
; 1163 : 		}
; 1164 : 	}

	jmp	SHORT $LN1@Order_Squa
$LN7@Order_Squa:

; 1165 : 	else if (!(moveFlags & GNDAI_MOVE_FIXED_POSITIONS))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, 8
	jne	SHORT $LN1@Order_Squa

; 1166 : 	{
; 1167 : 		ideal_h = leader->ideal_h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx
$LN1@Order_Squa:

; 1168 : 	}
; 1169 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Order_Squad@GNDAIClass@@QAEXXZ ENDP			; GNDAIClass::Order_Squad
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Order_Platoon@GNDAIClass@@QAEXXZ PROC			; GNDAIClass::Order_Platoon
; _this$ = ecx

; 1103 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 	ShiAssert( battalionCommand );	// This should always be TRUE, right?
; 1105 : 
; 1106 : 	if (moveState != GNDAI_MOVE_HALTED)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	$LN7@Order_Plat

; 1107 : 	{
; 1108 : 		// We can move, so get into formation
; 1109 : 		formation = battalionCommand->formation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 1110 : 		if (formation != GNDAI_FORM_COLUMN || !CheckThrough())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 1
	jne	SHORT $LN5@Order_Plat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckThrough@GNDAIClass@@QAEHXZ	; GNDAIClass::CheckThrough
	test	eax, eax
	jne	$LN3@Order_Plat
$LN5@Order_Plat:

; 1111 : 		{
; 1112 : 			if (InPosition(this))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?InPosition@@YAHPAVGNDAIClass@@@Z	; InPosition
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Order_Plat

; 1113 : 			{
; 1114 : 				// Just rotate in place, if we're in position already
; 1115 : 				ideal_h = leader->ideal_h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx

; 1116 : 			}
; 1117 : 			else

	jmp	$LN3@Order_Plat
$LN4@Order_Plat:

; 1118 : 			{
; 1119 : 				// Otherwise, move out.
; 1120 : 				ideal_x = leader->ideal_x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], edx

; 1121 : 				ideal_y = leader->ideal_y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+32], eax

; 1122 : 				AdjustOffset(battalionCommand->icosh, battalionCommand->isinh, &ideal_x, &ideal_y, CompanyFormations[formation][company_id].x, CompanyFormations[formation][company_id].y);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[edx+ecx*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	ecx
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[eax+edx*8]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	ecx
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMMPAM0MM@Z		; AdjustOffset
	add	esp, 24					; 00000018H

; 1123 : 				AdjustOffset(battalionCommand->icosh, battalionCommand->isinh, &ideal_x, &ideal_y, PlatoonFormations[formation][platoon_id].x, PlatoonFormations[formation][platoon_id].y);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	ecx
	movss	xmm0, DWORD PTR ?PlatoonFormations@@3PAY03UAIOffsetType@@A[ecx+eax*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	movss	xmm0, DWORD PTR ?PlatoonFormations@@3PAY03UAIOffsetType@@A[edx+ecx*8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+52]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+48]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMMPAM0MM@Z		; AdjustOffset
	add	esp, 24					; 00000018H
$LN3@Order_Plat:

; 1124 : 			}
; 1125 : 		}
; 1126 : 	}

	jmp	SHORT $LN1@Order_Plat
$LN7@Order_Plat:

; 1127 : 	else if (!(moveFlags & GNDAI_MOVE_FIXED_POSITIONS))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, 8
	jne	SHORT $LN1@Order_Plat

; 1128 : 	{
; 1129 : 		ideal_h = leader->ideal_h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx
$LN1@Order_Plat:

; 1130 : 	}
; 1131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Order_Platoon@GNDAIClass@@QAEXXZ ENDP			; GNDAIClass::Order_Platoon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Order_Company@GNDAIClass@@QAEXXZ PROC			; GNDAIClass::Order_Company
; _this$ = ecx

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1074 : 	ShiAssert( battalionCommand );	// This should always be TRUE, right?
; 1075 : 
; 1076 : 	if (moveState != GNDAI_MOVE_HALTED)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	$LN7@Order_Comp

; 1077 : 	{
; 1078 : 		// We can move, so get into formation
; 1079 : 		formation = battalionCommand->formation;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 1080 : 		if (formation != GNDAI_FORM_COLUMN || !CheckThrough())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 1
	jne	SHORT $LN5@Order_Comp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckThrough@GNDAIClass@@QAEHXZ	; GNDAIClass::CheckThrough
	test	eax, eax
	jne	$LN3@Order_Comp
$LN5@Order_Comp:

; 1081 : 		{
; 1082 : 			if (InPosition(this))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?InPosition@@YAHPAVGNDAIClass@@@Z	; InPosition
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Order_Comp

; 1083 : 			{
; 1084 : 				// Just rotate in place, if we're in position already
; 1085 : 				ideal_h = leader->ideal_h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+36], ecx

; 1086 : 			}
; 1087 : 			else

	jmp	$LN3@Order_Comp
$LN4@Order_Comp:

; 1088 : 			{
; 1089 : 				// Otherwise, move out.
; 1090 : 				ideal_x = leader->ideal_x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], edx

; 1091 : 				ideal_y = leader->ideal_y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+32], eax

; 1092 : 				AdjustOffset(battalionCommand->icosh, battalionCommand->isinh, &ideal_x, &ideal_y, CompanyFormations[formation][company_id].x, CompanyFormations[formation][company_id].y);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[edx+ecx*8+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	ecx
	movss	xmm0, DWORD PTR ?CompanyFormations@@3PAY03UAIOffsetType@@A[eax+edx*8]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	ecx
	movss	xmm0, DWORD PTR [eax+52]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	ecx
	movss	xmm0, DWORD PTR [edx+48]
	movss	DWORD PTR [esp], xmm0
	call	?AdjustOffset@@YAXMMPAM0MM@Z		; AdjustOffset
	add	esp, 24					; 00000018H
$LN3@Order_Comp:

; 1093 : 			}
; 1094 : 		}
; 1095 : 	}

	jmp	SHORT $LN1@Order_Comp
$LN7@Order_Comp:

; 1096 : 	else if (!(moveFlags & GNDAI_MOVE_FIXED_POSITIONS))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, 8
	jne	SHORT $LN1@Order_Comp

; 1097 : 	{
; 1098 : 		ideal_h = leader->ideal_h;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+36], edx
$LN1@Order_Comp:

; 1099 : 	}
; 1100 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Order_Company@GNDAIClass@@QAEXXZ ENDP			; GNDAIClass::Order_Company
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_trig$ = -120						; size = 8
tv836 = -112						; size = 4
tv829 = -108						; size = 4
tv803 = -104						; size = 4
tv796 = -100						; size = 4
tv756 = -96						; size = 4
tv750 = -92						; size = 4
tv710 = -88						; size = 4
tv913 = -84						; size = 4
tv705 = -80						; size = 4
tv699 = -76						; size = 4
tv911 = -72						; size = 4
tv694 = -68						; size = 4
tv677 = -64						; size = 4
tv670 = -60						; size = 4
_closeToRange$ = -56					; size = 4
tv269 = -52						; size = 4
tv182 = -48						; size = 4
_delta$ = -44						; size = 4
_o$ = -40						; size = 4
_distToDestSqu$ = -36					; size = 4
_i$ = -32						; size = 4
_j$ = -28						; size = 4
_deltaX$ = -24						; size = 4
_deltaY$ = -20						; size = 4
_this$ = -16						; size = 4
_cx$1 = -12						; size = 2
_cy$2 = -8						; size = 2
_onWater$3 = -1						; size = 1
?Order_Battalion@GNDAIClass@@QAEXXZ PROC		; GNDAIClass::Order_Battalion
; _this$ = ecx

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 897  : 	float deltaX, deltaY;
; 898  : 	float distToDestSqu,closeToRange;
; 899  : 	mlTrig	trig;
; 900  : 	Objective o;
; 901  : 	int i,j;
; 902  : 	int delta = 1-g_nlookAroundWaterTiles;

	mov	eax, 1
	sub	eax, DWORD PTR ?g_nlookAroundWaterTiles@@3HA ; g_nlookAroundWaterTiles
	mov	DWORD PTR _delta$[ebp], eax

; 903  : 
; 904  : 
; 905  : 	moveFlags |= GNDAI_MOVE_BATTALION;		// We're the battalion lead

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx

; 906  : 
; 907  : 	// are we halted?
; 908  : 	if (moveState == GNDAI_MOVE_HALTED)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN39@Order_Batt

; 909  : 	{
; 910  : 		deltaX = deltaY = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _deltaY$[ebp], xmm0
	movss	xmm0, DWORD PTR _deltaY$[ebp]
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 911  : 		ideal_x = self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 912  : 		ideal_y = self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+32]

; 913  : 		distToDestSqu = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _distToDestSqu$[ebp], xmm0

; 914  : 	}
; 915  : 	else

	jmp	$LN37@Order_Batt
$LN39@Order_Batt:

; 916  : 	{
; 917  : 		parent_unit->SimSetLocation(self->XPos(),self->YPos(),0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+556]
	call	eax

; 918  : 		deltaX = (ideal_x - self->XPos());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv670[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	subss	xmm0, DWORD PTR tv670[ebp]
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 919  : 		deltaY = (ideal_y - self->YPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv677[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	subss	xmm0, DWORD PTR tv677[ebp]
	movss	DWORD PTR _deltaY$[ebp], xmm0

; 920  : 		distToDestSqu = deltaX * deltaX + deltaY * deltaY;

	movss	xmm0, DWORD PTR _deltaX$[ebp]
	mulss	xmm0, DWORD PTR _deltaX$[ebp]
	movss	xmm1, DWORD PTR _deltaY$[ebp]
	mulss	xmm1, DWORD PTR _deltaY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _distToDestSqu$[ebp], xmm0

; 921  : 		if ( distToDestSqu < 50.0f )

	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR _distToDestSqu$[ebp]
	jbe	$LN37@Order_Batt

; 922  : 		{
; 923  : 			// Move towards other ground targets (first priority)
; 924  : 			if ( self->targetPtr && self->targetPtr->BaseData()->OnGround() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	cmp	DWORD PTR [eax+656], 0
	je	$LN36@Order_Batt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv182[ebp], eax
	mov	eax, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv182[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN36@Order_Batt

; 925  : 			{
; 926  : 				deltaX = self->targetPtr->BaseData()->XPos()  - self->XPos() ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv694[ebp]
	movss	xmm0, DWORD PTR tv694[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	movss	DWORD PTR tv911[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv699[ebp]
	movss	xmm0, DWORD PTR tv911[ebp]
	subss	xmm0, DWORD PTR tv699[ebp]
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 927  : 				deltaY = self->targetPtr->BaseData()->YPos()  - self->YPos() ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv705[ebp]
	movss	xmm0, DWORD PTR tv705[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	movss	DWORD PTR tv913[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv710[ebp]
	movss	xmm0, DWORD PTR tv913[ebp]
	subss	xmm0, DWORD PTR tv710[ebp]
	movss	DWORD PTR _deltaY$[ebp], xmm0

; 928  : 				ideal_h = (float)atan2(deltaY, deltaX);

	cvtss2sd xmm0, DWORD PTR _deltaX$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _deltaY$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+36]

; 929  : 				// KCK: Stopping when in range wasn't really working (A unit with one artillery peice would
; 930  : 				// sit and snipe out of range of the majority of it's vehicles).
; 931  : 				// I'm going to try determining what to do by role type:
; 932  : 				// Basically, if we're attacking we'll close to 1 km range, otherwise, we'll stop
; 933  : 				// when within max range. That way defenders will sit still, artillery will sit still, but attackers
; 934  : 				// will always close to minimum range.
; 935  : 				if (parent_unit->GetUnitCurrentRole() == GRO_ATTACK)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+672]
	call	eax
	cmp	eax, 1
	jne	SHORT $LN35@Order_Batt

; 936  : 					closeToRange = KM_TO_FT;

	movss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _closeToRange$[ebp], xmm0

; 937  : 				else

	jmp	SHORT $LN34@Order_Batt
$LN35@Order_Batt:

; 938  : 					closeToRange = parent_unit->GetWeaponRange(self->targetPtr->BaseData()->GetMovementType())*KM_TO_FT - KM_TO_FT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv269[ebp], eax
	push	0
	mov	eax, DWORD PTR tv269[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv269[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+408]
	call	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@454cffae
	subss	xmm0, DWORD PTR __real@454cffae
	movss	DWORD PTR _closeToRange$[ebp], xmm0
$LN34@Order_Batt:

; 939  : 				if ( self->targetPtr->localData->range < closeToRange)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+656]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR _closeToRange$[ebp]
	comiss	xmm0, DWORD PTR [ecx+44]
	jbe	SHORT $LN33@Order_Batt

; 940  : 				{
; 941  : 					distToDestSqu = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _distToDestSqu$[ebp], xmm0

; 942  : 					deltaX = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 943  : 					deltaY = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _deltaY$[ebp], xmm0

; 944  : 					ideal_x = self->XPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 945  : 					ideal_y = self->YPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+32]

; 946  : 				}
; 947  : 				else

	jmp	SHORT $LN32@Order_Batt
$LN33@Order_Batt:

; 948  : 				{
; 949  : 					deltaX *= 0.25f;

	movss	xmm0, DWORD PTR _deltaX$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 950  : 					deltaY *= 0.25f;

	movss	xmm0, DWORD PTR _deltaY$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _deltaY$[ebp], xmm0

; 951  : 					ideal_x = self->XPos() + deltaX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv750[ebp]
	movss	xmm0, DWORD PTR tv750[ebp]
	addss	xmm0, DWORD PTR _deltaX$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+28], xmm0

; 952  : 					ideal_y = self->YPos() + deltaY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv756[ebp]
	movss	xmm0, DWORD PTR tv756[ebp]
	addss	xmm0, DWORD PTR _deltaY$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+32], xmm0
$LN32@Order_Batt:

; 953  : 				}

	jmp	$LN25@Order_Batt
$LN36@Order_Batt:

; 954  : 			}
; 955  : 			else if ((moveState == GNDAI_MOVE_GENERAL) && parent_unit)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 2
	jne	$LN30@Order_Batt
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN30@Order_Batt

; 956  : 			{
; 957  : 				// Follow path
; 958  : 				lastGridX = gridX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+112]
	mov	WORD PTR [eax+116], dx

; 959  : 				lastGridY = gridY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+114]
	mov	WORD PTR [eax+118], dx

; 960  : 				// Update the parent battalion's position
; 961  : 				formation = (GNDAIFormType) parent_unit->GetUnitFormation();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 962  : 				parent_unit->GetLocation (&gridX, &gridY);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 114				; 00000072H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 963  : 				moveDir = parent_unit->GetNextMoveDirection();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+920]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], eax

; 964  : 				through_x = through_y = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+44], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 965  : 				if (moveDir < 8)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+120], 8
	jge	$LN29@Order_Batt

; 966  : 				{
; 967  : 					// 2002-02-16 MN Aaaaaaaahh - WHO DID THIS BS - THEY MUST HAVE BEEN DRUNK !!! 
; 968  : 					// Look what they have done: since when are Sim coordinates SHORT ??? No wonder the ground units move strangely...
; 969  : 					// GridToSim returns a float !!! And ideal_x/y are floats, too... Aaaaaaaaaaaaahhhhh....;-)
; 970  : 					//					ideal_y = (short)GridToSim(gridX + dx[moveDir]);
; 971  : 					//					ideal_x = (short)GridToSim(gridY + dy[moveDir]);
; 972  : 					ideal_y = GridToSim(gridX + dx[moveDir]);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	movsx	ecx, WORD PTR ?dx@@3PAFA[edx*2]
	add	eax, ecx
	push	eax
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+32]

; 973  : 					ideal_x = GridToSim(gridY + dy[moveDir]);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+114]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	movsx	edx, WORD PTR ?dy@@3PAFA[eax*2]
	add	ecx, edx
	push	ecx
	call	?GridToSim@@YAMF@Z			; GridToSim
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+28]

; 974  : 					deltaX = ideal_x - self->XPos() ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv796[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	subss	xmm0, DWORD PTR tv796[ebp]
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 975  : 					deltaY = ideal_y - self->YPos() ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv803[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+32]
	subss	xmm0, DWORD PTR tv803[ebp]
	movss	DWORD PTR _deltaY$[ebp], xmm0

; 976  : 					if (formation == GNDAI_FORM_COLUMN)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 1
	jne	SHORT $LN28@Order_Batt

; 977  : 					{
; 978  : 						through_x = self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+40]

; 979  : 						through_y = self->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+44]
$LN28@Order_Batt:

; 980  : 					}
; 981  : 					ideal_h = moveDir*45*DTR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	imul	edx, 45					; 0000002dH
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3c8efa34
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 982  : 				}
; 983  : 				else

	jmp	SHORT $LN27@Order_Batt
$LN29@Order_Batt:

; 984  : 				{
; 985  : 					// Force the battalion to do an update on the next Campaign update, if we don't
; 986  : 					// have a destination (NOTE: Often no destination is fine, but this isn't very
; 987  : 					// heavy anyway).
; 988  : 					((Battalion)self->GetCampaignObject())->SetLastCheck(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?SetLastCheck@UnitClass@@QAEXK@Z	; UnitClass::SetLastCheck
$LN27@Order_Batt:

; 989  : 				}

	jmp	$LN25@Order_Batt
$LN30@Order_Batt:

; 990  : 				//				MonoPrint("Battalion Following Path: Next move = %d, heading = %3.3f\n",moveDir,ideal_h);
; 991  : 			}
; 992  : 			else if (self->curWaypoint)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	cmp	DWORD PTR [eax+728], 0
	je	$LN25@Order_Batt

; 993  : 			{
; 994  : 				// Follow waypoints
; 995  : 				self->curWaypoint->GetLocation(&ideal_x, &ideal_y, &ideal_h);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+728]
	call	?GetLocation@WayPointClass@@QBEXPAM00@Z	; WayPointClass::GetLocation

; 996  : 				deltaX = ideal_x - self->XPos() ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv829[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+28]
	subss	xmm0, DWORD PTR tv829[ebp]
	movss	DWORD PTR _deltaX$[ebp], xmm0

; 997  : 				deltaY = ideal_y - self->YPos() ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv836[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	subss	xmm0, DWORD PTR tv836[ebp]
	movss	DWORD PTR _deltaY$[ebp], xmm0

; 998  : 				ideal_h = (float)atan2(deltaY, deltaX);

	cvtss2sd xmm0, DWORD PTR _deltaX$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _deltaY$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+36]
$LN25@Order_Batt:

; 999  : 			}
; 1000 : 			// Calculate our trig values for formation offsets
; 1001 : 			mlSinCos (&trig, ideal_h);

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+36]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1002 : 			isinh = trig.sin;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [ecx+52], xmm0

; 1003 : 			icosh = trig.cos;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [edx+48], xmm0

; 1004 : 			distToDestSqu = deltaX * deltaX + deltaY * deltaY;

	movss	xmm0, DWORD PTR _deltaX$[ebp]
	mulss	xmm0, DWORD PTR _deltaX$[ebp]
	movss	xmm1, DWORD PTR _deltaY$[ebp]
	mulss	xmm1, DWORD PTR _deltaY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _distToDestSqu$[ebp], xmm0
$LN37@Order_Batt:

; 1005 : 		}
; 1006 : 	}
; 1007 : 
; 1008 : 	// determine our next location's terrain type
; 1009 : 	if (distToDestSqu)

	movss	xmm0, DWORD PTR _distToDestSqu$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN1@Order_Batt

; 1010 : 	{
; 1011 : 		// KCK: For simplicity, I'm going to check current tile's coverage. This should be
; 1012 : 		// enough for our purposes until we get bridges to work.
; 1013 : 		GridIndex	cx,cy;
; 1014 : 		ShiAssert(parent_unit);
; 1015 : 		parent_unit->GetLocation(&cx,&cy);

	lea	eax, DWORD PTR _cy$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _cx$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1016 : 		// 2002-02-23 MN Let ground units traverse the water when there is a bridge - now that they move correctly...
; 1017 : 		o = GetObjectiveByXY(cx,cy);

	movzx	eax, WORD PTR _cy$2[ebp]
	push	eax
	movzx	ecx, WORD PTR _cx$1[ebp]
	push	ecx
	call	?GetObjectiveByXY@@YAPAVObjectiveClass@@FF@Z ; GetObjectiveByXY
	add	esp, 8
	mov	DWORD PTR _o$[ebp], eax

; 1018 : 		// we may have 3 tile bridges in the future, so use g_nlookAroundWaterTiles instead of hardcoding
; 1019 : 		if (!o) // can be at 2 tile bridges -> scan around our parent units location for a bridge

	cmp	DWORD PTR _o$[ebp], 0
	jne	SHORT $LN20@Order_Batt

; 1020 : 		{
; 1021 : 			for (j=delta; j<g_nlookAroundWaterTiles; j++){

	mov	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $LN22@Order_Batt
$LN21@Order_Batt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@Order_Batt:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR ?g_nlookAroundWaterTiles@@3HA ; g_nlookAroundWaterTiles
	jge	SHORT $LN20@Order_Batt

; 1022 : 				for (i=delta; i<g_nlookAroundWaterTiles; i++){

	mov	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN19@Order_Batt
$LN18@Order_Batt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@Order_Batt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?g_nlookAroundWaterTiles@@3HA ; g_nlookAroundWaterTiles
	jge	SHORT $LN17@Order_Batt

; 1023 : 					if (GetCover(cx+i,cy+j) != Water){

	movsx	edx, WORD PTR _cy$2[ebp]
	add	edx, DWORD PTR _j$[ebp]
	push	edx
	movsx	eax, WORD PTR _cx$1[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?GetCover@@YA?AW4CoverType@@FF@Z	; GetCover
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@Order_Batt

; 1024 : 						continue;

	jmp	SHORT $LN18@Order_Batt
$LN16@Order_Batt:

; 1025 : 					}
; 1026 : 					o = GetObjectiveByXY(cx+i,cy+j);

	movsx	ecx, WORD PTR _cy$2[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	push	ecx
	movsx	edx, WORD PTR _cx$1[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?GetObjectiveByXY@@YAPAVObjectiveClass@@FF@Z ; GetObjectiveByXY
	add	esp, 8
	mov	DWORD PTR _o$[ebp], eax

; 1027 : 					if (o){

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN15@Order_Batt

; 1028 : 						goto FoundBridge;

	jmp	SHORT $LN14@Order_Batt
	jmp	SHORT $FoundBridge$42
$LN15@Order_Batt:

; 1029 : 					}
; 1030 : 				}

	jmp	SHORT $LN18@Order_Batt
$LN17@Order_Batt:

; 1031 : 			}

	jmp	SHORT $LN21@Order_Batt
$LN20@Order_Batt:
$LN14@Order_Batt:
$FoundBridge$42:

; 1032 : 		}
; 1033 : FoundBridge:
; 1034 : 		if ( parent_unit->IsBattalion() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	je	SHORT $LN13@Order_Batt

; 1035 : 		{
; 1036 : 			if (GetCover(cx,cy) == Water && !(o && o->GetType() == TYPE_BRIDGE))

	movzx	eax, WORD PTR _cy$2[ebp]
	push	eax
	movzx	ecx, WORD PTR _cx$1[ebp]
	push	ecx
	call	?GetCover@@YA?AW4CoverType@@FF@Z	; GetCover
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@Order_Batt
	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN11@Order_Batt
	mov	ecx, DWORD PTR _o$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 6
	je	SHORT $LN12@Order_Batt
$LN11@Order_Batt:

; 1037 : 			{
; 1038 : 				// that's it, we don't move anymore
; 1039 : 				moveState = GNDAI_MOVE_HALTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 0

; 1040 : 				ideal_x = self->XPos();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+28]

; 1041 : 				ideal_y = self->YPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]
$LN12@Order_Batt:

; 1042 : 			}
; 1043 : 
; 1044 : 		}
; 1045 : 		else // task force

	jmp	$LN1@Order_Batt
$LN13@Order_Batt:

; 1046 : 		{
; 1047 : 			// MN also look around tiles from the taskforce - should prevent having ships going on land
; 1048 : 			bool onWater = true;

	mov	BYTE PTR _onWater$3[ebp], 1

; 1049 : 			for (j=delta; j<g_nlookAroundWaterTiles; j++)

	mov	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $LN9@Order_Batt
$LN8@Order_Batt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@Order_Batt:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR ?g_nlookAroundWaterTiles@@3HA ; g_nlookAroundWaterTiles
	jge	SHORT $LN7@Order_Batt

; 1050 : 			{
; 1051 : 				for (i=delta; i<g_nlookAroundWaterTiles; i++)

	mov	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN6@Order_Batt
$LN5@Order_Batt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Order_Batt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR ?g_nlookAroundWaterTiles@@3HA ; g_nlookAroundWaterTiles
	jge	SHORT $LN4@Order_Batt

; 1052 : 				{
; 1053 : 					if (GetCover(cx+i,cy+j) == Water)

	movsx	edx, WORD PTR _cy$2[ebp]
	add	edx, DWORD PTR _j$[ebp]
	push	edx
	movsx	eax, WORD PTR _cx$1[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?GetCover@@YA?AW4CoverType@@FF@Z	; GetCover
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@Order_Batt

; 1054 : 						continue;

	jmp	SHORT $LN5@Order_Batt
$LN3@Order_Batt:

; 1055 : 					onWater = false;

	mov	BYTE PTR _onWater$3[ebp], 0

; 1056 : 					goto NearCoast;

	jmp	SHORT $LN2@Order_Batt
	jmp	SHORT $NearCoast$43

; 1057 : 				}

	jmp	SHORT $LN5@Order_Batt
$LN4@Order_Batt:

; 1058 : 			}

	jmp	SHORT $LN8@Order_Batt
$LN7@Order_Batt:
$LN2@Order_Batt:
$NearCoast$43:

; 1059 : NearCoast:
; 1060 : 			if (!onWater)

	movzx	ecx, BYTE PTR _onWater$3[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@Order_Batt

; 1061 : 			{
; 1062 : 				// that's it, we don't move anymore
; 1063 : 				moveState = GNDAI_MOVE_HALTED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 0

; 1064 : 				ideal_x = self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+28]

; 1065 : 				ideal_y = self->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+32]
$LN1@Order_Batt:

; 1066 : 			}
; 1067 : 
; 1068 : 		}
; 1069 : 	}
; 1070 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Order_Battalion@GNDAIClass@@QAEXXZ ENDP		; GNDAIClass::Order_Battalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newLeader$ = 8						; size = 4
?SetLeader@GNDAIClass@@QAEXPAV1@@Z PROC			; GNDAIClass::SetLeader
; _this$ = ecx

; 422  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 	leader = newLeader;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newLeader$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 424  : 	/*	GNDAIClass* oldLeader = leader;
; 425  : 
; 426  : 	// edg: don't reference/deref if ourself
; 427  : 	if (newLeader != oldLeader)
; 428  : 	{
; 429  : 	leader = newLeader;
; 430  : 	if (oldLeader && oldLeader->self != self)
; 431  : 	{
; 432  : 	VuDeReferenceEntity(oldLeader->self);
; 433  : 	}
; 434  : 	if (newLeader)
; 435  : 	{
; 436  : 	if ( newLeader->self != self )
; 437  : 	VuReferenceEntity(newLeader->self);
; 438  : 	formation = newLeader->formation;
; 439  : 	}
; 440  : 	}
; 441  : 	*/
; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetLeader@GNDAIClass@@QAEXPAV1@@Z ENDP			; GNDAIClass::SetLeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_sit$2 = -256						; size = 12
$T3 = -244						; size = 4
$T4 = -240						; size = 4
$T5 = -236						; size = 4
_d$6 = -232						; size = 4
_tmpTarget$7 = -228					; size = 4
_theWeapon$8 = -224					; size = 4
tv1138 = -220						; size = 4
tv157 = -216						; size = 4
_det$9 = -212						; size = 4
tv256 = -208						; size = 4
_bestReact$10 = -204					; size = 4
tv197 = -200						; size = 4
$T11 = -196						; size = 4
tv569 = -192						; size = 4
_react$12 = -188					; size = 4
tv491 = -184						; size = 4
$T13 = -180						; size = 4
tv347 = -176						; size = 4
$T14 = -172						; size = 4
tv755 = -168						; size = 4
tv192 = -164						; size = 4
_session$15 = -160					; size = 4
_oldUnit$ = -156					; size = 4
_best$16 = -152						; size = 4
_newUnit$ = -148					; size = 4
_localData$17 = -144					; size = 4
tv764 = -140						; size = 4
_range$18 = -136					; size = 4
_localData$19 = -132					; size = 4
_i$20 = -128						; size = 4
_who$21 = -121						; size = 1
_campTargetEntity$ = -120				; size = 4
_player$22 = -116					; size = 4
_newTarget$ = -112					; size = 4
_detecting$23 = -106					; size = 1
_tracking$24 = -105					; size = 1
_radar$25 = -104					; size = 4
_this$ = -100						; size = 4
_buf$26 = -96						; size = 40
_label$27 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ProcessTargeting@GNDAIClass@@QAEXXZ PROC		; GNDAIClass::ProcessTargeting
; _this$ = ecx

; 500  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProcessTargeting@GNDAIClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 501  : 	FalconEntity	*campTargetEntity;
; 502  : 	SimObjectType	*newTarget;
; 503  : 
; 504  : 	// If we're towed and moving, don't bother holding a target
; 505  : 	// This will prevent us from shooting on the move...
; 506  : 	// TODO:  Make the moving state a discrete
; 507  : 	//        flag so the visual object can change state
; 508  : 	//        too.  Should have an intermediate state with
; 509  : 	//        no motion OR firing to model "set up/tear down".
; 510  : 	if (self->isTowed && (self->GetVt() > 0.1f) && !g_bFireOntheMove) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+772]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN69@ProcessTar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+72]
	mov	edx, DWORD PTR [eax+220]
	call	edx
	fstp	DWORD PTR tv1138[ebp]
	movss	xmm0, DWORD PTR tv1138[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN69@ProcessTar
	movzx	eax, BYTE PTR ?g_bFireOntheMove@@3_NA	; g_bFireOntheMove
	test	eax, eax
	jne	SHORT $LN69@ProcessTar

; 511  : 		self->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget

; 512  : 		return;

	jmp	$LN70@ProcessTar
$LN69@ProcessTar:

; 513  : 	}
; 514  : 
; 515  : 	// Are we the battalion commander?
; 516  : 	if ( this == battalionCommand ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+80]
	jne	$LN59@ProcessTar

; 517  : 		parent_unit->UnsetChecked();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?UnsetChecked@CampBaseClass@@QAEXXZ	; CampBaseClass::UnsetChecked

; 518  : 		parent_unit->ChooseTarget();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+524]
	call	eax

; 519  : 
; 520  : 		// Get the battalion's ground target (if any)
; 521  : 		campTargetEntity = parent_unit->GetTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ; UnitClass::GetTarget
	mov	DWORD PTR _campTargetEntity$[ebp], eax

; 522  : 		if (campTargetEntity){

	cmp	DWORD PTR _campTargetEntity$[ebp], 0
	je	$LN67@ProcessTar

; 523  : 			// Create our shared ground target object (campaign target)
; 524  : 			if (!gndTargetPtr || gndTargetPtr->BaseData() != campTargetEntity){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+132], 0
	je	SHORT $LN65@ProcessTar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	eax, DWORD PTR _campTargetEntity$[ebp]
	je	SHORT $LN66@ProcessTar
$LN65@ProcessTar:

; 525  : 				SetGroundTarget( new SimObjectType(campTargetEntity) );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN72@ProcessTar
	mov	ecx, DWORD PTR _campTargetEntity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0SimObjectType@@QAE@PAVFalconEntity@@@Z ; SimObjectType::SimObjectType
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN73@ProcessTar
$LN72@ProcessTar:
	mov	DWORD PTR tv157[ebp], 0
$LN73@ProcessTar:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetGroundTarget
$LN66@ProcessTar:

; 526  : 			}
; 527  : 
; 528  : 			// KCK: As far as I can see, only range.ataFrom,az and el are being used from here.
; 529  : 			// Seems like we can just do those here for our targetPtr -
; 530  : 			CalcRelAzElRangeAta (self, gndTargetPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	?CalcRelAzElRangeAta@@YAXPAVSimBaseClass@@PAVSimObjectType@@@Z ; CalcRelAzElRangeAta
	add	esp, 8

; 531  : 		}
; 532  : 		else {

	jmp	SHORT $LN64@ProcessTar
$LN67@ProcessTar:

; 533  : 			SetGroundTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetGroundTarget
$LN64@ProcessTar:

; 534  : 		}
; 535  : 
; 536  : 		// Get the battalion's air target (if any)
; 537  : 		campTargetEntity = parent_unit->GetAirTarget();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+656]
	call	eax
	mov	DWORD PTR _campTargetEntity$[ebp], eax

; 538  : 		if (campTargetEntity){

	cmp	DWORD PTR _campTargetEntity$[ebp], 0
	je	$LN63@ProcessTar

; 539  : 			// Create our shared ground target object (campaign target)
; 540  : 			if (!airTargetPtr || airTargetPtr->BaseData() != campTargetEntity){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $LN61@ProcessTar
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+136]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	eax, DWORD PTR _campTargetEntity$[ebp]
	je	SHORT $LN62@ProcessTar
$LN61@ProcessTar:

; 541  : 				SetAirTarget( new SimObjectType(campTargetEntity) );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T13[ebp], 0
	je	SHORT $LN74@ProcessTar
	mov	eax, DWORD PTR _campTargetEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T13[ebp]
	call	??0SimObjectType@@QAE@PAVFalconEntity@@@Z ; SimObjectType::SimObjectType
	mov	DWORD PTR tv192[ebp], eax
	jmp	SHORT $LN75@ProcessTar
$LN74@ProcessTar:
	mov	DWORD PTR tv192[ebp], 0
$LN75@ProcessTar:
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetAirTarget
$LN62@ProcessTar:

; 542  : 			}
; 543  : 
; 544  : 			// 2000-09-11 ADDED BY S.G. SO WE GET THE azFrom and elFrom as well when the target is jamming
; 545  : 			if (airTargetPtr->BaseData()->IsSPJamming()) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv197[ebp], eax
	mov	ecx, DWORD PTR tv197[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv197[ebp]
	mov	eax, DWORD PTR [edx+268]
	call	eax
	test	eax, eax
	je	SHORT $LN60@ProcessTar

; 546  : 				// The next statement will set az, el, ata, ataFrom and range to what ground unit needs and leave
; 547  : 				// what we require (azFrom and elFrom) intact.
; 548  : 				// May be a new function just calculating that would be better...
; 549  : 				SimObjectType *tmpTarget = airTargetPtr->next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _tmpTarget$7[ebp], eax

; 550  : 				airTargetPtr->next = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	DWORD PTR [edx+16], 0

; 551  : 				CalcRelGeom(self, airTargetPtr, NULL, 1.0F / SimLibMajorFrameTime);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR ?SimLibMajorFrameTime@@3MA
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	?CalcRelGeom@@YAXPAVSimBaseClass@@PAVSimObjectType@@QAY02MM@Z ; CalcRelGeom
	add	esp, 16					; 00000010H

; 552  : 				airTargetPtr->next = tmpTarget;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	eax, DWORD PTR _tmpTarget$7[ebp]
	mov	DWORD PTR [edx+16], eax
$LN60@ProcessTar:

; 553  : 			}
; 554  : 			// END OF ADDED SECTION
; 555  : 
; 556  : 			// KCK: As far as I can see, only range.ataFrom,az and el are being used from here.
; 557  : 			// Seems like we can just do those here for our targetPtr
; 558  : 			CalcRelAzElRangeAta (self, airTargetPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	?CalcRelAzElRangeAta@@YAXPAVSimBaseClass@@PAVSimObjectType@@@Z ; CalcRelAzElRangeAta
	add	esp, 8

; 559  : 		}
; 560  : 		else {

	jmp	$LN59@ProcessTar
$LN63@ProcessTar:

; 561  : 			AircraftClass		*player;
; 562  : 			AircraftClass		*best = NULL;

	mov	DWORD PTR _best$16[ebp], 0

; 563  : 			int		bestReact = 1;

	mov	DWORD PTR _bestReact$10[ebp], 1

; 564  : 			Team	who = self->GetTeam();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _who$21[ebp], al

; 565  : 			VuSessionsIterator		sit(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN76@ProcessTar
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN77@ProcessTar
$LN76@ProcessTar:
	mov	DWORD PTR tv256[ebp], 0
$LN77@ProcessTar:
	mov	edx, DWORD PTR tv256[ebp]
	push	edx
	lea	ecx, DWORD PTR _sit$2[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 566  : 			FalconSessionEntity* session = (FalconSessionEntity*) sit.GetFirst();

	lea	ecx, DWORD PTR _sit$2[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$15[ebp], eax
$LN58@ProcessTar:

; 567  : 			while (session){

	cmp	DWORD PTR _session$15[ebp], 0
	je	$LN57@ProcessTar

; 568  : 				player = (AircraftClass*) session->GetPlayerEntity();

	mov	ecx, DWORD PTR _session$15[ebp]
	call	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
	mov	DWORD PTR _player$22[ebp], eax

; 569  : 				if (player && player->IsAirplane() && GetRoE(who,player->GetTeam(),ROE_GROUND_FIRE) == ROE_ALLOWED){

	cmp	DWORD PTR _player$22[ebp], 0
	je	$LN54@ProcessTar
	mov	eax, DWORD PTR _player$22[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _player$22[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN54@ProcessTar
	push	1
	mov	ecx, DWORD PTR _player$22[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _player$22[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	movzx	edx, BYTE PTR _who$21[ebp]
	push	edx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN54@ProcessTar

; 570  : 					int	react,det;
; 571  : 					float d;
; 572  : 
; 573  : 					det = Detected(parent_unit,player,&d);

	lea	eax, DWORD PTR _d$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$22[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?Detected@@YAHPAVUnitClass@@PAVFalconEntity@@PAM@Z ; Detected
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _det$9[ebp], eax

; 574  : 					//if (det & ENEMY_DETECTED) // JB SOJ
; 575  : 					// 2001-03-24 ADDED BY S.G. NEED TO CHECK IF DETECTED BEFORE WE CAN REACT...
; 576  : 					if (det & REACTION_MASK){

	mov	ecx, DWORD PTR _det$9[ebp]
	and	ecx, 17					; 00000011H
	je	SHORT $LN54@ProcessTar

; 577  : 						// END OF ADDED SECTION EXCEPT FOR INDENTATION
; 578  : 						react = parent_unit->Reaction(player->GetCampaignObject(),det,d);

	push	ecx
	movss	xmm0, DWORD PTR _d$6[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _det$9[ebp]
	push	edx
	mov	ecx, DWORD PTR _player$22[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+484]
	call	edx
	mov	DWORD PTR _react$12[ebp], eax

; 579  : 						if(react > bestReact){

	mov	eax, DWORD PTR _react$12[ebp]
	cmp	eax, DWORD PTR _bestReact$10[ebp]
	jle	SHORT $LN54@ProcessTar

; 580  : 							best = player;

	mov	ecx, DWORD PTR _player$22[ebp]
	mov	DWORD PTR _best$16[ebp], ecx

; 581  : 							// 2001-03-24 ADDED BY S.G. LETS KEEP THIS ONE AS HIGHEST SHALL WE...
; 582  : 							bestReact = react;

	mov	edx, DWORD PTR _react$12[ebp]
	mov	DWORD PTR _bestReact$10[ebp], edx
$LN54@ProcessTar:

; 583  : 							// END OF ADDED SECTION
; 584  : 						}
; 585  : 					}
; 586  : 				}
; 587  : 				session = (FalconSessionEntity*) sit.GetNext();

	lea	ecx, DWORD PTR _sit$2[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$15[ebp], eax

; 588  : 			}

	jmp	$LN58@ProcessTar
$LN57@ProcessTar:

; 589  : 
; 590  : 			if (!best){

	cmp	DWORD PTR _best$16[ebp], 0
	jne	SHORT $LN53@ProcessTar

; 591  : 				SetAirTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetAirTarget

; 592  : 			}
; 593  : 			else {

	jmp	SHORT $LN52@ProcessTar
$LN53@ProcessTar:

; 594  : 				SetAirTarget( new SimObjectType(best) );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN78@ProcessTar
	mov	eax, DWORD PTR _best$16[ebp]
	push	eax
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0SimObjectType@@QAE@PAVFalconEntity@@@Z ; SimObjectType::SimObjectType
	mov	DWORD PTR tv347[ebp], eax
	jmp	SHORT $LN79@ProcessTar
$LN78@ProcessTar:
	mov	DWORD PTR tv347[ebp], 0
$LN79@ProcessTar:
	mov	ecx, DWORD PTR tv347[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetAirTarget

; 595  : 				CalcRelAzElRangeAta (self, airTargetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	?CalcRelAzElRangeAta@@YAXPAVSimBaseClass@@PAVSimObjectType@@@Z ; CalcRelAzElRangeAta
	add	esp, 8
$LN52@ProcessTar:

; 596  : 			}
; 597  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sit$2[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
$LN59@ProcessTar:

; 598  : 
; 599  : 	}
; 600  : 
; 601  : 	// SCR 10/19/98
; 602  : 	// We could assign targets to our subordinates here if we wanted a "push" model where
; 603  : 	// the leader did some intelligent assignment.  For now, we just let each vehicle
; 604  : 	// pick an element of the aggregate target obtained from the leader's AI.
; 605  : 
; 606  : 	// Decide if we want to shoot at the battalion's air or ground target
; 607  : 	// If we are an emitter, we always choose the airtarget
; 608  : 	if (self->isGroundCapable && (!self->isEmitter || self->isShip)) { // JPO let ships decide.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+772]
	shr	eax, 6
	and	eax, 1
	je	$LN51@ProcessTar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+772]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN50@ProcessTar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+772]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN51@ProcessTar
$LN50@ProcessTar:

; 609  : 		if (self->isAirCapable) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+772]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN49@ProcessTar

; 610  : 			// Arbitrarily use a 2:1 distribution for vehicles which can do both
; 611  : 			if ((rand() % 3) > 1)

	call	_rand
	cdq
	mov	ecx, 3
	idiv	ecx
	cmp	edx, 1
	jle	SHORT $LN48@ProcessTar

; 612  : 				newTarget = battalionCommand->gndTargetPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR _newTarget$[ebp], ecx

; 613  : 			else

	jmp	SHORT $LN47@ProcessTar
$LN48@ProcessTar:

; 614  : 				newTarget = battalionCommand->airTargetPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _newTarget$[ebp], ecx
$LN47@ProcessTar:

; 615  : 		} else {

	jmp	SHORT $LN46@ProcessTar
$LN49@ProcessTar:

; 616  : 			newTarget = battalionCommand->gndTargetPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR _newTarget$[ebp], ecx
$LN46@ProcessTar:

; 617  : 		}

	jmp	SHORT $LN42@ProcessTar
$LN51@ProcessTar:

; 618  : 	} else if (self->isAirCapable || self->isEmitter){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+772]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN43@ProcessTar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+772]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN44@ProcessTar
$LN43@ProcessTar:

; 619  : 		newTarget = battalionCommand->airTargetPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _newTarget$[ebp], ecx

; 620  : 	}
; 621  : 	else 

	jmp	SHORT $LN42@ProcessTar
$LN44@ProcessTar:

; 622  : 		newTarget = NULL;

	mov	DWORD PTR _newTarget$[ebp], 0
$LN42@ProcessTar:

; 623  : 
; 624  : 	CampEntity newUnit = NULL;

	mov	DWORD PTR _newUnit$[ebp], 0

; 625  : 	CampEntity oldUnit = NULL;

	mov	DWORD PTR _oldUnit$[ebp], 0

; 626  : 	if (newTarget){

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	SHORT $LN39@ProcessTar

; 627  : 		if(newTarget->BaseData()->IsSim())

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN40@ProcessTar

; 628  : 			newUnit = ((SimBaseClass*)newTarget->BaseData())->GetCampaignObject();

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _newUnit$[ebp], eax

; 629  : 		else

	jmp	SHORT $LN39@ProcessTar
$LN40@ProcessTar:

; 630  : 			newUnit = (CampEntity)newTarget->BaseData();

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR _newUnit$[ebp], eax
$LN39@ProcessTar:

; 631  : 	}
; 632  : 
; 633  : 	if (self->targetPtr){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	cmp	DWORD PTR [eax+656], 0
	je	SHORT $LN36@ProcessTar

; 634  : 		if(self->targetPtr->BaseData()->IsSim())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsSim@FalconEntity@@QAEHXZ		; FalconEntity::IsSim
	test	eax, eax
	je	SHORT $LN37@ProcessTar

; 635  : 			oldUnit = ((SimBaseClass*)self->targetPtr->BaseData())->GetCampaignObject();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _oldUnit$[ebp], eax

; 636  : 		else

	jmp	SHORT $LN36@ProcessTar
$LN37@ProcessTar:

; 637  : 			oldUnit = (CampEntity)self->targetPtr->BaseData();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR _oldUnit$[ebp], eax
$LN36@ProcessTar:

; 638  : 	}
; 639  : 
; 640  : 	// Pick an element of the battalion's aggregate target as our personal target
; 641  : 	//	1. if we don't have a target
; 642  : 	//	2. our target is dead
; 643  : 	//	3. our commander wants us to shoot at another unit
; 644  : 
; 645  : 	// RV - Biker - Switch to next target if we did take a hit (pctStrength <= 0.0f)
; 646  : 	//if(!self->targetPtr || self->targetPtr->BaseData()->IsDead() || newUnit != oldUnit)
; 647  : 	if (
; 648  : 		!self->targetPtr || 
; 649  : 		((SimBaseClass *)self->targetPtr->BaseData())->pctStrength <= 0.0f || 
; 650  : 		self->targetPtr->BaseData()->IsDead() || newUnit != oldUnit
; 651  : 	){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	DWORD PTR [edx+656], 0
	je	SHORT $LN34@ProcessTar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax+292]
	jae	SHORT $LN34@ProcessTar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv491[ebp], eax
	mov	ecx, DWORD PTR tv491[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv491[ebp]
	mov	eax, DWORD PTR [edx+212]
	call	eax
	test	eax, eax
	jne	SHORT $LN34@ProcessTar
	mov	ecx, DWORD PTR _newUnit$[ebp]
	cmp	ecx, DWORD PTR _oldUnit$[ebp]
	je	SHORT $LN35@ProcessTar
$LN34@ProcessTar:

; 652  : 		self->SetTarget( SimCampHandoff( newTarget, self->targetList, HANDOFF_RANDOM ) );

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+660]
	push	ecx
	mov	edx, DWORD PTR _newTarget$[ebp]
	push	edx
	call	?SimCampHandoff@@YAPAVSimObjectType@@PAV1@0W4HandOffType@@@Z ; SimCampHandoff
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
	jmp	SHORT $LN32@ProcessTar
$LN35@ProcessTar:

; 653  : 	}
; 654  : 	else if (self->targetPtr->BaseData()->IsCampaign()){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	ecx, eax
	call	?IsCampaign@FalconEntity@@QAEHXZ	; FalconEntity::IsCampaign
	test	eax, eax
	je	SHORT $LN32@ProcessTar

; 655  : 		self->SetTarget( SimCampHandoff( self->targetPtr, self->targetList, HANDOFF_RANDOM ) );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+660]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	call	?SimCampHandoff@@YAPAVSimObjectType@@PAV1@0W4HandOffType@@@Z ; SimCampHandoff
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
$LN32@ProcessTar:

; 656  : 	}
; 657  : 
; 658  : 	if (self->targetPtr){ 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	DWORD PTR [edx+656], 0
	je	$LN31@ProcessTar

; 659  : 		if (self->isEmitter && !self->targetPtr->BaseData()->OnGround()){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+772]
	shr	edx, 2
	and	edx, 1
	je	$LN6@ProcessTar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	DWORD PTR tv569[ebp], eax
	mov	edx, DWORD PTR tv569[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv569[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	$LN6@ProcessTar

; 660  : 			RadarClass* radar = (RadarClass*)FindSensor( self, SensorClass::Radar );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _radar$25[ebp], eax

; 661  : 			ShiAssert( radar );
; 662  : 			bool tracking = FALSE;

	mov	BYTE PTR _tracking$24[ebp], 0

; 663  : 			bool detecting = FALSE;

	mov	BYTE PTR _detecting$23[ebp], 0

; 664  : 			float range = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _range$18[ebp], xmm0

; 665  : 			int i =0;

	mov	DWORD PTR _i$20[ebp], 0

; 666  : 			/* 2002-03-21 MODIFIED BY S.G. If we're the emitter, we're also the radar's platform. 
; 667  : 			Therefore radar->platform->targetPtr is self->targetPtr. 
; 668  : 			There's an easier way to do this plus do some checks about our target state
; 669  : 			   for (i=0; i<((SimMoverClass*)(SimVehicleClass*)self)->numSensors; i++)
; 670  : 			   {
; 671  : 			   if (radar->platform->targetPtr->localData->sensorState[i]> SensorClass::Detection)
; 672  : 			   tracking = TRUE;
; 673  : 			   if (radar->platform->targetPtr->localData->sensorState[i]>= SensorClass::Detection)
; 674  : 			   detecting = TRUE;
; 675  : 			   if (radar->platform->targetPtr->localData->range > range) 
; 676  : 				range = radar->platform->targetPtr->localData->range ;
; 677  : 			   }
; 678  : 			   */
; 679  : 
; 680  : 			// If handoff switched target, localData will have zeros only, 
; 681  : 			// fix this by calling CalcRelAzElRangeAta and then run a sensor sweep
; 682  : 			SimObjectLocalData* localData= self->targetPtr->localData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+656]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _localData$19[ebp], edx

; 683  : 			if (
; 684  : 				localData->ataFrom == 0.0f && 
; 685  : 				localData->az == 0.0f  && 
; 686  : 				localData->el == 0.0f && localData->range == 0.0f
; 687  : 			){

	mov	eax, DWORD PTR _localData$19[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN29@ProcessTar
	mov	ecx, DWORD PTR _localData$19[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN29@ProcessTar
	mov	edx, DWORD PTR _localData$19[ebp]
	movss	xmm0, DWORD PTR [edx+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@ProcessTar
	mov	eax, DWORD PTR _localData$19[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@ProcessTar

; 688  : 				CalcRelAzElRangeAta(self, self->targetPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+656]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	?CalcRelAzElRangeAta@@YAXPAVSimBaseClass@@PAVSimObjectType@@@Z ; CalcRelAzElRangeAta
	add	esp, 8

; 689  : 
; 690  : 				radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 691  : 				// Flag it as a first sweep so it doesn't have to wait before locking
; 692  : 				radar->SetFlag(RadarClass::FirstSweep); 

	push	1
	mov	ecx, DWORD PTR _radar$25[ebp]
	call	?SetFlag@RadarClass@@QAEXW4RadarFlag@1@@Z ; RadarClass::SetFlag

; 693  : 				radar->Exec(self->targetList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+660]
	push	eax
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax

; 694  : 			}
; 695  : 			// If our radar has no target or if it has the SAME base object
; 696  : 			// as us but different target pointers, switch our radar target pointer to our target pointer
; 697  : 			else if (

	jmp	$LN27@ProcessTar
$LN29@ProcessTar:

; 698  : 				!radar->CurrentTarget() || (
; 699  : 					radar->CurrentTarget() != self->targetPtr && 
; 700  : 					radar->CurrentTarget()->BaseData() == self->targetPtr->BaseData()
; 701  : 				)
; 702  : 			){

	mov	ecx, DWORD PTR _radar$25[ebp]
	call	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
	test	eax, eax
	je	SHORT $LN26@ProcessTar
	mov	ecx, DWORD PTR _radar$25[ebp]
	call	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	eax, DWORD PTR [edx+656]
	je	SHORT $LN27@ProcessTar
	mov	ecx, DWORD PTR _radar$25[ebp]
	call	?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ; SensorClass::CurrentTarget
	mov	ecx, eax
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	ecx, DWORD PTR [ecx+656]
	call	?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ; SimObjectType::BaseData
	cmp	esi, eax
	jne	SHORT $LN27@ProcessTar
$LN26@ProcessTar:

; 703  : 				radar->SetDesiredTarget(self->targetPtr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+656]
	push	ecx
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 704  : 				radar->SetFlag(RadarClass::FirstSweep); // Flag it as a first sweep since change

	push	1
	mov	ecx, DWORD PTR _radar$25[ebp]
	call	?SetFlag@RadarClass@@QAEXW4RadarFlag@1@@Z ; RadarClass::SetFlag

; 705  : 				radar->Exec(self->targetList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+660]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
$LN27@ProcessTar:

; 706  : 			}
; 707  : 
; 708  : 			for (i = 0; i < ((SimMoverClass*)self)->numSensors; i++){

	mov	DWORD PTR _i$20[ebp], 0
	jmp	SHORT $LN25@ProcessTar
$LN24@ProcessTar:
	mov	ecx, DWORD PTR _i$20[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$20[ebp], ecx
$LN25@ProcessTar:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _i$20[ebp]
	cmp	ecx, DWORD PTR [eax+652]
	jge	SHORT $LN23@ProcessTar

; 709  : 				SimObjectLocalData* localData= self->targetPtr->localData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+656]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _localData$17[ebp], edx

; 710  : 				if (localData->sensorState[i] > SensorClass::Detection){

	mov	eax, DWORD PTR _i$20[ebp]
	mov	ecx, DWORD PTR _localData$17[ebp]
	cmp	DWORD PTR [ecx+eax*4+192], 1
	jle	SHORT $LN22@ProcessTar

; 711  : 					tracking = TRUE;

	mov	BYTE PTR _tracking$24[ebp], 1
$LN22@ProcessTar:

; 712  : 				}
; 713  : 
; 714  : 				if (localData->sensorState[i] >= SensorClass::Detection){

	mov	edx, DWORD PTR _i$20[ebp]
	mov	eax, DWORD PTR _localData$17[ebp]
	cmp	DWORD PTR [eax+edx*4+192], 1
	jl	SHORT $LN21@ProcessTar

; 715  : 					detecting = TRUE;

	mov	BYTE PTR _detecting$23[ebp], 1
$LN21@ProcessTar:

; 716  : 				}
; 717  : 
; 718  : 				if (localData->range > range){

	mov	ecx, DWORD PTR _localData$17[ebp]
	movss	xmm0, DWORD PTR [ecx+44]
	comiss	xmm0, DWORD PTR _range$18[ebp]
	jbe	SHORT $LN20@ProcessTar

; 719  : 					range = localData->range ;

	mov	edx, DWORD PTR _localData$17[ebp]
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR _range$18[ebp], xmm0
$LN20@ProcessTar:

; 720  : 				}
; 721  : 			}

	jmp	$LN24@ProcessTar
$LN23@ProcessTar:

; 722  : 
; 723  : 			// 2002-01-29 MN add a debug label that shows the current SAM radar mode
; 724  : #define SHOW_RADARSTATE
; 725  : #ifdef SHOW_RADARSTATE
; 726  : 			char label[40];
; 727  : 			sprintf(label,"OFF");

	push	OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
	lea	eax, DWORD PTR _label$27[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 728  : 			if (detecting)

	movzx	ecx, BYTE PTR _detecting$23[ebp]
	test	ecx, ecx
	je	SHORT $LN19@ProcessTar

; 729  : 				sprintf (label,"Detect");

	push	OFFSET ??_C@_06ILIGGHLH@Detect?$AA@
	lea	edx, DWORD PTR _label$27[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN19@ProcessTar:

; 730  : 			if (tracking)

	movzx	eax, BYTE PTR _tracking$24[ebp]
	test	eax, eax
	je	SHORT $LN18@ProcessTar

; 731  : 				sprintf (label,"Track");

	push	OFFSET ??_C@_05BFDCPAGB@Track?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN18@ProcessTar:

; 732  : 			//me123 modifyed to take tracking/detection parameter))
; 733  : 			switch (self->GetCampaignObject()->StepRadar(tracking, detecting, range) ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR tv755[ebp], eax
	push	ecx
	movss	xmm0, DWORD PTR _range$18[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, BYTE PTR _detecting$23[ebp]
	push	eax
	movzx	ecx, BYTE PTR _tracking$24[ebp]
	push	ecx
	mov	edx, DWORD PTR tv755[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv755[ebp]
	mov	edx, DWORD PTR [eax+428]
	call	edx
	mov	DWORD PTR tv764[ebp], eax
	mov	eax, DWORD PTR tv764[ebp]
	sub	eax, 1
	mov	DWORD PTR tv764[ebp], eax
	cmp	DWORD PTR tv764[ebp], 6
	ja	$LN8@ProcessTar
	mov	ecx, DWORD PTR tv764[ebp]
	jmp	DWORD PTR $LN85@ProcessTar[ecx*4]
$LN15@ProcessTar:

; 734  : 				case FEC_RADAR_SEARCH_100:
; 735  : 					radar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 736  : 					radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 737  : 					strcat(label," S100");

	push	OFFSET ??_C@_05IFJIKCNG@?5S100?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 738  : 					break;

	jmp	$LN16@ProcessTar
$LN14@ProcessTar:

; 739  : 				case FEC_RADAR_SEARCH_1:
; 740  : 					radar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 741  : 					radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 742  : 					strcat(label," S1");

	push	OFFSET ??_C@_03NGCOBIIG@?5S1?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 743  : 					break;

	jmp	$LN16@ProcessTar
$LN13@ProcessTar:

; 744  : 				case FEC_RADAR_SEARCH_2:
; 745  : 					radar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 746  : 					radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 747  : 					strcat(label," S2");

	push	OFFSET ??_C@_03PNADELEF@?5S2?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 748  : 					break;

	jmp	$LN16@ProcessTar
$LN12@ProcessTar:

; 749  : 				case FEC_RADAR_SEARCH_3:
; 750  : 					radar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 751  : 					radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 752  : 					strcat(label," S3");

	push	OFFSET ??_C@_03OEBIHKAE@?5S3?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 753  : 					break;

	jmp	$LN16@ProcessTar
$LN11@ProcessTar:

; 754  : 				case FEC_RADAR_GUIDE:
; 755  : 					radar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 756  : 					radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 757  : 					strcat(label," Guide");

	push	OFFSET ??_C@_06JPDLAIOB@?5Guide?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 758  : 					break;

	jmp	SHORT $LN16@ProcessTar
$LN10@ProcessTar:

; 759  : 				case FEC_RADAR_AQUIRE:
; 760  : 					radar->SetEmitting(TRUE);

	push	1
	mov	edx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax+84]
	call	edx

; 761  : 					radar->SetDesiredTarget(self->targetPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+656]
	push	edx
	mov	eax, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 762  : 					strcat(label," Acquire");

	push	OFFSET ??_C@_08DMPDNHHH@?5Acquire?$AA@
	lea	ecx, DWORD PTR _label$27[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 763  : 					break;

	jmp	SHORT $LN16@ProcessTar
$LN9@ProcessTar:

; 764  : 				case FEC_RADAR_CHANGEMODE:// do nothing
; 765  : 					strcat(label," Changemode");

	push	OFFSET ??_C@_0M@NMGDLKFJ@?5Changemode?$AA@
	lea	edx, DWORD PTR _label$27[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 766  : 					break;

	jmp	SHORT $LN16@ProcessTar
$LN8@ProcessTar:

; 767  : 				default:
; 768  : 					// No emissions this time
; 769  : 					strcat(label," OFF");

	push	OFFSET ??_C@_04OJFPHGHM@?5OFF?$AA@
	lea	eax, DWORD PTR _label$27[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 770  : 					radar->SetEmitting(FALSE);

	push	0
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 771  : 					radar->SetDesiredTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _radar$25[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN16@ProcessTar:

; 772  : 					break;
; 773  : 			}
; 774  : 			char buf[40];
; 775  : 			sprintf(buf," %f",range);

	cvtss2sd xmm0, DWORD PTR _range$18[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_03HDKIMHPH@?5?$CFf?$AA@
	lea	ecx, DWORD PTR _buf$26[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 776  : 			strcat(label,buf);

	lea	edx, DWORD PTR _buf$26[ebp]
	push	edx
	lea	eax, DWORD PTR _label$27[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 777  : 
; 778  : 			extern int g_nShowDebugLabels;
; 779  : 			if (self->drawPointer){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN6@ProcessTar

; 780  : 				if (g_nShowDebugLabels & 0x04){

	mov	eax, DWORD PTR ?g_nShowDebugLabels@@3HA	; g_nShowDebugLabels
	and	eax, 4
	je	SHORT $LN6@ProcessTar

; 781  : 					((DrawableBSP*)self->drawPointer)->SetLabel(
; 782  : 						label,((DrawableBSP*)self->drawPointer)->LabelColor()
; 783  : 					);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+332]
	call	?LabelColor@DrawableBSP@@QAEKXZ		; DrawableBSP::LabelColor
	push	eax
	lea	eax, DWORD PTR _label$27[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+332]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+332]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN6@ProcessTar:

; 784  : 				}
; 785  : 			}
; 786  : 
; 787  : #else
; 788  : 
; 789  : 			//me123 modifyed to take tracking/detection parameter))
; 790  : 			switch (self->GetCampaignObject()->StepRadar(tracking,detecting, range) )
; 791  : 			{
; 792  : 				case FEC_RADAR_SEARCH_100:
; 793  : 				case FEC_RADAR_SEARCH_1:
; 794  : 				case FEC_RADAR_SEARCH_2:
; 795  : 				case FEC_RADAR_SEARCH_3:
; 796  : 				case FEC_RADAR_GUIDE:
; 797  : 				case FEC_RADAR_AQUIRE:
; 798  : 					radar->SetEmitting(TRUE);
; 799  : 					radar->SetDesiredTarget(self->targetPtr);
; 800  : 					break;
; 801  : 				case FEC_RADAR_CHANGEMODE:// do nothing
; 802  : 					break;
; 803  : 				default:
; 804  : 					// No emissions this time
; 805  : 
; 806  : 					radar->SetEmitting(FALSE);
; 807  : 					radar->SetDesiredTarget(NULL);
; 808  : 					break;
; 809  : 			}
; 810  : #endif
; 811  : 		}
; 812  : 
; 813  : 		if( (!self->isEmitter || self->isAirCapable) && this != battalionCommand){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+772]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN4@ProcessTar
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+772]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN3@ProcessTar
$LN4@ProcessTar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	je	SHORT $LN3@ProcessTar

; 814  : 			self->SelectWeapon(FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?SelectWeapon@GroundClass@@QAEXH@Z	; GroundClass::SelectWeapon

; 815  : 			SimWeaponClass *theWeapon = self->Sms->GetCurrentWeapon();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [ecx+780]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+780]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _theWeapon$8[ebp], eax

; 816  : 			//if we can't shoot at the current target, don't shoot
; 817  : 			if (!theWeapon){

	cmp	DWORD PTR _theWeapon$8[ebp], 0
	jne	SHORT $LN3@ProcessTar

; 818  : 				self->SetTarget( NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?SetTarget@SimMoverClass@@QAEXPAVSimObjectType@@@Z ; SimMoverClass::SetTarget
$LN3@ProcessTar:

; 819  : 			}
; 820  : 		}
; 821  : 	}

	jmp	SHORT $LN1@ProcessTar
$LN31@ProcessTar:

; 822  : 	else if (self->isEmitter){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [eax+772]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN1@ProcessTar

; 823  : 		self->ReturnToSearch();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx+136]
	call	eax
$LN1@ProcessTar:
$LN70@ProcessTar:

; 824  : 	}
; 825  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN85@ProcessTar:
	DD	$LN15@ProcessTar
	DD	$LN14@ProcessTar
	DD	$LN13@ProcessTar
	DD	$LN12@ProcessTar
	DD	$LN10@ProcessTar
	DD	$LN11@ProcessTar
	DD	$LN9@ProcessTar
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$0:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$1:
	mov	eax, DWORD PTR $T13[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$2:
	lea	ecx, DWORD PTR _sit$2[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__unwindfunclet$?ProcessTargeting@GNDAIClass@@QAEXXZ$3:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ProcessTargeting@GNDAIClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProcessTargeting@GNDAIClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessTargeting@GNDAIClass@@QAEXXZ ENDP		; GNDAIClass::ProcessTargeting
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
tv145 = -20						; size = 4
tv207 = -16						; size = 4
tv198 = -12						; size = 4
tv77 = -8						; size = 4
_this$ = -4						; size = 4
?Process@GNDAIClass@@QAEXXZ PROC			; GNDAIClass::Process
; _this$ = ecx

; 830  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 831  : 	// Do general house keeping for the indivual units as detailed in the AI
; 832  : 	// design doc - I suspect more functionality to be added.
; 833  : 	// Calculate the "ideal" position for the low level formations,
; 834  : 	// this information will be used to determine the actual position in 
; 835  : 	// Follow way point, this allows us to change formation in battle and the
; 836  : 	// vehicles should smoothly re-group.
; 837  : 	//
; 838  : 	// Note: Need to get "tatics" from the campiagn level (mode).
; 839  : 	//
; 840  : 
; 841  : 	// KCK: This picks a location we want to get to
; 842  : 	// Probably it should also:
; 843  : 	// a) figure out how to move along the road, if that's what we're doing
; 844  : 	// b) figure out how to get to cover, if that's what were doing
; 845  : 	// c) figure out how to point at an enemy and shoot, if that's what we're doing
; 846  : 
; 847  : 	// edg: I'm not entirely sure this is working correctly in IA.
; 848  : 	// additionally check for leader == NULL ( meaning I'm a batallion )
; 849  : 	// and follow waypoints....
; 850  : 	if ( leader == NULL && self->curWaypoint && rank != GNDAI_BATTALION_COMMANDER)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN14@Process
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	cmp	DWORD PTR [edx+728], 0
	je	SHORT $LN14@Process
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 15			; 0000000fH
	je	SHORT $LN14@Process

; 851  : 	{
; 852  : 		rank = GNDAI_BATTALION_COMMANDER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	jmp	SHORT $LN11@Process
$LN14@Process:

; 853  : 	}
; 854  : 	else switch ( rank ) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 8
	je	SHORT $LN7@Process
	cmp	DWORD PTR tv77[ebp], 12			; 0000000cH
	je	SHORT $LN8@Process
	cmp	DWORD PTR tv77[ebp], 14			; 0000000eH
	je	SHORT $LN9@Process

; 855  : 	{
; 856  : 		case GNDAI_BATTALION_COMMANDER:
; 857  : 		default:
; 858  : 			Order_Battalion();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Order_Battalion@GNDAIClass@@QAEXXZ	; GNDAIClass::Order_Battalion

; 859  : 			break;

	jmp	SHORT $LN11@Process
$LN9@Process:

; 860  : 		case GNDAI_COMPANY_COMMANDER:
; 861  : 			Order_Company();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Order_Company@GNDAIClass@@QAEXXZ	; GNDAIClass::Order_Company

; 862  : 			break;

	jmp	SHORT $LN11@Process
$LN8@Process:

; 863  : 		case GNDAI_PLATOON_COMMANDER:	
; 864  : 			Order_Platoon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Order_Platoon@GNDAIClass@@QAEXXZ	; GNDAIClass::Order_Platoon

; 865  : 			break;

	jmp	SHORT $LN11@Process
$LN7@Process:

; 866  : 		case GNDAI_SQUAD_LEADER:
; 867  : 			Order_Squad();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Order_Squad@GNDAIClass@@QAEXXZ		; GNDAIClass::Order_Squad
$LN11@Process:

; 868  : 			break;
; 869  : 	}
; 870  : 
; 871  : 	if ((moveState == GNDAI_MOVE_WAYPOINT) && (ideal_x == self->XPos()) && (ideal_y == self->YPos()))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 1
	jne	$LN3@Process
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv198[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+28]
	ucomiss	xmm0, DWORD PTR tv198[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@Process
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv207[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+32]
	ucomiss	xmm0, DWORD PTR tv207[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@Process

; 872  : 	{
; 873  : 		// if in waypoint mode choose another
; 874  : 		if ( self->curWaypoint )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	cmp	DWORD PTR [ecx+728], 0
	je	SHORT $LN3@Process

; 875  : 		{
; 876  : 			switch ( rank ) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv145[ebp], eax

; 877  : 			{
; 878  : 				case GNDAI_COMPANY_COMMANDER:
; 879  : 				case GNDAI_PLATOON_COMMANDER:	
; 880  : 				case GNDAI_SQUAD_LEADER:
; 881  : 				case GNDAI_BATTALION_COMMANDER:
; 882  : 				default:
; 883  : 					// get the next waypoint
; 884  : 					self->curWaypoint = self->curWaypoint->GetNextWP ();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	ecx, DWORD PTR [edx+728]
	call	?GetNextWP@WayPointClass@@QAEPAV1@XZ	; WayPointClass::GetNextWP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [edx+728], eax

; 885  : 
; 886  : 					// if none, loop back to 1st waypoint
; 887  : 					if ( self->curWaypoint == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	cmp	DWORD PTR [ecx+728], 0
	jne	SHORT $LN1@Process

; 888  : 						self->curWaypoint = self->waypoint;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax+732]
	mov	DWORD PTR [edx+728], eax
$LN1@Process:
$LN3@Process:

; 889  : 					break;
; 890  : 			}
; 891  : 		}
; 892  : 	}
; 893  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Process@GNDAIClass@@QAEXXZ ENDP			; GNDAIClass::Process
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1GNDAIClass@@QAE@XZ PROC				; GNDAIClass::~GNDAIClass
; _this$ = ecx

; 444  : GNDAIClass::~GNDAIClass (void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 	SetGroundTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroundTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetGroundTarget

; 446  : 	SetAirTarget(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAirTarget@GNDAIClass@@QAEXPAVSimObjectType@@@Z ; GNDAIClass::SetAirTarget

; 447  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1GNDAIClass@@QAE@XZ ENDP				; GNDAIClass::~GNDAIClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\ground\gndai.cpp
_TEXT	SEGMENT
_trig$ = -16						; size = 8
_vc$ = -8						; size = 4
_this$ = -4						; size = 4
_s$ = 8							; size = 4
_l$ = 12						; size = 4
_r$ = 16						; size = 2
_unit_id$ = 20						; size = 4
_skill$ = 24						; size = 4
??0GNDAIClass@@QAE@PAVGroundClass@@PAV0@FHH@Z PROC	; GNDAIClass::GNDAIClass
; _this$ = ecx

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 319  : 	battalionCommand = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 320  : 	mlTrig trig;
; 321  : 	parent_unit = (UnitClass*) s->GetCampaignObject();

	mov	ecx, DWORD PTR _s$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 322  : 	gndTargetPtr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 0

; 323  : 	airTargetPtr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], 0

; 324  : 	leader = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 325  : 	self = s;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [edx+72], eax

; 326  : 	rank = r;

	movsx	ecx, WORD PTR _r$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 327  : 	skillLevel = skill;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _skill$[ebp]
	mov	DWORD PTR [eax+104], ecx

; 328  : 	distLOD = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+108], xmm0

; 329  : 	ideal_x = self->XPos();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+28]

; 330  : 	ideal_y = self->YPos();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+32]

; 331  : 	ideal_h = self->Yaw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+36]

; 332  : 	SetLeader(l);

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLeader@GNDAIClass@@QAEXPAV1@@Z	; GNDAIClass::SetLeader

; 333  : 	// Check for towed vehicles
; 334  : 	if (s->isTowed){

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+772]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN20@GNDAIClass

; 335  : 		move_backwards = PI;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [eax+68], xmm0

; 336  : 	}
; 337  : 	else {

	jmp	SHORT $LN19@GNDAIClass
$LN20@GNDAIClass:

; 338  : 		move_backwards = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+68], xmm0
$LN19@GNDAIClass:

; 339  : 	}
; 340  : 	// Update current trig values
; 341  : 	if (!l || this == l){

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $LN17@GNDAIClass
	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR _l$[ebp]
	jne	SHORT $LN18@GNDAIClass
$LN17@GNDAIClass:

; 342  : 		mlSinCos (&trig, ideal_h);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 343  : 		isinh = trig.sin;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR [edx+52], xmm0

; 344  : 		icosh = trig.cos;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR [eax+48], xmm0

; 345  : 	}
; 346  : 	else {

	jmp	SHORT $LN16@GNDAIClass
$LN18@GNDAIClass:

; 347  : 		isinh = l->isinh;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+52], eax

; 348  : 		icosh = l->icosh;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
$LN16@GNDAIClass:

; 349  : 	}
; 350  : 	through_x = through_y = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+44], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+40], xmm0

; 351  : 	leftToGoSq = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+56], xmm0

; 352  : 
; 353  : 	// edg note: In instant action it seems there are no formations --
; 354  : 	// everyone object is created separately.  If leader is NULL, insure
; 355  : 	// our rank is battalion commander and leader is set
; 356  : 	if ( leader == NULL ){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	jne	SHORT $LN15@GNDAIClass

; 357  : 		rank = GNDAI_BATTALION_COMMANDER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 15			; 0000000fH
$LN15@GNDAIClass:

; 358  : 	}
; 359  : 
; 360  : 	// KCK: Not sure why he need all these, but I'll fix them to work right...
; 361  : 	if (rank & GNDAI_BATTALION_LEADER){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	SHORT $LN14@GNDAIClass

; 362  : 		squad_id = platoon_id = company_id = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	jmp	SHORT $LN9@GNDAIClass
$LN14@GNDAIClass:

; 363  : 	}
; 364  : 	else if (rank & GNDAI_COMPANY_LEADER){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 2
	je	SHORT $LN12@GNDAIClass

; 365  : 		squad_id = platoon_id = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 366  : 		company_id = unit_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _unit_id$[ebp]
	mov	DWORD PTR [eax+20], ecx
	jmp	SHORT $LN9@GNDAIClass
$LN12@GNDAIClass:

; 367  : 	}
; 368  : 	else if (rank & GNDAI_PLATOON_LEADER){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 4
	je	SHORT $LN10@GNDAIClass

; 369  : 		squad_id = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 370  : 		platoon_id = unit_id;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _unit_id$[ebp]
	mov	DWORD PTR [edx+16], eax

; 371  : 		company_id = l->company_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax

; 372  : 	}
; 373  : 	else {

	jmp	SHORT $LN9@GNDAIClass
$LN10@GNDAIClass:

; 374  : 		squad_id = unit_id;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _unit_id$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 375  : 		platoon_id = l->platoon_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 376  : 		company_id = l->company_id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
$LN9@GNDAIClass:

; 377  : 	}
; 378  : 
; 379  : 	VehicleClassDataType *vc = (VehicleClassDataType*)Falcon4ClassTable[self->Type()-VU_LAST_ENTITY_TYPE].dataPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?Type@VuEntity@@QBEGXZ			; VuEntity::Type
	movzx	ecx, ax
	sub	ecx, 100				; 00000064H
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	mov	DWORD PTR _vc$[ebp], eax

; 380  : 	maxvel = vc->MaxSpeed * KPH_TO_FPS;

	mov	ecx, DWORD PTR _vc$[ebp]
	movsx	edx, WORD PTR [ecx+54]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f693e32
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+60], xmm0

; 381  : 
; 382  : 	if (parent_unit){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN8@GNDAIClass

; 383  : 		formation = (GNDAIFormType) parent_unit->GetUnitFormation();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetUnitFormation@UnitClass@@QBEHXZ	; UnitClass::GetUnitFormation
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 384  : 		unitvel = (float)parent_unit->GetCruiseSpeed();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetCruiseSpeed@UnitClass@@QBEHXZ	; UnitClass::GetCruiseSpeed
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+64], xmm0

; 385  : 	}
; 386  : 	else {

	jmp	SHORT $LN7@GNDAIClass
$LN8@GNDAIClass:

; 387  : 		formation = GNDAI_FORM_WEDGE; //(GNDAIFormType)(rand () % GNDAI_FORM_COLUMN);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 4

; 388  : 		unitvel = maxvel;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+64], ecx
$LN7@GNDAIClass:

; 389  : 	}
; 390  : 	lastMoveTime = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx], eax

; 391  : 
; 392  : 	// note: we can adjust this for AI levels / gun type
; 393  : 	airFireRate = (10 - skillLevel + rand() % (3 * (5-skillLevel)) ) * SEC_TO_MSEC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, 10					; 0000000aH
	sub	esi, DWORD PTR [ecx+104]
	call	_rand
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, 5
	sub	ecx, DWORD PTR [edx+104]
	imul	ecx, 3
	cdq
	idiv	ecx
	add	esi, edx
	imul	esi, 1000				; 000003e8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], esi

; 394  : 	gndFireRate = (2 + rand()%6) * SEC_TO_MSEC;

	call	_rand
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 2
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], edx

; 395  : 
; 396  : 	nextTurretCalc = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+92], edx

; 397  : 	if (rank){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@GNDAIClass

; 398  : 		nextGroundFire = nextAirFire = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+84], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+88], ecx

; 399  : 	}
; 400  : 	else {

	jmp	SHORT $LN5@GNDAIClass
$LN6@GNDAIClass:

; 401  : 		nextGroundFire = SimLibElapsedTime + ((int)(s->vehicleInUnit * SEC_TO_MSEC) % (int)gndFireRate);

	mov	edx, DWORD PTR _s$[ebp]
	movzx	eax, BYTE PTR [edx+664]
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+100]
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], edx

; 402  : 		nextAirFire = SimLibElapsedTime + ((int)(s->vehicleInUnit * 5 * SEC_TO_MSEC) % (int)airFireRate);

	mov	ecx, DWORD PTR _s$[ebp]
	movzx	eax, BYTE PTR [ecx+664]
	imul	eax, 5
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	cdq
	idiv	DWORD PTR [ecx+96]
	add	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], edx
$LN5@GNDAIClass:

; 403  : 	}
; 404  : 
; 405  : 	if (!maxvel){

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+60]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@GNDAIClass

; 406  : 		// If we can't move, set ourselves to halted
; 407  : 		moveState = GNDAI_MOVE_HALTED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 0
	jmp	SHORT $LN1@GNDAIClass
$LN4@GNDAIClass:

; 408  : 	}
; 409  : 	else if (SimDriver.RunningCampaignOrTactical() && !parent_unit->IsTaskForce() ){

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaignOrTactical
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GNDAIClass
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@GNDAIClass

; 410  : 		moveState = GNDAI_MOVE_GENERAL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 2

; 411  : 	}
; 412  : 	else {

	jmp	SHORT $LN1@GNDAIClass
$LN2@GNDAIClass:

; 413  : 		// Otherwise assume we're using waypoints to move
; 414  : 		moveState = GNDAI_MOVE_WAYPOINT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 1
$LN1@GNDAIClass:

; 415  : 	}
; 416  : 	moveFlags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 417  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0GNDAIClass@@QAE@PAVGroundClass@@PAV0@FHH@Z ENDP	; GNDAIClass::GNDAIClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ PROC	; UnitClass::GetTarget, COMDAT
; _this$ = ecx

; 366  : 	FalconEntity* GetTarget (void)					{ return (FalconEntity*) vuDatabase->Find(target_id); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	mov	edx, DWORD PTR [eax+212]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@UnitClass@@QAEPAVFalconEntity@@XZ ENDP	; UnitClass::GetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tviewpnt.h
;	COMDAT ?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z PROC		; TViewPoint::GetPos, COMDAT
; _this$ = ecx

; 119  : 	void	GetPos( Tpoint *p )		{ *p = pos; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPos@TViewPoint@@QAEXPAUTpoint@@@Z ENDP		; TViewPoint::GetPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ PROC ; SimulationDriver::RunningCampaignOrTactical, COMDAT
; _this$ = ecx

; 61   : 	bool RunningCampaignOrTactical() const   { return RunningCampaign() || RunningTactical(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunningCampaign@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningCampaign
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@RunningCam
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunningTactical@SimulationDriver@@QBE_NXZ ; SimulationDriver::RunningTactical
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@RunningCam
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@RunningCam
$LN3@RunningCam:
	mov	DWORD PTR tv72[ebp], 1
$LN4@RunningCam:
	mov	al, BYTE PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningCampaignOrTactical@SimulationDriver@@QBE_NXZ ENDP ; SimulationDriver::RunningCampaignOrTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningCampaign@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningCampaign@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningCampaign, COMDAT
; _this$ = ecx

; 59   : 	bool RunningCampaign() const             { return FalconLocalGame->GetGameType() == game_Campaign; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningCam
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningCam
$LN3@RunningCam:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningCam:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	SHORT $LN5@RunningCam
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningCam
$LN5@RunningCam:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningCam:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningCampaign@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?RunningTactical@SimulationDriver@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv76 = -4						; size = 4
?RunningTactical@SimulationDriver@@QBE_NXZ PROC		; SimulationDriver::RunningTactical, COMDAT
; _this$ = ecx

; 57   : 	bool RunningTactical() const             { return FalconLocalGame->GetGameType() == game_TacticalEngagement; }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@RunningTac
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@RunningTac
$LN3@RunningTac:
	mov	DWORD PTR tv76[ebp], 0
$LN4@RunningTac:
	mov	ecx, DWORD PTR tv76[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN5@RunningTac
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@RunningTac
$LN5@RunningTac:
	mov	DWORD PTR tv80[ebp], 0
$LN6@RunningTac:
	mov	al, BYTE PTR tv80[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?RunningTactical@SimulationDriver@@QBE_NXZ ENDP		; SimulationDriver::RunningTactical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?UnsetChecked@CampBaseClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UnsetChecked@CampBaseClass@@QAEXXZ PROC		; CampBaseClass::UnsetChecked, COMDAT
; _this$ = ecx

; 307  : 	void UnsetChecked (void)					{	local_flags &= ~CBC_CHECKED; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+156]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+156], cx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetChecked@CampBaseClass@@QAEXXZ ENDP		; CampBaseClass::UnsetChecked
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?IsAggregate@CampBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAggregate@CampBaseClass@@QAEHXZ PROC			; CampBaseClass::IsAggregate, COMDAT
; _this$ = ecx

; 278  : 	int IsAggregate (void)						{	return local_flags & CBC_AGGREGATE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+156]
	and	eax, 128				; 00000080H
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAggregate@CampBaseClass@@QAEHXZ ENDP			; CampBaseClass::IsAggregate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ PROC ; CampBaseClass::GetComponents, COMDAT
; _this$ = ecx

; 141  : 	TailInsertList *GetComponents() const		{	return components; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ENDP ; CampBaseClass::GetComponents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetNextWP@WayPointClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextWP@WayPointClass@@QAEPAV1@XZ PROC		; WayPointClass::GetNextWP, COMDAT
; _this$ = ecx

; 175  : 	WayPoint GetNextWP (void)						{ return NextWP; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextWP@WayPointClass@@QAEPAV1@XZ ENDP		; WayPointClass::GetNextWP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ PROC ; FalconSessionEntity::GetPlayerEntity, COMDAT
; _this$ = ecx

; 138  : 	FalconEntity* GetPlayerEntity(void) const     { return playerEntityPtr.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 484				; 000001e4H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ENDP ; FalconSessionEntity::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\object.h
;	COMDAT ?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ PROC	; SimObjectType::BaseData, COMDAT
; _this$ = ecx

; 92   : 	FalconEntity* BaseData(void) { return baseData.get(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?BaseData@SimObjectType@@QAEPAVFalconEntity@@XZ ENDP	; SimObjectType::BaseData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sensclas.h
;	COMDAT ?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ PROC ; SensorClass::CurrentTarget, COMDAT
; _this$ = ecx

; 46   : 	SimObjectType* CurrentTarget(void)	{ return lockedTarget; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentTarget@SensorClass@@QAEPAVSimObjectType@@XZ ENDP ; SensorClass::CurrentTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSim@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsSim@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsSim, COMDAT
; _this$ = ecx

; 103  : 		{return (falconType & FalconSimEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 2
	je	SHORT $LN3@IsSim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSim
$LN3@IsSim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSim:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSim@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsSim
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampaign@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?IsCampaign@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsCampaign, COMDAT
; _this$ = ecx

; 101  : 		{return (falconType & FalconCampaignEntity) ? TRUE : FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+137]
	and	ecx, 1
	je	SHORT $LN3@IsCampaign
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsCampaign
$LN3@IsCampaign:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsCampaign:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampaign@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsCampaign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Type@VuEntity@@QBEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Type@VuEntity@@QBEGXZ PROC				; VuEntity::Type, COMDAT
; _this$ = ecx

; 154  : 	ushort Type() const       { return share_.entityType_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Type@VuEntity@@QBEGXZ ENDP				; VuEntity::Type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPRDelta@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dyaw$ = 8						; size = 4
_dpitch$ = 12						; size = 4
_droll$ = 16						; size = 4
?SetYPRDelta@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPRDelta, COMDAT
; _this$ = ecx

; 116  : 	void SetYPRDelta(SM_SCALAR dyaw, SM_SCALAR dpitch,SM_SCALAR droll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		orient_.dyaw_ = dyaw; orient_.dpitch_ = dpitch; orient_.droll_=droll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dyaw$[ebp]
	movss	DWORD PTR [eax+72], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _dpitch$[ebp]
	movss	DWORD PTR [ecx+76], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _droll$[ebp]
	movss	DWORD PTR [edx+80], xmm0

; 118  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPRDelta@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPRDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetYPR@VuEntity@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?SetYPR@VuEntity@@QAEXMMM@Z PROC			; VuEntity::SetYPR, COMDAT
; _this$ = ecx

; 113  : 	void SetYPR(SM_SCALAR yaw, SM_SCALAR pitch, SM_SCALAR roll){ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		orient_.yaw_ = yaw; orient_.pitch_ = pitch; orient_.roll_ = roll; 

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [eax+60], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR [ecx+64], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _roll$[ebp]
	movss	DWORD PTR [edx+68], xmm0

; 115  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetYPR@VuEntity@@QAEXMMM@Z ENDP			; VuEntity::SetYPR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
