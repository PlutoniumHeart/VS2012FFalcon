; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\SIM\DISPLAYS\Hud.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?hudWinX@@3PAMA					; hudWinX
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?hudWinY@@3PAMA					; hudWinY
PUBLIC	?hudWinWidth@@3PAMA				; hudWinWidth
PUBLIC	?hudWinHeight@@3PAMA				; hudWinHeight
PUBLIC	?hudNumbers@@3PAPADA				; hudNumbers
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?flash@HudClass@@0HA				; HudClass::flash
PUBLIC	?Warnflash@HudClass@@0HA			; HudClass::Warnflash
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?hudColor@HudClass@@0UPcolor@@A			; HudClass::hudColor
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?curColorIdx@@3HA				; curColorIdx
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_02PKFBJPLJ@10?$AA@			; `string'
PUBLIC	??_C@_02ODEKKOPI@11?$AA@			; `string'
PUBLIC	??_C@_02MIGHPNDL@12?$AA@			; `string'
PUBLIC	??_C@_02NBHMMMHK@13?$AA@			; `string'
PUBLIC	??_C@_02JODNFKLN@14?$AA@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_02LFBAAJHO@17?$AA@			; `string'
PUBLIC	??_C@_02DCIIBFLB@18?$AA@			; `string'
PUBLIC	??_C@_02CLJDCEPA@19?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
PUBLIC	??_C@_02OBAMBAKB@21?$AA@			; `string'
PUBLIC	??_C@_02MKCBEDGC@22?$AA@			; `string'
PUBLIC	??_C@_02NDDKHCCD@23?$AA@			; `string'
PUBLIC	??_C@_02JMHLOEOE@24?$AA@			; `string'
PUBLIC	??_C@_02IFGANFKF@25?$AA@			; `string'
PUBLIC	??_C@_02KOENIGGG@26?$AA@			; `string'
PUBLIC	??_C@_02LHFGLHCH@27?$AA@			; `string'
PUBLIC	??_C@_02DAMOKLOI@28?$AA@			; `string'
PUBLIC	??_C@_02CJNFJKKJ@29?$AA@			; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31?$AA@			; `string'
PUBLIC	??_C@_02MLODCJFF@32?$AA@			; `string'
PUBLIC	??_C@_02NCPIBIBE@33?$AA@			; `string'
PUBLIC	??_C@_02JNLJIOND@34?$AA@			; `string'
PUBLIC	??_C@_02IEKCLPJC@35?$AA@			; `string'
PUBLIC	??_C@_02KPIPOMFB@36?$AA@			; `string'
PUBLIC	??_C@_02LGJENNBA@37?$AA@			; `string'
PUBLIC	??_C@_02DBAMMBNP@38?$AA@			; `string'
PUBLIC	??_C@_02CIBHPAJO@39?$AA@			; `string'
PUBLIC	??_C@_02PMJKFNFC@40?$AA@			; `string'
PUBLIC	??_C@_02OFIBGMBD@41?$AA@			; `string'
PUBLIC	??_C@_02MOKMDPNA@42?$AA@			; `string'
PUBLIC	??_C@_02NHLHAOJB@43?$AA@			; `string'
PUBLIC	??_C@_02JIPGJIFG@44?$AA@			; `string'
PUBLIC	??_C@_02IBONKJBH@45?$AA@			; `string'
PUBLIC	??_C@_02KKMAPKNE@46?$AA@			; `string'
PUBLIC	??_C@_02LDNLMLJF@47?$AA@			; `string'
PUBLIC	??_C@_02DEEDNHFK@48?$AA@			; `string'
PUBLIC	??_C@_02CNFIOGBL@49?$AA@			; `string'
PUBLIC	??_C@_02PNFIDHGF@50?$AA@			; `string'
PUBLIC	??_C@_02OEEDAGCE@51?$AA@			; `string'
PUBLIC	??_C@_02MPGOFFOH@52?$AA@			; `string'
PUBLIC	??_C@_02NGHFGEKG@53?$AA@			; `string'
PUBLIC	??_C@_02JJDEPCGB@54?$AA@			; `string'
PUBLIC	??_C@_02IACPMDCA@55?$AA@			; `string'
PUBLIC	??_C@_02KLACJAOD@56?$AA@			; `string'
PUBLIC	??_C@_02LCBJKBKC@57?$AA@			; `string'
PUBLIC	??_C@_02DFIBLNGN@58?$AA@			; `string'
PUBLIC	??_C@_02CMJKIMCM@59?$AA@			; `string'
PUBLIC	??_C@_02PPBOIJDM@60?$AA@			; `string'
PUBLIC	??_C@_02OGAFLIHN@61?$AA@			; `string'
PUBLIC	??_C@_02MNCIOLLO@62?$AA@			; `string'
PUBLIC	??_C@_02NEDDNKPP@63?$AA@			; `string'
PUBLIC	??_C@_02JLHCEMDI@64?$AA@			; `string'
PUBLIC	??_C@_02ICGJHNHJ@65?$AA@			; `string'
PUBLIC	??_C@_02KJEECOLK@66?$AA@			; `string'
PUBLIC	??_C@_02LAFPBPPL@67?$AA@			; `string'
PUBLIC	??_C@_02DHMHADDE@68?$AA@			; `string'
PUBLIC	?TheHud@@3PAVHudClass@@A			; TheHud
PUBLIC	??_C@_02CONMDCHF@69?$AA@			; `string'
PUBLIC	??_C@_02PONMODAL@70?$AA@			; `string'
PUBLIC	??_C@_02OHMHNCEK@71?$AA@			; `string'
PUBLIC	??_C@_02MMOKIBIJ@72?$AA@			; `string'
PUBLIC	??_C@_02NFPBLAMI@73?$AA@			; `string'
PUBLIC	??_C@_02JKLACGAP@74?$AA@			; `string'
PUBLIC	??_C@_02IDKLBHEO@75?$AA@			; `string'
PUBLIC	??_C@_02KIIGEEIN@76?$AA@			; `string'
PUBLIC	??_C@_02LBJNHFMM@77?$AA@			; `string'
PUBLIC	??_C@_02DGAFGJAD@78?$AA@			; `string'
PUBLIC	??_C@_02CPBOFIEC@79?$AA@			; `string'
PUBLIC	??_C@_02PFIAKEDG@80?$AA@			; `string'
PUBLIC	??_C@_02OMJLJFHH@81?$AA@			; `string'
PUBLIC	??_C@_02MHLGMGLE@82?$AA@			; `string'
PUBLIC	??_C@_02NOKNPHPF@83?$AA@			; `string'
PUBLIC	??_C@_02JBOMGBDC@84?$AA@			; `string'
PUBLIC	??_C@_02IIPHFAHD@85?$AA@			; `string'
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	??_C@_02KDNKADLA@86?$AA@			; `string'
PUBLIC	??_C@_02LKMBDCPB@87?$AA@			; `string'
PUBLIC	??_C@_02DNFJCODO@88?$AA@			; `string'
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	??_C@_02CEECBPHP@89?$AA@			; `string'
PUBLIC	??_C@_02PEECMOAB@90?$AA@			; `string'
PUBLIC	??_C@_02ONFJPPEA@91?$AA@			; `string'
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	??_C@_02MGHEKMID@92?$AA@			; `string'
PUBLIC	??_C@_02NPGPJNMC@93?$AA@			; `string'
PUBLIC	??_C@_02JACOALAF@94?$AA@			; `string'
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	??_C@_02IJDFDKEE@95?$AA@			; `string'
PUBLIC	??_C@_02KCBIGJIH@96?$AA@			; `string'
PUBLIC	??_C@_02LLADFIMG@97?$AA@			; `string'
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	??_C@_02DMJLEEAJ@98?$AA@			; `string'
PUBLIC	??_C@_02CFIAHFEI@99?$AA@			; `string'
PUBLIC	??_C@_03GNABGMEE@100?$AA@			; `string'
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
_BSS	SEGMENT
?flash@HudClass@@0HA DD 01H DUP (?)			; HudClass::flash
?Warnflash@HudClass@@0HA DD 01H DUP (?)			; HudClass::Warnflash
?hudColor@HudClass@@0UPcolor@@A DB 010H DUP (?)		; HudClass::hudColor
?curColorIdx@@3HA DD 01H DUP (?)			; curColorIdx
?TheHud@@3PAVHudClass@@A DD 01H DUP (?)			; TheHud
_BSS	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ??_C@_03GNABGMEE@100?$AA@
CONST	SEGMENT
??_C@_03GNABGMEE@100?$AA@ DB '100', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CFIAHFEI@99?$AA@
CONST	SEGMENT
??_C@_02CFIAHFEI@99?$AA@ DB '99', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DMJLEEAJ@98?$AA@
CONST	SEGMENT
??_C@_02DMJLEEAJ@98?$AA@ DB '98', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ??_C@_02LLADFIMG@97?$AA@
CONST	SEGMENT
??_C@_02LLADFIMG@97?$AA@ DB '97', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCBIGJIH@96?$AA@
CONST	SEGMENT
??_C@_02KCBIGJIH@96?$AA@ DB '96', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IJDFDKEE@95?$AA@
CONST	SEGMENT
??_C@_02IJDFDKEE@95?$AA@ DB '95', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ??_C@_02JACOALAF@94?$AA@
CONST	SEGMENT
??_C@_02JACOALAF@94?$AA@ DB '94', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NPGPJNMC@93?$AA@
CONST	SEGMENT
??_C@_02NPGPJNMC@93?$AA@ DB '93', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGHEKMID@92?$AA@
CONST	SEGMENT
??_C@_02MGHEKMID@92?$AA@ DB '92', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ??_C@_02ONFJPPEA@91?$AA@
CONST	SEGMENT
??_C@_02ONFJPPEA@91?$AA@ DB '91', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PEECMOAB@90?$AA@
CONST	SEGMENT
??_C@_02PEECMOAB@90?$AA@ DB '90', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEECBPHP@89?$AA@
CONST	SEGMENT
??_C@_02CEECBPHP@89?$AA@ DB '89', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ??_C@_02DNFJCODO@88?$AA@
CONST	SEGMENT
??_C@_02DNFJCODO@88?$AA@ DB '88', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LKMBDCPB@87?$AA@
CONST	SEGMENT
??_C@_02LKMBDCPB@87?$AA@ DB '87', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KDNKADLA@86?$AA@
CONST	SEGMENT
??_C@_02KDNKADLA@86?$AA@ DB '86', 00H			; `string'
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ??_C@_02IIPHFAHD@85?$AA@
CONST	SEGMENT
??_C@_02IIPHFAHD@85?$AA@ DB '85', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JBOMGBDC@84?$AA@
CONST	SEGMENT
??_C@_02JBOMGBDC@84?$AA@ DB '84', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NOKNPHPF@83?$AA@
CONST	SEGMENT
??_C@_02NOKNPHPF@83?$AA@ DB '83', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MHLGMGLE@82?$AA@
CONST	SEGMENT
??_C@_02MHLGMGLE@82?$AA@ DB '82', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OMJLJFHH@81?$AA@
CONST	SEGMENT
??_C@_02OMJLJFHH@81?$AA@ DB '81', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFIAKEDG@80?$AA@
CONST	SEGMENT
??_C@_02PFIAKEDG@80?$AA@ DB '80', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPBOFIEC@79?$AA@
CONST	SEGMENT
??_C@_02CPBOFIEC@79?$AA@ DB '79', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGAFGJAD@78?$AA@
CONST	SEGMENT
??_C@_02DGAFGJAD@78?$AA@ DB '78', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LBJNHFMM@77?$AA@
CONST	SEGMENT
??_C@_02LBJNHFMM@77?$AA@ DB '77', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KIIGEEIN@76?$AA@
CONST	SEGMENT
??_C@_02KIIGEEIN@76?$AA@ DB '76', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IDKLBHEO@75?$AA@
CONST	SEGMENT
??_C@_02IDKLBHEO@75?$AA@ DB '75', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JKLACGAP@74?$AA@
CONST	SEGMENT
??_C@_02JKLACGAP@74?$AA@ DB '74', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NFPBLAMI@73?$AA@
CONST	SEGMENT
??_C@_02NFPBLAMI@73?$AA@ DB '73', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MMOKIBIJ@72?$AA@
CONST	SEGMENT
??_C@_02MMOKIBIJ@72?$AA@ DB '72', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OHMHNCEK@71?$AA@
CONST	SEGMENT
??_C@_02OHMHNCEK@71?$AA@ DB '71', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PONMODAL@70?$AA@
CONST	SEGMENT
??_C@_02PONMODAL@70?$AA@ DB '70', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CONMDCHF@69?$AA@
CONST	SEGMENT
??_C@_02CONMDCHF@69?$AA@ DB '69', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHMHADDE@68?$AA@
CONST	SEGMENT
??_C@_02DHMHADDE@68?$AA@ DB '68', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAFPBPPL@67?$AA@
CONST	SEGMENT
??_C@_02LAFPBPPL@67?$AA@ DB '67', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJEECOLK@66?$AA@
CONST	SEGMENT
??_C@_02KJEECOLK@66?$AA@ DB '66', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICGJHNHJ@65?$AA@
CONST	SEGMENT
??_C@_02ICGJHNHJ@65?$AA@ DB '65', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JLHCEMDI@64?$AA@
CONST	SEGMENT
??_C@_02JLHCEMDI@64?$AA@ DB '64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEDDNKPP@63?$AA@
CONST	SEGMENT
??_C@_02NEDDNKPP@63?$AA@ DB '63', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MNCIOLLO@62?$AA@
CONST	SEGMENT
??_C@_02MNCIOLLO@62?$AA@ DB '62', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OGAFLIHN@61?$AA@
CONST	SEGMENT
??_C@_02OGAFLIHN@61?$AA@ DB '61', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPBOIJDM@60?$AA@
CONST	SEGMENT
??_C@_02PPBOIJDM@60?$AA@ DB '60', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CMJKIMCM@59?$AA@
CONST	SEGMENT
??_C@_02CMJKIMCM@59?$AA@ DB '59', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DFIBLNGN@58?$AA@
CONST	SEGMENT
??_C@_02DFIBLNGN@58?$AA@ DB '58', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LCBJKBKC@57?$AA@
CONST	SEGMENT
??_C@_02LCBJKBKC@57?$AA@ DB '57', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KLACJAOD@56?$AA@
CONST	SEGMENT
??_C@_02KLACJAOD@56?$AA@ DB '56', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IACPMDCA@55?$AA@
CONST	SEGMENT
??_C@_02IACPMDCA@55?$AA@ DB '55', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JJDEPCGB@54?$AA@
CONST	SEGMENT
??_C@_02JJDEPCGB@54?$AA@ DB '54', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NGHFGEKG@53?$AA@
CONST	SEGMENT
??_C@_02NGHFGEKG@53?$AA@ DB '53', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPGOFFOH@52?$AA@
CONST	SEGMENT
??_C@_02MPGOFFOH@52?$AA@ DB '52', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OEEDAGCE@51?$AA@
CONST	SEGMENT
??_C@_02OEEDAGCE@51?$AA@ DB '51', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PNFIDHGF@50?$AA@
CONST	SEGMENT
??_C@_02PNFIDHGF@50?$AA@ DB '50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CNFIOGBL@49?$AA@
CONST	SEGMENT
??_C@_02CNFIOGBL@49?$AA@ DB '49', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEEDNHFK@48?$AA@
CONST	SEGMENT
??_C@_02DEEDNHFK@48?$AA@ DB '48', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LDNLMLJF@47?$AA@
CONST	SEGMENT
??_C@_02LDNLMLJF@47?$AA@ DB '47', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KKMAPKNE@46?$AA@
CONST	SEGMENT
??_C@_02KKMAPKNE@46?$AA@ DB '46', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IBONKJBH@45?$AA@
CONST	SEGMENT
??_C@_02IBONKJBH@45?$AA@ DB '45', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JIPGJIFG@44?$AA@
CONST	SEGMENT
??_C@_02JIPGJIFG@44?$AA@ DB '44', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NHLHAOJB@43?$AA@
CONST	SEGMENT
??_C@_02NHLHAOJB@43?$AA@ DB '43', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MOKMDPNA@42?$AA@
CONST	SEGMENT
??_C@_02MOKMDPNA@42?$AA@ DB '42', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OFIBGMBD@41?$AA@
CONST	SEGMENT
??_C@_02OFIBGMBD@41?$AA@ DB '41', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PMJKFNFC@40?$AA@
CONST	SEGMENT
??_C@_02PMJKFNFC@40?$AA@ DB '40', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CIBHPAJO@39?$AA@
CONST	SEGMENT
??_C@_02CIBHPAJO@39?$AA@ DB '39', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DBAMMBNP@38?$AA@
CONST	SEGMENT
??_C@_02DBAMMBNP@38?$AA@ DB '38', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LGJENNBA@37?$AA@
CONST	SEGMENT
??_C@_02LGJENNBA@37?$AA@ DB '37', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36?$AA@
CONST	SEGMENT
??_C@_02KPIPOMFB@36?$AA@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEKCLPJC@35?$AA@
CONST	SEGMENT
??_C@_02IEKCLPJC@35?$AA@ DB '35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNLJIOND@34?$AA@
CONST	SEGMENT
??_C@_02JNLJIOND@34?$AA@ DB '34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCPIBIBE@33?$AA@
CONST	SEGMENT
??_C@_02NCPIBIBE@33?$AA@ DB '33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32?$AA@
CONST	SEGMENT
??_C@_02MLODCJFF@32?$AA@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31?$AA@
CONST	SEGMENT
??_C@_02OAMOHKJG@31?$AA@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJNFJKKJ@29?$AA@
CONST	SEGMENT
??_C@_02CJNFJKKJ@29?$AA@ DB '29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28?$AA@
CONST	SEGMENT
??_C@_02DAMOKLOI@28?$AA@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHFGLHCH@27?$AA@
CONST	SEGMENT
??_C@_02LHFGLHCH@27?$AA@ DB '27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENIGGG@26?$AA@
CONST	SEGMENT
??_C@_02KOENIGGG@26?$AA@ DB '26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IFGANFKF@25?$AA@
CONST	SEGMENT
??_C@_02IFGANFKF@25?$AA@ DB '25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMHLOEOE@24?$AA@
CONST	SEGMENT
??_C@_02JMHLOEOE@24?$AA@ DB '24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDDKHCCD@23?$AA@
CONST	SEGMENT
??_C@_02NDDKHCCD@23?$AA@ DB '23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBEDGC@22?$AA@
CONST	SEGMENT
??_C@_02MKCBEDGC@22?$AA@ DB '22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OBAMBAKB@21?$AA@
CONST	SEGMENT
??_C@_02OBAMBAKB@21?$AA@ DB '21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLJDCEPA@19?$AA@
CONST	SEGMENT
??_C@_02CLJDCEPA@19?$AA@ DB '19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCIIBFLB@18?$AA@
CONST	SEGMENT
??_C@_02DCIIBFLB@18?$AA@ DB '18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFBAAJHO@17?$AA@
CONST	SEGMENT
??_C@_02LFBAAJHO@17?$AA@ DB '17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JODNFKLN@14?$AA@
CONST	SEGMENT
??_C@_02JODNFKLN@14?$AA@ DB '14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMMMHK@13?$AA@
CONST	SEGMENT
??_C@_02NBHMMMHK@13?$AA@ DB '13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHPNDL@12?$AA@
CONST	SEGMENT
??_C@_02MIGHPNDL@12?$AA@ DB '12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKKOPI@11?$AA@
CONST	SEGMENT
??_C@_02ODEKKOPI@11?$AA@ DB '11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10?$AA@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10?$AA@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
_DATA	SEGMENT
?hudWinX@@3PAMA DD 0be19999ar			; -0.15	; hudWinX
	DD	0bf1eb852r			; -0.62
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	03f0ccccdr			; 0.55
	DD	0bf4ccccdr			; -0.8
	DD	0bf4ccccdr			; -0.8
	DD	000000000r			; 0
	DD	03f0ccccdr			; 0.55
	DD	080000000r			; -0
	DD	080000000r			; -0
	DD	03f0ccccdr			; 0.55
	DD	03f0ccccdr			; 0.55
	DD	0bf666666r			; -0.9
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f266666r			; 0.65
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
	DD	0bf000000r			; -0.5
	DD	03f0ccccdr			; 0.55
	DD	03f0ccccdr			; 0.55
	DD	0be99999ar			; -0.3
	DD	0be4ccccdr			; -0.2
	DD	0be333333r			; -0.175
	DD	0bf266666r			; -0.65
	DD	000000000r			; 0
	DD	03f051eb8r			; 0.52
	DD	03eb33333r			; 0.35
	DD	03f0ccccdr			; 0.55
	DD	0bf333333r			; -0.7
	DD	0bf666666r			; -0.9
	DD	03f051eb8r			; 0.52
	DD	03f266666r			; 0.65
	DD	0bf333333r			; -0.7
	DD	03f266666r			; 0.65
	DD	0bea66666r			; -0.325
	DD	0bea66666r			; -0.325
	DD	03f0f5c29r			; 0.56
	DD	0be99999ar			; -0.3
	DD	0bd4ccccdr			; -0.05
	DD	03f4ccccdr			; 0.8
	DD	0bf266666r			; -0.65
	DD	0bf400000r			; -0.75
	DD	0bf400000r			; -0.75
	DD	0bf266666r			; -0.65
	DD	03f4ccccdr			; 0.8
	DD	0bf4ccccdr			; -0.8
	DD	0bf666666r			; -0.9
	DD	0bf4ccccdr			; -0.8
	DD	0bf4ccccdr			; -0.8
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?hudWinY@@3PAMA DD 03f4ccccdr			; 0.8	; hudWinY
	DD	03e6b851fr			; 0.23
	DD	0be19999ar			; -0.15
	DD	0be6b851fr			; -0.23
	DD	03f0ccccdr			; 0.55
	DD	03e6b851fr			; 0.23
	DD	0be9eb852r			; -0.31
	DD	0bec7ae14r			; -0.39
	DD	000000000r			; 0
	DD	0bec7ae14r			; -0.39
	DD	03e4ccccdr			; 0.2
	DD	03d4ccccdr			; 0.05
	DD	0bef0a3d7r			; -0.47
	DD	0bf0ccccdr			; -0.55
	DD	0bef0a3d7r			; -0.47
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f2e147br			; 0.68
	DD	0bee66666r			; -0.45
	DD	0bf07ae14r			; -0.53
	DD	0bf1c28f6r			; -0.61
	DD	0bf30a3d7r			; -0.69
	DD	0bf47ae14r			; -0.78
	DD	0be9eb852r			; -0.31
	DD	0be4ccccdr			; -0.2
	DD	03ea3d70ar			; 0.32
	DD	0bcf5c28fr			; -0.03
	DD	0bde147aer			; -0.11
	DD	0bd8f5c29r			; -0.07
	DD	000000000r			; 0
	DD	0bd75c28fr			; -0.06
	DD	03e570a3dr			; 0.21
	DD	03f028f5cr			; 0.51
	DD	0bf0ccccdr			; -0.55
	DD	0bf2147aer			; -0.63
	DD	0be051eb8r			; -0.13
	DD	03f19999ar			; 0.6
	DD	0bdcccccdr			; -0.1
	DD	0bdcccccdr			; -0.1
	DD	03f59999ar			; 0.85
	DD	0be99999ar			; -0.3
	DD	03cf5c28fr			; 0.03
	DD	0be99999ar			; -0.3
	DD	03f19999ar			; 0.6
	DD	03d4ccccdr			; 0.05
	DD	0be051eb8r			; -0.13
	DD	0be6b851fr			; -0.23
	DD	0be99999ar			; -0.3
	DD	0bebd70a4r			; -0.37
	DD	03d8f5c29r			; 0.07
	DD	03d8f5c29r			; 0.07
	DD	0bca3d70ar			; -0.02
	DD	03d8f5c29r			; 0.07
	DD	03d8f5c29r			; 0.07
	ORG $+4
?hudWinWidth@@3PAMA DD 03dcccccdr		; 0.1	; hudWinWidth
	DD	03d4ccccdr			; 0.05
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03d4ccccdr			; 0.05
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03f266666r			; 0.65
	DD	03e99999ar			; 0.3
	DD	03e800000r			; 0.25
	DD	03e800000r			; 0.25
	DD	03eb33333r			; 0.35
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03e800000r			; 0.25
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03e99999ar			; 0.3
	DD	03e99999ar			; 0.3
	DD	03f19999ar			; 0.6
	DD	03ecccccdr			; 0.4
	DD	03eb33333r			; 0.35
	DD	03dcccccdr			; 0.1
	DD	000000000r			; 0
	DD	03dcccccdr			; 0.1
	DD	03e4ccccdr			; 0.2
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03eb33333r			; 0.35
	DD	03dcccccdr			; 0.1
	DD	03e800000r			; 0.25
	DD	03da3d70ar			; 0.08
	DD	03da3d70ar			; 0.08
	DD	03f266666r			; 0.65
	DD	03f266666r			; 0.65
	DD	03d75c28fr			; 0.06
	DD	03f000000r			; 0.5
	DD	03dcccccdr			; 0.1
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	DD	03e19999ar			; 0.15
	ORG $+4
?hudWinHeight@@3PAMA DD 03d75c28fr		; 0.06	; hudWinHeight
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	000000000r			; 0
	DD	03d75c28fr			; 0.06
	DD	03dcccccdr			; 0.1
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d8f5c29r			; 0.07
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	000000000r			; 0
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03f0ccccdr			; 0.55
	DD	03f0ccccdr			; 0.55
	DD	03dcccccdr			; 0.1
	DD	03dcccccdr			; 0.1
	DD	03ee66666r			; 0.45
	DD	03fd9999ar			; 1.7
	DD	03d4ccccdr			; 0.05
	DD	03f0ccccdr			; 0.55
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	DD	03d75c28fr			; 0.06
	ORG $+4
?hudNumbers@@3PAPADA DD FLAT:??_C@_01GBGANLPD@0?$AA@	; hudNumbers
	DD	FLAT:??_C@_01HIHLOKLC@1?$AA@
	DD	FLAT:??_C@_01FDFGLJHB@2?$AA@
	DD	FLAT:??_C@_01EKENIIDA@3?$AA@
	DD	FLAT:??_C@_01FAMBOPH@4?$AA@
	DD	FLAT:??_C@_01BMBHCPLG@5?$AA@
	DD	FLAT:??_C@_01DHDKHMHF@6?$AA@
	DD	FLAT:??_C@_01COCBENDE@7?$AA@
	DD	FLAT:??_C@_01KJLJFBPL@8?$AA@
	DD	FLAT:??_C@_01LAKCGALK@9?$AA@
	DD	FLAT:??_C@_02PKFBJPLJ@10?$AA@
	DD	FLAT:??_C@_02ODEKKOPI@11?$AA@
	DD	FLAT:??_C@_02MIGHPNDL@12?$AA@
	DD	FLAT:??_C@_02NBHMMMHK@13?$AA@
	DD	FLAT:??_C@_02JODNFKLN@14?$AA@
	DD	FLAT:??_C@_02IHCGGLPM@15?$AA@
	DD	FLAT:??_C@_02KMALDIDP@16?$AA@
	DD	FLAT:??_C@_02LFBAAJHO@17?$AA@
	DD	FLAT:??_C@_02DCIIBFLB@18?$AA@
	DD	FLAT:??_C@_02CLJDCEPA@19?$AA@
	DD	FLAT:??_C@_02PIBHCBOA@20?$AA@
	DD	FLAT:??_C@_02OBAMBAKB@21?$AA@
	DD	FLAT:??_C@_02MKCBEDGC@22?$AA@
	DD	FLAT:??_C@_02NDDKHCCD@23?$AA@
	DD	FLAT:??_C@_02JMHLOEOE@24?$AA@
	DD	FLAT:??_C@_02IFGANFKF@25?$AA@
	DD	FLAT:??_C@_02KOENIGGG@26?$AA@
	DD	FLAT:??_C@_02LHFGLHCH@27?$AA@
	DD	FLAT:??_C@_02DAMOKLOI@28?$AA@
	DD	FLAT:??_C@_02CJNFJKKJ@29?$AA@
	DD	FLAT:??_C@_02PJNFELNH@30?$AA@
	DD	FLAT:??_C@_02OAMOHKJG@31?$AA@
	DD	FLAT:??_C@_02MLODCJFF@32?$AA@
	DD	FLAT:??_C@_02NCPIBIBE@33?$AA@
	DD	FLAT:??_C@_02JNLJIOND@34?$AA@
	DD	FLAT:??_C@_02IEKCLPJC@35?$AA@
	DD	FLAT:??_C@_02KPIPOMFB@36?$AA@
	DD	FLAT:??_C@_02LGJENNBA@37?$AA@
	DD	FLAT:??_C@_02DBAMMBNP@38?$AA@
	DD	FLAT:??_C@_02CIBHPAJO@39?$AA@
	DD	FLAT:??_C@_02PMJKFNFC@40?$AA@
	DD	FLAT:??_C@_02OFIBGMBD@41?$AA@
	DD	FLAT:??_C@_02MOKMDPNA@42?$AA@
	DD	FLAT:??_C@_02NHLHAOJB@43?$AA@
	DD	FLAT:??_C@_02JIPGJIFG@44?$AA@
	DD	FLAT:??_C@_02IBONKJBH@45?$AA@
	DD	FLAT:??_C@_02KKMAPKNE@46?$AA@
	DD	FLAT:??_C@_02LDNLMLJF@47?$AA@
	DD	FLAT:??_C@_02DEEDNHFK@48?$AA@
	DD	FLAT:??_C@_02CNFIOGBL@49?$AA@
	DD	FLAT:??_C@_02PNFIDHGF@50?$AA@
	DD	FLAT:??_C@_02OEEDAGCE@51?$AA@
	DD	FLAT:??_C@_02MPGOFFOH@52?$AA@
	DD	FLAT:??_C@_02NGHFGEKG@53?$AA@
	DD	FLAT:??_C@_02JJDEPCGB@54?$AA@
	DD	FLAT:??_C@_02IACPMDCA@55?$AA@
	DD	FLAT:??_C@_02KLACJAOD@56?$AA@
	DD	FLAT:??_C@_02LCBJKBKC@57?$AA@
	DD	FLAT:??_C@_02DFIBLNGN@58?$AA@
	DD	FLAT:??_C@_02CMJKIMCM@59?$AA@
	DD	FLAT:??_C@_02PPBOIJDM@60?$AA@
	DD	FLAT:??_C@_02OGAFLIHN@61?$AA@
	DD	FLAT:??_C@_02MNCIOLLO@62?$AA@
	DD	FLAT:??_C@_02NEDDNKPP@63?$AA@
	DD	FLAT:??_C@_02JLHCEMDI@64?$AA@
	DD	FLAT:??_C@_02ICGJHNHJ@65?$AA@
	DD	FLAT:??_C@_02KJEECOLK@66?$AA@
	DD	FLAT:??_C@_02LAFPBPPL@67?$AA@
	DD	FLAT:??_C@_02DHMHADDE@68?$AA@
	DD	FLAT:??_C@_02CONMDCHF@69?$AA@
	DD	FLAT:??_C@_02PONMODAL@70?$AA@
	DD	FLAT:??_C@_02OHMHNCEK@71?$AA@
	DD	FLAT:??_C@_02MMOKIBIJ@72?$AA@
	DD	FLAT:??_C@_02NFPBLAMI@73?$AA@
	DD	FLAT:??_C@_02JKLACGAP@74?$AA@
	DD	FLAT:??_C@_02IDKLBHEO@75?$AA@
	DD	FLAT:??_C@_02KIIGEEIN@76?$AA@
	DD	FLAT:??_C@_02LBJNHFMM@77?$AA@
	DD	FLAT:??_C@_02DGAFGJAD@78?$AA@
	DD	FLAT:??_C@_02CPBOFIEC@79?$AA@
	DD	FLAT:??_C@_02PFIAKEDG@80?$AA@
	DD	FLAT:??_C@_02OMJLJFHH@81?$AA@
	DD	FLAT:??_C@_02MHLGMGLE@82?$AA@
	DD	FLAT:??_C@_02NOKNPHPF@83?$AA@
	DD	FLAT:??_C@_02JBOMGBDC@84?$AA@
	DD	FLAT:??_C@_02IIPHFAHD@85?$AA@
	DD	FLAT:??_C@_02KDNKADLA@86?$AA@
	DD	FLAT:??_C@_02LKMBDCPB@87?$AA@
	DD	FLAT:??_C@_02DNFJCODO@88?$AA@
	DD	FLAT:??_C@_02CEECBPHP@89?$AA@
	DD	FLAT:??_C@_02PEECMOAB@90?$AA@
	DD	FLAT:??_C@_02ONFJPPEA@91?$AA@
	DD	FLAT:??_C@_02MGHEKMID@92?$AA@
	DD	FLAT:??_C@_02NPGPJNMC@93?$AA@
	DD	FLAT:??_C@_02JACOALAF@94?$AA@
	DD	FLAT:??_C@_02IJDFDKEE@95?$AA@
	DD	FLAT:??_C@_02KCBIGJIH@96?$AA@
	DD	FLAT:??_C@_02LLADFIMG@97?$AA@
	DD	FLAT:??_C@_02DMJLEEAJ@98?$AA@
	DD	FLAT:??_C@_02CFIAHFEI@99?$AA@
	DD	FLAT:??_C@_03GNABGMEE@100?$AA@
	ORG $+4
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_HUDcolor DD	0ff00ff00H
	DD	0ff0000ffH
	DD	0ffff0000H
	DD	0ffffff00H
	DD	0ffff00ffH
	DD	0ff00ffffH
	DD	0ff00007fH
	DD	0fffffffeH
_DATA	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
_Tadpolesize DD	03ced9168r			; 0.029
_Linelenght DD	03d8f5c29r			; 0.07
_PitchLadderDiff DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_acosf
PUBLIC	_atanf
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	_tanf
PUBLIC	?acos@@YAMM@Z					; acos
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?tan@@YAMM@Z					; tan
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?Pitch@VuEntity@@QBEMXZ				; VuEntity::Pitch
PUBLIC	?Roll@VuEntity@@QBEMXZ				; VuEntity::Roll
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	??0DrawableClass@@IAE@XZ			; DrawableClass::DrawableClass
PUBLIC	??1DrawableClass@@UAE@XZ			; DrawableClass::~DrawableClass
PUBLIC	?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z ; DrawableClass::Display
PUBLIC	?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z ; DrawableClass::DisplayInit
PUBLIC	?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ ; DrawableClass::GetDisplay
PUBLIC	?IsSOI@DrawableClass@@QAEHXZ			; DrawableClass::IsSOI
PUBLIC	?PushButton@DrawableClass@@UAEXHH@Z		; DrawableClass::PushButton
PUBLIC	??_GDrawableClass@@UAEPAXI@Z			; DrawableClass::`scalar deleting destructor'
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?CurrentForegroundColor@ContextMPR@@QAEHXZ	; ContextMPR::CurrentForegroundColor
PUBLIC	??0HudDataType@@QAE@XZ				; HudDataType::HudDataType
PUBLIC	?IsSet@HudDataType@@QAEHH@Z			; HudDataType::IsSet
PUBLIC	?DrawFPM@HudClass@@AAEXXZ			; HudClass::DrawFPM
PUBLIC	?DrawHorizonLine@HudClass@@AAEXXZ		; HudClass::DrawHorizonLine
PUBLIC	?DrawPitchLadder@HudClass@@AAEXXZ		; HudClass::DrawPitchLadder
PUBLIC	?DrawTDBox@HudClass@@AAEXXZ			; HudClass::DrawTDBox
PUBLIC	?DrawDTOSSBox@HudClass@@AAEXXZ			; HudClass::DrawDTOSSBox
PUBLIC	?DrawTDMarker@HudClass@@AAEXMMMM@Z		; HudClass::DrawTDMarker
PUBLIC	?DrawAATDBox@HudClass@@AAEXXZ			; HudClass::DrawAATDBox
PUBLIC	?DrawBoresightCross@HudClass@@AAEXXZ		; HudClass::DrawBoresightCross
PUBLIC	?DrawAlphaNumeric@HudClass@@AAEXXZ		; HudClass::DrawAlphaNumeric
PUBLIC	?DrawDesignateMarker@HudClass@@AAEXW4DesignateShape@1@MMM@Z ; HudClass::DrawDesignateMarker
PUBLIC	?DrawF18HUD@HudClass@@AAEXXZ			; HudClass::DrawF18HUD
PUBLIC	?DrawF14HUD@HudClass@@AAEXXZ			; HudClass::DrawF14HUD
PUBLIC	?DrawF15HUD@HudClass@@AAEXXZ			; HudClass::DrawF15HUD
PUBLIC	?DrawA10HUD@HudClass@@AAEXXZ			; HudClass::DrawA10HUD
PUBLIC	?DrawWindowString@HudClass@@AAEXHPADH@Z		; HudClass::DrawWindowString
PUBLIC	?MRToHudUnits@HudClass@@AAEMM@Z			; HudClass::MRToHudUnits
PUBLIC	?RadToHudUnits@HudClass@@AAEMM@Z		; HudClass::RadToHudUnits
PUBLIC	?RadToHudUnitsX@HudClass@@AAEMM@Z		; HudClass::RadToHudUnitsX
PUBLIC	?RadToHudUnitsY@HudClass@@AAEMM@Z		; HudClass::RadToHudUnitsY
PUBLIC	?HudUnitsToRad@HudClass@@AAEMM@Z		; HudClass::HudUnitsToRad
PUBLIC	?CheckGhostHorizon@HudClass@@AAE_NMMMMMMM@Z	; HudClass::CheckGhostHorizon
PUBLIC	??0HudClass@@QAE@XZ				; HudClass::HudClass
PUBLIC	??1HudClass@@UAE@XZ				; HudClass::~HudClass
PUBLIC	?SetOwnship@HudClass@@QAEXPAVAircraftClass@@@Z	; HudClass::SetOwnship
PUBLIC	?SetTarget@HudClass@@QAEXPAVSimObjectType@@@Z	; HudClass::SetTarget
PUBLIC	?ClearTarget@HudClass@@QAEXXZ			; HudClass::ClearTarget
PUBLIC	?GetBoresightPos@HudClass@@QAEXPAM0@Z		; HudClass::GetBoresightPos
PUBLIC	?SetHalfAngle@HudClass@@QAEXMMM@Z		; HudClass::SetHalfAngle
PUBLIC	?GetDisplay@HudClass@@UAEPAVVirtualDisplay@@XZ	; HudClass::GetDisplay
PUBLIC	?Display@HudClass@@QAEXPAVVirtualDisplay@@_N@Z	; HudClass::Display
PUBLIC	?Display@HudClass@@UAEXPAVVirtualDisplay@@@Z	; HudClass::Display
PUBLIC	?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z	; HudClass::DisplayInit
PUBLIC	?CanSeeTarget@HudClass@@QAEPAVVuEntity@@HPAV2@PAVFalconEntity@@@Z ; HudClass::CanSeeTarget
PUBLIC	?PushButton@HudClass@@UAEXHH@Z			; HudClass::PushButton
PUBLIC	?GetHudColor@HudClass@@QAEKXZ			; HudClass::GetHudColor
PUBLIC	?SetHudColor@HudClass@@QAEXK@Z			; HudClass::SetHudColor
PUBLIC	?HudColorStep@HudClass@@QAEXXZ			; HudClass::HudColorStep
PUBLIC	?SetLightLevel@HudClass@@QAEXXZ			; HudClass::SetLightLevel
PUBLIC	?CalculateBrightness@HudClass@@QAEXMPAK@Z	; HudClass::CalculateBrightness
PUBLIC	?SetContrastLevel@HudClass@@QAEXXZ		; HudClass::SetContrastLevel
PUBLIC	?GetScalesSwitch@HudClass@@QAEHXZ		; HudClass::GetScalesSwitch
PUBLIC	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch
PUBLIC	?CycleScalesSwitch@HudClass@@QAEXXZ		; HudClass::CycleScalesSwitch
PUBLIC	?GetFPMSwitch@HudClass@@QAEHXZ			; HudClass::GetFPMSwitch
PUBLIC	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z	; HudClass::SetFPMSwitch
PUBLIC	?CycleFPMSwitch@HudClass@@QAEXXZ		; HudClass::CycleFPMSwitch
PUBLIC	?GetDriftCOSwitch@HudClass@@QAEHXZ		; HudClass::GetDriftCOSwitch
PUBLIC	?SetDriftCOSwitch@HudClass@@QAEXW4DriftCOSwitch@1@@Z ; HudClass::SetDriftCOSwitch
PUBLIC	?CycleDriftCOSwitch@HudClass@@QAEXXZ		; HudClass::CycleDriftCOSwitch
PUBLIC	?GetDEDSwitch@HudClass@@QAEHXZ			; HudClass::GetDEDSwitch
PUBLIC	?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z	; HudClass::SetDEDSwitch
PUBLIC	?CycleDEDSwitch@HudClass@@QAEXXZ		; HudClass::CycleDEDSwitch
PUBLIC	?GetVelocitySwitch@HudClass@@QAEHXZ		; HudClass::GetVelocitySwitch
PUBLIC	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch
PUBLIC	?CycleVelocitySwitch@HudClass@@QAEXXZ		; HudClass::CycleVelocitySwitch
PUBLIC	?GetRadarSwitch@HudClass@@QAEHXZ		; HudClass::GetRadarSwitch
PUBLIC	?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z ; HudClass::SetRadarSwitch
PUBLIC	?CycleRadarSwitch@HudClass@@QAEXXZ		; HudClass::CycleRadarSwitch
PUBLIC	?GetBrightnessSwitch@HudClass@@QAEHXZ		; HudClass::GetBrightnessSwitch
PUBLIC	?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z ; HudClass::SetBrightnessSwitch
PUBLIC	?CycleBrightnessSwitch@HudClass@@QAEXXZ		; HudClass::CycleBrightnessSwitch
PUBLIC	?CycleBrightnessSwitchUp@HudClass@@QAEXXZ	; HudClass::CycleBrightnessSwitchUp
PUBLIC	?CycleBrightnessSwitchDown@HudClass@@QAEXXZ	; HudClass::CycleBrightnessSwitchDown
PUBLIC	??_GHudClass@@UAEPAXI@Z				; HudClass::`scalar deleting destructor'
PUBLIC	?GetState@CDXEngine@@QAE?AW4DX_StateType@@XZ	; CDXEngine::GetState
PUBLIC	?IsSetFlag@SimBaseClass@@QBEHH@Z		; SimBaseClass::IsSetFlag
PUBLIC	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ		; VuBin<SimWeaponClass>::operator bool
PUBLIC	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
PUBLIC	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
PUBLIC	?IsAGMasterMode@FireControlComputer@@QAEHXZ	; FireControlComputer::IsAGMasterMode
PUBLIC	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
PUBLIC	?NumCurrentWpn@SMSBaseClass@@QAEHXZ		; SMSBaseClass::NumCurrentWpn
PUBLIC	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
PUBLIC	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
PUBLIC	?IsF16@AircraftClass@@QAEHXZ			; AircraftClass::IsF16
PUBLIC	?GetTypeAC@AirframeClass@@QAEHXZ		; AirframeClass::GetTypeAC
PUBLIC	?GetBingoSnd@AirframeClass@@QAEHXZ		; AirframeClass::GetBingoSnd
PUBLIC	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ	; PlayerOptionsClass::GetAvionicsType
PUBLIC	??0VirtualDisplay@@QAE@XZ			; VirtualDisplay::VirtualDisplay
PUBLIC	??1VirtualDisplay@@UAE@XZ			; VirtualDisplay::~VirtualDisplay
PUBLIC	?Circle@VirtualDisplay@@UAEXMMM@Z		; VirtualDisplay::Circle
PUBLIC	?Arc@VirtualDisplay@@UAEXMMMMM@Z		; VirtualDisplay::Arc
PUBLIC	?TextWidth@VirtualDisplay@@UAEMPAD@Z		; VirtualDisplay::TextWidth
PUBLIC	?TextHeight@VirtualDisplay@@UAEMXZ		; VirtualDisplay::TextHeight
PUBLIC	?CurFont@VirtualDisplay@@SAHXZ			; VirtualDisplay::CurFont
PUBLIC	?SetLineStyle@VirtualDisplay@@UAEXH@Z		; VirtualDisplay::SetLineStyle
PUBLIC	?Color@VirtualDisplay@@UAEKXZ			; VirtualDisplay::Color
PUBLIC	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ	; VirtualDisplay::CenterOriginInViewport
PUBLIC	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ	; VirtualDisplay::ZeroRotationAboutOrigin
PUBLIC	??_GVirtualDisplay@@UAEPAXI@Z			; VirtualDisplay::`scalar deleting destructor'
PUBLIC	??0Render2D@@QAE@XZ				; Render2D::Render2D
PUBLIC	??1Render2D@@UAE@XZ				; Render2D::~Render2D
PUBLIC	?ClearDraw@Render2D@@UAEXXZ			; Render2D::ClearDraw
PUBLIC	?ClearZBuffer@Render2D@@UAEXXZ			; Render2D::ClearZBuffer
PUBLIC	?Color@Render2D@@UAEKXZ				; Render2D::Color
PUBLIC	?SetColor@Render2D@@UAEXK@Z			; Render2D::SetColor
PUBLIC	?SetBackground@Render2D@@UAEXK@Z		; Render2D::SetBackground
PUBLIC	?SetLineStyle@Render2D@@UAEXH@Z			; Render2D::SetLineStyle
PUBLIC	??_GRender2D@@UAEPAXI@Z				; Render2D::`scalar deleting destructor'
PUBLIC	?MasterCaution@FackClass@@QAEHXZ		; FackClass::MasterCaution
PUBLIC	?WarnReset@FackClass@@QAEHXZ			; FackClass::WarnReset
PUBLIC	?GetCMDSTR@ICPClass@@QAEHXZ			; ICPClass::GetCMDSTR
PUBLIC	?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ; SmsDrawable::DisplayMode
PUBLIC	?IsEnabled@LantirnClass@@QAE_NXZ		; LantirnClass::IsEnabled
PUBLIC	?GetSeekerType@MissileClass@@QAEHXZ		; MissileClass::GetSeekerType
PUBLIC	?IsSet@RadarDopplerClass@@QAEHH@Z		; RadarDopplerClass::IsSet
PUBLIC	?GetAmbientValue@CTimeOfDay@@QAEMXZ		; CTimeOfDay::GetAmbientValue
PUBLIC	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7DrawableClass@@6B@				; DrawableClass::`vftable'
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_7HudClass@@6B@				; HudClass::`vftable'
PUBLIC	??_7VirtualDisplay@@6B@				; VirtualDisplay::`vftable'
PUBLIC	??_7Render2D@@6B@				; Render2D::`vftable'
PUBLIC	??_C@_03FNHOLOBO@SOI?$AA@			; `string'
PUBLIC	??_C@_07GMFMKBEK@RPM?5?$CF3d?$AA@		; `string'
PUBLIC	??_C@_06HGGOEBHK@?$CF02?41f?$AA@		; `string'
PUBLIC	??_C@_03NALBENGH@ILS?$AA@			; `string'
PUBLIC	??_C@_03NAHIIPNL@SAF?$AA@			; `string'
PUBLIC	??_C@_03NHPMNECN@ARM?$AA@			; `string'
PUBLIC	??_C@_03DNJPAHKI@SIM?$AA@			; `string'
PUBLIC	??_C@_04GEFJINEE@?$CF?42f?$AA@			; `string'
PUBLIC	??_C@_04GGBPDDBN@?$CF?41f?$AA@			; `string'
PUBLIC	??_C@_05OKAJNMKE@ALIGN?$AA@			; `string'
PUBLIC	??_C@_04DCDGPODJ@JETT?$AA@			; `string'
PUBLIC	??_C@_05OPEIBKFE@?$CFd?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_03PHIAGONP@PRE?$AA@			; `string'
PUBLIC	??_C@_03NOAAMIEF@VIS?$AA@			; `string'
PUBLIC	??_C@_04DKKPAKDO@BORE?$AA@			; `string'
PUBLIC	??_C@_04JBIELMDE@WARN?$AA@			; `string'
PUBLIC	??_C@_04DICABFLJ@FUEL?$AA@			; `string'
PUBLIC	??_C@_08EMPPOEK@TRP?5FUEL?$AA@			; `string'
PUBLIC	??_C@_09IMNIJPFK@FUEL?5?$CF03d?$AA@		; `string'
PUBLIC	??_C@_06HICPBJFO@FLY?5UP?$AA@			; `string'
PUBLIC	??_C@_08OOPLBCBC@OBSTACLE?$AA@			; `string'
PUBLIC	??_C@_04BJJAFLBC@SLOW?$AA@			; `string'
PUBLIC	??_C@_04GHNNFJCK@?$CF?40f?$AA@			; `string'
PUBLIC	??_C@_06MNCBBDMH@NO?5RAD?$AA@			; `string'
PUBLIC	??_C@_06LACKECLL@GO?5STT?$AA@			; `string'
PUBLIC	??_C@_06BNGHLEKI@M?5?$CF?42f?$AA@		; `string'
PUBLIC	??_C@_06LLFBFFLP@G?5?$CF?41f?$AA@		; `string'
PUBLIC	??_C@_09LGMCLHNC@RDC?5SPEED?$AA@		; `string'
PUBLIC	??_C@_04GLGLOEHP@T?5?$CFd?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4VirtualDisplay@@6B@			; VirtualDisplay::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVirtualDisplay@@@8			; VirtualDisplay `RTTI Type Descriptor'
PUBLIC	??_R3VirtualDisplay@@8				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VirtualDisplay@@8				; VirtualDisplay::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VirtualDisplay@@8			; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DrawableClass@@6B@				; DrawableClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDrawableClass@@@8			; DrawableClass `RTTI Type Descriptor'
PUBLIC	??_R3DrawableClass@@8				; DrawableClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DrawableClass@@8				; DrawableClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DrawableClass@@8			; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4HudClass@@6B@				; HudClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHudClass@@@8				; HudClass `RTTI Type Descriptor'
PUBLIC	??_R3HudClass@@8				; HudClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HudClass@@8				; HudClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HudClass@@8			; HudClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Render2D@@8			; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRender2D@@@8				; Render2D `RTTI Type Descriptor'
PUBLIC	??_R3Render2D@@8				; Render2D::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Render2D@@8				; Render2D::`RTTI Base Class Array'
PUBLIC	??_R4Render2D@@6B@				; Render2D::`RTTI Complete Object Locator'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3bf5c28f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c75c28f
PUBLIC	__real@3c8efa34
PUBLIC	__real@3c8efa35
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3cc82b15
PUBLIC	__real@3ccccccd
PUBLIC	__real@3cf5c28f
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3d56774e
PUBLIC	__real@3d5a511a
PUBLIC	__real@3d8f5c29
PUBLIC	__real@3d961e4f
PUBLIC	__real@3d99999a
PUBLIC	__real@3da3d70a
PUBLIC	__real@3db851ec
PUBLIC	__real@3dcccccd
PUBLIC	__real@3dda511a
PUBLIC	__real@3df5c28f
PUBLIC	__real@3e01a36e
PUBLIC	__real@3e0f5c29
PUBLIC	__real@3e19999a
PUBLIC	__real@3e23d70a
PUBLIC	__real@3e29fbe7
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e978d50
PUBLIC	__real@3e99999a
PUBLIC	__real@3eaa7efa
PUBLIC	__real@3eb33333
PUBLIC	__real@3ecccccd
PUBLIC	__real@3edd1044
PUBLIC	__real@3ee66666
PUBLIC	__real@3f000000
PUBLIC	__real@3f060a91
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f11eb85
PUBLIC	__real@3f178d50
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f19999a
PUBLIC	__real@3f266666
PUBLIC	__real@3f2ac083
PUBLIC	__real@3f3851ec
PUBLIC	__real@3f3d70a4
PUBLIC	__real@3f400000
PUBLIC	__real@3f428f5c
PUBLIC	__real@3f47ae14
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f553f7d
PUBLIC	__real@3f6147ae
PUBLIC	__real@3f666666
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3f860a91
PUBLIC	__real@3f99999a
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@4019999a
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@41000000
PUBLIC	__real@4104cccd
PUBLIC	__real@41200000
PUBLIC	__real@41500000
PUBLIC	__real@41700000
PUBLIC	__real@41880000
PUBLIC	__real@41a00000
PUBLIC	__real@420c0000
PUBLIC	__real@42340000
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@43610000
PUBLIC	__real@43700000
PUBLIC	__real@437f0000
PUBLIC	__real@43960000
PUBLIC	__real@43a00000
PUBLIC	__real@454cffae
PUBLIC	__real@469c4000
PUBLIC	__real@8000000000000000
PUBLIC	__real@bbf5c28f
PUBLIC	__real@bc23d70a
PUBLIC	__real@bc75c28f
PUBLIC	__real@bcf5c28f
PUBLIC	__real@bd4ccccd
PUBLIC	__real@bd99999a
PUBLIC	__real@bdb851ec
PUBLIC	__real@bdcccccd
PUBLIC	__real@bdd6774e
PUBLIC	__real@bde147ae
PUBLIC	__real@bdf5c28f
PUBLIC	__real@be051eb8
PUBLIC	__real@be0efa34
PUBLIC	__real@be0f5c29
PUBLIC	__real@be19999a
PUBLIC	__real@be23d70a
PUBLIC	__real@be29fbe7
PUBLIC	__real@be2e147b
PUBLIC	__real@be75c28f
PUBLIC	__real@be800000
PUBLIC	__real@beaa7efa
PUBLIC	__real@becccccd
PUBLIC	__real@bf000000
PUBLIC	__real@bf19999a
PUBLIC	__real@bf2ac083
PUBLIC	__real@bf333333
PUBLIC	__real@bf400000
PUBLIC	__real@bf428f5c
PUBLIC	__real@bf47ae14
PUBLIC	__real@bf4ccccd
PUBLIC	__real@bf51eb85
PUBLIC	__real@bf553f7d
PUBLIC	__real@bf59999a
PUBLIC	__real@bf6147ae
PUBLIC	__real@bf666666
PUBLIC	__real@bf68f5c3
PUBLIC	__real@bf6b851f
PUBLIC	__real@bf6e147b
PUBLIC	__real@bf733333
PUBLIC	__real@bf800000
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0200000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_sprintf:PROC
EXTRN	_acos:PROC
EXTRN	_atan:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?DisplayExit@DrawableClass@@UAEXXZ:PROC		; DrawableClass::DisplayExit
EXTRN	??_EDrawableClass@@UAEPAXI@Z:PROC		; DrawableClass::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??0ContextMPR@@QAE@XZ:PROC			; ContextMPR::ContextMPR
EXTRN	??1ContextMPR@@UAE@XZ:PROC			; ContextMPR::~ContextMPR
EXTRN	?SetState@ContextMPR@@QAEXGK@Z:PROC		; ContextMPR::SetState
EXTRN	?ClearBuffers@ContextMPR@@QAEXG@Z:PROC		; ContextMPR::ClearBuffers
EXTRN	?SelectForegroundColor@ContextMPR@@QAEXH@Z:PROC	; ContextMPR::SelectForegroundColor
EXTRN	?RestoreState@ContextMPR@@QAEXH@Z:PROC		; ContextMPR::RestoreState
EXTRN	?DrawAirspeed@HudClass@@AAEXXZ:PROC		; HudClass::DrawAirspeed
EXTRN	?DrawAltitude@HudClass@@AAEXXZ:PROC		; HudClass::DrawAltitude
EXTRN	?DrawHeading@HudClass@@AAEXXZ:PROC		; HudClass::DrawHeading
EXTRN	?DrawILS@HudClass@@AAEXXZ:PROC			; HudClass::DrawILS
EXTRN	?DrawNav@HudClass@@AAEXXZ:PROC			; HudClass::DrawNav
EXTRN	?DrawAirMissile@HudClass@@AAEXXZ:PROC		; HudClass::DrawAirMissile
EXTRN	?DrawDogfight@HudClass@@AAEXXZ:PROC		; HudClass::DrawDogfight
EXTRN	?DrawMissileOverride@HudClass@@AAEXXZ:PROC	; HudClass::DrawMissileOverride
EXTRN	?DrawAirGroundGravity@HudClass@@AAEXXZ:PROC	; HudClass::DrawAirGroundGravity
EXTRN	?DrawAirGroundRocket@HudClass@@AAEXXZ:PROC	; HudClass::DrawAirGroundRocket
EXTRN	?DrawTargetingPod@HudClass@@AAEXXZ:PROC		; HudClass::DrawTargetingPod
EXTRN	?DrawGroundMissile@HudClass@@AAEXXZ:PROC	; HudClass::DrawGroundMissile
EXTRN	?DrawHarm@HudClass@@AAEXXZ:PROC			; HudClass::DrawHarm
EXTRN	?DrawRPod@HudClass@@AAEXXZ:PROC			; HudClass::DrawRPod
EXTRN	?DrawGuns@HudClass@@AAEXXZ:PROC			; HudClass::DrawGuns
EXTRN	?DrawMANReticle@HudClass@@QAEXXZ:PROC		; HudClass::DrawMANReticle
EXTRN	?DrawCMDSTRG@HudClass@@QAEXXZ:PROC		; HudClass::DrawCMDSTRG
EXTRN	??_EHudClass@@UAEPAXI@Z:PROC			; HudClass::`vector deleting destructor'
EXTRN	_F4SoundFXSetDist:PROC
EXTRN	_F4SoundFXPlaying:PROC
EXTRN	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z:PROC	; MFDClass::SetNewMode
EXTRN	?MFDSwapDisplays@@YAXXZ:PROC			; MFDSwapDisplays
EXTRN	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z:PROC ; FindSensor
EXTRN	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ:PROC ; FireControlComputer::GetMainMasterMode
EXTRN	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z:PROC ; AircraftClass::HasPower
EXTRN	?Reference@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Reference
EXTRN	?Release@SimObjectType@@QAEXXZ:PROC		; SimObjectType::Release
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?CheckLOS@OTWDriverClass@@QAEHPAVFalconEntity@@0@Z:PROC ; OTWDriverClass::CheckLOS
EXTRN	?Setup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Setup
EXTRN	?Cleanup@VirtualDisplay@@UAEXXZ:PROC		; VirtualDisplay::Cleanup
EXTRN	?Point@VirtualDisplay@@UAEXMM@Z:PROC		; VirtualDisplay::Point
EXTRN	?Line@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Line@VirtualDisplay@@UAEXMMMMM@Z:PROC		; VirtualDisplay::Line
EXTRN	?Tri@VirtualDisplay@@UAEXMMMMMM@Z:PROC		; VirtualDisplay::Tri
EXTRN	?Oval@VirtualDisplay@@UAEXMMMM@Z:PROC		; VirtualDisplay::Oval
EXTRN	?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z:PROC	; VirtualDisplay::OvalArc
EXTRN	?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextLeft
EXTRN	?TextRight@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextRight
EXTRN	?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextLeftVertical
EXTRN	?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextRightVertical
EXTRN	?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z:PROC	; VirtualDisplay::TextCenter
EXTRN	?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z:PROC ; VirtualDisplay::TextCenterVertical
EXTRN	?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z:PROC	; VirtualDisplay::TextWrap
EXTRN	?ScreenTextHeight@VirtualDisplay@@SAHXZ:PROC	; VirtualDisplay::ScreenTextHeight
EXTRN	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z:PROC	; VirtualDisplay::ScreenTextWidth
EXTRN	?SetFont@VirtualDisplay@@SAXH@Z:PROC		; VirtualDisplay::SetFont
EXTRN	?SetViewport@VirtualDisplay@@UAEXMMMM@Z:PROC	; VirtualDisplay::SetViewport
EXTRN	?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z:PROC ; VirtualDisplay::SetViewportRelative
EXTRN	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z:PROC ; VirtualDisplay::AdjustOriginInViewport
EXTRN	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z:PROC ; VirtualDisplay::AdjustRotationAboutOrigin
EXTRN	?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z:PROC	; VirtualDisplay::Render2DTri
EXTRN	??_EVirtualDisplay@@UAEPAXI@Z:PROC		; VirtualDisplay::`vector deleting destructor'
EXTRN	?Setup@Render2D@@UAEXPAVImageBuffer@@@Z:PROC	; Render2D::Setup
EXTRN	?Cleanup@Render2D@@UAEXXZ:PROC			; Render2D::Cleanup
EXTRN	?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z:PROC ; Render2D::SetImageBuffer
EXTRN	?StartDraw@Render2D@@UAEXXZ:PROC		; Render2D::StartDraw
EXTRN	?EndDraw@Render2D@@UAEXXZ:PROC			; Render2D::EndDraw
EXTRN	?SetViewport@Render2D@@UAEXMMMM@Z:PROC		; Render2D::SetViewport
EXTRN	?Render2DPoint@Render2D@@UAEXMM@Z:PROC		; Render2D::Render2DPoint
EXTRN	?Render2DLine@Render2D@@UAEXMMMM@Z:PROC		; Render2D::Render2DLine
EXTRN	?Render2DTri@Render2D@@UAEXMMMMMM@Z:PROC	; Render2D::Render2DTri
EXTRN	?ScreenText@Render2D@@UAEXMMPBDH@Z:PROC		; Render2D::ScreenText
EXTRN	??_ERender2D@@UAEPAXI@Z:PROC			; Render2D::`vector deleting destructor'
EXTRN	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ:PROC ; SimulationDriver::GetPlayerAircraft
EXTRN	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z:PROC ; FackClass::GetFault
EXTRN	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z:PROC ; FackClass::GetFault
EXTRN	?ExecPfl@ICPClass@@QAEXXZ:PROC			; ICPClass::ExecPfl
EXTRN	?Exec@ICPClass@@QAEXXZ:PROC			; ICPClass::Exec
EXTRN	?GetDEDStrings@ICPClass@@QAEXPAD00@Z:PROC	; ICPClass::GetDEDStrings
EXTRN	?HudFont@CockpitManager@@QAEHXZ:PROC		; CockpitManager::HudFont
EXTRN	?GetBullseyeToOwnship@@YAXPAD@Z:PROC		; GetBullseyeToOwnship
EXTRN	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z:PROC ; SIMLIB_IO_CLASS::GetAxisValue
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuxRealTime@@3KA:DWORD				; vuxRealTime
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?m_RenderState@CDXEngine@@0W4DX_StateType@@A:DWORD ; CDXEngine::m_RenderState
EXTRN	?TheDXEngine@@3VCDXEngine@@A:BYTE		; TheDXEngine
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?g_bRealisticAvionics@@3_NA:BYTE		; g_bRealisticAvionics
EXTRN	?MfdDisplay@@3PAPAVMFDClass@@A:BYTE		; MfdDisplay
EXTRN	?PlayerOptions@@3VPlayerOptionsClass@@A:BYTE	; PlayerOptions
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?ObserverPitch@@3MA:DWORD			; ObserverPitch
EXTRN	?pFontSet@VirtualDisplay@@2PAUFontSet@@A:DWORD	; VirtualDisplay::pFontSet
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?cockpitFlightData@@3VFlightData@@A:BYTE	; cockpitFlightData
EXTRN	?theLantirn@@3PAVLantirnClass@@A:DWORD		; theLantirn
EXTRN	?TheTimeOfDay@@3VCTimeOfDay@@A:BYTE		; TheTimeOfDay
EXTRN	?g_bNoRPMOnHud@@3_NA:BYTE			; g_bNoRPMOnHud
EXTRN	?g_bINS@@3_NA:BYTE				; g_bINS
EXTRN	?g_bNewPitchLadder@@3_NA:BYTE			; g_bNewPitchLadder
EXTRN	?g_fReconCameraHalfFOV@@3MA:DWORD		; g_fReconCameraHalfFOV
EXTRN	?g_fReconCameraOffset@@3MA:DWORD		; g_fReconCameraOffset
EXTRN	?g_bBrightHUD@@3_NA:BYTE			; g_bBrightHUD
EXTRN	?g_bHUDFix@@3_NA:BYTE				; g_bHUDFix
EXTRN	?g_bhudAOA@@3_NA:BYTE				; g_bhudAOA
EXTRN	?shootCue@@3_NA:BYTE				; shootCue
EXTRN	?IO@@3VSIMLIB_IO_CLASS@@A:BYTE			; IO
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0200000
CONST	SEGMENT
__real@c0200000 DD 0c0200000r			; -2.5
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf733333
CONST	SEGMENT
__real@bf733333 DD 0bf733333r			; -0.95
CONST	ENDS
;	COMDAT __real@bf6e147b
CONST	SEGMENT
__real@bf6e147b DD 0bf6e147br			; -0.93
CONST	ENDS
;	COMDAT __real@bf6b851f
CONST	SEGMENT
__real@bf6b851f DD 0bf6b851fr			; -0.92
CONST	ENDS
;	COMDAT __real@bf68f5c3
CONST	SEGMENT
__real@bf68f5c3 DD 0bf68f5c3r			; -0.91
CONST	ENDS
;	COMDAT __real@bf666666
CONST	SEGMENT
__real@bf666666 DD 0bf666666r			; -0.9
CONST	ENDS
;	COMDAT __real@bf6147ae
CONST	SEGMENT
__real@bf6147ae DD 0bf6147aer			; -0.88
CONST	ENDS
;	COMDAT __real@bf59999a
CONST	SEGMENT
__real@bf59999a DD 0bf59999ar			; -0.85
CONST	ENDS
;	COMDAT __real@bf553f7d
CONST	SEGMENT
__real@bf553f7d DD 0bf553f7dr			; -0.833
CONST	ENDS
;	COMDAT __real@bf51eb85
CONST	SEGMENT
__real@bf51eb85 DD 0bf51eb85r			; -0.82
CONST	ENDS
;	COMDAT __real@bf4ccccd
CONST	SEGMENT
__real@bf4ccccd DD 0bf4ccccdr			; -0.8
CONST	ENDS
;	COMDAT __real@bf47ae14
CONST	SEGMENT
__real@bf47ae14 DD 0bf47ae14r			; -0.78
CONST	ENDS
;	COMDAT __real@bf428f5c
CONST	SEGMENT
__real@bf428f5c DD 0bf428f5cr			; -0.76
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@bf333333
CONST	SEGMENT
__real@bf333333 DD 0bf333333r			; -0.7
CONST	ENDS
;	COMDAT __real@bf2ac083
CONST	SEGMENT
__real@bf2ac083 DD 0bf2ac083r			; -0.667
CONST	ENDS
;	COMDAT __real@bf19999a
CONST	SEGMENT
__real@bf19999a DD 0bf19999ar			; -0.6
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@becccccd
CONST	SEGMENT
__real@becccccd DD 0becccccdr			; -0.4
CONST	ENDS
;	COMDAT __real@beaa7efa
CONST	SEGMENT
__real@beaa7efa DD 0beaa7efar			; -0.333
CONST	ENDS
;	COMDAT __real@be800000
CONST	SEGMENT
__real@be800000 DD 0be800000r			; -0.25
CONST	ENDS
;	COMDAT __real@be75c28f
CONST	SEGMENT
__real@be75c28f DD 0be75c28fr			; -0.24
CONST	ENDS
;	COMDAT __real@be2e147b
CONST	SEGMENT
__real@be2e147b DD 0be2e147br			; -0.17
CONST	ENDS
;	COMDAT __real@be29fbe7
CONST	SEGMENT
__real@be29fbe7 DD 0be29fbe7r			; -0.166
CONST	ENDS
;	COMDAT __real@be23d70a
CONST	SEGMENT
__real@be23d70a DD 0be23d70ar			; -0.16
CONST	ENDS
;	COMDAT __real@be19999a
CONST	SEGMENT
__real@be19999a DD 0be19999ar			; -0.15
CONST	ENDS
;	COMDAT __real@be0f5c29
CONST	SEGMENT
__real@be0f5c29 DD 0be0f5c29r			; -0.14
CONST	ENDS
;	COMDAT __real@be0efa34
CONST	SEGMENT
__real@be0efa34 DD 0be0efa34r			; -0.139626
CONST	ENDS
;	COMDAT __real@be051eb8
CONST	SEGMENT
__real@be051eb8 DD 0be051eb8r			; -0.13
CONST	ENDS
;	COMDAT __real@bdf5c28f
CONST	SEGMENT
__real@bdf5c28f DD 0bdf5c28fr			; -0.12
CONST	ENDS
;	COMDAT __real@bde147ae
CONST	SEGMENT
__real@bde147ae DD 0bde147aer			; -0.11
CONST	ENDS
;	COMDAT __real@bdd6774e
CONST	SEGMENT
__real@bdd6774e DD 0bdd6774er			; -0.10472
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@bdb851ec
CONST	SEGMENT
__real@bdb851ec DD 0bdb851ecr			; -0.09
CONST	ENDS
;	COMDAT __real@bd99999a
CONST	SEGMENT
__real@bd99999a DD 0bd99999ar			; -0.075
CONST	ENDS
;	COMDAT __real@bd4ccccd
CONST	SEGMENT
__real@bd4ccccd DD 0bd4ccccdr			; -0.05
CONST	ENDS
;	COMDAT __real@bcf5c28f
CONST	SEGMENT
__real@bcf5c28f DD 0bcf5c28fr			; -0.03
CONST	ENDS
;	COMDAT __real@bc75c28f
CONST	SEGMENT
__real@bc75c28f DD 0bc75c28fr			; -0.015
CONST	ENDS
;	COMDAT __real@bc23d70a
CONST	SEGMENT
__real@bc23d70a DD 0bc23d70ar			; -0.01
CONST	ENDS
;	COMDAT __real@bbf5c28f
CONST	SEGMENT
__real@bbf5c28f DD 0bbf5c28fr			; -0.0075
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@469c4000
CONST	SEGMENT
__real@469c4000 DD 0469c4000r			; 20000
CONST	ENDS
;	COMDAT __real@454cffae
CONST	SEGMENT
__real@454cffae DD 0454cffaer			; 3279.98
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@43610000
CONST	SEGMENT
__real@43610000 DD 043610000r			; 225
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@4104cccd
CONST	SEGMENT
__real@4104cccd DD 04104cccdr			; 8.3
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4019999a
CONST	SEGMENT
__real@4019999a DD 04019999ar			; 2.4
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f860a91
CONST	SEGMENT
__real@3f860a91 DD 03f860a91r			; 1.0472
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f6147ae
CONST	SEGMENT
__real@3f6147ae DD 03f6147aer			; 0.88
CONST	ENDS
;	COMDAT __real@3f553f7d
CONST	SEGMENT
__real@3f553f7d DD 03f553f7dr			; 0.833
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f47ae14
CONST	SEGMENT
__real@3f47ae14 DD 03f47ae14r			; 0.78
CONST	ENDS
;	COMDAT __real@3f428f5c
CONST	SEGMENT
__real@3f428f5c DD 03f428f5cr			; 0.76
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f3d70a4
CONST	SEGMENT
__real@3f3d70a4 DD 03f3d70a4r			; 0.74
CONST	ENDS
;	COMDAT __real@3f3851ec
CONST	SEGMENT
__real@3f3851ec DD 03f3851ecr			; 0.72
CONST	ENDS
;	COMDAT __real@3f2ac083
CONST	SEGMENT
__real@3f2ac083 DD 03f2ac083r			; 0.667
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f178d50
CONST	SEGMENT
__real@3f178d50 DD 03f178d50r			; 0.592
CONST	ENDS
;	COMDAT __real@3f11eb85
CONST	SEGMENT
__real@3f11eb85 DD 03f11eb85r			; 0.57
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f060a91
CONST	SEGMENT
__real@3f060a91 DD 03f060a91r			; 0.523599
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3edd1044
CONST	SEGMENT
__real@3edd1044 DD 03edd1044r			; 0.431765
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3eaa7efa
CONST	SEGMENT
__real@3eaa7efa DD 03eaa7efar			; 0.333
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e978d50
CONST	SEGMENT
__real@3e978d50 DD 03e978d50r			; 0.296
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@3e29fbe7
CONST	SEGMENT
__real@3e29fbe7 DD 03e29fbe7r			; 0.166
CONST	ENDS
;	COMDAT __real@3e23d70a
CONST	SEGMENT
__real@3e23d70a DD 03e23d70ar			; 0.16
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e0f5c29
CONST	SEGMENT
__real@3e0f5c29 DD 03e0f5c29r			; 0.14
CONST	ENDS
;	COMDAT __real@3e01a36e
CONST	SEGMENT
__real@3e01a36e DD 03e01a36er			; 0.1266
CONST	ENDS
;	COMDAT __real@3df5c28f
CONST	SEGMENT
__real@3df5c28f DD 03df5c28fr			; 0.12
CONST	ENDS
;	COMDAT __real@3dda511a
CONST	SEGMENT
__real@3dda511a DD 03dda511ar			; 0.1066
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db851ec
CONST	SEGMENT
__real@3db851ec DD 03db851ecr			; 0.09
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3d99999a
CONST	SEGMENT
__real@3d99999a DD 03d99999ar			; 0.075
CONST	ENDS
;	COMDAT __real@3d961e4f
CONST	SEGMENT
__real@3d961e4f DD 03d961e4fr			; 0.0733
CONST	ENDS
;	COMDAT __real@3d8f5c29
CONST	SEGMENT
__real@3d8f5c29 DD 03d8f5c29r			; 0.07
CONST	ENDS
;	COMDAT __real@3d5a511a
CONST	SEGMENT
__real@3d5a511a DD 03d5a511ar			; 0.0533
CONST	ENDS
;	COMDAT __real@3d56774e
CONST	SEGMENT
__real@3d56774e DD 03d56774er			; 0.0523599
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3cf5c28f
CONST	SEGMENT
__real@3cf5c28f DD 03cf5c28fr			; 0.03
CONST	ENDS
;	COMDAT __real@3ccccccd
CONST	SEGMENT
__real@3ccccccd DD 03ccccccdr			; 0.025
CONST	ENDS
;	COMDAT __real@3cc82b15
CONST	SEGMENT
__real@3cc82b15 DD 03cc82b15r			; 0.0244346
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c75c28f
CONST	SEGMENT
__real@3c75c28f DD 03c75c28fr			; 0.015
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3bf5c28f
CONST	SEGMENT
__real@3bf5c28f DD 03bf5c28fr			; 0.0075
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R4Render2D@@6B@
rdata$r	SEGMENT
??_R4Render2D@@6B@ DD 00H				; Render2D::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRender2D@@@8
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R2Render2D@@8
rdata$r	SEGMENT
??_R2Render2D@@8 DD FLAT:??_R1A@?0A@EA@Render2D@@8	; Render2D::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R3Render2D@@8
rdata$r	SEGMENT
??_R3Render2D@@8 DD 00H					; Render2D::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRender2D@@@8
_DATA	SEGMENT
??_R0?AVRender2D@@@8 DD FLAT:??_7type_info@@6B@		; Render2D `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRender2D@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Render2D@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Render2D@@8 DD FLAT:??_R0?AVRender2D@@@8	; Render2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Render2D@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@HudClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HudClass@@8 DD FLAT:??_R0?AVHudClass@@@8	; HudClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HudClass@@8
rdata$r	ENDS
;	COMDAT ??_R2HudClass@@8
rdata$r	SEGMENT
??_R2HudClass@@8 DD FLAT:??_R1A@?0A@EA@HudClass@@8	; HudClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R3HudClass@@8
rdata$r	SEGMENT
??_R3HudClass@@8 DD 00H					; HudClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2HudClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHudClass@@@8
_DATA	SEGMENT
??_R0?AVHudClass@@@8 DD FLAT:??_7type_info@@6B@		; HudClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHudClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HudClass@@6B@
rdata$r	SEGMENT
??_R4HudClass@@6B@ DD 00H				; HudClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHudClass@@@8
	DD	FLAT:??_R3HudClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DrawableClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DrawableClass@@8 DD FLAT:??_R0?AVDrawableClass@@@8 ; DrawableClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R2DrawableClass@@8
rdata$r	SEGMENT
??_R2DrawableClass@@8 DD FLAT:??_R1A@?0A@EA@DrawableClass@@8 ; DrawableClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DrawableClass@@8
rdata$r	SEGMENT
??_R3DrawableClass@@8 DD 00H				; DrawableClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawableClass@@@8
_DATA	SEGMENT
??_R0?AVDrawableClass@@@8 DD FLAT:??_7type_info@@6B@	; DrawableClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawableClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DrawableClass@@6B@
rdata$r	SEGMENT
??_R4DrawableClass@@6B@ DD 00H				; DrawableClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDrawableClass@@@8
	DD	FLAT:??_R3DrawableClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@VirtualDisplay@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VirtualDisplay@@8 DD FLAT:??_R0?AVVirtualDisplay@@@8 ; VirtualDisplay::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R2VirtualDisplay@@8
rdata$r	SEGMENT
??_R2VirtualDisplay@@8 DD FLAT:??_R1A@?0A@EA@VirtualDisplay@@8 ; VirtualDisplay::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VirtualDisplay@@8
rdata$r	SEGMENT
??_R3VirtualDisplay@@8 DD 00H				; VirtualDisplay::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVirtualDisplay@@@8
_DATA	SEGMENT
??_R0?AVVirtualDisplay@@@8 DD FLAT:??_7type_info@@6B@	; VirtualDisplay `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVirtualDisplay@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VirtualDisplay@@6B@
rdata$r	SEGMENT
??_R4VirtualDisplay@@6B@ DD 00H				; VirtualDisplay::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVirtualDisplay@@@8
	DD	FLAT:??_R3VirtualDisplay@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04GLGLOEHP@T?5?$CFd?$AA@
CONST	SEGMENT
??_C@_04GLGLOEHP@T?5?$CFd?$AA@ DB 'T %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGMCLHNC@RDC?5SPEED?$AA@
CONST	SEGMENT
??_C@_09LGMCLHNC@RDC?5SPEED?$AA@ DB 'RDC SPEED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLFBFFLP@G?5?$CF?41f?$AA@
CONST	SEGMENT
??_C@_06LLFBFFLP@G?5?$CF?41f?$AA@ DB 'G %.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNGHLEKI@M?5?$CF?42f?$AA@
CONST	SEGMENT
??_C@_06BNGHLEKI@M?5?$CF?42f?$AA@ DB 'M %.2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LACKECLL@GO?5STT?$AA@
CONST	SEGMENT
??_C@_06LACKECLL@GO?5STT?$AA@ DB 'GO STT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNCBBDMH@NO?5RAD?$AA@
CONST	SEGMENT
??_C@_06MNCBBDMH@NO?5RAD?$AA@ DB 'NO RAD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHNNFJCK@?$CF?40f?$AA@
CONST	SEGMENT
??_C@_04GHNNFJCK@?$CF?40f?$AA@ DB '%.0f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BJJAFLBC@SLOW?$AA@
CONST	SEGMENT
??_C@_04BJJAFLBC@SLOW?$AA@ DB 'SLOW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOPLBCBC@OBSTACLE?$AA@
CONST	SEGMENT
??_C@_08OOPLBCBC@OBSTACLE?$AA@ DB 'OBSTACLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HICPBJFO@FLY?5UP?$AA@
CONST	SEGMENT
??_C@_06HICPBJFO@FLY?5UP?$AA@ DB 'FLY UP', 00H		; `string'
CONST	ENDS
;	COMDAT ?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA
_DATA	SEGMENT
?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA DD 0bf147ae1r ; -0.58 ; `HudClass::DrawAlphaNumeric'::`148'::xPos
_DATA	ENDS
;	COMDAT ??_C@_09IMNIJPFK@FUEL?5?$CF03d?$AA@
CONST	SEGMENT
??_C@_09IMNIJPFK@FUEL?5?$CF03d?$AA@ DB 'FUEL %03d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMPPOEK@TRP?5FUEL?$AA@
CONST	SEGMENT
??_C@_08EMPPOEK@TRP?5FUEL?$AA@ DB 'TRP FUEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DICABFLJ@FUEL?$AA@
CONST	SEGMENT
??_C@_04DICABFLJ@FUEL?$AA@ DB 'FUEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBIELMDE@WARN?$AA@
CONST	SEGMENT
??_C@_04JBIELMDE@WARN?$AA@ DB 'WARN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKKPAKDO@BORE?$AA@
CONST	SEGMENT
??_C@_04DKKPAKDO@BORE?$AA@ DB 'BORE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NOAAMIEF@VIS?$AA@
CONST	SEGMENT
??_C@_03NOAAMIEF@VIS?$AA@ DB 'VIS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHIAGONP@PRE?$AA@
CONST	SEGMENT
??_C@_03PHIAGONP@PRE?$AA@ DB 'PRE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPEIBKFE@?$CFd?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05OPEIBKFE@?$CFd?5?$CFs?$AA@ DB '%d %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DCDGPODJ@JETT?$AA@
CONST	SEGMENT
??_C@_04DCDGPODJ@JETT?$AA@ DB 'JETT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKAJNMKE@ALIGN?$AA@
CONST	SEGMENT
??_C@_05OKAJNMKE@ALIGN?$AA@ DB 'ALIGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGBPDDBN@?$CF?41f?$AA@
CONST	SEGMENT
??_C@_04GGBPDDBN@?$CF?41f?$AA@ DB '%.1f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEFJINEE@?$CF?42f?$AA@
CONST	SEGMENT
??_C@_04GEFJINEE@?$CF?42f?$AA@ DB '%.2f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNJPAHKI@SIM?$AA@
CONST	SEGMENT
??_C@_03DNJPAHKI@SIM?$AA@ DB 'SIM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NHPMNECN@ARM?$AA@
CONST	SEGMENT
??_C@_03NHPMNECN@ARM?$AA@ DB 'ARM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NAHIIPNL@SAF?$AA@
CONST	SEGMENT
??_C@_03NAHIIPNL@SAF?$AA@ DB 'SAF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NALBENGH@ILS?$AA@
CONST	SEGMENT
??_C@_03NALBENGH@ILS?$AA@ DB 'ILS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGGOEBHK@?$CF02?41f?$AA@
CONST	SEGMENT
??_C@_06HGGOEBHK@?$CF02?41f?$AA@ DB '%02.1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMFMKBEK@RPM?5?$CF3d?$AA@
CONST	SEGMENT
??_C@_07GMFMKBEK@RPM?5?$CF3d?$AA@ DB 'RPM %3d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FNHOLOBO@SOI?$AA@
CONST	SEGMENT
??_C@_03FNHOLOBO@SOI?$AA@ DB 'SOI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7Render2D@@6B@
CONST	SEGMENT
??_7Render2D@@6B@ DD FLAT:??_R4Render2D@@6B@		; Render2D::`vftable'
	DD	FLAT:??_ERender2D@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@Render2D@@UAEXXZ
	DD	FLAT:?StartDraw@Render2D@@UAEXXZ
	DD	FLAT:?ClearDraw@Render2D@@UAEXXZ
	DD	FLAT:?EndDraw@Render2D@@UAEXXZ
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:?SetColor@Render2D@@UAEXK@Z
	DD	FLAT:?SetBackground@Render2D@@UAEXK@Z
	DD	FLAT:?ScreenText@Render2D@@UAEXMMPBDH@Z
	DD	FLAT:?SetLineStyle@Render2D@@UAEXH@Z
	DD	FLAT:?Color@Render2D@@UAEKXZ
	DD	FLAT:?SetViewport@Render2D@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Render2DPoint@Render2D@@UAEXMM@Z
	DD	FLAT:?Render2DLine@Render2D@@UAEXMMMM@Z
	DD	FLAT:?Render2DTri@Render2D@@UAEXMMMMMM@Z
	DD	FLAT:?Setup@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?SetImageBuffer@Render2D@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?ClearZBuffer@Render2D@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7VirtualDisplay@@6B@
CONST	SEGMENT
??_7VirtualDisplay@@6B@ DD FLAT:??_R4VirtualDisplay@@6B@ ; VirtualDisplay::`vftable'
	DD	FLAT:??_EVirtualDisplay@@UAEPAXI@Z
	DD	FLAT:?Setup@VirtualDisplay@@UAEXXZ
	DD	FLAT:?Cleanup@VirtualDisplay@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Point@VirtualDisplay@@UAEXMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?Line@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?Tri@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Oval@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?OvalArc@VirtualDisplay@@UAEXMMMMMM@Z
	DD	FLAT:?Circle@VirtualDisplay@@UAEXMMM@Z
	DD	FLAT:?Arc@VirtualDisplay@@UAEXMMMMM@Z
	DD	FLAT:?TextLeft@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRight@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextLeftVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextRightVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenter@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextCenterVertical@VirtualDisplay@@UAEXMMPBDH@Z
	DD	FLAT:?TextWrap@VirtualDisplay@@UAEHMMPBDMM@Z
	DD	FLAT:?TextWidth@VirtualDisplay@@UAEMPAD@Z
	DD	FLAT:?TextHeight@VirtualDisplay@@UAEMXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?SetLineStyle@VirtualDisplay@@UAEXH@Z
	DD	FLAT:?Color@VirtualDisplay@@UAEKXZ
	DD	FLAT:?SetViewport@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:?SetViewportRelative@VirtualDisplay@@UAEXMMMM@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Render2DTri@VirtualDisplay@@MAEXMMMMMM@Z
CONST	ENDS
;	COMDAT ??_7HudClass@@6B@
CONST	SEGMENT
??_7HudClass@@6B@ DD FLAT:??_R4HudClass@@6B@		; HudClass::`vftable'
	DD	FLAT:??_EHudClass@@UAEPAXI@Z
	DD	FLAT:?Display@HudClass@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@HudClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@HudClass@@UAEXHH@Z
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7DrawableClass@@6B@
CONST	SEGMENT
??_7DrawableClass@@6B@ DD FLAT:??_R4DrawableClass@@6B@	; DrawableClass::`vftable'
	DD	FLAT:??_EDrawableClass@@UAEPAXI@Z
	DD	FLAT:?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z
	DD	FLAT:?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z
	DD	FLAT:?DisplayExit@DrawableClass@@UAEXXZ
	DD	FLAT:?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
	DD	FLAT:?PushButton@DrawableClass@@UAEXHH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z$0
__unwindtable$??1HudClass@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HudClass@@UAE@XZ$0
__unwindtable$??0HudClass@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HudClass@@QAE@XZ$0
__ehfuncinfo$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1HudClass@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1HudClass@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0HudClass@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HudClass@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simio.h
;	COMDAT ?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z PROC ; SIMLIB_IO_CLASS::AnalogIsUsed, COMDAT
; _this$ = ecx

; 237  : 	bool	AnalogIsUsed(GameAxis_t id) { return ( analog[id].isUsed); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _id$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+eax+12]
	mov	esp, ebp
	pop	ebp
	ret	4
?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ENDP ; SIMLIB_IO_CLASS::AnalogIsUsed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\tod.h
;	COMDAT ?GetAmbientValue@CTimeOfDay@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAmbientValue@CTimeOfDay@@QAEMXZ PROC		; CTimeOfDay::GetAmbientValue, COMDAT
; _this$ = ecx

; 105  : 	float GetAmbientValue()						{ return Ambient; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+220]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAmbientValue@CTimeOfDay@@QAEMXZ ENDP		; CTimeOfDay::GetAmbientValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\radardoppler.h
;	COMDAT ?IsSet@RadarDopplerClass@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_newFlag$ = 8						; size = 4
?IsSet@RadarDopplerClass@@QAEHH@Z PROC			; RadarDopplerClass::IsSet, COMDAT
; _this$ = ecx

; 236  :    int  IsSet (int newFlag) {return (newFlag & flags) ? TRUE : FALSE;}; //MI moved to public

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newFlag$[ebp]
	and	ecx, DWORD PTR [eax+492]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@RadarDopplerClass@@QAEHH@Z ENDP			; RadarDopplerClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\missile.h
;	COMDAT ?GetSeekerType@MissileClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSeekerType@MissileClass@@QAEHXZ PROC		; MissileClass::GetSeekerType, COMDAT
; _this$ = ecx

; 264  : 	int GetSeekerType (void) { return inputData->seekerType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+848]
	mov	eax, DWORD PTR [ecx+88]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeekerType@MissileClass@@QAEHXZ ENDP		; MissileClass::GetSeekerType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\lantirn.h
;	COMDAT ?IsEnabled@LantirnClass@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsEnabled@LantirnClass@@QAE_NXZ PROC			; LantirnClass::IsEnabled, COMDAT
; _this$ = ecx

; 17   :     bool IsEnabled() { return (m_flags & AVAILABLE) ? TRUE : FALSE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	and	ecx, 2
	je	SHORT $LN3@IsEnabled
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsEnabled
$LN3@IsEnabled:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsEnabled:
	mov	al, BYTE PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEnabled@LantirnClass@@QAE_NXZ ENDP			; LantirnClass::IsEnabled
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\smsdraw.h
;	COMDAT ?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ PROC ; SmsDrawable::DisplayMode, COMDAT
; _this$ = ecx

; 26   : 	SmsDisplayMode DisplayMode(void) {return displayMode;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]
	mov	esp, ebp
	pop	ebp
	ret	0
?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ENDP ; SmsDrawable::DisplayMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\icp.h
;	COMDAT ?GetCMDSTR@ICPClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCMDSTR@ICPClass@@QAEHXZ PROC			; ICPClass::GetCMDSTR, COMDAT
; _this$ = ecx

; 243  : 	BOOL GetCMDSTR(void)	{return CMDSTRG;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+1501]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCMDSTR@ICPClass@@QAEHXZ ENDP			; ICPClass::GetCMDSTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?WarnReset@FackClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?WarnReset@FackClass@@QAEHXZ PROC			; FackClass::WarnReset, COMDAT
; _this$ = ecx

; 41   :     int		WarnReset(void)	{return NeedsWarnReset;};	//MI

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?WarnReset@FackClass@@QAEHXZ ENDP			; FackClass::WarnReset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fack.h
;	COMDAT ?MasterCaution@FackClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterCaution@FackClass@@QAEHXZ PROC			; FackClass::MasterCaution, COMDAT
; _this$ = ecx

; 35   :     int		MasterCaution(void) {return mMasterCaution;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterCaution@FackClass@@QAEHXZ ENDP			; FackClass::MasterCaution
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GRender2D@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRender2D@@UAEPAXI@Z PROC				; Render2D::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Render2D@@UAE@XZ			; Render2D::~Render2D
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRender2D@@UAEPAXI@Z ENDP				; Render2D::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetLineStyle@Render2D@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@Render2D@@UAEXH@Z PROC			; Render2D::SetLineStyle, COMDAT
; _this$ = ecx

; 60   : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@Render2D@@UAEXH@Z ENDP			; Render2D::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetBackground@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetBackground@Render2D@@UAEXK@Z PROC			; Render2D::SetBackground, COMDAT
; _this$ = ecx

; 50   : 	virtual void SetBackground(DWORD packedRGBA){ context.SetState(MPR_STA_BG_COLOR,packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SetState@ContextMPR@@QAEXGK@Z		; ContextMPR::SetState
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBackground@Render2D@@UAEXK@Z ENDP			; Render2D::SetBackground
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?SetColor@Render2D@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_packedRGBA$ = 8					; size = 4
?SetColor@Render2D@@UAEXK@Z PROC			; Render2D::SetColor, COMDAT
; _this$ = ecx

; 49   : 	virtual void SetColor(DWORD packedRGBA)	{ context.RestoreState(STATE_SOLID); context.SelectForegroundColor(packedRGBA); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?RestoreState@ContextMPR@@QAEXH@Z	; ContextMPR::RestoreState
	mov	eax, DWORD PTR _packedRGBA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?SelectForegroundColor@ContextMPR@@QAEXH@Z ; ContextMPR::SelectForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	4
?SetColor@Render2D@@UAEXK@Z ENDP			; Render2D::SetColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?Color@Render2D@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@Render2D@@UAEKXZ PROC				; Render2D::Color, COMDAT
; _this$ = ecx

; 48   : 	virtual DWORD Color(void) { return context.CurrentForegroundColor(); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?CurrentForegroundColor@ContextMPR@@QAEHXZ ; ContextMPR::CurrentForegroundColor
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@Render2D@@UAEKXZ ENDP				; Render2D::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearZBuffer@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearZBuffer@Render2D@@UAEXXZ PROC			; Render2D::ClearZBuffer, COMDAT
; _this$ = ecx

; 42   : 	virtual void ClearZBuffer( void )	{ context.ClearBuffers( MPR_CI_ZBUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearZBuffer@Render2D@@UAEXXZ ENDP			; Render2D::ClearZBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ?ClearDraw@Render2D@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearDraw@Render2D@@UAEXXZ PROC			; Render2D::ClearDraw, COMDAT
; _this$ = ecx

; 41   : 	virtual void ClearDraw( void )		{ context.ClearBuffers( MPR_CI_DRAW_BUFFER ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?ClearBuffers@ContextMPR@@QAEXG@Z	; ContextMPR::ClearBuffers
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDraw@Render2D@@UAEXXZ ENDP			; Render2D::ClearDraw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??1Render2D@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Render2D@@UAE@XZ PROC				; Render2D::~Render2D, COMDAT
; _this$ = ecx

; 32   : 	virtual ~Render2D()	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	esp, ebp
	pop	ebp
	ret	0
??1Render2D@@UAE@XZ ENDP				; Render2D::~Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\render2d.h
;	COMDAT ??0Render2D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Render2D@@QAE@XZ PROC				; Render2D::Render2D, COMDAT
; _this$ = ecx

; 31   : 	Render2D()			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VirtualDisplay@@QAE@XZ		; VirtualDisplay::VirtualDisplay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Render2D@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Render2D@@QAE@XZ ENDP				; Render2D::Render2D
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GVirtualDisplay@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVirtualDisplay@@UAEPAXI@Z PROC			; VirtualDisplay::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VirtualDisplay@@UAE@XZ		; VirtualDisplay::~VirtualDisplay
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVirtualDisplay@@UAEPAXI@Z ENDP			; VirtualDisplay::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::ZeroRotationAboutOrigin, COMDAT
; _this$ = ecx

; 144  :     void ZeroRotationAboutOrigin( void ) { dmatrix.rotation01 = dmatrix.rotation10 = 0.0f, dmatrix.rotation00 = dmatrix.rotation11 = 1.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+84], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+80], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+88], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+76], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::ZeroRotationAboutOrigin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CenterOriginInViewport@VirtualDisplay@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ PROC	; VirtualDisplay::CenterOriginInViewport, COMDAT
; _this$ = ecx

; 143  : 	void CenterOriginInViewport( void )  { dmatrix.translationX = 0.0f; dmatrix.translationY = 0.0f; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+68], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+72], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ENDP	; VirtualDisplay::CenterOriginInViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Color@VirtualDisplay@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Color@VirtualDisplay@@UAEKXZ PROC			; VirtualDisplay::Color, COMDAT
; _this$ = ecx

; 136  : 	virtual DWORD Color( void )	{return 0x0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Color@VirtualDisplay@@UAEKXZ ENDP			; VirtualDisplay::Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?SetLineStyle@VirtualDisplay@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetLineStyle@VirtualDisplay@@UAEXH@Z PROC		; VirtualDisplay::SetLineStyle, COMDAT
; _this$ = ecx

; 135  : 	virtual void SetLineStyle (int) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLineStyle@VirtualDisplay@@UAEXH@Z ENDP		; VirtualDisplay::SetLineStyle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?CurFont@VirtualDisplay@@SAHXZ
_TEXT	SEGMENT
?CurFont@VirtualDisplay@@SAHXZ PROC			; VirtualDisplay::CurFont, COMDAT

; 132  : 	static int CurFont(void) { return pFontSet->fontNum; };

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?pFontSet@VirtualDisplay@@2PAUFontSet@@A ; VirtualDisplay::pFontSet
	mov	eax, DWORD PTR [eax+24672]
	pop	ebp
	ret	0
?CurFont@VirtualDisplay@@SAHXZ ENDP			; VirtualDisplay::CurFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextHeight@VirtualDisplay@@UAEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?TextHeight@VirtualDisplay@@UAEMXZ PROC			; VirtualDisplay::TextHeight, COMDAT
; _this$ = ecx

; 121  : 	virtual float TextHeight(void)			{ return ScreenTextHeight()/scaleY; };		// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	call	?ScreenTextHeight@VirtualDisplay@@SAHXZ	; VirtualDisplay::ScreenTextHeight
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR tv71[ebp], xmm0
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TextHeight@VirtualDisplay@@UAEMXZ ENDP			; VirtualDisplay::TextHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?TextWidth@VirtualDisplay@@UAEMPAD@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_string$ = 8						; size = 4
?TextWidth@VirtualDisplay@@UAEMPAD@Z PROC		; VirtualDisplay::TextWidth, COMDAT
; _this$ = ecx

; 120  : 	virtual float TextWidth(char *string)	{ return ScreenTextWidth(string)/scaleX; };	// normalized screen space

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	?ScreenTextWidth@VirtualDisplay@@SAHPBD@Z ; VirtualDisplay::ScreenTextWidth
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR tv73[ebp], xmm0
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?TextWidth@VirtualDisplay@@UAEMPAD@Z ENDP		; VirtualDisplay::TextWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Arc@VirtualDisplay@@UAEXMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
_start$ = 20						; size = 4
_stop$ = 24						; size = 4
?Arc@VirtualDisplay@@UAEXMMMMM@Z PROC			; VirtualDisplay::Arc, COMDAT
; _this$ = ecx

; 109  : 		{ OvalArc(x, y, xRadius, xRadius*scaleX/scaleY, start, stop); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _stop$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Arc@VirtualDisplay@@UAEXMMMMM@Z ENDP			; VirtualDisplay::Arc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ?Circle@VirtualDisplay@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xRadius$ = 16						; size = 4
?Circle@VirtualDisplay@@UAEXMMM@Z PROC			; VirtualDisplay::Circle, COMDAT
; _this$ = ecx

; 107  : 		{ Oval(x, y, xRadius, xRadius*scaleX/scaleY); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	divss	xmm0, DWORD PTR [ecx+36]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Circle@VirtualDisplay@@UAEXMMM@Z ENDP			; VirtualDisplay::Circle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??1VirtualDisplay@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1VirtualDisplay@@UAE@XZ PROC				; VirtualDisplay::~VirtualDisplay, COMDAT
; _this$ = ecx

; 86   :     virtual ~VirtualDisplay()	{ ShiAssert( ready == FALSE ); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??1ContextMPR@@UAE@XZ			; ContextMPR::~ContextMPR
	mov	esp, ebp
	pop	ebp
	ret	0
??1VirtualDisplay@@UAE@XZ ENDP				; VirtualDisplay::~VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\display.h
;	COMDAT ??0VirtualDisplay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VirtualDisplay@@QAE@XZ PROC				; VirtualDisplay::VirtualDisplay, COMDAT
; _this$ = ecx

; 85   :     VirtualDisplay()			{ ready = FALSE; tLeft = tTop = tRight = tBottom = txRes = tyRes = 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VirtualDisplay@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0ContextMPR@@QAE@XZ			; ContextMPR::ContextMPR
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262776], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262772], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262768], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+262764], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+262760], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+262756], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VirtualDisplay@@QAE@XZ ENDP				; VirtualDisplay::VirtualDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\playerop.h
;	COMDAT ?GetAvionicsType@PlayerOptionsClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ PROC	; PlayerOptionsClass::GetAvionicsType, COMDAT
; _this$ = ecx

; 142  : 	int GetAvionicsType (void)								{ return SimAvionicsType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ENDP	; PlayerOptionsClass::GetAvionicsType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetBingoSnd@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBingoSnd@AirframeClass@@QAEHXZ PROC			; AirframeClass::GetBingoSnd, COMDAT
; _this$ = ecx

; 1230 : 	int GetBingoSnd() { return auxaeroData->sndBBBingo; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+2388]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBingoSnd@AirframeClass@@QAEHXZ ENDP			; AirframeClass::GetBingoSnd
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?GetTypeAC@AirframeClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTypeAC@AirframeClass@@QAEHXZ PROC			; AirframeClass::GetTypeAC, COMDAT
; _this$ = ecx

; 809  : 	int GetTypeAC() {return auxaeroData->typeAC;};//TJL 02/28/04

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+3880]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTypeAC@AirframeClass@@QAEHXZ ENDP			; AirframeClass::GetTypeAC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?IsF16@AircraftClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsF16@AircraftClass@@QAEHXZ PROC			; AircraftClass::IsF16, COMDAT
; _this$ = ecx

; 335  : 	int            IsF16 (void) {return (acFlags & isF16 ? TRUE : FALSE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 1
	je	SHORT $LN3@IsF16
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsF16
$LN3@IsF16:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsF16:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsF16@AircraftClass@@QAEHXZ ENDP			; AircraftClass::IsF16
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_fl$ = 8						; size = 4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z PROC	; AircraftClass::INSState, COMDAT
; _this$ = ecx

; 211  : 	int INSState(INSAlignFlags fl) { return (INSFlags & fl) == (unsigned int)fl ? 1 : 0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	and	ecx, DWORD PTR _fl$[ebp]
	cmp	ecx, DWORD PTR _fl$[ebp]
	jne	SHORT $LN3@INSState
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@INSState
$LN3@INSState:
	mov	DWORD PTR tv67[ebp], 0
$LN4@INSState:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ENDP	; AircraftClass::INSState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ PROC ; SMSBaseClass::MasterArm, COMDAT
; _this$ = ecx

; 92   : 	MasterArmState MasterArm(void) {return masterArm;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ENDP ; SMSBaseClass::MasterArm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\sms.h
;	COMDAT ?NumCurrentWpn@SMSBaseClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumCurrentWpn@SMSBaseClass@@QAEHXZ PROC		; SMSBaseClass::NumCurrentWpn, COMDAT
; _this$ = ecx

; 89   : 	int  NumCurrentWpn(void) {return numCurrentWpn;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?NumCurrentWpn@SMSBaseClass@@QAEHXZ ENDP		; SMSBaseClass::NumCurrentWpn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ PROC ; FireControlComputer::GetSubMode, COMDAT
; _this$ = ecx

; 281  : 	FCCSubMode GetSubMode (void) {return (subMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ENDP ; FireControlComputer::GetSubMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?IsAGMasterMode@FireControlComputer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsAGMasterMode@FireControlComputer@@QAEHXZ PROC	; FireControlComputer::IsAGMasterMode, COMDAT
; _this$ = ecx

; 278  : 	int IsAGMasterMode() { return GetMainMasterMode() == MM_AG; };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMainMasterMode@FireControlComputer@@QAE?AW4MASTERMODES@@XZ ; FireControlComputer::GetMainMasterMode
	test	eax, eax
	jne	SHORT $LN3@IsAGMaster
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsAGMaster
$LN3@IsAGMaster:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsAGMaster:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAGMasterMode@FireControlComputer@@QAEHXZ ENDP	; FireControlComputer::IsAGMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\fcc.h
;	COMDAT ?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ PROC ; FireControlComputer::GetMasterMode, COMDAT
; _this$ = ecx

; 276  : 	FCCMasterMode GetMasterMode (void) {return (masterMode);};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ENDP ; FireControlComputer::GetMasterMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ PROC ; VuBin<SimWeaponClass>::operator->, COMDAT
; _this$ = ecx

; 50   : 	E *operator->() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ENDP ; VuBin<SimWeaponClass>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ PROC		; VuBin<SimWeaponClass>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ ENDP		; VuBin<SimWeaponClass>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?IsSetFlag@SimBaseClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFlag@SimBaseClass@@QBEHH@Z PROC			; SimBaseClass::IsSetFlag, COMDAT
; _this$ = ecx

; 178  : 	int  IsSetFlag(int flag) const { return ((specialData.flags & flag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetFlag
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetFlag
$LN3@IsSetFlag:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetFlag:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFlag@SimBaseClass@@QBEHH@Z ENDP			; SimBaseClass::IsSetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\dxengine\dxengine.h
;	COMDAT ?GetState@CDXEngine@@QAE?AW4DX_StateType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetState@CDXEngine@@QAE?AW4DX_StateType@@XZ PROC	; CDXEngine::GetState, COMDAT
; _this$ = ecx

; 147  : 	DX_StateType	GetState(void)					{ return m_RenderState; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?m_RenderState@CDXEngine@@0W4DX_StateType@@A ; CDXEngine::m_RenderState
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CDXEngine@@QAE?AW4DX_StateType@@XZ ENDP	; CDXEngine::GetState
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GHudClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHudClass@@UAEPAXI@Z PROC				; HudClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HudClass@@UAE@XZ			; HudClass::~HudClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHudClass@@UAEPAXI@Z ENDP				; HudClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv76 = -12						; size = 4
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?CycleBrightnessSwitchDown@HudClass@@QAEXXZ PROC	; HudClass::CycleBrightnessSwitchDown
; _this$ = ecx

; 945  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 946  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 947  : 	if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP)) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN7@CycleBrigh
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN7@CycleBrigh

; 948  : 		switch(brightnessSwitch) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4884]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 1
	je	SHORT $LN3@CycleBrigh
	cmp	DWORD PTR tv76[ebp], 2
	je	SHORT $LN2@CycleBrigh
	jmp	SHORT $LN4@CycleBrigh
$LN3@CycleBrigh:

; 949  : 		{
; 950  : 		case DAY:
; 951  : 			brightnessSwitch = BRIGHT_AUTO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4884], 2

; 952  : 		break;

	jmp	SHORT $LN4@CycleBrigh
$LN2@CycleBrigh:

; 953  : 		case BRIGHT_AUTO:
; 954  : 			brightnessSwitch = NIGHT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4884], 3
$LN4@CycleBrigh:

; 955  : 		break;
; 956  : 		//case NIGHT:  // MD -- 20040108: commented out since there's no such state
; 957  : 		//	brightnessSwitch = OFF;
; 958  : 		//	playerAC->PowerOff(AircraftClass::HUDPower);
; 959  : 		//break;
; 960  : 		default:
; 961  : 		break;		
; 962  : 		}
; 963  : 
; 964  : 		SetLightLevel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel
$LN7@CycleBrigh:

; 965  : 	}
; 966  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleBrightnessSwitchDown@HudClass@@QAEXXZ ENDP	; HudClass::CycleBrightnessSwitchDown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv76 = -12						; size = 4
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?CycleBrightnessSwitchUp@HudClass@@QAEXXZ PROC		; HudClass::CycleBrightnessSwitchUp
; _this$ = ecx

; 919  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 920  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 921  : 	if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP)) 

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN7@CycleBrigh
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN7@CycleBrigh

; 922  : 	{
; 923  : 		// MD -- 20040108: Comment out the power control since this switch doesn't do that!
; 924  : 		//if(!playerAC->HasPower(AircraftClass::HUDPower))
; 925  : 		//	playerAC->PowerOn(AircraftClass::HUDPower);
; 926  : 		switch(brightnessSwitch) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4884]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 2
	je	SHORT $LN2@CycleBrigh
	cmp	DWORD PTR tv76[ebp], 3
	je	SHORT $LN3@CycleBrigh
	jmp	SHORT $LN4@CycleBrigh
$LN3@CycleBrigh:

; 927  : 		{
; 928  : 		//case OFF:  // MD -- 20040108: commented out since there's no such state
; 929  : 		//	brightnessSwitch = NIGHT;
; 930  : 		//break;
; 931  : 		case NIGHT:
; 932  : 			brightnessSwitch = BRIGHT_AUTO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4884], 2

; 933  : 		break;

	jmp	SHORT $LN4@CycleBrigh
$LN2@CycleBrigh:

; 934  : 		case BRIGHT_AUTO:
; 935  : 			brightnessSwitch = DAY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4884], 1
$LN4@CycleBrigh:

; 936  : 		break;
; 937  : 		default:
; 938  : 		break;
; 939  : 		}
; 940  : 
; 941  : 		SetLightLevel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel
$LN7@CycleBrigh:

; 942  : 	}
; 943  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleBrightnessSwitchUp@HudClass@@QAEXXZ ENDP		; HudClass::CycleBrightnessSwitchUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?CycleBrightnessSwitch@HudClass@@QAEXXZ PROC		; HudClass::CycleBrightnessSwitch
; _this$ = ecx

; 896  : void HudClass::CycleBrightnessSwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 897  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 898  : 	if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP)) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN8@CycleBrigh
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN8@CycleBrigh

; 899  : 		switch(brightnessSwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4884]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 1
	je	SHORT $LN4@CycleBrigh
	cmp	DWORD PTR tv76[ebp], 2
	je	SHORT $LN3@CycleBrigh
	cmp	DWORD PTR tv76[ebp], 3
	je	SHORT $LN2@CycleBrigh
	jmp	SHORT $LN1@CycleBrigh
$LN4@CycleBrigh:

; 900  : 		case DAY:
; 901  : 			brightnessSwitch = NIGHT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4884], 3

; 902  : 		break;

	jmp	SHORT $LN5@CycleBrigh
$LN3@CycleBrigh:

; 903  : 		case BRIGHT_AUTO:
; 904  : 			brightnessSwitch = DAY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4884], 1

; 905  : 		break;

	jmp	SHORT $LN5@CycleBrigh
$LN2@CycleBrigh:

; 906  : 		case NIGHT:
; 907  : 			brightnessSwitch = BRIGHT_AUTO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4884], 2

; 908  : 		break;

	jmp	SHORT $LN5@CycleBrigh
$LN1@CycleBrigh:

; 909  : 		default:
; 910  : 			brightnessSwitch = DAY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4884], 1
$LN5@CycleBrigh:

; 911  : 		break;
; 912  : 		}
; 913  : 
; 914  : 		SetLightLevel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel
$LN8@CycleBrigh:

; 915  : 	}
; 916  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleBrightnessSwitch@HudClass@@QAEXXZ ENDP		; HudClass::CycleBrightnessSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z PROC ; HudClass::SetBrightnessSwitch
; _this$ = ecx

; 889  : void HudClass::SetBrightnessSwitch(BrightnessSwitch state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 890  : 
; 891  : 	brightnessSwitch = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4884], ecx

; 892  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBrightnessSwitch@HudClass@@QAEXW4BrightnessSwitch@1@@Z ENDP ; HudClass::SetBrightnessSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBrightnessSwitch@HudClass@@QAEHXZ PROC		; HudClass::GetBrightnessSwitch
; _this$ = ecx

; 884  : int HudClass::GetBrightnessSwitch(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 885  : 
; 886  : 	return brightnessSwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4884]

; 887  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBrightnessSwitch@HudClass@@QAEHXZ ENDP		; HudClass::GetBrightnessSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_playerAC$ = -12					; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?CycleRadarSwitch@HudClass@@QAEXXZ PROC			; HudClass::CycleRadarSwitch
; _this$ = ecx

; 863  : void HudClass::CycleRadarSwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 864  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 865  : 	if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP)) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN7@CycleRadar
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN7@CycleRadar

; 866  : 		switch(radarSwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4880]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN3@CycleRadar
	cmp	DWORD PTR tv76[ebp], 1
	je	SHORT $LN2@CycleRadar
	cmp	DWORD PTR tv76[ebp], 2
	je	SHORT $LN1@CycleRadar
	jmp	SHORT $LN7@CycleRadar
$LN3@CycleRadar:

; 867  : 		case ALT_RADAR:
; 868  : 			radarSwitch = BARO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4880], 1

; 869  : 		break;

	jmp	SHORT $LN7@CycleRadar
$LN2@CycleRadar:

; 870  : 		case BARO:
; 871  : 			radarSwitch = RADAR_AUTO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4880], 2

; 872  : 		break;

	jmp	SHORT $LN7@CycleRadar
$LN1@CycleRadar:

; 873  : 		case RADAR_AUTO:
; 874  : 			radarSwitch = ALT_RADAR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4880], 0
$LN7@CycleRadar:

; 875  : 		break;
; 876  : 		}
; 877  : 	}
; 878  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleRadarSwitch@HudClass@@QAEXXZ ENDP			; HudClass::CycleRadarSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z PROC	; HudClass::SetRadarSwitch
; _this$ = ecx

; 858  : void HudClass::SetRadarSwitch(RadarSwitch state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 859  : 
; 860  : 	radarSwitch = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4880], ecx

; 861  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarSwitch@HudClass@@QAEXW4RadarSwitch@1@@Z ENDP	; HudClass::SetRadarSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarSwitch@HudClass@@QAEHXZ PROC			; HudClass::GetRadarSwitch
; _this$ = ecx

; 853  : int HudClass::GetRadarSwitch(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 854  : 
; 855  : 	return radarSwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4880]

; 856  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarSwitch@HudClass@@QAEHXZ ENDP			; HudClass::GetRadarSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?CycleVelocitySwitch@HudClass@@QAEXXZ PROC		; HudClass::CycleVelocitySwitch
; _this$ = ecx

; 834  : void HudClass::CycleVelocitySwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 835  : 
; 836  : 	switch(velocitySwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4876]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN3@CycleVeloc
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN2@CycleVeloc
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN1@CycleVeloc
	jmp	SHORT $LN6@CycleVeloc
$LN3@CycleVeloc:

; 837  : 	  case CAS:
; 838  : 		SetVelocitySwitch( TAS );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch

; 839  : 		break;

	jmp	SHORT $LN6@CycleVeloc
$LN2@CycleVeloc:

; 840  : 	  case TAS:
; 841  : 		SetVelocitySwitch( GND_SPD );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch

; 842  : 		break;

	jmp	SHORT $LN6@CycleVeloc
$LN1@CycleVeloc:

; 843  : 	  case GND_SPD:
; 844  : 		SetVelocitySwitch( CAS );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch
$LN6@CycleVeloc:

; 845  : 		break;
; 846  : 	}
; 847  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleVelocitySwitch@HudClass@@QAEXXZ ENDP		; HudClass::CycleVelocitySwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z PROC ; HudClass::SetVelocitySwitch
; _this$ = ecx

; 826  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 827  : 	if (PlayerOptions.GetAvionicsType() == ATEasy) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	jne	SHORT $LN2@SetVelocit

; 828  : 		velocitySwitch = CAS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4876], 0

; 829  : 	} else {

	jmp	SHORT $LN3@SetVelocit
$LN2@SetVelocit:

; 830  : 		velocitySwitch = state;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4876], edx
$LN3@SetVelocit:

; 831  : 	}
; 832  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ENDP ; HudClass::SetVelocitySwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVelocitySwitch@HudClass@@QAEHXZ PROC		; HudClass::GetVelocitySwitch
; _this$ = ecx

; 821  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 822  : 	return velocitySwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4876]

; 823  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetVelocitySwitch@HudClass@@QAEHXZ ENDP		; HudClass::GetVelocitySwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv78 = -16						; size = 4
_playerAC$ = -12					; size = 4
tv84 = -8						; size = 4
_this$ = -4						; size = 4
?CycleDEDSwitch@HudClass@@QAEXXZ PROC			; HudClass::CycleDEDSwitch
; _this$ = ecx

; 779  : void HudClass::CycleDEDSwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 780  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 781  : 	if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP)) 

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN14@CycleDEDSw
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	$LN14@CycleDEDSw

; 782  : 	{
; 783  : 		//MI
; 784  : 		if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN12@CycleDEDSw

; 785  : 		{
; 786  : 			switch(dedSwitch) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4872]
	mov	DWORD PTR tv78[ebp], edx
	cmp	DWORD PTR tv78[ebp], 0
	je	SHORT $LN9@CycleDEDSw
	cmp	DWORD PTR tv78[ebp], 1
	je	SHORT $LN8@CycleDEDSw
	jmp	SHORT $LN10@CycleDEDSw
$LN9@CycleDEDSw:

; 787  : 			{
; 788  : 			case DED_DATA:
; 789  : 				dedSwitch = DED_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4872], 1

; 790  : 				break;

	jmp	SHORT $LN10@CycleDEDSw
$LN8@CycleDEDSw:

; 791  : 			case DED_OFF:
; 792  : 				dedSwitch = DED_DATA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4872], 0
$LN10@CycleDEDSw:

; 793  : 				break;
; 794  : 			}
; 795  : 		}
; 796  : 		else

	jmp	SHORT $LN14@CycleDEDSw
$LN12@CycleDEDSw:

; 797  : 		{
; 798  : 			switch(dedSwitch) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4872]
	mov	DWORD PTR tv84[ebp], eax
	cmp	DWORD PTR tv84[ebp], 0
	je	SHORT $LN2@CycleDEDSw
	cmp	DWORD PTR tv84[ebp], 1
	je	SHORT $LN4@CycleDEDSw
	cmp	DWORD PTR tv84[ebp], 2
	je	SHORT $LN3@CycleDEDSw
	jmp	SHORT $LN14@CycleDEDSw
$LN4@CycleDEDSw:

; 799  : 			{
; 800  : 			case DED_OFF:
; 801  : 				dedSwitch = PFL_DATA;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4872], 2

; 802  : 			break;

	jmp	SHORT $LN14@CycleDEDSw
$LN3@CycleDEDSw:

; 803  : 			case PFL_DATA:
; 804  : 				dedSwitch = DED_DATA;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4872], 0

; 805  : 			break;

	jmp	SHORT $LN14@CycleDEDSw
$LN2@CycleDEDSw:

; 806  : 			case DED_DATA:
; 807  : 				dedSwitch = DED_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4872], 1
$LN14@CycleDEDSw:

; 808  : 			break;
; 809  : 			default:
; 810  : 			break;
; 811  : 			}
; 812  : 		}
; 813  : 	}
; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleDEDSwitch@HudClass@@QAEXXZ ENDP			; HudClass::CycleDEDSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z PROC	; HudClass::SetDEDSwitch
; _this$ = ecx

; 774  : void HudClass::SetDEDSwitch(DEDSwitch state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  : 	dedSwitch = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4872], ecx

; 777  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDEDSwitch@HudClass@@QAEXW4DEDSwitch@1@@Z ENDP	; HudClass::SetDEDSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDEDSwitch@HudClass@@QAEHXZ PROC			; HudClass::GetDEDSwitch
; _this$ = ecx

; 769  : int HudClass::GetDEDSwitch(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 770  : 
; 771  : 	return dedSwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4872]

; 772  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDEDSwitch@HudClass@@QAEHXZ ENDP			; HudClass::GetDEDSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv76 = -12						; size = 4
_playerAC$ = -8						; size = 4
_this$ = -4						; size = 4
?CycleDriftCOSwitch@HudClass@@QAEXXZ PROC		; HudClass::CycleDriftCOSwitch
; _this$ = ecx

; 749  : void HudClass::CycleDriftCOSwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 750  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 751  : 	if(playerAC && playerAC->IsSetFlag(MOTION_OWNSHIP)) {

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	SHORT $LN6@CycleDrift
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?IsSetFlag@SimBaseClass@@QBEHH@Z	; SimBaseClass::IsSetFlag
	test	eax, eax
	je	SHORT $LN6@CycleDrift

; 752  : 		switch(driftCOSwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4888]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN1@CycleDrift
	cmp	DWORD PTR tv76[ebp], 1
	je	SHORT $LN2@CycleDrift
	jmp	SHORT $LN6@CycleDrift
$LN2@CycleDrift:

; 753  : 		case DRIFT_CO_ON:
; 754  : 			driftCOSwitch = DRIFT_CO_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4888], 0

; 755  : 		break;

	jmp	SHORT $LN6@CycleDrift
$LN1@CycleDrift:

; 756  : 		case DRIFT_CO_OFF:
; 757  : 			driftCOSwitch = DRIFT_CO_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4888], 1
$LN6@CycleDrift:

; 758  : 		break;
; 759  : 		}
; 760  : 	}
; 761  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleDriftCOSwitch@HudClass@@QAEXXZ ENDP		; HudClass::CycleDriftCOSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetDriftCOSwitch@HudClass@@QAEXW4DriftCOSwitch@1@@Z PROC ; HudClass::SetDriftCOSwitch
; _this$ = ecx

; 744  : void HudClass::SetDriftCOSwitch(DriftCOSwitch state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 
; 746  : 	driftCOSwitch = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4888], ecx

; 747  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDriftCOSwitch@HudClass@@QAEXW4DriftCOSwitch@1@@Z ENDP ; HudClass::SetDriftCOSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDriftCOSwitch@HudClass@@QAEHXZ PROC			; HudClass::GetDriftCOSwitch
; _this$ = ecx

; 739  : int HudClass::GetDriftCOSwitch(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 740  : 
; 741  : 	return driftCOSwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4888]

; 742  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDriftCOSwitch@HudClass@@QAEHXZ ENDP			; HudClass::GetDriftCOSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?CycleFPMSwitch@HudClass@@QAEXXZ PROC			; HudClass::CycleFPMSwitch
; _this$ = ecx

; 717  : void HudClass::CycleFPMSwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 	switch(fpmSwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4868]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN4@CycleFPMSw
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN3@CycleFPMSw
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN2@CycleFPMSw
	jmp	SHORT $LN1@CycleFPMSw
$LN4@CycleFPMSw:

; 719  : 	  case ATT_FPM:
; 720  : 		SetFPMSwitch( FPM );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 721  : 		break;

	jmp	SHORT $LN7@CycleFPMSw
$LN3@CycleFPMSw:

; 722  : 	  case FPM:
; 723  : 		SetFPMSwitch( FPM_OFF );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 724  : 		break;

	jmp	SHORT $LN7@CycleFPMSw
$LN2@CycleFPMSw:

; 725  : 	  case FPM_OFF:
; 726  : 		SetFPMSwitch( ATT_FPM );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 727  : 		break;

	jmp	SHORT $LN7@CycleFPMSw
$LN1@CycleFPMSw:

; 728  :      default:
; 729  :         SetFPMSwitch(ATT_FPM);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch
$LN7@CycleFPMSw:

; 730  :       break;
; 731  : 	}
; 732  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleFPMSwitch@HudClass@@QAEXXZ ENDP			; HudClass::CycleFPMSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z PROC	; HudClass::SetFPMSwitch
; _this$ = ecx

; 709  : void HudClass::SetFPMSwitch(FPMSwitch state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 710  : 	if (PlayerOptions.GetAvionicsType() == ATEasy) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	jne	SHORT $LN2@SetFPMSwit

; 711  :        fpmSwitch = FPM_AUTO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4868], 3

; 712  : 	} else {

	jmp	SHORT $LN3@SetFPMSwit
$LN2@SetFPMSwit:

; 713  :        fpmSwitch = state;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4868], edx
$LN3@SetFPMSwit:

; 714  : 	}
; 715  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ENDP	; HudClass::SetFPMSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFPMSwitch@HudClass@@QAEHXZ PROC			; HudClass::GetFPMSwitch
; _this$ = ecx

; 704  : int HudClass::GetFPMSwitch(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 705  : 
; 706  : 	return fpmSwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4868]

; 707  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFPMSwitch@HudClass@@QAEHXZ ENDP			; HudClass::GetFPMSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?CycleScalesSwitch@HudClass@@QAEXXZ PROC		; HudClass::CycleScalesSwitch
; _this$ = ecx

; 682  : void HudClass::CycleScalesSwitch(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 683  : 
; 684  : 	switch(scalesSwitch) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4864]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN4@CycleScale
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN3@CycleScale
	cmp	DWORD PTR tv65[ebp], 3
	je	SHORT $LN2@CycleScale
	jmp	SHORT $LN1@CycleScale
$LN4@CycleScale:

; 685  : 	  case VV_VAH:
; 686  : 		SetScalesSwitch( VAH );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 687  : 		break;

	jmp	SHORT $LN7@CycleScale
$LN3@CycleScale:

; 688  : 	  case VAH: 
; 689  : 		SetScalesSwitch( SS_OFF );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 690  : 		break;

	jmp	SHORT $LN7@CycleScale
$LN2@CycleScale:

; 691  : 	  case SS_OFF:
; 692  : 		SetScalesSwitch( VV_VAH );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 693  : 		break;

	jmp	SHORT $LN7@CycleScale
$LN1@CycleScale:

; 694  :      default:
; 695  :       SetScalesSwitch (VAH);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch
$LN7@CycleScale:

; 696  :       break;
; 697  : 	}
; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CycleScalesSwitch@HudClass@@QAEXXZ ENDP		; HudClass::CycleScalesSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 4
?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z PROC	; HudClass::SetScalesSwitch
; _this$ = ecx

; 674  : void HudClass::SetScalesSwitch(ScalesSwitch state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 675  : 	if (PlayerOptions.GetAvionicsType() == ATEasy) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	jne	SHORT $LN2@SetScalesS

; 676  : 		scalesSwitch = H;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4864], 2

; 677  : 	} else {

	jmp	SHORT $LN3@SetScalesS
$LN2@SetScalesS:

; 678  : 		scalesSwitch = state;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4864], edx
$LN3@SetScalesS:

; 679  : 	}
; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ENDP	; HudClass::SetScalesSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetScalesSwitch@HudClass@@QAEHXZ PROC			; HudClass::GetScalesSwitch
; _this$ = ecx

; 669  : int HudClass::GetScalesSwitch(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 670  : 
; 671  : 	return scalesSwitch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4864]

; 672  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetScalesSwitch@HudClass@@QAEHXZ ENDP			; HudClass::GetScalesSwitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetContrastLevel@HudClass@@QAEXXZ PROC			; HudClass::SetContrastLevel
; _this$ = ecx

; 2184 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2185 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetContrastLevel@HudClass@@QAEXXZ ENDP			; HudClass::SetContrastLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_percent$ = 8						; size = 4
_color$ = 12						; size = 4
?CalculateBrightness@HudClass@@QAEXMPAK@Z PROC		; HudClass::CalculateBrightness
; _this$ = ecx

; 2197 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2198 : 	HudBrightness=1.0f*percent;

	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _percent$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+4896], xmm0

; 2199 : 	*color=(*color&0x00ffffff)|((FloatToInt32(255*percent))<<24);

	mov	ecx, DWORD PTR _color$[ebp]
	mov	esi, DWORD PTR [ecx]
	and	esi, 16777215				; 00ffffffH
	movss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm0, DWORD PTR _percent$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	shl	eax, 24					; 00000018H
	or	esi, eax
	mov	edx, DWORD PTR _color$[ebp]
	mov	DWORD PTR [edx], esi

; 2200 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?CalculateBrightness@HudClass@@QAEXMPAK@Z ENDP		; HudClass::CalculateBrightness
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv239 = -28						; size = 4
tv284 = -24						; size = 4
tv232 = -20						; size = 4
tv134 = -16						; size = 4
_Value$ = -12						; size = 4
_lightLevel$ = -8					; size = 4
_this$ = -4						; size = 4
?SetLightLevel@HudClass@@QAEXXZ PROC			; HudClass::SetLightLevel
; _this$ = ecx

; 2204 : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2205 : 	float	Value;
; 2206 : 
; 2207 : 	curHudColor = HUDcolor[curColorIdx];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	edx, DWORD PTR _HUDcolor[ecx*4]
	mov	DWORD PTR [eax+4892], edx

; 2208 : 
; 2209 : 	// COBRA - RED - Non realistic
; 2210 : 	if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN22@SetLightLe

; 2211 : 	{
; 2212 : 		if(brightnessSwitch == BRIGHT_AUTO) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4884], 2
	jne	SHORT $LN21@SetLightLe

; 2213 : 			CalculateBrightness(0.8F, &curHudColor);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4892				; 0000131cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness

; 2214 : 			HudContrast=0.8f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [eax+4900], xmm0
	jmp	$LN17@SetLightLe
$LN21@SetLightLe:

; 2215 : 		} 
; 2216 : 		else if(brightnessSwitch == NIGHT) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4884], 3
	jne	SHORT $LN19@SetLightLe

; 2217 : 			CalculateBrightness(0.6F, &curHudColor);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4892				; 0000131cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness

; 2218 : 			HudContrast=0.8f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [eax+4900], xmm0
	jmp	SHORT $LN17@SetLightLe
$LN19@SetLightLe:

; 2219 : 		}
; 2220 : 		else if(brightnessSwitch == DAY) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4884], 1
	jne	SHORT $LN17@SetLightLe

; 2221 : 			CalculateBrightness(0.9F, &curHudColor);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4892				; 0000131cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness

; 2222 : 			HudContrast=1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+4900], xmm0
$LN17@SetLightLe:

; 2223 : 		}
; 2224 : 		return;											// if Non realistic exits here

	jmp	$LN23@SetLightLe
$LN22@SetLightLe:

; 2225 : 	}
; 2226 : 
; 2227 : 	if (IO.AnalogIsUsed(AXIS_HUD_BRIGHTNESS) == true)	// Retro 4Jan2004 (whole if)

	push	18					; 00000012H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?AnalogIsUsed@SIMLIB_IO_CLASS@@QAE_NW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::AnalogIsUsed
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN16@SetLightLe

; 2228 : 		Value = (float)IO.GetAxisValue(AXIS_HUD_BRIGHTNESS)/20000.0F;  

	push	18					; 00000012H
	mov	ecx, OFFSET ?IO@@3VSIMLIB_IO_CLASS@@A	; IO
	call	?GetAxisValue@SIMLIB_IO_CLASS@@QAEHW4GameAxis_t@@@Z ; SIMLIB_IO_CLASS::GetAxisValue
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@469c4000
	movss	DWORD PTR _Value$[ebp], xmm0

; 2229 : 	else 

	jmp	SHORT $LN15@SetLightLe
$LN16@SetLightLe:

; 2230 : 		Value=SymWheelPos;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+5136]
	movss	DWORD PTR _Value$[ebp], xmm0
$LN15@SetLightLe:

; 2231 : 
; 2232 : 	// Calculate valued based on Hud Brightness Mode Switch
; 2233 : 	float lightLevel;
; 2234 : 	switch(brightnessSwitch){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4884]
	mov	DWORD PTR tv134[ebp], ecx
	cmp	DWORD PTR tv134[ebp], 1
	je	$LN8@SetLightLe
	cmp	DWORD PTR tv134[ebp], 2
	je	SHORT $LN12@SetLightLe
	cmp	DWORD PTR tv134[ebp], 3
	je	$LN9@SetLightLe
	jmp	$LN5@SetLightLe
$LN12@SetLightLe:

; 2235 : 
; 2236 : 		// Auto Mode - Brightness is based on Pitch of the Plane, the higher, the brighter
; 2237 : 		case	BRIGHT_AUTO:
; 2238 : 							lightLevel = hudColor.a * TheTimeOfDay.GetAmbientValue() * 0.2f;

	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	call	?GetAmbientValue@CTimeOfDay@@QAEMXZ	; CTimeOfDay::GetAmbientValue
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	mulss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _lightLevel$[ebp], xmm0

; 2239 : 							lightLevel+= AutoHudCx * 0.5f * TheTimeOfDay.GetAmbientValue();

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4904]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, OFFSET ?TheTimeOfDay@@3VCTimeOfDay@@A ; TheTimeOfDay
	movss	DWORD PTR tv284[ebp], xmm0
	call	?GetAmbientValue@CTimeOfDay@@QAEMXZ	; CTimeOfDay::GetAmbientValue
	fstp	DWORD PTR tv239[ebp]
	movss	xmm0, DWORD PTR tv284[ebp]
	mulss	xmm0, DWORD PTR tv239[ebp]
	addss	xmm0, DWORD PTR _lightLevel$[ebp]
	movss	DWORD PTR _lightLevel$[ebp], xmm0

; 2240 : 							lightLevel+= 0.3f * Value;

	movss	xmm0, DWORD PTR __real@3e99999a
	mulss	xmm0, DWORD PTR _Value$[ebp]
	addss	xmm0, DWORD PTR _lightLevel$[ebp]
	movss	DWORD PTR _lightLevel$[ebp], xmm0

; 2241 : 							if(lightLevel>HUD_MAX_BRIGHT_DAY)lightLevel=HUD_MAX_BRIGHT_DAY;					// check for limits

	movss	xmm0, DWORD PTR _lightLevel$[ebp]
	comiss	xmm0, DWORD PTR __real@3f4ccccd
	jbe	SHORT $LN11@SetLightLe
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _lightLevel$[ebp], xmm0
$LN11@SetLightLe:

; 2242 : 							if(lightLevel<0.2f)lightLevel=0.2f;					//

	movss	xmm0, DWORD PTR __real@3e4ccccd
	comiss	xmm0, DWORD PTR _lightLevel$[ebp]
	jbe	SHORT $LN10@SetLightLe
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _lightLevel$[ebp], xmm0
$LN10@SetLightLe:

; 2243 : 							CalculateBrightness(lightLevel, &curHudColor);		// apply

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4892				; 0000131cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _lightLevel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness

; 2244 : 							break;

	jmp	$LN13@SetLightLe
$LN9@SetLightLe:

; 2245 : 		
; 2246 : 		case	NIGHT:		
; 2247 : 							CalculateBrightness(hudColor.a * (HUD_MAX_BRIGHT_NIGHT * .25f + HUD_MAX_BRIGHT_NIGHT *.74f * Value), &curHudColor);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4892				; 0000131cH
	push	ecx
	movss	xmm0, DWORD PTR __real@3e978d50
	mulss	xmm0, DWORD PTR _Value$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness

; 2248 : 							break;

	jmp	$LN13@SetLightLe
$LN8@SetLightLe:

; 2249 : 
; 2250 : 		case	DAY:		
; 2251 : 							if (g_bBrightHUD)

	movzx	edx, BYTE PTR ?g_bBrightHUD@@3_NA	; g_bBrightHUD
	test	edx, edx
	je	SHORT $LN7@SetLightLe

; 2252 : 								CalculateBrightness(1.0F, &curHudColor);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4892				; 0000131cH
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness

; 2253 : 							else

	jmp	SHORT $LN6@SetLightLe
$LN7@SetLightLe:

; 2254 : 								CalculateBrightness(hudColor.a * (HUD_MAX_BRIGHT_DAY * .25f + HUD_MAX_BRIGHT_DAY *.74f * Value), &curHudColor);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4892				; 0000131cH
	push	ecx
	movss	xmm0, DWORD PTR __real@3f178d50
	mulss	xmm0, DWORD PTR _Value$[ebp]
	addss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness
$LN6@SetLightLe:

; 2255 : 							break;

	jmp	SHORT $LN13@SetLightLe
$LN5@SetLightLe:

; 2256 : 
; 2257 : 		default:	CalculateBrightness(Value, &curHudColor);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4892				; 0000131cH
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _Value$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateBrightness@HudClass@@QAEXMPAK@Z ; HudClass::CalculateBrightness
$LN13@SetLightLe:

; 2258 : 	}
; 2259 : 
; 2260 : 	if ((g_bBrightHUD) && (brightnessSwitch == DAY))

	movzx	eax, BYTE PTR ?g_bBrightHUD@@3_NA	; g_bBrightHUD
	test	eax, eax
	je	SHORT $LN4@SetLightLe
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4884], 1
	jne	SHORT $LN4@SetLightLe

; 2261 : 		HudContrast = 1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+4900], xmm0

; 2262 : 	else

	jmp	SHORT $LN3@SetLightLe
$LN4@SetLightLe:

; 2263 : 		HudContrast = hudColor.a + 1.0f - HUD_MAX_BRIGHT_DAY + HudBrightness * (1.0f-hudColor.a); //0.5f + TheTimeOfDay.GetAmbientValue() * lightLevel * 3.0f;

	movss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12
	addss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [eax+4896]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+4900], xmm0
$LN3@SetLightLe:

; 2264 : 	if(HudContrast>1.0f) HudContrast=1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4900]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN2@SetLightLe
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+4900], xmm0
$LN2@SetLightLe:

; 2265 : 	if(HudContrast<0.0f) HudContrast=0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [ecx+4900]
	jbe	SHORT $LN1@SetLightLe
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4900], xmm0
$LN1@SetLightLe:
$LN23@SetLightLe:

; 2266 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetLightLevel@HudClass@@QAEXXZ ENDP			; HudClass::SetLightLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HudColorStep@HudClass@@QAEXXZ PROC			; HudClass::HudColorStep
; _this$ = ecx

; 2188 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2189 :   curColorIdx ++;

	mov	eax, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	add	eax, 1
	mov	DWORD PTR ?curColorIdx@@3HA, eax	; curColorIdx

; 2190 :   curColorIdx %= NumHudColors;

	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN3@HudColorSt
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN3@HudColorSt:
	mov	DWORD PTR ?curColorIdx@@3HA, ecx	; curColorIdx

; 2191 : 	SetHudColor(HUDcolor[curColorIdx]);

	mov	edx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	eax, DWORD PTR _HUDcolor[edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHudColor@HudClass@@QAEXK@Z		; HudClass::SetHudColor

; 2192 : //	SetLightLevel();
; 2193 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HudColorStep@HudClass@@QAEXXZ ENDP			; HudClass::HudColorStep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv212 = -52						; size = 8
tv202 = -44						; size = 8
tv192 = -36						; size = 8
tv182 = -28						; size = 8
tv209 = -20						; size = 4
tv199 = -16						; size = 4
tv189 = -12						; size = 4
tv179 = -8						; size = 4
_this$ = -4						; size = 4
_newColor$ = 8						; size = 4
?SetHudColor@HudClass@@QAEXK@Z PROC			; HudClass::SetHudColor
; _this$ = ecx

; 2156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 2157 : 	// Find fixed colors index
; 2158 : 	curColorIdx = 0;

	mov	DWORD PTR ?curColorIdx@@3HA, 0		; curColorIdx
$LN4@SetHudColo:

; 2159 : 	while(newColor != HUDcolor[curColorIdx])

	mov	eax, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	ecx, DWORD PTR _newColor$[ebp]
	cmp	ecx, DWORD PTR _HUDcolor[eax*4]
	je	SHORT $LN3@SetHudColo

; 2160 : 	{
; 2161 : 		curColorIdx++;

	mov	edx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	add	edx, 1
	mov	DWORD PTR ?curColorIdx@@3HA, edx	; curColorIdx

; 2162 : 		if(curColorIdx > NumHudColors)

	cmp	DWORD PTR ?curColorIdx@@3HA, 8		; curColorIdx
	jle	SHORT $LN2@SetHudColo

; 2163 : 		{
; 2164 : 			curColorIdx = 0;

	mov	DWORD PTR ?curColorIdx@@3HA, 0		; curColorIdx

; 2165 : 			break;

	jmp	SHORT $LN3@SetHudColo
$LN2@SetHudColo:

; 2166 : 		}
; 2167 : 	}

	jmp	SHORT $LN4@SetHudColo
$LN3@SetHudColo:

; 2168 : 	if (TheHud){

	cmp	DWORD PTR ?TheHud@@3PAVHudClass@@A, 0	; TheHud
	je	SHORT $LN1@SetHudColo

; 2169 : 		SymWheelPos = 0.5F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+5136], xmm0
$LN1@SetHudColo:

; 2170 : 	}
; 2171 : 	hudColor.a=((float)((HUDcolor[curColorIdx]&0xff000000)>>24))/255.0f;

	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	edx, DWORD PTR _HUDcolor[ecx*4]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	DWORD PTR tv179[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv179[ebp]
	mov	eax, DWORD PTR tv179[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv182[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv182[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12, xmm0

; 2172 : 	hudColor.b=((float)((HUDcolor[curColorIdx]&0xff0000)>>16))/255.0f;

	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	edx, DWORD PTR _HUDcolor[ecx*4]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	DWORD PTR tv189[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv189[ebp]
	mov	eax, DWORD PTR tv189[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv192[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv192[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+8, xmm0

; 2173 : 	hudColor.g=((float)((HUDcolor[curColorIdx]&0xff00)>>8))/255.0f;

	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	edx, DWORD PTR _HUDcolor[ecx*4]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	DWORD PTR tv199[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv199[ebp]
	mov	eax, DWORD PTR tv199[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv202[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv202[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+4, xmm0

; 2174 : 	hudColor.r=((float)(HUDcolor[curColorIdx]&0xff))/255.0f;

	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	edx, DWORD PTR _HUDcolor[ecx*4]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR tv209[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv209[ebp]
	mov	eax, DWORD PTR tv209[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv212[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv212[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR ?hudColor@HudClass@@0UPcolor@@A, xmm0

; 2175 : 	//Set Up the Contrast, the Hud Color and the Light Level and Apply them
; 2176 : 	SetLightLevel();														

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel

; 2177 : 	curHudColor = curHudColor&0xff000000;								// mantain alpha

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4892]
	and	edx, -16777216				; ff000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4892], edx

; 2178 : 	curHudColor+= ((int)(hudColor.b*255*(0.5F + HudContrast/2)))<<16;

	movss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+8
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4900]
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	cvttss2si edx, xmm0
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4892]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4892], edx

; 2179 : 	curHudColor+= ((int)(hudColor.g*255*(0.5F + HudContrast/2)))<<8;

	movss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+4
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4900]
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4892]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4892], eax

; 2180 : 	curHudColor+= ((int)(hudColor.r*255*(0.5F + HudContrast/2)));

	movss	xmm0, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4900]
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4892]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4892], ecx

; 2181 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHudColor@HudClass@@QAEXK@Z ENDP			; HudClass::SetHudColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_Color$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?GetHudColor@HudClass@@QAEKXZ PROC			; HudClass::GetHudColor
; _this$ = ecx

; 2126 : DWORD HudClass::GetHudColor(void){

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2127 : 	// COBRA - RED - Hud Cxes based on plane pitch and time o day
; 2128 : 	AutoHudCx=ObserverPitch;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?ObserverPitch@@3MA
	movss	DWORD PTR [eax+4904], xmm0

; 2129 : 	if(ObserverPitch<(-0.05f)) AutoHudCx*=1.2f;							// if going down faster changes

	movss	xmm0, DWORD PTR __real@bd4ccccd
	comiss	xmm0, DWORD PTR ?ObserverPitch@@3MA
	jbe	SHORT $LN2@GetHudColo
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4904]
	mulss	xmm0, DWORD PTR __real@3f99999a
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4904], xmm0
$LN2@GetHudColo:

; 2130 : 
; 2131 : 	// a copy of the selected hud color
; 2132 : 	Pcolor	Color=hudColor;

	mov	eax, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A
	mov	DWORD PTR _Color$[ebp], eax
	mov	ecx, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+4
	mov	DWORD PTR _Color$[ebp+4], ecx
	mov	edx, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+8
	mov	DWORD PTR _Color$[ebp+8], edx
	mov	eax, DWORD PTR ?hudColor@HudClass@@0UPcolor@@A+12
	mov	DWORD PTR _Color$[ebp+12], eax

; 2133 : 	// if NVG change it to whiteish
; 2134 : 	if(TheDXEngine.GetState() == DX_NVG){

	mov	ecx, OFFSET ?TheDXEngine@@3VCDXEngine@@A ; TheDXEngine
	call	?GetState@CDXEngine@@QAE?AW4DX_StateType@@XZ ; CDXEngine::GetState
	cmp	eax, 2
	jne	SHORT $LN1@GetHudColo

; 2135 : 		Color.r=0.8f;

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _Color$[ebp], xmm0

; 2136 : 		Color.g=1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _Color$[ebp+4], xmm0

; 2137 : 		Color.b=0.9f;

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR _Color$[ebp+8], xmm0
$LN1@GetHudColo:

; 2138 : 	}
; 2139 : 
; 2140 : 
; 2141 : 	//Set Up the Contrast, the Hud Color and the Light Level and Apply them
; 2142 : 	SetLightLevel();														

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel

; 2143 : 	curHudColor = curHudColor&0xff000000;								// mantain alpha

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4892]
	and	edx, -16777216				; ff000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4892], edx

; 2144 : 	curHudColor+= ((int)(Color.b*255*(0.5F + HudContrast/2)))<<16;

	movss	xmm0, DWORD PTR _Color$[ebp+8]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4900]
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	cvttss2si edx, xmm0
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4892]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4892], edx

; 2145 : 	curHudColor+= ((int)(Color.g*255*(0.5F + HudContrast/2)))<<8;

	movss	xmm0, DWORD PTR _Color$[ebp+4]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4900]
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4892]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4892], eax

; 2146 : 	curHudColor+= ((int)(Color.r*255*(0.5F + HudContrast/2)));

	movss	xmm0, DWORD PTR _Color$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+4900]
	divss	xmm1, DWORD PTR __real@40000000
	addss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4892]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4892], ecx

; 2147 : 	//curHudColor += (((int)(hudColor*HudContrast))<<8);
; 2148 : 
; 2149 : //	curHudColor = HUDcolor[curColorIdx];
; 2150 : //	CalculateBrightness(SymWheelPos, &curHudColor);
; 2151 : 
; 2152 : 	return curHudColor;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4892]

; 2153 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHudColor@HudClass@@QAEKXZ ENDP			; HudClass::GetHudColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv64 = -4						; size = 4
_whichButton$ = 8					; size = 4
_whichMFD$ = 12						; size = 4
?PushButton@HudClass@@UAEXHH@Z PROC			; HudClass::PushButton
; _this$ = ecx

; 2105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2106 :    switch (whichButton){

	mov	eax, DWORD PTR _whichButton$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN2@PushButton
	cmp	DWORD PTR tv64[ebp], 14			; 0000000eH
	je	SHORT $LN1@PushButton
	jmp	SHORT $LN5@PushButton
$LN2@PushButton:

; 2107 :       case 0:
; 2108 :          MfdDisplay[whichMFD]->SetNewMode(MFDClass::MfdMenu);

	push	1
	mov	ecx, DWORD PTR _whichMFD$[ebp]
	mov	ecx, DWORD PTR ?MfdDisplay@@3PAPAVMFDClass@@A[ecx*4]
	call	?SetNewMode@MFDClass@@QAEXW4MfdMode@1@@Z ; MFDClass::SetNewMode

; 2109 :       break;

	jmp	SHORT $LN5@PushButton
$LN1@PushButton:

; 2110 :       case 14:
; 2111 :          MFDSwapDisplays();

	call	?MFDSwapDisplays@@YAXXZ			; MFDSwapDisplays
$LN5@PushButton:

; 2112 :       break;
; 2113 :    }
; 2114 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PushButton@HudClass@@UAEXHH@Z ENDP			; HudClass::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_offset$ = -204						; size = 4
_CameraHalfFOV$ = -200					; size = 4
tv429 = -196						; size = 4
tv446 = -192						; size = 4
tv424 = -188						; size = 4
tv460 = -184						; size = 4
_curRangeSqrd$ = -180					; size = 4
tv419 = -176						; size = 4
tv474 = -172						; size = 4
tv467 = -168						; size = 4
tv579 = -164						; size = 4
tv453 = -160						; size = 4
tv572 = -156						; size = 4
_this$ = -152						; size = 4
_el$ = -148						; size = 4
tv481 = -144						; size = 4
_maxRangeSqrd$ = -140					; size = 4
_wc$ = -136						; size = 4
_sinP$ = -132						; size = 4
_cosP$ = -128						; size = 4
_az$ = -124						; size = 4
_sinR$ = -120						; size = 4
_cosY$ = -116						; size = 4
_sinY$ = -112						; size = 4
_retval$ = -108						; size = 4
_cosR$ = -104						; size = 4
_dx$ = -100						; size = 4
_dz$ = -96						; size = 4
_dy$ = -92						; size = 4
_RR$ = -88						; size = 36
_RR2$ = -52						; size = 36
_point$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_entity$ = 12						; size = 4
_platform$ = 16						; size = 4
?CanSeeTarget@HudClass@@QAEPAVVuEntity@@HPAV2@PAVFalconEntity@@@Z PROC ; HudClass::CanSeeTarget
; _this$ = ecx

; 2272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 	//MI camera fix
; 2274 : #if 0
; 2275 : Tpoint point;
; 2276 : ThreeDVertex pixel;
; 2277 : VuEntity* retval = NULL;
; 2278 : WeaponClassDataType *wc;
; 2279 : float top, left, bottom, right;
; 2280 : float dx, dy, dz;
; 2281 : float maxRangeSqrd;
; 2282 : float curRangeSqrd;
; 2283 : 
; 2284 :    wc = (WeaponClassDataType*)Falcon4ClassTable[type-VU_LAST_ENTITY_TYPE].dataPtr;
; 2285 : 
; 2286 :    maxRangeSqrd = (wc->Range * KM_TO_FT) * (wc->Range * KM_TO_FT);
; 2287 : 
; 2288 :    point.x = entity->XPos();
; 2289 :    point.y = entity->YPos();
; 2290 :    point.z = OTWDriver.GetGroundLevel (point.x, point.y);
; 2291 : 
; 2292 :    dx = point.x - platform->XPos();
; 2293 :    dy = point.y - platform->YPos();
; 2294 :    dz = point.z - platform->ZPos();
; 2295 : 
; 2296 :    curRangeSqrd = dx*dx + dy*dy + dz*dz;
; 2297 : 
; 2298 :    if (curRangeSqrd < maxRangeSqrd)
; 2299 :    {
; 2300 :       // Check LOS
; 2301 :       if (OTWDriver.CheckLOS( platform, (FalconEntity*)entity))
; 2302 :       {
; 2303 :          // For ownship, check if in the circle
; 2304 :          if (platform == ownship)
; 2305 :          {
; 2306 :             OTWDriver.renderer->TransformPoint(&point, &pixel );
; 2307 : 
; 2308 :             if (pixel.clipFlag == ON_SCREEN)
; 2309 :             {
; 2310 :                // It's in front, but is it in the circle?
; 2311 :                bottom = pixelYCenter + 6.0F*sightRadius;
; 2312 :                top    = pixelYCenter - 6.0F*sightRadius;
; 2313 :                left   = pixelXCenter - 6.0F*sightRadius;
; 2314 :                right  = pixelXCenter + 6.0F*sightRadius;
; 2315 : 
; 2316 :                if (pixel.x > left && pixel.x < right && pixel.y < bottom && pixel.y > top)
; 2317 :                {
; 2318 :                   retval = entity;
; 2319 :                }
; 2320 :             }
; 2321 :          }
; 2322 :          else // In range and good LOS enough for AI
; 2323 :          {
; 2324 :             retval = entity;
; 2325 :          }
; 2326 :       }
; 2327 :    }
; 2328 : 
; 2329 :    return retval;
; 2330 : #else
; 2331 :    Tpoint point;
; 2332 : Trotation RR, RR2;
; 2333 : float cosP,sinP,cosY,sinY, sinR, cosR = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _cosR$[ebp], xmm0

; 2334 : float el, az = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _az$[ebp], xmm0

; 2335 : VuEntity* retval = NULL;

	mov	DWORD PTR _retval$[ebp], 0

; 2336 : WeaponClassDataType *wc;
; 2337 : float dx, dy, dz;
; 2338 : float maxRangeSqrd;
; 2339 : float curRangeSqrd;
; 2340 : float CameraHalfFOV = 1.4F * DTR;

	movss	xmm0, DWORD PTR __real@3cc82b15
	movss	DWORD PTR _CameraHalfFOV$[ebp], xmm0

; 2341 : float offset = -8.0F * DTR;

	movss	xmm0, DWORD PTR __real@be0efa34
	movss	DWORD PTR _offset$[ebp], xmm0

; 2342 : 
; 2343 :         wc = 
; 2344 : (WeaponClassDataType*)Falcon4ClassTable[type-VU_LAST_ENTITY_TYPE].dataPtr;

	mov	eax, DWORD PTR _type$[ebp]
	sub	eax, 100				; 00000064H
	imul	eax, 81					; 00000051H
	mov	ecx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	edx, DWORD PTR [ecx+eax+77]
	mov	DWORD PTR _wc$[ebp], edx

; 2345 : 
; 2346 :         maxRangeSqrd = (wc->Range * KM_TO_FT) * (wc->Range * KM_TO_FT);

	mov	eax, DWORD PTR _wc$[ebp]
	movsx	ecx, WORD PTR [eax+8]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@454cffae
	mov	edx, DWORD PTR _wc$[ebp]
	movsx	eax, WORD PTR [edx+8]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@454cffae
	mulss	xmm0, xmm1
	movss	DWORD PTR _maxRangeSqrd$[ebp], xmm0

; 2347 : 
; 2348 :         point.x = entity->XPos();

	mov	ecx, DWORD PTR _entity$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _point$[ebp]

; 2349 :         point.y = entity->YPos();

	mov	ecx, DWORD PTR _entity$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _point$[ebp+4]

; 2350 :         point.z = OTWDriver.GetGroundLevel (point.x, point.y);

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _point$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _point$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _point$[ebp+8]

; 2351 : 
; 2352 :         dx = point.x - platform->XPos();

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv419[ebp]
	movss	xmm0, DWORD PTR _point$[ebp]
	subss	xmm0, DWORD PTR tv419[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2353 :         dy = point.y - platform->YPos();

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv424[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+4]
	subss	xmm0, DWORD PTR tv424[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2354 :         dz = point.z - platform->ZPos();

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv429[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+8]
	subss	xmm0, DWORD PTR tv429[ebp]
	movss	DWORD PTR _dz$[ebp], xmm0

; 2355 :         point.x = dx;

	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR _point$[ebp], xmm0

; 2356 :         point.y = dy;

	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _point$[ebp+4], xmm0

; 2357 :         point.z = dz;

	movss	xmm0, DWORD PTR _dz$[ebp]
	movss	DWORD PTR _point$[ebp+8], xmm0

; 2358 :         curRangeSqrd = dx*dx + dy*dy + dz*dz;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _dz$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _curRangeSqrd$[ebp], xmm0

; 2359 : 
; 2360 :         if (curRangeSqrd < maxRangeSqrd)

	movss	xmm0, DWORD PTR _maxRangeSqrd$[ebp]
	comiss	xmm0, DWORD PTR _curRangeSqrd$[ebp]
	jbe	$LN1@CanSeeTarg

; 2361 :         {
; 2362 :                 // Check LOS
; 2363 :                 if (OTWDriver.CheckLOS( platform, (FalconEntity*)entity))

	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _platform$[ebp]
	push	edx
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?CheckLOS@OTWDriverClass@@QAEHPAVFalconEntity@@0@Z ; OTWDriverClass::CheckLOS
	test	eax, eax
	je	$LN1@CanSeeTarg

; 2364 :                 {
; 2365 : 					// For ownship, check if within camera FOV
; 2366 : 					if (platform == ownship)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _platform$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jne	$LN4@CanSeeTarg

; 2367 : 					{
; 2368 : 						//dpc - Rotation Matrix should be done once per every camera shot, not for 
; 2369 : 						//each entity, ah well...
; 2370 : 						//But it doesn't look like it's hogging down FPS so it remains here...
; 2371 : 						//I should probably calculate one matrix that does all three - Yaw, Pitch 
; 2372 : 						//and Roll but this works
; 2373 : 						//and I don't want to mess it up...End effect is the same.
; 2374 : 
; 2375 : 						cosP = (float)cos (- platform->Pitch());

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv446[ebp]
	movss	xmm0, DWORD PTR tv446[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosP$[ebp]

; 2376 : 						sinP = (float)sin (- platform->Pitch());

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?Pitch@VuEntity@@QBEMXZ			; VuEntity::Pitch
	fstp	DWORD PTR tv453[ebp]
	movss	xmm0, DWORD PTR tv453[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinP$[ebp]

; 2377 : 						cosY = (float)cos (- platform->Yaw());

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv460[ebp]
	movss	xmm0, DWORD PTR tv460[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosY$[ebp]

; 2378 : 						sinY = (float)sin (- platform->Yaw());

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv467[ebp]
	movss	xmm0, DWORD PTR tv467[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinY$[ebp]

; 2379 : 						cosR = (float)cos (- platform->Roll());

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv474[ebp]
	movss	xmm0, DWORD PTR tv474[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cosR$[ebp]

; 2380 : 						sinR = (float)sin (- platform->Roll());

	mov	ecx, DWORD PTR _platform$[ebp]
	call	?Roll@VuEntity@@QBEMXZ			; VuEntity::Roll
	fstp	DWORD PTR tv481[ebp]
	movss	xmm0, DWORD PTR tv481[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sinR$[ebp]

; 2381 : 
; 2382 : 						RR.M11 = cosY;

	movss	xmm0, DWORD PTR _cosY$[ebp]
	movss	DWORD PTR _RR$[ebp], xmm0

; 2383 : 						RR.M21 = sinY;

	movss	xmm0, DWORD PTR _sinY$[ebp]
	movss	DWORD PTR _RR$[ebp+12], xmm0

; 2384 : 						RR.M31 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR$[ebp+24], xmm0

; 2385 : 
; 2386 : 						RR.M12 = -sinY;

	movss	xmm0, DWORD PTR _sinY$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _RR$[ebp+4], xmm0

; 2387 : 						RR.M22 = cosY;

	movss	xmm0, DWORD PTR _cosY$[ebp]
	movss	DWORD PTR _RR$[ebp+16], xmm0

; 2388 : 						RR.M32 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR$[ebp+28], xmm0

; 2389 : 
; 2390 : 						RR.M13 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR$[ebp+8], xmm0

; 2391 : 						RR.M23 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR$[ebp+20], xmm0

; 2392 : 						RR.M33 = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RR$[ebp+32], xmm0

; 2393 : 						//First rotation is only doing (-Yaw)
; 2394 : 						point.x = dx * RR.M11 + dy * RR.M12 + dz * RR.M13;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _RR$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _RR$[ebp+4]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _RR$[ebp+8]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp], xmm0

; 2395 : 						point.y = dx * RR.M21 + dy * RR.M22 + dz * RR.M23;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _RR$[ebp+12]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _RR$[ebp+16]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _RR$[ebp+20]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp+4], xmm0

; 2396 : 						point.z = dx * RR.M31 + dy * RR.M32 + dz * RR.M33;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _RR$[ebp+24]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _RR$[ebp+28]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _RR$[ebp+32]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp+8], xmm0

; 2397 : 						dx = point.x; dy = point.y; dz = point.z;

	movss	xmm0, DWORD PTR _point$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR _point$[ebp+4]
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR _point$[ebp+8]
	movss	DWORD PTR _dz$[ebp], xmm0

; 2398 : 
; 2399 : 						//JAM 27Sep03 - These are floats
; 2400 : 						cosY = (float)cosf (0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	fstp	DWORD PTR _cosY$[ebp]

; 2401 : 						sinY = (float)sinf (0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	fstp	DWORD PTR _sinY$[ebp]

; 2402 : 						cosR = (float)cosf (0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	fstp	DWORD PTR _cosR$[ebp]

; 2403 : 						sinR = (float)sinf (0);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	fstp	DWORD PTR _sinR$[ebp]

; 2404 : 						//JAM
; 2405 : 
; 2406 : 						RR2.M11 = cosP;

	movss	xmm0, DWORD PTR _cosP$[ebp]
	movss	DWORD PTR _RR2$[ebp], xmm0

; 2407 : 						RR2.M21 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR2$[ebp+12], xmm0

; 2408 : 						RR2.M31 = -sinP;

	movss	xmm0, DWORD PTR _sinP$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _RR2$[ebp+24], xmm0

; 2409 : 
; 2410 : 						RR2.M12 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR2$[ebp+4], xmm0

; 2411 : 						RR2.M22 = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RR2$[ebp+16], xmm0

; 2412 : 						RR2.M32 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR2$[ebp+28], xmm0

; 2413 : 
; 2414 : 						RR2.M13 = sinP;

	movss	xmm0, DWORD PTR _sinP$[ebp]
	movss	DWORD PTR _RR2$[ebp+8], xmm0

; 2415 : 						RR2.M23 = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _RR2$[ebp+20], xmm0

; 2416 : 						RR2.M33 = cosP;

	movss	xmm0, DWORD PTR _cosP$[ebp]
	movss	DWORD PTR _RR2$[ebp+32], xmm0

; 2417 : 						//Second rotation is doing (-Pitch)
; 2418 : 						point.x = dx * RR2.M11 + dy * RR2.M12 + dz * RR2.M13;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _RR2$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _RR2$[ebp+4]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _RR2$[ebp+8]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp], xmm0

; 2419 : 						point.y = dx * RR2.M21 + dy * RR2.M22 + dz * RR2.M23;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _RR2$[ebp+12]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _RR2$[ebp+16]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _RR2$[ebp+20]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp+4], xmm0

; 2420 : 						point.z = dx * RR2.M31 + dy * RR2.M32 + dz * RR2.M33;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _RR2$[ebp+24]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _RR2$[ebp+28]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _RR2$[ebp+32]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp+8], xmm0

; 2421 : 						dx = point.x; dy = point.y; dz = point.z;

	movss	xmm0, DWORD PTR _point$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR _point$[ebp+4]
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR _point$[ebp+8]
	movss	DWORD PTR _dz$[ebp], xmm0

; 2422 : 
; 2423 : 						if (point.x > 0.0F)     //check to see if entity is in front of us (maybe not needed but anyway...)

	movss	xmm0, DWORD PTR _point$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN2@CanSeeTarg

; 2424 : 						{
; 2425 : 							//One last rotation: (-Roll) this time
; 2426 : 							point.y = dy * cosR - dz * sinR;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _cosR$[ebp]
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _sinR$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp+4], xmm0

; 2427 : 							point.z = dy * sinR + dz * cosR;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _sinR$[ebp]
	movss	xmm1, DWORD PTR _dz$[ebp]
	mulss	xmm1, DWORD PTR _cosR$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _point$[ebp+8], xmm0

; 2428 : 
; 2429 : 							el = (float)atan2(-point.z, (float)sqrt(point.x*point.x+point.y*point.y));

	movss	xmm0, DWORD PTR _point$[ebp]
	mulss	xmm0, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR _point$[ebp+4]
	mulss	xmm1, DWORD PTR _point$[ebp+4]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, -4					; fffffffcH
	fstp	QWORD PTR [esp]
	movss	xmm0, DWORD PTR _point$[ebp+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _el$[ebp]

; 2430 : 							az = (float)atan2(point.y,point.x);

	cvtss2sd xmm0, DWORD PTR _point$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _point$[ebp+4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _az$[ebp]

; 2431 : 							if (fabs(el-g_fReconCameraOffset * DTR) < g_fReconCameraHalfFOV * DTR && fabs(az) < g_fReconCameraHalfFOV * DTR)

	movss	xmm0, DWORD PTR ?g_fReconCameraOffset@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _el$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv572[ebp]
	movss	xmm0, DWORD PTR ?g_fReconCameraHalfFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR tv572[ebp]
	jbe	SHORT $LN2@CanSeeTarg
	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv579[ebp]
	movss	xmm0, DWORD PTR ?g_fReconCameraHalfFOV@@3MA
	mulss	xmm0, DWORD PTR __real@3c8efa34
	comiss	xmm0, DWORD PTR tv579[ebp]
	jbe	SHORT $LN2@CanSeeTarg

; 2432 : 							{
; 2433 : 								retval = entity;

	mov	edx, DWORD PTR _entity$[ebp]
	mov	DWORD PTR _retval$[ebp], edx
$LN2@CanSeeTarg:

; 2434 : 							}
; 2435 : 						}
; 2436 : 					}
; 2437 : 					else // In range and good LOS enough for AI

	jmp	SHORT $LN1@CanSeeTarg
$LN4@CanSeeTarg:

; 2438 : 					{
; 2439 : 						retval = entity;

	mov	eax, DWORD PTR _entity$[ebp]
	mov	DWORD PTR _retval$[ebp], eax
$LN1@CanSeeTarg:

; 2440 : 					}
; 2441 :                 }
; 2442 :         }
; 2443 :         return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 2444 : #endif
; 2445 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CanSeeTarget@HudClass@@QAEPAVVuEntity@@HPAV2@PAVFalconEntity@@@Z ENDP ; HudClass::CanSeeTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv86 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_image$ = 8						; size = 4
?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z PROC	; HudClass::DisplayInit
; _this$ = ecx

; 362  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 363  :    DisplayExit();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 364  : 
; 365  :    privateDisplay = new Render2D;

	push	262840					; 000402b8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@DisplayIni
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Render2D@@QAE@XZ			; Render2D::Render2D
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN4@DisplayIni
$LN3@DisplayIni:
	mov	DWORD PTR tv86[ebp], 0
$LN4@DisplayIni:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+24], eax

; 366  :    ((Render2D*)privateDisplay)->Setup (image);

	mov	ecx, DWORD PTR _image$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+132]
	call	eax

; 367  : 
; 368  :    privateDisplay->SetColor (0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 369  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayInit@HudClass@@UAEXPAVImageBuffer@@@Z ENDP	; HudClass::DisplayInit
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?Display@HudClass@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_D$ = 8							; size = 4
?Display@HudClass@@UAEXPAVVirtualDisplay@@@Z PROC	; HudClass::Display, COMDAT
; _this$ = ecx

; 262  : 	void			Display (VirtualDisplay* D) { Display( D, false); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	eax, DWORD PTR _D$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Display@HudClass@@QAEXPAVVirtualDisplay@@_N@Z ; HudClass::Display
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@HudClass@@UAEXPAVVirtualDisplay@@@Z ENDP	; HudClass::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_rollTrig$ = -272					; size = 8
tv754 = -264						; size = 4
tv652 = -260						; size = 4
tv721 = -256						; size = 4
tv318 = -252						; size = 4
_this$ = -248						; size = 4
_tmpStr$ = -244						; size = 240
__$ArrayPad$ = -4					; size = 4
_newDisplay$ = 8					; size = 4
_gTranslucent$ = 12					; size = 1
?Display@HudClass@@QAEXPAVVirtualDisplay@@_N@Z PROC	; HudClass::Display
; _this$ = ecx

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	char tmpStr[240];
; 376  : 	mlTrig rollTrig;
; 377  : 
; 378  : 	// We must have one to draw...
; 379  : 	ShiAssert( ownship );
; 380  : 
; 381  :    // Various ways to be broken
; 382  :    if (ownship->mFaults &&
; 383  :        (
; 384  :         (ownship->mFaults->GetFault(FaultClass::flcs_fault) & FaultClass::dmux) ||
; 385  :          ownship->mFaults->GetFault(FaultClass::dmux_fault) ||
; 386  :          ownship->mFaults->GetFault(FaultClass::hud_fault)
; 387  :        )
; 388  :       )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx+928], 0
	je	$LN59@Display
	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	and	eax, 16					; 00000010H
	jne	SHORT $LN58@Display
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN58@Display
	push	18					; 00000012H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_FSubSystem@FaultClass@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN59@Display
$LN58@Display:

; 389  :    {
; 390  : 	   //MI still allow STBY reticle for bombing
; 391  : 	   if(FCC->GetSubMode() == FireControlComputer::MAN && WhichMode == 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN57@Display
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5016], 2
	jne	SHORT $LN57@Display

; 392  : 		  DrawMANReticle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMANReticle@HudClass@@QAEXXZ	; HudClass::DrawMANReticle
$LN57@Display:

; 393  :       return;

	jmp	$LN60@Display
$LN59@Display:

; 394  :    }
; 395  :    // JPO - check systems have power
; 396  :    if (!ownship->HasPower(AircraftClass::HUDPower)){

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	jne	SHORT $LN56@Display

; 397  :        return;

	jmp	$LN60@Display
$LN56@Display:

; 398  :    }
; 399  :    display = newDisplay;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newDisplay$[ebp]
	mov	DWORD PTR [edx+28], eax

; 400  : 
; 401  :    // COBRA - RED - ALPHA forced for HUD Display
; 402  :    display->ForceAlpha=gTranslucent;							

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	al, BYTE PTR _gTranslucent$[ebp]
	mov	BYTE PTR [edx+96], al

; 403  :    // Do we draw flashing things this frame?
; 404  :    flash = (vuxRealTime & 0x200);

	mov	ecx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	ecx, 512				; 00000200H
	mov	DWORD PTR ?flash@HudClass@@0HA, ecx	; HudClass::flash

; 405  :    Warnflash = (vuxRealTime & 0x080);

	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	edx, 128				; 00000080H
	mov	DWORD PTR ?Warnflash@HudClass@@0HA, edx	; HudClass::Warnflash

; 406  :    mlSinCos (&rollTrig, cockpitFlightData.roll);

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _rollTrig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 407  :    alphaHudUnits = RadToHudUnitsX(cockpitFlightData.alpha*DTR - cockpitFlightData.windOffset*rollTrig.sin);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+24
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+64
	mulss	xmm1, DWORD PTR _rollTrig$[ebp]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+4856]

; 408  : // 2000-11-10 MODIFIED BY S.G. TO HANDLE THE 'driftCO' switch
; 409  : // if (ownship->OnGround()) {
; 410  :    if (ownship->OnGround() || driftCOSwitch == DRIFT_CO_ON) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN54@Display
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4888], 1
	jne	SHORT $LN55@Display
$LN54@Display:

; 411  : #if 1
; 412  : 	   // With weight on wheels, the jet turns on "drift cutout" to keep the fpm centered on the HUD
; 413  : 	   betaHudUnits = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4860], xmm0

; 414  : #else
; 415  : 	   // While I'm looking for the pitch ladder clipping bug...
; 416  : 	   betaHudUnits = RadToHudUnitsY(cockpitFlightData.beta*DTR + cockpitFlightData.windOffset*rollTrig.cos);
; 417  : #endif
; 418  :    } else {

	jmp	SHORT $LN53@Display
$LN55@Display:

; 419  : 	   betaHudUnits = RadToHudUnitsY(cockpitFlightData.beta*DTR + cockpitFlightData.windOffset*rollTrig.cos);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+28
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+64
	mulss	xmm1, DWORD PTR _rollTrig$[ebp+4]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4860]
$LN53@Display:

; 420  :    }
; 421  : 
; 422  :    //MI
; 423  :    if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	SHORT $LN52@Display

; 424  :    {
; 425  : 	   if(!(WhichMode == 2 && FCC->GetSubMode() == FireControlComputer::MAN))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+5016], 2
	jne	SHORT $LN50@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	je	SHORT $LN49@Display
$LN50@Display:

; 426  : 	   {
; 427  : 		   DrawBoresightCross();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawBoresightCross@HudClass@@AAEXXZ	; HudClass::DrawBoresightCross

; 428  : 		   DrawAirspeed();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirspeed@HudClass@@AAEXXZ		; HudClass::DrawAirspeed

; 429  : 		   DrawAltitude();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAltitude@HudClass@@AAEXXZ		; HudClass::DrawAltitude

; 430  : 		   // Marco Edit
; 431  : 		   if (FCC && FCC->GetMasterMode() !=FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN49@Display
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN49@Display

; 432  : 			   DrawHeading();		// Don't draw heading in Dogfight Mode

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawHeading@HudClass@@AAEXXZ		; HudClass::DrawHeading
$LN49@Display:

; 433  : 	   }
; 434  :    }
; 435  :    else

	jmp	SHORT $LN47@Display
$LN52@Display:

; 436  :    {
; 437  : 	   DrawBoresightCross();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawBoresightCross@HudClass@@AAEXXZ	; HudClass::DrawBoresightCross

; 438  : 	   DrawAirspeed();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirspeed@HudClass@@AAEXXZ		; HudClass::DrawAirspeed

; 439  : 	   DrawAltitude();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAltitude@HudClass@@AAEXXZ		; HudClass::DrawAltitude

; 440  : 	   // Marco Edit
; 441  : 	   if (FCC && FCC->GetMasterMode() !=FireControlComputer::Dogfight)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN47@Display
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN47@Display

; 442  : 		   DrawHeading();		// Don't draw heading in Dogfight Mode

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawHeading@HudClass@@AAEXXZ		; HudClass::DrawHeading
$LN47@Display:

; 443  :    }
; 444  : #if 0	// Turned off to evaluate easy mode HUD clutter level...  SCR 9/18/98
; 445  : #ifdef _DEBUG
; 446  : {
; 447  : int i;
; 448  : int days, hours, minutes;
; 449  : double cur_time;
; 450  : 
; 451  : 	cur_time = SimLibElapsedTime / SEC_TO_MSEC;
; 452  : 	days = FloatToInt32(cur_time / (3600.0F * 24.0F));
; 453  : 	cur_time -= days * 3600.0F * 24.0F;
; 454  : 	hours = FloatToInt32(cur_time / 3600.0F);
; 455  : 	cur_time -= hours * 3600.0F;
; 456  : 	minutes = FloatToInt32(cur_time / 60.0F);
; 457  : 	cur_time -= minutes * 60.0F;
; 458  : 	sprintf (tmpStr, "%3d-%02d:%02d:%05.2f", days, hours, minutes, (float)cur_time);
; 459  :    display->TextRight (0.95F, 0.9F, tmpStr, 0);
; 460  :    ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 461  : 
; 462  : 	sprintf (tmpStr, "T%-4d", HudData.tgtId);
; 463  :    ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 464  : 	display->TextLeft (-0.9F, 0.9F, tmpStr, 0);
; 465  :    sprintf (tmpStr, "C%3d", ownship->Id().num_);
; 466  :    ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 467  : 	display->TextLeft (-0.9F, 0.8F, tmpStr, 0);
; 468  : 
; 469  :    sprintf (tmpStr, "S%3.0f", ownship->af->dbrake*100.0F);
; 470  :    ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 471  :    display->TextLeft (-0.9F, 0.6F, tmpStr, 0);
; 472  : 
; 473  :    for (i=0; i<10; i++)
; 474  :       if (debstr[i][0])
; 475  :          display->TextLeft (-0.8F, 0.8F - 0.1F * i, debstr[i], 0);
; 476  : }
; 477  : #endif
; 478  : #endif
; 479  : 
; 480  : 	if (fpmSwitch == FPM_AUTO)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4868], 3
	jne	SHORT $LN46@Display

; 481  : 	{
; 482  : 		if (fabs(cockpitFlightData.pitch) > 10.0f*DTR) {

	push	ecx
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv652[ebp]
	movss	xmm0, DWORD PTR tv652[ebp]
	comiss	xmm0, DWORD PTR __real@3e32b8c1
	jbe	SHORT $LN45@Display

; 483  : 			DrawPitchLadder();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPitchLadder@HudClass@@AAEXXZ	; HudClass::DrawPitchLadder

; 484  : 		} else {

	jmp	SHORT $LN44@Display
$LN45@Display:

; 485  : 			DrawHorizonLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawHorizonLine@HudClass@@AAEXXZ	; HudClass::DrawHorizonLine
$LN44@Display:

; 486  : 		}

	jmp	SHORT $LN39@Display
$LN46@Display:

; 487  : 	}
; 488  : 	else if ((ownship && ownship->af && ownship->af->gearPos > 0.5F) || (fpmSwitch == ATT_FPM))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN40@Display
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx+932], 0
	je	SHORT $LN40@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	ja	SHORT $LN41@Display
$LN40@Display:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4868], 0
	jne	SHORT $LN39@Display
$LN41@Display:

; 489  : 	{
; 490  : 	if  (FCC && FCC->GetMasterMode() !=FireControlComputer::Dogfight)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN39@Display
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN39@Display

; 491  : 	    DrawPitchLadder();//me123 status ok. don't draw ladders in dogfight mode

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawPitchLadder@HudClass@@AAEXXZ	; HudClass::DrawPitchLadder
$LN39@Display:

; 492  : 	}
; 493  : 
; 494  : 	if (IsSOI())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSOI@DrawableClass@@QAEHXZ		; DrawableClass::IsSOI
	test	eax, eax
	je	$LN36@Display

; 495  : 	{
; 496  : 	    if (g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN37@Display

; 497  : 		display->TextLeft(-0.8F, 0.65F, "*", 0);

	push	0
	push	OFFSET ??_C@_01NBENCBCI@?$CK?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f266666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 498  : 	    else

	jmp	SHORT $LN36@Display
$LN37@Display:

; 499  : 		display->TextLeft(-0.8F, 0.65F, "SOI", 0);

	push	0
	push	OFFSET ??_C@_03FNHOLOBO@SOI?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@3f266666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN36@Display:

; 500  : 	}
; 501  : 
; 502  :    DrawAlphaNumeric();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAlphaNumeric@HudClass@@AAEXXZ	; HudClass::DrawAlphaNumeric

; 503  :    //TJL 03/07/04 Draw Other HUDs 04/17/04 Make non-F16 default to F18 HUD
; 504  :    if (ownship->af->GetTypeAC() == 8 || ownship->af->GetTypeAC() == 9 || ownship->af->GetTypeAC() == 10)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 8
	je	SHORT $LN34@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 9
	je	SHORT $LN34@Display
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN35@Display
$LN34@Display:

; 505  :    {
; 506  : 	   DrawF18HUD();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawF18HUD@HudClass@@AAEXXZ		; HudClass::DrawF18HUD
	jmp	$LN26@Display
$LN35@Display:

; 507  :    }
; 508  :    else if (ownship->af->GetTypeAC() == 6 || ownship->af->GetTypeAC() == 7)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 6
	je	SHORT $LN31@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 7
	jne	SHORT $LN32@Display
$LN31@Display:

; 509  :    {
; 510  : 	   DrawF14HUD();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawF14HUD@HudClass@@AAEXXZ		; HudClass::DrawF14HUD
	jmp	SHORT $LN26@Display
$LN32@Display:

; 511  :    }
; 512  :    else if (ownship->af->GetTypeAC() == 3 || ownship->af->GetTypeAC() == 4 || ownship->af->GetTypeAC() == 5)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 3
	je	SHORT $LN28@Display
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 4
	je	SHORT $LN28@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 5
	jne	SHORT $LN29@Display
$LN28@Display:

; 513  :    {
; 514  : 	   DrawF15HUD();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawF15HUD@HudClass@@AAEXXZ		; HudClass::DrawF15HUD
	jmp	SHORT $LN26@Display
$LN29@Display:

; 515  :    }
; 516  :    else if (ownship->af->GetTypeAC() == 12)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN26@Display

; 517  :    {
; 518  : 	   DrawA10HUD();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawA10HUD@HudClass@@AAEXXZ		; HudClass::DrawA10HUD
$LN26@Display:

; 519  :    }
; 520  : 
; 521  :    if ((!FCC->postDrop || flash) && 
; 522  :        fpmSwitch != FPM_OFF && 
; 523  :        FCC && FCC->GetMasterMode() !=FireControlComputer::Dogfight) // JPO not show in DGFT

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movsx	eax, BYTE PTR [edx+183]
	test	eax, eax
	je	SHORT $LN24@Display
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN25@Display
$LN24@Display:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4868], 2
	je	SHORT $LN25@Display
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN25@Display
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN25@Display

; 524  :       DrawFPM();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawFPM@HudClass@@AAEXXZ		; HudClass::DrawFPM
$LN25@Display:

; 525  : 
; 526  :    switch (FCC->GetMasterMode())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	mov	DWORD PTR tv318[ebp], eax
	cmp	DWORD PTR tv318[ebp], 13		; 0000000dH
	ja	$LN22@Display
	mov	edx, DWORD PTR tv318[ebp]
	jmp	DWORD PTR $LN62@Display[edx*4]
$LN21@Display:

; 527  :    {
; 528  :    case FireControlComputer::AAGun:
; 529  : 	   DrawTDBox();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTDBox@HudClass@@AAEXXZ		; HudClass::DrawTDBox

; 530  : 	   DrawGuns();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGuns@HudClass@@AAEXXZ		; HudClass::DrawGuns

; 531  :        break;

	jmp	$LN22@Display
$LN20@Display:

; 532  :    case FireControlComputer::AGGun:
; 533  : 	   DrawAirGroundGravity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirGroundGravity@HudClass@@AAEXXZ	; HudClass::DrawAirGroundGravity

; 534  :       break;

	jmp	$LN22@Display
$LN19@Display:

; 535  : /*
; 536  :    case FireControlComputer::Gun:
; 537  :        if (FCC->GetSubMode() != FireControlComputer::STRAF) 
; 538  : 	   {
; 539  : 		   DrawTDBox();
; 540  : 		   DrawGuns();
; 541  :        }
; 542  :        else    
; 543  : 	   DrawAirGroundGravity();
; 544  :       break;
; 545  : */
; 546  : 
; 547  :       case FireControlComputer::Dogfight:
; 548  :          DrawDogfight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDogfight@HudClass@@AAEXXZ		; HudClass::DrawDogfight

; 549  :       break;

	jmp	$LN22@Display
$LN18@Display:

; 550  : 
; 551  :       case FireControlComputer::MissileOverride:
; 552  :          DrawMissileOverride();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawMissileOverride@HudClass@@AAEXXZ	; HudClass::DrawMissileOverride

; 553  :       break;

	jmp	$LN22@Display
$LN17@Display:

; 554  : 
; 555  :       case FireControlComputer::Missile:
; 556  :          DrawAirMissile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirMissile@HudClass@@AAEXXZ	; HudClass::DrawAirMissile

; 557  :       break;

	jmp	$LN22@Display
$LN16@Display:

; 558  : 
; 559  :       case FireControlComputer::AirGroundHARM:
; 560  :          DrawHarm();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawHarm@HudClass@@AAEXXZ		; HudClass::DrawHarm

; 561  :       break;

	jmp	$LN22@Display
$LN15@Display:

; 562  : 
; 563  :       case FireControlComputer::AirGroundMissile:
; 564  : 		 DrawGroundMissile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawGroundMissile@HudClass@@AAEXXZ	; HudClass::DrawGroundMissile

; 565  :       break;

	jmp	$LN22@Display
$LN14@Display:

; 566  : 
; 567  :       case FireControlComputer::ILS:
; 568  : 		  DrawILS();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawILS@HudClass@@AAEXXZ		; HudClass::DrawILS

; 569  : 		  //MI
; 570  : 		  if(OTWDriver.pCockpitManager) 

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	SHORT $LN12@Display

; 571  : 		  {
; 572  : 			  if(OTWDriver.pCockpitManager->mpIcp->GetCMDSTR())

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?GetCMDSTR@ICPClass@@QAEHXZ		; ICPClass::GetCMDSTR
	test	eax, eax
	je	SHORT $LN12@Display

; 573  : 				  DrawCMDSTRG();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawCMDSTRG@HudClass@@QAEXXZ		; HudClass::DrawCMDSTRG
$LN12@Display:

; 574  : 		  }
; 575  :       break;

	jmp	SHORT $LN22@Display
$LN11@Display:

; 576  : 
; 577  :       case FireControlComputer::Nav:
; 578  :          DrawNav();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawNav@HudClass@@AAEXXZ		; HudClass::DrawNav

; 579  :       break;

	jmp	SHORT $LN22@Display
$LN10@Display:

; 580  : 
; 581  :       case FireControlComputer::AirGroundBomb:
; 582  :          DrawAirGroundGravity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirGroundGravity@HudClass@@AAEXXZ	; HudClass::DrawAirGroundGravity

; 583  :       break;

	jmp	SHORT $LN22@Display
$LN9@Display:

; 584  : 
; 585  :       case FireControlComputer::AirGroundRocket:
; 586  : 		if(!g_bRealisticAvionics){ // MLR 5/30/2004 - 

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN8@Display

; 587  : 			DrawAirGroundRocket();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirGroundRocket@HudClass@@AAEXXZ	; HudClass::DrawAirGroundRocket

; 588  : 		}
; 589  : 		else {

	jmp	SHORT $LN7@Display
$LN8@Display:

; 590  : 			DrawAirGroundGravity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawAirGroundGravity@HudClass@@AAEXXZ	; HudClass::DrawAirGroundGravity
$LN7@Display:

; 591  : 		}
; 592  :       break;

	jmp	SHORT $LN22@Display
$LN6@Display:

; 593  : 
; 594  :       case FireControlComputer::AirGroundLaser:
; 595  :          DrawTargetingPod();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTargetingPod@HudClass@@AAEXXZ	; HudClass::DrawTargetingPod

; 596  :       break;

	jmp	SHORT $LN22@Display
$LN5@Display:

; 597  : 
; 598  :       case FireControlComputer::AirGroundCamera:
; 599  :          DrawRPod();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawRPod@HudClass@@AAEXXZ		; HudClass::DrawRPod
$LN22@Display:

; 600  :       break;
; 601  :    }
; 602  : 
; 603  :    // Check ground Collision
; 604  :    if (Warnflash && ownship && ownship->mFaults->GetFault(alt_low))

	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	$LN4@Display
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	$LN4@Display
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	$LN4@Display

; 605  :    {
; 606  :       display->AdjustOriginInViewport (0.0F, hudWinY[BORESIGHT_CROSS_WINDOW] +
; 607  :          hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F);

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 608  :       display->AdjustOriginInViewport (0.0F, MISSILE_RETICLE_OFFSET);

	push	ecx
	movss	xmm0, DWORD PTR __real@bdd6774e
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR tv721[ebp]
	movss	xmm0, DWORD PTR tv721[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 609  :       display->Line (0.4F,  0.4F, -0.4F, -0.4F);

	push	ecx
	movss	xmm0, DWORD PTR __real@becccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@becccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 610  :       display->Line (0.4F, -0.4F, -0.4F,  0.4F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@becccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@becccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 611  :       display->AdjustOriginInViewport (0.0F, -MISSILE_RETICLE_OFFSET);

	push	ecx
	movss	xmm0, DWORD PTR __real@bdd6774e
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR tv754[ebp]
	movss	xmm0, DWORD PTR tv754[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 612  :       display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 613  :          hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN4@Display:

; 614  :    }
; 615  : 
; 616  :    //MI removed RPM indication
; 617  :    //M.N. we need RPM indication for Flightmodel testing
; 618  :    if (!g_bNoRPMOnHud/* || !g_bRealisticAvionics*/)

	movzx	ecx, BYTE PTR ?g_bNoRPMOnHud@@3_NA	; g_bNoRPMOnHud
	test	ecx, ecx
	jne	$LN2@Display

; 619  :    {
; 620  : 	   if (ownship)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	$LN2@Display

; 621  : 	   {
; 622  : 		  sprintf (tmpStr, "RPM %3d", FloatToInt32(ownship->af->rpm*100.0F+0.99F));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1212]
	mulss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, DWORD PTR __real@3f7d70a4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_07GMFMKBEK@RPM?5?$CF3d?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 623  : 		  ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 624  : 			  display->TextLeft (-0.9F, -0.75F, tmpStr, 0);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bf400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN2@Display:

; 625  : 	   }
; 626  :    }
; 627  : 
; 628  :    //TJL 11/08/03 HUD Alpha for aircraft with AOA in the HUD
; 629  :    if (!ownship->IsF16() && g_bhudAOA)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	$LN1@Display
	movzx	edx, BYTE PTR ?g_bhudAOA@@3_NA		; g_bhudAOA
	test	edx, edx
	je	$LN1@Display

; 630  :    {
; 631  : 	   //TJL 11/10/03 HUD AOA Greek Letter Alpha
; 632  : 		  display->Line (-0.95F, 0.74F, -0.95F, 0.76F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f428f5c
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 633  : 		  display->Line (-0.95F, 0.76F, -0.93F, 0.78F);      

	push	ecx
	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f428f5c
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 634  : 		  display->Line (-0.93F, 0.78F, -0.91F, 0.78F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf68f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6e147b
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 635  : 		  display->Line (-0.91F, 0.78F, -0.85F, 0.72F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f3851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf59999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf68f5c3
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 636  : 		  display->Line (-0.95F, 0.74F, -0.93F, 0.72F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f3851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3d70a4
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf733333
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 637  : 		  display->Line (-0.93F, 0.72F, -0.91F, 0.72F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f3851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf68f5c3
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6e147b
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 638  : 		  display->Line (-0.91F, 0.72F, -0.85F, 0.78F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf59999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f3851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf68f5c3
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 639  : 
; 640  : 
; 641  : 			//TJL 11/08/03 HUD AOA numbers
; 642  : 			sprintf (tmpStr, "%02.1f", ownship->af->alpha);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	cvtss2sd xmm0, DWORD PTR [edx+1152]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06HGGOEBHK@?$CF02?41f?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 643  : 			ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 644  : 			display->TextLeft (-0.80F, 0.8F, tmpStr, 0);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN1@Display:

; 645  : 	}
; 646  :    //End Alpha
; 647  : 
; 648  : 	//////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
; 649  : 	// COBRA - RED - HACK!!!!!! This forces a Context VB Flush to solve a loss of vertices
; 650  : 	// still have to find why
; 651  : 	/////////////////////////////////////////////////////////////////////////////////////
; 652  : 	
; 653  : 	display->TextCenter (0, 0, "", 0);

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 654  : 	
; 655  : 	// COBRA - RED - END OF HACK !!!! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
; 656  : 
; 657  : 
; 658  :    display->ZeroRotationAboutOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 659  :    display->CenterOriginInViewport();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?CenterOriginInViewport@VirtualDisplay@@QAEXXZ ; VirtualDisplay::CenterOriginInViewport

; 660  : 
; 661  :    // COBRA - RED - ALPHA forced for HUD Display
; 662  :    display->ForceAlpha=gTranslucent=false;							

	mov	BYTE PTR _gTranslucent$[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	dl, BYTE PTR _gTranslucent$[ebp]
	mov	BYTE PTR [ecx+96], dl
$LN60@Display:

; 663  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN62@Display:
	DD	$LN21@Display
	DD	$LN20@Display
	DD	$LN17@Display
	DD	$LN14@Display
	DD	$LN11@Display
	DD	$LN10@Display
	DD	$LN15@Display
	DD	$LN16@Display
	DD	$LN6@Display
	DD	$LN19@Display
	DD	$LN18@Display
	DD	$LN5@Display
	DD	$LN22@Display
	DD	$LN9@Display
?Display@HudClass@@QAEXPAVVirtualDisplay@@_N@Z ENDP	; HudClass::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?GetDisplay@HudClass@@UAEPAVVirtualDisplay@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplay@HudClass@@UAEPAVVirtualDisplay@@XZ PROC	; HudClass::GetDisplay, COMDAT
; _this$ = ecx

; 260  : 	VirtualDisplay*	GetDisplay (void) {return privateDisplay;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@HudClass@@UAEPAVVirtualDisplay@@XZ ENDP	; HudClass::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newAngle$ = 8						; size = 4
_HScale$ = 12						; size = 4
_VScale$ = 16						; size = 4
?SetHalfAngle@HudClass@@QAEXMMM@Z PROC			; HudClass::SetHalfAngle
; _this$ = ecx

; 2097 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2098 :    halfAngle = newAngle;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _newAngle$[ebp]
	movss	DWORD PTR [eax+4836], xmm0

; 2099 :    degreesForScreen = 1.0F / halfAngle;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [ecx+4836]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4840], xmm0

; 2100 :    mVScale=VScale;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _VScale$[ebp]
	movss	DWORD PTR [eax+5184], xmm0

; 2101 :    mHScale=HScale;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _HScale$[ebp]
	movss	DWORD PTR [ecx+5188], xmm0

; 2102 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetHalfAngle@HudClass@@QAEXMMM@Z ENDP			; HudClass::SetHalfAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_xPos$ = 8						; size = 4
_yPos$ = 12						; size = 4
?GetBoresightPos@HudClass@@QAEXPAM0@Z PROC		; HudClass::GetBoresightPos
; _this$ = ecx

; 2091 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2092 :    *xPos = hudWinX[BORESIGHT_CROSS_WINDOW] + hudWinWidth[BORESIGHT_CROSS_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinX@@3PAMA[eax]
	mov	edx, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2093 :    *yPos = hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	mov	edx, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [edx], xmm0

; 2094 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBoresightPos@HudClass@@QAEXPAM0@Z ENDP		; HudClass::GetBoresightPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearTarget@HudClass@@QAEXXZ PROC			; HudClass::ClearTarget
; _this$ = ecx

; 352  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 	if (targetPtr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN2@ClearTarge

; 354  : 		targetPtr->Release(  );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	call	?Release@SimObjectType@@QAEXXZ		; SimObjectType::Release

; 355  : 		targetPtr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 356  : 		targetData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 357  : 		shootCue = 0;//TJL 01/28/04

	mov	BYTE PTR ?shootCue@@3_NA, 0		; shootCue
$LN2@ClearTarge:

; 358  : 	}
; 359  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearTarget@HudClass@@QAEXXZ ENDP			; HudClass::ClearTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTarget$ = 8						; size = 4
?SetTarget@HudClass@@QAEXPAVSimObjectType@@@Z PROC	; HudClass::SetTarget
; _this$ = ecx

; 336  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 337  : 	if (newTarget == targetPtr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTarget$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jne	SHORT $LN2@SetTarget

; 338  : 		return;

	jmp	SHORT $LN3@SetTarget
$LN2@SetTarget:

; 339  : 	
; 340  : 	ClearTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTarget@HudClass@@QAEXXZ		; HudClass::ClearTarget

; 341  : 
; 342  : 	if (newTarget)

	cmp	DWORD PTR _newTarget$[ebp], 0
	je	SHORT $LN3@SetTarget

; 343  : 	{
; 344  : 		ShiAssert( newTarget->BaseData() != (FalconEntity*)0xDDDDDDDD );
; 345  : 		newTarget->Reference(  );

	mov	ecx, DWORD PTR _newTarget$[ebp]
	call	?Reference@SimObjectType@@QAEXXZ	; SimObjectType::Reference

; 346  : 		targetPtr = newTarget;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTarget$[ebp]
	mov	DWORD PTR [edx+40], eax

; 347  : 		targetData = newTarget->localData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newTarget$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+44], eax
$LN3@SetTarget:

; 348  : 	}
; 349  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTarget@HudClass@@QAEXPAVSimObjectType@@@Z ENDP	; HudClass::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_newOwnship$ = 8					; size = 4
?SetOwnship@HudClass@@QAEXPAVAircraftClass@@@Z PROC	; HudClass::SetOwnship
; _this$ = ecx

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 	// Quit now if this is a redundant call
; 295  : 	if (ownship == newOwnship)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _newOwnship$[ebp]
	jne	SHORT $LN9@SetOwnship

; 296  : 		return;

	jmp	$LN10@SetOwnship
$LN9@SetOwnship:

; 297  : 
; 298  : 	// Drop any target we may have had
; 299  : 	ClearTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTarget@HudClass@@QAEXXZ		; HudClass::ClearTarget

; 300  : 
; 301  : 	// Take the new ownship pointer
; 302  : 	ownship = newOwnship;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newOwnship$[ebp]
	mov	DWORD PTR [edx+32], eax

; 303  : 
; 304  : 	// Initialize the gunsight and FCC pointer
; 305  : 	if (newOwnship) {

	cmp	DWORD PTR _newOwnship$[ebp], 0
	je	$LN8@SetOwnship

; 306  : 		FCC = ownship->FCC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+936]
	mov	DWORD PTR [eax+36], ecx

; 307  : 		ShiAssert( FCC );
; 308  : 
; 309  : 		// Reset our history data to something reasonable for this platform.
; 310  : 		// TODO:  Could do a better job here by assuming level flight and calculating a false history...
; 311  : 		int i;
; 312  : 		for (i=0; i<NumEEGSFrames; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@SetOwnship
$LN6@SetOwnship:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN7@SetOwnship:
	cmp	DWORD PTR _i$1[ebp], 146		; 00000092H
	jge	$LN5@SetOwnship

; 313  : 			eegsFrameArray[i].time	= SimLibElapsedTime - (NumEEGSFrames-i);

	mov	eax, 146				; 00000092H
	sub	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, eax
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+736], ecx

; 314  : 			eegsFrameArray[i].x		= newOwnship->XPos();

	mov	ecx, DWORD PTR _newOwnship$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+ecx+740]

; 315  : 			eegsFrameArray[i].y		= newOwnship->YPos();

	mov	ecx, DWORD PTR _newOwnship$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+eax+744]

; 316  : 			eegsFrameArray[i].z		= newOwnship->ZPos();

	mov	ecx, DWORD PTR _newOwnship$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+edx+748]

; 317  : 			eegsFrameArray[i].vx	= 0.0f;

	mov	ecx, DWORD PTR _i$1[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx+752], xmm0

; 318  : 			eegsFrameArray[i].vy	= 0.0f;

	mov	eax, DWORD PTR _i$1[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax+756], xmm0

; 319  : 			eegsFrameArray[i].vz	= 0.0f;

	mov	edx, DWORD PTR _i$1[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx+760], xmm0

; 320  : 		}

	jmp	$LN6@SetOwnship
$LN5@SetOwnship:

; 321  : 		for (i=0; i<NumEEGSSegments; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SetOwnship
$LN3@SetOwnship:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@SetOwnship:
	cmp	DWORD PTR _i$1[ebp], 24			; 00000018H
	jge	SHORT $LN2@SetOwnship

; 322  : 			funnel1X[i] = 0.0f;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx*4+352], xmm0

; 323  : 			funnel1Y[i] = 0.0f;

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+ecx*4+448], xmm0

; 324  : 			funnel2X[i] = 0.0f;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+eax*4+544], xmm0

; 325  : 			funnel2Y[i] = 0.0f;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+edx*4+640], xmm0

; 326  : 		}

	jmp	SHORT $LN3@SetOwnship
$LN2@SetOwnship:
	jmp	SHORT $LN1@SetOwnship
$LN8@SetOwnship:

; 327  : 	} else {
; 328  : 		FCC = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
$LN1@SetOwnship:

; 329  : 	}
; 330  : 
; 331  : 	eegsFrameNum = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4824], 0

; 332  : 	lastEEGSstepTime = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4828], 0
$LN10@SetOwnship:

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetOwnship@HudClass@@QAEXPAVAircraftClass@@@Z ENDP	; HudClass::SetOwnship
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HudClass@@UAE@XZ PROC				; HudClass::~HudClass
; _this$ = ecx

; 288  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1HudClass@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HudClass@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 289  : 	ClearTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearTarget@HudClass@@QAEXXZ		; HudClass::ClearTarget

; 290  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DrawableClass@@UAE@XZ		; DrawableClass::~DrawableClass
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1HudClass@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DrawableClass@@UAE@XZ		; DrawableClass::~DrawableClass
__ehhandler$??1HudClass@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1HudClass@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HudClass@@UAE@XZ ENDP				; HudClass::~HudClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv247 = -24						; size = 4
tv241 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0HudClass@@QAE@XZ PROC				; HudClass::HudClass
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HudClass@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DrawableClass@@IAE@XZ		; DrawableClass::DrawableClass
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HudClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4972				; 0000136cH
	call	??0HudDataType@@QAE@XZ			; HudDataType::HudDataType

; 179  :    headingPos      = Low;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4964], 1

; 180  :    ownship         = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 181  :    HudData.tgtId   = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4996], -1

; 182  :    // RV - Biker
; 183  :    //lowAltWarning   = 10.0F;//Cobra this thing is soo annoying on takeoff.  From 300 to 10
; 184  :    lowAltWarning   = 300.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [ecx+4960], xmm0

; 185  :    maxGs           = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4832], xmm0

; 186  : 
; 187  : 	 SetHalfAngle((float)atan (0.25F * tan(30.0F * DTR)) * RTD);	//MI halfangle is degrees

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f060a91
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR tv247[ebp]
	movss	xmm0, DWORD PTR tv247[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHalfAngle@HudClass@@QAEXMMM@Z	; HudClass::SetHalfAngle

; 188  :    waypointX = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+4908], xmm0

; 189  :    waypointY = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4912], xmm0

; 190  :    waypointZ = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4916], xmm0

; 191  :    waypointRange = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+4944], xmm0

; 192  :    waypointArrival = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4936], xmm0

; 193  :    waypointBearing = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4940], xmm0

; 194  :    waypointRange = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+4944], xmm0

; 195  :    waypointAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4920], xmm0

; 196  :    waypointEl = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4924], xmm0

; 197  :    waypointValid = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4952], 0

; 198  :    //curRwy = NULL;
; 199  :    curRwy = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 200  : 
; 201  :    	SetScalesSwitch( VAH );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetScalesSwitch@HudClass@@QAEXW4ScalesSwitch@1@@Z ; HudClass::SetScalesSwitch

; 202  : 	SetFPMSwitch( ATT_FPM );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFPMSwitch@HudClass@@QAEXW4FPMSwitch@1@@Z ; HudClass::SetFPMSwitch

; 203  : 	SetVelocitySwitch( CAS );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVelocitySwitch@HudClass@@QAEXW4VelocitySwitch@1@@Z ; HudClass::SetVelocitySwitch

; 204  : 
; 205  : 	dedSwitch = DED_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4872], 1

; 206  : 	radarSwitch = RADAR_AUTO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4880], 2

; 207  : 	brightnessSwitch = DAY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4884], 1

; 208  : 	display = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 209  : 	curColorIdx = 0;

	mov	DWORD PTR ?curColorIdx@@3HA, 0		; curColorIdx

; 210  : 	curHudColor = 0xff00ff00;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4892], -16711936		; ff00ff00H

; 211  : 	SetHudColor(HUDcolor[curColorIdx]);

	mov	ecx, DWORD PTR ?curColorIdx@@3HA	; curColorIdx
	mov	edx, DWORD PTR _HUDcolor[ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHudColor@HudClass@@QAEXK@Z		; HudClass::SetHudColor

; 212  :   //SYM Wheel
; 213  :   SymWheelPos = 1.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+5136], xmm0

; 214  :   ContWheelPos=0.5f;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [ecx+5140], xmm0

; 215  : 	SetLightLevel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLightLevel@HudClass@@QAEXXZ		; HudClass::SetLightLevel

; 216  : 	targetPtr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 217  : 	targetData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 218  : 	eegsFrameNum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4824], 0

; 219  : 	lastEEGSstepTime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4828], 0

; 220  :    pixelXCenter = 320.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43a00000
	movss	DWORD PTR [eax+4844], xmm0

; 221  :    pixelYCenter = 240.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@43700000
	movss	DWORD PTR [ecx+4848], xmm0

; 222  : // 2000-11-10 ADDED BY S.G. FOR THE Drift C/O switch
; 223  :    driftCOSwitch = DRIFT_CO_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4888], 0

; 224  : // END OF ADDED SECTION
; 225  :    //MI MSLFloor stuff
; 226  :    MSLFloor = 10000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5008], 10000		; 00002710H

; 227  :    if(-cockpitFlightData.z >= MSLFloor)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+5008]
	comiss	xmm0, xmm1
	jb	SHORT $LN4@HudClass

; 228  : 	   WasAboveMSLFloor = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5004], 1

; 229  :    else

	jmp	SHORT $LN3@HudClass
$LN4@HudClass:

; 230  : 	   WasAboveMSLFloor = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5004], 0
$LN3@HudClass:

; 231  :    TFAdv = 400;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5012], 400		; 00000190H

; 232  :    DefaultTargetSpan = 35.0f;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@420c0000
	movss	DWORD PTR [edx+5020], xmm0

; 233  :    WhichMode = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5016], 0

; 234  :    OA1Az = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+5024], xmm0

; 235  :    OA1Elev = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+5028], xmm0

; 236  :    OA1Valid = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5040], 0

; 237  :    OA2Az = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+5032], xmm0

; 238  :    OA2Elev = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+5036], xmm0

; 239  :    OA2Valid = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5041], 0

; 240  :    VIPAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+5044], xmm0

; 241  :    VIPElev = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+5048], xmm0

; 242  :    VIPValid = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5052], 0

; 243  :    VRPAz = 0.0F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+5056], xmm0

; 244  :    VRPElev = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+5060], xmm0

; 245  :    VRPValid = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5064], 0

; 246  :    CalcRoll = CalcBank = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5093], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5092], 1

; 247  :    //added check for font so PW's pit looks good too
; 248  :    if(OTWDriver.pCockpitManager->HudFont() == 1)

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	call	?HudFont@CockpitManager@@QAEHXZ		; CockpitManager::HudFont
	cmp	eax, 1
	jne	SHORT $LN2@HudClass

; 249  :    {
; 250  : 	   YRALTText = -0.17F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [eax+5088], xmm0

; 251  : 	   YALText = -0.24F;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@be75c28f
	movss	DWORD PTR [ecx+5084], xmm0

; 252  :    }
; 253  :    else

	jmp	SHORT $LN1@HudClass
$LN2@HudClass:

; 254  :    {
; 255  : 	   YRALTText = -0.16F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@be23d70a
	movss	DWORD PTR [edx+5088], xmm0

; 256  : 	   YALText = -0.25F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [eax+5084], xmm0
$LN1@HudClass:

; 257  :    }
; 258  :    //MI check when to hide the funnel
; 259  :    HideFunnel = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5104], 0

; 260  :    HideFunnelTimer = SimLibElapsedTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+5096], eax

; 261  :    ShowFunnelTimer = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+5100], edx

; 262  :    SetHideTimer = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5105], 0

; 263  :    SetShowTimer = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5106], 0

; 264  : 
; 265  :    SlantRange = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+5132], xmm0

; 266  :    RET_CENTER = hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+5120], xmm0

; 267  :    ReticlePosition = 0;	//for the wheel

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5128], 0

; 268  :    RetPos = 0;	//controls where to move it

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5124], 0

; 269  : 
; 270  :    sprintf(SpeedText, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5107				; 000013f3H
	push	edx
	call	_sprintf
	add	esp, 8

; 271  :    //MI init
; 272  :    shootCue = 0;//TJL 01/28/04

	mov	BYTE PTR ?shootCue@@3_NA, 0		; shootCue

; 273  :    fpmConstrained = false; //TJL 03/11/04Made this accessible

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5144], 0

; 274  :    hudDelayTimer = SimLibElapsedTime;//Cobra

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+5152], edx

; 275  :    hudAltDelayTimer = SimLibElapsedTime;//Cobra

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+5156], ecx

; 276  :    hudRAltDelayTimer = SimLibElapsedTime;//Cobra

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+5160], eax

; 277  :    aspeedHud= 0;//Cobra

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+5164], 0

; 278  :    altHud=0.0f;//Cobra

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+5168], xmm0

; 279  :    altHudn=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+5172], xmm0

; 280  :    raltHud=0.0f;//Cobra

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+5176], xmm0

; 281  :    vvid=0;//Cobra

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+5180], 0

; 282  :    HudBrightness=1.0f;		// COBRA - RED -

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+4896], xmm0

; 283  :    AutoHudCx=0.0f;			// COBRA - RED -

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+4904], xmm0

; 284  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0HudClass@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DrawableClass@@UAE@XZ		; DrawableClass::~DrawableClass
__ehhandler$??0HudClass@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HudClass@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HudClass@@QAE@XZ ENDP				; HudClass::HudClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_discriminant$ = -80					; size = 8
_drSquared$ = -72					; size = 8
_D$ = -64						; size = 8
tv232 = -56						; size = 4
tv227 = -52						; size = 4
tv187 = -48						; size = 4
tv182 = -44						; size = 4
_y1$ = -40						; size = 4
_x2$ = -36						; size = 4
_y2$ = -32						; size = 4
_x1$ = -28						; size = 4
_dy$ = -24						; size = 4
_dx$ = -20						; size = 4
_vertOffset$ = -16					; size = 4
_horizOffset$ = -12					; size = 4
_this$ = -8						; size = 4
_ghostHorizonDrawn$ = -1				; size = 1
_radius$ = 8						; size = 4
_xOffset$ = 12						; size = 4
_yOffset$ = 16						; size = 4
_horizX1$ = 20						; size = 4
_horizY1$ = 24						; size = 4
_horizX2$ = 28						; size = 4
_horizY2$ = 32						; size = 4
?CheckGhostHorizon@HudClass@@AAE_NMMMMMMM@Z PROC	; HudClass::CheckGhostHorizon
; _this$ = ecx

; 2001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 2002 : 	bool ghostHorizonDrawn = false;

	mov	BYTE PTR _ghostHorizonDrawn$[ebp], 0

; 2003 : 
; 2004 : 	//Ghost horizon only drawn if HUD fixes are used and we're on realistic avionics.
; 2005 : 	if((g_bHUDFix == false) || !(g_bRealisticAvionics))

	movzx	eax, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	test	eax, eax
	je	SHORT $LN2@CheckGhost
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN3@CheckGhost
$LN2@CheckGhost:

; 2006 : 	{
; 2007 : 		return ghostHorizonDrawn;

	mov	al, BYTE PTR _ghostHorizonDrawn$[ebp]
	jmp	$LN4@CheckGhost
$LN3@CheckGhost:

; 2008 : 	}
; 2009 : 
; 2010 : 	//This function decides whether the normal horizon line should be drawn (true) or the
; 2011 : 	//ghost horizon (false). It works by determining whether the normal horizon line
; 2012 : 	//intersects the circle around which the ghost horizon would be drawn. If it intersects,
; 2013 : 	//the horizon is visible in the HUD. If it doesn't, the ghost horizon needs to be 
; 2014 : 	//drawn. A bit of a pain in the arse, but it's the only way to be sure this works
; 2015 : 	//for all possible cases.
; 2016 : 
; 2017 : 	//Points at either end of horizon line. These need to be corrected because origin is 
; 2018 : 	//first offset to boresight cross, then offset to FPM position relative to that. However,
; 2019 : 	//offset needed depends on the roll angle, so we need to correct for that, too.
; 2020 : 	float horizOffset = sinf(-ownship->GetMu()) * (-xOffset);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+436]
	call	eax
	fstp	DWORD PTR tv182[ebp]
	movss	xmm0, DWORD PTR tv182[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	fstp	DWORD PTR tv187[ebp]
	movss	xmm0, DWORD PTR tv187[ebp]
	movss	xmm1, DWORD PTR _xOffset$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, xmm1
	movss	DWORD PTR _horizOffset$[ebp], xmm0

; 2021 : 	float vertOffset = cosf(-ownship->GetMu()) * (-yOffset - (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2022 :       hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+436]
	call	eax
	fstp	DWORD PTR tv227[ebp]
	movss	xmm0, DWORD PTR tv227[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	movss	xmm1, DWORD PTR _yOffset$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm2, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm2, DWORD PTR ?hudWinY@@3PAMA[ecx]
	subss	xmm1, xmm2
	mulss	xmm0, xmm1
	movss	DWORD PTR _vertOffset$[ebp], xmm0

; 2023 : 
; 2024 : 	float x1 = horizX1 - horizOffset;

	movss	xmm0, DWORD PTR _horizX1$[ebp]
	subss	xmm0, DWORD PTR _horizOffset$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 2025 : 	float y1 = horizY1 - vertOffset; 

	movss	xmm0, DWORD PTR _horizY1$[ebp]
	subss	xmm0, DWORD PTR _vertOffset$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2026 : 	float x2 = horizX2 - horizOffset; 

	movss	xmm0, DWORD PTR _horizX2$[ebp]
	subss	xmm0, DWORD PTR _horizOffset$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2027 : 	float y2 = horizY2 - vertOffset;

	movss	xmm0, DWORD PTR _horizY2$[ebp]
	subss	xmm0, DWORD PTR _vertOffset$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2028 : 
; 2029 : 	/* //Only enabled if debugging needed...
; 2030 : 	//Draw some stuff that's useful for eyeballing whether this actually works or not.
; 2031 : 	display->Circle(horizOffset, vertOffset, radius);
; 2032 : 	display->Line(horizOffset, vertOffset, horizOffset, vertOffset + 2);
; 2033 : 	display->Line(horizOffset, vertOffset, horizOffset, vertOffset - 2);
; 2034 : 	display->Line(horizOffset, vertOffset, horizOffset + 2, vertOffset);
; 2035 : 	display->Line(horizOffset, vertOffset, horizOffset - 2, vertOffset);
; 2036 : 	*/
; 2037 : 
; 2038 : 	//Intersection check.
; 2039 : 	float dx = x2 - x1;

	movss	xmm0, DWORD PTR _x2$[ebp]
	subss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2040 : 	float dy = y2 - y1;

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2041 : 	double drSquared = (dx * dx) + (dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _drSquared$[ebp], xmm0

; 2042 : 	double D  = (x1 * y2) - (x2 * y1);

	movss	xmm0, DWORD PTR _x1$[ebp]
	mulss	xmm0, DWORD PTR _y2$[ebp]
	movss	xmm1, DWORD PTR _x2$[ebp]
	mulss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _D$[ebp], xmm0

; 2043 : 
; 2044 : 	double discriminant = (radius * radius) * drSquared - (D * D);

	movss	xmm0, DWORD PTR _radius$[ebp]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR _drSquared$[ebp]
	movsd	xmm1, QWORD PTR _D$[ebp]
	mulsd	xmm1, QWORD PTR _D$[ebp]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _discriminant$[ebp], xmm0

; 2045 : 
; 2046 : 	//If discriminant is less than zero, the horizon line didn't intersect the circle, so
; 2047 : 	//the ghost horizon line must be drawn.
; 2048 : 	if (discriminant < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _discriminant$[ebp]
	jbe	SHORT $LN1@CheckGhost

; 2049 : 	{
; 2050 : 		ghostHorizonDrawn = true;

	mov	BYTE PTR _ghostHorizonDrawn$[ebp], 1
$LN1@CheckGhost:

; 2051 : 	}
; 2052 : 	return (ghostHorizonDrawn);

	mov	al, BYTE PTR _ghostHorizonDrawn$[ebp]
$LN4@CheckGhost:

; 2053 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?CheckGhostHorizon@HudClass@@AAE_NMMMMMMM@Z ENDP	; HudClass::CheckGhostHorizon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_retval$ = -12						; size = 4
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_hudUnits$ = 8						; size = 4
?HudUnitsToRad@HudClass@@AAEMM@Z PROC			; HudClass::HudUnitsToRad
; _this$ = ecx

; 2083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2084 : 	float retval;
; 2085 : 
; 2086 : 	retval = (float)atan (hudUnits * tan (halfAngle * DTR));

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4836]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv77[ebp]
	movss	xmm0, DWORD PTR tv77[ebp]
	mulss	xmm0, DWORD PTR _hudUnits$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR _retval$[ebp]

; 2087 : 	return (retval);

	fld	DWORD PTR _retval$[ebp]

; 2088 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HudUnitsToRad@HudClass@@AAEMM@Z ENDP			; HudClass::HudUnitsToRad
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?RadToHudUnitsY@HudClass@@AAEMM@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_mr$ = 8						; size = 4
?RadToHudUnitsY@HudClass@@AAEMM@Z PROC			; HudClass::RadToHudUnitsY, COMDAT
; _this$ = ecx

; 220  : 	float	RadToHudUnitsY (float mr)	{ return RadToHudUnits(mr) * mVScale; };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _mr$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR tv75[ebp]
	movss	xmm0, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+5184]
	movss	DWORD PTR tv78[ebp], xmm0
	fld	DWORD PTR tv78[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?RadToHudUnitsY@HudClass@@AAEMM@Z ENDP			; HudClass::RadToHudUnitsY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?RadToHudUnitsX@HudClass@@AAEMM@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_mr$ = 8						; size = 4
?RadToHudUnitsX@HudClass@@AAEMM@Z PROC			; HudClass::RadToHudUnitsX, COMDAT
; _this$ = ecx

; 219  : 	float	RadToHudUnitsX (float mr)	{ return RadToHudUnits(mr) * mHScale; };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _mr$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnits@HudClass@@AAEMM@Z	; HudClass::RadToHudUnits
	fstp	DWORD PTR tv75[ebp]
	movss	xmm0, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+5188]
	movss	DWORD PTR tv78[ebp], xmm0
	fld	DWORD PTR tv78[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?RadToHudUnitsX@HudClass@@AAEMM@Z ENDP			; HudClass::RadToHudUnitsX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv132 = -20						; size = 4
tv136 = -16						; size = 4
tv93 = -12						; size = 4
_retval$ = -8						; size = 4
_this$ = -4						; size = 4
_rad$ = 8						; size = 4
?RadToHudUnits@HudClass@@AAEMM@Z PROC			; HudClass::RadToHudUnits
; _this$ = ecx

; 2069 : float HudClass::RadToHudUnits (float rad){

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2070 : 	float retval;
; 2071 : 
; 2072 : 	if(rad > 2.0F * halfAngle * DTR){

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR [eax+4836]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _rad$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@RadToHudUn

; 2073 : 		//retval = 2.0F;
; 2074 : 		retval = (float)(rad/(halfAngle * DTR));

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4836]
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	xmm1, DWORD PTR _rad$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _retval$[ebp], xmm1

; 2075 : 	}
; 2076 : 	else{

	jmp	SHORT $LN1@RadToHudUn
$LN2@RadToHudUn:

; 2077 : 		retval = (float)(tan(rad) / tan (halfAngle * DTR));

	push	ecx
	movss	xmm0, DWORD PTR _rad$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv93[ebp]
	movss	xmm0, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4836]
	mulss	xmm1, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv136[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv132[ebp]
	movss	xmm0, DWORD PTR tv136[ebp]
	divss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _retval$[ebp], xmm0
$LN1@RadToHudUn:

; 2078 : 	}
; 2079 : 	return retval;

	fld	DWORD PTR _retval$[ebp]

; 2080 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RadToHudUnits@HudClass@@AAEMM@Z ENDP			; HudClass::RadToHudUnits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv95 = -20						; size = 4
tv131 = -16						; size = 4
tv88 = -12						; size = 4
_retval$ = -8						; size = 4
_this$ = -4						; size = 4
_mr$ = 8						; size = 4
?MRToHudUnits@HudClass@@AAEMM@Z PROC			; HudClass::MRToHudUnits
; _this$ = ecx

; 2055 : float HudClass::MRToHudUnits (float mr){

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2056 : 	float retval;
; 2057 : 
; 2058 :    if(mr * 0.001F > 2.0F * halfAngle * DTR)

	movss	xmm0, DWORD PTR _mr$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR [eax+4836]
	mulss	xmm1, DWORD PTR __real@3c8efa34
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@MRToHudUni

; 2059 :    {
; 2060 :       retval = 2.0F;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _retval$[ebp], xmm0

; 2061 :    }
; 2062 :    else

	jmp	SHORT $LN1@MRToHudUni
$LN2@MRToHudUni:

; 2063 :    {
; 2064 :       retval = (float)(tan(mr * 0.001F) / tan (halfAngle * DTR));

	movss	xmm0, DWORD PTR _mr$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv88[ebp]
	movss	xmm0, DWORD PTR tv88[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4836]
	mulss	xmm1, DWORD PTR __real@3c8efa34
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv131[ebp], xmm0
	call	?tan@@YAMM@Z				; tan
	add	esp, 4
	fstp	DWORD PTR tv95[ebp]
	movss	xmm0, DWORD PTR tv131[ebp]
	divss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR _retval$[ebp], xmm0
$LN1@MRToHudUni:

; 2065 :    }
; 2066 :    return (retval);

	fld	DWORD PTR _retval$[ebp]

; 2067 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MRToHudUnits@HudClass@@AAEMM@Z ENDP			; HudClass::MRToHudUnits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_width$ = -20						; size = 4
_y$ = -16						; size = 4
_height$ = -12						; size = 4
_x$ = -8						; size = 4
_this$ = -4						; size = 4
_window$ = 8						; size = 4
_str$ = 12						; size = 4
_boxed$ = 16						; size = 4
?DrawWindowString@HudClass@@AAEXHPADH@Z PROC		; HudClass::DrawWindowString
; _this$ = ecx

; 1331 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1332 : float x, y, width, height;
; 1333 : 
; 1334 :    window --;

	mov	eax, DWORD PTR _window$[ebp]
	sub	eax, 1
	mov	DWORD PTR _window$[ebp], eax

; 1335 : 
; 1336 :    x = hudWinX[window];

	mov	ecx, DWORD PTR _window$[ebp]
	movss	xmm0, DWORD PTR ?hudWinX@@3PAMA[ecx*4]
	movss	DWORD PTR _x$[ebp], xmm0

; 1337 :    y = hudWinY[window];

	mov	edx, DWORD PTR _window$[ebp]
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx*4]
	movss	DWORD PTR _y$[ebp], xmm0

; 1338 :    width = hudWinWidth[window];

	mov	eax, DWORD PTR _window$[ebp]
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax*4]
	movss	DWORD PTR _width$[ebp], xmm0

; 1339 :    height = hudWinHeight[window];

	mov	ecx, DWORD PTR _window$[ebp]
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[ecx*4]
	movss	DWORD PTR _height$[ebp], xmm0

; 1340 : 
; 1341 :    if (x > 0.01F)

	movss	xmm0, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN4@DrawWindow

; 1342 :       display->TextRight (x + width, y + height * 0.5F, str, boxed);

	mov	edx, DWORD PTR _boxed$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	jmp	$LN1@DrawWindow
$LN4@DrawWindow:

; 1343 :    else if (x < -0.01F)

	movss	xmm0, DWORD PTR __real@bc23d70a
	comiss	xmm0, DWORD PTR _x$[ebp]
	jbe	SHORT $LN2@DrawWindow

; 1344 :       display->TextLeft (x, y + height * 0.5F, str, boxed);

	mov	ecx, DWORD PTR _boxed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	movss	xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 1345 :    else

	jmp	SHORT $LN1@DrawWindow
$LN2@DrawWindow:

; 1346 :       display->TextCenter (x, y + height * 0.5F, str, boxed );

	mov	eax, DWORD PTR _boxed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN1@DrawWindow:

; 1347 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DrawWindowString@HudClass@@AAEXHPADH@Z ENDP		; HudClass::DrawWindowString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawA10HUD@HudClass@@AAEXXZ PROC			; HudClass::DrawA10HUD
; _this$ = ecx

; 2793 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2794 : 
; 2795 : 	//
; 2796 : 
; 2797 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawA10HUD@HudClass@@AAEXXZ ENDP			; HudClass::DrawA10HUD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_vvi$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawF15HUD@HudClass@@AAEXXZ PROC			; HudClass::DrawF15HUD
; _this$ = ecx

; 2724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2725 : 	headingPos = High;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4964], 0

; 2726 : 	g_bhudAOA = 0;

	mov	BYTE PTR ?g_bhudAOA@@3_NA, 0		; g_bhudAOA

; 2727 : 
; 2728 :    //TJL 03/07/04 VVI #45
; 2729 : 	//Cobra.  Let's fix this to increment by 10 and add in the delay factor
; 2730 :    int vvi =  (((FloatToInt32(-cockpitFlightData.zDot*60))+ 5) / 10) * 10;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _vvi$[ebp], eax

; 2731 :    if (vuxRealTime & 0x040)

	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	edx, 64					; 00000040H
	je	SHORT $LN6@DrawF15HUD

; 2732 : 	   vvid=vvi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vvi$[ebp]
	mov	DWORD PTR [eax+5180], ecx
$LN6@DrawF15HUD:

; 2733 : 
; 2734 :    sprintf (tmpStr, "%d", vvid );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5180]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2735 :    ShiAssert (strlen(tmpStr) < 40);
; 2736 :    DrawWindowString (51, tmpStr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	push	51					; 00000033H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 2737 : 
; 2738 :    //AOA 46
; 2739 :    //HUD AOA Greek Letter Alpha -65 X -13 Y
; 2740 : 
; 2741 : 	display->Line (-0.92F, 0.05F, -0.92F, 0.07F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d8f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6b851f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6b851f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2742 : 	display->Line (-0.92F, 0.07F, -0.90F, 0.09F);      

	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d8f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6b851f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2743 : 	display->Line (-0.90F, 0.09F, -0.88F, 0.09F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2744 : 	display->Line (-0.88F, 0.09F, -0.82F, 0.03F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf51eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6147ae
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2745 : 	display->Line (-0.92F, 0.05F, -0.90F, 0.03F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6b851f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2746 : 	display->Line (-0.90F, 0.03F, -0.88F, 0.03F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf666666
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2747 : 	display->Line (-0.88F, 0.03F, -0.82F, 0.09F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf51eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf6147ae
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2748 : 
; 2749 : 	//TJL 11/08/03 HUD AOA numbers
; 2750 : 	sprintf (tmpStr, "%02.1f", ownship->af->alpha);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	cvtss2sd xmm0, DWORD PTR [edx+1152]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06HGGOEBHK@?$CF02?41f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2751 : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 2752 : 	DrawWindowString (52, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	push	52					; 00000034H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 2753 :    
; 2754 :    //Mach 47
; 2755 :    if (ownship->af->gearPos < 0.5F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [ecx+1552]
	jbe	SHORT $LN5@DrawF15HUD

; 2756 :    {
; 2757 : 	sprintf (tmpStr, "M %.2f", cockpitFlightData.mach);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+48
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06BNGHLEKI@M?5?$CF?42f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2758 : 	ShiAssert (strlen(tmpStr) < 40);
; 2759 : 	DrawWindowString (48, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN5@DrawF15HUD:

; 2760 :    }
; 2761 : 
; 2762 :    //G 48
; 2763 :    if (ownship->af->gearPos < 0.5F || (ownship->af->gearPos > 0.5 && maxGs > 4.0f))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [eax+1552]
	ja	SHORT $LN3@DrawF15HUD
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	cvtss2sd xmm0, DWORD PTR [eax+1552]
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jbe	SHORT $LN4@DrawF15HUD
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4832]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN4@DrawF15HUD
$LN3@DrawF15HUD:

; 2764 :    {
; 2765 : 	sprintf (tmpStr, "G %.1f", cockpitFlightData.gs);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06LLFBFFLP@G?5?$CF?41f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2766 : 	ShiAssert (strlen(tmpStr) < 40);
; 2767 : 	DrawWindowString (49, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN4@DrawF15HUD:

; 2768 :    }
; 2769 : 
; 2770 :    //G-Max 49
; 2771 :    if (cockpitFlightData.gs > 4.0F && cockpitFlightData.gs > maxGs)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN2@DrawF15HUD
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR [ecx+4832]
	jbe	SHORT $LN2@DrawF15HUD

; 2772 :    {
; 2773 : 	maxGs = cockpitFlightData.gs;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [edx+4832], xmm0
$LN2@DrawF15HUD:

; 2774 :    }
; 2775 :    
; 2776 :    if (maxGs > 4.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4832]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN1@DrawF15HUD

; 2777 :    {
; 2778 : 	sprintf (tmpStr, "%.1f", maxGs);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+4832]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2779 : 	DrawWindowString (50, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN1@DrawF15HUD:

; 2780 :    }
; 2781 : 
; 2782 : 	//True Airspeed
; 2783 : 
; 2784 : 	sprintf (tmpStr, "T %d", FloatToInt32(cockpitFlightData.vt * FTPSEC_TO_KNOTS));

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+56
	mulss	xmm0, DWORD PTR __real@3f17ac60
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_04GLGLOEHP@T?5?$CFd?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2785 : 	ShiAssert (strlen(tmpStr) < 40);
; 2786 : 	DrawWindowString (53, tmpStr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	push	53					; 00000035H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 2787 :          
; 2788 :       
; 2789 : 
; 2790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawF15HUD@HudClass@@AAEXXZ ENDP			; HudClass::DrawF15HUD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv561 = -12						; size = 4
_vvi$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawF14HUD@HudClass@@AAEXXZ PROC			; HudClass::DrawF14HUD
; _this$ = ecx

; 2635 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2636 : 	headingPos = High;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4964], 0

; 2637 : 	g_bhudAOA = 0;

	mov	BYTE PTR ?g_bhudAOA@@3_NA, 0		; g_bhudAOA

; 2638 : 
; 2639 :    //TJL 03/07/04 VVI #45
; 2640 : 	//Cobra.  Let's fix this to increment by 10 and add in the delay factor
; 2641 :    int vvi =  (((FloatToInt32(-cockpitFlightData.zDot*60))+ 5) / 10) * 10;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _vvi$[ebp], eax

; 2642 :    if (vuxRealTime & 0x040)

	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	edx, 64					; 00000040H
	je	SHORT $LN15@DrawF14HUD

; 2643 : 	   vvid=vvi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vvi$[ebp]
	mov	DWORD PTR [eax+5180], ecx
$LN15@DrawF14HUD:

; 2644 : 
; 2645 :    sprintf (tmpStr, "%d", vvid );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5180]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2646 :    ShiAssert (strlen(tmpStr) < 40);
; 2647 :    DrawWindowString (51, tmpStr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	push	51					; 00000033H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 2648 : 
; 2649 :    //AOA 46
; 2650 :    //HUD AOA Greek Letter Alpha -65 X -13 Y
; 2651 :    if (ownship->af->gearPos < 0.5F || (ownship->af->gearPos > 0.5F && 
; 2652 : 	   (ownship->af->alpha > 17.0F || ownship->af->alpha < 13.0F)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [edx+1552]
	ja	SHORT $LN12@DrawF14HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN14@DrawF14HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1152]
	comiss	xmm0, DWORD PTR __real@41880000
	ja	SHORT $LN12@DrawF14HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@41500000
	comiss	xmm0, DWORD PTR [edx+1152]
	jbe	$LN14@DrawF14HUD
$LN12@DrawF14HUD:

; 2653 :    {
; 2654 : 
; 2655 : 	display->Line (-0.80F, -0.13F, -0.80F, -0.15F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be051eb8
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2656 : 	display->Line (-0.80F, -0.15F, -0.78F, -0.17F);      

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2657 : 	display->Line (-0.78F, -0.17F, -0.76F, -0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2658 : 	display->Line (-0.76F, -0.17F, -0.70F, -0.11F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2659 : 	display->Line (-0.80F, -0.13F, -0.78F, -0.11F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be051eb8
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2660 : 	display->Line (-0.78F, -0.11F, -0.76F, -0.11F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2661 : 	display->Line (-0.76F, -0.11F, -0.70F, -0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2662 : 	
; 2663 : 
; 2664 : 	//TJL 11/08/03 HUD AOA numbers
; 2665 : 	sprintf (tmpStr, "%02.1f", ownship->af->alpha);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	cvtss2sd xmm0, DWORD PTR [edx+1152]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06HGGOEBHK@?$CF02?41f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2666 : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 2667 : 	DrawWindowString (47, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN14@DrawF14HUD:

; 2668 :    }
; 2669 :    
; 2670 :    //Mach 47
; 2671 :    if (ownship->af->gearPos < 0.5F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [ecx+1552]
	jbe	SHORT $LN11@DrawF14HUD

; 2672 :    {
; 2673 : 	sprintf (tmpStr, "M %.2f", cockpitFlightData.mach);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+48
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06BNGHLEKI@M?5?$CF?42f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2674 : 	ShiAssert (strlen(tmpStr) < 40);
; 2675 : 	DrawWindowString (48, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN11@DrawF14HUD:

; 2676 :    }
; 2677 : 
; 2678 :    //G 48
; 2679 :    if (ownship->af->gearPos < 0.5F || (ownship->af->gearPos > 0.5 && maxGs > 4.0f))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [eax+1552]
	ja	SHORT $LN9@DrawF14HUD
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	cvtss2sd xmm0, DWORD PTR [eax+1552]
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jbe	SHORT $LN10@DrawF14HUD
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4832]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN10@DrawF14HUD
$LN9@DrawF14HUD:

; 2680 :    {
; 2681 : 	sprintf (tmpStr, "G %.1f", cockpitFlightData.gs);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06LLFBFFLP@G?5?$CF?41f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2682 : 	ShiAssert (strlen(tmpStr) < 40);
; 2683 : 	DrawWindowString (49, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN10@DrawF14HUD:

; 2684 :    }
; 2685 : 
; 2686 :    //G-Max 49
; 2687 :    if (cockpitFlightData.gs > 4.0F && cockpitFlightData.gs > maxGs)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN8@DrawF14HUD
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR [ecx+4832]
	jbe	SHORT $LN8@DrawF14HUD

; 2688 :    {
; 2689 : 	maxGs = cockpitFlightData.gs;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [edx+4832], xmm0
$LN8@DrawF14HUD:

; 2690 :    }
; 2691 :    
; 2692 :    if (maxGs > 4.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4832]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN7@DrawF14HUD

; 2693 :    {
; 2694 : 	sprintf (tmpStr, "%.1f", maxGs);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+4832]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2695 : 	DrawWindowString (50, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN7@DrawF14HUD:

; 2696 :    }
; 2697 : 
; 2698 : 	  //TJL 03/06/04 F-14 Specific HUD warning per -1
; 2699 :    
; 2700 :    if ((ownship->af->tefPos > 0.0f || ownship->af->lefPos > 0.0f) && 
; 2701 : 		   ownship->GetKias() > 225.0f && flash)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1580]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN5@DrawF14HUD
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1576]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@DrawF14HUD
$LN5@DrawF14HUD:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv561[ebp]
	movss	xmm0, DWORD PTR tv561[ebp]
	comiss	xmm0, DWORD PTR __real@43610000
	jbe	SHORT $LN6@DrawF14HUD
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN6@DrawF14HUD

; 2702 : 	   {
; 2703 : 			DrawWindowString (12, "RDC SPEED");

	push	0
	push	OFFSET ??_C@_09LGMCLHNC@RDC?5SPEED?$AA@
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
	jmp	SHORT $LN3@DrawF14HUD
$LN6@DrawF14HUD:

; 2704 : 	   }
; 2705 :    else if (ownship->af->mach > 2.4f && flash)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1144]
	comiss	xmm0, DWORD PTR __real@4019999a
	jbe	SHORT $LN3@DrawF14HUD
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN3@DrawF14HUD

; 2706 : 	   {
; 2707 : 		   DrawWindowString (12, "RDC SPEED");

	push	0
	push	OFFSET ??_C@_09LGMCLHNC@RDC?5SPEED?$AA@
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN3@DrawF14HUD:

; 2708 : 	   }
; 2709 : 
; 2710 :    //Waterline
; 2711 :    if (fpmConstrained || ownship->af->gearPos > 0.5)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5144]
	test	edx, edx
	jne	SHORT $LN1@DrawF14HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	cvtss2sd xmm0, DWORD PTR [edx+1552]
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jbe	$LN2@DrawF14HUD
$LN1@DrawF14HUD:

; 2712 :    {
; 2713 : 	display->Line (-0.09F, 0.6F, -0.05F, 0.6F);      

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2714 : 	display->Line (-0.05F, 0.6F, -0.03F, 0.57F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bcf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2715 : 	display->Line (-0.03F, 0.57F, 0.0F, 0.6F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bcf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2716 : 	display->Line (0.0F, 0.6F, 0.03F, 0.57F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2717 : 	display->Line (0.03F, 0.57F, 0.05F, 0.6F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2718 : 	display->Line (0.05F, 0.6F, 0.09F, 0.6F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN2@DrawF14HUD:

; 2719 :    }
; 2720 : 
; 2721 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawF14HUD@HudClass@@AAEXXZ ENDP			; HudClass::DrawF14HUD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_vvi$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawF18HUD@HudClass@@AAEXXZ PROC			; HudClass::DrawF18HUD
; _this$ = ecx

; 2559 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2560 : 	headingPos = High;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4964], 0

; 2561 : 	g_bhudAOA = 0;

	mov	BYTE PTR ?g_bhudAOA@@3_NA, 0		; g_bhudAOA

; 2562 : 
; 2563 :    //TJL 03/07/04 VVI #45
; 2564 : 	//Cobra.  Let's fix this to increment by 10 and add in the delay factor
; 2565 :    int vvi =  (((FloatToInt32(-cockpitFlightData.zDot*60))+ 5) / 10) * 10;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+20
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 5
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _vvi$[ebp], eax

; 2566 :    if (vuxRealTime & 0x040)

	mov	edx, DWORD PTR ?vuxRealTime@@3KA	; vuxRealTime
	and	edx, 64					; 00000040H
	je	SHORT $LN11@DrawF18HUD

; 2567 : 	   vvid=vvi;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vvi$[ebp]
	mov	DWORD PTR [eax+5180], ecx
$LN11@DrawF18HUD:

; 2568 : 
; 2569 :    sprintf (tmpStr, "%d", vvid );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5180]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2570 :    ShiAssert (strlen(tmpStr) < 40);
; 2571 :    DrawWindowString (46, tmpStr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	push	46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 2572 : 
; 2573 :    //AOA 46
; 2574 :    //HUD AOA Greek Letter Alpha -65 X -13 Y
; 2575 :    if (ownship->af->gearPos < 0.5F || (ownship->af->gearPos > 0.5F && 
; 2576 : 	   (ownship->af->alpha > 10.0F || ownship->af->alpha < 6.0F)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [edx+1552]
	ja	SHORT $LN8@DrawF18HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN10@DrawF18HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1152]
	comiss	xmm0, DWORD PTR __real@41200000
	ja	SHORT $LN8@DrawF18HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@40c00000
	comiss	xmm0, DWORD PTR [edx+1152]
	jbe	$LN10@DrawF18HUD
$LN8@DrawF18HUD:

; 2577 :    {
; 2578 : 
; 2579 : 	display->Line (-0.80F, -0.13F, -0.80F, -0.15F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be051eb8
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2580 : 	display->Line (-0.80F, -0.15F, -0.78F, -0.17F);      

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2581 : 	display->Line (-0.78F, -0.17F, -0.76F, -0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2582 : 	display->Line (-0.76F, -0.17F, -0.70F, -0.11F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2583 : 	display->Line (-0.80F, -0.13F, -0.78F, -0.11F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be051eb8
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2584 : 	display->Line (-0.78F, -0.11F, -0.76F, -0.11F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf47ae14
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2585 : 	display->Line (-0.76F, -0.11F, -0.70F, -0.17F);

	push	ecx
	movss	xmm0, DWORD PTR __real@be2e147b
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bde147ae
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf428f5c
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2586 : 
; 2587 : 	//TJL 11/08/03 HUD AOA numbers
; 2588 : 	sprintf (tmpStr, "%02.1f", ownship->af->alpha);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	cvtss2sd xmm0, DWORD PTR [edx+1152]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06HGGOEBHK@?$CF02?41f?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2589 : 	ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 2590 : 	DrawWindowString (47, tmpStr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5065				; 000013c9H
	push	ecx
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN10@DrawF18HUD:

; 2591 :    }
; 2592 :    
; 2593 :    //Mach 47
; 2594 :    if (ownship->af->gearPos < 0.5F)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [ecx+1552]
	jbe	SHORT $LN7@DrawF18HUD

; 2595 :    {
; 2596 : 	sprintf (tmpStr, "M %.2f", cockpitFlightData.mach);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+48
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06BNGHLEKI@M?5?$CF?42f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2597 : 	ShiAssert (strlen(tmpStr) < 40);
; 2598 : 	DrawWindowString (48, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN7@DrawF18HUD:

; 2599 :    }
; 2600 : 
; 2601 :    //G 48
; 2602 :    if (ownship->af->gearPos < 0.5F || (ownship->af->gearPos > 0.5 && maxGs > 4.0f))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [eax+1552]
	ja	SHORT $LN5@DrawF18HUD
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+932]
	cvtss2sd xmm0, DWORD PTR [eax+1552]
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jbe	SHORT $LN6@DrawF18HUD
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4832]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN6@DrawF18HUD
$LN5@DrawF18HUD:

; 2603 :    {
; 2604 : 	sprintf (tmpStr, "G %.1f", cockpitFlightData.gs);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06LLFBFFLP@G?5?$CF?41f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2605 : 	ShiAssert (strlen(tmpStr) < 40);
; 2606 : 	DrawWindowString (49, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN6@DrawF18HUD:

; 2607 :    }
; 2608 : 
; 2609 :    //G-Max 49
; 2610 :    if (cockpitFlightData.gs > 4.0F && cockpitFlightData.gs > maxGs)

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN4@DrawF18HUD
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR [ecx+4832]
	jbe	SHORT $LN4@DrawF18HUD

; 2611 :    {
; 2612 : 	maxGs = cockpitFlightData.gs;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [edx+4832], xmm0
$LN4@DrawF18HUD:

; 2613 :    }
; 2614 :    
; 2615 :    if (maxGs > 4.0F)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4832]
	comiss	xmm0, DWORD PTR __real@40800000
	jbe	SHORT $LN3@DrawF18HUD

; 2616 :    {
; 2617 : 	sprintf (tmpStr, "%.1f", maxGs);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+4832]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 5065				; 000013c9H
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2618 : 	DrawWindowString (50, tmpStr);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 5065				; 000013c9H
	push	eax
	push	50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN3@DrawF18HUD:

; 2619 :    }
; 2620 : 
; 2621 :    //Waterline
; 2622 :    if (fpmConstrained || ownship->af->gearPos > 0.5)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5144]
	test	edx, edx
	jne	SHORT $LN1@DrawF18HUD
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	cvtss2sd xmm0, DWORD PTR [edx+1552]
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jbe	$LN2@DrawF18HUD
$LN1@DrawF18HUD:

; 2623 :    {
; 2624 : 	display->Line (-0.09F, 0.6F, -0.05F, 0.6F);      

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bdb851ec
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2625 : 	display->Line (-0.05F, 0.6F, -0.03F, 0.57F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bcf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2626 : 	display->Line (-0.03F, 0.57F, 0.0F, 0.6F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bcf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2627 : 	display->Line (0.0F, 0.6F, 0.03F, 0.57F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2628 : 	display->Line (0.03F, 0.57F, 0.05F, 0.6F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f11eb85
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2629 : 	display->Line (0.05F, 0.6F, 0.09F, 0.6F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3db851ec
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN2@DrawF18HUD:

; 2630 :    }
; 2631 : 
; 2632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawF18HUD@HudClass@@AAEXXZ ENDP			; HudClass::DrawF18HUD
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_trig$ = -76						; size = 8
tv409 = -68						; size = 4
tv276 = -64						; size = 4
tv269 = -60						; size = 4
tv399 = -56						; size = 4
tv379 = -52						; size = 4
tv390 = -48						; size = 4
tv283 = -44						; size = 4
tv385 = -40						; size = 4
tv293 = -36						; size = 4
_offset$ = -32						; size = 4
_yPos$ = -28						; size = 4
_xPos$ = -24						; size = 4
_this$ = -20						; size = 4
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_shape$ = 8						; size = 4
_az$ = 12						; size = 4
_el$ = 16						; size = 4
_dRoll$ = 20						; size = 4
?DrawDesignateMarker@HudClass@@AAEXW4DesignateShape@1@MMM@Z PROC ; HudClass::DrawDesignateMarker
; _this$ = ecx

; 1486 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1487 : float xPos, yPos;
; 1488 : char tmpStr[12];
; 1489 : mlTrig trig;
; 1490 : float offset = MRToHudUnits(45.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MRToHudUnits@HudClass@@AAEMM@Z		; HudClass::MRToHudUnits
	fstp	DWORD PTR _offset$[ebp]

; 1491 : 
; 1492 : 	xPos = RadToHudUnitsX(az);

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 1493 : 	yPos = RadToHudUnitsY(el);

	push	ecx
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 1494 : 
; 1495 :    if (fabs (az) < 90.0F * DTR &&
; 1496 :        fabs (el) < 90.0F * DTR &&
; 1497 :        fabs (xPos) < 0.90F && fabs(yPos + hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1498 :          hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F) < 0.90F)

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv269[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv269[ebp]
	jbe	$LN5@DrawDesign
	push	ecx
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv276[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv276[ebp]
	jbe	$LN5@DrawDesign
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv283[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR tv283[ebp]
	jbe	$LN5@DrawDesign
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[eax]
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm1, DWORD PTR ?hudWinHeight@@3PAMA[ecx]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv293[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR tv293[ebp]
	jbe	$LN5@DrawDesign

; 1499 :    {
; 1500 :       if (shape == Square)

	cmp	DWORD PTR _shape$[ebp], 1
	jne	$LN4@DrawDesign

; 1501 :       {
; 1502 :          display->AdjustOriginInViewport(xPos, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1503 :          display->Line (-0.05F, -0.05F, -0.05F,  0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1504 :          display->Line (-0.05F, -0.05F,  0.05F, -0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1505 :          display->Line ( 0.05F,  0.05F, -0.05F,  0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1506 :          display->Line ( 0.05F,  0.05F,  0.05F, -0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@bd4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1507 :          display->AdjustOriginInViewport(-xPos, -yPos);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
	jmp	SHORT $LN2@DrawDesign
$LN4@DrawDesign:

; 1508 :       }
; 1509 :       else if (shape == Circle)

	cmp	DWORD PTR _shape$[ebp], 0
	jne	SHORT $LN2@DrawDesign

; 1510 :       {
; 1511 :          display->Circle (xPos, yPos, 0.05F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+48]
	call	eax
$LN2@DrawDesign:

; 1512 :       }
; 1513 :    }
; 1514 :    else

	jmp	$LN1@DrawDesign
$LN5@DrawDesign:

; 1515 :    {
; 1516 :       mlSinCos (&trig, dRoll);

	push	ecx
	movss	xmm0, DWORD PTR _dRoll$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 1517 :       xPos = offset * trig.sin;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 1518 :       yPos = offset * trig.cos;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _yPos$[ebp], xmm0

; 1519 :       display->Line (0.0f, 0.0f, xPos, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1520 :       sprintf (tmpStr, "%.0f", (float)acos (cos (az) * cos (el)) * RTD);

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv379[ebp]
	movss	xmm0, DWORD PTR tv379[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _el$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv409[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv385[ebp]
	movss	xmm0, DWORD PTR tv409[ebp]
	mulss	xmm0, DWORD PTR tv385[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?acos@@YAMM@Z				; acos
	add	esp, 4
	fstp	DWORD PTR tv390[ebp]
	movss	xmm0, DWORD PTR tv390[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1521 :       ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 1522 :       display->TextRight(-0.075F, display->TextHeight()*0.5F, tmpStr, 0);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+88]
	call	edx
	fstp	DWORD PTR tv399[ebp]
	movss	xmm0, DWORD PTR tv399[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd99999a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+60]
	call	edx
$LN1@DrawDesign:

; 1523 :    }
; 1524 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DrawDesignateMarker@HudClass@@AAEXW4DesignateShape@1@MMM@Z ENDP ; HudClass::DrawDesignateMarker
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_playerAC$ = -412					; size = 4
_ofont$ = -408						; size = 4
$T1 = -404						; size = 4
$T2 = -400						; size = 4
tv769 = -396						; size = 4
$T3 = -392						; size = 4
$T4 = -388						; size = 4
$T5 = -384						; size = 4
tv871 = -380						; size = 4
tv136 = -376						; size = 4
_mach$6 = -372						; size = 4
_yPos$7 = -368						; size = 4
_j$8 = -364						; size = 4
_i$9 = -360						; size = 4
_this$ = -356						; size = 4
_line2$10 = -352					; size = 40
_line3$11 = -312					; size = 40
_line1$12 = -272					; size = 40
_line3$13 = -232					; size = 27
_line5$14 = -204					; size = 27
_line2$15 = -176					; size = 27
_line4$16 = -148					; size = 27
_line1$17 = -120					; size = 27
_tempstr$18 = -92					; size = 15
_tmpStr$ = -76						; size = 40
_tempstr$19 = -36					; size = 20
_tempstr$20 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?DrawAlphaNumeric@HudClass@@AAEXXZ PROC			; HudClass::DrawAlphaNumeric
; _this$ = ecx

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 971  : 	//MI not here in BUP reticle mode
; 972  : 	if(g_bRealisticAvionics && WhichMode == 2 && FCC->GetSubMode() == FireControlComputer::MAN)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN124@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+5016], 2
	jne	SHORT $LN124@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN124@DrawAlphaN

; 973  : 		return;

	jmp	$LN125@DrawAlphaN
$LN124@DrawAlphaN:

; 974  : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 975  : 	char tmpStr[40];
; 976  : 
; 977  :    // Window 3 (Master Arm / ILS)
; 978  : 	//TJL 03/07/04 F16 specific or default HUD
; 979  :    if (PlayerOptions.GetAvionicsType() != ATEasy && (ownship->IsF16() || ownship->af->GetTypeAC() == 0)) {

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	$LN118@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN122@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN118@DrawAlphaN
$LN122@DrawAlphaN:

; 980  : 	   if (FCC && FCC->GetMasterMode() == FireControlComputer::ILS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN121@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 3
	jne	SHORT $LN121@DrawAlphaN

; 981  : 		  DrawWindowString (3, "ILS");

	push	0
	push	OFFSET ??_C@_03NALBENGH@ILS?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
	jmp	$LN118@DrawAlphaN
$LN121@DrawAlphaN:

; 982  : 	   else switch (ownship->Sms->MasterArm())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+940]
	call	?MasterArm@SMSBaseClass@@QAE?AW4MasterArmState@1@XZ ; SMSBaseClass::MasterArm
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 0
	je	SHORT $LN117@DrawAlphaN
	cmp	DWORD PTR tv136[ebp], 1
	je	SHORT $LN114@DrawAlphaN
	cmp	DWORD PTR tv136[ebp], 2
	je	SHORT $LN115@DrawAlphaN
	jmp	SHORT $LN118@DrawAlphaN
$LN117@DrawAlphaN:

; 983  :       {
; 984  :          case SMSBaseClass::Safe:
; 985  : 			 //MI not here in real
; 986  : 			 if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN116@DrawAlphaN

; 987  : 				 DrawWindowString (3, "SAF");

	push	0
	push	OFFSET ??_C@_03NAHIIPNL@SAF?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN116@DrawAlphaN:

; 988  :          break;

	jmp	SHORT $LN118@DrawAlphaN
$LN115@DrawAlphaN:

; 989  : 
; 990  :          case SMSBaseClass::Arm:
; 991  :             DrawWindowString (3, "ARM");

	push	0
	push	OFFSET ??_C@_03NHPMNECN@ARM?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 992  :          break;

	jmp	SHORT $LN118@DrawAlphaN
$LN114@DrawAlphaN:

; 993  : 
; 994  :          case SMSBaseClass::Sim:
; 995  :             DrawWindowString (3, "SIM");

	push	0
	push	OFFSET ??_C@_03DNJPAHKI@SIM?$AA@
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN118@DrawAlphaN:

; 996  :          break;
; 997  :       }
; 998  :    }
; 999  : 
; 1000 :    // Window 4 (Mach Number)
; 1001 :    //TJL 03/07/04 F16 specific or default HUD
; 1002 :    if (ownship->IsF16() || ownship->af->GetTypeAC() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN112@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN110@DrawAlphaN
$LN112@DrawAlphaN:

; 1003 :    {
; 1004 : 	float mach =  cockpitFlightData.mach;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+48
	movss	DWORD PTR _mach$6[ebp], xmm0

; 1005 : 	if (mach < 0.1f)

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _mach$6[ebp]
	jbe	SHORT $LN111@DrawAlphaN

; 1006 : 		mach = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _mach$6[ebp], xmm0
$LN111@DrawAlphaN:

; 1007 : 	sprintf (tmpStr, "%.2f", mach);

	cvtss2sd xmm0, DWORD PTR _mach$6[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GEFJINEE@?$CF?42f?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1008 : 	ShiAssert (strlen(tmpStr) < 40);
; 1009 : 	if (FCC && FCC->GetMasterMode() !=FireControlComputer::Dogfight)  //JPG 29 Apr 04 - Not here in DF override

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN110@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN110@DrawAlphaN

; 1010 : 	{
; 1011 : 		DrawWindowString (4, tmpStr);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN110@DrawAlphaN:

; 1012 : 	}
; 1013 :    }
; 1014 : 
; 1015 :    // Window 5 (Gs)
; 1016 :    //MI (JPO - fixed elsewhere !)
; 1017 :    //TJL 03/07/04 F16 specific or default HUD
; 1018 :    if (ownship->IsF16() || ownship->af->GetTypeAC() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN108@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	SHORT $LN109@DrawAlphaN
$LN108@DrawAlphaN:

; 1019 :    {
; 1020 : 	sprintf (tmpStr, "%.1f", cockpitFlightData.gs);

	cvtss2sd xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1021 : 	ShiAssert (strlen(tmpStr) < 40);
; 1022 : 	DrawWindowString (5, tmpStr);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN109@DrawAlphaN:

; 1023 :    }
; 1024 : 	//TJL 03/07/04 F16 specific or default HUD
; 1025 :    if (PlayerOptions.GetAvionicsType() != ATEasy && (ownship->IsF16() || ownship->af->GetTypeAC() == 0)) 

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	$LN87@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN106@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN87@DrawAlphaN
$LN106@DrawAlphaN:

; 1026 :    {
; 1027 : 	   //MI changed for INS stuff
; 1028 : 	   if(g_bINS && g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	edx, edx
	je	$LN105@DrawAlphaN
	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	$LN105@DrawAlphaN

; 1029 : 	   {
; 1030 : 		   if(!ownship->INSState(AircraftClass::INS_Aligned) &&
; 1031 : 			   ownship->INSState(AircraftClass::INS_AlignNorm) && (cockpitFlightData.kias <= 1.0F
; 1032 : 			   && !ownship->INS60kts) || ownship->INSState(AircraftClass::INS_AlignFlight))

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN101@DrawAlphaN
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN101@DrawAlphaN
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	jb	SHORT $LN101@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movzx	edx, BYTE PTR [ecx+800]
	test	edx, edx
	je	SHORT $LN103@DrawAlphaN
$LN101@DrawAlphaN:
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN104@DrawAlphaN
$LN103@DrawAlphaN:

; 1033 : 		   {
; 1034 : 			   sprintf(tmpStr,"ALIGN");

	push	OFFSET ??_C@_05OKAJNMKE@ALIGN?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 1035 : 		   }
; 1036 : 		   else if(ownship->INSState(AircraftClass::INS_Aligned) &&

	jmp	$LN93@DrawAlphaN
$LN104@DrawAlphaN:

; 1037 : 			   ownship->INSState(AircraftClass::INS_AlignNorm) && cockpitFlightData.kias <= 1.0F
; 1038 : 			   && !ownship->INS60kts || ownship->INSState(AircraftClass::INS_AlignFlight))

	push	64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN97@DrawAlphaN
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN97@DrawAlphaN
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+52
	jb	SHORT $LN97@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	movzx	eax, BYTE PTR [edx+800]
	test	eax, eax
	je	SHORT $LN98@DrawAlphaN
$LN97@DrawAlphaN:
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	SHORT $LN99@DrawAlphaN
$LN98@DrawAlphaN:

; 1039 : 		   {
; 1040 : 			   if(flash)

	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN96@DrawAlphaN

; 1041 : 				   sprintf(tmpStr, "ALIGN");

	push	OFFSET ??_C@_05OKAJNMKE@ALIGN?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 1042 : 			   else

	jmp	SHORT $LN95@DrawAlphaN
$LN96@DrawAlphaN:

; 1043 : 			   {
; 1044 : 				   if (cockpitFlightData.gs > maxGs)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR [eax+4832]
	jbe	SHORT $LN94@DrawAlphaN

; 1045 : 					   maxGs = cockpitFlightData.gs;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [ecx+4832], xmm0
$LN94@DrawAlphaN:

; 1046 : 				 sprintf (tmpStr, "%.1f", maxGs);

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+4832]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN95@DrawAlphaN:

; 1047 : 			   }
; 1048 : 		   }
; 1049 : 		   else

	jmp	SHORT $LN93@DrawAlphaN
$LN99@DrawAlphaN:

; 1050 : 		   {
; 1051 : 			   if (cockpitFlightData.gs > maxGs)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR [ecx+4832]
	jbe	SHORT $LN92@DrawAlphaN

; 1052 : 				   maxGs = cockpitFlightData.gs;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [edx+4832], xmm0
$LN92@DrawAlphaN:

; 1053 : 			   sprintf (tmpStr, "%.1f", maxGs);

	mov	eax, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4832]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN93@DrawAlphaN:

; 1054 : 		   }

	jmp	SHORT $LN90@DrawAlphaN
$LN105@DrawAlphaN:

; 1055 : 	   }
; 1056 : 	   else if (ownship->IsF16() || ownship->af->GetTypeAC() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN89@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	SHORT $LN90@DrawAlphaN
$LN89@DrawAlphaN:

; 1057 : 	   {
; 1058 : 		   // Window 7 (Max Gs)
; 1059 : 		   if (cockpitFlightData.gs > maxGs)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	comiss	xmm0, DWORD PTR [edx+4832]
	jbe	SHORT $LN88@DrawAlphaN

; 1060 : 			   maxGs = cockpitFlightData.gs;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+60
	movss	DWORD PTR [eax+4832], xmm0
$LN88@DrawAlphaN:

; 1061 : 		   sprintf (tmpStr, "%.1f", maxGs);

	mov	ecx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+4832]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GGBPDDBN@?$CF?41f?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN90@DrawAlphaN:

; 1062 : 	   }
; 1063 : 	   ShiAssert (strlen(tmpStr) < 40);
; 1064 : 	   if (FCC && FCC->GetMasterMode() !=FireControlComputer::Dogfight)  //JPG 29 Apr 04 - Not here in DF override

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN87@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	je	SHORT $LN87@DrawAlphaN

; 1065 : 	   {
; 1066 : 			DrawWindowString (7, tmpStr);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN87@DrawAlphaN:

; 1067 : 	   }
; 1068 :    }
; 1069 : 
; 1070 :    // Window 8 (Master/Sub Mode)
; 1071 :    if (ownship->Sms->drawable && ownship->Sms->drawable->DisplayMode() == SmsDrawable::SelJet)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+160], 0
	je	SHORT $LN86@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+940]
	mov	ecx, DWORD PTR [edx+160]
	call	?DisplayMode@SmsDrawable@@QAE?AW4SmsDisplayMode@1@XZ ; SmsDrawable::DisplayMode
	cmp	eax, 3
	jne	SHORT $LN86@DrawAlphaN

; 1072 :       DrawWindowString (8, "JETT");

	push	0
	push	OFFSET ??_C@_04DCDGPODJ@JETT?$AA@
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
	jmp	$LN84@DrawAlphaN
$LN86@DrawAlphaN:

; 1073 :    //TJL F16 specific or default HUD
; 1074 :    else if (ownship->IsF16() || ownship->af->GetTypeAC() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN83@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN84@DrawAlphaN
$LN83@DrawAlphaN:

; 1075 :    {
; 1076 : 	   //MI
; 1077 : 	   if(!g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	SHORT $LN82@DrawAlphaN

; 1078 : 	   {
; 1079 : 		   if (ownship->Sms->NumCurrentWpn() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+940]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	test	eax, eax
	jle	SHORT $LN81@DrawAlphaN

; 1080 : 			   sprintf (tmpStr, "%d %s", ownship->Sms->NumCurrentWpn(), FCC->subModeString);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, 400				; 00000190H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+940]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	push	eax
	push	OFFSET ??_C@_05OPEIBKFE@?$CFd?5?$CFs?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1081 : 		   else

	jmp	SHORT $LN80@DrawAlphaN
$LN81@DrawAlphaN:

; 1082 : 			   sprintf (tmpStr, "%s", FCC->subModeString);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 400				; 00000190H
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN80@DrawAlphaN:

; 1083 : 	   }
; 1084 : 	   else

	jmp	$LN69@DrawAlphaN
$LN82@DrawAlphaN:

; 1085 : 	   {
; 1086 : 		   if(FCC && FCC->IsAGMasterMode())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	$LN78@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?IsAGMasterMode@FireControlComputer@@QAEHXZ ; FireControlComputer::IsAGMasterMode
	test	eax, eax
	je	$LN78@DrawAlphaN

; 1087 : 		   {
; 1088 : 			   if(ownship->Sms && ownship->Sms->curWeaponType == wtAgm65)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx+940], 0
	je	SHORT $LN77@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+148], 4
	jne	SHORT $LN77@DrawAlphaN

; 1089 : 			   {
; 1090 : 				   if(ownship->Sms->MavSubMode == SMSBaseClass::PRE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN76@DrawAlphaN

; 1091 : 					   sprintf(tmpStr,"PRE");

	push	OFFSET ??_C@_03PHIAGONP@PRE?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN73@DrawAlphaN
$LN76@DrawAlphaN:

; 1092 : 				   else if(ownship->Sms->MavSubMode == SMSBaseClass::VIS)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+940]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN74@DrawAlphaN

; 1093 : 					   sprintf(tmpStr, "VIS");

	push	OFFSET ??_C@_03NOAAMIEF@VIS?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 1094 : 				   else

	jmp	SHORT $LN73@DrawAlphaN
$LN74@DrawAlphaN:

; 1095 : 					   sprintf(tmpStr,"BORE");

	push	OFFSET ??_C@_04DKKPAKDO@BORE?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN73@DrawAlphaN:

; 1096 : 			   }
; 1097 : 			   else

	jmp	SHORT $LN72@DrawAlphaN
$LN77@DrawAlphaN:

; 1098 : 				   sprintf (tmpStr, "%s", FCC->subModeString);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, 400				; 00000190H
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN72@DrawAlphaN:

; 1099 : 		   }
; 1100 : 		   else

	jmp	SHORT $LN69@DrawAlphaN
$LN78@DrawAlphaN:

; 1101 : 		   {
; 1102 : 			   if (ownship->Sms->NumCurrentWpn() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+940]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	test	eax, eax
	jle	SHORT $LN70@DrawAlphaN

; 1103 : 				   sprintf (tmpStr, "%d %s", ownship->Sms->NumCurrentWpn(), FCC->subModeString);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 400				; 00000190H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+940]
	call	?NumCurrentWpn@SMSBaseClass@@QAEHXZ	; SMSBaseClass::NumCurrentWpn
	push	eax
	push	OFFSET ??_C@_05OPEIBKFE@?$CFd?5?$CFs?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1104 : 			   else

	jmp	SHORT $LN69@DrawAlphaN
$LN70@DrawAlphaN:

; 1105 : 				   sprintf (tmpStr, "%s", FCC->subModeString);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 400				; 00000190H
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN69@DrawAlphaN:

; 1106 : 		   }
; 1107 : 	   }
; 1108 : 	   
; 1109 : 	   DrawWindowString (8, tmpStr);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN84@DrawAlphaN:

; 1110 :    }
; 1111 : 
; 1112 :    // Window 10 (Range)
; 1113 :    // Done in missile or gun mode section
; 1114 : 
; 1115 :    // Window 11 (Master Caution)
; 1116 :    //MI Warn reset is correct
; 1117 :    int ofont = display->CurFont();

	call	?CurFont@VirtualDisplay@@SAHXZ		; VirtualDisplay::CurFont
	mov	DWORD PTR _ofont$[ebp], eax

; 1118 :    display->SetFont(3);

	push	3
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 1119 :    if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN68@DrawAlphaN

; 1120 :    {
; 1121 : 	   if (ownship->mFaults->MasterCaution() && flash)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?MasterCaution@FackClass@@QAEHXZ	; FackClass::MasterCaution
	test	eax, eax
	je	SHORT $LN67@DrawAlphaN
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN67@DrawAlphaN

; 1122 : 	   {
; 1123 : 		   DrawWindowString (11, "WARN");

	push	0
	push	OFFSET ??_C@_04JBIELMDE@WARN?$AA@
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN67@DrawAlphaN:

; 1124 : 	   }
; 1125 :    }
; 1126 :    else

	jmp	$LN64@DrawAlphaN
$LN68@DrawAlphaN:

; 1127 :    {
; 1128 : 	   if(ownship->mFaults->WarnReset() && Warnflash)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?WarnReset@FackClass@@QAEHXZ		; FackClass::WarnReset
	test	eax, eax
	je	SHORT $LN64@DrawAlphaN
	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	SHORT $LN64@DrawAlphaN

; 1129 : 	   {
; 1130 : 		   //Fuel doesn't flash warning
; 1131 : 		   if(!ownship->mFaults->GetFault(fuel_low_fault) &&
; 1132 : 			   !ownship->mFaults->GetFault(fuel_trapped) &&
; 1133 : 			   !ownship->mFaults->GetFault(fuel_home))

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN64@DrawAlphaN
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN64@DrawAlphaN
	push	25					; 00000019H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN64@DrawAlphaN

; 1134 : 			   DrawWindowString(11, "WARN");

	push	0
	push	OFFSET ??_C@_04JBIELMDE@WARN?$AA@
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN64@DrawAlphaN:

; 1135 : 	   }
; 1136 :    }
; 1137 :    display->SetFont(ofont);

	mov	ecx, DWORD PTR _ofont$[ebp]
	push	ecx
	call	?SetFont@VirtualDisplay@@SAXH@Z		; VirtualDisplay::SetFont
	add	esp, 4

; 1138 : 
; 1139 :    // Window 12, 15 (Bingo, trapped or home Fuel) JPO additions
; 1140 : 
; 1141 :    
; 1142 :    if (ownship->mFaults->GetFault(fuel_low_fault) ||
; 1143 :        ownship->mFaults->GetFault(fuel_trapped) ||
; 1144 :        ownship->mFaults->GetFault(fuel_home))

	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN62@DrawAlphaN
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	jne	SHORT $LN62@DrawAlphaN
	push	25					; 00000019H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	$LN63@DrawAlphaN
$LN62@DrawAlphaN:

; 1145 :    {
; 1146 : 		//MI Warn Reset is correct
; 1147 : 		if(!g_bRealisticAvionics)

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN61@DrawAlphaN

; 1148 : 		{
; 1149 : 			if (ownship->mFaults->MasterCaution() && flash)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?MasterCaution@FackClass@@QAEHXZ	; FackClass::MasterCaution
	test	eax, eax
	je	SHORT $LN60@DrawAlphaN
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN60@DrawAlphaN

; 1150 : 				DrawWindowString (12, "FUEL");

	push	0
	push	OFFSET ??_C@_04DICABFLJ@FUEL?$AA@
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN60@DrawAlphaN:

; 1151 : 		}
; 1152 : 		else

	jmp	SHORT $LN58@DrawAlphaN
$LN61@DrawAlphaN:

; 1153 : 		{
; 1154 : 			if(ownship->mFaults->WarnReset() && Warnflash)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?WarnReset@FackClass@@QAEHXZ		; FackClass::WarnReset
	test	eax, eax
	je	SHORT $LN58@DrawAlphaN
	cmp	DWORD PTR ?Warnflash@HudClass@@0HA, 0	; HudClass::Warnflash
	je	SHORT $LN58@DrawAlphaN

; 1155 : 				DrawWindowString(12,"FUEL");

	push	0
	push	OFFSET ??_C@_04DICABFLJ@FUEL?$AA@
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN58@DrawAlphaN:

; 1156 : 		} 
; 1157 : 
; 1158 : 		// RV - RED - REWRITTEN THIS STUFF in a decent way
; 1159 : 		if(PlayerOptions.GetAvionicsType() != ATEasy){

	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	$LN53@DrawAlphaN

; 1160 : 		  char tempstr[10] = "";

	mov	cl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _tempstr$20[ebp], cl
	xor	edx, edx
	mov	DWORD PTR _tempstr$20[ebp+1], edx
	mov	DWORD PTR _tempstr$20[ebp+5], edx
	mov	BYTE PTR _tempstr$20[ebp+9], dl

; 1161 : 		  // Check various Fuel Situations
; 1162 : 	      if (ownship->mFaults->GetFault(fuel_low_fault)) sprintf(tempstr, "FUEL");

	push	13					; 0000000dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN56@DrawAlphaN
	push	OFFSET ??_C@_04DICABFLJ@FUEL?$AA@
	lea	edx, DWORD PTR _tempstr$20[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN56@DrawAlphaN:

; 1163 : 	      if (ownship->mFaults->GetFault(fuel_trapped))  sprintf(tempstr, "TRP FUEL");

	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN55@DrawAlphaN
	push	OFFSET ??_C@_08EMPPOEK@TRP?5FUEL?$AA@
	lea	edx, DWORD PTR _tempstr$20[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN55@DrawAlphaN:

; 1164 : 	      if (ownship->mFaults->GetFault(fuel_home)) sprintf(tempstr, "FUEL %03d", ownship->af->HomeFuel/100);

	push	25					; 00000019H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN54@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	mov	eax, DWORD PTR [ecx+1796]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	push	eax
	push	OFFSET ??_C@_09IMNIJPFK@FUEL?5?$CF03d?$AA@
	lea	edx, DWORD PTR _tempstr$20[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN54@DrawAlphaN:

; 1165 : 		  // if any warn, draw it
; 1166 : 		  if(tempstr[0]) DrawWindowString (15, tempstr);

	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR _tempstr$20[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN53@DrawAlphaN
	push	0
	lea	edx, DWORD PTR _tempstr$20[ebp]
	push	edx
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN53@DrawAlphaN:

; 1167 : 		}
; 1168 : 
; 1169 : 		//MI warn reset is correct
; 1170 : 		if(!g_bRealisticAvionics){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN51@DrawAlphaN

; 1171 : 			if (ownship->mFaults->GetFault(fuel_low_fault) && ownship->mFaults->MasterCaution() &&
; 1172 : 				F4SoundFXPlaying( ownship->af->GetBingoSnd())) // JB 010425

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+928]
	call	?GetFault@FackClass@@QAEHW4type_CSubSystem@@@Z ; FackClass::GetFault
	test	eax, eax
	je	SHORT $LN51@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+928]
	call	?MasterCaution@FackClass@@QAEHXZ	; FackClass::MasterCaution
	test	eax, eax
	je	SHORT $LN51@DrawAlphaN
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetBingoSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetBingoSnd
	push	eax
	call	_F4SoundFXPlaying
	add	esp, 8
	test	eax, eax
	je	SHORT $LN51@DrawAlphaN

; 1173 : 			{
; 1174 : 				F4SoundFXSetDist( ownship->af->GetBingoSnd(), FALSE, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetBingoSnd@AirframeClass@@QAEHXZ	; AirframeClass::GetBingoSnd
	push	eax
	call	_F4SoundFXSetDist
	add	esp, 16					; 00000010H
$LN51@DrawAlphaN:

; 1175 : 			}
; 1176 : 		}
; 1177 : 	  //MI fix for Bingo warning. This get's called in cautions.cpp
; 1178 : #if 0
; 1179 : 	  else
; 1180 : 	  {
; 1181 : 		  if (ownship->mFaults->GetFault(fuel_low_fault) && 
; 1182 : 			  ownship->mFaults->WarnReset() &&
; 1183 : 			  F4SoundFXPlaying( ownship->af->GetBingoSnd())) // JB 010425
; 1184 : 			  {
; 1185 : 				F4SoundFXSetDist( ownship->af->GetBingoSnd(), FALSE, 0.0f, 1.0f );
; 1186 : 			  }
; 1187 : 	  }
; 1188 : #endif
; 1189 :    }

	jmp	SHORT $LN49@DrawAlphaN
$LN63@DrawAlphaN:

; 1190 :    //Wombat778 10-16-2003 added as per MIRV  (draw bullseye info on hud)
; 1191 : 
; 1192 :    else if ((OTWDriver.pCockpitManager->mpIcp->ShowBullseyeInfo) && (PlayerOptions.GetAvionicsType() != ATEasy))

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	movzx	edx, BYTE PTR [ecx+300]
	test	edx, edx
	je	SHORT $LN49@DrawAlphaN
	mov	ecx, OFFSET ?PlayerOptions@@3VPlayerOptionsClass@@A ; PlayerOptions
	call	?GetAvionicsType@PlayerOptionsClass@@QAEHXZ ; PlayerOptionsClass::GetAvionicsType
	test	eax, eax
	je	SHORT $LN49@DrawAlphaN

; 1193 : 	  {
; 1194 : 		  char tempstr[15] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _tempstr$18[ebp], al
	xor	ecx, ecx
	mov	DWORD PTR _tempstr$18[ebp+1], ecx
	mov	DWORD PTR _tempstr$18[ebp+5], ecx
	mov	DWORD PTR _tempstr$18[ebp+9], ecx
	mov	WORD PTR _tempstr$18[ebp+13], cx

; 1195 : 		  GetBullseyeToOwnship(tempstr);

	lea	edx, DWORD PTR _tempstr$18[ebp]
	push	edx
	call	?GetBullseyeToOwnship@@YAXPAD@Z		; GetBullseyeToOwnship
	add	esp, 4

; 1196 : 		  DrawWindowString (15, tempstr);

	push	0
	lea	eax, DWORD PTR _tempstr$18[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString
$LN49@DrawAlphaN:

; 1197 : 	  }
; 1198 : 
; 1199 : 
; 1200 :    // Window 13 (Closure)
; 1201 :    // Done in missile or gun section
; 1202 : 
; 1203 :    // Window 14 (Steerpoint)
; 1204 :    // Done in nav section
; 1205 : 
; 1206 :    // Window 19 (Variable)
; 1207 :    // Done in missile or gun section
; 1208 : 
; 1209 :    //MI they wanted DED data, so here it is.....
; 1210 :    //if (dedSwitch == DED_DATA && OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModeHud)
; 1211 :    if (dedSwitch == DED_DATA || dedSwitch == PFL_DATA)// && OTWDriver.GetOTWDisplayMode() == OTWDriverClass::ModeHud)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4872], 0
	je	SHORT $LN47@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4872], 2
	jne	$LN39@DrawAlphaN
$LN47@DrawAlphaN:

; 1212 :    {
; 1213 : 		if(OTWDriver.pCockpitManager) {

	cmp	DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684, 0
	je	$LN39@DrawAlphaN

; 1214 : 	
; 1215 : 			if(!g_bRealisticAvionics && dedSwitch == DED_DATA)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	jne	$LN45@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4872], 0
	jne	SHORT $LN45@DrawAlphaN

; 1216 : 			{
; 1217 : 				char line1[40];
; 1218 : 				char line2[40];
; 1219 : 				char line3[40];
; 1220 : 
; 1221 : 				OTWDriver.pCockpitManager->mpIcp->Exec();

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [edx+688]
	call	?Exec@ICPClass@@QAEXXZ			; ICPClass::Exec

; 1222 : 				OTWDriver.pCockpitManager->mpIcp->GetDEDStrings(line1, line2, line3);

	lea	eax, DWORD PTR _line3$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _line2$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _line1$12[ebp]
	push	edx
	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?GetDEDStrings@ICPClass@@QAEXPAD00@Z	; ICPClass::GetDEDStrings

; 1223 : 				
; 1224 : 				DrawWindowString (21, line1);

	push	0
	lea	ecx, DWORD PTR _line1$12[ebp]
	push	ecx
	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 1225 : 				DrawWindowString (22, line2);

	push	0
	lea	edx, DWORD PTR _line2$10[ebp]
	push	edx
	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 1226 : 				DrawWindowString (23, line3);

	push	0
	lea	eax, DWORD PTR _line3$11[ebp]
	push	eax
	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawWindowString@HudClass@@AAEXHPADH@Z	; HudClass::DrawWindowString

; 1227 : 			}
; 1228 : 			else

	jmp	$LN39@DrawAlphaN
$LN45@DrawAlphaN:

; 1229 : 			{
; 1230 : 				if(!playerAC->HasPower(AircraftClass::UFCPower) ||
; 1231 : 					(FCC && FCC->GetMasterMode() == FireControlComputer::Dogfight))

	push	8
	mov	ecx, DWORD PTR _playerAC$[ebp]
	call	?HasPower@AircraftClass@@QAEHW4AvionicsPowerFlags@1@@Z ; AircraftClass::HasPower
	test	eax, eax
	je	SHORT $LN42@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN43@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetMasterMode@FireControlComputer@@QAE?AW4FCCMasterMode@1@XZ ; FireControlComputer::GetMasterMode
	cmp	eax, 9
	jne	SHORT $LN43@DrawAlphaN
$LN42@DrawAlphaN:

; 1232 : 					return;

	jmp	$LN125@DrawAlphaN
$LN43@DrawAlphaN:

; 1233 : 
; 1234 : 				OTWDriver.pCockpitManager->mpIcp->Exec();

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	call	?Exec@ICPClass@@QAEXXZ			; ICPClass::Exec

; 1235 : 				OTWDriver.pCockpitManager->mpIcp->ExecPfl();

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [ecx+688]
	call	?ExecPfl@ICPClass@@QAEXXZ		; ICPClass::ExecPfl

; 1236 : 			
; 1237 : 				char line1[27] = "";

	mov	dl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _line1$17[ebp], dl
	xor	eax, eax
	mov	DWORD PTR _line1$17[ebp+1], eax
	mov	DWORD PTR _line1$17[ebp+5], eax
	mov	DWORD PTR _line1$17[ebp+9], eax
	mov	DWORD PTR _line1$17[ebp+13], eax
	mov	DWORD PTR _line1$17[ebp+17], eax
	mov	DWORD PTR _line1$17[ebp+21], eax
	mov	WORD PTR _line1$17[ebp+25], ax

; 1238 : 				char line2[27] = "";

	mov	cl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _line2$15[ebp], cl
	xor	edx, edx
	mov	DWORD PTR _line2$15[ebp+1], edx
	mov	DWORD PTR _line2$15[ebp+5], edx
	mov	DWORD PTR _line2$15[ebp+9], edx
	mov	DWORD PTR _line2$15[ebp+13], edx
	mov	DWORD PTR _line2$15[ebp+17], edx
	mov	DWORD PTR _line2$15[ebp+21], edx
	mov	WORD PTR _line2$15[ebp+25], dx

; 1239 : 				char line3[27] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _line3$13[ebp], al
	xor	ecx, ecx
	mov	DWORD PTR _line3$13[ebp+1], ecx
	mov	DWORD PTR _line3$13[ebp+5], ecx
	mov	DWORD PTR _line3$13[ebp+9], ecx
	mov	DWORD PTR _line3$13[ebp+13], ecx
	mov	DWORD PTR _line3$13[ebp+17], ecx
	mov	DWORD PTR _line3$13[ebp+21], ecx
	mov	WORD PTR _line3$13[ebp+25], cx

; 1240 : 				char line4[27] = "";

	mov	dl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _line4$16[ebp], dl
	xor	eax, eax
	mov	DWORD PTR _line4$16[ebp+1], eax
	mov	DWORD PTR _line4$16[ebp+5], eax
	mov	DWORD PTR _line4$16[ebp+9], eax
	mov	DWORD PTR _line4$16[ebp+13], eax
	mov	DWORD PTR _line4$16[ebp+17], eax
	mov	DWORD PTR _line4$16[ebp+21], eax
	mov	WORD PTR _line4$16[ebp+25], ax

; 1241 : 				char line5[27] = "";

	mov	cl, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _line5$14[ebp], cl
	xor	edx, edx
	mov	DWORD PTR _line5$14[ebp+1], edx
	mov	DWORD PTR _line5$14[ebp+5], edx
	mov	DWORD PTR _line5$14[ebp+9], edx
	mov	DWORD PTR _line5$14[ebp+13], edx
	mov	DWORD PTR _line5$14[ebp+17], edx
	mov	DWORD PTR _line5$14[ebp+21], edx
	mov	WORD PTR _line5$14[ebp+25], dx

; 1242 : 				line1[26] = '\0';

	mov	eax, 1
	imul	eax, 26					; 0000001aH
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 27			; 0000001bH
	jae	SHORT $LN127@DrawAlphaN
	jmp	SHORT $LN128@DrawAlphaN
$LN127@DrawAlphaN:
	call	___report_rangecheckfailure
$LN128@DrawAlphaN:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _line1$17[ebp+ecx], 0

; 1243 : 				line2[26] = '\0';

	mov	edx, 1
	imul	edx, 26					; 0000001aH
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 27			; 0000001bH
	jae	SHORT $LN129@DrawAlphaN
	jmp	SHORT $LN130@DrawAlphaN
$LN129@DrawAlphaN:
	call	___report_rangecheckfailure
$LN130@DrawAlphaN:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _line2$15[ebp+eax], 0

; 1244 : 				line3[26] = '\0';

	mov	ecx, 1
	imul	ecx, 26					; 0000001aH
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 27			; 0000001bH
	jae	SHORT $LN131@DrawAlphaN
	jmp	SHORT $LN132@DrawAlphaN
$LN131@DrawAlphaN:
	call	___report_rangecheckfailure
$LN132@DrawAlphaN:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _line3$13[ebp+edx], 0

; 1245 : 				line4[26] = '\0';

	mov	eax, 1
	imul	eax, 26					; 0000001aH
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 27			; 0000001bH
	jae	SHORT $LN133@DrawAlphaN
	jmp	SHORT $LN134@DrawAlphaN
$LN133@DrawAlphaN:
	call	___report_rangecheckfailure
$LN134@DrawAlphaN:
	mov	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _line4$16[ebp+ecx], 0

; 1246 : 				line5[26] = '\0';

	mov	edx, 1
	imul	edx, 26					; 0000001aH
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 27			; 0000001bH
	jae	SHORT $LN135@DrawAlphaN
	jmp	SHORT $LN136@DrawAlphaN
$LN135@DrawAlphaN:
	call	___report_rangecheckfailure
$LN136@DrawAlphaN:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _line5$14[ebp+eax], 0

; 1247 : 				static float xPos = -0.58F;  // JPG 16 Dec 03 - was -0.70F
; 1248 : 				float yPos = -0.60F;

	movss	xmm0, DWORD PTR __real@bf19999a
	movss	DWORD PTR _yPos$7[ebp], xmm0

; 1249 : 				for(int j = 0; j < 5; j++)

	mov	DWORD PTR _j$8[ebp], 0
	jmp	SHORT $LN41@DrawAlphaN
$LN40@DrawAlphaN:
	mov	ecx, DWORD PTR _j$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$8[ebp], ecx
$LN41@DrawAlphaN:
	cmp	DWORD PTR _j$8[ebp], 5
	jge	$LN39@DrawAlphaN

; 1250 : 				{
; 1251 : 					for(int i = 0; i < 26; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN38@DrawAlphaN
$LN37@DrawAlphaN:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN38@DrawAlphaN:
	cmp	DWORD PTR _i$9[ebp], 26			; 0000001aH
	jge	$LN36@DrawAlphaN

; 1252 : 					{
; 1253 : 						switch(j)

	mov	eax, DWORD PTR _j$8[ebp]
	mov	DWORD PTR tv769[ebp], eax
	cmp	DWORD PTR tv769[ebp], 4
	ja	$LN34@DrawAlphaN
	mov	ecx, DWORD PTR tv769[ebp]
	jmp	DWORD PTR $LN137@DrawAlphaN[ecx*4]
$LN33@DrawAlphaN:

; 1254 : 						{
; 1255 : 						case 0:
; 1256 : 							if(dedSwitch == DED_DATA)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4872], 0
	jne	SHORT $LN32@DrawAlphaN

; 1257 : 								line1[i] = OTWDriver.pCockpitManager->mpIcp->DEDLines[j][i];

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$8[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+764]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR _line1$17[ebp+ecx], al
	jmp	SHORT $LN30@DrawAlphaN
$LN32@DrawAlphaN:

; 1258 : 							else if(dedSwitch == PFL_DATA)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4872], 2
	jne	SHORT $LN30@DrawAlphaN

; 1259 : 								line1[i] = OTWDriver.pCockpitManager->mpIcp->PFLLines[j][i];

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR _j$8[ebp]
	imul	ecx, 26					; 0000001aH
	lea	edx, DWORD PTR [eax+ecx+1084]
	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	dl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _line1$17[ebp+eax], dl
$LN30@DrawAlphaN:

; 1260 : 							break;

	jmp	$LN34@DrawAlphaN
$LN29@DrawAlphaN:

; 1261 : 						case 1:
; 1262 : 							if(dedSwitch == DED_DATA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4872], 0
	jne	SHORT $LN28@DrawAlphaN

; 1263 : 								line2[i] = OTWDriver.pCockpitManager->mpIcp->DEDLines[j][i];

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _j$8[ebp]
	imul	eax, 26					; 0000001aH
	lea	ecx, DWORD PTR [edx+eax+764]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	eax, DWORD PTR _i$9[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _line2$15[ebp+edx], cl
	jmp	SHORT $LN26@DrawAlphaN
$LN28@DrawAlphaN:

; 1264 : 							else if(dedSwitch == PFL_DATA)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4872], 2
	jne	SHORT $LN26@DrawAlphaN

; 1265 : 								line2[i] = OTWDriver.pCockpitManager->mpIcp->PFLLines[j][i];

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$8[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+1084]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR _line2$15[ebp+ecx], al
$LN26@DrawAlphaN:

; 1266 : 							break;

	jmp	$LN34@DrawAlphaN
$LN25@DrawAlphaN:

; 1267 : 						case 2:
; 1268 : 							if(dedSwitch == DED_DATA)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4872], 0
	jne	SHORT $LN24@DrawAlphaN

; 1269 : 								line3[i] = OTWDriver.pCockpitManager->mpIcp->DEDLines[j][i];

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR _j$8[ebp]
	imul	ecx, 26					; 0000001aH
	lea	edx, DWORD PTR [eax+ecx+764]
	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	dl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _line3$13[ebp+eax], dl
	jmp	SHORT $LN22@DrawAlphaN
$LN24@DrawAlphaN:

; 1270 : 							else if(dedSwitch == PFL_DATA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4872], 2
	jne	SHORT $LN22@DrawAlphaN

; 1271 : 								line3[i] = OTWDriver.pCockpitManager->mpIcp->PFLLines[j][i];

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _j$8[ebp]
	imul	eax, 26					; 0000001aH
	lea	ecx, DWORD PTR [edx+eax+1084]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	eax, DWORD PTR _i$9[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _line3$13[ebp+edx], cl
$LN22@DrawAlphaN:

; 1272 : 							break;

	jmp	$LN34@DrawAlphaN
$LN21@DrawAlphaN:

; 1273 : 						case 3:
; 1274 : 							if(dedSwitch == DED_DATA)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4872], 0
	jne	SHORT $LN20@DrawAlphaN

; 1275 : 								line4[i] = OTWDriver.pCockpitManager->mpIcp->DEDLines[j][i];

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$8[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+764]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR _line4$16[ebp+ecx], al
	jmp	SHORT $LN18@DrawAlphaN
$LN20@DrawAlphaN:

; 1276 : 							else if(dedSwitch == PFL_DATA)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4872], 2
	jne	SHORT $LN18@DrawAlphaN

; 1277 : 								line4[i] = OTWDriver.pCockpitManager->mpIcp->PFLLines[j][i];

	mov	edx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	eax, DWORD PTR [edx+688]
	mov	ecx, DWORD PTR _j$8[ebp]
	imul	ecx, 26					; 0000001aH
	lea	edx, DWORD PTR [eax+ecx+1084]
	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	dl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _line4$16[ebp+eax], dl
$LN18@DrawAlphaN:

; 1278 : 							break;

	jmp	$LN34@DrawAlphaN
$LN17@DrawAlphaN:

; 1279 : 						case 4:
; 1280 : 							if(dedSwitch == DED_DATA)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4872], 0
	jne	SHORT $LN16@DrawAlphaN

; 1281 : 								line5[i] = OTWDriver.pCockpitManager->mpIcp->DEDLines[j][i];

	mov	ecx, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _j$8[ebp]
	imul	eax, 26					; 0000001aH
	lea	ecx, DWORD PTR [edx+eax+764]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	eax, DWORD PTR _i$9[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _line5$14[ebp+edx], cl
	jmp	SHORT $LN14@DrawAlphaN
$LN16@DrawAlphaN:

; 1282 : 							else if(dedSwitch == PFL_DATA)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4872], 2
	jne	SHORT $LN14@DrawAlphaN

; 1283 : 								line5[i] = OTWDriver.pCockpitManager->mpIcp->PFLLines[j][i];

	mov	eax, DWORD PTR ?OTWDriver@@3VOTWDriverClass@@A+33684
	mov	ecx, DWORD PTR [eax+688]
	mov	edx, DWORD PTR _j$8[ebp]
	imul	edx, 26					; 0000001aH
	lea	eax, DWORD PTR [ecx+edx+1084]
	mov	ecx, DWORD PTR _i$9[ebp]
	mov	edx, DWORD PTR _i$9[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR _line5$14[ebp+ecx], al
$LN14@DrawAlphaN:
$LN34@DrawAlphaN:

; 1284 : 							break;				
; 1285 : 						}
; 1286 : 					}

	jmp	$LN37@DrawAlphaN
$LN36@DrawAlphaN:

; 1287 : 					switch(j)

	mov	ecx, DWORD PTR _j$8[ebp]
	mov	DWORD PTR tv871[ebp], ecx
	cmp	DWORD PTR tv871[ebp], 4
	ja	$LN6@DrawAlphaN
	mov	edx, DWORD PTR tv871[ebp]
	jmp	DWORD PTR $LN138@DrawAlphaN[edx*4]
$LN11@DrawAlphaN:

; 1288 : 					{
; 1289 : 					case 0:
; 1290 : 						display->TextLeft (xPos, yPos + 0.03F, line1, 0);

	push	0
	lea	eax, DWORD PTR _line1$17[ebp]
	push	eax
	movss	xmm0, DWORD PTR _yPos$7[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1291 : 						break;

	jmp	$LN12@DrawAlphaN
$LN10@DrawAlphaN:

; 1292 : 					case 1:
; 1293 : 						display->TextLeft (xPos, yPos + 0.03F, line2, 0);

	push	0
	lea	ecx, DWORD PTR _line2$15[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _yPos$7[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1294 : 						break;

	jmp	$LN12@DrawAlphaN
$LN9@DrawAlphaN:

; 1295 : 					case 2:
; 1296 : 						display->TextLeft (xPos, yPos + 0.03F, line3, 0);

	push	0
	lea	ecx, DWORD PTR _line3$13[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _yPos$7[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1297 : 						break;

	jmp	$LN12@DrawAlphaN
$LN8@DrawAlphaN:

; 1298 : 					case 3:
; 1299 : 						display->TextLeft (xPos, yPos + 0.03F, line4, 0);

	push	0
	lea	ecx, DWORD PTR _line4$16[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _yPos$7[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 1300 : 						break;

	jmp	SHORT $LN12@DrawAlphaN
$LN7@DrawAlphaN:

; 1301 : 					case 4:
; 1302 : 						display->TextLeft (xPos, yPos + 0.03F, line5, 0);

	push	0
	lea	ecx, DWORD PTR _line5$14[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _yPos$7[ebp]
	addss	xmm0, DWORD PTR __real@3cf5c28f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR ?xPos@?JE@??DrawAlphaNumeric@HudClass@@AAEXXZ@4MA
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+56]
	call	eax
$LN6@DrawAlphaN:
$LN12@DrawAlphaN:

; 1303 : 						break;
; 1304 : 					default:
; 1305 : 						break;
; 1306 : 					}
; 1307 : 					yPos -= 0.08F;

	movss	xmm0, DWORD PTR _yPos$7[ebp]
	subss	xmm0, DWORD PTR __real@3da3d70a
	movss	DWORD PTR _yPos$7[ebp], xmm0

; 1308 : 				}

	jmp	$LN40@DrawAlphaN
$LN39@DrawAlphaN:

; 1309 : 			}
; 1310 : 		}
; 1311 :    }
; 1312 : 
; 1313 :    //MI TFR info if needed
; 1314 :    if(theLantirn && theLantirn->IsEnabled() && ownship && ownship->mFaults && !ownship->mFaults->WarnReset()
; 1315 : 	   && ownship->RFState != 2)

	cmp	DWORD PTR ?theLantirn@@3PAVLantirnClass@@A, 0 ; theLantirn
	je	$LN5@DrawAlphaN
	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	call	?IsEnabled@LantirnClass@@QAE_NXZ	; LantirnClass::IsEnabled
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	$LN5@DrawAlphaN
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx+928], 0
	je	$LN5@DrawAlphaN
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+928]
	call	?WarnReset@FackClass@@QAEHXZ		; FackClass::WarnReset
	test	eax, eax
	jne	$LN5@DrawAlphaN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx+1520], 2
	je	$LN5@DrawAlphaN

; 1316 :    {
; 1317 : 	   char tempstr[20] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _tempstr$19[ebp], al
	xor	ecx, ecx
	mov	DWORD PTR _tempstr$19[ebp+1], ecx
	mov	DWORD PTR _tempstr$19[ebp+5], ecx
	mov	DWORD PTR _tempstr$19[ebp+9], ecx
	mov	DWORD PTR _tempstr$19[ebp+13], ecx
	mov	WORD PTR _tempstr$19[ebp+17], cx
	mov	BYTE PTR _tempstr$19[ebp+19], cl

; 1318 : 	   if (theLantirn->evasize  == 1 && flash)

	mov	edx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	cmp	DWORD PTR [edx+36], 1
	jne	SHORT $LN4@DrawAlphaN
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN4@DrawAlphaN

; 1319 : 		   sprintf(tempstr, "FLY UP");

	push	OFFSET ??_C@_06HICPBJFO@FLY?5UP?$AA@
	lea	eax, DWORD PTR _tempstr$19[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN2@DrawAlphaN
$LN4@DrawAlphaN:

; 1320 : 	   else if (theLantirn->evasize  == 2 && flash)

	mov	ecx, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	cmp	DWORD PTR [ecx+36], 2
	jne	SHORT $LN2@DrawAlphaN
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	je	SHORT $LN2@DrawAlphaN

; 1321 : 		   sprintf(tempstr, "OBSTACLE");

	push	OFFSET ??_C@_08OOPLBCBC@OBSTACLE?$AA@
	lea	edx, DWORD PTR _tempstr$19[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN2@DrawAlphaN:

; 1322 : 	   if (theLantirn->SpeedUp && !flash)

	mov	eax, DWORD PTR ?theLantirn@@3PAVLantirnClass@@A ; theLantirn
	movzx	ecx, BYTE PTR [eax+104]
	test	ecx, ecx
	je	SHORT $LN1@DrawAlphaN
	cmp	DWORD PTR ?flash@HudClass@@0HA, 0	; HudClass::flash
	jne	SHORT $LN1@DrawAlphaN

; 1323 : 		   sprintf(tempstr, "SLOW");

	push	OFFSET ??_C@_04BJJAFLBC@SLOW?$AA@
	lea	edx, DWORD PTR _tempstr$19[ebp]
	push	edx
	call	_sprintf
	add	esp, 8
$LN1@DrawAlphaN:

; 1324 : 	   
; 1325 : 	   display->TextCenter (0, 0.25, tempstr, 0 );

	push	0
	lea	eax, DWORD PTR _tempstr$19[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN5@DrawAlphaN:
$LN125@DrawAlphaN:

; 1326 :    }
; 1327 : 
; 1328 : }//End function

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN137@DrawAlphaN:
	DD	$LN33@DrawAlphaN
	DD	$LN29@DrawAlphaN
	DD	$LN25@DrawAlphaN
	DD	$LN21@DrawAlphaN
	DD	$LN17@DrawAlphaN
$LN138@DrawAlphaN:
	DD	$LN11@DrawAlphaN
	DD	$LN10@DrawAlphaN
	DD	$LN9@DrawAlphaN
	DD	$LN8@DrawAlphaN
	DD	$LN7@DrawAlphaN
?DrawAlphaNumeric@HudClass@@AAEXXZ ENDP			; HudClass::DrawAlphaNumeric
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
tv773 = -24						; size = 4
tv671 = -20						; size = 4
tv611 = -16						; size = 4
_xCenter$ = -12						; size = 4
_yCenter$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawBoresightCross@HudClass@@AAEXXZ PROC		; HudClass::DrawBoresightCross
; _this$ = ecx

; 1528 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1529 : 	float xCenter = hudWinX[BORESIGHT_CROSS_WINDOW] + hudWinWidth[BORESIGHT_CROSS_WINDOW] * 0.5F;

	mov	eax, 4
	imul	eax, 44					; 0000002cH
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinX@@3PAMA[eax]
	movss	DWORD PTR _xCenter$[ebp], xmm0

; 1530 : 	float yCenter = hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F;

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	movss	DWORD PTR _yCenter$[ebp], xmm0

; 1531 : 	
; 1532 : 	//TJL 03/11/04 F16 only for boresight cross (others have waterline) or default HUD
; 1533 : 	if (ownship->IsF16() || ownship->af->GetTypeAC() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?IsF16@AircraftClass@@QAEHXZ		; AircraftClass::IsF16
	test	eax, eax
	jne	SHORT $LN11@DrawBoresi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	test	eax, eax
	jne	$LN12@DrawBoresi
$LN11@DrawBoresi:

; 1534 : 	{
; 1535 : 	//end
; 1536 : 	
; 1537 : 
; 1538 : 	display->Line ( xCenter + 0.025F, yCenter, xCenter + 0.05F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3ccccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1539 : 	display->Line ( xCenter - 0.025F, yCenter, xCenter - 0.05F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3ccccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1540 : 	display->Line ( xCenter, yCenter + 0.025F, xCenter, yCenter + 0.05F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3ccccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1541 : 	display->Line ( xCenter, yCenter - 0.025F, xCenter, yCenter - 0.05F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3ccccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN12@DrawBoresi:

; 1542 : 	}
; 1543 : 
; 1544 :    if (HudData.IsSet(HudDataType::RadarNoRad))

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4972				; 0000136cH
	call	?IsSet@HudDataType@@QAEHH@Z		; HudDataType::IsSet
	test	eax, eax
	je	SHORT $LN8@DrawBoresi

; 1545 :    {
; 1546 : 	   //MI
; 1547 : 	   if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	SHORT $LN9@DrawBoresi

; 1548 : 		   display->TextCenter (xCenter, yCenter + 0.075F, "NO RAD", 0);

	push	0
	push	OFFSET ??_C@_06MNCBBDMH@NO?5RAD?$AA@
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 1549 : 	   else

	jmp	SHORT $LN8@DrawBoresi
$LN9@DrawBoresi:

; 1550 : 		   display->TextCenter (xCenter, yCenter + 0.15F, "NO RAD", 0);

	push	0
	push	OFFSET ??_C@_06MNCBBDMH@NO?5RAD?$AA@
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3e19999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN8@DrawBoresi:

; 1551 :    }
; 1552 : 
; 1553 :    if (HudData.IsSet(HudDataType::RadarBoresight | HudDataType::RadarSlew))

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4972				; 0000136cH
	call	?IsSet@HudDataType@@QAEHH@Z		; HudDataType::IsSet
	test	eax, eax
	je	$LN2@DrawBoresi

; 1554 :    {
; 1555 : 	   if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN6@DrawBoresi

; 1556 : 	   {
; 1557 : 		   yCenter -= RadToHudUnitsY(3.0F * DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d56774e
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR tv611[ebp]
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR tv611[ebp]
	movss	DWORD PTR _yCenter$[ebp], xmm0

; 1558 : 		   display->Line ( xCenter + 0.05F, yCenter, xCenter + 0.1F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1559 : 		   display->Line ( xCenter - 0.05F, yCenter, xCenter - 0.1F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1560 : 		   display->Line ( xCenter, yCenter + 0.05F, xCenter, yCenter + 0.15F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3e19999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1561 : 		   display->Line ( xCenter, yCenter - 0.05F, xCenter, yCenter - 0.15F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3e19999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3d4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1562 : 		   display->Point (xCenter, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 1563 : 	   }
; 1564 : 	   else

	jmp	$LN3@DrawBoresi
$LN6@DrawBoresi:

; 1565 : 	   {
; 1566 : 		   //MI draw the cross correct
; 1567 : 		   if(HudData.IsSet(HudDataType::RadarSlew))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4972				; 0000136cH
	call	?IsSet@HudDataType@@QAEHH@Z		; HudDataType::IsSet
	test	eax, eax
	je	$LN4@DrawBoresi

; 1568 : 		   {
; 1569 : 			   yCenter -= RadToHudUnitsY(3.0F * DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d56774e
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR tv671[ebp]
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR tv671[ebp]
	movss	DWORD PTR _yCenter$[ebp], xmm0

; 1570 : 			   display->Line ( xCenter + 0.02F, yCenter, xCenter + 0.1F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1571 : 			   display->Line ( xCenter - 0.02F, yCenter, xCenter - 0.1F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1572 : 			   display->Line(xCenter, yCenter + 0.02F, xCenter, yCenter + 0.0533F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d5a511a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1573 : 			   display->Line(xCenter, yCenter + 0.0733F, xCenter, yCenter + 0.1066F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3dda511a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3d961e4f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1574 : 			   display->Line(xCenter, yCenter + 0.1266F, xCenter, yCenter + 0.16F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3e23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3e01a36e
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1575 : 			   display->Line(xCenter, yCenter - 0.02F, xCenter, yCenter - 0.0533F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3d5a511a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1576 : 			   display->Line(xCenter, yCenter - 0.0733F, xCenter, yCenter - 0.1066F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3dda511a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3d961e4f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1577 : 			   display->Line(xCenter, yCenter - 0.1266F, xCenter, yCenter - 0.16F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3e23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3e01a36e
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1578 : 			   display->Point (xCenter, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 1579 : 		   }
; 1580 : 		   else

	jmp	$LN3@DrawBoresi
$LN4@DrawBoresi:

; 1581 : 		   {
; 1582 : 			   yCenter -= RadToHudUnitsY(3.0F * DTR);

	push	ecx
	movss	xmm0, DWORD PTR __real@3d56774e
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR tv773[ebp]
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR tv773[ebp]
	movss	DWORD PTR _yCenter$[ebp], xmm0

; 1583 : 			   display->Line ( xCenter + 0.02F, yCenter, xCenter + 0.1F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1584 : 			   display->Line ( xCenter - 0.02F, yCenter, xCenter - 0.1F, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3dcccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1585 : 			   display->Line ( xCenter, yCenter + 0.02F, xCenter, yCenter + 0.16F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3e23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	addss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1586 : 			   display->Line ( xCenter, yCenter - 0.02F, xCenter, yCenter - 0.16F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3e23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3ca3d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1587 : 			   display->Point (xCenter, yCenter);

	push	ecx
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN3@DrawBoresi:

; 1588 : 		   }
; 1589 : 	   }
; 1590 :       if (HudData.IsSet(HudDataType::RadarSlew))

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4972				; 0000136cH
	call	?IsSet@HudDataType@@QAEHH@Z		; HudDataType::IsSet
	test	eax, eax
	je	SHORT $LN2@DrawBoresi

; 1591 :       {
; 1592 :          display->Circle (xCenter + HudData.radarAz/(60.0F * DTR) * 0.1F,
; 1593 :             yCenter + HudData.radarEl/(60.0F * DTR) * 0.15F, 0.025F);

	push	ecx
	movss	xmm0, DWORD PTR __real@3ccccccd
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4992]
	divss	xmm0, DWORD PTR __real@3f860a91
	mulss	xmm0, DWORD PTR __real@3e19999a
	addss	xmm0, DWORD PTR _yCenter$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4988]
	divss	xmm0, DWORD PTR __real@3f860a91
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR _xCenter$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+48]
	call	edx
$LN2@DrawBoresi:

; 1594 :       }
; 1595 :    }
; 1596 : 
; 1597 :    if (HudData.IsSet(HudDataType::RadarVertical))

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4972				; 0000136cH
	call	?IsSet@HudDataType@@QAEHH@Z		; HudDataType::IsSet
	test	eax, eax
	je	SHORT $LN1@DrawBoresi

; 1598 :    {
; 1599 :       display->Line ( xCenter, yCenter - 0.15F, xCenter, yCenter - 2.0F);

	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _yCenter$[ebp]
	subss	xmm0, DWORD PTR __real@3e19999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xCenter$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN1@DrawBoresi:

; 1600 :    }
; 1601 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawBoresightCross@HudClass@@AAEXXZ ENDP		; HudClass::DrawBoresightCross
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawAATDBox@HudClass@@AAEXXZ PROC			; HudClass::DrawAATDBox
; _this$ = ecx

; 2545 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2546 : 		if (targetData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$LN1@DrawAATDBo

; 2547 : 	{
; 2548 : 		display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2549 : 			hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2550 : 		
; 2551 : 		DrawTDMarker(targetData->az, targetData->el, targetData->droll, 0.07F );

	push	ecx
	movss	xmm0, DWORD PTR __real@3d8f5c29
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTDMarker@HudClass@@AAEXMMMM@Z	; HudClass::DrawTDMarker

; 2552 : 		
; 2553 : 		display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2554 : 			hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN1@DrawAATDBo:

; 2555 : 	}
; 2556 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawAATDBox@HudClass@@AAEXXZ ENDP			; HudClass::DrawAATDBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_trig$ = -88						; size = 8
tv919 = -80						; size = 4
tv596 = -76						; size = 4
tv620 = -72						; size = 4
tv909 = -68						; size = 4
tv889 = -64						; size = 4
tv900 = -60						; size = 4
tv610 = -56						; size = 4
tv895 = -52						; size = 4
tv603 = -48						; size = 4
tv385 = -44						; size = 4
_offset$ = -40						; size = 4
_theRadar$ = -36					; size = 4
_yPos$ = -32						; size = 4
_xPos$ = -28						; size = 4
_playerAC$ = -24					; size = 4
_this$ = -20						; size = 4
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_az$ = 8						; size = 4
_el$ = 12						; size = 4
_dRoll$ = 16						; size = 4
_size$ = 20						; size = 4
?DrawTDMarker@HudClass@@AAEXMMMM@Z PROC			; HudClass::DrawTDMarker
; _this$ = ecx

; 2460 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2461 : 	float xPos, yPos;
; 2462 : 	char tmpStr[12];
; 2463 : 	mlTrig trig;
; 2464 : 	float offset = MRToHudUnits(45.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MRToHudUnits@HudClass@@AAEMM@Z		; HudClass::MRToHudUnits
	fstp	DWORD PTR _offset$[ebp]

; 2465 : 	//MI
; 2466 : 	AircraftClass *playerAC = SimDriver.GetPlayerAircraft();

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerAircraft@SimulationDriver@@QBEPAVAircraftClass@@XZ ; SimulationDriver::GetPlayerAircraft
	mov	DWORD PTR _playerAC$[ebp], eax

; 2467 : 	RadarDopplerClass* theRadar = (RadarDopplerClass*)FindSensor(playerAC, SensorClass::Radar);

	push	1
	mov	eax, DWORD PTR _playerAC$[ebp]
	push	eax
	call	?FindSensor@@YAPAVSensorClass@@PAVSimMoverClass@@H@Z ; FindSensor
	add	esp, 8
	mov	DWORD PTR _theRadar$[ebp], eax

; 2468 : 	xPos = RadToHudUnitsX(az);

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsX@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsX
	fstp	DWORD PTR _xPos$[ebp]

; 2469 : 	yPos = RadToHudUnitsY(el);

	push	ecx
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RadToHudUnitsY@HudClass@@AAEMM@Z	; HudClass::RadToHudUnitsY
	fstp	DWORD PTR _yPos$[ebp]

; 2470 : 
; 2471 :    if (fabs (az) < 90.0F * DTR && fabs (el) < 90.0F * DTR && fabs (xPos) < 0.90F && 
; 2472 : 	   fabs(yPos + hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F) < 0.90F)

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv596[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv596[ebp]
	jbe	$LN14@DrawTDMark
	push	ecx
	movss	xmm0, DWORD PTR _el$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv603[ebp]
	movss	xmm0, DWORD PTR __real@3fc90fd9
	comiss	xmm0, DWORD PTR tv603[ebp]
	jbe	$LN14@DrawTDMark
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv610[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR tv610[ebp]
	jbe	$LN14@DrawTDMark
	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR _yPos$[ebp]
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm1, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv620[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR tv620[ebp]
	jbe	$LN14@DrawTDMark

; 2473 :    {
; 2474 : 	   display->AdjustOriginInViewport(xPos, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2475 : 	   //MI
; 2476 : 	   if(g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN13@DrawTDMark

; 2477 : 	   {
; 2478 : 		   if(playerAC && playerAC->Sms && playerAC->Sms
; 2479 : 			   ->curWeaponType == wtAgm65 && playerAC->Sms->curWeapon)

	cmp	DWORD PTR _playerAC$[ebp], 0
	je	$LN12@DrawTDMark
	mov	edx, DWORD PTR _playerAC$[ebp]
	cmp	DWORD PTR [edx+940], 0
	je	$LN12@DrawTDMark
	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+148], 4
	jne	$LN12@DrawTDMark
	mov	edx, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [edx+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN12@DrawTDMark

; 2480 : 		   {
; 2481 : 			   if(playerAC->Sms->MavSubMode == SMSBaseClass::VIS)

	mov	ecx, DWORD PTR _playerAC$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	cmp	DWORD PTR [edx+24], 1
	jne	$LN11@DrawTDMark

; 2482 : 			   {
; 2483 : 				   if(FCC->preDesignate)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movsx	edx, BYTE PTR [ecx+182]
	test	edx, edx
	je	$LN10@DrawTDMark

; 2484 : 				   {				 
; 2485 : 					   display->Line (-size, -size, -size, size);	

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2486 : 					   display->Line (-size, -size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2487 : 					   display->Line ( size, size, -size, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2488 : 					   display->Line ( size, size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2489 : 				   }
; 2490 : 				   else

	jmp	SHORT $LN9@DrawTDMark
$LN10@DrawTDMark:

; 2491 : 					   display->Circle(0.0F, 0.0F, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+48]
	call	edx
$LN9@DrawTDMark:
	jmp	$LN6@DrawTDMark
$LN11@DrawTDMark:

; 2492 : 			   }
; 2493 : 			   else if(playerAC->Sms->MavSubMode == SMSBaseClass::PRE)

	mov	eax, DWORD PTR _playerAC$[ebp]
	mov	ecx, DWORD PTR [eax+940]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN7@DrawTDMark

; 2494 : 			   {
; 2495 : 				   display->Line (-size, -size, -size, size);	

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2496 : 				   display->Line (-size, -size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2497 : 				   display->Line ( size, size, -size, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2498 : 				   display->Line ( size, size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2499 : 			   }
; 2500 : 			   else

	jmp	$LN6@DrawTDMark
$LN7@DrawTDMark:

; 2501 : 			   {
; 2502 : 				   display->Line (0.0F,  0.14F,  0.0F, -0.14F);  // JPG 11 Dec 03 - Let's draw a BORE EO reticle instead of a box

	push	ecx
	movss	xmm0, DWORD PTR __real@be0f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e0f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2503 : 				   display->Line (0.14F,  0.0F, -0.14F,  0.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be0f5c29
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3e0f5c29
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN6@DrawTDMark:

; 2504 : 			   }   
; 2505 : 		   }
; 2506 : 		   else

	jmp	$LN3@DrawTDMark
$LN12@DrawTDMark:

; 2507 : 		   {
; 2508 : 			   display->Line (-size, -size, -size, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2509 : 			   display->Line (-size, -size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2510 : 			   display->Line ( size, size, -size, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2511 : 			   display->Line ( size, size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2512 : 			   //MI add a GO STT readout if we're a SARH and not in STT
; 2513 : 			   if(ownship && g_bRealisticAvionics)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	$LN3@DrawTDMark
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN3@DrawTDMark

; 2514 : 			   {
; 2515 : 				   if(ownship->Sms && ownship->Sms->curWeapon && ownship->Sms->curWeapon->IsMissile() &&
; 2516 : 					   ((MissileClass *)ownship->Sms->GetCurrentWeapon())->GetSeekerType() == SensorClass::RadarHoming &&
; 2517 : 					   theRadar && !theRadar->IsSet(RadarDopplerClass::STTingTarget))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx+940], 0
	je	$LN3@DrawTDMark
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	??B?$VuBin@VSimWeaponClass@@@@QBE_NXZ	; VuBin<SimWeaponClass>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@DrawTDMark
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+940]
	add	ecx, 164				; 000000a4H
	call	??C?$VuBin@VSimWeaponClass@@@@QBEPAVSimWeaponClass@@XZ ; VuBin<SimWeaponClass>::operator->
	mov	DWORD PTR tv385[ebp], eax
	mov	ecx, DWORD PTR tv385[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv385[ebp]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	SHORT $LN3@DrawTDMark
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+940]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+940]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, eax
	call	?GetSeekerType@MissileClass@@QAEHXZ	; MissileClass::GetSeekerType
	cmp	eax, 6
	jne	SHORT $LN3@DrawTDMark
	cmp	DWORD PTR _theRadar$[ebp], 0
	je	SHORT $LN3@DrawTDMark
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _theRadar$[ebp]
	call	?IsSet@RadarDopplerClass@@QAEHH@Z	; RadarDopplerClass::IsSet
	test	eax, eax
	jne	SHORT $LN3@DrawTDMark

; 2518 : 				   {
; 2519 : 					   display->TextCenter(0.0F, -0.1F, "GO STT", 0);

	push	0
	push	OFFSET ??_C@_06LACKECLL@GO?5STT?$AA@
	push	ecx
	movss	xmm0, DWORD PTR __real@bdcccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+72]
	call	edx
$LN3@DrawTDMark:

; 2520 : 				   }
; 2521 : 			   }
; 2522 : 		   }
; 2523 : 	   }
; 2524 : 	   else

	jmp	$LN2@DrawTDMark
$LN13@DrawTDMark:

; 2525 : 	   {
; 2526 : 		   display->Line (-size, -size, -size, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2527 : 		   display->Line (-size, -size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2528 : 		   display->Line ( size, size, -size, size);

	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 2529 : 		   display->Line ( size, size, size, -size);

	movss	xmm0, DWORD PTR _size$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN2@DrawTDMark:

; 2530 : 	   }
; 2531 : 	   display->AdjustOriginInViewport(-xPos, -yPos);

	movss	xmm0, DWORD PTR _yPos$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2532 :    }
; 2533 :    else

	jmp	$LN1@DrawTDMark
$LN14@DrawTDMark:

; 2534 :    {
; 2535 :       mlSinCos (&trig, dRoll);

	push	ecx
	movss	xmm0, DWORD PTR _dRoll$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 2536 :       xPos = offset * trig.sin;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp]
	movss	DWORD PTR _xPos$[ebp], xmm0

; 2537 :       yPos = offset * trig.cos;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _trig$[ebp+4]
	movss	DWORD PTR _yPos$[ebp], xmm0

; 2538 :       display->Line (0.0f, 0.0f, xPos, yPos);

	push	ecx
	movss	xmm0, DWORD PTR _yPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2539 :       sprintf (tmpStr, "%.0f", (float)acos (cos (az) * cos (el)) * RTD);

	push	ecx
	movss	xmm0, DWORD PTR _az$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv889[ebp]
	movss	xmm0, DWORD PTR tv889[ebp]
	push	ecx
	movss	xmm1, DWORD PTR _el$[ebp]
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv919[ebp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv895[ebp]
	movss	xmm0, DWORD PTR tv919[ebp]
	mulss	xmm0, DWORD PTR tv895[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?acos@@YAMM@Z				; acos
	add	esp, 4
	fstp	DWORD PTR tv900[ebp]
	movss	xmm0, DWORD PTR tv900[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04GHNNFJCK@?$CF?40f?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2540 :       ShiAssert (strlen(tmpStr) < sizeof(tmpStr));
; 2541 :       display->TextRight(-0.075F, display->TextHeight()*0.5F, tmpStr, 0);

	push	0
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+88]
	call	edx
	fstp	DWORD PTR tv909[ebp]
	movss	xmm0, DWORD PTR tv909[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bd99999a
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+60]
	call	edx
$LN1@DrawTDMark:

; 2542 :    }
; 2543 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DrawTDMarker@HudClass@@AAEXMMMM@Z ENDP			; HudClass::DrawTDMarker
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawDTOSSBox@HudClass@@AAEXXZ PROC			; HudClass::DrawDTOSSBox
; _this$ = ecx

; 2447 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2448 : 	if (targetData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$LN1@DrawDTOSSB

; 2449 : 	{
; 2450 : 		display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2451 : 			hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 2452 : 		
; 2453 : 		DrawTDMarker(targetData->az, targetData->el, targetData->droll, 0.03F );

	push	ecx
	movss	xmm0, DWORD PTR __real@3cf5c28f
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawTDMarker@HudClass@@AAEXMMMM@Z	; HudClass::DrawTDMarker

; 2454 : 		
; 2455 : 		display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 2456 : 			hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN1@DrawDTOSSB:

; 2457 : 	}
; 2458 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawDTOSSBox@HudClass@@AAEXXZ ENDP			; HudClass::DrawDTOSSBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawTDBox@HudClass@@AAEXXZ PROC			; HudClass::DrawTDBox
; _this$ = ecx

; 1471 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1472 : 	if (targetData)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$LN1@DrawTDBox

; 1473 : 	{
; 1474 : 		display->AdjustOriginInViewport (0.0F, (hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1475 : 			hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1476 : 		
; 1477 : 		DrawDesignateMarker( Square, targetData->az, targetData->el, targetData->droll );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	ecx
	movss	xmm0, DWORD PTR [edx+40]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawDesignateMarker@HudClass@@AAEXW4DesignateShape@1@MMM@Z ; HudClass::DrawDesignateMarker

; 1478 : 		
; 1479 : 		display->AdjustOriginInViewport (0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1480 : 			hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F));

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN1@DrawTDBox:

; 1481 : 	}
; 1482 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawTDBox@HudClass@@AAEXXZ ENDP			; HudClass::DrawTDBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_offset$ = -348						; size = 4
_delta$1 = -344						; size = 4
tv2122 = -340						; size = 4
tv3146 = -336						; size = 4
_angleDown$2 = -332					; size = 4
tv3153 = -328						; size = 4
tv3171 = -324						; size = 4
tv3165 = -320						; size = 4
tv3159 = -316						; size = 4
_xOffset$3 = -312					; size = 4
_yOffset$4 = -308					; size = 4
_yPos$5 = -304						; size = 4
_xPos$6 = -300						; size = 4
_dx$ = -296						; size = 4
_dy$ = -292						; size = 4
_angleFromCentre$7 = -288				; size = 4
_ghostRadius$ = -284					; size = 4
_tanAngleDown$8 = -280					; size = 4
_i$ = -276						; size = 4
_horizontalLevel$9 = -272				; size = 4
_drawGhostHorizon$ = -265				; size = 1
_a$ = -264						; size = 4
_this$ = -260						; size = 4
_ghostVert$10 = -256					; size = 96
_vert$ = -160						; size = 144
_tmpStr$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?DrawPitchLadder@HudClass@@AAEXXZ PROC			; HudClass::DrawPitchLadder
; _this$ = ecx

; 1632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1633 : 
; 1634 : 	//MI INS stuff
; 1635 : 	if(g_bRealisticAvionics && g_bINS){

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN33@DrawPitchL
	movzx	ecx, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	ecx, ecx
	je	SHORT $LN33@DrawPitchL

; 1636 : 		if (
; 1637 : 			ownship && 
; 1638 : 			ownship->INSState(AircraftClass::INS_PowerOff) ||
; 1639 : 			!ownship->INSState(AircraftClass::INS_HUD_STUFF)
; 1640 : 		){

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN31@DrawPitchL
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN32@DrawPitchL
$LN31@DrawPitchL:
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	jne	SHORT $LN33@DrawPitchL
$LN32@DrawPitchL:

; 1641 : 			return;

	jmp	$LN35@DrawPitchL
$LN33@DrawPitchL:

; 1642 : 		}
; 1643 : 	}
; 1644 : 	//MI not here in BUP reticle mode
; 1645 : 	if(g_bRealisticAvionics && WhichMode == 2 && FCC->GetSubMode() == FireControlComputer::MAN){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	SHORT $LN30@DrawPitchL
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5016], 2
	jne	SHORT $LN30@DrawPitchL
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN30@DrawPitchL

; 1646 : 		return;

	jmp	$LN35@DrawPitchL
$LN30@DrawPitchL:

; 1647 : 	}
; 1648 : 
; 1649 : 	char tmpStr[12];
; 1650 : 	float vert[18][2];
; 1651 : 	int i, a;
; 1652 : 	float dx, dy;
; 1653 : 	bool drawGhostHorizon = true;

	mov	BYTE PTR _drawGhostHorizon$[ebp], 1

; 1654 : 	//radius was originally calculated as 8.0F * degressForScreen, but that screws up
; 1655 : 	//for full-screen HUD. Fixed radius at value that seems to work well for 2D, 3D and
; 1656 : 	//fullscreen.
; 1657 : 	float ghostRadius = 0.88F;

	movss	xmm0, DWORD PTR __real@3f6147ae
	movss	DWORD PTR _ghostRadius$[ebp], xmm0

; 1658 : 
; 1659 : 	// Pitch ladder is centered about the boresight cross
; 1660 : 	display->AdjustOriginInViewport(
; 1661 : 		0.0F, 
; 1662 : 		hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F
; 1663 : 	);

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1664 : 
; 1665 : 
; 1666 :    dx = betaHudUnits;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4860]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1667 :    dy = -alphaHudUnits;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4856]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 1668 : 
; 1669 :    // Well, really it is centered on the flight path marker
; 1670 :    display->AdjustOriginInViewport (dx, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1671 : 
; 1672 :    // Rotate about nose marker
; 1673 : // display->AdjustRotationAboutOrigin(-cockpitFlightData.roll);
; 1674 :    display->AdjustRotationAboutOrigin(-ownship->GetMu());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+436]
	call	eax
	fstp	DWORD PTR tv2122[ebp]
	movss	xmm0, DWORD PTR tv2122[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1675 : 
; 1676 :    /*-------------------------*/
; 1677 :    /* elevation in tenths      */
; 1678 :    /*-------------------------*/
; 1679 :    a = FloatToInt32( cockpitFlightData.gamma * 10.0F * RTD );

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+32
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1680 :    float offset = cockpitFlightData.gamma * 10.0F * RTD - a;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+32
	mulss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR __real@42652ee1
	cvtsi2ss xmm1, DWORD PTR _a$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _offset$[ebp], xmm0

; 1681 :    i = a%50;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	DWORD PTR _i$[ebp], edx

; 1682 : 
; 1683 :    //MI Smaller pitchladder
; 1684 :    if(!g_bRealisticAvionics){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	$LN29@DrawPitchL

; 1685 : 	   vert[0][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 0.25F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3e800000
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1686 : 	   vert[1][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 0.35F;

	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3eb33333
	mov	edx, 8
	shl	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1687 : 	   vert[2][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 0.45F;

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3ee66666
	mov	eax, 8
	shl	eax, 1
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1688 : 	   vert[3][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 0.55F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f0ccccd
	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1689 : 	   vert[4][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 0.65F;

	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3f266666
	mov	edx, 8
	shl	edx, 2
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1690 : 	   vert[5][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 0.75F;

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f400000
	mov	eax, 8
	imul	eax, 5
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1691 : 	   vert[6][0] = vert[5][0];

	mov	eax, 8
	imul	eax, 5
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 8
	imul	eax, 6
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	imul	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1692 :    }
; 1693 :    else {

	jmp	$LN28@DrawPitchL
$LN29@DrawPitchL:

; 1694 : 	   vert[0][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 0.25F;

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3e800000
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1695 : 	   vert[1][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 0.35F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3eb33333
	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1696 : 	   vert[2][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 0.45F;

	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3ee66666
	mov	edx, 8
	shl	edx, 1
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1697 : 	   vert[3][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 0.55F;

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3f0ccccd
	mov	eax, 8
	imul	eax, 3
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1698 : 	   vert[4][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 0.65F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3f266666
	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1699 : 	   vert[5][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 0.75F;

	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3f400000
	mov	edx, 8
	imul	edx, 5
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1700 : 	   vert[6][0] = vert[5][0];

	mov	edx, 8
	imul	edx, 5
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, 8
	imul	edx, 6
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	imul	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax
$LN28@DrawPitchL:

; 1701 :    }
; 1702 : 
; 1703 :    vert[7][0] = -vert[0][0];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1704 :    vert[8][0] = -vert[1][0];

	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	shl	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1705 :    vert[9][0] = -vert[2][0];

	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 9
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1706 :    vert[10][0] = -vert[3][0];

	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1707 :    vert[11][0] = -vert[4][0];

	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 11					; 0000000bH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1708 :    vert[12][0] = -vert[5][0];

	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1709 :    vert[13][0] = -vert[5][0];

	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 13					; 0000000dH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1710 : 
; 1711 :    //MI Smaller pitchladder
; 1712 :    if(!g_bRealisticAvionics){

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN27@DrawPitchL

; 1713 : 	   vert[14][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 1.00F;

	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 8
	imul	eax, 14					; 0000000eH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1714 : 	   vert[15][0] = -vert[14][0];

	mov	eax, 8
	imul	eax, 14					; 0000000eH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 8
	imul	eax, 15					; 0000000fH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1715 : 	   vert[16][0] = hudWinWidth[PITCH_LADDER_WINDOW] * 2.00F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@40000000
	mov	ecx, 8
	shl	ecx, 4
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1716 : 	   vert[17][0] = -vert[16][0];

	mov	ecx, 8
	shl	ecx, 4
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1717 :    }
; 1718 :    else { 

	jmp	$LN24@DrawPitchL
$LN27@DrawPitchL:

; 1719 : 	   vert[14][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 1.00F;

	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 8
	imul	edx, 14					; 0000000eH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1720 : 	   vert[15][0] = -vert[14][0];

	mov	edx, 8
	imul	edx, 14					; 0000000eH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1721 : 
; 1722 : 	   	//HUD_Fixes.pdf #1 - +if enabled, extend horizon line out beyond edges 
; 1723 : 	    //of pitch ladder, otherwise do old stuff. Smeg, 14-Oct-2003.
; 1724 : 		if( g_bHUDFix == true){

	movzx	edx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	edx, 1
	jne	SHORT $LN25@DrawPitchL

; 1725 : 			vert[16][0] = 1.00F;

	mov	eax, 8
	shl	eax, 4
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+edx], xmm0

; 1726 : 			vert[17][0] = -1.00F;

	mov	eax, 8
	imul	eax, 17					; 00000011H
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+edx], xmm0

; 1727 : 		}
; 1728 : 		else {

	jmp	SHORT $LN24@DrawPitchL
$LN25@DrawPitchL:

; 1729 : 			vert[16][0] = (hudWinWidth[PITCH_LADDER_WINDOW] - PitchLadderDiff) * 1.00F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	subss	xmm0, DWORD PTR _PitchLadderDiff
	mulss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 8
	shl	ecx, 4
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1730 : 			vert[17][0] = -vert[16][0];

	mov	ecx, 8
	shl	ecx, 4
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	ecx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
$LN24@DrawPitchL:

; 1731 : 		}
; 1732 : 	}
; 1733 : 
; 1734 : 	if(!g_bNewPitchLadder){

	movzx	ecx, BYTE PTR ?g_bNewPitchLadder@@3_NA	; g_bNewPitchLadder
	test	ecx, ecx
	jne	SHORT $LN23@DrawPitchL

; 1735 : 		vert[0][1] = -(0.1F * i + 20.0F) * degreesForScreen;

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR __real@41a00000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+4840]
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 1736 : 	}
; 1737 : 	else{

	jmp	SHORT $LN22@DrawPitchL
$LN23@DrawPitchL:

; 1738 : 	   vert[0][1] = -(0.1F * (i + offset) + 20.0F) * degreesForScreen;

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	addss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR __real@41a00000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+4840]
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
$LN22@DrawPitchL:

; 1739 : 	}
; 1740 : 
; 1741 : 	a = (a-i)/10 - 20; // starting number

	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	sub	eax, 20					; 00000014H
	mov	DWORD PTR _a$[ebp], eax

; 1742 : 
; 1743 : 	// JPO - draw the 2.5 degree line when gear is down and locked.
; 1744 : 	if (
; 1745 : 		((AircraftClass*)ownship)->af->gearPos > 0.5F && 
; 1746 : 		(a < -2) && ((a + 50) > -2)
; 1747 : 	){ // JPO we surround the -2.5 line

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN21@DrawPitchL
	cmp	DWORD PTR _a$[ebp], -2			; fffffffeH
	jge	$LN21@DrawPitchL
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 50					; 00000032H
	cmp	edx, -2					; fffffffeH
	jle	$LN21@DrawPitchL

; 1748 : 		float delta = (float)a - -2.5f;

	cvtsi2ss xmm0, DWORD PTR _a$[ebp]
	subss	xmm0, DWORD PTR __real@c0200000
	movss	DWORD PTR _delta$1[ebp], xmm0

; 1749 : 		vert[0][1] = vert[0][1] - delta * degreesForScreen; // adjust

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _delta$1[ebp]
	mulss	xmm0, DWORD PTR [eax+4840]
	movss	xmm1, DWORD PTR [ecx+edx]
	subss	xmm1, xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1750 : 
; 1751 : 		vert[1][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 0
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1752 : 		vert[2][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	shl	eax, 1
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1753 : 		vert[3][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 3
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1754 : 		vert[4][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 2
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1755 : 		vert[5][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 5
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1756 : 		vert[7][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 7
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1757 : 		vert[8][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 3
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1758 : 		vert[9][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 9
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1759 : 		vert[10][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 10					; 0000000aH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1760 : 		vert[11][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 11					; 0000000bH
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1761 : 		vert[12][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 12					; 0000000cH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1762 : 		vert[14][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 14					; 0000000eH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1763 : 		vert[15][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 15					; 0000000fH
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1764 : 
; 1765 : 		display->Line(vert[0][0], vert[0][1], vert[1][0], vert[1][1]);

	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1766 : 		display->Line(vert[2][0], vert[2][1], vert[3][0], vert[3][1]);

	mov	eax, 8
	imul	eax, 3
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 3
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 1
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 1
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1767 : 		display->Line(vert[4][0], vert[4][1], vert[5][0], vert[5][1]);

	mov	eax, 8
	imul	eax, 5
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 5
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 2
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 2
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1768 : 		display->Line(vert[7][0], vert[7][1], vert[8][0], vert[8][1]);

	mov	eax, 8
	shl	eax, 3
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	shl	eax, 3
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 7
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 7
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1769 : 		display->Line(vert[9][0], vert[9][1], vert[10][0], vert[10][1]);

	mov	eax, 8
	imul	eax, 10					; 0000000aH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 10					; 0000000aH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 9
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 9
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1770 : 		display->Line(vert[11][0], vert[11][1], vert[12][0], vert[12][1]);

	mov	eax, 8
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 11					; 0000000bH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 11					; 0000000bH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1771 : 
; 1772 : 		// reset it
; 1773 : 		vert[0][1] = -(0.1F * i + 20.0F) * degreesForScreen;

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR __real@41a00000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [eax+4840]
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
$LN21@DrawPitchL:

; 1774 : 	}
; 1775 : 
; 1776 : 	//By default, set things up so the ghost horizon will be drawn, unless decided otherwise.
; 1777 : 	drawGhostHorizon = true;

	mov	BYTE PTR _drawGhostHorizon$[ebp], 1

; 1778 : 
; 1779 : 	for (i=0; i<30; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@DrawPitchL
$LN19@DrawPitchL:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN20@DrawPitchL:
	cmp	DWORD PTR _i$[ebp], 30			; 0000001eH
	jge	$LN18@DrawPitchL

; 1780 :       if ((a >= -90) && (a <= 90)){

	cmp	DWORD PTR _a$[ebp], -90			; ffffffa6H
	jl	$LN4@DrawPitchL
	cmp	DWORD PTR _a$[ebp], 90			; 0000005aH
	jg	$LN4@DrawPitchL

; 1781 : 		  //MI no - is drawn on the real pitchladder
; 1782 : 		  if(!g_bRealisticAvionics){

	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	jne	SHORT $LN16@DrawPitchL

; 1783 : 			  sprintf (tmpStr , "%d", a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1784 : 		  }
; 1785 : 		  else {

	jmp	SHORT $LN13@DrawPitchL
$LN16@DrawPitchL:

; 1786 : 			  if(a > 0){

	cmp	DWORD PTR _a$[ebp], 0
	jle	SHORT $LN14@DrawPitchL

; 1787 : 				  sprintf (tmpStr , "%d", a);

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1788 : 			  }
; 1789 : 			  else {

	jmp	SHORT $LN13@DrawPitchL
$LN14@DrawPitchL:

; 1790 : 				  sprintf(tmpStr, "%d", -a);

	mov	ecx, DWORD PTR _a$[ebp]
	neg	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN13@DrawPitchL:

; 1791 : 			  }
; 1792 : 		  }
; 1793 :          ShiAssert (strlen(tmpStr) < 12);
; 1794 : 
; 1795 : 		 //If pitch latter for lines above horizon...
; 1796 : 		 if ( a > 0 ) {

	cmp	DWORD PTR _a$[ebp], 0
	jle	$LN12@DrawPitchL

; 1797 : 			 vert[5][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 5
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1798 : 			 vert[6][1] = vert[0][1] - hudWinWidth[PITCH_LADDER_WINDOW] * 0.1F;

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	xmm1, DWORD PTR [eax+ecx]
	subss	xmm1, xmm0
	mov	eax, 8
	imul	eax, 6
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm1

; 1799 : 			 vert[7][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 7
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1800 : 			 vert[12][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1801 : 			 vert[13][1] = vert[6][1];

	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 13					; 0000000dH
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1802 : 			 vert[14][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 14					; 0000000eH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1803 : 			 vert[15][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1804 : 
; 1805 : 			 //If the HUD fix is applied, then we may have buggered up the x position of the 
; 1806 : 			 //two tick marks by moving them to the inside.. Restore it here to make sure.
; 1807 : 			 vert[6][0] = vert[5][0];

	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, 8
	imul	ecx, 6
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	imul	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1808 : 			 vert[13][0] = vert[12][0];

	mov	eax, 8
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 8
	imul	eax, 13					; 0000000dH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	imul	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1809 : 			 
; 1810 : 			 display->Line(vert[0][0], vert[0][1], vert[5][0], vert[5][1]);

	mov	edx, 8
	imul	edx, 5
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 5
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1811 : 			 display->Line(vert[5][0], vert[5][1], vert[6][0], vert[6][1]);

	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1812 : 			 display->Line(vert[7][0], vert[7][1], vert[12][0], vert[12][1]);

	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1813 : 			 display->Line(vert[12][0], vert[12][1], vert[13][0], vert[13][1]);

	mov	ecx, 8
	imul	ecx, 13					; 0000000dH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 13					; 0000000dH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1814 : 			 display->TextCenterVertical (vert[14][0], vert[14][1], tmpStr, 0);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 14					; 0000000eH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 14					; 0000000eH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 1815 : 			 display->TextCenterVertical (vert[15][0], vert[15][1], tmpStr, 0);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+76]
	call	eax
	jmp	$LN4@DrawPitchL
$LN12@DrawPitchL:

; 1816 : 		 }  
; 1817 : 		 //Else if below horizon...
; 1818 : 		 else if ( a < 0 ) 

	cmp	DWORD PTR _a$[ebp], 0
	jge	$LN10@DrawPitchL

; 1819 : 		 {
; 1820 : 			float horizontalLevel = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _horizontalLevel$9[ebp], xmm0

; 1821 : 			 //HUD fix #3b: pitch ladder bars below horizon should be slanted downwards,
; 1822 : 			 //from 8.3 degrees down for the -5deg line, to 45deg down on the -90deg line.
; 1823 : 			 //Smeg, 15-Oct-2003
; 1824 : 			 if((g_bHUDFix == true) && (g_bRealisticAvionics))

	movzx	ecx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	ecx, 1
	jne	$LN9@DrawPitchL
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN9@DrawPitchL

; 1825 : 			 {
; 1826 : 				//Determine angle down from horizontal.
; 1827 : 				float angleDown = (-a - 5) * ((45.0F - 8.3F)/85.0F) + 8.3F;

	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	sub	eax, 5
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3edd1044
	addss	xmm0, DWORD PTR __real@4104cccd
	movss	DWORD PTR _angleDown$2[ebp], xmm0

; 1828 : 				float tanAngleDown = tanf(angleDown * (2 * static_cast<float>(DPI)/360.0F));

	movss	xmm0, DWORD PTR _angleDown$2[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_tanf
	add	esp, 4
	fstp	DWORD PTR _tanAngleDown$8[ebp]

; 1829 : 				horizontalLevel = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _horizontalLevel$9[ebp], xmm0

; 1830 : 
; 1831 : 				//Correct vertical position of each vertice...Right side.
; 1832 : 				vert[0][1] = horizontalLevel - (tanAngleDown * vert[0][0]);

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _tanAngleDown$8[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	movss	xmm1, DWORD PTR _horizontalLevel$9[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1833 : 				vert[1][1] = horizontalLevel - (tanAngleDown * vert[1][0]);

	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _tanAngleDown$8[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	movss	xmm1, DWORD PTR _horizontalLevel$9[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1834 : 				vert[2][1] = horizontalLevel - (tanAngleDown * vert[2][0]);

	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _tanAngleDown$8[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	movss	xmm1, DWORD PTR _horizontalLevel$9[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1835 : 				vert[3][1] = horizontalLevel - (tanAngleDown * vert[3][0]);

	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _tanAngleDown$8[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	movss	xmm1, DWORD PTR _horizontalLevel$9[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1836 : 				vert[4][1] = horizontalLevel - (tanAngleDown * vert[4][0]);

	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _tanAngleDown$8[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	movss	xmm1, DWORD PTR _horizontalLevel$9[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1837 : 				vert[5][1] = horizontalLevel - (tanAngleDown * vert[5][0]);

	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	movss	xmm0, DWORD PTR _tanAngleDown$8[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	movss	xmm1, DWORD PTR _horizontalLevel$9[ebp]
	subss	xmm1, xmm0
	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm1

; 1838 : 				//vert[6][1] = vert[5][1] + hudWinWidth[PITCH_LADDER_WINDOW] * 0.1F; moved to inside.
; 1839 : 
; 1840 : 				//Left side is a copy of the right side.
; 1841 : 				vert[7][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 7
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1842 : 				vert[8][1] = vert[1][1];

	mov	eax, 8
	shl	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	shl	eax, 3
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1843 : 				vert[9][1] = vert[2][1];

	mov	edx, 8
	shl	edx, 1
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 9
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1844 : 				vert[10][1] = vert[3][1];

	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1845 : 				vert[11][1] = vert[4][1];

	mov	eax, 8
	shl	eax, 2
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 11					; 0000000bH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1846 : 				vert[12][1] = vert[5][1];

	mov	edx, 8
	imul	edx, 5
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1847 : 				//vert[13][1] = vert[6][1]; moved to inside.
; 1848 : 
; 1849 : 				//Text stays level with start of mark.
; 1850 : 				vert[14][1] = horizontalLevel;

	mov	ecx, 8
	imul	ecx, 14					; 0000000eH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _horizontalLevel$9[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 1851 : 				vert[15][1] = horizontalLevel;

	mov	ecx, 8
	imul	ecx, 15					; 0000000fH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _horizontalLevel$9[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 1852 : 
; 1853 : 				//Now, sort out the vertical ticks. On the -ve ladder, they should be on the 
; 1854 : 				//inside of the lines, not the outside, and should be 3/4 the size of the originals.
; 1855 : 				vert[6][1]  = vert[0][1] + hudWinWidth[PITCH_LADDER_WINDOW] * 0.075F;

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@3d99999a
	addss	xmm0, DWORD PTR [edx+eax]
	mov	edx, 8
	imul	edx, 6
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 1856 : 				vert[13][1] = vert[6][1];

	mov	edx, 8
	imul	edx, 6
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 13					; 0000000dH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1857 : 				vert[6][0]  = vert[0][0];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	mov	ecx, 8
	imul	ecx, 6
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	imul	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1858 : 				vert[13][0] = vert[7][0];

	mov	eax, 8
	imul	eax, 7
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	mov	eax, 8
	imul	eax, 13					; 0000000dH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	imul	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1859 : 
; 1860 : 			 }
; 1861 : 			 else //Do old horizontal lines as hud fixes are either off or not realistic Avionics.

	jmp	$LN8@DrawPitchL
$LN9@DrawPitchL:

; 1862 : 			 {
; 1863 : 				vert[1][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	shl	edx, 0
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1864 : 				vert[2][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 1
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1865 : 				vert[3][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 3
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1866 : 				vert[4][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	shl	edx, 2
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1867 : 				vert[5][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 5
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1868 : 				vert[6][1] = vert[0][1] + hudWinWidth[PITCH_LADDER_WINDOW] * 0.1F;

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 1869 : 				vert[7][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 7
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1870 : 				vert[8][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	shl	eax, 3
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1871 : 				vert[9][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 9
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1872 : 				vert[10][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1873 : 				vert[11][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 11					; 0000000bH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1874 : 				vert[12][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1875 : 				vert[13][1] = vert[6][1];

	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 13					; 0000000dH
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1876 : 				vert[14][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	imul	eax, 14					; 0000000eH
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1877 : 				vert[15][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax
$LN8@DrawPitchL:

; 1878 : 
; 1879 : 			 }
; 1880 : 
; 1881 : 			 //Draw Right side ladder line - 3 dashes.
; 1882 : 			 display->Line(vert[0][0], vert[0][1], vert[1][0], vert[1][1]);

	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1883 : 			 display->Line(vert[2][0], vert[2][1], vert[3][0], vert[3][1]);

	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1884 : 			 display->Line(vert[4][0], vert[4][1], vert[5][0], vert[5][1]);

	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1885 : 
; 1886 : 			 //Left-side line.
; 1887 : 			 display->Line(vert[7][0], vert[7][1], vert[8][0], vert[8][1]);

	mov	ecx, 8
	shl	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 3
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1888 : 			 display->Line(vert[9][0], vert[9][1], vert[10][0], vert[10][1]);

	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 9
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 9
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1889 : 			 display->Line(vert[11][0], vert[11][1], vert[12][0], vert[12][1]);

	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 11					; 0000000bH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 11					; 0000000bH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1890 : 
; 1891 : 			 //Now do vertical ticks. Positioning is different for -ve pitch ladder
; 1892 : 			 //if we're applying the HUD fix.
; 1893 : 			 if((g_bHUDFix == true) && (a < 0) && (g_bRealisticAvionics))

	movzx	ecx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	ecx, 1
	jne	$LN7@DrawPitchL
	cmp	DWORD PTR _a$[ebp], 0
	jge	$LN7@DrawPitchL
	movzx	edx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	edx, edx
	je	$LN7@DrawPitchL

; 1894 : 			 {
; 1895 : 				display->Line(vert[0][0], vert[0][1], vert[6][0], vert[6][1]);

	mov	eax, 8
	imul	eax, 6
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 6
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1896 : 				display->Line(vert[7][0], vert[7][1], vert[13][0], vert[13][1]);

	mov	eax, 8
	imul	eax, 13					; 0000000dH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 13					; 0000000dH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 7
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 7
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1897 : 
; 1898 : 				//Return vertice[0][1] back to its original value prior to messing with the sloped
; 1899 : 				//lines. Otherwise, we'll end up accumulating a bunch of errors that will eventually 
; 1900 : 				//result in the horizon line being drawn in the wrong place as everything uses this
; 1901 : 				//as the vertical reference, apparently.
; 1902 : 				vert[0][1] = horizontalLevel;

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _horizontalLevel$9[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 1903 : 			 }
; 1904 : 			 else

	jmp	$LN6@DrawPitchL
$LN7@DrawPitchL:

; 1905 : 			 {
; 1906 : 				display->Line(vert[5][0], vert[5][1], vert[6][0], vert[6][1]);

	mov	eax, 8
	imul	eax, 6
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 6
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 5
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 5
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1907 : 				display->Line(vert[12][0], vert[12][1], vert[13][0], vert[13][1]);

	mov	eax, 8
	imul	eax, 13					; 0000000dH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 13					; 0000000dH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 8
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	imul	edx, 0
	push	ecx
	movss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN6@DrawPitchL:

; 1908 : 			 }
; 1909 : 
; 1910 : 			 display->TextCenterVertical (vert[14][0], vert[14][1], tmpStr, 0);

	push	0
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	mov	ecx, 8
	imul	ecx, 14					; 0000000eH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 14					; 0000000eH
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 1911 : 			 display->TextCenterVertical (vert[15][0], vert[15][1], tmpStr, 0);

	push	0
	lea	ecx, DWORD PTR _tmpStr$[ebp]
	push	ecx
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 15					; 0000000fH
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 1912 : 		 } 
; 1913 : 		 
; 1914 : 		 //Otherwise, must be horizon line.
; 1915 : 		 else 

	jmp	$LN4@DrawPitchL
$LN10@DrawPitchL:

; 1916 : 		 {
; 1917 : 			 ShiAssert( a == 0 );
; 1918 : 		 	 vert[7][1] = vert[0][1];

	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 7
	lea	ecx, DWORD PTR _vert$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx

; 1919 : 			 vert[16][1] = vert[0][1];

	mov	eax, 8
	imul	eax, 0
	lea	ecx, DWORD PTR _vert$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 8
	shl	eax, 4
	lea	eax, DWORD PTR _vert$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 1920 : 			 vert[17][1] = vert[0][1];

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 8
	imul	edx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+edx]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax

; 1921 : 
; 1922 : 			 //If HUD fixes are applied, only draw horizon line if it's outside the imaginary circle
; 1923 : 			 //that's used for drawing ghost horizon line.
; 1924 : 			 drawGhostHorizon = CheckGhostHorizon(ghostRadius, dx, dy, vert[16][0], vert[16][1], vert[17][0], vert[17][1]);

	mov	ecx, 8
	imul	ecx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 4
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 4
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ghostRadius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckGhostHorizon@HudClass@@AAE_NMMMMMMM@Z ; HudClass::CheckGhostHorizon
	mov	BYTE PTR _drawGhostHorizon$[ebp], al

; 1925 : 
; 1926 : 			 if ( drawGhostHorizon == false )

	movzx	ecx, BYTE PTR _drawGhostHorizon$[ebp]
	test	ecx, ecx
	jne	$LN4@DrawPitchL

; 1927 : 			 {
; 1928 : 				display->Line(vert[0][0], vert[0][1], vert[16][0], vert[16][1]);

	mov	edx, 8
	shl	edx, 4
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	shl	edx, 4
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	imul	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1929 : 				display->Line(vert[7][0], vert[7][1], vert[17][0], vert[17][1]);

	mov	ecx, 8
	imul	ecx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 17					; 00000011H
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN4@DrawPitchL:

; 1930 : 			 }
; 1931 : 		 }
; 1932 :       }
; 1933 : 
; 1934 :       a += 5;

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 5
	mov	DWORD PTR _a$[ebp], ecx

; 1935 : 
; 1936 :       vert[0][1] +=  5.0F * degreesForScreen;

	mov	edx, 8
	imul	edx, 0
	lea	eax, DWORD PTR _vert$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [edx+4840]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _vert$[ebp+ecx]
	movss	DWORD PTR [edx+eax], xmm0

; 1937 :    }

	jmp	$LN19@DrawPitchL
$LN18@DrawPitchL:

; 1938 : 
; 1939 : 	//HUD fix #3a - ghost horizon when normal horizon line not drawn. Smeghead, 14-Oct-2003.
; 1940 : 	if(drawGhostHorizon == true)

	movzx	eax, BYTE PTR _drawGhostHorizon$[ebp]
	cmp	eax, 1
	jne	$LN3@DrawPitchL

; 1941 : 	{
; 1942 : 		//How much has the origin been shifted for the display? It was shifted once vertically 
; 1943 : 		//for the boresight, then once more for the FPM.
; 1944 : 		float xOffset = dx;

	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR _xOffset$3[ebp], xmm0

; 1945 : 		float yOffset = hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F + dy;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	addss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _yOffset$4[ebp], xmm0

; 1946 : 
; 1947 : 		//Vertices for horizon dotted line - 3 dashes either side of centre.
; 1948 : 		float ghostVert[12][2] = { 
; 1949 : 			{-1.000F, 0.000F}, {-0.833F, 0.000F},

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _ghostVert$10[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@bf553f7d
	movss	DWORD PTR _ghostVert$10[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+12], xmm0

; 1950 : 			{-0.667F, 0.000F}, {-0.500F, 0.000F},

	movss	xmm0, DWORD PTR __real@bf2ac083
	movss	DWORD PTR _ghostVert$10[ebp+16], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+20], xmm0
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR _ghostVert$10[ebp+24], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+28], xmm0

; 1951 : 			{-0.333F, 0.000F}, {-0.166F, 0.000F},

	movss	xmm0, DWORD PTR __real@beaa7efa
	movss	DWORD PTR _ghostVert$10[ebp+32], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+36], xmm0
	movss	xmm0, DWORD PTR __real@be29fbe7
	movss	DWORD PTR _ghostVert$10[ebp+40], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+44], xmm0

; 1952 : 			{0.166F, 0.000F}, {0.333F, 0.000F},

	movss	xmm0, DWORD PTR __real@3e29fbe7
	movss	DWORD PTR _ghostVert$10[ebp+48], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+52], xmm0
	movss	xmm0, DWORD PTR __real@3eaa7efa
	movss	DWORD PTR _ghostVert$10[ebp+56], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+60], xmm0

; 1953 : 			{0.500F, 0.000F}, {0.667F, 0.000F},

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _ghostVert$10[ebp+64], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+68], xmm0
	movss	xmm0, DWORD PTR __real@3f2ac083
	movss	DWORD PTR _ghostVert$10[ebp+72], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+76], xmm0

; 1954 : 			{0.833F, 0.000F}, {1.000F, 0.000F},

	movss	xmm0, DWORD PTR __real@3f553f7d
	movss	DWORD PTR _ghostVert$10[ebp+80], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+84], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ghostVert$10[ebp+88], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _ghostVert$10[ebp+92], xmm0

; 1955 : 		};
; 1956 : 		//Ghost horizon is situated perpendicular to 8-degree circle that's centred on the HUD.
; 1957 : 		//Presumably we could do this by setting the origin to a point on that circle, then 
; 1958 : 		//rotating it to the aircraft's angle of bank. Since the angle of bank is already set 
; 1959 : 		//above when we start drawing the pitch ladder, we don't need to care about that.
; 1960 : 		float angleFromCentre = -ownship->GetMu();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+436]
	call	edx
	fstp	DWORD PTR tv3146[ebp]
	movss	xmm0, DWORD PTR tv3146[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _angleFromCentre$7[ebp], xmm0

; 1961 : 
; 1962 : 		float xPos;
; 1963 : 		float yPos;
; 1964 : 
; 1965 : 		//Ghost horizon needs to be drawn opposite way round if nose is above horizon.
; 1966 : 		if (cockpitFlightData.pitch > 0){

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+36
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@DrawPitchL

; 1967 : 			yPos = -cos(angleFromCentre) * ghostRadius;

	push	ecx
	movss	xmm0, DWORD PTR _angleFromCentre$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv3153[ebp]
	movss	xmm0, DWORD PTR tv3153[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _ghostRadius$[ebp]
	movss	DWORD PTR _yPos$5[ebp], xmm0

; 1968 : 			xPos = -sin(angleFromCentre) * ghostRadius;

	push	ecx
	movss	xmm0, DWORD PTR _angleFromCentre$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv3159[ebp]
	movss	xmm0, DWORD PTR tv3159[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _ghostRadius$[ebp]
	movss	DWORD PTR _xPos$6[ebp], xmm0

; 1969 : 		}
; 1970 : 		else {

	jmp	SHORT $LN1@DrawPitchL
$LN2@DrawPitchL:

; 1971 : 			yPos = cos(angleFromCentre) * ghostRadius;

	push	ecx
	movss	xmm0, DWORD PTR _angleFromCentre$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR tv3165[ebp]
	movss	xmm0, DWORD PTR tv3165[ebp]
	mulss	xmm0, DWORD PTR _ghostRadius$[ebp]
	movss	DWORD PTR _yPos$5[ebp], xmm0

; 1972 : 			xPos = sin(angleFromCentre) * ghostRadius;

	push	ecx
	movss	xmm0, DWORD PTR _angleFromCentre$7[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR tv3171[ebp]
	movss	xmm0, DWORD PTR tv3171[ebp]
	mulss	xmm0, DWORD PTR _ghostRadius$[ebp]
	movss	DWORD PTR _xPos$6[ebp], xmm0
$LN1@DrawPitchL:

; 1973 : 		}
; 1974 : 
; 1975 : 		//Shift origin to position on circle.
; 1976 : 		display->AdjustOriginInViewport(xPos - xOffset, yPos - yOffset);

	movss	xmm0, DWORD PTR _yPos$5[ebp]
	subss	xmm0, DWORD PTR _yOffset$4[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$6[ebp]
	subss	xmm0, DWORD PTR _xOffset$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1977 : 
; 1978 : 		//Draw dashed line - 3 dashes on each side.
; 1979 : 		display->Line(ghostVert[0][0], ghostVert[0][1], ghostVert[1][0], ghostVert[1][1]);

	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 0
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 0
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1980 : 		display->Line(ghostVert[2][0], ghostVert[2][1], ghostVert[3][0], ghostVert[3][1]);

	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 3
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 1
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1981 : 		display->Line(ghostVert[4][0], ghostVert[4][1], ghostVert[5][0], ghostVert[5][1]);

	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 5
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 2
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1982 : 
; 1983 : 		display->Line(ghostVert[6][0],  ghostVert[6][1],  ghostVert[7][0],  ghostVert[7][1]);

	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 7
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 6
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1984 : 		display->Line(ghostVert[8][0],  ghostVert[8][1],  ghostVert[9][0],  ghostVert[9][1]);

	mov	ecx, 8
	imul	ecx, 9
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 9
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 3
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	shl	ecx, 3
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1985 : 		display->Line(ghostVert[10][0], ghostVert[10][1], ghostVert[11][0], ghostVert[11][1]);

	mov	ecx, 8
	imul	ecx, 11					; 0000000bH
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 11					; 0000000bH
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 8
	imul	ecx, 10					; 0000000aH
	lea	edx, DWORD PTR _ghostVert$10[ebp+ecx]
	mov	eax, 4
	imul	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1986 : 		
; 1987 : 		//Done drawing. Put the origin back the way it was
; 1988 : 		display->AdjustOriginInViewport(-(xPos - xOffset), -(yPos - yOffset));

	movss	xmm0, DWORD PTR _yPos$5[ebp]
	subss	xmm0, DWORD PTR _yOffset$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xPos$6[ebp]
	subss	xmm0, DWORD PTR _xOffset$3[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN3@DrawPitchL:

; 1989 : 	} //End of HUD fix.
; 1990 :         
; 1991 : 	display->ZeroRotationAboutOrigin();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 1992 : 	display->AdjustOriginInViewport (-dx, -dy);

	movss	xmm0, DWORD PTR _dy$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1993 : 
; 1994 : 	display->AdjustOriginInViewport(
; 1995 : 		0.0F, -(hudWinY[BORESIGHT_CROSS_WINDOW] + hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F)
; 1996 : 	);

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport
$LN35@DrawPitchL:

; 1997 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawPitchLadder@HudClass@@AAEXXZ ENDP			; HudClass::DrawPitchLadder
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_dx$ = -24						; size = 4
_dy$ = -20						; size = 4
_x1$ = -16						; size = 4
_x2$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawHorizonLine@HudClass@@AAEXXZ PROC			; HudClass::DrawHorizonLine
; _this$ = ecx

; 1605 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1606 : 	float dx, dy;
; 1607 : 	float x1, x2, y;
; 1608 : 	
; 1609 : 	// Pitch ladder is centered about the flight path marker
; 1610 : 	dx = betaHudUnits;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4860]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1611 : 	dy = -alphaHudUnits;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+4856]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 1612 : 	display->AdjustOriginInViewport (dx, hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1613 : 		hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F + dy);

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, 4
	imul	eax, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[edx]
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1614 : 
; 1615 : 	// AdjustRotationAboutOrigin about nose marker
; 1616 : 	display->AdjustRotationAboutOrigin(-cockpitFlightData.roll);

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+40
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	call	?AdjustRotationAboutOrigin@VirtualDisplay@@QAEXM@Z ; VirtualDisplay::AdjustRotationAboutOrigin

; 1617 : 	x1	= hudWinWidth[PITCH_LADDER_WINDOW] * 0.25F;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[eax]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _x1$[ebp], xmm0

; 1618 : 	x2	= hudWinWidth[PITCH_LADDER_WINDOW] * 2.00F;

	mov	ecx, 4
	imul	ecx, 43					; 0000002bH
	movss	xmm0, DWORD PTR ?hudWinWidth@@3PAMA[ecx]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _x2$[ebp], xmm0

; 1619 : 	y	= -cockpitFlightData.gamma * RTD * degreesForScreen;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+32
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm0, DWORD PTR [edx+4840]
	movss	DWORD PTR _y$[ebp], xmm0

; 1620 : 
; 1621 : 	display->Line( x1, y,  x2, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1622 : 	display->Line(-x1, y, -x2, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x2$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1623 : 
; 1624 : 	// Put the display offsets back the way they were
; 1625 : 	display->ZeroRotationAboutOrigin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?ZeroRotationAboutOrigin@VirtualDisplay@@QAEXXZ ; VirtualDisplay::ZeroRotationAboutOrigin

; 1626 : 	display->AdjustOriginInViewport (-dx, -hudWinY[BORESIGHT_CROSS_WINDOW] -
; 1627 : 		hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F - dy);

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm1, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, xmm1
	subss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	?AdjustOriginInViewport@VirtualDisplay@@QAEXMM@Z ; VirtualDisplay::AdjustOriginInViewport

; 1628 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawHorizonLine@HudClass@@AAEXXZ ENDP			; HudClass::DrawHorizonLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_crossSize$1 = -24					; size = 4
_constraint$2 = -20					; size = 4
_aoaOffset$3 = -16					; size = 4
_dx$ = -12						; size = 4
_dy$ = -8						; size = 4
_this$ = -4						; size = 4
?DrawFPM@HudClass@@AAEXXZ PROC				; HudClass::DrawFPM
; _this$ = ecx

; 1351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1352 : 	//MI not here in BUP reticle mode
; 1353 : 	if(g_bRealisticAvionics && WhichMode == 2 && FCC->GetSubMode() == FireControlComputer::MAN)

	movzx	eax, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	eax, eax
	je	SHORT $LN21@DrawFPM
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+5016], 2
	jne	SHORT $LN21@DrawFPM
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?GetSubMode@FireControlComputer@@QAE?AW4FCCSubMode@1@XZ ; FireControlComputer::GetSubMode
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN21@DrawFPM

; 1354 : 		return;

	jmp	$LN22@DrawFPM
$LN21@DrawFPM:

; 1355 : 
; 1356 : 	float dx, dy;
; 1357 : 
; 1358 : 	ShiAssert(ownship);
; 1359 : 
; 1360 :    dx = betaHudUnits;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+4860]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1361 :    dy = hudWinY[BORESIGHT_CROSS_WINDOW] +
; 1362 :       hudWinHeight[BORESIGHT_CROSS_WINDOW] * 0.5F -
; 1363 :       alphaHudUnits;

	mov	ecx, 4
	imul	ecx, 44					; 0000002cH
	mov	edx, 4
	imul	edx, 44					; 0000002cH
	movss	xmm0, DWORD PTR ?hudWinHeight@@3PAMA[edx]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR ?hudWinY@@3PAMA[ecx]
	mov	eax, DWORD PTR _this$[ebp]
	subss	xmm0, DWORD PTR [eax+4856]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1364 : 
; 1365 :    //MI -- Make the FPM a bit bigger....why did they make it so complicated??
; 1366 : 	if(!g_bRealisticAvionics)

	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	jne	$LN20@DrawFPM

; 1367 : 	{
; 1368 :    display->Line (-0.0075F + dx, 0.015F + dy, 0.0075F + dx, 0.015F + dy);

	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1369 :    display->Line (0.0075F + dx, 0.015F + dy, 0.015F + dx, 0.0075F + dy);

	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1370 :    display->Line (0.015F + dx, 0.0075F + dy, 0.015F + dx, -0.0075F + dy);

	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1371 :    display->Line (0.015F + dx, -0.0075F + dy, 0.0075F + dx, -0.015F + dy);

	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1372 :    display->Line (0.0075F + dx, -0.015F + dy, -0.0075F + dx, -0.015F + dy);

	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1373 :    display->Line (-0.0075F + dx, -0.015F + dy, -0.015F + dx, -0.0075F + dy);

	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1374 :    display->Line (-0.015F + dx, -0.0075F + dy, -0.015F + dx, 0.0075F + dy);

	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1375 :    display->Line (-0.015F + dx, 0.0075F + dy, -0.0075F + dx, 0.015F + dy);

	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bbf5c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3bf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1376 :    display->Line (0.015F + dx, dy, 0.05F + dx, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3d4ccccd
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1377 :    display->Line (-0.015F + dx, dy, -0.05F + dx, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bd4ccccd
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@bc75c28f
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1378 :    display->Line (dx, 0.015F + dy, dx, 0.05F + dy);

	movss	xmm0, DWORD PTR __real@3d4ccccd
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3c75c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1379 : 	}
; 1380 : 	else

	jmp	$LN8@DrawFPM
$LN20@DrawFPM:

; 1381 : 	{
; 1382 : 		//HUD_Fixes.pdf #2 - restrain FPM within bounds of HUD. Smeg, 14-Oct-2003.
; 1383 : 		if( g_bHUDFix == true)

	movzx	ecx, BYTE PTR ?g_bHUDFix@@3_NA		; g_bHUDFix
	cmp	ecx, 1
	jne	$LN11@DrawFPM

; 1384 : 		{
; 1385 : 			float constraint = 1.00F - Linelenght - Tadpolesize;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _Linelenght
	subss	xmm0, DWORD PTR _Tadpolesize
	movss	DWORD PTR _constraint$2[ebp], xmm0

; 1386 : 			//bool fpmConstrained = false; TJL I need this
; 1387 : 			fpmConstrained = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5144], 0

; 1388 : 			if(dx < -constraint) //Left edge

	movss	xmm0, DWORD PTR _constraint$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _dx$[ebp]
	jbe	SHORT $LN17@DrawFPM

; 1389 : 			{
; 1390 : 				dx = -constraint;

	movss	xmm0, DWORD PTR _constraint$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dx$[ebp], xmm0

; 1391 : 				fpmConstrained = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5144], 1
	jmp	SHORT $LN15@DrawFPM
$LN17@DrawFPM:

; 1392 : 			}
; 1393 : 			else if (dx > constraint) //Right

	movss	xmm0, DWORD PTR _dx$[ebp]
	comiss	xmm0, DWORD PTR _constraint$2[ebp]
	jbe	SHORT $LN15@DrawFPM

; 1394 : 			{
; 1395 : 				dx = constraint;

	movss	xmm0, DWORD PTR _constraint$2[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 1396 : 				fpmConstrained = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5144], 1
$LN15@DrawFPM:

; 1397 : 			}
; 1398 : 			if (dy < -constraint) //Bottom

	movss	xmm0, DWORD PTR _constraint$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _dy$[ebp]
	jbe	SHORT $LN14@DrawFPM

; 1399 : 			{
; 1400 : 				dy = -constraint;

	movss	xmm0, DWORD PTR _constraint$2[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dy$[ebp], xmm0

; 1401 : 				fpmConstrained = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5144], 1
	jmp	SHORT $LN12@DrawFPM
$LN14@DrawFPM:

; 1402 : 			}
; 1403 : 			else if (dy > constraint) //Top

	movss	xmm0, DWORD PTR _dy$[ebp]
	comiss	xmm0, DWORD PTR _constraint$2[ebp]
	jbe	SHORT $LN12@DrawFPM

; 1404 : 			{
; 1405 : 				dy = constraint;

	movss	xmm0, DWORD PTR _constraint$2[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 1406 : 				fpmConstrained = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5144], 1
$LN12@DrawFPM:

; 1407 : 			}
; 1408 : 
; 1409 : 			//If FPM was constrained to HUD, then draw a cross on top of it to warn that it's unreliable.
; 1410 : 			if(fpmConstrained == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+5144]
	cmp	edx, 1
	jne	$LN11@DrawFPM

; 1411 : 			{
; 1412 : 				float crossSize = Tadpolesize; //mirv sez that the cross covers only the FPM circle.

	movss	xmm0, DWORD PTR _Tadpolesize
	movss	DWORD PTR _crossSize$1[ebp], xmm0

; 1413 : 				display->Line (-crossSize + dx, -crossSize + dy, crossSize + dx, crossSize + dy);

	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1414 : 				display->Line (-crossSize + dx, crossSize + dy, crossSize + dx, -crossSize + dy);

	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _crossSize$1[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN11@DrawFPM:

; 1415 : 			}
; 1416 : 		} //End of HUD fix.
; 1417 : 
; 1418 : 		//MI
; 1419 : 		if(g_bINS && g_bRealisticAvionics)

	movzx	eax, BYTE PTR ?g_bINS@@3_NA		; g_bINS
	test	eax, eax
	je	$LN10@DrawFPM
	movzx	ecx, BYTE PTR ?g_bRealisticAvionics@@3_NA ; g_bRealisticAvionics
	test	ecx, ecx
	je	$LN10@DrawFPM

; 1420 : 		{
; 1421 : 			if(ownship->INSState(AircraftClass::INS_HUD_FPM))

	push	512					; 00000200H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?INSState@AircraftClass@@QAEHW4INSAlignFlags@1@@Z ; AircraftClass::INSState
	test	eax, eax
	je	$LN9@DrawFPM

; 1422 : 			{
; 1423 : 				display->Circle(dx,dy,Tadpolesize);

	push	ecx
	movss	xmm0, DWORD PTR _Tadpolesize
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+48]
	call	edx

; 1424 : 				display->Line(dx + Tadpolesize, dy, dx + Tadpolesize + Linelenght, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	addss	xmm0, DWORD PTR _Linelenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1425 : 				display->Line(dx - Tadpolesize, dy, dx - Tadpolesize - Linelenght, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	subss	xmm0, DWORD PTR _Tadpolesize
	subss	xmm0, DWORD PTR _Linelenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	subss	xmm0, DWORD PTR _Tadpolesize
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1426 : 				display->Line(dx, dy + Tadpolesize, dx, dy + Tadpolesize + Linelenght - 0.025f);

	movss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	addss	xmm0, DWORD PTR _Linelenght
	subss	xmm0, DWORD PTR __real@3ccccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN9@DrawFPM:

; 1427 : 			}
; 1428 : 		}
; 1429 : 		else

	jmp	$LN8@DrawFPM
$LN10@DrawFPM:

; 1430 : 		{
; 1431 : 			display->Circle(dx,dy,Tadpolesize);

	push	ecx
	movss	xmm0, DWORD PTR _Tadpolesize
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+48]
	call	edx

; 1432 : 			display->Line(dx + Tadpolesize, dy, dx + Tadpolesize + Linelenght, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	addss	xmm0, DWORD PTR _Linelenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1433 : 			display->Line(dx - Tadpolesize, dy, dx - Tadpolesize - Linelenght, dy);

	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	subss	xmm0, DWORD PTR _Tadpolesize
	subss	xmm0, DWORD PTR _Linelenght
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dx$[ebp]
	subss	xmm0, DWORD PTR _Tadpolesize
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 1434 : 			display->Line(dx, dy + Tadpolesize, dx, dy + Tadpolesize + Linelenght - 0.025f);

	movss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	addss	xmm0, DWORD PTR _Linelenght
	subss	xmm0, DWORD PTR __real@3ccccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _dy$[ebp]
	addss	xmm0, DWORD PTR _Tadpolesize
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dx$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+32]
	call	edx
$LN8@DrawFPM:

; 1435 : 		}
; 1436 : 
; 1437 : 
; 1438 : 	}
; 1439 : 
; 1440 :    // AOA Bracket 11 - 15 Degrees
; 1441 :    // Check for gear down
; 1442 : 	//TJL 03/08/04
; 1443 :    if (((AircraftClass*)ownship)->af->gearPos > 0.5F)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1552]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN7@DrawFPM

; 1444 :    {
; 1445 : 	   float aoaOffset = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _aoaOffset$3[ebp], xmm0

; 1446 : 	   if (ownship->af->GetTypeAC() == 8 || ownship->af->GetTypeAC() == 9 || ownship->af->GetTypeAC() == 10)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 8
	je	SHORT $LN5@DrawFPM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 9
	je	SHORT $LN5@DrawFPM
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [edx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN6@DrawFPM
$LN5@DrawFPM:

; 1447 : 	   {
; 1448 : 			aoaOffset = cockpitFlightData.alpha - 8.0F;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+24
	subss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _aoaOffset$3[ebp], xmm0
	jmp	SHORT $LN1@DrawFPM
$LN6@DrawFPM:

; 1449 : 	   }
; 1450 : 	   else if (ownship->af->GetTypeAC() == 6 || ownship->af->GetTypeAC() == 7)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [ecx+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 6
	je	SHORT $LN2@DrawFPM
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetTypeAC@AirframeClass@@QAEHXZ	; AirframeClass::GetTypeAC
	cmp	eax, 7
	jne	SHORT $LN3@DrawFPM
$LN2@DrawFPM:

; 1451 : 	   {
; 1452 : 			aoaOffset = cockpitFlightData.alpha -15.0F;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+24
	subss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _aoaOffset$3[ebp], xmm0

; 1453 : 	   }
; 1454 : 	   else

	jmp	SHORT $LN1@DrawFPM
$LN3@DrawFPM:

; 1455 : 	   {
; 1456 : 			aoaOffset = cockpitFlightData.alpha - 13.0F;

	movss	xmm0, DWORD PTR ?cockpitFlightData@@3VFlightData@@A+24
	subss	xmm0, DWORD PTR __real@41500000
	movss	DWORD PTR _aoaOffset$3[ebp], xmm0
$LN1@DrawFPM:

; 1457 : 	   }
; 1458 : 
; 1459 :       //aoaOffset = min ( max (aoaOffset, -2.0F), 2.0F) / 2.0F;
; 1460 : 	  aoaOffset = aoaOffset / 2.0F;

	movss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _aoaOffset$3[ebp], xmm0

; 1461 :       display->Line (-0.15F + dx, -0.12F + 0.12F * aoaOffset + dy,
; 1462 :          -0.15F + dx, 0.12F + 0.12F * aoaOffset + dy);

	movss	xmm0, DWORD PTR __real@3df5c28f
	mulss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	addss	xmm0, DWORD PTR __real@3df5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@be19999a
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3df5c28f
	mulss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	addss	xmm0, DWORD PTR __real@bdf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@be19999a
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1463 :       display->Line (-0.15F + dx, -0.12F + 0.12F * aoaOffset + dy,
; 1464 :          -0.13F + dx,-0.12F + 0.12F * aoaOffset + dy);

	movss	xmm0, DWORD PTR __real@3df5c28f
	mulss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	addss	xmm0, DWORD PTR __real@bdf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@be051eb8
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3df5c28f
	mulss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	addss	xmm0, DWORD PTR __real@bdf5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@be19999a
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 1465 :       display->Line (-0.15F + dx,  0.12F + 0.12F * aoaOffset + dy,
; 1466 :          -0.13F + dx, 0.12F + 0.12F * aoaOffset + dy);

	movss	xmm0, DWORD PTR __real@3df5c28f
	mulss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	addss	xmm0, DWORD PTR __real@3df5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@be051eb8
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@3df5c28f
	mulss	xmm0, DWORD PTR _aoaOffset$3[ebp]
	addss	xmm0, DWORD PTR __real@3df5c28f
	addss	xmm0, DWORD PTR _dy$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@be19999a
	addss	xmm0, DWORD PTR _dx$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN7@DrawFPM:
$LN22@DrawFPM:

; 1467 :    }
; 1468 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawFPM@HudClass@@AAEXXZ ENDP				; HudClass::DrawFPM
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\hud.h
;	COMDAT ?IsSet@HudDataType@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@HudDataType@@QAEHH@Z PROC			; HudDataType::IsSet, COMDAT
; _this$ = ecx

; 70   : 	int		IsSet (int testFlag)	{ return (flags & testFlag ? TRUE : FALSE); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@HudDataType@@QAEHH@Z ENDP			; HudDataType::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\displays\hud.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0HudDataType@@QAE@XZ PROC				; HudDataType::HudDataType
; _this$ = ecx

; 2116 : HudDataType::HudDataType(void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2117 : 	tgtAz = tgtEl = tgtAta = tgtDroll = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+12], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+8], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax], xmm0

; 2118 : 	tgtId = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 2119 : 	flags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 2120 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0HudDataType@@QAE@XZ ENDP				; HudDataType::HudDataType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\context.h
;	COMDAT ?CurrentForegroundColor@ContextMPR@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CurrentForegroundColor@ContextMPR@@QAEHXZ PROC		; ContextMPR::CurrentForegroundColor, COMDAT
; _this$ = ecx

; 708  : 	int CurrentForegroundColor(void) {return m_colFG_Raw;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?CurrentForegroundColor@ContextMPR@@QAEHXZ ENDP		; ContextMPR::CurrentForegroundColor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GDrawableClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDrawableClass@@UAEPAXI@Z PROC			; DrawableClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DrawableClass@@UAE@XZ		; DrawableClass::~DrawableClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDrawableClass@@UAEPAXI@Z ENDP			; DrawableClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?PushButton@DrawableClass@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?PushButton@DrawableClass@@UAEXHH@Z PROC		; DrawableClass::PushButton, COMDAT
; _this$ = ecx

; 152  :       virtual void PushButton (int, int)	{};								// Override to get button messages in subclasses

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	8
?PushButton@DrawableClass@@UAEXHH@Z ENDP		; DrawableClass::PushButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?IsSOI@DrawableClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?IsSOI@DrawableClass@@QAEHXZ PROC			; DrawableClass::IsSOI, COMDAT
; _this$ = ecx

; 141  :       int IsSOI (void) {return (drawFlags & SOI ? TRUE : FALSE);};

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN3@IsSOI
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSOI
$LN3@IsSOI:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSOI:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSOI@DrawableClass@@QAEHXZ ENDP			; DrawableClass::IsSOI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ PROC ; DrawableClass::GetDisplay, COMDAT
; _this$ = ecx

; 139  :       virtual VirtualDisplay* GetDisplay (void)	{return privateDisplay;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplay@DrawableClass@@UAEPAVVirtualDisplay@@XZ ENDP ; DrawableClass::GetDisplay
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z PROC	; DrawableClass::DisplayInit, COMDAT
; _this$ = ecx

; 137  :       virtual void DisplayInit (ImageBuffer*)	{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?DisplayInit@DrawableClass@@UAEXPAVImageBuffer@@@Z ENDP	; DrawableClass::DisplayInit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z PROC	; DrawableClass::Display, COMDAT
; _this$ = ecx

; 136  :       virtual void Display(VirtualDisplay*)		{ ShiWarning( "No Display!" ); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?Display@DrawableClass@@UAEXPAVVirtualDisplay@@@Z ENDP	; DrawableClass::Display
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ??1DrawableClass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DrawableClass@@UAE@XZ PROC				; DrawableClass::~DrawableClass, COMDAT
; _this$ = ecx

; 132  :       virtual ~DrawableClass (void)				{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DrawableClass@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DrawableClass@@UAE@XZ ENDP				; DrawableClass::~DrawableClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\drawable.h
;	COMDAT ??0DrawableClass@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DrawableClass@@IAE@XZ PROC				; DrawableClass::DrawableClass, COMDAT
; _this$ = ecx

; 126  :       DrawableClass(void) {privateDisplay = display = NULL; viewPoint = NULL; drawFlags = 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DrawableClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DrawableClass@@IAE@XZ ENDP				; DrawableClass::DrawableClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Roll@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Roll@VuEntity@@QBEMXZ PROC				; VuEntity::Roll, COMDAT
; _this$ = ecx

; 166  : 	SM_SCALAR Roll() const { return orient_.roll_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	mov	esp, ebp
	pop	ebp
	ret	0
?Roll@VuEntity@@QBEMXZ ENDP				; VuEntity::Roll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Pitch@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pitch@VuEntity@@QBEMXZ PROC				; VuEntity::Pitch, COMDAT
; _this$ = ecx

; 165  : 	SM_SCALAR Pitch() const { return orient_.pitch_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	esp, ebp
	pop	ebp
	ret	0
?Pitch@VuEntity@@QBEMXZ ENDP				; VuEntity::Pitch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?tan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?tan@@YAMM@Z PROC					; tan, COMDAT

; 543  :         {return (tanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_tanf
	add	esp, 4
	pop	ebp
	ret	0
?tan@@YAMM@Z ENDP					; tan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?acos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?acos@@YAMM@Z PROC					; acos, COMDAT

; 501  :         {return (acosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_acosf
	add	esp, 4
	pop	ebp
	ret	0
?acos@@YAMM@Z ENDP					; acos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 400  :         {return ((float)acos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_acosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
